 (function () { const Version = '7.7.1'; const templates = []; let namespace = 'LW'; if (window[namespace] && window[namespace].Version) { if (window[namespace].Version === Version) { return; } else if (window[namespace].Version !== Version) { namespace += Version; } else { let suffix = 2; while (window[namespace]) { namespace += suffix.toString(); suffix++; } } } const isEdge = navigator.userAgent.indexOf('Edge') > -1 && navigator.appVersion.indexOf('Edge') > -1; if (!document.elementsFromPoint) { document.elementsFromPoint = document.msElementsFromPoint; } function Import(urls, async) { let loadedScriptsLength = 0; const loadScript = function (url, baseUrl) { return new Promise(resolve => { const script = document.createElement('script'); script.src = url; script.onload = resolve; for (let j = 0; j < document.head.children.length; j++) { const child = document.head.children[j]; if (child.src && child.src.toString().indexOf(baseUrl) >= 0) { resolve(); return; } } document.head.appendChild(script); }); } return new Promise(resolve => { const urlBase = Utilities.Core.getScriptLocation(); const syncLoadScripts = function (index) { if (!urls[index]) { return; } const url = urlBase + '/' + urls[index]; loadScript(url, urls[index]).then(function () { loadedScriptsLength++; if (loadedScriptsLength === urls.length) { resolve(); } syncLoadScripts(index + 1) }); } if (async) { for (let i = 0; i < urls.length; i++) { const url = urlBase + '/' + urls[i]; loadScript(url, urls[i]).then(function () { loadedScriptsLength++; if (loadedScriptsLength === urls.length) { resolve(); } }); } } else { syncLoadScripts(0); } }) } /** This is a class with utility methods for determing the type of a value. */ class Types { /** * Determines whether a value is Boolean. * @param {Object}. * @return {Boolean}. */ static isBoolean(value) { return typeof value === 'boolean'; } /** * Determines whether a value is Function. * @param {Object}. * @return {Boolean}. */ static isFunction(value) { return !!(value && value.constructor && value.call && value.apply); } /** * Determines whether a value is Array. * @param {Object}. * @return {Boolean}. */ static isArray(value) { return Array.isArray(value); } /** * Determines whether a value is Object. * @param {Object}. * @return {Boolean}. */ static isObject(value) { const that = this; return (value && (typeof value === 'object' || that.isFunction(value))) || false; } /** * Determines whether a value is Date. * @param {Object}. * @return {Boolean}. */ static isDate(value) { return value instanceof Date; } /** * Determines whether a value is String. * @param {Object}. * @return {Boolean}. */ static isString(value) { return typeof value === 'string'; } /** * Determines whether a value is Number. * @param {Object}. * @return {Boolean}. */ static isNumber(value) { return typeof value === 'number'; } /** * Determines the type of an object. * @param {Object}. * @return {String} The value's type or undefined, if the type is unknown. */ static getType(value) { const that = this; const types = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'Object']; const type = types.find(type => { if (that['is' + type](value)) { return type; } }); return type ? type.toLowerCase() : undefined; } } class Ripple { static animate(element, left, top, callback) { const target = element; if (!target || target instanceof HTMLElement === false) { return; } if (target.getElementsByClassName('lw-ripple').length === 0) { const span = document.createElement('span'); span.classList.add('lw-ripple'); span.setAttribute('role', 'presentation'); let canAppendRipple = true; let firstElementChild = null; if (window[namespace].EnableShadowDOM && target.enableShadowDOM && target.isInShadowDOM !== true) { for (let i = 0; i < target.shadowRoot.host.shadowRoot.children.length; i++) { if (target.shadowRoot.host.shadowRoot.children[i].tagName.toLowerCase() === 'link') { continue; } firstElementChild = target.shadowRoot.host.shadowRoot.children[i]; } if (target.shadowRoot.host.shadowRoot.querySelector('.lw-ripple')) { canAppendRipple = false; } } else { firstElementChild = target.firstElementChild; } if (canAppendRipple) { if (firstElementChild && !firstElementChild.noRipple && firstElementChild.offsetHeight > 0) { firstElementChild.appendChild(span); } else { target.appendChild(span); } } } let ripple = null; if (window[namespace].EnableShadowDOM && target.shadowRoot) { ripple = target.shadowRoot.host.shadowRoot.querySelector('.lw-ripple'); } else { ripple = target.getElementsByClassName('lw-ripple')[0]; } if (!ripple) { return; } ripple.innerHTML = ''; ripple.classList.remove('lw-animate'); ripple.style.height = ripple.style.width = Math.max(target.offsetHeight, target.offsetWidth) + 'px'; const parentStyle = window.getComputedStyle(ripple.parentElement), borderLeftWidth = parseInt(parentStyle.borderLeftWidth) || 0, borderTopWidth = parseInt(parentStyle.borderTopWidth) || 0, rect = target.getBoundingClientRect(), x = left - (rect.left + window.pageXOffset) - ripple.offsetWidth / 2 - borderLeftWidth, y = top - (rect.top + window.pageYOffset) - ripple.offsetHeight / 2 - borderTopWidth; ripple.style.left = x + 'px'; ripple.style.top = y + 'px'; ripple.classList.add('lw-animate'); //Remove the ripple element when animation is over ripple.addEventListener('animationend', function handler() { if (ripple.parentElement) { ripple.parentElement.removeChild(ripple); } if (callback) { callback(); } ripple.removeEventListener('animationend', handler); ripple.removeEventListener('animationcancel', handler); }); //Remove the ripple element if the animation is canceled. Just in case ripple.addEventListener('animationcancel', function handler() { if (ripple.parentElement) { ripple.parentElement.removeChild(ripple); } if (callback) { callback(); } ripple.removeEventListener('animationcancel', handler); ripple.removeEventListener('animationend', handler); }); } } class Easings { static easeInQuad(t, b, c, d) { return c * (t /= d) * t + b; } static easeOutQuad(t, b, c, d) { return -c * (t /= d) * (t - 2) + b; } static easeInOutQuad(t, b, c, d) { if ((t /= d / 2) < 1) { return c / 2 * t * t + b; } return -c / 2 * ((--t) * (t - 2) - 1) + b; } static easeInCubic(t, b, c, d) { return c * (t /= d) * t * t + b; } static easeOutCubic(t, b, c, d) { return c * ((t = t / d - 1) * t * t + 1) + b; } static easeInOutCubic(t, b, c, d) { if ((t /= d / 2) < 1) { return c / 2 * t * t * t + b; } return c / 2 * ((t -= 2) * t * t + 2) + b; } static easeInQuart(t, b, c, d) { return c * (t /= d) * t * t * t + b; } static easeOutQuart(t, b, c, d) { return -c * ((t = t / d - 1) * t * t * t - 1) + b; } static easeInOutQuart(t, b, c, d) { if ((t /= d / 2) < 1) { return c / 2 * t * t * t * t + b; } return -c / 2 * ((t -= 2) * t * t * t - 2) + b; } static easeInQuint(t, b, c, d) { return c * (t /= d) * t * t * t * t + b; } static easeOutQuint(t, b, c, d) { return c * ((t = t / d - 1) * t * t * t * t + 1) + b; } static easeInOutQuint(t, b, c, d) { if ((t /= d / 2) < 1) { return c / 2 * t * t * t * t * t + b; } return c / 2 * ((t -= 2) * t * t * t * t + 2) + b; } static easeInSine(t, b, c, d) { return -c * Math.cos(t / d * (Math.PI / 2)) + c + b; } static easeOutSine(t, b, c, d) { return c * Math.sin(t / d * (Math.PI / 2)) + b; } static easeInOutSine(t, b, c, d) { return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b; } static easeInExpo(t, b, c, d) { return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b; } static easeOutExpo(t, b, c, d) { return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b; } static easeInOutExpo(t, b, c, d) { if (t === 0) { return b; } if (t === d) { return b + c; } if ((t /= d / 2) < 1) { return c / 2 * Math.pow(2, 10 * (t - 1)) + b; } return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b; } static easeInCirc(t, b, c, d) { return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b; } static easeOutCirc(t, b, c, d) { return c * Math.sqrt(1 - (t = t / d - 1) * t) + b; } static easeInOutCirc(t, b, c, d) { if ((t /= d / 2) < 1) { return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b; } return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b; } static easeInElastic(t, b, c, d) { let s = 1.70158; let p = 0; let a = c; if (t === 0) { return b; } if ((t /= d) === 1) { return b + c; } if (!p) { p = d * .3; } if (a < Math.abs(c)) { a = c; s = p / 4; } else { s = p / (2 * Math.PI) * Math.asin(c / a); } return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; } static easeOutElastic(t, b, c, d) { let s = 1.70158; let p = 0; let a = c; if (t === 0) { return b; } if ((t /= d) === 1) { return b + c; } if (!p) { p = d * .3; } if (a < Math.abs(c)) { a = c; s = p / 4; } else { s = p / (2 * Math.PI) * Math.asin(c / a); } return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b; } static easeInOutElastic(t, b, c, d) { let s = 1.70158; let p = 0; let a = c; if (t === 0) { return b; } if ((t /= d / 2) === 2) { return b + c; } if (!p) { p = d * (.3 * 1.5); } if (a < Math.abs(c)) { a = c; s = p / 4; } else { s = p / (2 * Math.PI) * Math.asin(c / a); } if (t < 1) { return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; } return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b; } static easeInBack(t, b, c, d, s) { if (s === undefined) { s = 1.70158; } return c * (t /= d) * t * ((s + 1) * t - s) + b; } static easeOutBack(t, b, c, d, s) { if (s === undefined) { s = 1.70158; } return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b; } static easeInOutBack(t, b, c, d, s) { if (s === undefined) { s = 1.70158; } if ((t /= d / 2) < 1) { return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; } return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b; } static easeInBounce(t, b, c, d) { return c - this.easeOutBounce(d - t, 0, c, d) + b; } static easeOutBounce(t, b, c, d) { if ((t /= d) < (1 / 2.75)) { return c * (7.5625 * t * t) + b; } else if (t < (2 / 2.75)) { return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b; } else if (t < (2.5 / 2.75)) { return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b; } else { return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b; } } static easeInOutBounce(t, b, c, d) { if (t < d / 2) { return this.easeInBounce(t * 2, 0, c, d) * .5 + b; } return this.easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b; } } /** This is a class with utility methods. */ class Core { static get isMobile() { const isMobile = /(iphone|ipod|ipad|android|iemobile|blackberry|bada)/.test(window.navigator.userAgent.toLowerCase()); return isMobile; } static get Browser() { let versionSearchString; const browser = function () { const data = [ { string: navigator.userAgent, subString: 'Edge', identity: 'Edge' }, { string: navigator.userAgent, subString: 'MSIE', identity: 'IE' }, { string: navigator.userAgent, subString: 'Trident', identity: 'IE' }, { string: navigator.userAgent, subString: 'Firefox', identity: 'Firefox' }, { string: navigator.userAgent, subString: 'Opera', identity: 'Opera' }, { string: navigator.userAgent, subString: 'OPR', identity: 'Opera' }, { string: navigator.userAgent, subString: 'Chrome', identity: 'Chrome' }, { string: navigator.userAgent, subString: 'Safari', identity: 'Safari' } ]; for (let i = 0; i < data.length; i++) { let dataString = data[i].string; versionSearchString = data[i].subString; if (dataString.indexOf(data[i].subString) !== -1) { return data[i].identity; } } return 'Other'; }; const version = function (dataString) { let index = dataString.indexOf(versionSearchString); if (index === -1) { return; } const rv = dataString.indexOf('rv:'); if (versionSearchString === 'Trident' && rv !== -1) { return parseFloat(dataString.substring(rv + 3)); } else { return parseFloat(dataString.substring(index + versionSearchString.length + 1)); } } let result = { }; result[browser()] = true; result.version = version(navigator.userAgent) || version(navigator.appVersion) || 'Unknown'; return result; } static toCamelCase(value) { return value.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); }); } static toDash(value) { return value.split(/(?=[A-Z])/).join('-').toLowerCase(); } static unescapeHTML(value) { let doc = new DOMParser().parseFromString(value, 'text/html'); return doc.documentElement.textContent; } static escapeHTML(value) { const entityMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;' }; return String(value).replace(/[&<>"'`=\/]/g, s => entityMap[s]); } static createGUID() { function part() { return Math.floor((1 + Math.random()) * 0x10000) .toString(16) .substring(1); } return part() + part() + '-' + part() + '-' + part() + '-' + part() + '-' + part() + part() + part(); } static getScriptLocation() { if (window[namespace].BaseUrl !== './') { return window[namespace].BaseUrl; } const location = (function () { if (document.currentScript) { let link = document.currentScript.src; let lastIndex = link.lastIndexOf('/'); link = link.substring(0, lastIndex); return link; } const error = new Error(); let startCharacter = '(', endCharacter = ')'; if (LW.Utilities.Core.Browser.Safari) { startCharacter = '@'; endCharacter = '\n'; } if (error.fileName) { return error.fileName.replace('/lw.element.js', ''); } let link = error.stack.split(startCharacter); link = link[1]; link = link.split(endCharacter)[0]; link = link.split(':') link.splice(-2, 2) link = link.join(':') return link.replace('/lw.element.js', ''); })(); return location; } static CSSVariablesSupport() { return window.CSS && window.CSS.supports && window.CSS.supports('(--fake-var: 0)'); } static assign(target, source) { const isObject = item => { return (item && typeof item === 'object' && !Array.isArray(item) && item !== null); } let output = Object.assign({}, target); if (isObject(target) && isObject(source)) { Object.keys(source).forEach(key => { if (isObject(source[key])) { if (!(key in target)) { Object.assign(output, { [key]: source[key] }); } else { output[key] = this.assign(target[key], source[key]); } } else { Object.assign(output, { [key]: source[key] }); } }); } return output; } static html(node, htmlString) { const that = this; let output = ''; let nodes = node.childNodes; if (htmlString) { const rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi; node.innerHTML = htmlString.replace(rxhtmlTag, '<$1></$2>'); return; } for (let i = 0, l = nodes.length, child; (i < l) && (child = nodes[i]); i++) { const miscElements = ['strong']; if (child instanceof HTMLElement || (child.tagName && miscElements.indexOf(child.tagName.toLowerCase()) >= 0)) { const tagName = child.tagName.toLowerCase(); const attrs = child.attributes; let nodeOutput = '<' + tagName; for (let j = 0, attr; (attr = attrs[j]); j++) { nodeOutput += ' ' + attr.name + '="' + attr.value.replace(/[&\u00A0"]/g, Utilities.Core.escapeHTML) + '"'; } nodeOutput += '>'; const voidElements = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']; if (voidElements[tagName]) { output += nodeOutput; } output = output + nodeOutput + that.html(child) + '</' + tagName + '>'; } else if (child.nodeType === 8) { continue; } else { output += child.textContent.replace(/[&\u00A0<>]/g, Utilities.Core.escapeHTML); } } return output; } } let styleObservedElements = []; class StyleObserver { static watch(element) { styleObservedElements.push(element); if (StyleObserver.interval) { clearInterval(StyleObserver.interval); } StyleObserver.interval = setInterval(function () { StyleObserver.observe(); }, 100); } static observeElement(element) { const that = element; let computedStyle = element._computedStyle || that.hasStyleObserver !== 'resize' ? document.defaultView.getComputedStyle(that, null) : { }; let canRaiseResize = true; let styleProperties = that.hasStyleObserver !== 'resize' ? ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth', 'display', 'visibility', 'font-size', 'font-family', 'font-style', 'font-weight', 'max-height', 'min-height', 'max-width', 'min-width', 'overflow', 'overflow-x', 'overflow-y'] : []; if (element.styleProperties) { styleProperties = styleProperties.concat(element.styleProperties); } if (element.observableStyleProperties) { styleProperties = element.observableStyleProperties; } if (!that._styleInfo) { that._styleInfo = []; for (let i = 0; i < styleProperties.length; i++) { const styleProperty = styleProperties[i]; const propertyValue = styleProperty.startsWith('--') ? computedStyle.getPropertyValue(styleProperty) : computedStyle[styleProperty]; that._styleInfo[styleProperty] = propertyValue; } return; } if (!element.isHidden) { if (computedStyle['display'] !== 'none') { if (element.offsetWidth === 0 || element.offsetHeight === 0) { element.isHidden = true; } } } if (element.isHidden) { element.visibilityChangedHandler(); if (!element.isHidden) { canRaiseResize = false; } else { return; } } let changedStyleProperties = []; for (let i = 0; i < styleProperties.length; i++) { const styleProperty = styleProperties[i]; const propertyValue = styleProperty.startsWith('--') ? computedStyle.getPropertyValue(styleProperty) : computedStyle[styleProperty]; if (that._styleInfo[styleProperty] !== propertyValue) { changedStyleProperties[styleProperty] = { oldValue: that._styleInfo[styleProperty], value: propertyValue }; changedStyleProperties.length++; } that._styleInfo[styleProperty] = propertyValue; } if (changedStyleProperties.length > 0) { that.$.fireEvent('styleChanged', { styleProperties: changedStyleProperties }, { bubbles: false, cancelable: true } ); if (changedStyleProperties['display'] && canRaiseResize) { that.$.fireEvent('resize', that, { bubbles: false, cancelable: true }); } } } static observe() { for (let i = 0; i < styleObservedElements.length; i++) { const that = styleObservedElements[i]; this.observeElement(that); } } static unwatch(element) { if (StyleObserver.interval) { clearInterval(StyleObserver.interval); } const elementIndex = styleObservedElements.indexOf(element); if (elementIndex !== -1) { styleObservedElements.splice(elementIndex, 1); } if (styleObservedElements.length > 0) { StyleObserver.interval = setInterval(function () { StyleObserver.observe(); }, 100); } } } let dataContextInfo = []; const data = []; const inputEventTypes = ['resize', 'down', 'up', 'move', 'tap', 'taphold', 'swipeleft', 'swiperight', 'swipetop', 'swipebottom']; /** This is a class which extends an element and adds custom input events to it. */ class InputEvents { constructor(target) { const that = this; that.target = target; that.$target = new Extend(target); that.$document = target.$document ? target.$document : new Extend(document); that.id = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase(); // that.target === document ? '' : that.target.id || that.target.getAttribute('lw-id'); let result = { handlers: {}, boundEventTypes: [], listen: that.listen.bind(that), unlisten: that.unlisten.bind(that) }; //The taphold delay. If this delay is passed then taphold event will be fired. that.tapHoldDelay = 750; //Defines the minimum swipe distance required by the plugin. that.swipeMin = 10; //Defines the maximum swipe distance. After it is passed the propagation of the event will be restored, therefore the scrolling will be available. that.swipeMax = 5000; //The swipe delay. After it is passed swipe event won't be fired. that.swipeDelay = 1000; //The taphold delay. If this delay is passed then taphold event will be fired. that.tapHoldDelay = 750; that.inputEventProperties = ['clientX', 'clientY', 'pageX', 'pageY', 'screenX', 'screenY']; inputEventTypes.forEach((eventType) => { result[eventType] = (handler) => { result.handlers[eventType] = handler; } that[eventType] = (event) => { if (!result.handlers[event.type]) { if ((event.type === 'mousemove' || event.type === 'pointermove' || event.type === 'touchmove') && result.handlers['move']) { const moveEvent = that.createEvent(event, 'move'); result.handlers['move'](moveEvent); } return true; } return result.handlers[event.type](event); }; }); that.listen(); that.handlers = result.handlers; return result; } listen(eventType) { const that = this; if (eventType === 'resize') { if (!that.target.resizeTrigger && that.target !== document && that.target !== window && that.target.hasResizeObserver !== false) { const container = document.createElement('div'); container.className = 'lw-resize-trigger-container'; container.innerHTML = '<div class="lw-resize-trigger-container">' + '<div class="lw-resize-trigger"></div>' + '</div>' + '<div class="lw-resize-trigger-container">' + '<div class="lw-resize-trigger-shrink"></div>' + '</div>'; container.setAttribute('aria-hidden', true); if (window[namespace].EnableShadowDOM && that.target.shadowRoot) { that.target.shadowRoot.appendChild(container); } else { that.target.appendChild(container); } that.target.resizeTrigger = container; const expand = container.childNodes[0]; const expandChild = expand.childNodes[0]; const shrink = container.childNodes[1]; const reset = function () { expandChild.style.width = '100000px'; expandChild.style.height = '100000px'; expand.scrollLeft = 100000; expand.scrollTop = 100000; shrink.scrollLeft = 100000; shrink.scrollTop = 100000; }; let dirty, requestAnimationFrameId, newWidth, newHeight; let lastWidth = that.target.offsetWidth; let lastHeight = that.target.offsetHeight; if (lastWidth === 0 || lastHeight === 0) { const resizeFunc = function () { reset(); that.target.removeEventListener('resize', resizeFunc); } that.target.addEventListener('resize', resizeFunc); reset(); } else { reset(); } that.target.resizeHandler = function () { if (!requestAnimationFrameId) { requestAnimationFrameId = requestAnimationFrame(function () { requestAnimationFrameId = 0; newWidth = that.target.offsetWidth; newHeight = that.target.offsetHeight; dirty = newWidth !== lastWidth || newHeight !== lastHeight; if (that.target.requiresLayout) { dirty = true; } if (!dirty) { return; } lastWidth = newWidth; lastHeight = newHeight; const resizeEvent = new CustomEvent('resize', { bubbles: false, cancelable: true }); that.resize(resizeEvent); that.target.requiresLayout = false; }); } reset(); }; expand.addEventListener('scroll', that.target.resizeHandler); shrink.addEventListener('scroll', that.target.resizeHandler); } } if (that.isListening) { return; } that.isListening = true; that.isPressed = false; that.isReleased = false; that.isInBounds = false; if (window.PointerEvent) { that.$target.listen('pointerdown.inputEvents' + that.id, that.pointerDown.bind(that)); that.$target.listen('pointerup.inputEvents' + that.id, that.pointerUp.bind(that)); that.$target.listen('pointermove.inputEvents' + that.id, that.pointerMove.bind(that)); that.$target.listen('pointercancel.inputEvents' + that.id, that.pointerCancel.bind(that)); } else { const hasTouch = 'ontouchstart' in window; if (hasTouch) { that.$target.listen('touchmove.inputEvents' + that.id, that.touchMove.bind(that)); that.$target.listen('touchstart.inputEvents' + that.id, that.touchStart.bind(that)); that.$target.listen('touchend.inputEvents' + that.id, that.touchEnd.bind(that)); that.$target.listen('touchcancel.inputEvents' + that.id, that.touchCancel.bind(that)); } that.$target.listen('mousedown.inputEvents' + that.id, that.mouseDown.bind(that)); that.$target.listen('mouseup.inputEvents' + that.id, that.mouseUp.bind(that)); that.$target.listen('mousemove.inputEvents' + that.id, that.mouseMove.bind(that)); that.$target.listen('mouseleave.inputEvents' + that.id, that.mouseLeave.bind(that)); } if (!that.target._handleDocumentUp) { that.target._handleDocumentUp = that.handleDocumentUp.bind(that); that.target._handleDocumentUpId = that.id; that.$document.listen('mouseup.inputEvents' + that.target._handleDocumentUpId, that.target._handleDocumentUp); } } unlisten(eventType) { const that = this; that.isListening = false; if (window.PointerEvent) { that.$target.unlisten('pointerdown.inputEvents' + that.id); that.$target.unlisten('pointerup.inputEvents' + that.id); that.$target.unlisten('pointermove.inputEvents' + that.id); that.$target.unlisten('pointercancel.inputEvents' + that.id); } else { const hasTouch = 'ontouchstart' in window; if (hasTouch) { that.$target.unlisten('touchstart.inputEvents' + that.id); that.$target.unlisten('touchmove.inputEvents' + that.id); that.$target.unlisten('touchend.inputEvents' + that.id); that.$target.unlisten('touchcancel.inputEvents' + that.id); } that.$target.unlisten('mousedown.inputEvents' + that.id); that.$target.unlisten('mouseup.inputEvents' + that.id); that.$target.unlisten('mousemove.inputEvents' + that.id); that.$target.unlisten('mouseleave.inputEvents' + that.id); } if (that.target._handleDocumentUp) { that.$document.unlisten('mouseup.inputEvents' + that.target._handleDocumentUpId, that.target._handleDocumentUp); delete that.target._handleDocumentUp; delete that.target._handleDocumentUpId; } if (eventType === 'resize' && that.target.resizeTrigger) { const container = that.target.resizeTrigger; const expand = container.childNodes[0]; const shrink = container.childNodes[1]; expand.removeEventListener('scroll', that.target.resizeHandler); shrink.removeEventListener('scroll', that.target.resizeHandler); that.target.resizeHandler = null; container.parentNode.removeChild(container); delete that.target.resizeTrigger; } } handleDocumentUp(event) { const that = this; that.isPressed = false; that.isReleased = false; that.resetSwipe(event); } createEvent(event, eventType) { const that = this; const touches = event.touches; const changedTouches = event.changedTouches; const touch = (touches && touches.length) ? touches[0] : ((changedTouches && changedTouches.length) ? changedTouches[0] : undefined); const customEvent = new CustomEvent(eventType, { bubbles: true, cancelable: true, composed: that.$target.element.getRootNode().host !== undefined }); customEvent.originalEvent = event; if (touch) { for (let j = 0; j < that.inputEventProperties.length; j++) { const key = that.inputEventProperties[j]; customEvent[key] = touch[key]; } return customEvent; } for (let key in event) { if (!(key in customEvent)) { customEvent[key] = event[key]; } } return customEvent; } fireTap(event) { const that = this; clearTimeout(this.tapHoldTimeout); if (!this.tapHoldFired && this.isInBounds) { const tap = that.createEvent(event, 'tap'); that.tap(tap); } } initTap(event) { const that = this; that.isInBounds = true; that.tapHoldFired = false; that.tapHoldTimeout = setTimeout(function () { if (that.isInBounds) { that.tapHoldFired = true; const taphold = that.createEvent(event, 'taphold'); that.taphold(taphold); } }, that.tapHoldDelay); } pointerDown(event) { const that = this; return that.handleDown(event); } mouseDown(event) { const that = this; if (that.isPressed || (that.touchStartTime && new Date() - that.touchStartTime < 500)) { return; } return that.handleDown(event); } touchStart(event) { const that = this; that.touchStartTime = new Date(); that.isTouchMoved = true; return that.handleDown(event); } mouseUp(event) { const that = this; if (that.isReleased || (that.touchEndTime && new Date() - that.touchEndTime < 500)) { return; } return that.handleUp(event); } handleDown(event) { const that = this; that.isReleased = false; that.isPressed = true; const down = that.createEvent(event, 'down'); if (that.handlers['tap'] || that.handlers['taphold']) { that.initTap(down); } if (that.handlers['swipeleft'] || that.handlers['swiperight'] || that.handlers['swipetop'] || that.handlers['swipebottom']) { that.initSwipe(down); } return that.down(down); } handleUp(event) { const that = this; that.isReleased = true; that.isPressed = false; const up = that.createEvent(event, 'up'); const result = that.up(up); if (that.handlers['tap'] || that.handlers['taphold']) { that.fireTap(up); } that.resetSwipe(up); return result; } handleMove(event) { const that = this; let eventResult = that.move(event); if (that.isPressed) { that._maxSwipeVerticalDistance = Math.max(that._maxSwipeVerticalDistance, Math.abs(that._startY - event.pageY)); that._maxSwipeHorizontalDistance = Math.max(that._maxSwipeHorizontalDistance, Math.abs(that._startX - event.pageX)); eventResult = that.handleSwipeEvents(event); } return eventResult; } touchEnd(event) { const that = this; that.touchEndTime = new Date(); return that.handleUp(event); } pointerUp(event) { const that = this; return that.handleUp(event); } pointerCancel(event) { const that = this; that.pointerUp(event); } touchCancel(event) { const that = this; that.touchEnd(event); } mouseLeave() { const that = this; that.isInBounds = false; } mouseMove(event) { const that = this; if (that.isTouchMoved) { return; } return that.handleMove(event); } pointerMove(event) { const that = this; return that.handleMove(event); } touchMove(event) { const that = this; const touches = event.touches; const changedTouches = event.changedTouches; const touch = (touches && touches.length) ? touches[0] : ((changedTouches && changedTouches.length) ? changedTouches[0] : undefined); for (let j = 0; j < that.inputEventProperties.length; j++) { const key = that.inputEventProperties[j]; if (event[key] === undefined) { event[key] = touch[key]; } } that.isTouchMoved = true; return that.handleMove(event); } handleSwipeEvents(event) { const that = this; let eventResult = true; if (that.handlers['swipetop'] || that.handlers['swipebottom']) { eventResult = this.handleVerticalSwipeEvents(event); } if (eventResult === false) { return eventResult; } if (that.handlers['swipeleft'] || that.handlers['swiperight']) { eventResult = this.handleHorizontalSwipeEvents(event); } return eventResult; } handleVerticalSwipeEvents(event) { let current, diff; current = event.pageY; diff = current - this._startY; return this.swiped(event, diff, 'vertical'); } handleHorizontalSwipeEvents(event) { let current, diff; current = event.pageX; diff = current - this._startX; return this.swiped(event, diff, 'horizontal'); } swiped(event, diff, direction) { const that = this; direction = direction || 0; if (Math.abs(diff) >= that.swipeMin && !that._swipeEvent && !that._swipeLocked) { let eventType = diff < 0 ? 'swipeleft' : 'swiperight'; if (direction === 'horizontal') { that._swipeEvent = that.createEvent(event, eventType); } else { eventType = diff < 0 ? 'swipetop' : 'swipebottom'; that._swipeEvent = that.createEvent(event, diff < 0 ? 'swipetop' : 'swipebottom') } if (that[eventType]) { that[eventType](this._swipeEvent); if (Math.abs(diff) <= this.swipeMax) { event.stopImmediatePropagation(); return false; } } } return true; } resetSwipe() { const that = this; that._swipeEvent = null; clearTimeout(this._swipeTimeout); } initSwipe(event) { const that = this; that._maxSwipeVerticalDistance = 0; that._maxSwipeHorizontalDistance = 0; that._startX = event.pageX; that._startY = event.pageY; that._swipeLocked = false; that._swipeEvent = null; that._swipeTimeout = setTimeout(function () { that._swipeLocked = true; }, that.swipeDelay); } } class Scroll { get scrollWidth() { const that = this; if (that.horizontalScrollBar) { return that.horizontalScrollBar.max; } return -1; } set scrollWidth(value) { const that = this; if (value < 0) { value = 0; } if (that.horizontalScrollBar) { that.horizontalScrollBar.max = value; } } get scrollHeight() { const that = this; if (that.verticalScrollBar) { return that.verticalScrollBar.max; } return -1; } set scrollHeight(value) { const that = this; if (value < 0) { value = 0; } if (that.verticalScrollBar) { that.verticalScrollBar.max = value; } } get scrollLeft() { const that = this; if (that.horizontalScrollBar) { return that.horizontalScrollBar.value; } return -1; } set scrollLeft(value) { const that = this; if (value < 0) { value = 0; } if (that.horizontalScrollBar) { that.horizontalScrollBar.value = value; } } get scrollTop() { const that = this; if (that.verticalScrollBar) { return that.verticalScrollBar.value; } return -1; } set scrollTop(value) { const that = this; if (value < 0) { value = 0; } if (that.verticalScrollBar) { that.verticalScrollBar.value = value; } } get vScrollBar() { const that = this; return that.verticalScrollBar; } get hScrollBar() { const that = this; return that.horizontalScrollBar; } constructor(container, horizontalScrollBar, verticalScrollBar) { const that = this; that.container = container; that.horizontalScrollBar = horizontalScrollBar; that.verticalScrollBar = verticalScrollBar; that.disableSwipeScroll = false; that.listen(); } listen() { const that = this; const isMobile = Core.isMobile; const horizontalScrollBar = that.horizontalScrollBar; const verticalScrollBar = that.verticalScrollBar; that.inputEvents = new InputEvents(that.container); let dragStarted, rafId, pointerCaptured, timestamp, ticker, now, elapsed, timeConstant = 500, currentScrollInfo; const createScrollInfo = function (scrollBar) { return { amplitude: 0, delta: 0, initialValue: 0, min: 0, max: scrollBar.max, previousValue: 0, pointerPosition: 0, targetValue: 0, scrollBar: scrollBar, value: 0, velocity: 0 } } const hScrollInfo = createScrollInfo(horizontalScrollBar); const vScrollInfo = createScrollInfo(verticalScrollBar); const track = function () { const velocityCoefficient = that.container.touchVelocityCoefficient || 50; now = Date.now(); elapsed = now - timestamp; timestamp = now; const updateScrollInfo = function (scrollInfo) { scrollInfo.delta = scrollInfo.value - scrollInfo.previousValue; scrollInfo.previousValue = scrollInfo.value; let velocity = velocityCoefficient * scrollInfo.delta / (1 + elapsed); scrollInfo.velocity = 0.8 * velocity + 0.2 * scrollInfo.velocity; } updateScrollInfo(vScrollInfo); updateScrollInfo(hScrollInfo); } const scroll = function (value) { currentScrollInfo.value = (value > currentScrollInfo.max) ? currentScrollInfo.max : (value < currentScrollInfo.min) ? currentScrollInfo.min : value; currentScrollInfo.scrollBar.value = currentScrollInfo.value; return (value > currentScrollInfo.max) ? 'max' : (value < currentScrollInfo.min) ? 'min' : 'value'; } function autoScroll() { let elapsed, delta; if (currentScrollInfo.amplitude) { that.container.$.fireEvent('kineticScroll'); elapsed = Date.now() - timestamp; delta = -currentScrollInfo.amplitude * Math.exp(-elapsed / timeConstant); if (delta > 5 || delta < -5) { scroll(currentScrollInfo.targetValue + delta); cancelAnimationFrame(rafId); rafId = 0; rafId = requestAnimationFrame(autoScroll); } else { scroll(currentScrollInfo.targetValue); } } } that.inputEvents['down'](function (event) { if (!isMobile) { return; } const originalTarget = event.originalEvent.target, target = originalTarget && originalTarget.closest ? originalTarget.closest('lw-scroll-bar') : undefined; if (target === that.horizontalScrollBar || target === that.verticalScrollBar) { return; } pointerCaptured = true; dragStarted = false; const updateScrollInfo = function (scrollInfo, pointerPosition) { scrollInfo.amplitude = 0; scrollInfo.pointerPosition = pointerPosition; scrollInfo.previousValue = scrollInfo.value; scrollInfo.value = scrollInfo.scrollBar.value; scrollInfo.initialValue = scrollInfo.value; scrollInfo.max = scrollInfo.scrollBar.max; } updateScrollInfo(vScrollInfo, event.clientY); updateScrollInfo(hScrollInfo, event.clientX); timestamp = Date.now(); clearInterval(ticker); ticker = setInterval(track, timeConstant); }); that.inputEvents['up'](function () { if (!pointerCaptured) { return true; } clearInterval(ticker); if (that.disableSwipeScroll) { pointerCaptured = false; return; } const startScroll = function (scrollInfo) { currentScrollInfo = scrollInfo; scrollInfo.amplitude = 0.8 * scrollInfo.velocity; scrollInfo.targetValue = Math.round(scrollInfo.value + scrollInfo.amplitude); timestamp = Date.now(); cancelAnimationFrame(rafId); rafId = requestAnimationFrame(autoScroll); scrollInfo.velocity = 0; } if (vScrollInfo.velocity > 10 || vScrollInfo.velocity < -10) { startScroll(vScrollInfo); } else if (hScrollInfo.velocity > 10 || hScrollInfo.velocity < -10) { startScroll(hScrollInfo); } pointerCaptured = false; }); that.inputEvents['move'](function (event) { if (!pointerCaptured) { return true; } if (that.disableSwipeScroll) { return; } if (dragStarted) { event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); } hScrollInfo.visible = horizontalScrollBar.offsetHeight > 0; vScrollInfo.visible = verticalScrollBar.offsetWidth > 0; if (!pointerCaptured || (!hScrollInfo.visible && !vScrollInfo.visible)) { return; } const touchScrollRatio = that.container.touchScrollRatio; let vScrollRatio, hScrollRatio; if (touchScrollRatio) { if (typeof touchScrollRatio === 'number') { vScrollRatio = -touchScrollRatio; hScrollRatio = -touchScrollRatio; } else if (typeof touchScrollRatio === 'function') { vScrollRatio = touchScrollRatio(vScrollInfo.max, vScrollInfo.scrollBar.offsetHeight); hScrollRatio = touchScrollRatio(hScrollInfo.max, hScrollInfo.scrollBar.offsetWidth); } } vScrollInfo.ratio = vScrollRatio || (-vScrollInfo.max / vScrollInfo.scrollBar.offsetHeight); vScrollInfo.delta = (event.clientY - vScrollInfo.pointerPosition) * vScrollInfo.ratio; hScrollInfo.ratio = hScrollRatio || (-hScrollInfo.max / hScrollInfo.scrollBar.offsetWidth); hScrollInfo.delta = (event.clientX - hScrollInfo.pointerPosition) * hScrollInfo.ratio; let dragged = 'value'; const doDrag = function (scrollInfo, pointerPosition, event) { if (scrollInfo.delta > 5 || scrollInfo.delta < -5) { currentScrollInfo = scrollInfo; dragged = (scrollInfo.initialValue + scrollInfo.delta > currentScrollInfo.max) ? 'max' : (scrollInfo.initialValue + scrollInfo.delta < currentScrollInfo.min) ? 'min' : 'value'; if (dragged === 'min' && scrollInfo.initialValue === 0) { return true; } if (dragged === 'max' && scrollInfo.initialValue === scrollInfo.max) { return true; } if (!scrollInfo.visible) { return true; } that.container.$.fireEvent('kineticScroll'); scroll(scrollInfo.initialValue + scrollInfo.delta); track(); event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); dragStarted = true; return false; } return null; } let verticalDragResult = doDrag(vScrollInfo, event.clientY, event); if (verticalDragResult === null) { let horizontalDragResult = doDrag(hScrollInfo, event.clientX, event); if (horizontalDragResult !== null) { return horizontalDragResult; } } else { return verticalDragResult; } }); let elapsedScrollTo; that.scrollTo = function (value, vertically) { const scrollInfo = vertically === false ? hScrollInfo : vScrollInfo; let isScrolling = false; if (!timestamp) { timestamp = Date.now(); } if (!elapsedScrollTo) { elapsedScrollTo = Date.now(); } if (Math.abs(Date.now() - elapsedScrollTo) > 375) { timestamp = Date.now(); } else { isScrolling = true; } elapsedScrollTo = Date.now(); scrollInfo.value = scrollInfo.scrollBar.value; scrollInfo.delta = value - scrollInfo.value; scrollInfo.max = scrollInfo.scrollBar.max; if (value <= scrollInfo.min) { value = scrollInfo.min; } if (value >= scrollInfo.max) { value = scrollInfo.max; } scrollInfo.targetValue = value; const to = value; let from = scrollInfo.value; scrollInfo.velocity = 100 * scrollInfo.delta / (1 + scrollInfo.max); scrollInfo.from = from; const scroll = function (value) { scrollInfo.value = (value > scrollInfo.max) ? scrollInfo.max : (value < scrollInfo.min) ? scrollInfo.min : value; scrollInfo.scrollBar.value = scrollInfo.value; return (value > scrollInfo.max) ? 'max' : (value < scrollInfo.min) ? 'min' : 'value'; } const autoScroll = function () { let delta; let duration = 175; let time = Date.now() - elapsedScrollTo; let elapsed = Math.min(1000, Date.now() - timestamp); let amplitude = scrollInfo.velocity * Math.exp(elapsed / duration); if (isScrolling) { if (amplitude < 0 && scrollInfo.value <= value) { amplitude = 0; } else if (amplitude > 0 && scrollInfo.value >= value) { amplitude = 0; } if (scrollInfo.value + amplitude <= scrollInfo.min || scrollInfo.value + amplitude >= scrollInfo.max) { amplitude = 0; } if (amplitude > 0.5 || amplitude < -0.5) { scroll(scrollInfo.value + amplitude); cancelAnimationFrame(rafId); rafId = 0; rafId = requestAnimationFrame(autoScroll); } else { scroll(scrollInfo.targetValue); } } else { if (time >= duration) { cancelAnimationFrame(rafId); that.container.$.fireEvent('kineticScroll'); rafId = 0; return; } delta = Utilities.Animation.Easings.easeInSine(time, from, to - from, duration); scroll(delta); cancelAnimationFrame(rafId); rafId = 0; rafId = requestAnimationFrame(autoScroll); } } cancelAnimationFrame(rafId); rafId = requestAnimationFrame(autoScroll); } that.inputEvents.listen(); } unlisten() { const that = this; if (that.inputEvents) { that.inputEvents.unlisten(); } delete that.inputEvents; } } /** This is a class which extends an element with utility methods. */ class Extend { constructor(element) { this.events = { }; this.handlers = { }; this.element = element; } /** * Gets whether an element has a CSS Class. * @param {String}. */ hasClass(className) { const that = this; const classNames = className.split(' '); for (let i = 0; i < classNames.length; i++) { const result = that.element.classList.contains(classNames[i]); if (!result) { return false; } } return true; } /** * Adds a CSS Class to an element. * @param {String}. */ addClass(className) { const that = this; if (that.hasClass(className)) { return; } const classNames = className.split(' '); for (let i = 0; i < classNames.length; i++) { that.element.classList.add(classNames[i]); } if (!that.isNativeElement) { StyleObserver.observeElement(that.element); } } /** * Removes a CSS Class from an element. * @param {String}. */ removeClass(className) { const that = this; if (arguments.length === 0) { that.element.removeAttribute('class'); return; } const classNames = className.split(' '); for (let i = 0; i < classNames.length; i++) { that.element.classList.remove(classNames[i]); } if (that.element.className === '') { that.element.removeAttribute('class'); } if (!that.isNativeElement) { StyleObserver.observeElement(that.element); } } get isCustomElement() { const that = this; if (that.element.tagName.startsWith(namespace)) { return true; } if (that.element instanceof window[namespace].BaseElement === true) { return true; } if (that.element.tagName === 'DIV' || that.element.tagName === 'SPAN' || that.element.tagName === 'BUTTON' || that.element.tagName === 'INPUT' || that.element.tagName === 'UL' || that.element.tagName === 'LI') { return false; } if (document.createElement(that.element.nodeName) instanceof window[namespace].BaseElement === true) { return true; } return false; } /** Determines whether this element is native HTMLElement. */ get isNativeElement() { const that = this; if (!that.isCustomElement) { return true; } return false; } /** * Applies the event handlers. * @param {Event} - event object. */ dispatch(event) { const that = this; const handleObjects = that.events[event.type]; let shouldSort = false; if (handleObjects.length > 1) { for (let i = 0; i < handleObjects.length; i++) { const handleObject = handleObjects[i]; if (handleObject.namespace && handleObject.namespace.indexOf('_') >= 0) { shouldSort = true; break; } } } if (shouldSort) { handleObjects.sort(function (element1, element2) { let namespace1 = element1.namespace; let namespace2 = element2.namespace; if (namespace1.indexOf('_') === -1) { namespace1 = 0; } else { namespace1 = parseInt(namespace1.substring(namespace1.indexOf('_') + 1)); } if (namespace2.indexOf('_') === -1) { namespace2 = 0; } else { namespace2 = parseInt(namespace2.substring(namespace2.indexOf('_') + 1)); } if (namespace1 < namespace2) { return -1; } if (namespace1 > namespace2) { return 1; } return 0; }); } for (let i = 0; i < handleObjects.length; i++) { const handleObject = handleObjects[i]; event.namespace = handleObject.namespace; event.context = handleObject.context; if (event.defaultPrevented) { break; } const result = handleObject.handler.apply(that.element, [event]); if (result !== undefined) { event.result = result; if (result === false) { event.preventDefault(); event.stopPropagation(); break; } } } return event.result; } /** * Fires a new event. * @param {String} - event type. * @param {Object} - event details. * @param {Object} - event options. */ fireEvent(eventType, detail, options) { const that = this; if (!options) { options = { bubbles: true, cancelable: true, composed: that.element.getRootNode().host !== null } } options.detail = detail || { }; const customEvent = new CustomEvent(eventType, options); customEvent.originalStopPropagation = customEvent.stopPropagation; customEvent.stopPropagation = function () { customEvent.isPropagationStopped = true; return customEvent.originalStopPropagation(); } that.dispatchEvent(customEvent); return customEvent; } get isPassiveSupported() { // Test via a getter in the options object to see if the passive property is accessed const that = this; if (that.supportsPassive !== undefined) { return that.supportsPassive; } that.supportsPassive = false; try { let opts = Object.defineProperty({ }, 'passive', { get: function () { that.supportsPassive = true; } }); window.addEventListener('testPassive', null, opts); window.removeEventListener('testPassive', null, opts); } catch (e) { // } return that.supportsPassive; } /** * Dispatches an event. * @param {CustomEvent} - event. */ dispatchEvent(customEvent) { const that = this; const eventType = customEvent.type; const context = that.element.context; const normalizedEventType = eventType.substring(0, 1).toUpperCase() + eventType.substring(1); that.element.context = document; if (that.element['on' + normalizedEventType]) { that.element['on' + normalizedEventType](customEvent); } else if (that.element['on' + eventType.toLowerCase()]) { that.element['on' + eventType.toLowerCase()](customEvent); } else { that.element.dispatchEvent(customEvent); } that.element.context = context; } /** * Adds an event listener. * @param {String} - event types. * @param {Function} - the event handler. */ listen(types, handler) { const that = this; const typesArray = types.split('.'); const namespace = typesArray.slice(1).join('.'); const eventType = typesArray[0]; if (!that.events[eventType]) { that.events[eventType] = []; } const handleObject = { type: eventType, handler: handler, context: that.element, namespace: namespace }; if (inputEventTypes.indexOf(eventType) >= 0) { if (!that.inputEvents) { that.inputEvents = new InputEvents(that.element); } that.inputEvents[eventType](function (event) { that.dispatchEvent(event); }); that.inputEvents.boundEventTypes.push(eventType); that.inputEvents.listen(eventType); } if (that.events[eventType].length === 0) { that.handlers[eventType] = that.dispatch.bind(that); if (eventType === 'wheel') { that.element.addEventListener('wheel', that.handlers[eventType], that.isPassiveSupported ? { passive: false } : false); } else { that.element.addEventListener(eventType, that.handlers[eventType], false); } } that.events[eventType].push(handleObject); } /** * Removes an event listener. * @param {String} - event types. */ unlisten(types) { const that = this; const typesArray = types.split('.'); const namespace = typesArray.slice(1).join('.'); const eventType = typesArray[0]; let handleObjects = that.events[eventType]; if (that.inputEvents && that.inputEvents.boundEventTypes.indexOf(eventType) >= 0) { that.inputEvents.boundEventTypes.splice(that.inputEvents.boundEventTypes.indexOf(eventType), 1); if (that.inputEvents.boundEventTypes.length === 0) { that.inputEvents.unlisten(eventType); } } if (!handleObjects) { return; } for (let i = 0; i < handleObjects.length; i++) { if (namespace !== '') { let index = handleObjects.findIndex(o => o.namespace === namespace); handleObjects.splice(index, 1); break; } else { handleObjects = []; } } if (handleObjects.length === 0) { that.element.removeEventListener(eventType, that.handlers[eventType]); that.events[eventType] = []; delete that.handlers[eventType]; } } /** * Gets the element's attribute value by using the property's value. * @param {String} - attribute's name. * @param {String} - property's type. * @return {Object} The converted from String attribute value. */ getAttributeValue(attributeName, type) { const that = this; const attributeString = that.element.getAttribute(attributeName); if (that.isNativeElement) { return that.deserialize(attributeString, type); } const propertyConfig = that.element.propertyByAttributeName[attributeName]; const typedValue = propertyConfig.deserialize === undefined ? that.deserialize(attributeString, type, propertyConfig.nullable) : that.element[propertyConfig.deserialize](attributeString); return typedValue; } /** * Sets the element's attribute using the property's value. * @param {String} - attribute's name. * @param {Object} - property's value. * @param {String} - property's type. */ setAttributeValue(attributeName, value, type) { const that = this; let newAttributeValue; let nullable = false; if (!that.isNativeElement) { const propertyConfig = that.element.propertyByAttributeName[attributeName]; nullable = propertyConfig ? propertyConfig.nullable : true; if (propertyConfig && propertyConfig.serialize) { newAttributeValue = that.element[propertyConfig.serialize](value); } else { newAttributeValue = that.serialize(value, type, nullable); } } else { newAttributeValue = that.serialize(value, type); if (type === 'boolean') { const booleans = ['checked', 'selected', 'async', 'autofocus', 'autoplay', 'controls', 'defer', 'disabled', 'hidden', 'ismap', 'loop', 'multiple', 'open', 'readonly', 'required', 'scoped']; if (booleans.indexOf(attributeName) >= 0) { if (!value) { that.element.removeAttribute(attributeName); } else { that.element.setAttribute(attributeName, ''); } return; } } } if (type === 'array' || type === 'object') { if (newAttributeValue === '[]' || newAttributeValue === '{}') { that.element.removeAttribute(attributeName); return; } } if (newAttributeValue === undefined) { that.element.removeAttribute(attributeName); if (that.element.shadowRoot && that.element.$.root) { that.element.$.root.removeAttribute(attributeName); } } else { that.element.setAttribute(attributeName, newAttributeValue); if (that.element.shadowRoot && that.element.$.root) { that.element.$.root.setAttribute(attributeName, newAttributeValue); } } } /** * Converts a javascript value to string. * @param {Object} the value to be converted. * @return {String} The converted to String value. If the type is unknown, returns undefined. */ serialize(value, type, nullable) { if (type === undefined) { type = Utilities.Types.getType(value); } if (value === undefined || (!nullable && value === null)) { return undefined; } if (nullable && value === null) { return 'null'; } if (type === 'string') { return value; } if (type === 'boolean' || type === 'bool') { if (value === true || value === 'true' || value === 1 || value === '1') { return ''; } else if (value === false || value === 'false' || value === 0 || value === '0') { return undefined; } } if (type === 'array') { return JSON.stringify(value); } const types = ['string', 'number', 'int', 'integer', 'float', 'date', 'any', 'function']; if (types.indexOf(type) >= 0) { return value.toString(); } if (type === 'object') { return JSON.stringify(value); } return undefined; } /** * Converts a string to a Javascript value. * @param {String} * @param {String} * @return {Object} The converted String value. */ deserialize(stringValue, type, nullable) { const nullValue = stringValue === 'null'; if (stringValue === undefined || (nullValue && !nullable)) { return undefined; } if (nullValue && nullable) { return null; } if (type === 'boolean' || type === 'bool') { if (stringValue === null) { return false; } // Boolean properties are set based on the presence of the attribute: if the attribute exists at all, the value is true. return true; } else if (type === 'number' || type === 'float') { if (stringValue === 'NaN') { return NaN; } if (stringValue === 'Infinity') { return Infinity; } if (stringValue === '-Infinity') { return -Infinity; } return parseFloat(stringValue); } else if (type === 'int' || type === 'integer') { if (stringValue === 'NaN') { return NaN; } if (stringValue === 'Infinity') { return Infinity; } if (stringValue === '-Infinity') { return -Infinity; } return parseInt(stringValue); } else if (type === 'string') { return stringValue; } else if (type === 'any') { return stringValue; } else if (type === 'date') { return new Date(stringValue); } else if (type === 'function') { if (typeof window[stringValue] === 'function') { return window[stringValue]; } } else if (type === 'array' || type === 'object') { try { const jsonObject = JSON.parse(stringValue); if (jsonObject) { return jsonObject; } } catch (er) { if (window[stringValue] && (typeof window[stringValue] === 'object')) { return window[stringValue]; } else if (type === 'array' && stringValue.indexOf('[') >= 0) { if (stringValue.indexOf('{') >= 0) { let array = stringValue.replace(/{/ig, '').replace('[', '').replace(']', '').replace(/'/ig, '').replace(/"/ig, '').trim(); array = array.split('},'); for (let i = 0; i < array.length; i++) { let parsedObject = { }; let parts = array[i].trim().split(','); for (let j = 0; j < parts.length; j++) { const key = parts[j].split(':')[0].trim(); const value = parts[j].split(':')[1].trim(); parsedObject[key] = value; } array[i] = parsedObject; } return array; } const array = stringValue.replace('[', '').replace(']', '').replace(/'/ig, '').replace(/"/ig, '').trim().split(','); return array; } } } return undefined; } } /** Animation class. */ class Animation { /** Get access to Ripple class. */ static get Ripple() { return Ripple; } /** Get access to Easings class. */ static get Easings() { return Easings; } } /** Utilities class. */ class Utilities { /** Get access to Types class. */ static get Types() { return Types; } static get Core() { return Core; } static get Animation() { return Animation; } static get Scroll() { return Scroll; } static get InputEvents() { return InputEvents; } /** * Extends Element with useful methods. * @param {HTMLElement} */ static Extend(element) { return new Extend(element); } static Assign(moduleName, module) { if (moduleName.indexOf('.') >= 0) { const modules = moduleName.split('.'); if (!Utilities[modules[0]]) { Utilities[modules[0]] = { }; } Utilities[modules[0]][modules[1]] = module; return; } Utilities[moduleName] = module; } } const $document = Utilities.Extend(document); class BindingModule { } BindingModule.cache = { }; /** * This is a base class for LW Elements. It extends HTMLElement. */ class BaseElement extends HTMLElement { /** * Element's properties. * * @return {Object} - element's properties. */ static get properties() { return { 'animation': { value: 'advanced', type: 'string', allowedValues: ['none', 'simple', 'advanced'] }, 'unfocusable': { value: false, type: 'boolean' }, 'disabled': { value: false, type: 'boolean' }, 'dataContext': { value: null, reflectToAttribute: false, type: 'any' }, 'debugMode': { value: true, type: 'boolean', reflectToAttribute: false }, 'locale': { value: 'en', type: 'string', reflectToAttribute: false }, 'localizeFormatFunction': { value: undefined, type: 'function', reflectToAttribute: false }, 'messages': { value: { 'en': { 'propertyUnknownName': 'Invalid property name: \'{{name}}\'!', 'propertyUnknownType': '\'{{name}}\' property is with undefined \'type\' member!', 'propertyInvalidValue': 'Invalid \'{{name}}\' property value! Actual value: \'{{actualValue}}\', Expected value: \'{{value}}\'!', 'propertyInvalidValueType': 'Invalid \'{{name}}\' property value type! Actual type: \'{{actualType}}\', Expected type: \'{{type}}\'!', 'methodInvalidValueType': 'Invalid \'{{name}}\' method argument value type! Actual type: \'{{actualType}}\', Expected type: \'{{type}}\' for argument with index: \'{{argumentIndex}}\'!', 'methodInvalidArgumentsCount': 'Invalid \'{{name}}\' method arguments count! Actual arguments count: \'{{actualArgumentsCount}}\', Expected at least: \'{{argumentsCount}}\' argument(s)!', 'methodInvalidReturnType': 'Invalid \'{{name}}\' method return type! Actual type: \'{{actualType}}\', Expected type: \'{{type}}\'!', 'elementNotInDOM': 'Element does not exist in DOM! Please, add the element to the DOM, before invoking a method.', 'moduleUndefined': 'Module is undefined.', 'missingReference': '{{elementType}}: Missing reference to \'{{files}}\'.', 'htmlTemplateNotSuported': '{{elementType}}: Web Browser doesn\'t support HTMLTemplate elements.', 'invalidTemplate': '{{elementType}}: \'{{property}}\' property accepts a string that must match the id of an HTMLTemplate element from the DOM.' } }, reflectToAttribute: false, inherit: true, type: 'object' }, 'props': { value: null, reflectToAttribute: false, isHierarchicalProperty: true, type: 'any' }, 'readonly': { value: false, type: 'boolean' }, 'renderMode': { value: 'auto', type: 'string', reflectToAttribute: false, allowedValues: ['auto', 'manual'] }, 'rightToLeft': { value: false, type: 'boolean' }, 'rethrowError': { value: true, type: 'boolean', reflectToAttribute: false }, 'theme': { value: window[namespace].Theme, type: 'string' }, 'visibility': { value: 'visible', allowedValues: ['visible', 'collapsed', 'hidden'], type: 'string' }, 'wait': { value: false, type: 'boolean' } }; } /** * @typedef {Object} bindings * @property {Array<Node>} children The child nodes. * @property {Node} node The node. * @property {BindingData} data The node's binding data. */ /** * @typedef {Object} BindingData * @property {Boolean} twoWay - Deterimes whether it's one way or two way data binding. * @property {Boolean} updating - Determines whether the node is in update state. * @property {Object} value - The bound property's value. * @property {String} name - The bound property's name. */ getBindings(node, ownerMap) { const that = this; let index = 0; let map = { }; let boundData = (node => { if (node instanceof HTMLElement) { return that.parseAttributes(node); } else { let boundProperty = that.parseProperty(node.data ? node.data.trim() : null, 'textContent', node); if (boundProperty) { if (that && node.parentNode === that.$.content) { boundProperty.value = that.$.html !== '' ? that.$.html : undefined; that.innerHTML = ''; } return { 'textContent': boundProperty }; } } return undefined; })(node); if (boundData) { map.data = boundData; } if (!ownerMap) { map.mapping = []; ownerMap = map; } if (node.getAttribute) { map.nodeId = node.getAttribute('lw-id'); if (ownerMap && boundData) { ownerMap.mapping[map.nodeId] = boundData; } } map.node = node; if (node.firstChild) { map.children = { }; } for (let child = node.firstChild; child; child = child.nextSibling) { map.children[index++] = that.getBindings(child, ownerMap); } return map; } _addRemovePropertyBinding(hostPropertyName, targetPropertyName, targetElement, removeBinding, parentElement) { if (!hostPropertyName || !targetPropertyName || !targetElement) { return; } const that = this; const bindings = that.bindings; const id = targetElement.getAttribute('lw-id'); const twoWayBinding = hostPropertyName.indexOf('{{') >= 0; hostPropertyName = hostPropertyName.replace('{{', '').replace('}}', '').replace('[[', '').replace(']]', ''); let not = false; if (hostPropertyName.indexOf('!') >= 0) { hostPropertyName = hostPropertyName.replace('!', ''); not = true; } const hostProperty = that._properties[hostPropertyName]; const boundProperty = { name: hostPropertyName, reflectToAttribute: hostProperty.reflectToAttribute, twoWay: twoWayBinding, type: hostProperty.type, not: not }; if (parentElement && !removeBinding) { const map = {}; const targetBoundProperty = { name: hostPropertyName, targetPropertyName: targetPropertyName, reflectToAttribute: hostProperty.reflectToAttribute, twoWay: twoWayBinding, type: hostProperty.type, not: not }; map[hostPropertyName] = targetBoundProperty; bindings.mapping[id] = map; } const setBinding = function (boundChildren) { for (let childIndex in boundChildren) { const child = boundChildren[childIndex]; if (child.nodeId === id) { if (!child.data) { child.data = { }; } if (removeBinding) { child.data[targetPropertyName] = null; delete child.data[targetPropertyName]; } else { child.data[targetPropertyName] = boundProperty; } break; } if (child.children) { setBinding(child.children); } else if (child.node && child.node.children && child.node === targetElement.parentElement) { const node = child.node; if (node.firstChild) { child.children = { }; } else { continue; } let index = 0; for (let currentChild = node.firstChild; currentChild; currentChild = currentChild.nextSibling) { child.children[index++] = that.getBindings(currentChild); } setBinding(child.children); } } } setBinding(bindings.children); if (!removeBinding) { that.boundProperties[hostPropertyName] = true; } else { delete that.boundProperties[hostPropertyName]; } that.updateBoundNodes(hostPropertyName); } addPropertyBinding(hostPropertyName, targetPropertyName, targetElement, parentElement) { const that = this; that._addRemovePropertyBinding(hostPropertyName, targetPropertyName, targetElement, false, parentElement); } removePropertyBinding(hostPropertyName, targetPropertyName, targetElement, parentElement) { const that = this; that._addRemovePropertyBinding(hostPropertyName, targetPropertyName, targetElement, true, parentElement); } /** * Parses the element's attributes. * @param {HTMLElement} - html element. * @return {Array<BindingData>} */ parseAttributes(htmlElement) { const that = this; let boundProperties = undefined; for (let i = 0; i < htmlElement.attributes.length; i++) { const attribute = htmlElement.attributes[i]; const attributeName = attribute.name; const attributeValue = attribute.value; if (!BindingModule.cache['toCamelCase' + attributeName]) { BindingModule.cache['toCamelCase' + attributeName] = Utilities.Core.toCamelCase(attributeName); } const propertyName = BindingModule.cache['toCamelCase' + attributeName]; if (attributeName.indexOf('(') >= 0) { let eventName = attributeName.substring(1, attributeName.length - 1); if (that && !that.dataContext) { that.templateListeners[htmlElement.getAttribute('lw-id') + '.' + eventName] = attributeValue; htmlElement.removeAttribute(attributeName); continue; } else { if (!boundProperties) { boundProperties = { }; } const handlerName = attributeValue.substring(0, attributeValue.indexOf('(')); boundProperties[propertyName] = { isEvent: true, name: eventName, value: handlerName }; continue; } } let boundProperty = that.parseProperty(attributeValue, attributeName, htmlElement); if (!boundProperty) { continue; } if (!boundProperties) { boundProperties = { }; } boundProperties[propertyName] = boundProperty; } return boundProperties; } /** * Parses a property. * @param {String} - The string to parse. * @param {name} - property's name. * @param {Node} - the node. * @return {BindingData} */ parseProperty(text, elementAttributeName/*, name, node*/) { if (!text || !text.length) return; const that = this; let boundProperty; let length = text.length; let startIndex = 0, lastIndex = 0, endIndex = 0; let twoWay = true; while (lastIndex < length) { startIndex = text.indexOf('{{', lastIndex); let twoWayStart = text.indexOf('[[', lastIndex); let terminator = '}}'; if (twoWayStart >= 0 && (startIndex < 0 || twoWayStart < startIndex)) { startIndex = twoWayStart; twoWay = false; terminator = ']]'; } endIndex = startIndex < 0 ? -1 : text.indexOf(terminator, startIndex + 2); if (endIndex < 0) { return; } boundProperty = boundProperty || { }; let pathString = text.slice(startIndex + 2, endIndex).trim(); let attributeName = pathString; boundProperty.name = attributeName; lastIndex = endIndex + 2; } const propertyName = boundProperty.name; const elementProperty = that ? that._properties[propertyName] : null; boundProperty.twoWay = twoWay; boundProperty.ready = false; if (that) { if (propertyName.indexOf('::') >= 0) { that.boundProperties[propertyName.substring(0, propertyName.indexOf('::'))] = true; } else { that.boundProperties[propertyName] = true; } } if (elementProperty) { boundProperty.type = elementProperty.type; boundProperty.reflectToAttribute = elementProperty.reflectToAttribute; } else { const booleans = ['checked', 'selected', 'async', 'autofocus', 'autoplay', 'controls', 'defer', 'disabled', 'hidden', 'ismap', 'loop', 'multiple', 'open', 'readonly', 'required', 'scoped']; if (booleans.indexOf(elementAttributeName) >= 0) { boundProperty.type = 'boolean'; } else { boundProperty.type = 'string'; } boundProperty.reflectToAttribute = true; } return boundProperty; } /** * Updates element's data bound nodes. */ updateTextNodes() { const that = this; that.updateTextNode(that.shadowRoot || that, that.bindings, that); } /** * Updates a data bound node. * @param {Node} - The bound node. * @param {Array<BindingData>} - The node's binding data. * @param {Element} - The element to be updated. */ updateTextNode(node, bindings, element) { const that = this; if (!bindings) { return; } let index = 0; for (let child = node.firstChild; child; child = child.nextSibling) { if (!bindings.children) { break; } that.updateTextNode(child, bindings.children[index++], element); } if (!bindings || !bindings.data) { return; } for (let name in bindings.data) { const boundProperty = bindings.data[name]; const boundPropertyName = boundProperty.name; if (name !== 'textContent' || !boundProperty.twoWay || boundProperty.updating || boundProperty.value === undefined) { continue; } element[boundPropertyName] = boundProperty.value; } } /** * Updates a data bound property. * @param {String} - The propery's name. * @param {Object} - The property's value. */ updateBoundProperty(propertyName, propertyConfig) { if (propertyConfig.updating) { return; } const that = this; const element = that; propertyConfig.updating = true; element[propertyName] = propertyConfig.value; propertyConfig.updating = false; } /** * Updates element's data bound nodes. */ updateBoundNodes(propertyName) { const that = this; that.updateBoundNode(that.shadowRoot || that, that.bindings, that, propertyName); if (that.detachedChildren.length > 0) { for (let i = 0; i < that.detachedChildren.length; i++) { const node = that.detachedChildren[i]; const lwId = node.getAttribute('lw-id'); const getBindings = function (bindings) { if (bindings.nodeId === lwId) { return bindings; } for (let index in bindings.children) { const node = bindings.children[index]; const attribute = node.getAttribute ? node.getAttribute('lw-id') : ''; if (attribute === lwId) { return bindings; } if (node.children) { const result = getBindings(node); if (result) { return result; } } } return null; } const bindings = getBindings(that.bindings); if (bindings) { that.updateBoundNode(node, bindings, that, propertyName, true); } else { if (node.getAttribute && that.bindings.mapping) { const element = that; const bindings = that.bindings; if (bindings) { for (let mapping in bindings.mapping) { const childNode = element.querySelector('[lw-id="' + mapping + '"]'); if (childNode) { const dataBoundProperties = bindings.mapping[mapping]; that.updateBoundData(childNode, dataBoundProperties, element, propertyName); } } } } } } } } updateBoundMappedNodes() { const that = this; const bindings = that.bindings; const element = that; if (!bindings.mapping) { return; } for (let mapping in bindings.mapping) { let childNode = element.querySelector('[lw-id="' + mapping + '"]'); if (element.shadowRoot) { childNode = element.querySelector('[id="' + mapping + '"]'); if (!childNode) { childNode = element.shadowRoot.querySelector('[id="' + mapping + '"]') || element.shadowRoot.querySelector('[lw-id="' + mapping + '"]'); } } if (childNode) { const dataBoundProperties = bindings.mapping[mapping]; that.updateBoundData(childNode, dataBoundProperties, element); } else if (element.getAttribute('aria-controls')) { let detachedChildNode = document.getElementById(element.getAttribute('aria-controls')); if (!detachedChildNode && element.shadowRoot) { detachedChildNode = element.shadowRoot.getElementById(element.getAttribute('aria-controls')); } childNode = detachedChildNode.querySelector('[lw-id="' + mapping + '"]'); if (childNode) { const dataBoundProperties = bindings.mapping[mapping]; that.updateBoundData(childNode, dataBoundProperties, element); } } } } /** * Updates a data bound node. * @param {Node} - The bound node. * @param {Array<BindingData>} - The node's binding data. * @param {Element} - The element to be updated. */ updateBoundNode(node, bindings, element, propertyName, detached) { const that = this; if (!bindings) { return; } let index = 0; if (!detached) { for (let child = node.firstChild; child; child = child.nextSibling) { if (!bindings.children) { break; } // that.updateBoundNode(child, bindings.children[index++], element, propertyName); if (child.getAttribute) { const childId = child.getAttribute('lw-id'); const childBindings = function () { for (let binding in bindings.children) { if (bindings.children[binding].nodeId === childId) { return bindings.children[binding]; } } }(); that.updateBoundNode(child, childBindings, element, propertyName); index++; } else { that.updateBoundNode(child, bindings.children[index++], element, propertyName); } } } else if (detached && !bindings.data) { for (let child = node.firstChild; child; child = child.nextSibling) { if (!bindings.children) { break; } // that.updateBoundNode(child, bindings.children[index++], element, propertyName, detached); if (child.getAttribute) { const childId = child.getAttribute('lw-id'); const childBindings = function () { for (let binding in bindings.children) { if (bindings.children[binding].nodeId === childId) { return bindings.children[binding]; } } }(); that.updateBoundNode(child, childBindings, element, propertyName); index++; } else { that.updateBoundNode(child, bindings.children[index++], element, propertyName, detached); } } } if (!bindings || !bindings.data) { return; } const dataBoundProperties = bindings.data; that.updateBoundData(node, dataBoundProperties, element, propertyName); } updateBoundData(node, dataBoundProperties, element, propertyName) { const that = this; for (let name in dataBoundProperties) { const boundProperty = dataBoundProperties[name]; let boundPropertyName = boundProperty.name; if (boundProperty.updating) { continue; } if (boundPropertyName.indexOf('::') >= 0) { boundPropertyName = boundPropertyName.substring(0, boundPropertyName.indexOf('::')); } if (propertyName !== undefined && propertyName !== boundPropertyName) { continue; } if (boundPropertyName.indexOf('(') >= 0) { let args = boundPropertyName.substring(boundPropertyName.indexOf('(')); const methodName = boundPropertyName.substring(0, boundPropertyName.indexOf('(')); args = args.substring(1, args.length - 1); args = args.replace(/ /ig, ''); args = args.split(','); if (args.length > 0 && args[0] !== '') { let values = []; for (let i = 0; i < args.length; i++) { values.push(element[args[i]]); } boundProperty.value = element[methodName].apply(element, values); } else { boundProperty.value = element[methodName](); } boundProperty.type = typeof boundProperty.value; } else { boundProperty.value = element[boundPropertyName]; } if (boundPropertyName === 'innerHTML') { if (node[name].toString().trim() !== element[boundPropertyName].toString().trim()) { if (boundProperty.ready) { node[name] = boundProperty.value.toString().trim(); } else if (element._properties[boundPropertyName].defaultValue !== boundProperty.value) { node[name] = boundProperty.value.toString().trim(); } } } else { if (boundProperty.not) { node[name] = !boundProperty.value; if (boundProperty.targetPropertyName) { node[boundProperty.targetPropertyName] = !boundProperty.value; } } else { node[name] = boundProperty.value; if (boundProperty.targetPropertyName) { node[boundProperty.targetPropertyName] = boundProperty.value; } } } if (node.$ && node.$.isNativeElement) { if (!BindingModule.cache['toDash' + name]) { BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name); } const attributeName = BindingModule.cache['toDash' + name]; const oldValue = node.$.getAttributeValue(attributeName, boundProperty.type); if (boundProperty.reflectToAttribute && (oldValue !== boundProperty.value || !boundProperty.ready)) { node.$.setAttributeValue(attributeName, boundProperty.value, boundProperty.type); } if (!boundProperty.reflectToAttribute) { node.$.setAttributeValue(attributeName, null, boundProperty.type); } } if (!boundProperty.ready) { if (node.$ && node.$.isCustomElement) { if (!BindingModule.cache['toDash' + name]) { BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name); } const attributeName = BindingModule.cache['toDash' + name]; if (!node._properties) { node._beforeCreatedProperties = node._properties = node.propertyByAttributeName = []; } if (!node._properties[name]) { node._properties[name] = { attributeName: attributeName } if (node._beforeCreatedProperties) { node._beforeCreatedProperties[name] = node._properties[name]; } node.propertyByAttributeName[attributeName] = node._properties[name]; } const propertyConfig = node._properties[name]; propertyConfig.isUpdating = true; if (boundProperty.reflectToAttribute) { if (boundProperty.not) { node.$.setAttributeValue(propertyConfig.attributeName, !boundProperty.value, boundProperty.type); } else { node.$.setAttributeValue(propertyConfig.attributeName, boundProperty.value, boundProperty.type); } } if (!boundProperty.reflectToAttribute) { node.$.setAttributeValue(propertyConfig.attributeName, null, boundProperty.type); } propertyConfig.isUpdating = false; } if (boundProperty.twoWay) { const updateToken = function (value) { boundProperty.value = value; if (node.$ && node.$.isNativeElement) { if (!BindingModule.cache['toDash' + name]) { BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name); } const attributeName = BindingModule.cache['toDash' + name]; const oldValue = node.$.getAttributeValue(attributeName, boundProperty.type); if (boundProperty.reflectToAttribute && oldValue !== boundProperty.value) { node.$.setAttributeValue(attributeName, boundProperty.value, boundProperty.type); } if (!boundProperty.reflectToAttribute) { node.$.setAttributeValue(attributeName, null, boundProperty.type); } } } if (boundProperty.name.indexOf('::') >= 0) { const eventIndex = boundProperty.name.indexOf('::'); const eventName = boundProperty.name.substring(eventIndex + 2); that['$' + node.getAttribute('lw-id')].listen(eventName, function () { updateToken(node[name]); const boundPropertyName = boundProperty.name.substring(0, boundProperty.name.indexOf('::')); that.updateBoundProperty(boundPropertyName, boundProperty); }); } if (node.$ && node.$.isCustomElement) { if (node._properties[name]) { node._properties[name].notify = true; } if (!BindingModule.cache['toDash' + name]) { BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name); } const attributeName = BindingModule.cache['toDash' + name]; that['$' + node.getAttribute('lw-id')].listen(attributeName + '-changed', function (event) { let detail = event.detail; updateToken(detail.value); const context = that.context; if (event.context !== document) { that.context = that; } that.updateBoundProperty(boundProperty.name, boundProperty); // that.updateBoundProperty(name, boundProperty); that.context = context; }); } } } boundProperty.ready = true; } } static clearCache() { const that = this; that.cache = { }; } /** * Adds messages. * @param {String} - the string value's key. * @param {Object} - the messages object. */ addMessages(messageKey, messages) { const that = this; Object.assign(that.messages[messageKey], messages); } /** * Translates a text. * @param {String} the string value's key. * @param {Object} the values to be replaced in the string. * @return {String} the translated text. */ localize(messageKey, messageArguments) { const that = this; if (!that.messages || !that.messages[that.locale]) { return undefined; } let message = that.messages[that.locale][messageKey]; if (message === '') { return ''; } if (!message) { return undefined; } const defaultMessage = message; for (let messageName in messageArguments) { let messageValue = messageArguments[messageName]; message = message.replace(new RegExp('{{' + messageName + '}}', 'g'), messageValue); } if (that.localizeFormatFunction) { that.localizeFormatFunction(defaultMessage, message, messageArguments) } return message; } /** * Element's requires. * * @return {Object} - element's required modules. */ static get requires() { return { }; } /** * Element's listeners. * * @return {Object} - element's listeners. */ static get listeners() { return { 'theme-changed': function (event) { this.theme = event.detail.newValue; } }; } static get methods() { return { }; } get classNamesMap() { return { animation: 'lw-animate', rippleAnimation: 'lw-ripple' } } get hasAnimation() { const that = this; if (that.animation === 'none') { return false; } return true; } get hasRippleAnimation() { const that = this; if (that.animation === 'none') { return false; } if (that.animation === 'advanced') { return true; } return false; } /** * Element's modules. * * @return {Array<Module>} - element's modules. */ static get modules() { return window[namespace].Modules; } get properties() { const that = this; if (!that._properties) { that._properties = []; } return that._properties; } /** * Gets the element's parents. * * @return {Array<HTMLElement>} - element's parents. */ get parents() { const that = this; let matched = [], current = that.parentNode; while (current && current.nodeType !== 9) { if (current instanceof HTMLElement === true) { matched.push(current); } current = current.parentNode; } const rootNode = that.getRootNode(); if (rootNode.host) { const getNodeParents = (node) => { let matched = [node], current = node.parentNode; while (current && current.nodeType !== 9) { if (current instanceof HTMLElement === true) { matched.push(current); } current = current.parentNode; } return matched; } matched = matched.concat(getNodeParents(rootNode.host)); } if (window[namespace].EnableShadowDOM && that.isInShadowDOM && that.shadowParent) { matched = matched.concat(that.shadowParent.parents); } return matched; } /** Displays a log in the console.*/ log(message) { const that = this; that._logger('log', message); } /** Displays a warning in the console.*/ warn(message) { const that = this; that._logger('warn', message); } /** Displays an error in the console.*/ error(message) { const that = this; that._logger('error', message); } /** Logs an Error. @param {String} the error's level - 'warn', 'error' or 'log'. @param {Error} the error to be logged. */ _logger(level, error) { const that = this; if (that.debugMode) { const errorMessage = error instanceof Error ? error.message : error.toString(); console[level](errorMessage); } if (that.rethrowError && level === 'error') { throw error; } } /** * Gets if the element is currently focused. * * @return {Boolean}. */ get focused() { return this.contains(document.activeElement); } /** * Gets the element's HTML Template. * * @returns {String} - element's template. */ template() { return '<div></div>'; } /** Called when the element is registered. */ registered() { const that = this; if (that.onRegistered) { that.onRegistered(); } } /** Called when the element has been created. */ created() { const that = this; that.isReady = false; that._initElement(that); that._setModuleState('created'); if (that.onCreated) { that.onCreated(); } } /** Called when the element is rendered and configured. Use for one-time post configuration of your element. */ completed() { const that = this; that.isCompleted = true; if (that._onCompleted) { that._onCompleted(); } if (that.onCompleted) { that.onCompleted(); } } whenReady(callback) { const that = this; if (that.isCompleted) { callback(); return; } if (!that.whenReadyCallbacks) { that.whenReadyCallbacks = []; } that.whenReadyCallbacks.push(callback); } whenRendered(callback) { const that = this; if (that.isRendered) { callback(); return; } if (!that.whenRenderedCallbacks) { that.whenRenderedCallbacks = []; } that.whenRenderedCallbacks.push(callback); } addThemeClass() { const that = this; if (that.theme !== '') { that.classList.add('lw-' + that.theme); } } addDefaultClass() { const that = this; that.classList.add(namespace.toLowerCase() + '-element'); that.classList.add(that.nodeName.toLowerCase()); } _renderShadowRoot() { const that = this; if (that.shadowRoot) { that.$.root.classList.add(that.nodeName.toLowerCase()); for (let i = 0; i < that.attributes.length; i++) { const attribute = that.attributes[i]; if (attribute.name === 'class' || attribute.name === 'id' || attribute.name === 'style' || attribute.name === 'tabindex' || attribute.name.indexOf('aria') >= 0) { continue; } that.$.root.setAttribute(attribute.name, attribute.value); } for (let i = 0; i < that.classList.length; i++) { const className = that.classList[i]; if (className === 'lw-element-init' || className === 'lw-element' || className === 'lw-hidden' || className === 'lw-visibility-hidden') { continue; } that.$.root.classList.add(className); } } } render() { const that = this; if (!that.isRendered) { that.isRendered = true; that.isRendering = false; that.context = document; that._renderShadowRoot(); if (that.whenRenderedCallbacks) { for (let i = 0; i < that.whenRenderedCallbacks.length; i++) { that.whenRenderedCallbacks[i](); } that.whenRenderedCallbacks = []; } } if (that.onRender) { that.onRender(); } if (that.disabled) { that.setAttribute('aria-disabled', true); } if (that.readonly && ['checkbox', 'combobox', 'grid', 'gridcell', 'listbox', 'radiogroup', 'slider', 'spinbutton', 'textbox'].indexOf(that.getAttribute('role')) !== -1) { that.setAttribute('aria-readonly', true); } } /** Called when the element is ready. Use for one-time configuration of your element. */ ready() { const that = this; that._setId(); that.addThemeClass(); that.addDefaultClass(); if (that.visibility === 'collapsed') { that.classList.add('lw-hidden'); } else if (that.visibility === 'hidden') { that.classList.add('lw-visibility-hidden'); } if (that.dataContext) { that.applyDataContext(); } if (that.onReady) { that.onReady(); } if (that.shadowRoot && LW(that._selector)) { if (LW(that._selector).styleUrls) { const styleUrls = LW(that._selector).styleUrls; for (let i = 0; i < styleUrls.length; i++) { that.importStyle(styleUrls[i]); } } if (LW(that._selector).styles) { const scopedStyle = document.createElement('style'); scopedStyle.innerHTML = LW(that._selector).styles; that.shadowRoot.insertBefore(scopedStyle, that.shadowRoot.firstChild); } } if (LW(that._selector) && LW(that._selector).ready) { LW(that._selector).ready(); } } /** * Sets an id to the element if one is not provided by the user. */ _setId() { const that = this; if (!that.id) { const elementName = that.elementName; that.id = elementName.slice(0, 1).toLowerCase() + elementName.slice(1) + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); } } checkLicense() { const that = this; if (window[namespace].License === 'Evaluation' && window.location.hostname.indexOf('htmlelements') === -1) { that.logWatermark(); that.logLicense(); window[namespace].License = '' } } logWatermark() { //const that = this; const anchor = document.createElement('a'); const delay = 6000; anchor.href = 'https://www.htmlelements.com/'; anchor.innerHTML = 'https://www.htmlelements.com/'; anchor.style.position = 'absolute'; anchor.style.right = '5px'; anchor.style.bottom = '5px'; anchor.style.color = '#fff'; anchor.style.padding = '20px'; anchor.style.borderRadius = '5px'; anchor.style.background = '#0C3D78'; anchor.style.cursor = 'pointer'; anchor.style.zIndex = '999999'; anchor.style.display = 'block'; anchor.style.fontSize = '24px'; anchor.style.textDecoration = 'none'; anchor.style.fontWeight = 'bold'; anchor.style.opacity = 0; anchor.style.transition = 'opacity .35s ease-in-out'; anchor.id = 'watermark'; if (document.getElementById('watermark')) { return; } setTimeout(() => { if (document.getElementById('watermark')) { return; } document.body.appendChild(anchor); setTimeout(() => { anchor.style.opacity = 1; }); setTimeout(() => { anchor.style.opacity = 0; setTimeout(() => { anchor.parentNode.removeChild(anchor); }, 350); }, delay); }, 1000); } logLicense() { console.log('****************************************************************************************************************'); console.log('****************************************************************************************************************'); console.log('****************************************************************************************************************'); console.log('*LW HTML Elements License Key Not Found.'); console.log('*This is an evaluation only version, it is not licensed for development projects intended for production.'); console.log('*if you want to hide the watermark, please send an email to: sales@htmlelements.com for a license.'); console.log('****************************************************************************************************************'); console.log('****************************************************************************************************************'); console.log('****************************************************************************************************************'); } get _selector() { const that = this; if (that.id) { return '#' + that.id; } if (that.classList.length > 0) { return '.' + that.classList[0]; } return ''; } applyDataContext(dataContextObject) { const that = this; let dataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext; if (dataContextObject) { dataContext = dataContextObject; that.dataContext = dataContextObject; } if (!dataContext) { that.dataContextProperties = null; const lazyApplyDataContext = function () { const dataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext; if (dataContext) { that.applyDataContext(); window.removeEventListener('load', lazyApplyDataContext); } } window.addEventListener('load', lazyApplyDataContext); return; } if (!dataContext._uid) { dataContext._uid = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase(); dataContext._properties = []; for (let propertyName in dataContext) { const dataContextItem = dataContext[propertyName]; if (typeof dataContextItem === 'function' || propertyName === '_properties' || propertyName === '_uid') { continue; } dataContext._properties[propertyName] = dataContextItem; Object.defineProperty(dataContext, propertyName, { configurable: false, enumerable: true, get() { return dataContext._properties[propertyName]; }, set(value) { const oldValue = dataContext._properties[propertyName]; dataContext._properties[propertyName] = value; let changedProperties = []; changedProperties[propertyName] = { oldValue: oldValue, value: value }; changedProperties.length++; that.updatingDataContext = true; $document.fireEvent('dataContextPropertyChanged', { dataContext: dataContext, properties: changedProperties }, { bubbles: false, cancelable: true }); that.updatingDataContext = false; } }); } } that.dataContextProperties = that.parseAttributes(that); that.dataContextPropertiesMap = { }; that.dataContextListeners = { }; if (!that.dataContextProperties) { that.dataContextProperties = null; return; } that.updatingDataContext = true; for (let boundProperty in that.dataContextProperties) { const binding = that.dataContextProperties[boundProperty]; const name = binding.name; binding.propertyName = boundProperty; that.dataContextPropertiesMap[name] = boundProperty; if (!BindingModule.cache['toDash' + boundProperty]) { BindingModule.cache['toDash' + boundProperty] = Utilities.Core.toDash(name); } if (binding.isEvent) { const handlerName = binding.value; if (that.dataContextListeners[name]) { that.removeEventListener(name, that.dataContextListeners[name]); } that.dataContextListeners[name] = function (event) { dataContext[handlerName](event); }; that.addEventListener(name, that.dataContextListeners[name]); } if (name.indexOf('.') >= 0) { const path = name.split('.'); let dataBoundObject = dataContext[path[0]]; for (let i = 1; i < path.length; i++) { dataBoundObject = dataBoundObject[path[i]]; } if (dataBoundObject !== undefined) { that[boundProperty] = dataBoundObject; } } else { that[boundProperty] = dataContext[name]; } } that.dataContextPropertyChangedHandler = function (event) { const properties = event.detail.properties; const dataContext = event.detail.dataContext; const elementDataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext; if (dataContext === elementDataContext) { for (let property in properties) { const elementPropertyName = that.dataContextPropertiesMap[property]; const context = that.context; if (!elementPropertyName) { continue; } that.context = document; that[elementPropertyName] = properties[property].value; that.context = context; } } } $document.listen('dataContextPropertyChanged', that.dataContextPropertyChangedHandler); that.updatingDataContext = false; } updateDataContextProperty(propertyName) { const that = this; const dataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext; const boundProperty = that.dataContextProperties[propertyName]; if (that.updatingDataContext) { return; } if (boundProperty.twoWay) { const name = boundProperty.name; if (name.indexOf('.') >= 0) { const path = name.split('.'); let dataBoundObject = dataContext[path[0]]; for (let i = 1; i < path.length; i++) { dataBoundObject = dataBoundObject[path[i]]; } if (dataBoundObject !== undefined) { dataBoundObject = that[propertyName]; if (dataContextInfo[dataContext._uid]) { dataContextInfo[dataContext._uid][propertyName] = dataBoundObject; } } } else { dataContext[name] = that[propertyName]; if (dataContextInfo[dataContext._uid]) { dataContextInfo[dataContext._uid][propertyName] = dataContext[name]; } } } } static get version() { return window[namespace].Version; } initProperties() { const that = this; if (LW(that._selector) && LW(that._selector).properties) { that._initProperties = LW(that._selector).properties; } if (that.hasAttribute('props') && !that.props) { that._initProperties = window[that.getAttribute('props')]; } else if (that.props) { that._initProperties = that.props; } if (that._initProperties) { const propertyNames = Object.keys(that._initProperties); for (let i = 0; i < propertyNames.length; i++) { const propertyName = propertyNames[i]; const propertyValue = that._initProperties[propertyName] if (propertyValue.constructor === LW.ObservableArray || propertyValue instanceof LW.ObservableArray) { that[propertyName] = propertyValue.toArray(); continue; } if (propertyValue.constructor === LW.DataAdapter || propertyValue.constructor.name === 'lwDataAdapter' || (typeof propertyValue === 'object' && LW.DataAdapter && propertyValue instanceof LW.DataAdapter) || propertyValue instanceof LW.Observable || propertyValue.constructor === LW.Observable || typeof propertyValue !== 'object' || Utilities.Types.isArray(propertyValue)) { if (that[propertyName] === undefined && ['onReady', 'onAttached', 'onDetached', 'onCreated', 'onCompleted'].indexOf(propertyName) === -1) { const localizedError = that.localize('propertyUnknownName', { name: propertyName }); that.log(localizedError); } that[propertyName] = propertyValue; continue; } if (propertyName === 'messages') { that[propertyName] = propertyValue; continue; } if (typeof propertyValue === 'object') { const setHierarchicalProperty = function (propertyValue, path) { const subPropertyNames = Object.keys(propertyValue); for (let i = 0; i < subPropertyNames.length; i++) { const propertyName = subPropertyNames[i]; const subPropertyValue = propertyValue[propertyName] const property = that._properties[path + '_' + propertyName]; if (property && property.value === null) { if (that[path + '_' + propertyName] === undefined) { const localizedError = that.localize('propertyUnknownName', { name: path + '_' + propertyName }); that.log(localizedError); } that[path + '_' + propertyName] = subPropertyValue; continue; } if (typeof subPropertyValue === 'object' && !Utilities.Types.isArray(subPropertyValue) && subPropertyValue && subPropertyValue.constructor !== Date) { setHierarchicalProperty(subPropertyValue, path + '_' + propertyName); } else { if (that[path + '_' + propertyName] === undefined) { const localizedError = that.localize('propertyUnknownName', { name: path + '_' + propertyName }); that.log(localizedError); } that[path + '_' + propertyName] = subPropertyValue; } } } setHierarchicalProperty(propertyValue, propertyName); } } } } setup() { const that = this; that.context = this; if (that.isReady && !that.isCompleted) { return; } if (that.isReady) { that._setModuleState('attached'); that.isAttached = true; that.attached(); that._handleListeners('listen'); that.context = document; return; } if (that.ownerElement && that.ownerElement.detachedChildren.indexOf(that) >= 0) { that.ownerElement.detachedChildren.splice(that.ownerElement.detachedChildren.indexOf(that), 1); } that.isReady = true; that.methods = that.getStaticMember('methods'); that.initProperties(); const isMobile = Core.isMobile; if (isMobile) { that.classList.add('lw-mobile'); } /* Updates the properties by using the attribute values. */ for (let i = 0; i < that.attributes.length; i += 1) { const property = that.propertyByAttributeName[that.attributes[i].name]; if (!property) { continue; } let attributeValue = that.$.getAttributeValue(property.attributeName, property.type); const attributeValueString = attributeValue ? attributeValue.toString() : ''; if (attributeValueString.indexOf('{{') >= 0 || attributeValueString.indexOf('[[') >= 0) { continue; } if (property.type !== 'object' && property.type !== 'array') { if (that.attributes[i].value.indexOf('{{') >= 0 || that.attributes[i].value.indexOf('[[') >= 0) { continue; } } if (attributeValue !== undefined && property.value !== attributeValue) { const attributeValueType = Utilities.Types.getType(attributeValue); const attributeUntypedValue = that.attributes[i].value; if (property.type === 'any' || property.type === 'object') { if ('' + that[property.name] === attributeValue) { continue; } } if (property.type === 'array') { if (that[property.name] && JSON.stringify(that[property.name]) === attributeValue) { continue; } } if (attributeValueType === 'number' && isNaN(attributeValue) && attributeUntypedValue !== 'NaN' && attributeUntypedValue !== 'Infinity' && attributeUntypedValue !== '-Infinity') { const localizedError = that.localize('propertyInvalidValueType', { name: property.name, actualType: 'string', type: property.type }); that.log(localizedError); } property.isUpdatingFromAttribute = true; that[property.name] = attributeValue; property.isUpdatingFromAttribute = false; } } /* Set the default boolean and innerhtml attributes by using the property values. */ for (let propertyName in that._properties) { const property = that._properties[propertyName]; if (propertyName === 'innerHTML' && property.value === property.defaultValue) { property.value = property.defaultValue = Utilities.Core.html(that); } if (property.type === 'boolean' || property.type === 'bool') { if (that.getAttribute(property.attributeName) === 'false') { property.isUpdating = true; that.setAttribute(property.attributeName, ''); property.isUpdating = false; } } if (!property.defaultReflectToAttribute || !property.reflectToAttribute) { continue; } if (property.defaultReflectToAttribute && property.defaultReflectToAttributeConditions) { let reflectToAttribute = true; for (let i = 0; i < property.defaultReflectToAttributeConditions.length; i++) { const condition = property.defaultReflectToAttributeConditions[i]; let conditionName; let conditionValue; for (let name in condition) { conditionName = name; conditionValue = condition[name]; } if (that._properties[conditionName] && that._properties[conditionName].value !== conditionValue) { reflectToAttribute = false; } } if (!reflectToAttribute) { continue; } } property.isUpdating = true; that.$.setAttributeValue(property.attributeName, property.value, property.type); property.isUpdating = false; } const children = []; if (that.children.length > 0) { for (let i = 0; i < that.children.length; i++) { const node = that.children[i]; if (Utilities.Extend(node).isCustomElement) { children.push(node); } } } that.applyTemplate(); that.complete = function () { if (!that.templateBindingsReady) { const updateTemplateBindings = (node) => { if (node.templateBindingsReady) { return; } node.templateBindingsReady = true; node.updateTextNodes(); node.updateBoundNodes(); } if (!that.ownerElement) { updateTemplateBindings(that); } else { let owner = that.ownerElement; let owners = []; while (owner) { owners.push(owner); owner = owner.ownerElement; } for (let i = owners.length - 1; i >= 0; i--) { updateTemplateBindings(owners[i]); } updateTemplateBindings(that); } } const init = () => { that._setModuleState('ready'); that.ready(); if (that.renderMode === 'auto' && !that.isRendered) { that.render(); } that.isAttached = true; that._setModuleState('attached'); that.attached(); that._handleListeners('listen'); if (!that.isHidden) { if (that.offsetWidth === 0 || that.offsetHeight === 0) { that.isHidden = true; } } that.completed(); if (that.isRendered) { that.context = document; } if (that.whenReadyCallbacks) { for (let i = 0; i < that.whenReadyCallbacks.length; i++) { that.whenReadyCallbacks[i](); } that.whenReadyCallbacks = []; } } if (!that.wait) { if (!that.classList.contains('lw-async')) { const shadowParent = that.shadowParent; that.shadowParent = null; const parents = that.parents; that.shadowParent = shadowParent; if (parents.length === 0) { return; } const updateBindings = () => { let owner = that.ownerElement; let owners = []; while (owner) { owners.push(owner); owner = owner.ownerElement; } for (let i = owners.length - 1; i >= 0; i--) { owners[i].updateBoundMappedNodes(); } } if (!that.ownerElement || parents[parents.length - 1].nodeName === 'HTML') { init(); } else if (that.getRootNode().host) { init(); } else if (that.ownerElement && that.ownerElement.parents[that.ownerElement.parents.length - 1].nodeName === 'HTML') { updateBindings(); init(); } else { that.checkIsInDomInterval = setInterval(() => { const parents = that.parents; if (parents[parents.length - 1].nodeName === 'HTML') { clearInterval(that.checkIsInDomInterval); updateBindings(); init(); } }, 100); } } else { requestAnimationFrame(() => { init(); }); } } else { that.classList.add('lw-visibility-hidden'); } } // All of the registered elements inside the element's local DOM are ready, and have had their ready methods called. let templateNodes = [].slice.call(that.querySelectorAll('[lw-id]')).concat(children); if (window[namespace].EnableShadowDOM && that.isInShadowDOM !== true) { templateNodes = [].slice.call(that.shadowRoot.querySelectorAll('[lw-id]')).concat(children); } if (templateNodes.length === 0) { that.complete(); } else { that._completeListeners = 0; for (let i = 0; i < templateNodes.length; i++) { const node = templateNodes[i]; if (Utilities.Extend(node).isCustomElement) { const completeEventHandler = function () { that._completeListeners--; if (that._completeListeners === 0) { that.complete(); delete that._completeListeners; } }.bind(that); if (!node.isCompleted && !node.isUtilityElement && node.wait !== true) { that._completeListeners++; if (!node._onCompleted) { node.completeHandlers = []; node._onCompleted = function () { for (let i = 0; i < node.completeHandlers.length; i++) { node.completeHandlers[i](); } } } node.completeHandlers.push(completeEventHandler); } } } if (that._completeListeners === 0) { that.complete(); } } } visibilityChangedHandler() { const that = this; if (!that.isReady) { return; } requestAnimationFrame(() => { if (that.offsetWidth === 0 || that.offsetHeight === 0) { that.isHidden = true; } else { that.isHidden = false; that.$.fireEvent('resize', that, { bubbles: false, cancelable: true }); } }); } /** Called when an attribute is changed. */ attributeChangedCallback(name, oldValue, newValue) { const that = this; const property = that.propertyByAttributeName[name]; if (name === 'class' || name === 'style') { that.visibilityChangedHandler(); } if (!property) { that.attributeChanged(name, oldValue, newValue); } if (!property || (property && property.isUpdating)) { return; } let newPropertyValue = that.$.getAttributeValue(property.attributeName, property.type); if (newValue !== undefined && that[property.name] !== newPropertyValue) { property.isUpdatingFromAttribute = true; if (newPropertyValue !== undefined) { that[property.name] = newPropertyValue; } else { that[property.name] = that._properties[property.name].defaultValue; } property.isUpdatingFromAttribute = false; } } /** Called when one of the element's attributes is changed. Use to handle attribute changes that don't correspond to declared properties. */ attributeChanged(name, oldValue, newValue) { if (oldValue !== newValue) { /* attribute change handling logic here. */ } } set hasStyleObserver(value) { const that = this; if (that._hasStyleObserver === undefined) { that._hasStyleObserver = value; } if (value) { StyleObserver.watch(that); } else { StyleObserver.unwatch(that); } } get hasStyleObserver() { const that = this; if (that._hasStyleObserver !== undefined) { return that._hasStyleObserver; } return true; } /** Called after the element is attached to the document. Can be called multiple times during the lifetime of an element. */ attached() { const that = this; if (that.hasStyleObserver) { StyleObserver.watch(that); } if (that.onAttached) { that.onAttached(); } if (LW(that._selector) && LW(that._selector).attached) { LW(that._selector).attached(); } } /** Called after the element is detached from the document. Can be called multiple times during the lifetime of an element. */ detached() { const that = this; if (that.hasStyleObserver) { StyleObserver.unwatch(that); } that._setModuleState('detached'); that.isAttached = false; if (that.ownerElement && that.ownerElement.detachedChildren.indexOf(that) === -1) { that.ownerElement.detachedChildren.push(that); } that._handleListeners('unlisten'); if (that.onDetached) { that.onDetached(); } if (LW(that._selector) && LW(that._selector).detached) { LW(that._selector).detached(); } } /** Called when a property value is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (oldValue === newValue) { return; } if (propertyName === 'theme') { if (oldValue !== '') { that.classList.remove('lw-' + oldValue); } if (newValue !== '') { that.classList.add('lw-' + newValue); } } if (propertyName === 'visibility') { if (oldValue === 'collapsed') { that.classList.remove('lw-hidden'); } else if (oldValue === 'hidden') { that.classList.remove('lw-visibility-hidden'); } if (newValue === 'collapsed') { that.classList.add('lw-hidden'); } else if (newValue === 'hidden') { that.classList.add('lw-visibility-hidden'); } } else if (propertyName === 'disabled') { that._ariaPropertyChangedHandler(propertyName, newValue); } else if (propertyName === 'readonly') { that._ariaPropertyChangedHandler(propertyName, newValue); } if (that.propertyChanged) { that.propertyChanged(propertyName, oldValue, newValue); } /* Property changed logic goes here. */ } _ariaPropertyChangedHandler(propertyName, newValue) { const that = this; if (propertyName === 'readonly' && ['checkbox', 'combobox', 'grid', 'gridcell', 'listbox', 'radiogroup', 'slider', 'spinbutton', 'textbox'].indexOf(that.getAttribute('role')) === -1) { return; } if (newValue) { that.setAttribute('aria-' + propertyName, true); } else { that.removeAttribute('aria-' + propertyName); } } _handleListeners(action) { const that = this; const tagName = that.tagName.toLowerCase(); const listeners = that.getStaticMember('listeners'); const processListeners = (listeners) => { for (let listener in listeners) { const path = listener.split('.'); let eventType = path[0]; let element = that.$; if (path[1]) { eventType = path[1]; element = that['$' + path[0]]; if (path[0] === 'document') { let id = that.lwId; if (id === '') { id = Utilities.Core.toCamelCase(tagName); } eventType = eventType + '.' + id; } else if (that.lwId) { eventType = eventType + '.' + that.lwId + '_' + that.parents.length; } } else if (that.lwId) { eventType = eventType + '.' + that.lwId; } const handlerName = listeners[listener]; const handler = function (event) { const context = that.context; that.context = that; if (that[handlerName]) { that[handlerName].apply(that, [event]); } that.context = context; } if (!element) { continue; } element[action](eventType, handler); } } processListeners(listeners); processListeners(that.templateListeners); if (LW(that._selector) && LW(that._selector).properties) { processListeners(LW(that._selector).listeners); } } /** Parses the element's template. */ parseTemplate() { const that = this; const template = that.template(); const fragment = document.createDocumentFragment(); if (templates[that.nodeName] && !isEdge) { return templates[that.nodeName].cloneNode(true); } if (template === '') { return null; } /* Create a wrapper DIV tag. */ let tmpElement = document.createElement('div'); fragment.appendChild(tmpElement); /* Fill the nodes array with the wrapper's childNodes. */ tmpElement.innerHTML = template; let nodes = tmpElement.childNodes; /* Remove the wrapper DIV tag. */ tmpElement.parentNode.removeChild(tmpElement); /* Add the nodes to the fragment. */ for (let i = 0; i < nodes.length; i++) { fragment.appendChild(nodes[i]); } templates[that.nodeName] = fragment; return !isEdge ? fragment.cloneNode(true) : fragment; } applyTemplate() { const that = this; const template = that.parseTemplate(); if (!template) { return; } //const template = document.importNode(templateElement, true); if (!template.hasChildNodes) { return; } const rootElement = template.childNodes[0]; const map = (name, element) => { that['$' + name] = element.$ = Utilities.Extend(element); that.$[name] = element; element.ownerElement = that; }; /* Create a content element. */ let contentElement = rootElement; if (rootElement.getElementsByTagName('content').length > 0) { let contentInsertionPoint = rootElement.getElementsByTagName('content')[0]; contentElement = contentInsertionPoint.parentNode; contentElement.removeChild(contentInsertionPoint); } else { const preudoContentElement = template.querySelectorAll('[inner-h-t-m-l]'); if (preudoContentElement && preudoContentElement.length > 0) { contentElement = preudoContentElement[0]; } } that.$.template = rootElement.nodeName.toLowerCase() === 'template' ? rootElement : rootElement.querySelector('template'); /* Build nodes map. */ let templateNodes = template.querySelectorAll('[id]'); if (templateNodes.length === 0) { templateNodes = template.querySelectorAll('*'); } map('root', rootElement); map('content', contentElement); that.$.html = that.innerHTML.toString().trim(); for (let i = 0; i < templateNodes.length; i += 1) { let templateNode = templateNodes[i]; if (templateNode.id === '') { templateNode.id = 'child' + i; } map(templateNode.id, templateNode); templateNode.setAttribute('lw-id', templateNode.id); if (!that.shadowRoot) { templateNode.removeAttribute('id'); } else { templateNode.shadowParent = that; } } if (that.hasTemplateBindings !== false) { that.bindings = that.getBindings(template); } else { that.bindings = []; } that.$root.addClass('lw-container'); /* Move element's initial nodes to the content element. */ while (that.childNodes.length) { contentElement.appendChild(that.firstChild); } /* Append the template. */ that.appendTemplate(template); if (that.$.template) { const templateContainer = document.createElement('div'); templateContainer.classList.add('lw-template-container'); that.$.templateContainer = templateContainer; that.$.template.parentNode.insertBefore(templateContainer, that.$.template); that.refreshTemplate(); } } refreshTemplate() { const that = this; if (!that.$.templateContainer) { return; } that.templateDetached(that.$.templateContainer); const templateContent = that.$.template.content.cloneNode(true); that.templateBindings = that.getBindings(templateContent); that.templateProperties = []; let fragment = document.createDocumentFragment(); const applyBindings = function (boundChildren, ownerElement, item) { for (let childIndex in boundChildren) { const child = boundChildren[childIndex]; const node = child.node.cloneNode(); ownerElement.appendChild(node); let array = []; let hasArray = false; if (child.data) { for (let templatePropertyName in child.data) { const data = child.data[templatePropertyName]; const hostPropertyName = data.name; that.templateProperties[hostPropertyName] = true; node.removeAttribute(Utilities.Core.toDash(templatePropertyName)); if (templatePropertyName === '*items') { array = that[hostPropertyName]; hasArray = true; } else if (hostPropertyName.indexOf('item.') >= 0 && item !== undefined) { data.value = item[hostPropertyName.substring('item.'.length)]; node[templatePropertyName] = data.value; } else if (hostPropertyName.indexOf('item') >= 0 && item !== undefined) { data.value = item; node[templatePropertyName] = data.value; } else if (templatePropertyName === '*if') { if (hostPropertyName.indexOf('(') >= 0) { let args = hostPropertyName.substring(hostPropertyName.indexOf('(')); let result; const methodName = hostPropertyName.substring(0, hostPropertyName.indexOf('(')); args = args.substring(1, args.length - 1); args = args.replace(/ /ig, ''); args = args.split(','); if (args.length > 0 && args[0] !== '') { let values = []; for (let i = 0; i < args.length; i++) { values.push(that[args[i]]); } result = that[methodName].apply(that, values); } else { result = that[methodName](); } if (false === result) { ownerElement.removeChild(node); } } else if (!that[hostPropertyName]) { ownerElement.removeChild(node); } } else { that.updateBoundNode(node, child, that, hostPropertyName); } } } if (array.length > 0 || hasArray) { for (let i = 0; i < array.length; i++) { if (child.children) { applyBindings(child.children, node, array[i]); } } if (typeof array === 'number') { for (let i = 0; i < array; i++) { if (child.children) { applyBindings(child.children, node, i); } } } } else { if (child.children) { applyBindings(child.children, node, item); } } } } applyBindings(that.templateBindings.children, fragment); that.$.templateContainer.innerHTML = ''; that.$.templateContainer.appendChild(fragment); that.templateAttached(that.$.templateContainer); } templateAttached() { } templateDetached() { } appendTemplate(template) { const that = this; that.appendChild(template); } /** Defines the custom element's default modules. The function is called once when the element's script file is referred. */ defineElementModules() { const that = this; const proto = that.constructor.prototype; if (proto.elementName === 'BaseElement') { proto.modules = that.constructor.modules; const modules = proto.modules; for (let i = 0; i < modules.length; i += 1) { that.addModule(modules[i]); } } else { const modules = proto.modules; for (let i = 0; i < modules.length; i += 1) { const module = modules[i]; const proto = module.prototype; that.defineElementMethods(proto.methodNames, proto); that.defineElementProperties(module.properties); } } } watch(properties, propertyChangedCallback) { const that = this; if (properties === null || propertyChangedCallback === null) { that._watch = null; return; } that._watch = { properties: properties, propertyChangedCallback: propertyChangedCallback } } unwatch() { const that = this; that._watch = null; } set(propertyName, value, notify) { const that = this; const context = that.context; if (notify === true) { that.context = document; } else { that.context = that; } that[propertyName] = value; that.context = context; } get(propertyName) { const that = this; return that[propertyName]; } _setModuleState(stateName, args) { const that = this; const statusName = 'is' + stateName.substring(0, 1).toUpperCase() + stateName.substring(1); const callbackName = 'on' + stateName.substring(0, 1).toUpperCase() + stateName.substring(1); for (let i = 0; i < that.modulesList.length; i++) { const module = that.modulesList[i]; module[statusName] = true; if (module[stateName]) { module[stateName](args); } if (module[callbackName]) { module[callbackName](args); } } } /** * Adds a module to the the element. Module's methods and properties are mixed into the element's prototype. * @param {Object}. */ addModule(module, subclasses) { const that = this; if (!module) { return; } const modules = that.modules.slice(0); const proto = module.prototype; const baseProto = Object.getPrototypeOf(module); if (baseProto.name && baseProto.name !== module.name) { that.addModule(baseProto); } if (!module.moduleName && module.name) { module.moduleName = module.name; } if (modules.findIndex(currentModule => module.moduleName === currentModule.moduleName) === -1) { modules.push(module); } that.defineModule(module); that.defineElementMethods(proto.methodNames, proto); that.defineElementProperties(module.properties); const elementProto = that.constructor.prototype; elementProto.modules = modules; if (subclasses) { for (let tagName in LW.Elements.tagNames) { const element = LW.Elements.tagNames[tagName]; let baseProto = Object.getPrototypeOf(element); let protoChain = []; while (baseProto !== HTMLElement) { protoChain.push(baseProto.prototype); baseProto = Object.getPrototypeOf(baseProto); } if (protoChain.indexOf(that) >= 0 && element !== that) { element.prototype.addModule(module); } } } } /** Defines a module and creates its properties. */ defineModule(module) { if (module.isDefined) { return; } module.prototype._initModule = function (element) { const that = this; that.ownerElement = element; } const properties = module.properties || { }; const propertyNames = Object.keys(properties); const methodNames = Object.getOwnPropertyNames(module.prototype); module.prototype.methodNames = methodNames; for (let j = 0; j < propertyNames.length; j += 1) { const propertyName = propertyNames[j]; const property = properties[propertyName]; Object.defineProperty(module.prototype, propertyName, { configurable: false, enumerable: true, get() { const that = this; if (!that.ownerElement) { return property.value; } return that.ownerElement[propertyName]; }, set(value) { const that = this; that.ownerElement[propertyName] = value; } }); } module.isDefined = true; } getStaticMember(memberName, memberType) { const that = this; const element = window[namespace][that.elementName]; const staticMember = element[memberName]; if (!memberType) { memberType = ''; } let inheritedStaticMember = (memberType === 'array') ? [] : (memberType === 'string' ? '' : { }); let baseProto = Object.getPrototypeOf(element); let protoChain = []; while (baseProto[memberName]) { protoChain.push(baseProto[memberName]); baseProto = Object.getPrototypeOf(baseProto); } for (let i = protoChain.length - 1; i >= 0; i--) { if (memberType === 'array') { for (let j = 0; j < protoChain[i].length; j++) { if (inheritedStaticMember.indexOf(protoChain[i][j]) === -1) { inheritedStaticMember.push(protoChain[i][j]); } } } else if (memberType === 'string') { if (inheritedStaticMember.indexOf(protoChain[i]) === -1) { inheritedStaticMember += protoChain[i]; } } else { inheritedStaticMember = Utilities.Core.assign(inheritedStaticMember, protoChain[i]); } } if (memberType === 'array') { for (let j = 0; j < staticMember.length; j++) { if (inheritedStaticMember.indexOf(staticMember[j]) === -1) { inheritedStaticMember.push(staticMember[j]); } } return inheritedStaticMember; } if (memberType === 'string') { if (inheritedStaticMember.indexOf(staticMember) === -1) { inheritedStaticMember += staticMember; } return inheritedStaticMember; } return Utilities.Core.assign(inheritedStaticMember, staticMember); } defineElementHierarchicalProperties(properties, context) { const that = this; const propertyObjectsTree = []; const buildPropertyObjects = function (properties) { const propertyNames = Object.keys(properties); for (let i = 0; i < propertyNames.length; i++) { const parentPropertyName = propertyNames[i]; if (parentPropertyName === 'messages') { continue; } const parentProperty = properties[parentPropertyName]; const propertyKeys = Object.keys(parentProperty); const isPropertyObject = propertyKeys.indexOf('value') >= 0 && propertyKeys.indexOf('type') >= 0 && typeof parentProperty.value === 'object'; if (parentProperty.type === 'propertyObject' || isPropertyObject) { const buildPropertyObject = function (parentProperty, parentPropertyName) { if (!parentProperty.value) { return; } const propertyNames = Object.keys(parentProperty.value); for (let j = 0; j < propertyNames.length; j++) { const propertyName = propertyNames[j]; const property = parentProperty.value[propertyName]; const subPropertyName = parentPropertyName + '_' + propertyName; if (typeof property !== 'object' || property === null) { break; } const propertyKeys = Object.keys(property); const isPropertyObject = propertyKeys.indexOf('value') >= 0 && propertyKeys.indexOf('type') >= 0; if (!isPropertyObject) { break; } if (parentProperty.type !== 'array') { parentProperty.isHierarchicalProperty = true; } property.parentPropertyName = parentPropertyName; if (context) { const elementProperty = context._properties[subPropertyName]; if (parentProperty.value.hasOwnProperty(propertyName)) { if (!elementProperty.isDefined) { delete parentProperty.value[propertyName]; } else { continue; } } elementProperty.isDefined = true; Object.defineProperty(parentProperty.value, propertyName, { configurable: false, enumerable: true, get() { return context._properties[subPropertyName].value; }, set(value) { context.updateProperty(context, context._properties[subPropertyName], value); } }); } if (!propertyObjectsTree[subPropertyName]) { propertyObjectsTree[subPropertyName] = property; propertyObjectsTree.length++; } if (property.type === 'propertyObject' || typeof property.value === 'object' && property.type !== 'array') { if (context) { buildPropertyObject(context._properties[subPropertyName], subPropertyName); } else { buildPropertyObject(property, subPropertyName); } } } } buildPropertyObject(parentProperty, parentPropertyName); } } } buildPropertyObjects(properties); if (propertyObjectsTree.length > 0 && !context) { that.defineElementProperties(propertyObjectsTree); } } /** Defines the element properties, methods and modules. */ defineElement() { const that = this; const proto = that.constructor.prototype; const properties = that.getStaticMember('properties'); const methods = Object.getOwnPropertyNames(proto); proto.extendedProperties = { }; proto.boundProperties = { }; proto.templateListeners = { }; that.defineElementModules(); that.defineElementMethods(methods, proto); that.defineElementProperties(properties); that.defineElementHierarchicalProperties(that.extendedProperties); /* Initialization of element's instance properties. */ proto._initElement = function () { const that = this; const properties = proto.extendedProperties; const propertyNames = Object.keys(properties); const modules = that.modules; that.$ = Utilities.Extend(that); that.$document = $document; that.lwId = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase(); if (!that.isCreated) { that.modulesList = []; that._properties = []; if (that._beforeCreatedProperties) { that._properties = that._beforeCreatedProperties; delete that._beforeCreatedProperties; } that.detachedChildren = []; that.propertyByAttributeName = []; } for (let i = 0; i < modules.length; i += 1) { const module = modules[i]; let moduleInstance = new module(); moduleInstance._initModule(that); that.modulesList.push(moduleInstance); } for (let i = 0; i < propertyNames.length; i += 1) { const propertyName = propertyNames[i]; const property = properties[propertyName]; let defaultValue = property.value; if (that._properties[propertyName]) { if (that._properties[propertyName].notify !== undefined) { continue; } else { delete that._properties[propertyName]; } } if (isOldChrome && propertyName === 'innerHTML') { delete that[propertyName]; } if (window.navigator.userAgent.indexOf('PhantomJS') === -1 && that.hasOwnProperty(propertyName)) { defaultValue = that[propertyName]; delete that[propertyName]; } if (property.type === 'array' && defaultValue !== undefined && defaultValue !== null) { defaultValue = defaultValue.slice(0); } if (property.type === 'object' && defaultValue !== undefined && defaultValue !== null) { if (Array.isArray(defaultValue)) { defaultValue = defaultValue.slice(0); } else { defaultValue = Object.assign({ }, defaultValue); } } that._properties[propertyName] = { name: propertyName, notify: property.notify, allowedValues: property.allowedValues, type: property.type, nullable: property.nullable, reflectToAttribute: property.reflectToAttribute, defaultReflectToAttribute: property.defaultReflectToAttribute, defaultReflectToAttributeConditions: property.defaultReflectToAttributeConditions, value: defaultValue, readOnly: property.readOnly, defaultValue: defaultValue, attributeName: property.attributeName, observer: property.observer, inherit: property.inherit, extend: property.extend, validator: property.validator } that.propertyByAttributeName[property.attributeName] = that._properties[propertyName]; if (!property.hasOwnProperty('type')) { const localizedError = that.localize('propertyUnknownType', { name: propertyName }); that.log(localizedError); } if (property.type === 'any' || property.type === 'propertyObject') { continue; } const defaultValueType = Utilities.Types.getType(defaultValue); if (defaultValue !== undefined && defaultValue !== null && property.type !== defaultValueType && !property.validator) { if (property.type === 'object' && defaultValueType === 'array') { continue; } if (defaultValueType === 'number') { const types = ['integer', 'int', 'float']; const propertyIndex = types.findIndex(type => type === property.type); if (propertyIndex >= 0) { continue; } } const localizedError = that.localize('propertyInvalidValueType', { name: propertyName, actualType: defaultValueType, type: property.type }); that.log(localizedError); } } that.defineElementHierarchicalProperties(that._properties, that); that.isCreated = true; }; /* Calls the registered method. It is useful for one-time configuration. */ proto.registered(); } /** * Defines Element's methods. * {Array} - methods. * {Object} - method owner's prototype. */ defineElementMethods(methods, proto) { const that = this; const elementProto = that.constructor.prototype; const invokeMethod = function (method, methodName) { const args = Array.prototype.slice.call(arguments, 2); const elementMethod = function () { /* Raise an exception when the method is invoked while the element is not in Ready state. */ if (!this.isReady && methodName !== 'localize' && methodName !== 'localize' && methodName !== 'cloneNode' && methodName !== 'importStyle' && methodName !== 'log' && methodName !== 'parseAttributes') { const localizedError = this.localize('elementNotInDOM'); this.log(localizedError); } let methodContext = this; for (let i = 0; i < this.modulesList.length; i++) { let module = this.modulesList[i]; if (methodName in module) { methodContext = module; break; } } const context = this.context; const methodArguments = args.concat(Array.prototype.slice.call(arguments)); let methodReturnType = null; const areTypesEqual = function (typeA, typeB) { if (typeA === typeB) { return true; } if (typeA === 'number' && (typeB === 'int' || typeB === 'integer' || typeB === 'float')) { return true; } if ((typeA === 'bool' && typeB === 'boolean') || (typeA === 'boolean' && typeB === 'bool')) { return true; } if (typeA === 'object' && typeB === 'any') { return true; } } if (this['methods']) { const methodMetaInformation = this['methods'][methodName]; if (methodMetaInformation) { const methodSplitParts = methodMetaInformation.split(':'); methodReturnType = methodSplitParts[methodSplitParts.length - 1].trim(); const metaArguments = methodMetaInformation.substring(1 + methodMetaInformation.indexOf('('), methodMetaInformation.lastIndexOf(')')); const metaArgumentsList = []; const metaArgumentsSplit = metaArguments.split(','); let argument = ''; for (let i = 0; i < metaArgumentsSplit.length; i++) { const metaArgument = metaArgumentsSplit[i]; argument += metaArgument; if (metaArgument.indexOf(':') >= 0) { metaArgumentsList.push(argument); argument = ''; } else { argument += ','; } } let metaArgumentsListRequiredCount = metaArgumentsList.length; for (let m = 0; m < metaArgumentsList.length; m++) { const metaArgumentString = metaArgumentsList[m].trim(); const metaArgumentSplitParts = metaArgumentString.split(':'); const metaArgumentName = metaArgumentSplitParts[0].split('=')[0].trim(); const metaArgumentOptional = metaArgumentName.indexOf('?') >= 0; const metaArgumentNullableType = metaArgumentSplitParts[1].indexOf('?') >= 0; const metaArgumentType = metaArgumentSplitParts[1].replace(/\?/ig, '').trim(); const metaArgumentTypes = metaArgumentType.split('|'); let metaArgumentDefaultValue = metaArgumentSplitParts[0].split('=')[1]; const callerArgumentType = Utilities.Types.getType(methodArguments[m]); if (undefined === methodArguments[m] && metaArgumentDefaultValue) { metaArgumentDefaultValue = metaArgumentDefaultValue.trim(); switch (metaArgumentType[0]) { case 'date': { let dateObjectArguments = metaArgumentDefaultValue.substring(metaArgumentDefaultValue.indexOf('(') + 1, metaArgumentDefaultValue.lastIndexOf(')')); dateObjectArguments = dateObjectArguments.length > 0 ? dateObjectArguments.split(',').map(arg => parseInt(arg)) : []; metaArgumentDefaultValue = dateObjectArguments.length === 0 ? new Date() : new Date(dateObjectArguments[0], dateObjectArguments[1], dateObjectArguments[2]); break; } case 'bool': case 'boolean': metaArgumentDefaultValue = metaArgumentDefaultValue === 'true' || metaArgumentDefaultValue === '1' ? true : false; break; case 'int': case 'integer': metaArgumentDefaultValue = parseInt(metaArgumentDefaultValue); break; case 'float': case 'number': metaArgumentDefaultValue = parseFloat(metaArgumentDefaultValue); break; case 'any': case 'object': metaArgumentDefaultValue = metaArgumentDefaultValue.indexOf('{') >= 0 ? JSON.parse(metaArgumentDefaultValue) : metaArgumentDefaultValue; break; } methodArguments.push(metaArgumentDefaultValue); } else if (metaArgumentOptional) { metaArgumentsListRequiredCount--; } if (metaArgumentType !== callerArgumentType && callerArgumentType) { let isInvalidValueType = true; for (let i = 0; i < metaArgumentTypes.length; i++) { if (areTypesEqual(callerArgumentType, metaArgumentTypes[i])) { isInvalidValueType = false; break; } } if (isInvalidValueType && !(methodArguments[m] === null && metaArgumentNullableType)) { const localizedError = this.localize('methodInvalidValueType', { name: methodName, actualType: callerArgumentType, type: metaArgumentType, argumentIndex: m }); this.log(localizedError); } } if (methodArguments.length < metaArgumentsListRequiredCount) { const localizedError = this.localize('methodInvalidArgumentsCount', { name: methodName, actualArgumentsCount: methodArguments.length, argumentsCount: metaArgumentsListRequiredCount }); this.log(localizedError); } } } } this.context = this; const result = method.apply(methodContext, methodArguments); if (methodReturnType) { const actualReturnType = Utilities.Types.getType(result) === undefined ? 'void' : Utilities.Types.getType(result); if (!areTypesEqual(actualReturnType, methodReturnType)) { const localizedError = this.localize('methodInvalidReturnType', { name: methodName, actualType: actualReturnType, type: methodReturnType }); this.log(localizedError); } } this.context = context; return result; }; return elementMethod; } /* Exclude these methods. */ const excludeMethods = ['constructor', 'ready', 'created', 'render', 'attached', 'detached', 'appendChild', 'insertBefore', 'removeChild', 'connect', 'disconnectedCallback', 'connectedCallback', 'attributeChangedCallback', 'propertyChangedHandler', 'enableShadowDOM', 'isInShadowDOM', 'addPropertyBindings']; /* Wrap Custom Element's methods. */ for (let index in methods) { let methodName = methods[index]; if (methodName.startsWith('_') || excludeMethods.find( excludeMethodName => excludeMethodName === methodName) !== undefined) { continue; } if (elementProto.extendedProperties[methodName]) continue; if (!Utilities.Types.isFunction(proto[methodName])) continue; elementProto[methodName] = invokeMethod(proto[methodName], methodName); } } /** Defines the custom element's properties. The function is called once when an element's script file is referred. */ defineElementProperties(properties) { if (!properties) { return; } const that = this; const proto = that.constructor.prototype; const propertyNames = Object.keys(properties); const defaultProperties = that.getStaticMember('properties'); Object.assign(proto.extendedProperties, properties); /* Called when a property is set. Updates the property and synchronizes with the attribute. */ that.updateProperty = function (context, property, value) { const that = context; if (!property || property.readOnly) { return; } /* Raises an exception when the new value is not in the allowedValues list. */ if (property.allowedValues) { let isValidValue = false; for (let i = 0; i < property.allowedValues.length; i++) { if (property.allowedValues[i] === value) { isValidValue = true; break; } } if (!isValidValue) { const allowedValuesString = JSON.stringify(property.allowedValues).replace(/\[|\]/gi, '').replace(',', ', ').replace(/"/gi, '\''); const actualValueString = '\'' + value + '\''; const localizedError = that.localize('propertyInvalidValue', { name: property.name, actualValue: actualValueString, value: allowedValuesString }); that.log(localizedError); return; } } const propertyName = property.name; const oldValue = that._properties[propertyName].value; /* Calls the property's validator, if defined. */ if (property.validator) { if (that[property.validator]) { const context = that.context; that.context = that; const validatedResult = that[property.validator](oldValue, value); if (validatedResult !== undefined) { value = validatedResult; } that.context = context; } } if (oldValue === value) { return; } if (that.propertyChanging) { const canChangeProperty = that.propertyChanging(propertyName, oldValue, value); if (canChangeProperty === false || canChangeProperty === null) { return; } } if (!property.hasOwnProperty('type')) { const localizedError = that.localize('propertyUnknownType', { name: propertyName }); that.log(localizedError); } if ((property.type === 'array') && JSON.stringify(oldValue) === JSON.stringify(value)) { return; } if ((value !== undefined && value !== null && property.type !== 'any' && property.type !== 'propertyObject' && property.type !== Utilities.Types.getType(value) && !property.validator) || (value === null && !property.nullable)) { let throwError = true; if (property.type === 'object' && Utilities.Types.getType(value) === 'array') { throwError = false; } if (Utilities.Types.getType(value) === 'number') { const types = ['integer', 'int', 'float']; const propertyIndex = types.findIndex(type => type === property.type); if (propertyIndex >= 0) { throwError = false; } } if (throwError) { const localizedError = that.localize('propertyInvalidValueType', { name: propertyName, actualType: Utilities.Types.getType(value), type: property.type }); that.error(localizedError); return; } } property.isUpdating = true; if (property.isHierarchicalProperty) { const setHierarchicalProperty = function (propertyValue, path) { const subPropertyNames = Object.keys(propertyValue); for (let i = 0; i < subPropertyNames.length; i++) { const propertyName = subPropertyNames[i]; const subPropertyValue = propertyValue[propertyName] if (typeof subPropertyValue === 'object' && !Utilities.Types.isArray(subPropertyValue) && subPropertyValue && subPropertyValue.constructor !== Date) { setHierarchicalProperty(subPropertyValue, path + '_' + propertyName); } else { that[path + '_' + propertyName] = subPropertyValue; } } } setHierarchicalProperty(value, propertyName); } else { that._properties[propertyName].value = value; } /* Updates the element's attribute value. */ if (!property.isUpdatingFromAttribute && property.reflectToAttribute) { that.$.setAttributeValue(property.attributeName, value, property.type); } /* Calls the element's propertyChangedHandler function when the element is in Ready state and the property is observed. */ const isReady = that.isReady && (!that.ownerElement || (that.ownerElement && that.ownerElement.isReady)); if (isReady) { if (propertyName === 'wait') { if (!value && oldValue && !that.isCompleted) { that.classList.remove('lw-visibility-hidden'); if (that.ownerElement) { that.ownerElement.updateBoundMappedNodes(); } that.updateBoundMappedNodes(); that.complete(); } } if (propertyName === 'renderMode') { return; } if (that.context !== that && !that.wait) { /* Setting context to that prevents calling propertyChangedHandler, if the custom element's developer * sets another element property within the propertyChangedHandler. */ const context = that.context; that.context = that; that.propertyChangedHandler(propertyName, oldValue, value); that.context = context; /* Calls the property's observer, if defined. */ if (property.observer) { if (that[property.observer]) { that.context = that; that[property.observer](oldValue, value); that.context = document; } } if (that._watch && that._watch.properties.indexOf(propertyName) >= 0) { that._watch.propertyChangedCallback(propertyName, oldValue, value); } } /* Dispatch an event when property's notify member is set. */ const notify = property.notify || that.boundProperties[propertyName]; if (notify) { that.$.fireEvent(property.attributeName + '-changed', { context: that.context, oldValue: oldValue, value: that[propertyName] }); if (that.boundProperties[propertyName]) { that.updateBoundNodes(propertyName); } } if (notify && that.templateProperties && that.templateProperties[propertyName]) { that.refreshTemplate(); } if (that.dataContextProperties) { if (propertyName === 'dataContext') { that.applyDataContext(); } else if (that.dataContextProperties[propertyName]) { that.updateDataContextProperty(propertyName); } } } property.isUpdating = false; } /* Defines element's properties. */ for (let i = 0; i < propertyNames.length; i += 1) { const propertyName = propertyNames[i]; const property = properties[propertyName]; const attributeName = Utilities.Core.toDash(propertyName); const type = property.type || 'any'; const nullable = type.indexOf('?') >= 0 || type === 'any'; if (nullable && type !== 'any') { property.type = type.substring(0, type.length - 1) } property.nullable = nullable; property.attributeName = attributeName.toLowerCase(); property.name = propertyName; property.reflectToAttribute = property.reflectToAttribute !== undefined ? property.reflectToAttribute : true; if (property.inherit && defaultProperties[propertyName]) { property.value = defaultProperties[propertyName].value; } if (property.extend && defaultProperties[propertyName]) { Utilities.Core.assign(property.value, defaultProperties[propertyName].value); } if (proto.hasOwnProperty(propertyName)) { continue; } Object.defineProperty(proto, propertyName, { configurable: false, enumerable: true, get() { const that = this; if (!that._properties[propertyName]) { return undefined; } return that._properties[propertyName].value; }, set(value) { const that = this; that.updateProperty(that, that._properties[propertyName], value); } }); } } } let customElements = []; let registeredCallbacks = []; let registeredLoadedCallbacks = []; let isOldChrome = false; const chromeAgent = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./); if (chromeAgent) { const chromeVersion = parseInt(chromeAgent[2], 10); if (chromeVersion <= 50) { isOldChrome = true; } } class BaseCustomElement extends BaseElement { static get observedAttributes() { let that = this; let observedAttributes = ['external-style']; for (let propertyName in that.prototype.extendedProperties) { const propertyConfig = that.prototype.extendedProperties[propertyName]; observedAttributes.push(propertyConfig.attributeName); } return observedAttributes; } static get styleUrls() { return [ ] } static get styles() { return ''; } get styleUrl() { //const that = this; return this._styleUrl; } set styleUrl(path) { this._styleUrl = path; } get isInShadowDOM() { const that = this; return that.getRootNode() !== document; } getShadowRootOrBody() { const that = this; if (that.isInShadowDOM) { return that.getRootNode().host.shadowRoot; } return document.body; } get enableShadowDOM() { //const that = this; const enableShadowDOM = window[namespace].EnableShadowDOM; return enableShadowDOM; } importStyle(path, loadHandler) { const that = this; that._importStyle(path, loadHandler); } _importStyle(path, loadHandler) { const that = this; if (!that.shadowRoot || !path) { return; } const createLink = (path) => { //Check if style link already exists const rootChildren = that.shadowRoot.children; for (let i = 0; i < rootChildren.length; i++) { const rootChild = rootChildren[i]; if (rootChild instanceof HTMLLinkElement) { if (rootChild.href === path) { if (loadHandler) { loadHandler(); } return null; } } } const link = document.createElement('link'); link.rel = 'stylesheet'; link.type = 'text/css'; link.href = path; link.onload = loadHandler; return link; } const lastLinkChild = (() => { const rootChildren = that.shadowRoot.children; let lastLinkChild = null; for (let i = 0; i < rootChildren.length; i++) { const rootChild = rootChildren[i]; if (rootChild instanceof HTMLLinkElement) { lastLinkChild = rootChild; } } return lastLinkChild; })(); const insertAfter = (newNode, referenceNode) => { referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling); } if (Array.isArray(path)) { const fragment = document.createDocumentFragment(); for (let i = 0; i < path.length; i++) { const link = createLink(path[i]); if (link) { fragment.appendChild(link); } } if (lastLinkChild) { insertAfter(fragment, lastLinkChild); } else { that.shadowRoot.insertBefore(fragment, that.shadowRoot.firstChild); } } else { const link = createLink(path); if (!link) { return; } if (lastLinkChild) { insertAfter(link, lastLinkChild); } else { that.shadowRoot.insertBefore(link, that.shadowRoot.firstChild); } } } attributeChanged(name, oldValue, newValue) { if (name === 'style-url') { this.styleUrl = newValue; } } attributeChangedCallback(name, oldValue, newValue) { const that = this; if (!that.isReady) { return; } super.attributeChangedCallback(name, oldValue, newValue); } /** Called when an instance of the custom element is created. */ constructor(selector, properties) { super(); /* initialization code goes here. */ const that = this; if (selector) { if (properties) { that._initProperties = properties; } const createElement = (selector) => { if (typeof selector === 'string' ? document.querySelector(selector) : selector) { const element = typeof selector === 'string' ? document.querySelector(selector) : selector; if (element instanceof HTMLDivElement) { const customElement = document.createElement(that.tagName); for (let attribute of element.attributes) { customElement.setAttribute(attribute.name, element.getAttribute(attribute.name)); } while (element.childNodes.length) { customElement.appendChild(element.firstChild); } if (typeof selector === 'string') { customElement.id = selector.substring(1); } customElement._initProperties = properties; if (element.parentNode) { element.parentNode.replaceChild(customElement, element); } return customElement; } else { if (properties) { const context = element.context; element._initProperties = properties; if (element.isReady) { element.context = element; const oldValues = { }; const values = { }; for (let propertyName in properties) { oldValues[propertyName] = element[propertyName]; values[propertyName] = properties[propertyName]; } if (Object.getOwnPropertyNames(properties).length > 0) { element.initProperties(); element.propertyChangedHandler(properties, oldValues, values); } element.context = context; } } } return element; } } if (typeof selector === 'string') { const elements = document.querySelectorAll(selector); const customElements = []; if (elements.length > 1) { for (let i = 0; i < elements.length; i++) { const element = createElement(elements[i]); customElements.push(element); } return customElements; } } else if (selector && selector.length > 0) { const elements = selector; if (elements.length > 1) { for (let i = 0; i < elements.length; i++) { const element = createElement(elements[i]); customElements.push(element); } return customElements; } } return createElement(selector); } that._styleUrl = ''; if (that.isUtilityElement) { return; } that.created(); } _getRootShadowParent() { const that = this; let parent = that.shadowParent; while (parent) { if (!parent.shadowParent) { return parent; } parent = parent.shadowParent; } return parent || that.shadowParent; } _getStyleUrl(styleUrl) { const that = this; let url = Utilities.Core.getScriptLocation() + window[namespace].StyleBaseUrl + styleUrl; if (that.shadowParent) { url = url.replace('scoped/', ''); } return url; } _getStyleUrls() { const that = this; //let defaultBeforeStyleUrls = []; //let defaultAfterStyleUrls = []; if (that.nodeName.startsWith(namespace)) { //defaultBeforeStyleUrls = [ // 'lw.common.css' //]; //defaultAfterStyleUrls = [ // 'lw.misc.css' //]; } const styleUrls = that.getStaticMember('styleUrls', 'array'); const importUrls = []; for (let i = 0; i < styleUrls.length; i++) { const styleUrl = styleUrls[i]; const url = that._getStyleUrl(styleUrl); importUrls.push(url); } return importUrls; } _setupShadowRoot() { const that = this; that.classList.add('lw-element-init'); const render = (element) => { if (element.$.root) { element.$.root.classList.add(namespace.toLowerCase() + '-element'); element.$.root.classList.add(that.nodeName.toLowerCase()); } element.setup(); element.classList.remove('lw-element-init'); } if (document.adoptedStyleSheets) { if (!window[namespace].AdoptedStyleSheets) { const sheet = new CSSStyleSheet(); // replace all styles, allowing external resources: let url = Utilities.Core.getScriptLocation() + '/styles/lw.default.css'; sheet.replace('@import url("' + url + '")') .then(() => { render(that); window[namespace].AdoptedStyleSheetsLoaded = true; if (window[namespace].AdoptedStyleSheetsLoadedQueue) { const queue = window[namespace].AdoptedStyleSheetsLoadedQueue; for (let i = 0; i < queue.length; i++) { const element = queue[i]; render(element); } delete window[namespace].AdoptedStyleSheetsLoadedQueue; } }) .catch(err => { console.error('Failed to load:', err); }); window[namespace].AdoptedStyleSheets = [sheet]; document.adoptedStyleSheets = [sheet]; that.shadowRoot.adoptedStyleSheets = window[namespace].AdoptedStyleSheets; } else if (window[namespace].AdoptedStyleSheetsLoaded) { that.shadowRoot.adoptedStyleSheets = window[namespace].AdoptedStyleSheets; render(that); } else { that.shadowRoot.adoptedStyleSheets = window[namespace].AdoptedStyleSheets; if (!window[namespace].AdoptedStyleSheetsLoadedQueue) { window[namespace].AdoptedStyleSheetsLoadedQueue = []; } window[namespace].AdoptedStyleSheetsLoadedQueue.push(that); } } } connect() { const that = this; //const isReady = that.isReady; // Uncomment when scopedStyle is implemented in all elements. if (window[namespace].EnableShadowDOM && !that.shadowRoot && that.isInShadowDOM !== true) { that.attachShadow({ mode: 'open' }); if (that.shadowRoot && that.$.root) { that.shadowRoot.appendChild(that.$.root); that.$.root.classList.add(that.nodeName.toLowerCase()); } } // by default if (!that.shadowRoot && !that.shadowParent) { that.setup(); } else { if (that.shadowRoot) { that._setupShadowRoot(); } else if (that.shadowParent && window[namespace].EnableShadowDOM) { that.setup(); } else { that.setup(); } } } /** Called when an instance of custom element is attached to the DOM. */ connectedCallback() { const that = this; if (that.isLoading || that.isUtilityElement) { return; } that.classList.add('lw-element-init'); const updateVisibility = function () { that.classList.remove('lw-element-init'); } if (document.readyState === 'complete' && window[namespace].RenderMode !== 'manual' /*&& !ElementRegistry.isRegistering */) { const parents = that.parents; if (parents.length && (parents[parents.length - 1].nodeName === 'HTML')) { if (that.checkIsInDomTimer) { clearInterval(that.checkIsInDomTimer); } updateVisibility(); that.connect(); } else if (that.getRootNode().host) { if (that.checkIsInDomTimer) { clearInterval(that.checkIsInDomTimer); } updateVisibility(); that.connect(); } else { if (that.checkIsInDomTimer) { clearInterval(that.checkIsInDomTimer); } if (parents.length > 0) { that.checkIsInDomTimer = setInterval(() => { const parents = that.parents; if (parents.length === 0) { clearInterval(that.checkIsInDomTimer); } if (parents.length > 0 && parents[parents.length - 1].nodeName === 'HTML') { clearInterval(that.checkIsInDomTimer); updateVisibility(); that.connect(); } }, 100); } } } else { that.isLoading = true; registeredLoadedCallbacks.push({ element: this, callback: function () { if (this.isReady) { return; } updateVisibility(); this.connect(); }.bind(that) }); } } /** Called when an instance of custom element is detached from the DOM. V0 spec. */ disconnectedCallback() { const that = this; if (!that.isAttached) { that._resetShadowParent(); return; } that.shadowParent = null; that.detached(); } /** Called when an instance of custom element is attached to the DOM. */ adoptedCallback() { const that = this; that.setup(); } appendTemplate(template) { const that = this; if (that.shadowRoot) { that.shadowRoot.appendChild(template); } else { that.appendChild(template); } } _resetShadowParent() { const that = this; if (!window[namespace].EnableShadowDOM || that.shadowParent === null) { return; } const parents = []; let current = that.parentNode; while (current && current.nodeType !== 9) { if (current instanceof HTMLElement === true) { parents.push(current); } else if (current.nodeType === 11) { if (current.host) { current = current.host; continue; } } current = current.parentNode; } for (let i = 0; i < parents.length; i++) { if (parents[i] === that.shadowParent) { return; } } if (parents.length > 0 && parents[parents.length - 1].nodeName === 'HTML') { that.shadowParent = null; } } } /** * This is a base class for registration of custom elements. */ class ElementRegistry { /** * Called by each custom element to register it. @param {String} - tag name. @param {Object} - element's object like Button, NumericTextBox, etc. */ static register(tagName, element) { const proto = element.prototype; let elementName = Core.toCamelCase(tagName).replace(/[a-z]+/, ''); let elementVersion = element.version || window[namespace].Version; if (window.customElements.get(tagName) && window.customElements.get(tagName).version === elementVersion) { return; } let tmpTagName = tagName; elementVersion = elementVersion.split('.'); while (window.customElements.get(tagName)) { tagName = tmpTagName + '-' + elementVersion.join('.'); elementVersion[2] = parseInt(elementVersion[2]) + 1; } if (customElements[tagName]) { return; } if (tagName.startsWith(namespace.toLowerCase())) { customElements[tagName] = window[namespace][elementName] = window[namespace.toLowerCase() + elementName] = element; } else { let customNamespace = tagName.split('-')[0]; customNamespace = customNamespace.substring(0, 1).toUpperCase() + customNamespace.substring(1); if (!window[namespace][customNamespace]) { window[namespace][customNamespace] = { }; } customElements[tagName] = window[namespace][customNamespace][elementName] = window[customNamespace.toLowerCase() + elementName] = element; if (window[namespace][elementName]) { elementName = Core.toCamelCase(tagName); } window[namespace][elementName] = element; } proto.elementName = elementName; proto.defineElement(); if (registeredCallbacks[tagName]) { registeredCallbacks[tagName](proto); } /** Use customElements v1 spec, if it is supported. */ window.customElements.define(tagName, element); } static registerElements() { const that = this; if (!that.toRegister) { return; } that.isRegistering = true; for (let i = 0; i < that.toRegister.length; i++) { const toRegisterItem = that.toRegister[i]; that.register(toRegisterItem.tagName, toRegisterItem.element); } that.isRegistering = false; } /** * Returns the element's object. * @param {String} - tag name. * @return {Object} - custom element's object. */ static get(tagName) { if (customElements[tagName]) { return customElements[tagName]; } return undefined; } /** * Determines whether the element is registered. * @param {String} - tag name. * @param {Function} - the callback function which is called when the element is registered. */ static whenRegistered(tagName, callback) { if (!tagName) { throw new Error('Syntax Error: Invalid tag name'); } const that = this; const existingCallback = registeredCallbacks[tagName]; const element = that.get(tagName); const modulesLength = element ? element.modules.length : 3; try { if (!existingCallback && !element) { registeredCallbacks[tagName] = function (proto) { try { callback(proto) } catch (error) { const errorMessage = error instanceof Error ? error.message : error.toString(); console.log(errorMessage); } }; } else if (!existingCallback && element) { callback(element.prototype); registeredCallbacks[tagName] = undefined; } else if (existingCallback && !element) { registeredCallbacks[tagName] = function (proto) { existingCallback(proto); callback(proto); } } else if (existingCallback && element) { if (element.proto) { existingCallback(element.proto); callback(element.proto); } registeredCallbacks[tagName] = undefined; } } catch (error) { const errorMessage = error instanceof Error ? error.message : error.toString(); console.log(errorMessage); } if (element && modulesLength !== element.prototype.modules.length) { const elements = document.querySelectorAll(tagName); for (let j = 0; j < elements.length; j++) { const element = elements[j]; if (element.isCreated) { element._initElement(); } } } } } ElementRegistry.lazyRegister = false; ElementRegistry.tagNames = []; class Observable { constructor(object, observables) { const that = this; this.name = 'observable'; if (object) { Object.assign(that, object); } const proxyMethodsOf = function (obj) { Object.getOwnPropertyNames(Object.getPrototypeOf(obj)).forEach(methodName => { if (methodName === 'constructor') { return true; } if (methodName.startsWith('_')) { return true; } that[methodName] = obj[methodName]; }) } proxyMethodsOf(object); const proxy = new Proxy(that, { deleteProperty: function (target, property) { delete target[property]; return true; }, get: function (target, property/*, receiver*/) { return target[property]; }, set: function (target, property, value/*, receiver*/) { const oldValue = target[property]; if (oldValue === value) { return true; } target[property] = value; if (property === 'notifyFn' || property.startsWith('_') || property === 'canNotify') { return true; } if (observables && observables.indexOf(property) === -1) { return true; } if (!that.canNotify) { return true } that._notify({ target: target, propertyName: property, oldValue: oldValue, newValue: value }); return true; } }); return proxy; } get canNotify() { const that = this; if (that._canNotify === undefined) { that._canNotify = true; } return that._canNotify; } set canNotify(value) { const that = this; that._canNotify = value; } _notify(changeArgs) { const that = this; if (!that.canNotify) { return; } if (that.notifyFn) { for (let i = 0; i < that.notifyFn.length; i++) { that.notifyFn[i](changeArgs); } } } notify(notifyFn) { const that = this; if (notifyFn) { if (!that.notifyFn) { that.notifyFn = []; } that.notifyFn.push(notifyFn); } } } class ObservableArray { constructor() { const that = this; that.name = 'observableArray'; that.observables = arguments.length < 3 ? null : arguments[2]; const arrayProxy = new Proxy(that, { deleteProperty: function (target, property) { delete target[property]; return true; }, apply: function (method, context, args) { return method.apply(context, args) }, get: function (target, property/*, receiver*/) { if (!target[property] && !isNaN(parseInt(property))) { return that.getItem(parseInt(property)); } return target[property]; }, set: function (target, property, value/*, receiver*/) { if (!target[property] && !isNaN(parseInt(property))) { that.setItem(parseInt(property), value); return true; } target[property] = value; return true; } }); that._addArgs = { eventName: 'change', object: arrayProxy, action: 'add', index: null, removed: new Array(), addedCount: 1 }; that._removeArgs = { eventName: 'change', object: arrayProxy, action: 'remove', index: null, removed: null, addedCount: 0 }; if (arguments.length >= 1 && Array.isArray(arguments[0])) { that._array = []; const source = arguments[0]; for (let i = 0, l = source.length; i < l; i++) { const item = that._getItem(that._array.length, source[i]); that._array.push(item); } } else { that._array = Array.apply(null, arguments); } if (arguments.length === 2) { that.notifyFn = arguments[1]; } return arrayProxy; } get canNotify() { const that = this; if (that._canNotify === undefined) { that._canNotify = true; } return that._canNotify; } set canNotify(value) { const that = this; that._canNotify = value; } _notify(changeArgs) { const that = this; if (!that.canNotify) { return; } if (that.notifyFn) { that.notifyFn(changeArgs); } } notify(notifyFn) { const that = this; if (notifyFn) { that.notifyFn = notifyFn; } } toArray() { const that = this; return that._array; } _getItem(index, item) { const that = this; if (typeof item === 'string') { return item; } if (typeof item === 'number') { return item; } if (item === undefined) { return item; } const itemProxy = new Proxy(item, { deleteProperty: function (target, property) { delete target[property]; }, set: function (target, property, value/*, receiver*/) { const oldValue = target[property]; target[property] = value; if (!that._canNotify || target.canNotify === false) { return true } if (that.observables && !that.observables[property]) { return true; } that._notify({ eventName: 'change', object: that, target: target, action: 'update', index: index, path: index + '.' + property, oldValue: oldValue, newValue: value, propertyName: property }); return true; } }); return itemProxy; } getItem(index) { return this._array[index]; } setItem(index, value) { const that = this; const oldValue = that._array[index]; that._array[index] = that._getItem(index, value); that._notify({ eventName: 'change', object: that._array, action: 'update', index: index, removed: [oldValue], addedCount: 1 }); } get length() { return this._array.length; } set length(value) { const that = this; if (Types.isNumber(value) && that._array && that._array.length !== value) { that.splice(value, that._array.length - value); } } toString() { const that = this; return that._array.toString(); } toLocaleString() { const that = this; return that._array.toLocaleString(); } concat() { const that = this; that._addArgs.index = that._array.length; const result = that._array.concat.apply(that._array, arguments); return new LW.ObservableArray(result); } join(separator) { const that = this; return that._array.join(separator); } pop() { const that = this; that._removeArgs.index = that._array.length - 1; delete that[that._array.length - 1]; const result = that._array.pop(); that._removeArgs.removed = [result]; that._notify(that._removeArgs); that._notifyLengthChange(); return result; } push() { const that = this; that._addArgs.index = that._array.length; if (arguments.length === 1 && Array.isArray(arguments[0])) { const source = arguments[0]; for (let i = 0, l = source.length; i < l; i++) { const item = that._getItem(that._array.length, source[i]); that._array.push(item); } } else { const item = that._getItem(that._addArgs.index, arguments[0]); that._array.push.apply(that._array, [item]); } that._addArgs.addedCount = that._array.length - that._addArgs.index; that._notify(that._addArgs); that._notifyLengthChange(); return that._array.length; } _notifyLengthChange() { const that = this; if (!that.canNotify) { return; } const lengthChangedData = that._createPropertyChangeData('length', that._array.length); that._notify(lengthChangedData); } _createPropertyChangeData(action, value, oldValue) { return { eventName: 'change', object: this, action, value, oldValue }; } reverse() { const that = this; return that._array.reverse(); } shift() { const that = this; const result = that._array.shift(); that._removeArgs.index = 0; that._removeArgs.removed = [result]; that._notify(that._removeArgs); that._notifyLengthChange(); return result; } slice(start, end) { const that = this; return that._array.slice(start, end); } sort(compareFn) { const that = this; return that._array.sort(compareFn); } splice(start, deleteCount, addCount) { const that = this; const length = that._array.length; let result; if (addCount && addCount.length) { for (let i = 0; i < addCount.length; i++) { result = that._array.splice(start + i, deleteCount, addCount[i]); } } else { result = that._array.splice.apply(that._array, arguments); } if (!addCount) { that._notify({ eventName: 'change', object: this, action: 'remove', index: start, removed: result, addedCount: that._array.length > length ? that._array.length - length : 0 }); } else { let canNotify = that.canNotify; that.canNotify = false; if (addCount.length) { for (let i = 0; i < addCount.length; i++) { that.setItem(start + i, addCount[i]); } } else { that.setItem(start, addCount); } that.canNotify = canNotify; that._notify({ eventName: 'change', object: this, action: 'add', index: start, added: result, addedCount: that._array.length > length ? that._array.length - length : 0 }); } if (that._array.length !== length) { that._notifyLengthChange(); } return result; } unshift() { const that = this; const length = that._array.length; const result = that._array.unshift.apply(that._array, arguments); that._addArgs.index = 0; that._addArgs.addedCount = result - length; that._notify(this._addArgs); that._notifyLengthChange(); return result; } indexOf(searchElement, fromIndex) { const that = this; const index = fromIndex ? fromIndex : 0; for (let i = index, l = that._array.length; i < l; i++) { if (that._array[i] === searchElement) { return i; } } return -1; } lastIndexOf(searchElement, fromIndex) { const that = this; const index = fromIndex ? fromIndex : that._array.length - 1; for (let i = index; i >= 0; i--) { if (that._array[i] === searchElement) { return i; } } return -1; } find(callbackfn, thisArg) { const that = this; return that._array.find(callbackfn, thisArg); } findIndex(callbackfn, thisArg) { const that = this; return that._array.findIndex(callbackfn, thisArg); } every(callbackfn, thisArg) { const that = this; return that._array.every(callbackfn, thisArg); } some(callbackfn, thisArg) { const that = this; return that._array.some(callbackfn, thisArg); } forEach(callbackfn, thisArg) { const that = this; that._array.forEach(callbackfn, thisArg); } map(callbackfn, thisArg) { const that = this; return that._array.map(callbackfn, thisArg); } filter(callbackfn, thisArg) { const that = this; const filteredArray = that._array.filter(callbackfn, thisArg); return filteredArray; } reduce(callbackfn, initialValue) { const that = this; return initialValue !== undefined ? that._array.reduce(callbackfn, initialValue) : that._array.reduce(callbackfn); } reduceRight(callbackfn, initialValue) { const that = this; return initialValue !== undefined ? that._array.reduceRight(callbackfn, initialValue) : that._array.reduceRight(callbackfn); } move(from, to) { const that = this; that.splice(to, 0, that.splice(from, 1)[0]); } } function Init(selector, element) { const properties = element.properties; element._properties = []; const defineProperties = function (properties, propertyPath) { const propertyNames = Object.keys(properties); for (let i = 0; i < propertyNames.length; i++) { const propertyName = propertyNames[i]; const propertyValue = properties[propertyName]; element._properties[propertyPath + propertyName] = propertyValue; if (Array.isArray(propertyValue)) { element._properties[propertyPath + propertyName] = new ObservableArray(propertyValue, function (detail) { const path = propertyName + '.' + detail.path; const newValue = detail.newValue; const instance = document.querySelector(selector); if (instance) { const pathSteps = path.split('.'); let propertyValue = instance; for (let i = 0; i < pathSteps.length; i++) { const step = pathSteps[i]; propertyValue = propertyValue[step]; } propertyValue = newValue; } }); continue; } Object.defineProperty(properties, propertyName, { configurable: false, enumerable: true, get() { return element._properties[propertyPath + propertyName]; }, set(value) { element._properties[propertyPath + propertyName] = value; } }); if (propertyValue && propertyValue.constructor.name === 'DataAdapter') { continue; } if (propertyValue && typeof propertyValue === 'object' && LW.DataAdapter && propertyValue instanceof LW.DataAdapter) { continue; } if (typeof propertyValue === 'object' && propertyValue && Object.keys(propertyValue).length > 0) { defineProperties(propertyValue, propertyPath + propertyName + '.'); } } } defineProperties(properties, ''); Object.defineProperty(element, 'properties', { configurable: false, enumerable: true, get() { return properties; } }); const instance = document.querySelector(selector); if (instance && instance.isReady) { for (let property in properties) { instance[property] = properties[property]; } } else if (instance) { instance.props = {}; for (let property in properties) { instance.props[property] = properties[property]; } } } let userDefinedSettings = { }; if (window[namespace]) { userDefinedSettings = window[namespace]; } /* * Defines the 'LW' namespace. * @param {String} - the tag's name. * @param {Object} - the custom element. */ window[namespace] = function (tagName, element) { let name = tagName; if (!tagName) { return; } if (tagName.indexOf('#') >= 0 || tagName.indexOf('.') >= 0) { if (data[tagName]) { return data[tagName]; } else if (element) { data[tagName] = new element(); Init(tagName, data[tagName]); return data[tagName]; } return; } if (!element) { return; } ElementRegistry.tagNames[tagName] = element; if (ElementRegistry.lazyRegister) { if (!ElementRegistry.toRegister) { ElementRegistry.toRegister = []; } const elementName = Core.toCamelCase(name).replace(/[a-z]+/, ''); window[namespace][elementName] = element; ElementRegistry.toRegister.push({ tagName: name, element: element }); return; } ElementRegistry.register(name, element); } window.addEventListener('load', function () { const tagNames = window[namespace].Elements.tagNames; let customElements = []; for (let tagName in tagNames) { const customElement = tagNames[tagName]; let elements = document.querySelectorAll('[' + tagName + ']'); for (let j = 0; j < elements.length; j++) { const element = elements[j]; if (element instanceof HTMLDivElement) { element.__proto__ = customElement.prototype; element.created(); element.connectedCallback(); } element.classList.add('lw-element-ready'); } let name = customElement.name; if (name === 'Item') { name = 'ListItem'; } elements = document.querySelectorAll('[is="' + namespace.toLocaleLowerCase() + name + '"]'); for (let i = 0; i < elements.length; i++) { customElements.push(elements[i]); } } if (customElements.length > 0) { const parents = element => { let matched = [], current = element.parentNode; while (current && current.nodeType !== 9) { if (current instanceof HTMLElement === true) { matched.push(current); } current = current.parentNode; } return matched; } customElements.sort(function (element1, element2) { let indexA = parents(element1).length; let indexB = parents(element2).length; if (indexA < indexB) { return 1; } if (indexA > indexB) { return -1; } return 0; }); for (let j = 0; j < customElements.length; j++) { const element = customElements[j]; const tagName = element.getAttribute('is'); let customElement; if (tagName === 'lwItem') { customElement = new window['lwListItem'](element); } else { customElement = new window[tagName](element); } customElement.removeAttribute('is'); } } }); class Component { constructor(selector, properties) { const that = this; const name = this.name; let element = null; if (selector) { element = new window[name](selector, properties); } else { element = new window[name]; element._initProperties = properties; } that._element = element; return element; } get name() { return 'Component'; } get element() { return this._element; } } const connectElements = function () { if (document.readyState !== 'complete') { return; } if (window[namespace].RenderMode === 'manual') { return; } registeredLoadedCallbacks.sort(function (element1, element2) { let indexA = element1.element.parents.length; let indexB = element2.element.parents.length; if (indexA < indexB) { return -1; } if (indexA > indexB) { return 1; } return 0; }); for (let i = 0; i < registeredLoadedCallbacks.length; i++) { registeredLoadedCallbacks[i].element.isLoading = false; registeredLoadedCallbacks[i].callback(); } registeredLoadedCallbacks = []; document.removeEventListener('readystatechange', connectElements); }; const render = function () { const connectOnLoad = () => { window[namespace].RenderMode = ''; connectElements(); }; if (document.readyState === 'complete') { connectOnLoad(); } else { window.removeEventListener('load', connectOnLoad); window.addEventListener('load', connectOnLoad); } } Object.assign(window[namespace], { Elements: ElementRegistry, Modules: [], BaseElement: BaseCustomElement, Utilities: Utilities, Import: Import, ObservableArray: ObservableArray, Observable: Observable, Component: Component, Theme: userDefinedSettings.Theme || '', EnableShadowDOM: userDefinedSettings.ShadowDom || false, // EnableShadowDOM: /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor), BaseUrl: './', StyleBaseUrl: '/styles/default/', Version: Version, RenderMode: userDefinedSettings.RenderMode || 'auto', Render: render, License: 'Evaluation' }); let theme = window[namespace].Theme; if (window[namespace].RenderMode !== 'manual') { document.addEventListener('readystatechange', connectElements); } Object.defineProperty(window[namespace], 'Theme', { configurable: false, enumerable: true, get() { return theme; }, set(value) { const oldValue = theme; theme = value; $document.fireEvent('theme-changed', { oldValue: oldValue, newValue: value }, { bubbles: true, cancelable: true }); } }); window[namespace]('lw-base-element', window[namespace].BaseElement); /** * Content element. */ window[namespace]('lw-content-element', class ContentElement extends window[namespace].BaseElement { static get properties() { return { 'content': { type: 'any', reflectToAttribute: false }, 'innerHTML': { type: 'string', reflectToAttribute: false } }; } /** Content Element's template. */ template() { return '<div inner-h-t-m-l=\'[[innerHTML]]\'></div>'; } ready() { super.ready(); const that = this; that.applyContent(); } clearContent() { const that = this; while (that.$.content.firstChild) { that.$.content.removeChild(that.$.content.firstChild); } } applyContent() { const that = this; if (that.content === undefined) { that.content = that.$.content; return; } if (that.content === '' || that.content === null) { that.clearContent(); return; } if (that.content instanceof HTMLElement) { that.clearContent(); that.$.content.appendChild(that.content); return; } const fragment = document.createDocumentFragment(); /* Create a wrapper DIV tag. */ let tmpElement = document.createElement('div'); fragment.appendChild(tmpElement); /* Fill the nodes array with the wrapper's childNodes. */ if (that.content instanceof HTMLElement) { tmpElement.appendChild(that.content); } else { tmpElement.innerHTML = that.content; } let nodes = Array.from(tmpElement.childNodes); /* Remove the wrapper DIV tag. */ tmpElement.parentNode.removeChild(tmpElement); for (let i = 0; i < nodes.length; i++) { fragment.appendChild(nodes[i]); } that.clearContent(); that.$.content.appendChild(fragment); } propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (oldValue === newValue) { return; } if (propertyName === 'innerHTML') { that.content = newValue; that.applyContent(); that.innerHTML = that.content = Utilities.Core.html(that.$.content); } if (propertyName === 'content') { that.applyContent(); } } }); window[namespace]('lw-scroll-viewer', class ScrollViewer extends window[namespace].ContentElement { static get properties() { return { 'horizontalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] }, 'touchScrollRatio': { type: 'any', value: null }, 'touchVelocityCoefficient': { type: 'number', value: 50 }, 'verticalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] } }; } static get listeners() { return { 'horizontalScrollBar.change': '_horizontalScrollbarHandler', 'verticalScrollBar.change': '_verticalScrollbarHandler', 'touchmove': '_touchmoveHandler', 'touchstart': '_touchstartHandler', 'wheel': '_mouseWheelHandler', 'document.up': '_upHandler' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.scrollviewer.css' ] } /** ScrollViewer Element's template. */ template() { return `<div id="container" class="lw-container" role="presentation"> <div id="scrollViewerContainer" class="lw-scroll-viewer-container" role="presentation"> <div id="scrollViewerContentContainer" inner-h-t-m-l=\'[[innerHTML]]\' class="lw-scroll-viewer-content-container" role="presentation"> <content></content> </div> </div> <lw-scroll-bar id="verticalScrollBar" animation="[[animation]]" disabled="[[disabled]]" right-to-left="[[rightToLeft]]" orientation="vertical"></lw-scroll-bar> <lw-scroll-bar id="horizontalScrollBar" animation="[[animation]]" disabled="[[disabled]]" right-to-left="[[rightToLeft]]"></lw-scroll-bar> </div>`; } appendChild(node) { const that = this; if (!node) { return; } if (!that.isCompleted || (node.classList && node.classList.contains('lw-resize-trigger-container'))) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.scrollViewerContentContainer.appendChild(node); } removeChild(node) { const that = this; if (!node) { return; } if (!that.isCompleted || (node.classList && node.classList.contains('lw-resize-trigger-container'))) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.scrollViewerContentContainer.removeChild(node); } removeAll() { const that = this; if (that.isCompleted) { that.$.scrollViewerContentContainer.innerHTML = ''; } } _horizontalScrollbarHandler(event) { const that = this; that.$.scrollViewerContentContainer.style.left = ((that.rightToLeft ? 1 : -1) * that.scrollLeft) + 'px'; event.stopPropagation(); if (that.onHorizontalChange) { that.onHorizontalChange(event); } } _verticalScrollbarHandler(event) { const that = this; that.$.scrollViewerContentContainer.style.top = -that.scrollTop + 'px'; event.stopPropagation(); if (that.onVerticalChange) { that.onVerticalChange(event); } } /** * touchmove handler. */ _touchmoveHandler(event) { const that = this; if (that._touchmoveInside && event.cancelable) { event.preventDefault(); event.stopPropagation(); return; } const computedVerticalScrollBarVisibility = that.computedVerticalScrollBarVisibility, coords = that._touchCoords; if (!that.computedHorizontalScrollBarVisibility && !computedVerticalScrollBarVisibility || !coords) { return; } const touches = event.touches[0]; let scrolled, scrollSize, coord, previousCoord; that._touchCoords = [touches.pageX, touches.pageY]; if (computedVerticalScrollBarVisibility) { scrolled = that.scrollTop; scrollSize = that.scrollHeight; coord = touches.pageY; previousCoord = coords[1]; } else { scrolled = that.scrollLeft; scrollSize = that.scrollWidth; coord = touches.pageX; previousCoord = coords[0]; } const normalizedCoord = parseFloat(coord.toFixed(5)), normalizedPreviousCoord = parseFloat(previousCoord.toFixed(5)); if (scrolled === 0 && normalizedCoord >= normalizedPreviousCoord || // pan up scrolled === scrollSize && normalizedCoord <= normalizedPreviousCoord) { // pan down return; } if (coord !== previousCoord) { that._touchmoveInside = true; } if (event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * touchstart handler. */ _touchstartHandler(event) { const touches = event.touches[0]; this._touchCoords = [touches.pageX, touches.pageY]; } _mouseWheelHandler(event) { const that = this; if (that.disabled || (!that.computedHorizontalScrollBarVisibility && !that.computedVerticalScrollBarVisibility)) { return; } if (event.shiftKey && that.computedHorizontalScrollBarVisibility) { const scrollLeft = that.scrollLeft; if (scrollLeft === 0 && event.deltaX < 0 || scrollLeft === that.scrollHeight && event.deltaX > 0) { return; } event.stopPropagation(); event.preventDefault(); if (that.scrollWidth > 0) { that.scrollTo(undefined, that.scrollLeft + that._getScrollCoefficient(event, that.offsetWidth)); } return; } if (that.computedVerticalScrollBarVisibility) { const scrollTop = that.scrollTop; if (scrollTop === 0 && event.deltaY < 0 || scrollTop === that.scrollHeight && event.deltaY > 0) { return; } event.stopPropagation(); event.preventDefault(); if (that.scrollHeight > 0) { that.scrollTo(that.scrollTop + that._getScrollCoefficient(event, that.offsetHeight)); } } } _overriddenHandler() { } /** * document up handler. */ _upHandler() { const that = this; delete that._touchCoords; delete that._touchmoveInside; } _getScrollCoefficient(event, defaultCoefficient) { const deltaMode = event.deltaMode, absoluteDeltaY = Math.abs(event.deltaY); let coefficient; if (deltaMode === 0) { // DOM_DELTA_PIXEL if (absoluteDeltaY < 100 / 3) { // trackpad coefficient = absoluteDeltaY; } else { coefficient = defaultCoefficient; } } else if (deltaMode === 1) { // DOM_DELTA_LINE (Firefox only) if (absoluteDeltaY < 1) { // trackpad coefficient = absoluteDeltaY * (100 / 3); } else { coefficient = defaultCoefficient; } } else if (deltaMode === 2) { // DOM_DELTA_PAGE (when "Mouse Properties" -> "Wheel" -> "Vertical Scrolling" -> "One screen at a time" is selected in Windows settings) coefficient = defaultCoefficient; } return event.deltaY < 0 ? -coefficient : coefficient; } applyContent() { const that = this; super.applyContent(); that.refresh(); } get computedHorizontalScrollBarVisibility() { const that = this; if (that._scrollView && that._scrollView.hScrollBar) { return !that._scrollView.hScrollBar.$.hasClass('lw-hidden'); } return null; } get computedVerticalScrollBarVisibility() { const that = this; if (that._scrollView && that._scrollView.vScrollBar) { return !that._scrollView.vScrollBar.$.hasClass('lw-hidden'); } return null; } scrollTo(top, left) { const that = this; if (!that._scrollView) { return; } if (top !== undefined) { that._scrollView.scrollTo(top); } if (left !== undefined) { that._scrollView.scrollTo(left, false); } } refreshScrollBarsVisibility() { const that = this; if (!that._scrollView) { return; } that._scrollView.hScrollBar.disabled = that.disabled; that._scrollView.vScrollBar.disabled = that.disabled; if (that.horizontalScrollBarVisibility === 'disabled') { that._scrollView.hScrollBar.disabled = true; } if (that.verticalScrollBarVisibility === 'disabled') { that._scrollView.vScrollBar.disabled = true; } if (that.scrollWidth > 0) { that._scrollView.hScrollBar.$.removeClass('lw-hidden'); } else if (that.horizontalScrollBarVisibility !== 'visible') { that._scrollView.hScrollBar.$.addClass('lw-hidden'); } if (that.scrollHeight > 0) { that._scrollView.vScrollBar.$.removeClass('lw-hidden'); } else if (that.verticalScrollBarVisibility !== 'visible') { that._scrollView.vScrollBar.$.addClass('lw-hidden'); } if (that.horizontalScrollBarVisibility === 'hidden') { that._scrollView.hScrollBar.$.addClass('lw-hidden'); } if (that.verticalScrollBarVisibility === 'hidden') { that._scrollView.vScrollBar.$.addClass('lw-hidden'); } if (that.horizontalScrollBarVisibility === 'visible') { that._scrollView.hScrollBar.$.removeClass('lw-hidden'); } if (that.verticalScrollBarVisibility === 'visible') { that._scrollView.vScrollBar.$.removeClass('lw-hidden'); if (!that.disabled) { that._scrollView.vScrollBar.disabled = that.scrollHeight <= 0; } } if (that.computedHorizontalScrollBarVisibility && that.computedVerticalScrollBarVisibility) { that._scrollView.hScrollBar.$.addClass('bottom-corner'); that._scrollView.vScrollBar.$.addClass('bottom-corner'); } else { that._scrollView.hScrollBar.$.removeClass('bottom-corner'); that._scrollView.vScrollBar.$.removeClass('bottom-corner'); } } ready() { super.ready(); const that = this; that.$.verticalScrollBar.setAttribute('aria-controls', that.id); that.$.horizontalScrollBar.setAttribute('aria-controls', that.id); if (!that._customScrollView) { that._scrollView = new LW.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar); } that.refresh(); } refresh() { const that = this; function getScrollWidth() { const scrollWidth = that.$.scrollViewerContentContainer.offsetWidth - that.$.scrollViewerContainer.offsetWidth; if (scrollWidth > 0 && that.horizontalScrollBarVisibility !== 'hidden' || that.horizontalScrollBarVisibility === 'visible') { that.$.scrollViewerContainer.classList.add('hscroll'); } else { that.$.scrollViewerContainer.classList.remove('hscroll'); } return scrollWidth; } function getScrollHeight() { let scrollHeight; //NOTE: Safari has an issue where it rounds the parent's height to the lowest integer number ignoring the decimal part if (LW.Utilities.Core.Browser.Safari) { const contentContainerHeight = that.$.scrollViewerContentContainer.getBoundingClientRect().height, containerHeight = that.$.scrollViewerContainer.getBoundingClientRect().height; if (contentContainerHeight && containerHeight) { scrollHeight = parseInt(contentContainerHeight) - parseInt(containerHeight); } else { scrollHeight = that.$.scrollViewerContentContainer.offsetHeight - that.$.scrollViewerContainer.offsetHeight; } } else { scrollHeight = that.$.scrollViewerContentContainer.offsetHeight - that.$.scrollViewerContainer.offsetHeight; } if (scrollHeight > 0 && that.verticalScrollBarVisibility !== 'hidden' || that.verticalScrollBarVisibility === 'visible') { that.$.scrollViewerContainer.classList.add('vscroll'); } else { that.$.scrollViewerContainer.classList.remove('vscroll'); } return scrollHeight; } if (!that.$.scrollViewerContentContainer) { return; } //Caching the size's before they are re-calculated. Used to check if width/height of the container have changed. let initialWidth = that.scrollWidth, initialHeight = that.scrollHeight; that.scrollWidth = getScrollWidth(); that.scrollHeight = getScrollHeight(); //double check in case vScroll has become hidden and hScroll visibility should be checked if (!that.scrollHeight || initialHeight !== that.scrollHeight) { that.scrollWidth = getScrollWidth(); } //doble check in case hScroll has become hidden and vScroll visibility should be checked if (!that.scrollWidth || initialWidth !== that.scrollWidth) { that.scrollHeight = getScrollHeight(); } if (that.computedVerticalScrollBarVisibility) { that.scrollHeight += that._scrollView.hScrollBar.offsetHeight; } if (that.computedHorizontalScrollBarVisibility) { that.scrollWidth += that._scrollView.vScrollBar.offsetWidth; } } attached() { const that = this; super.attached(); if (!that._scrollView && !that._customScrollView) { that._scrollView = new LW.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar); } } detached() { const that = this; super.detached(); if (that._scrollView) { that._scrollView.unlisten(); delete that._scrollView; } } get scrollWidth() { const that = this; if (that._scrollView && that._scrollView.hScrollBar) { if (that._scrollView.hScrollBar.max === 1 && that.horizontalScrollBarVisibility === 'visible') { return 0; } return that._scrollView.hScrollBar.max; } return -1; } set scrollWidth(value) { const that = this; if (value < 0) { value = 0; } if (that._scrollView && that._scrollView.hScrollBar) { if (value === 0 && that.horizontalScrollBarVisibility === 'visible') { that._scrollView.hScrollBar.max = 0; } else { that._scrollView.hScrollBar.max = value; } that.refreshScrollBarsVisibility(); } } get scrollHeight() { const that = this; if (that._scrollView && that._scrollView.vScrollBar) { if (that._scrollView.vScrollBar.max === 1 && that.verticalScrollBarVisibility === 'visible') { return 0; } return that._scrollView.vScrollBar.max; } return 0; } set scrollHeight(value) { const that = this; if (value < 0) { value = 0; } if (that._scrollView && that._scrollView.vScrollBar) { if (value === 0 && that.verticalScrollBarVisibility === 'visible') { that._scrollView.vScrollBar.max = 1; } else { that._scrollView.vScrollBar.max = value; } that.refreshScrollBarsVisibility(); } } get scrollLeft() { const that = this; if (that._scrollView && that._scrollView.hScrollBar) { return that._scrollView.hScrollBar.value; } return 0; } set scrollLeft(value) { const that = this; if (value < 0) { value = 0; } if (that._scrollView && that._scrollView.hScrollBar) { that._scrollView.hScrollBar.value = value; } } get scrollTop() { const that = this; if (that._scrollView && that._scrollView.vScrollBar) { return that._scrollView.vScrollBar.value; } return 0; } set scrollTop(value) { const that = this; if (value < 0) { value = 0; } if (that._scrollView && that._scrollView.vScrollBar) { that._scrollView.vScrollBar.value = value; } } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); if (propertyName !== 'animation' && propertyName !== 'theme') { that.refresh(); } } }); window[namespace].Utilities.Assign('PositionDetection', class PositionDetection { constructor(context, dropDown, defaultParent, closeMethod) { const that = this; if (dropDown) { const id = 'dropDown' + Math.floor((1 + Math.random()) * 0x10000) .toString(16) .substring(1); dropDown.id = id; context.setAttribute('aria-owns', id); } that.context = context; that.dropDown = dropDown; that.defaultParent = defaultParent; that.closeMethod = closeMethod; } /** * Checks Element's position inside the document */ handleAutoPositioning() { const positionDetection = this, that = positionDetection.context; if (that.dropDownPosition !== 'auto' || that.disabled) { return; } // eslint-disable-next-line const requestAnimFrame = (() => { return window.requestAnimationFrame })(); let start = Date.now(), animationFrame; function loop() { animationFrame = requestAnimFrame(loop); //Cancel condition. if (that.dropDownPosition !== 'auto' || that.disabled || !(that.isInShadowDOM ? document.body.contains(that.shadowParent) : document.body.contains(that))) { cancelAnimationFrame(animationFrame); } const current = Date.now(); if (current - start >= 200) { positionDetection.scrollHandler(); start = Date.now(); } } return animationFrame = requestAnimFrame(loop); } /** * Checks window bounds and repositions the listbox popup */ checkBrowserBounds(direction) { const that = this.context; if (that.dropDownPosition !== 'auto' || that.disabled) { return; } switch (direction) { case 'vertically': this.checkBrowserBoundsVertically(); break; case 'horizontally': this.checkBrowserBoundsHorizontally(); break; default: this.checkBrowserBoundsVertically(); this.checkBrowserBoundsHorizontally(); break; } } /** * Check browser bounds Horizontally */ checkBrowserBoundsHorizontally() { const that = this.context, dropDown = this.dropDown; let isParentChanged, vScrollBar = 0; //if vertical scrollbar is visible if (!Core.isMobile && window.innerWidth !== document.documentElement.clientWidth) { vScrollBar = window.innerWidth - document.documentElement.clientWidth; } if (that._dropDownParent !== null) { isParentChanged = true; } else { dropDown.style.left = ''; } const windowWidth = window.innerWidth - vScrollBar; let currentOffsetLeft = that.getBoundingClientRect().left; //Left side check - Not Tested if (currentOffsetLeft < 0) { dropDown.style.left = (isParentChanged ? 0 : Math.abs(currentOffsetLeft)) + 'px'; currentOffsetLeft = parseFloat(dropDown.style.left); } //Right side check if (currentOffsetLeft + dropDown.offsetWidth > windowWidth) { let newOffset = currentOffsetLeft - Math.abs(windowWidth - currentOffsetLeft - dropDown.offsetWidth); if (isParentChanged) { newOffset += window.pageXOffset; } //Sets the left here in order to fit the drop down inside the viewport to avoid scroll bar appearing which leads to //misscalculations for the documentElement.scrollWidth! dropDown.style.left = (isParentChanged ? newOffset : newOffset - currentOffsetLeft) + 'px'; //Check the viewPort horizontal offset //const viewPortHorizontalOffset = Math.max(0, document.documentElement.scrollWidth - (window.innerWidth + document.documentElement.scrollLeft - vScrollBar)); //if (viewPortHorizontalOffset && !isParentChanged) { // dropDown.style.left = (Math.max(0, newOffset - currentOffsetLeft) - viewPortHorizontalOffset) + 'px'; //} //if vertical scrollbar has become hidden if (window.innerWidth === document.documentElement.clientWidth) { dropDown.style.left = (parseFloat(dropDown.style.left) + vScrollBar) + 'px'; } //if the dropDownList is in another container different from the listBox's if (isParentChanged && window.innerHeight === document.documentElement.clientHeight) { this.positionDropDown(true); } } //TODO: What if there's no space to the left nor the right ? } /** * Check browser bounds Vertically */ checkBrowserBoundsVertically(elementCoordinates) { const that = this.context, dropDown = this.dropDown, oldDropDownListPosition = that._dropDownListPosition; if (!elementCoordinates) { elementCoordinates = that.getBoundingClientRect(); } if (elementCoordinates.height === 0) { return; } if (document.documentElement.clientHeight - Math.abs(elementCoordinates.top + elementCoordinates.height + dropDown.offsetHeight) >= 0) { that._dropDownListPosition = 'bottom'; } else if (elementCoordinates.top - dropDown.offsetHeight >= 0) { that._dropDownListPosition = 'top'; } else { //What if there's no space above or under, place over ? that._dropDownListPosition = 'overlay-center'; // Solution: Maybe reduce the height ? } this.updatePositionAttribute(oldDropDownListPosition, that._dropDownListPosition); } /** * Handles the scrolling */ scrollHandler() { const that = this.context; if (!that.parentElement) { return; } const rect = that.getBoundingClientRect(); if (rect.top === that._positionTop) { return; } const oldDropDownListPosition = that._dropDownListPosition; this.checkBrowserBoundsVertically(rect); if (that._dropDownListPosition !== oldDropDownListPosition) { this.positionDropDown(); } that._positionTop = rect.top; } getDropDownParent(init) { const that = this.context, dropDown = this.dropDown; let dropDownAppendTo = that.dropDownAppendTo; that._positionedParent = null; if (dropDownAppendTo === null) { that._dropDownParent = null; } else if (dropDownAppendTo === 'body' || dropDownAppendTo === document.body) { if (that.getRootNode().host) { that._dropDownParent = that.getRootNode().host.shadowRoot; } else { that._dropDownParent = document.body; } } else if (dropDownAppendTo instanceof HTMLElement) { that._dropDownParent = dropDownAppendTo; } else if (typeof dropDownAppendTo === 'string') { dropDownAppendTo = document.getElementById(dropDownAppendTo); if (dropDownAppendTo instanceof HTMLElement) { that._dropDownParent = dropDownAppendTo; } else { that.dropDownAppendTo = null; that._dropDownParent = null; } } else { that.dropDownAppendTo = null; that._dropDownParent = null; } let container = that._dropDownParent; if (container === null) { return; } while (container && container instanceof HTMLElement && window.getComputedStyle(container).position === 'static' && container !== that.getShadowRootOrBody()) { container = container.parentElement; } if (container === document.body) { that._positionedParent = null; } else { that._positionedParent = container; } if (!dropDown) { return; } dropDown.setAttribute('animation', that.animation); if (that.theme !== '') { dropDown.$.addClass(that.theme); } if (init) { that._dropDownParent.appendChild(dropDown); dropDown.$.addClass('lw-drop-down-repositioned'); } if (that.detachedChildren.indexOf(dropDown) === -1) { that.detachedChildren.push(dropDown); } } dropDownAppendToChangedHandler() { const that = this.context, dropDown = this.dropDown, oldDropDownParent = that._dropDownParent; this.getDropDownParent(); if (that._dropDownParent === oldDropDownParent) { return; } that[this.closeMethod](); ['left', 'top', 'font-size', 'font-family', 'font-style', 'font-weight'].forEach(styleName => dropDown.style[styleName] = null); if (that._dropDownParent === null) { this.defaultParent.appendChild(dropDown); dropDown.$.removeClass('lw-drop-down-repositioned'); } else { that._dropDownParent.appendChild(dropDown); dropDown.$.addClass('lw-drop-down-repositioned'); } } dropDownPositionChangedHandler() { const that = this; that.dropDown.style.transition = 'none'; that.context[that.closeMethod](); that.setDropDownPosition(); that.handleAutoPositioning(); } dropDownAttached(callback) { const that = this.context; if (that._dropDownParent === null) { return; } that._dropDownParent.appendChild(this.dropDown); this.handleAutoPositioning(); if (callback) { that[callback](); } } dropDownDetached() { const that = this.context; if (that._dropDownParent !== null && document.body.contains(this.dropDown) && document.body.contains(that._dropDownParent)) { that._dropDownParent.removeChild(this.dropDown); } } /** * Set the drop down position property. * @param {any} value */ setDropDownPosition() { const that = this.context, value = that.dropDownPosition, oldDropDownListPosition = that._dropDownListPosition; if (value === 'auto') { this.checkBrowserBounds(); } else { that._dropDownListPosition = value; } this.updatePositionAttribute(oldDropDownListPosition, that._dropDownListPosition); } updatePositionAttribute(oldPosition, newPosition) { const that = this.context, dropDown = this.dropDown; if (that.$.dropDownButton && !that.$.dropDownButton.hasAttribute(newPosition)) { that.$.dropDownButton.removeAttribute(oldPosition); that.$.dropDownButton.setAttribute(newPosition, ''); } if (!dropDown.hasAttribute(newPosition)) { dropDown.style.transition = 'none'; dropDown.removeAttribute(oldPosition); dropDown.setAttribute(newPosition, ''); requestAnimationFrame(function () { dropDown.style.transition = null; }); } } /** * Calculates the new position of the popup afer it's parent has been changed. */ positionDropDown(vertically) { const that = this.context, dropDown = this.dropDown; if (!that.opened || that._dropDownParent === null) { return; } const coordinates = that.getBoundingClientRect(); let left, top; if (this.customPositionDropDown) { const customCoordinates = this.customPositionDropDown(coordinates); left = customCoordinates.left; top = customCoordinates.top; } else { left = coordinates.left; top = coordinates.top; switch (that._dropDownListPosition) { case 'bottom': top += that.$.container.offsetHeight - 1; // 1 is the min border-width. Doesn't matter if it's bigger. break; case 'center-bottom': top += that.$.container.offsetHeight - 1; left += that.offsetWidth - dropDown.offsetWidth / 2; break; case 'center-top': top -= dropDown.offsetHeight - 1; left += that.offsetWidth - dropDown.offsetWidth / 2; break; case 'top': top -= dropDown.offsetHeight - 1; break; case 'overlay-bottom': break; case 'overlay-center': top -= dropDown.offsetHeight / 2 - that.offsetHeight / 2; break; case 'overlay-top': top -= dropDown.offsetHeight - that.offsetHeight; break; } } const dropDownOffset = this.getDropDownOffset(); dropDown.style.top = top + dropDownOffset.y + 'px'; if (vertically) { return; } dropDown.style.left = left + dropDownOffset.x + 'px'; } getDropDownOffset() { const positionedParent = this.context._positionedParent; let xOffset, yOffset; if (positionedParent) { const parentRect = positionedParent.getBoundingClientRect(); xOffset = -parentRect.left; yOffset = -parentRect.top; } else { xOffset = window.pageXOffset; yOffset = window.pageYOffset; } return { x: xOffset, y: yOffset }; } /** * Places dropdown overlay. */ placeOverlay() { const that = this.context; if (!that.dropDownOverlay || that._overlay) { return; } const overlay = document.createElement('div'); overlay.classList.add('lw-drop-down-overlay'); overlay.style.width = document.documentElement.scrollWidth + 'px'; overlay.style.height = document.documentElement.scrollHeight + 'px'; document.body.appendChild(overlay); that._overlay = overlay; } /** * Removes dropdown overlay. */ removeOverlay(onClose) { const positionDetection = this, that = positionDetection.context; function check() { if (positionDetection.dropDown.getBoundingClientRect().height > 0) { requestAnimationFrame(check); } else { document.body.removeChild(that._overlay); delete that._overlay; } } if (that._overlay) { if (that.hasAnimation && onClose) { requestAnimationFrame(check); } else { document.body.removeChild(that._overlay); delete that._overlay; } } } }); })(); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * A class for instantiating a complex number object. */ LW.Utilities.Assign('Complex', class LWComplex { constructor(value, imag) { if (typeof value === 'string') { this.complexNumber = this.parseComplexNumber(value); this.realPart = this.complexNumber.realPart; this.imaginaryPart = this.complexNumber.imaginaryPart; } else if (typeof value === 'number') { this.realPart = value; if (typeof imag === 'number') { this.imaginaryPart = imag; } else if (typeof imag === 'undefined') { this.imaginaryPart = 0; } else { throw new Error('Can\'t create complex number: invalid imaginary part'); } this.complexNumber = this.parseComplexNumber(this.realPart, this.imaginaryPart); } else { throw new Error('Can\'t create complex number'); } } valueOf() { if (this.imaginaryPart === 0) { return this.realPart; } return null; } isNaN() { return isNaN(this.realPart) || isNaN(this.imaginaryPart); } isZero() { return ( (this.realPart === 0 || this.realPart === -0) && (this.imaginaryPart === 0 || this.imaginaryPart === -0) ); } isFinite() { return isFinite(this.realPart) && isFinite(this.imaginaryPart); } isInfinite() { return !(this.isNaN() || this.isFinite()); } parseComplexNumber(value, imaginaryPart) { const complexNumber = { realPart: 0, imaginaryPart: 0 }; if (value === undefined || value === null) { complexNumber.realPart = complexNumber.imaginaryPart = 0; } else if (imaginaryPart !== undefined) { complexNumber.realPart = value; complexNumber.imaginaryPart = imaginaryPart; } else switch (typeof value) { case 'object': if ('imaginaryPart' in value && 'realPart' in value) { complexNumber.realPart = value.realPart; complexNumber.imaginaryPart = value.imaginaryPart; } else if (value.length === 2) { complexNumber.realPart = value[0]; complexNumber.imaginaryPart = value[1]; } else { throw SyntaxError('Invalid Complex Number Parameter'); } break; case 'string': { complexNumber.imaginaryPart = complexNumber.realPart = 0; const tokens = value.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g); let plus = 1; let minus = 0; if (tokens === null) { throw SyntaxError('Invalid Complex Number Parameter'); } for (let i = 0; i < tokens.length; i++) { const token = tokens[i]; if (token === ' ' || token === '\t' || token === '\n') { /* void */ } else if (token === '+') { plus++; } else if (token === '-') { minus++; } else if (token === 'i' || token === 'I') { if (plus + minus === 0) { throw SyntaxError('Invalid Complex Number Parameter'); } if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) { complexNumber.imaginaryPart += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]); i++; } else { complexNumber.imaginaryPart += parseFloat((minus % 2 ? '-' : '') + '1'); } plus = minus = 0; } else { if (plus + minus === 0 || isNaN(token)) { throw SyntaxError('Invalid Complex Number Parameter'); } if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') { complexNumber.imaginaryPart += parseFloat((minus % 2 ? '-' : '') + token); i++; } else { complexNumber.realPart += parseFloat((minus % 2 ? '-' : '') + token); } plus = minus = 0; } } if (plus + minus > 0) { throw SyntaxError('Invalid Complex Number Parameter'); } break; } case 'number': complexNumber.imaginaryPart = 0; complexNumber.realPart = value; break; default: throw SyntaxError('Invalid Complex Number Parameter'); } return complexNumber; } compare(value, imaginaryPart) { const complexNumber = this.parseComplexNumber(value, imaginaryPart); const epsilon = this.parseComplexNumber('1e-16'); return Math.abs(complexNumber.realPart - this.realPart) <= epsilon && Math.abs(complexNumber.imaginaryPart - this.imaginaryPart) <= epsilon; } toString() { let realPart = this.realPart; let imaginaryPart = this.imaginaryPart; let complexNumberAsString = ''; if (this.isNaN()) { return 'NaN'; } if (this.isZero()) { return '0'; } if (this.isInfinite()) { return 'Infinity'; } if (realPart !== 0) { complexNumberAsString += realPart; } if (imaginaryPart !== 0) { if (realPart !== 0) { complexNumberAsString += imaginaryPart < 0 ? ' - ' : ' + '; } else if (imaginaryPart < 0) { complexNumberAsString += '-'; } imaginaryPart = Math.abs(imaginaryPart); if (1 !== imaginaryPart) { complexNumberAsString += imaginaryPart; } complexNumberAsString += 'i'; } if (!complexNumberAsString) { return '0'; } return complexNumberAsString; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // class DataAdapter { constructor ( config ) { if ( !config ) { config = {}; } const that = Object.assign( this, config ); const generateKey = function () { const S4 = function () { return ( ( ( 1 + Math.random() ) * 0x10000 ) | 0 ).toString( 16 ).substring( 1 ); }; return S4(); }; that.key = generateKey(); that.$document = LW.Utilities.Extend( document ); that.boundSource = false === that.observable ? [] : new LW.ObservableArray(); that.dataItemById = []; if ( that.allowAdd === undefined ) { that.allowAdd = true; } if ( that.allowRemove === undefined ) { that.allowRemove = true; } if ( that.allowUpdate === undefined ) { that.allowUpdate = true; } if ( config.observable === undefined ) { that.observable = true; } if ( !config.dataSource ) { that.dataSource = []; } if ( !config.dataFields ) { that.dataFields = []; } else { /* if (config.dataSource && config.dataSource.length > 0) { const keys = Object.keys(config.dataSource[0]); // that.dataFields = []; for (let i = 0; i < keys.length; i++) { } } */ } if ( !config.dataSourceType ) { that.dataSourceType = 'array'; } if ( !config.id ) { that.id = null; } if ( !config.autoFetch ) { that.autoFetch = true; } if ( config.dataFields ) { that.dataFields = config.dataFields; } Object.defineProperty( that, 'groupBy', { configurable: false, enumerable: true, get() { if ( !that._groupBy ) { return []; } return that._groupBy; }, set( value ) { const updateGrouping = () => { that.boundHierarchy = null; that.refreshHierarchy(); if ( that.onGroup ) { that.onGroup(); } } that._groupBy = new LW.ObservableArray( value ); that._groupBy.notify( function () { updateGrouping(); } ); if ( that.isInitialized ) { updateGrouping(); } } } ); if ( !config.groupBy ) { that.groupBy = []; } else { if ( config.groupBy.toArray ) { that.groupBy = config.groupBy.toArray(); } else { that.groupBy = config.groupBy; } } if ( config && config.autoBind !== false ) { that.dataBind(); } that.isInitialized = true; } get dataFields() { const that = this; return that._dataFields; } set dataFields( value ) { const that = this; that._dataFields = that._getDataFieldObjects( value ); return that._dataFields; } _getDataFieldObjects( dataFields ) { //const that = this; let dataFieldObjects = []; if ( typeof dataFields === 'number' ) { const charCode = 'A'.charCodeAt( 0 ); let prefix = ''; let index = 0; for ( let i = 0; i < dataFields; i++ ) { const letter = String.fromCharCode( charCode + index ); index++; const label = prefix + letter; dataFieldObjects.push( { name: label, dataType: 'string' } ) if ( index >= 26 ) { index = 0; prefix += 'A'; } } } else if ( dataFields.length > 0 ) { for ( let i = 0; i < dataFields.length; i++ ) { const dataField = dataFields[ i ]; if ( typeof dataField === 'string' ) { const dataFieldParts = dataField.split( ':' ); const name = dataFieldParts[ 0 ].trim(); const dataType = dataFieldParts.length > 1 ? dataFieldParts[ 1 ].trim() : 'string'; dataFieldObjects.push( { name: name, dataType: dataType } ); } else { dataFieldObjects.push( dataField ); } } } return dataFieldObjects; } get dataSource() { const that = this; if ( !that._dataSource ) { that._dataSource = []; } return that._dataSource; } set dataSource( value ) { const that = this; that._dataSource = value; if ( that.isInitialized ) { that.boundSource = false === that.observable ? [] : new LW.ObservableArray(); that.dataItemById = []; that.bindingCompleted = false; that.dataBind(); } } get canNotify() { const that = this; if ( that._canNotify === undefined ) { that._canNotify = true; } return that._canNotify; } set canNotify( value ) { const that = this; that._canNotify = value; } _notify( changeArgs ) { const that = this; if ( !that.canNotify ) { return; } if ( that.notifyFn ) { that.notifyFn( changeArgs ); } } notify( notifyFn ) { const that = this; if ( notifyFn ) { that.notifyFn = notifyFn; } } toArray() { const that = this; return that.boundSource.toArray(); } dataBind() { const that = this; that.clear(); const completed = () => { if ( that.observable ) { that.boundSource.notify( function ( event ) { if ( event.action === 'update' && event.path && event.path.indexOf( '.' ) >= 0 && event.path.indexOf( 'children' ) === -1 && event.path.indexOf( 'loaded' ) === -1 && event.path.indexOf( 'level' ) === -1 && event.path.indexOf( 'leaf' ) === -1 && event.path.indexOf( 'expanded' ) === -1 ) { let canNotify = false; for ( let i = 0; i < that.dataFields.length; i++ ) { const dataField = that.dataFields[ i ].name; if ( event.path.indexOf( dataField ) >= 0 ) { canNotify = true; } } if ( that._notify && canNotify ) { that._notify( { action: 'update', data: event.target, index: event.index } ); } } } ); } that._onBindingComplete(); } if ( typeof that.dataSource === 'string' && ( that.dataSource.indexOf( '.json' ) >= 0 ) ) { that.url = that.dataSource; that.dataSourceType = 'json'; new Ajax( that, ( data/*, status*/ ) => { that.dataSource = data; that._bindToJSON(); } ); } else if ( typeof that.dataSource === 'string' && ( that.dataSource.indexOf( '.xlsx' ) >= 0 ) ) { that.url = that.dataSource; that.dataSourceType = 'xlsx'; new Ajax( that, ( data/*, status*/ ) => { if ( !data[ 0 ] ) { data = []; that._bindToArray(); completed(); return; } const keys = Object.keys( data[ 0 ] ); const dataFieldMap = {}; const dataRows = []; if ( that.exportHeader !== false ) { let index = 0; for ( let key in keys ) { const name = keys[ key ]; dataFieldMap[ name ] = that.dataFields[ index++ ].name; } for ( let i = 1; i < data.length; i++ ) { const row = data[ i ]; const dataRow = {}; for ( let key in keys ) { const name = keys[ key ]; dataRow[ dataFieldMap[ name ] ] = row[ name ]; } dataRows.push( dataRow ); } that.dataSource = dataRows; } that._bindToArray(); completed(); } ); } else if ( typeof that.dataSource === 'string' && ( that.dataSource.indexOf( '.csv' ) >= 0 ) ) { that.dataSourceType = 'csv'; new Ajax( that, (/*data, status*/ ) => { that._bindToArray(); } ); } else if ( typeof that.dataSource === 'string' && ( that.dataSource.indexOf( '.tsv' ) >= 0 ) ) { that.dataSourceType = 'tsv'; new Ajax( that, (/*data, status*/ ) => { } ); } else if ( that.dataSourceType === 'array' ) { that._bindToArray(); completed(); } else if ( that.dataSourceType === 'json' ) { that._bindToJSON(); completed(); } } _onBindingComplete() { const that = this; that._buildHierarchy(); if ( that.onBindingComplete ) { that.onBindingComplete( { data: that.boundSource } ); } if ( that._notify ) { that._notify( { action: 'bindingComplete', data: that.boundSource } ); } that.bindingCompleted = true; } refreshHierarchy() { const that = this; that._buildHierarchy(); } find() { const that = this; return that.boundSource.find.apply( that.boundSource, arguments ); } onVirtualDataSourceRequested( requestCallback, details ) { const that = this; let first = details ? details.first : Infinity; let last = details ? details.last : Infinity; let row = details ? details.row : null; if ( undefined === first ) { first = Infinity; } if ( undefined === last ) { last = Infinity; } that.virtualFirstIndex = first; that.virtualLastIndex = last; if ( that.virtualDataSource ) { const getDataSource = function ( dataAdapterSettings ) { if ( dataAdapterSettings.virtualDataSourceLength !== undefined ) { that.virtualDataSourceLength = dataAdapterSettings.virtualDataSourceLength; } new LW.DataAdapter( { dataSource: dataAdapterSettings.dataSource, dataFields: dataAdapterSettings.dataFields || that.dataFields, data: details, onBindingComplete( event ) { if ( that.virtualDataSourceOnExpand && row ) { if ( event.data && event.data.length > 0 ) { that.add( event.data, row.$.id ); } else { row.leaf = true; } if ( that.onFilter ) { that.onFilter() } requestCallback(); return; } if ( first === Infinity ) { that.add( event.data ); } else { let items = []; let indexes = []; for ( let i = 0; i < event.data.length; i++ ) { const item = event.data[ i ]; if ( first + i <= last ) { items.push( item ); indexes.push( first + i ); } } that.update( indexes, items ); } if ( that.onFilter ) { that.onFilter() } requestCallback(); } } ); } let hasCache = false; const isEmpty = ( obj ) => Object.entries( obj ).length === 0 && ( obj.constructor === Object || obj.constructor === Array ); const canCache = isEmpty( details.sorting ) && isEmpty( details.filtering ) && isEmpty( details.grouping ) && !details.row && ( details.action !== 'filter' && details.action !== 'sort' && details.action !== 'group' ); if ( that.virtualDataSourceCache && first !== Infinity && canCache ) { let cachedCount = 0; for ( let i = first; i < last; i++ ) { if ( !that[ i ].$.isEmpty ) { cachedCount++; } } if ( cachedCount === last - first ) { hasCache = true; } } if ( hasCache ) { requestCallback(); } else { if ( details.action === 'expand' ) { that.virtualDataSourceOnExpand( getDataSource, { first: first, last: last, row: details.row, sorting: details.sorting, filtering: details.filtering, grouping: details.grouping, action: details.action } ); } else { that.virtualDataSource( getDataSource, { first: first, last: last, sorting: details.sorting, filtering: details.filtering, filterOperator: details.filterOperator || 'and', grouping: details.grouping, action: details.action } ); } } } else { requestCallback(); } } add( item, parentId ) { const that = this; if ( !item ) { return; } let result = true; const addItem = function ( item ) { const itemObject = that._getDataItem( item, that.boundSource.length ); that[ that.boundSource.length ] = itemObject; that.dataItemById[ itemObject.$.id ] = itemObject; const pushResult = that.boundSource.push( itemObject ); if ( parentId !== undefined ) { itemObject.$.parentId = parentId; } if ( !pushResult ) { result = false; } return itemObject; } if ( item.length ) { let itemObjects = []; for ( let i = 0; i < item.length; i++ ) { const itemObject = addItem( item[ i ] ); itemObjects.push( itemObject ); } that._notify( { action: 'add', data: itemObjects } ); } else { const itemObject = addItem( item ); that._notify( { action: 'add', data: itemObject } ); } that.refreshHierarchy(); return result; } refreshIndexes() { const that = this; for (let i = 0; i < that.boundSource.length; i++) { that[i] = that.boundSource[i]; that[i].$.index = i; that.dataItemById[that[i].$.id] = that[i]; } let i = that.boundSource.length; while (that[i]) { delete that[i]; i++; } } removeLast() { const that = this; delete that[that.boundSource.length - 1]; const result = that.boundSource.pop(); delete that.dataItemById[result.$.id]; that._notify({ action: 'removeLast', data: result }); that.refreshHierarchy(); return result; } removeAt(index) { const that = this; const item = that.boundSource[index]; if (!item) { throw new Error('Invalid Item Index'); } that.boundSource.splice(index, 1); delete that.dataItemById[item.$.id]; that.refreshIndexes(); that._notify({ action: 'remove', index: index, data: item }); that.refreshHierarchy(); } update( index, dataSourceItem ) { const that = this; if ( LW.Utilities.Types.isArray( index ) && LW.Utilities.Types.isArray( dataSourceItem ) ) { if ( index.length === 0 && dataSourceItem.length === 0 ) { that.refreshHierarchy(); return; } } if ( dataSourceItem.length && index.length ) { let itemObjects = []; for ( let i = 0; i < index.length; i++ ) { const itemObject = that._getDataItem( dataSourceItem[ i ], index[ i ] ); const currentIndex = index[ i ]; itemObjects.push( itemObject ); that.boundSource[ currentIndex ] = itemObject; that[ currentIndex ] = that.boundSource[ currentIndex ]; that.dataItemById[ itemObject.$.id ] = that[ currentIndex ]; } that._notify( { action: 'update', index: index, data: itemObjects } ); that.refreshHierarchy(); return; } const itemObject = that._getDataItem( dataSourceItem, index ); that.boundSource[ index ] = itemObject; that[ index ] = that.boundSource[ index ]; that.dataItemById[ itemObject.$.id ] = that[ index ]; that._notify( { action: 'update', index: index, data: itemObject } ); that.refreshHierarchy(); return itemObject; } insert( index, item ) { const that = this; item = that._getDataItem( item, index ); const result = that.boundSource.splice( index, 0, item ); that.refreshIndexes(); that._notify( { action: 'insert', index: index, data: item } ); that.refreshHierarchy(); return result; } move( from, to ) { if ( to > from && to - from === 1 || from === to ) { return; } const that = this, recordToMove = that.boundSource.splice( from, 1 )[ 0 ]; if ( to > from ) { to--; that.boundSource.splice( to, 0, recordToMove ); } else { that.boundSource.splice( to, 0, recordToMove ); } that.refreshIndexes(); that._notify( { action: 'move', index: to, data: that.boundSource[ to ] } ); that.refreshHierarchy(); } indexOf( item ) { const that = this; const index = that.boundSource.indexOf( item ); return index; } get length() { const that = this; if ( that.virtualDataSourceLength !== undefined ) { return that.virtualDataSourceLength; } if ( that.dataSourceLength ) { return that.dataSourceLength; } if ( typeof ( that.dataSource ) === 'number' ) { return that.dataSource; } if ( that.bindingCompleted ) { return that.boundSource.length; } if ( that.dataSource && typeof that.dataSource !== 'string' && that.dataSource.length ) { return that.dataSource.length; } return that.boundSource.length; } clear() { const that = this; if ( !that.isInitialized ) { that._cachedValues = []; that.dataItemById = []; return; } for ( let i = 0; i < that.boundSource.length; i++ ) { delete that[ i ]; } that._cachedValues = []; that.boundSource = that.observable ? new LW.ObservableArray() : []; that.dataItemById = []; that.refreshHierarchy(); } _getId( id, item, index ) { if ( id !== null && id.name !== undefined ) { if ( id.name && item.getAttribute ) { let result = item.getAttribute( id.name ); if ( result !== null && result.toString().length > 0 ) { return result; } else if ( id.map ) { try { let result = item.getAttribute( id.map ); if ( result !== null && result.toString().length > 0 ) { return result; } } catch ( error ) { return index; } } return; } } if ( id ) { if ( id.toString().length > 0 && item.getAttribute ) { let result = item.getAttribute( id ); if ( result !== null && result.toString().length > 0 ) { return result.trim().split( ' ' ).join( '' ).replace( /([ #;?%&,.+*~\':'!^$[\]()=>|\/@])/g, '' ); } else { let splitMap = id.split( this.mapChar ); if ( splitMap.length > 1 ) { let d = item; for ( let p = 0; p < splitMap.length; p++ ) { if ( d !== undefined ) { d = d[ splitMap[ p ] ]; } } if ( d !== undefined ) { return d; } } else { if ( item[ id ] !== undefined ) { return item[ id ]; } } } } } return index; } _buildHierarchy() { const that = this; if ( !that.reservedNames ) { that.reservedNames = { leaf: 'leaf', parent: 'parent', expanded: 'expanded', checked: 'checked', selected: 'selected', level: 'level', icon: 'icon', data: 'data' } } else { const names = that.reservedNames; if ( !names.leaf ) { names.leaf = 'leaf'; } if ( !names.parent ) { names.parent = 'parent'; } if ( !names.expanded ) { names.expanded = 'expanded'; } if ( !names.checked ) { names.checked = 'checked'; } if ( !names.selected ) { names.selected = 'selected'; } if ( !names.level ) { names.level = 'level'; } if ( !names.data ) { names.data = 'data'; } } const names = that.reservedNames; if ( that.childrenDataField ) { const hierarchy = []; for ( let i = 0; i < that.boundSource.length; i++ ) { const item = Object.assign( {}, that.boundSource[ i ] ); if ( !item ) { continue; } hierarchy.push( item ); const addItems = function ( item ) { const splitMap = that.childrenDataField.split( that.mapChar ); let children = null; if ( splitMap.length > 1 ) { let data = item; for ( let p = 0; p < splitMap.length; p++ ) { if ( data !== undefined ) { data = data[ splitMap[ p ] ]; } } children = data; } else { children = item[ 'children' ]; } item[ 'children' ] = children; if ( item[ 'children' ] === null || item[ 'children' ] === undefined || ( item[ 'children' ] && item[ 'children' ].length === 0 ) ) { item[ names.leaf ] = true; } } addItems( item ); item[ names.level ] = 0; if ( !item.$ ) { item.$ = {}; } item[ names.parent ] = null; item[ names.data ] = item; if ( item[ names.expanded ] === undefined ) { item[ names.expanded ] = false; } const drillThrough = function ( parent, children ) { if ( !children ) { parent[ 'children' ] = new Array(); return; } for ( let i = 0; i < children.length; i++ ) { let item = that._getDataItem( children[ i ], i ); if ( !item ) { continue; } addItems( item ); item[ names.level ] = parent[ names.level ] + 1; item[ names.parent ] = parent; item[ names.data ] = item; if ( parent ) { parent[ 'children' ][ i ] = item; } if ( item[ names.expanded ] === undefined ) { item[ names.expanded ] = false; } drillThrough( item, item[ 'children' ] ); } } drillThrough( item, item[ 'children' ] ); } that.boundHierarchy = hierarchy; if ( !that._boundSourceUpdate ) { for ( let i = 0; i < that.boundHierarchy.length; i++ ) { const item = that.boundHierarchy[ i ]; if ( item.children ) { const drillThrough = function ( item ) { if ( !that.dataItemById[ item.$.id ] ) { that.boundSource.canNotify = false; that.dataItemById[ item.$.id ] = item; that[ that.boundSource.length ] = item; that.boundSource.push( item ); that.boundSource.canNotify = true; } if ( item.children ) { for ( let i = 0; i < item.children.length; i++ ) { const child = item.children[ i ]; if ( child.children ) { drillThrough( child ); } } } } drillThrough( item ); } } that._boundSourceUpdate = true; } } if ( that.xmlRoot && that.dataSourceType === 'xml' ) { that.boundHierarchy = this._getHierarchy( 'uid', '_parentuid', 'children', null, that.boundSource ); } if ( that.keyDataField && that.parentDataField ) { that.boundHierarchy = this._getHierarchy( that.keyDataField, that.parentDataField, 'children', null, that.boundSource ); } if ( that.groupBy && that.groupBy.length > 0 ) { that.boundHierarchy = this._getGroupHierarchy( that.groupBy, 'children', 'label', null, 'data', null, 'parent', that.boundSource ); } if ( that.virtualDataSourceOnExpand ) { that.boundHierarchy = this._getHierarchy( 'id', 'parentId', 'children', null, that.boundSource ); } } _getGroupHierarchy( groups, collectionName, groupName, mappingFields, itemName, valueName, parentName, data, startIndex ) { let that = this; if ( !startIndex ) { startIndex = 0; } let names = that.reservedNames; const guid = function () { function s4() { return Math.floor( ( 1 + Math.random() ) * 0x10000 ) .toString( 16 ) .substring( 1 ); } return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4(); } let groupHashCodes = new Array(); for ( let iGroupColumn = 0; iGroupColumn < groups.length; iGroupColumn++ ) { groupHashCodes[ iGroupColumn ] = guid(); } if ( !collectionName ) { collectionName = 'children'; } if ( !groupName ) { groupName = 'group'; } if ( !itemName ) { itemName = 'item'; } if ( !parentName ) { parentName = 'parent'; } if ( undefined === valueName ) { valueName = 'value'; } const groupboundSource = new Array(); const hashItemGroups = new Array(); let groupboundSourceIndex = 0; const getItem = function ( item ) { let itemObj = item; if ( mappingFields ) { for ( let mappingField in mappingFields ) { const mappingObject = mappingFields[ mappingField ]; if ( mappingObject.name && mappingObject.map ) { itemObj[ mappingObject.map ] = itemObj[ mappingObject.name ]; } } } return itemObj; } for ( let obj = 0; obj < data.length; obj++ ) { let item = Object.assign( {}, getItem( data[ obj ] ) ); item[ names.leaf ] = false; let itemKeysHierarchy = new Array(); let keys = 0; for ( let iGroupColumn = 0; iGroupColumn < groups.length; iGroupColumn++ ) { const group = groups[ iGroupColumn ]; const value = item[ group ]; if ( null === value ) { continue; } itemKeysHierarchy[ keys++ ] = { value: value, group: group, hash: groupHashCodes[ iGroupColumn ] }; } if ( itemKeysHierarchy.length !== groups.length ) { break; } let parentItem = null; let lookupKey = ''; for ( let q = 0; q < itemKeysHierarchy.length; q++ ) { const itemKey = itemKeysHierarchy[ q ].value; const groupDataField = itemKeysHierarchy[ q ].group; const columnHash = itemKeysHierarchy[ q ].hash; lookupKey = lookupKey + '_' + columnHash + '_' + itemKey; if ( hashItemGroups[ lookupKey ] !== undefined && hashItemGroups[ lookupKey ] !== null ) { parentItem = hashItemGroups[ lookupKey ]; continue; } if ( parentItem === null ) { parentItem = { $: {} }; parentItem[ names.level ] = 0; parentItem[ names.leaf ] = false; parentItem[ parentName ] = null; parentItem[ groupName ] = itemKey; parentItem[ itemName ] = item; parentItem[ 'groupDataField' ] = groupDataField; if ( !parentItem[ groupDataField ] ) { parentItem[ groupDataField ] = parentItem.data[ groupDataField ]; } if ( item[ names.expanded ] !== undefined ) { parentItem[ names.expanded ] = item[ names.expanded ]; } else { parentItem[ names.expanded ] = false; } if ( valueName ) { parentItem[ valueName ] = item[ valueName ]; } parentItem[ collectionName ] = new Array(); let uid = groupboundSource.length + startIndex; if ( !this.id || typeof item.$.id === 'number' || isFinite( item.$.id ) ) { uid = 'Item' + uid; } if ( parentItem.$.id === undefined ) { parentItem.$.id = uid; } groupboundSource[ groupboundSourceIndex++ ] = parentItem; } else { const subItem = { $: {} }; subItem[ names.level ] = parentItem[ names.level ] + 1; subItem[ parentName ] = parentItem; subItem[ groupName ] = itemKey; subItem[ collectionName ] = new Array(); subItem[ itemName ] = item; subItem[ 'groupDataField' ] = groupDataField; subItem[ names.leaf ] = false; if ( !subItem[ groupDataField ] ) { subItem[ groupDataField ] = subItem.data[ groupDataField ]; } if ( item[ names.expanded ] !== undefined ) { subItem[ names.expanded ] = item[ names.expanded ]; } else { subItem[ names.expanded ] = false; } if ( valueName ) { subItem[ valueName ] = item[ valueName ]; } if ( subItem.$.id === undefined ) { subItem.$.id = parentItem.$.id + '_' + parentItem[ collectionName ].length; } parentItem[ collectionName ][ parentItem[ collectionName ].length ] = subItem; parentItem = subItem; } hashItemGroups[ lookupKey ] = parentItem; } if ( item ) { item[ names.leaf ] = true; } if ( parentItem !== null ) { if ( this.id === null ) { if ( undefined === item.$.id ) { item.$.id = parentItem.$.id + '_' + parentItem[ collectionName ].length; } } else { if ( undefined === item.$.id ) { if ( item.$.id.toString().indexOf( parentItem.$.id ) === -1 ) { item.$.id = parentItem.$.id + '_' + item.$.id; } } } item[ parentName ] = parentItem; item[ names.level ] = parentItem[ names.level ] + 1; parentItem[ collectionName ][ parentItem[ collectionName ].length ] = item; } else { if ( undefined === item.$.id ) { item.$.id = guid(); } } } return groupboundSource; } _getHierarchy( fieldName, parentFieldName, collectionName, mappingFields, boundSource ) { const that = this; const databoundHierarchy = new Array(); let flatData = this.boundSource; if ( boundSource ) { flatData = boundSource; } if ( this.boundSource.length === 0 ) return null; const childrenName = collectionName !== null ? collectionName : 'children'; let items = new Array(); let data = flatData; let dataLength = data.length; let names = that.reservedNames; const getItem = function ( item ) { let itemObj = item; if ( mappingFields ) { for ( let mappingField in mappingFields ) { const mappingObject = mappingFields[ mappingField ]; if ( mappingObject.name && mappingObject.map ) { itemObj[ mappingObject.map ] = itemObj[ mappingObject.name ]; } } } return itemObj; } // build hierarchical source. for ( let i = 0; i < dataLength; i++ ) { let item = data[ i ]; let parentId = item[ parentFieldName ]; let id = item[ fieldName ]; if ( parentFieldName === 'parentId' ) { parentId = item.$.parentId; } if ( fieldName === 'id' ) { id = item.$.id; } item[ childrenName ] = new Array(); items[ id ] = { parentId: parentId, item: item }; } for ( let i = 0; i < dataLength; i++ ) { const item = data[ i ]; let parentId = item[ parentFieldName ]; let id = item[ fieldName ]; if ( parentFieldName === 'parentId' ) { parentId = item.$.parentId; } if ( fieldName === 'id' ) { id = item.$.id; } if ( items[ parentId ] !== undefined ) { let item = { parentId: parentId, item: items[ id ].item }; let parentItem = items[ parentId ].item; if ( !parentItem[ childrenName ] ) { parentItem[ childrenName ] = new Array(); } let length = parentItem[ childrenName ].length; item = item.item; if ( !names ) { if ( item.parent === undefined ) { item.parent = parentItem; } } else { if ( item[ names.parent ] === undefined ) { item[ names.parent ] = parentItem; } } const itemObj = getItem( item ); parentItem[ childrenName ][ length ] = itemObj; items[ parentId ].item = parentItem; items[ id ].item = item; } else { let item = items[ id ].item; if ( !names ) { if ( item.parent === undefined ) { item.parent = null; } } else { if ( item[ names.parent ] === undefined ) { item[ names.parent ] = null; } } const itemObj = getItem( item ); if ( !names ) { itemObj.level = 0; } else { itemObj[ names.level ] = 0; } databoundHierarchy[ databoundHierarchy.length ] = itemObj; } } if ( databoundHierarchy.length !== 0 ) { let updateLevels = function ( level, children ) { for ( let i = 0; i < children.length; i++ ) { const child = children[ i ]; if ( !names ) { child.level = level; } else { child[ names.level ] = level; } const childChildren = child[ childrenName ]; if ( childChildren ) { if ( childChildren.length > 0 ) { updateLevels( level + 1, childChildren ); } else { if ( that.virtualDataSourceOnExpand ) { if ( child.leaf === undefined ) { child.leaf = false; } } else { if ( !names ) { child.leaf = true; } else { child[ names.leaf ] = true; } } } } else { if ( that.virtualDataSourceOnExpand ) { if ( child.leaf === undefined ) { child.leaf = false; } } else { if ( !names ) { child.leaf = true; } else { child[ names.leaf ] = true; } } } } }; updateLevels( 0, databoundHierarchy ); } return databoundHierarchy; } summarize( summaryItems, boundSource ) { const that = this; if ( !Array.isArray( summaryItems ) ) { summaryItems = [ summaryItems ]; } let tempSummaryItems = []; for ( let i = 0; i < summaryItems.length; i++ ) { const summaryItem = summaryItems[ i ]; for ( let name in summaryItem ) { const functions = summaryItem[ name ]; tempSummaryItems.push( { dataField: name, functions: functions } ) } } summaryItems = tempSummaryItems; let data = {}; let summaryByDataField = new Array(); if ( !boundSource ) { boundSource = that.boundSource; } let length = boundSource.length; if ( length === 0 ) { return; } if ( length === undefined ) { return; } for ( let i = 0; i < length; i++ ) { let dataItem = boundSource[ i ]; for ( let j = 0; j < summaryItems.length; j++ ) { const summaryItem = summaryItems[ j ]; let value = dataItem[ summaryItem.dataField ]; if ( summaryItem.functions ) { data[ summaryItem.dataField ] = data[ summaryItem.dataField ] || {}; summaryByDataField[ summaryItem.dataField ] = summaryByDataField[ summaryItem.dataField ] || 0; summaryByDataField[ summaryItem.dataField ]++; const _summaryItemFunction = function ( summaryItemObject ) { for ( let name in summaryItemObject ) { let oldValue = data[ summaryItem.dataField ][ name ]; if ( oldValue === null || oldValue === undefined ) { data[ summaryItem.dataField ][ name ] = 0; oldValue = 0; } if ( typeof summaryItemObject[ name ] === 'function' ) { oldValue = summaryItemObject[ name ]( oldValue, value, summaryItem.dataField, dataItem ); } data[ summaryItem.dataField ][ name ] = oldValue; } } let canParse = parseFloat( value ); if ( isNaN( canParse ) ) { canParse = false; } else { canParse = true; } if ( canParse ) { value = parseFloat( value ); } if ( typeof value === 'number' && isFinite( value ) ) { summaryItem.functions.forEach( function ( summaryItemFunction ) { let oldValue = data[ summaryItem.dataField ][ summaryItemFunction ]; if ( oldValue === null || oldValue === undefined ) { oldValue = 0; if ( summaryItemFunction === 'min' ) { oldValue = 9999999999999; } if ( summaryItemFunction === 'max' ) { oldValue = -9999999999999; } } if ( summaryItemFunction === 'sum' || summaryItemFunction === 'avg' || summaryItemFunction === 'stdev' || summaryItemFunction === 'stdevp' || summaryItemFunction === 'var' || summaryItemFunction === 'varp' ) { oldValue += parseFloat( value ); } else if ( summaryItemFunction === 'product' ) { if ( i === 0 ) oldValue = parseFloat( value ); else oldValue *= parseFloat( value ); } else if ( summaryItemFunction === 'min' ) { oldValue = Math.min( oldValue, parseFloat( value ) ); } else if ( summaryItemFunction === 'max' ) { oldValue = Math.max( oldValue, parseFloat( value ) ); } else if ( summaryItemFunction === 'count' ) { oldValue++; } else if ( typeof ( summaryItemFunction ) === 'object' ) { _summaryItemFunction( summaryItemFunction ); return; } data[ summaryItem.dataField ][ summaryItemFunction ] = oldValue; } ); } else { summaryItem.functions.forEach( function ( summaryItemFunction ) { if ( summaryItemFunction === 'min' || summaryItemFunction === 'max' || summaryItemFunction === 'count' || summaryItemFunction === 'product' || summaryItemFunction === 'sum' || summaryItemFunction === 'avg' || summaryItemFunction === 'stdev' || summaryItemFunction === 'stdevp' || summaryItemFunction === 'var' || summaryItemFunction === 'varp' ) { if ( value === null ) { return true; } let oldValue = data[ summaryItem.dataField ][ summaryItemFunction ]; if ( oldValue === null || oldValue === undefined ) { oldValue = 0; } data[ summaryItem.dataField ][ summaryItemFunction ] = oldValue; return true; } if ( typeof ( summaryItemFunction ) === 'object' ) { _summaryItemFunction( summaryItemFunction ); } } ); } } } } for ( let j = 0; j < summaryItems.length; j++ ) { const summaryItem = summaryItems[ j ]; if ( !summaryItem.functions ) { continue; } if ( !data[ summaryItem.dataField ] ) { data[ summaryItem.dataField ] = {}; summaryItem.functions.forEach( function ( summaryItemFunction ) { data[ summaryItem.dataField ][ summaryItemFunction ] = 0; } ); } if ( data[ summaryItem.dataField ][ 'avg' ] !== undefined ) { const value = data[ summaryItem.dataField ][ 'avg' ]; const dataValues = summaryByDataField[ summaryItem.dataField ]; if ( dataValues === 0 || dataValues === undefined ) { data[ summaryItem.dataField ][ 'avg' ] = 0; } else { data[ summaryItem.dataField ][ 'avg' ] = value / dataValues; } } else if ( data[ summaryItem.dataField ][ 'count' ] !== undefined ) { data[ summaryItem.dataField ][ 'count' ] = length; } // stdev, stdevp, var, varp. // stdev - Standard deviation on a sample. // varp - Variance on an entire population. // let - Variance on a sample. if ( data[ summaryItem.dataField ][ 'stdev' ] || data[ summaryItem.dataField ][ 'stdevp' ] || data[ summaryItem.dataField ][ 'var' ] || data[ summaryItem.dataField ][ 'varp' ] ) { summaryItem.functions.forEach( function ( summaryItemFunction ) { if ( summaryItemFunction === 'stdev' || summaryItemFunction === 'var' || summaryItemFunction === 'varp' || summaryItemFunction === 'stdevp' ) { const value = data[ summaryItem.dataField ][ summaryItemFunction ]; const count = length; const average = ( value / length ); let sumSq = 0.0; for ( let i = 0; i < length; i++ ) { let dataItem = boundSource[ i ]; let value = dataItem[ summaryItem.dataField ]; sumSq += ( value - average ) * ( value - average ); } let denominator = ( summaryItemFunction === 'stdevp' || summaryItemFunction === 'varp' ) ? count : count - 1; if ( denominator === 0 ) { denominator = 1; } if ( summaryItemFunction === 'var' || summaryItemFunction === 'varp' ) { data[ summaryItem.dataField ][ summaryItemFunction ] = sumSq / denominator; } else if ( summaryItemFunction === 'stdevp' || summaryItemFunction === 'stdev' ) { data[ summaryItem.dataField ][ summaryItemFunction ] = Math.sqrt( sumSq / denominator ); } } } ); } } return data; } _getDataItem( dataSourceItem, index ) { const that = this; const itemObject = {}; const unboundMode = typeof ( that.dataSource ) === 'number' || that.dataSourceLength; if ( !dataSourceItem ) { return { $: { id: index, isEmpty: true, index: index } } } if ( typeof dataSourceItem === 'string' ) { dataSourceItem = { '': dataSourceItem }; } if ( unboundMode ) { for ( let j = 0; j < that.dataFields.length; j++ ) { const dataField = that.dataFields ? that.dataFields[ j ] : {}; itemObject[ dataField.name ] = ''; } itemObject.$ = {}; itemObject.$.id = index; itemObject.$.index = index; return itemObject; } const dataItem = dataSourceItem; if ( dataItem.expanded !== undefined ) { itemObject.expanded = dataItem.expanded; if ( dataItem.expanded === 'true' || dataItem.expanded === true || dataItem.expanded === 1 ) { itemObject.expanded = true; } else { itemObject.expanded = false; } } if ( that.childrenDataField ) { if ( dataItem[ that.childrenDataField ] !== undefined ) { itemObject.children = dataItem[ that.childrenDataField ]; } } else { if ( dataItem.children !== undefined ) { itemObject.children = dataItem.children; } else if ( dataItem.items !== undefined ) { itemObject.children = dataItem.items; } } if ( dataItem.leaf !== undefined ) { itemObject.leaf = dataItem.leaf; } if ( dataItem.level !== undefined ) { itemObject.level = dataItem.level; } if ( that.keyDataField ) { if ( dataItem[ that.keyDataField ] !== undefined ) { itemObject[ that.keyDataField ] = dataItem[ that.keyDataField ]; } } if ( that.parentDataField ) { if ( dataItem[ that.parentDataField ] !== undefined ) { itemObject[ that.parentDataField ] = dataItem[ that.parentDataField ]; } } if ( that.dataFields.length === 0 ) { const names = Object.getOwnPropertyNames( dataSourceItem ); for ( let i = 0; i < names.length; i++ ) { if ( names[ i ] === '$' ) { continue; } that.dataFields.push( { name: names[ i ], dataType: 'string' } ); } } for ( let j = 0; j < that.dataFields.length; j++ ) { const dataField = that.dataFields ? that.dataFields[ j ] : {}; let value = ''; if ( undefined === dataField || dataField === null ) { continue; } if ( dataSourceItem.length ) { value = dataSourceItem[ j ]; } if ( dataField.map ) { let splitMap = dataField.map.split( that.mapChar ); if ( splitMap.length > 0 ) { let dataMappedItem = dataItem; for ( let p = 0; p < splitMap.length; p++ ) { if ( !dataItem ) { continue; } dataMappedItem = dataMappedItem[ splitMap[ p ] ]; } value = dataMappedItem; } else { value = dataItem[ dataField.map ]; } } if ( value !== undefined && value !== null ) { value = value.toString(); } else { if ( value === undefined && value !== null ) { value = ''; } } let isEmptyString = false; // searches by both selectors when necessary. if ( value === '' ) { isEmptyString = true; value = dataSourceItem[ dataField.name ]; if ( value !== undefined && value !== null ) { if ( dataField.dataType !== 'array' ) { if ( dataField.dataType !== 'date' ) { value = value.toString(); } } } else { value = ''; } } if ( value === '[object Object]' && dataField.map && isEmptyString ) { value = ''; } if ( that._cachedValues[ '' + value + '_' + dataField.dataType ] ) { value = that._cachedValues[ '' + value + '_' + dataField.dataType ]; } else { if ( dataField.dataType === 'bool' || dataField.dataType === 'boolean' ) { if ( value === 'true' || value === '1' ) { value = true; } else if ( value === 'false' || value === '0' ) { value = false; } } else { value = that.$document.deserialize( '' + value, dataField.dataType, true ); } that._cachedValues[ value + '_' + dataField.dataType ] = value; } if ( dataField.dataType !== 'string' && dataField.dataType !== 'boolean' && dataField.dataType !== 'bool' ) { if ( isNaN( value ) || value === -Infinity || value === Infinity ) { value = 0; } } itemObject[ dataField.name ] = value; } let itemObjectId = index; if ( that.id ) { itemObjectId = dataItem[ that.id ]; if ( typeof ( itemObjectId ) === 'object' ) { itemObjectId = index; } } else if ( !that.virtualDataSource && that.dataItemById && that.dataItemById[ itemObjectId ] ) { itemObjectId = that.length; } if ( !itemObject.$ ) { itemObject.$ = {}; } itemObject.$.id = itemObjectId; itemObject.$.index = index; return new Object( itemObject ); } _bindToArray() { const that = this; const unboundMode = typeof ( that.dataSource ) === 'number' || that.dataSourceLength; const dataArray = []; that.boundSource.canNotify = false; for ( let i = 0; i < that.length; i++ ) { const dataSourceItem = unboundMode ? {} : that.dataSource[ i ]; const itemObject = that._getDataItem( dataSourceItem, i ); dataArray.push( itemObject ); } if ( unboundMode && that.dataSourceLength && that.dataSource.length > 0 ) { for ( let i = 0; i < that.dataSource.length; i++ ) { const cell = that.dataSource[ i ].cell; const value = that.dataSource[ i ].value; const row = cell.replace( /[^0-9]/g, '' ); const dataField = cell.replace( /[0-9]/g, '' ); dataArray[ row - 1 ][ dataField ] = value; } } that.boundSource = false === that.observable ? dataArray : new LW.ObservableArray( dataArray ); for ( let i = 0; i < that.length; i++ ) { that[ i ] = that.boundSource[ i ]; that.dataItemById[ that[ i ].$.id ] = that[ i ]; } that.boundSource.canNotify = true; } _bindToJSON() { const that = this; const dataArray = []; const dataEntries = Object.entries( that.dataSource ); that.boundSource.canNotify = false; for ( let i = 0; i < dataEntries.length; i++ ) { const dataSourceItem = dataEntries[ i ]; const itemObject = that._getDataItem( dataSourceItem, i ); dataArray.push( itemObject ); } that.boundSource = false === that.observable ? dataArray : new LW.ObservableArray( dataArray ); for ( let i = 0; i < that.length; i++ ) { that[ i ] = that.boundSource[ i ]; that.dataItemById[ that[ i ].$.id ] = that[ i ]; } that.boundSource.canNotify = true; } sortBy( dataField, dataType, orderBy ) { const that = this; if ( !dataType ) { for ( let i = 0; i < that.dataFields.length; i++ ) { const field = that.dataFields[ i ]; if ( field.name === dataField ) { dataType = field.dataType; break; } } } if ( that.boundHierarchy ) { if ( ( !dataField || dataField.length === 0 ) && that.groupBy.length > 0 ) { that.refreshHierarchy(); return; } const sortBy = function ( hierarchy ) { that._sort( hierarchy, dataField, orderBy, dataType ); for ( let i = 0; i < hierarchy.length; i++ ) { const item = hierarchy[ i ]; if ( item[ 'children' ] ) { sortBy( item[ 'children' ], dataField, orderBy, dataType ); } } } sortBy( that.boundHierarchy ); } else { that._sort( that.boundSource, dataField, orderBy, dataType ); } } _createFilter( dataType, filterExpressions ) { const filterOperators = { '=': 'EQUAL', '<>': 'NOT_EQUAL', '<': 'LESS_THAN', '>': 'GREATER_THAN', '<=': 'LESS_THAN_OR_EQUAL', '>=': 'GREATER_THAN_OR_EQUAL', 'equal': 'EQUAL', 'not equal': 'NOT_EQUAL', 'less than': 'LESS_THAN', 'greater than': 'GREATER_THAN', 'greater than or equal': 'GREATER_THAN_OR_EQUAL', 'less than or equal': 'LESS_THAN_OR_EQUAL', 'starts with': 'STARTS_WITH', 'ends with': 'ENDS_WITH', 'null': 'null', '': 'EMPTY', 'isblank': 'EMPTY', 'isnotblank': 'NOT_EMPTY', 'contains': 'CONTAINS', 'notcontains': 'DOES_NOT_CONTAIN', 'startswith': 'STARTS_WITH', 'endswith': 'ENDS_WITH', 'NULL': 'NULL', 'NOT_NULL': 'NOT_NULL' }; let filterExpressionsArray = []; for ( let i = 0; i < filterExpressions.length; i++ ) { const filterExpression = filterExpressions[ i ]; const filterExpressionParts = filterExpression.indexOf( '"' ) === -1 ? filterExpression.split( ' ' ) : filterExpression.split( '"' ); let filter = []; for ( let j = 0; j < filterExpressionParts.length; j++ ) { const part = filterExpressionParts[ j ]; if ( part !== '' ) { filter.push( part.trim() ); } } filterExpressionsArray.push( filter ); } const filterGroup = new LW.FilterGroup(); const filterGroupOperators = []; const filterSubGroups = []; for ( let i = 0; i < filterExpressionsArray.length; i++ ) { const filterExpression = filterExpressionsArray[ i ]; if ( filterExpression.length > 1 ) { const filterSubGroup = new LW.FilterGroup(); let operator = 'and'; let filterExpressionPartsCounter = 0; for ( let j = 0; j < filterExpression.length; j++ ) { const value = filterExpression[ j ]; if ( value === 'and' || value === 'or' ) { operator = value; continue; } filterExpressionPartsCounter++; if ( filterExpressionPartsCounter === 2 ) { const filter = filterSubGroup.createFilter( dataType, value, filterOperators[ filterExpression[ j - 1 ] ] ); filterExpressionPartsCounter = 0; if ( operator ) { filterSubGroup.addFilter( operator, filter ); } } } filterSubGroups.push( filterSubGroup ); } else { const filterGroupOperator = filterExpression[ 0 ]; if ( filterGroupOperator !== 'and' && filterGroupOperator !== 'or' ) { throw new Error( 'Filter Exprresion expects "AND" or "OR", but the token is: ' + filterGroupOperator ); } filterGroupOperators.push( filterGroupOperator ); } } let operatorsCounter = 0; if ( filterSubGroups.length === 1 ) { return filterSubGroups[ 0 ]; } for ( let i = 0; i < filterSubGroups.length; i++ ) { let operator = filterGroupOperators[ operatorsCounter ]; if ( ( i + 1 ) % 2 === 0 ) { operatorsCounter++; } if ( !operator ) { operator = 'and'; } filterGroup.addFilter( operator, filterSubGroups[ i ] ); } return filterGroup; } filterBy( dataField, ...filterExpressions ) { const that = this; const dataType = ( () => { for ( let i = 0; i < that.dataFields.length; i++ ) { const field = that.dataFields[ i ]; if ( field.name === dataField ) { return field.dataType; } } } )(); const filterGroup = that._createFilter( dataType, filterExpressions ); let filteredData = that.boundSource.filter( ( value ) => { const evaluation = filterGroup.evaluate( value[ dataField ] ); return evaluation; } ); return filteredData; } _filter( filters, operator = 'and' ) { const that = this; const filterGroups = []; const dataFields = []; if ( filters.length === 0 ) { that.clearFilter(); return; } const dataType = ( dataField ) => { for ( let i = 0; i < that.dataFields.length; i++ ) { const field = that.dataFields[ i ]; if ( field.name === dataField ) { return field.dataType; } } }; let defaultResult, operatorSpecificEval; if ( operator === 'and' ) { defaultResult = true; operatorSpecificEval = function ( result, filterGroup, row ) { return result && filterGroup.evaluate( row[ filterGroup.dataField ] ); }; } else { defaultResult = false; operatorSpecificEval = function ( result, filterGroup, row ) { return result || filterGroup.evaluate( row[ filterGroup.dataField ] ); }; } for ( let i = 0; i < filters.length; i++ ) { const filter = filters[ i ]; const dataField = filter[ 0 ]; let filterGroup = null; if ( filter[ 1 ] instanceof LW.FilterGroup ) { filterGroup = filter[ 1 ]; } else { filterGroup = that._createFilter( dataType( dataField ), filter.splice( 1 ) ); } if ( filterGroup ) { dataFields.push( dataField ); filterGroup.dataField = dataField; filterGroups.push( filterGroup ); } } if ( that.boundHierarchy ) { const filter = function ( row ) { let result = defaultResult; for ( let j = 0; j < filterGroups.length; j++ ) { const filterGroup = filterGroups[ j ]; result = operatorSpecificEval( result, filterGroup, row ); } row.$.filtered = result; return result; } const filterBy = function ( hierarchy, parentItem, root ) { let filteredCount = 0; for ( let i = 0; i < hierarchy.length; i++ ) { const item = hierarchy[ i ]; filter( item ); if ( item.$.filtered ) { filteredCount++; } if ( item[ 'children' ] ) { filterBy( item[ 'children' ], item, parentItem ); } } if ( filteredCount > 0 && that.groupBy.length > 0 && parentItem ) { parentItem.$.filtered = true; if ( root && !root.$.filtered ) { root.$.filtered = true; } } else { if ( filteredCount > 0 && filteredCount !== hierarchy.length && parentItem ) { parentItem.$.filtered = null; if ( root && !root.$.filtered ) { root.$.filtered = null; } } } } filterBy( that.boundHierarchy, null, null ); } else { for ( let i = 0; i < that.boundSource.length; i++ ) { const row = that.boundSource[ i ]; let result = defaultResult; for ( let j = 0; j < filterGroups.length; j++ ) { const filterGroup = filterGroups[ j ]; result = operatorSpecificEval( result, filterGroup, row ); } row.$.filtered = result; } } if ( that.onFilter ) { that.onFilter() } } clearGroup() { const that = this; that.groupBy = []; that.boundHierarchy = null; that.refreshHierarchy(); if ( that.onGroup ) { that.onGroup() } } clearFilter() { const that = this; for ( let i = 0; i < that.boundSource.length; i++ ) { const row = that.boundSource[ i ]; row.$.filtered = true; } if ( that.boundHierarchy ) { const filterBy = function ( hierarchy, parentItem, root ) { //let filteredCount = 0; for ( let i = 0; i < hierarchy.length; i++ ) { const item = hierarchy[ i ]; item.$.filtered = true; if ( item.$.filtered ) { //filteredCount++; } if ( item[ 'children' ] ) { filterBy( item[ 'children' ], item, parentItem ); } } if ( parentItem ) { parentItem.$.filtered = true; if ( root && !root.$.filtered ) { root.$.filtered = true; } } } filterBy( that.boundHierarchy, null, null ); } if ( that.onFilter ) { that.onFilter() } } clearSort() { const that = this; that._sort( that.boundSource, [], [], [] ); } _sort( dataSource, sortColumns, directions, dataTypes, customSortingCallback ) { const that = this; let isObservableArray = false; if ( dataSource.length === 0 ) { return; } if ( dataSource && dataSource.constructor && dataSource instanceof LW.ObservableArray ) { isObservableArray = true; } if ( !dataSource || !( Array.isArray( dataSource ) ) || dataSource.length === 0 || !sortColumns || Array.isArray( sortColumns ) && sortColumns.length === 0 ) { if ( !isObservableArray && !that.boundHierarchy ) { throw new Error( 'sort: Missing or Invalid arguments!' ); } } if ( typeof sortColumns === 'string' ) { sortColumns = [ sortColumns ]; } const directionCoefficients = [], compareFunctions = []; if ( directions === undefined ) { directions = []; } const getCompareFunction = function ( a, knownDataType ) { // gets data type of column (not necessary if the Grid provides this information) const dataType = knownDataType || typeof a; let compareFunction; switch ( dataType ) { case 'string': compareFunction = new Intl.Collator().compare; break; case 'number': compareFunction = function ( a, b ) { return a - b; }; break; case 'boolean': case 'bool': compareFunction = function ( a, b ) { if ( a === b ) { return 0; } else if ( a === false ) { return -1; } else { return 1; } }; break; case 'date': case 'time': case 'dateTime': if ( a instanceof Date ) { compareFunction = function ( a, b ) { return a.getTime() - b.getTime(); }; } else if ( a instanceof LW.Utilities.DateTime || a instanceof LW.Utilities.BigNumber ) { compareFunction = function ( a, b ) { return a.compare( b ); }; } break; case 'object': if ( a instanceof Date ) { compareFunction = function ( a, b ) { return a.getTime() - b.getTime(); }; } else if ( a instanceof LW.Utilities.DateTime || a instanceof LW.Utilities.BigNumber ) { compareFunction = function ( a, b ) { return a.compare( b ); }; } else if ( a instanceof LW.Utilities.Complex || ( window.NIComplex && a instanceof window.NIComplex ) ) { const complexNumericProcessor = new LW.Utilities.ComplexNumericProcessor(); compareFunction = function ( a, b ) { return complexNumericProcessor.compareComplexNumbers( a, b ); } } break; } return compareFunction; } for ( let i = 0; i < sortColumns.length; i++ ) { if ( directions[ i ] === undefined || directions[ i ] === 'asc' || directions[ i ] === 'ascending' ) { directionCoefficients[ i ] = 1; } else { directionCoefficients[ i ] = -1; } const value = dataSource[ 0 ][ sortColumns[ i ] ]; compareFunctions[ i ] = getCompareFunction( value, dataTypes[ i ] ); } if ( customSortingCallback ) { customSortingCallback( dataSource, sortColumns, directions, compareFunctions ); return; } dataSource.sort( function ( a, b ) { for ( let i = 0; i < sortColumns.length; i++ ) { const result = compareFunctions[ i ]( a[ sortColumns[ i ] ], b[ sortColumns[ i ] ] ); if ( result === 0 ) { if ( sortColumns[ i + 1 ] ) { continue; } else if ( a._index !== undefined ) { // makes sorting stable return ( a._index - b._index ) * directionCoefficients[ i ]; } return 0; } return result * directionCoefficients[ i ]; } if ( sortColumns.length === 0 ) { if ( a.$.index < b.$.index ) { return -1; } if ( a.$.index > b.$.index ) { return 1; } return 0; } } ); for ( let i = 0; i < dataSource.length; i++ ) { that[ i ] = dataSource[ i ]; } } static Filter( dataSource, filterColumns, filterGroups, customFilteringCallback, operator = 'and' ) { let defaultResult, operatorSpecificEval; if ( operator === 'and' ) { defaultResult = true; operatorSpecificEval = function ( result, dataItem, filterColumn, filterGroup ) { if ( customFilteringCallback ) { return result && customFilteringCallback( dataItem, filterColumn, filterGroup ); } return result && filterGroup.evaluate( dataItem[ filterColumn ] ); }; } else { defaultResult = false; operatorSpecificEval = function ( result, dataItem, filterColumn, filterGroup ) { if ( customFilteringCallback ) { return result || customFilteringCallback( dataItem, filterColumn, filterGroup ); } return result || filterGroup.evaluate( dataItem[ filterColumn ] ); }; } const filteredData = dataSource.filter( ( dataItem ) => { let result = defaultResult; for ( let i = 0; i < filterGroups.length; i++ ) { const filterGroup = filterGroups[ i ]; const filterColumn = filterColumns[ i ]; result = operatorSpecificEval( result, dataItem, filterColumn, filterGroup ); } return result; } ); return filteredData; } filter( filterColumns, filterGroups, customFilteringCallback ) { LW.DataAdapter.Filter( this.boundSource, filterColumns, filterGroups, customFilteringCallback ); } sort( sortColumns, directions, customSortingCallback ) { LW.DataAdapter.Sort( this.boundSource, sortColumns, directions, customSortingCallback ); } static Sort( dataSource, sortColumns, directions, customSortingCallback ) { const getCompareFunction = function ( a ) { // gets data type of column (not necessary if the Grid provides this information) const dataType = typeof a; let compareFunction; switch ( dataType ) { case 'string': compareFunction = new Intl.Collator().compare; break; case 'number': compareFunction = function ( a, b ) { return a - b; }; break; case 'boolean': compareFunction = function ( a, b ) { if ( a === b ) { return 0; } else if ( a === false ) { return -1; } else { return 1; } }; break; case 'object': if ( a instanceof Date ) { compareFunction = function ( a, b ) { return a.getTime() - b.getTime(); }; } else if ( a instanceof LW.Utilities.DateTime || a instanceof BigNumberNG ) { compareFunction = function ( a, b ) { return a.compare( b ); }; } else if ( a instanceof LW.Utilities.Complex || ( window.NIComplex && a instanceof window.NIComplex ) ) { const complexNumericProcessor = new LW.Utilities.ComplexNumericProcessor(); compareFunction = function ( a, b ) { return complexNumericProcessor.compareComplexNumbers( a, b ); } } break; } return compareFunction; } if ( !dataSource || !( Array.isArray( dataSource ) ) || dataSource.length === 0 || !sortColumns || Array.isArray( sortColumns ) && sortColumns.length === 0 ) { return; } if ( typeof sortColumns === 'string' ) { sortColumns = [ sortColumns ]; } const directionCoefficients = [], compareFunctions = []; if ( directions === undefined ) { directions = []; } for ( let i = 0; i < sortColumns.length; i++ ) { if ( directions[ i ] === undefined || directions[ i ] === 'asc' || directions[ i ] === 'ascending' ) { directionCoefficients[ i ] = 1; } else { directionCoefficients[ i ] = -1; } compareFunctions[ i ] = getCompareFunction( dataSource[ 0 ][ sortColumns[ i ] ] ); } if ( customSortingCallback ) { customSortingCallback( dataSource, sortColumns, directions, compareFunctions ); return; } const sortedData = dataSource.slice( 0 ); sortedData.sort( function ( a, b ) { for ( let i = 0; i < sortColumns.length; i++ ) { const result = compareFunctions[ i ]( a[ sortColumns[ i ] ], b[ sortColumns[ i ] ] ); if ( result === 0 ) { if ( sortColumns[ i + 1 ] ) { continue; } else if ( a._index !== undefined ) { // makes sorting stable return ( a._index - b._index ) * directionCoefficients[ i ]; } return 0; } return result * directionCoefficients[ i ]; } } ); return sortedData; } } LW.DataAdapter = window.lwDataAdapter = DataAdapter; class Ajax { constructor ( config, callback ) { const that = this; that.config = config; that.callback = callback; if ( config.autoFetch === false ) { return; } that.call( config ); } call( config ) { const that = this; if ( !config ) { config = that.config; } let method = 'GET', url = config.url, body = null, async = true; if ( config.type ) { method = config.type; } if ( config.data ) { if ( method === 'GET' ) { url += '?'; for ( let prop in config.data ) { if ( config.data.hasOwnProperty( prop ) ) { url += encodeURI( prop + '=' + config.data[ prop ] + '&' ); } } if ( url.charAt( url.length - 1 ) === '&' ) { url = url.slice( 0, url.length - 1 ); } } else if ( method === 'POST' ) { body = JSON.stringify( config.data ); } } if ( config && config.async === false && config.dataSourceType !== 'xlsx' ) { async = false; } if ( window.fetch !== undefined && async ) { that.ajaxFetch( config, method, url, body ); } else { that.ajaxXMLHttpRequest( config, method, url, body, async ); } } ajaxFetch( config, method, url, body ) { // prepare fetch config const that = this; const fetchInit = { method: method }; let parseMethod; switch ( config.dataSourceType ) { case 'json': parseMethod = 'json'; break; case 'xlsx': parseMethod = 'arrayBuffer'; break; default: parseMethod = 'text'; } if ( config ) { if ( config.contentType ) { fetchInit.headers = new Headers( { 'Content-Type': config.contentType } ); } } if ( body !== null ) { fetchInit.body = body; } let status, fetchTimeout, timeouted; if ( config.timeout ) { fetchTimeout = setTimeout( function () { timeouted = true; }, config.timeout ); } if ( config.beforeSend ) { const beforeSendResult = config.beforeSend( fetchInit, config ); if ( beforeSendResult === false ) { return; } } // fetch resource fetch( url, fetchInit ) .then( function ( response ) { if ( timeouted ) { status = 408; throw new Error( 'timeout' ); } if ( fetchTimeout ) { clearTimeout( fetchTimeout ); } status = response.status; if ( !response.ok ) { throw new Error( response.statusText ); } return response[ parseMethod ](); } ) .then( function ( data ) { if ( parseMethod === 'arrayBuffer' ) { return JSZip.loadAsync( data ).then( function ( zipData ) { // "data" represents the whole XLSX/ZIP file return zipData.files[ 'xl/worksheets/sheet1.xml' ].async( 'text' ).then( function ( sheet1 ) { return zipData.files[ 'xl/sharedStrings.xml' ].async( 'text' ).then( function ( sharedStrings ) { const parsedData = that.parseXLSXData( sheet1, sharedStrings ); that.ajaxComplete( config, parsedData, status ); } ); } ); } ); } else { that.ajaxComplete( config, data, status ); } } ) .catch( function ( error ) { if ( error.message === 'JSZip is not defined' ) { error.message = 'JSZip is not defined. Please include a reference to JSZip to be able to load data from XLSX files.'; } if ( config && config.loadError ) { config.loadError( status, error ); } if ( that.callback ) { that.callback( error, status ); } } ); } ajaxXMLHttpRequest( config, method, url, body, async ) { const request = new XMLHttpRequest(); const that = this; request.open( method, url, async ); request.ontimeout = function () { if ( config && config.loadError ) { config.loadError( 408, 'timeout' ); } }; request.onload = function () { if ( request.readyState === 4 ) { const status = request.status; let data = request.response; if ( status >= 200 && status <= 299 ) { if ( config.dataSourceType === 'json' ) { data = JSON.parse( data ); } that.ajaxComplete( config, data, status ); } else if ( config && config.loadError ) { config.loadError( status, data ); } } }; request.onerror = function () { if ( config && config.loadError ) { config.loadError( request.status, request.response ); } }; if ( config && config.contentType ) { request.setRequestHeader( 'Content-Type', config.contentType ); } if ( async && config.timeout ) { request.timeout = config.timeout; } if ( config.beforeSend ) { const beforeSendResult = config.beforeSend( request, config ); if ( beforeSendResult === false ) { return; } } request.send( body ); } ajaxComplete( config, data, status ) { if ( !config ) { return; } if ( config.beforeLoadComplete ) { const processedData = config.beforeLoadComplete( data ); if ( processedData ) { data = processedData; } } if ( config.loadComplete ) { config.loadComplete( data, status ); } if ( this.callback ) { this.callback( data, status ); } } parseXLSXData( sheet1, sharedStrings ) { const parser = new DOMParser(), sharedStringsDocument = parser.parseFromString( sharedStrings, 'text/xml' ), sharedStringsContainers = Array.from( sharedStringsDocument.getElementsByTagName( 'si' ) ), sharedStringsCollection = [], sheet1Document = parser.parseFromString( sheet1, 'text/xml' ), rows = Array.from( sheet1Document.getElementsByTagName( 'row' ) ), parsedData = []; sharedStringsContainers.forEach( function ( si ) { let texts = si.getElementsByTagName( 't' ); if ( texts.length === 1 ) { sharedStringsCollection.push( texts[ 0 ].innerHTML ); } else { let text = ''; texts = Array.from( texts ); texts.forEach( function ( t ) { text += t.innerHTML; } ); sharedStringsCollection.push( text ); } } ); rows.forEach( function ( row ) { const rowObject = {}, cells = Array.from( row.getElementsByTagName( 'c' ) ); cells.forEach( function ( cell/*, index*/ ) { const column = cell.getAttribute( 'r' ).match( /\D+/ )[ 0 ], type = cell.getAttribute( 't' ), xmlValue = cell.getElementsByTagName( 'v' )[ 0 ].innerHTML; let value; switch ( type ) { case 's': // string value = sharedStringsCollection[ parseFloat( xmlValue ) ]; break; case 'b': // boolean value = parseFloat( xmlValue ) === 1; break; default: // number or date value = parseFloat( xmlValue ); } rowObject[ column ] = value; } ); parsedData.push( rowObject ); } ); return parsedData; } } /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // const localTimezoneOffset = -1 * new Date().getTimezoneOffset(); const __timeZones = [ { id: 'Local', offset: localTimezoneOffset, offsetHours: localTimezoneOffset / 60, displayName: '', supportsDaylightSavingTime: false }, { id: 'Dateline Standard Time', offset: -720, offsetHours: -12, displayName: '(UTC-12:00) International Date Line West', supportsDaylightSavingTime: false }, { id: 'UTC-11', offset: -660, offsetHours: -11, displayName: '(UTC-11:00) Coordinated Universal Time-11', supportsDaylightSavingTime: false }, { id: 'Hawaiteratoran Standard Time', offset: -600, offsetHours: -10, displayName: '(UTC-10:00) Hawaiterator', supportsDaylightSavingTime: false }, { id: 'Alaskan Standard Time', offset: -540, offsetHours: -9, displayName: '(UTC-09:00) Alaska', supportsDaylightSavingTime: true }, { id: 'Pacific Standard Time (Mexico)', offset: -480, offsetHours: -8, displayName: '(UTC-08:00) Baja California', supportsDaylightSavingTime: true }, { id: 'Pacific Standard Time', offset: -480, offsetHours: -8, displayName: '(UTC-08:00) Pacific Time (US & Canada)', supportsDaylightSavingTime: true }, { id: 'US Mountain Standard Time', offset: -420, offsetHours: -7, displayName: '(UTC-07:00) Arizona', supportsDaylightSavingTime: false }, { id: 'Mountain Standard Time (Mexico)', offset: -420, offsetHours: -7, displayName: '(UTC-07:00) Chihuahua, La Paz, Mazatlan', supportsDaylightSavingTime: true }, { id: 'Mountain Standard Time', offset: -420, offsetHours: -7, displayName: '(UTC-07:00) Mountain Time (US & Canada)', supportsDaylightSavingTime: true }, { id: 'Central Standard Time', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Central Time (US & Canada)', supportsDaylightSavingTime: true }, { id: 'Central America Standard Time', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Central America', supportsDaylightSavingTime: false }, { id: 'Canada Central Standard Time', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Saskatchewan', supportsDaylightSavingTime: false }, { id: 'Central Standard Time (Mexico)', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Guadalajara, Mexico City, Monterrey', supportsDaylightSavingTime: true }, { id: 'SA Pacific Standard Time', offset: -300, offsetHours: -5, displayName: '(UTC-05:00) Bogota, Lima, Quito, Rio Branco', supportsDaylightSavingTime: false }, { id: 'Eastern Standard Time', offset: -300, offsetHours: -5, displayName: '(UTC-05:00) Eastern Time (US & Canada)', supportsDaylightSavingTime: true }, { id: 'US Eastern Standard Time', offset: -300, offsetHours: -5, displayName: '(UTC-05:00) Indiana (East)', supportsDaylightSavingTime: true }, { id: 'Venezuela Standard Time', offset: -270, offsetHours: -4.5, displayName: '(UTC-04:30) Caracas', supportsDaylightSavingTime: false }, { id: 'Atlantic Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Atlantic Time (Canada)', supportsDaylightSavingTime: true }, { id: 'Paraguay Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Asuncion', supportsDaylightSavingTime: true }, { id: 'Central Brazilian Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Cuiaba', supportsDaylightSavingTime: true }, { id: 'Pacific SA Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Santiago', supportsDaylightSavingTime: true }, { id: 'SA Western Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Georgetown, La Paz, Manaus, San Juan', supportsDaylightSavingTime: false }, { id: 'Newfoundland Standard Time', offset: -210, offsetHours: -3.5, displayName: '(UTC-03:30) Newfoundland', supportsDaylightSavingTime: true }, { id: 'SA Eastern Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Cayenne, Fortaleza', supportsDaylightSavingTime: false }, { id: 'Argentina Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Buenos Aires', supportsDaylightSavingTime: true }, { id: 'E. South America Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Brasilia', supportsDaylightSavingTime: true }, { id: 'Bahia Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Salvador', supportsDaylightSavingTime: true }, { id: 'Montevideo Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Montevideo', supportsDaylightSavingTime: true }, { id: 'Greenland Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Greenland', supportsDaylightSavingTime: true }, { id: 'UTC-02', offset: -120, offsetHours: -2, displayName: '(UTC-02:00) Coordinated Universal Time-02', supportsDaylightSavingTime: false }, { id: 'Mid-Atlantic Standard Time', offset: -120, offsetHours: -2, displayName: '(UTC-02:00) Mid-Atlantic - Old', supportsDaylightSavingTime: true }, { id: 'Azores Standard Time', offset: -60, offsetHours: -1, displayName: '(UTC-01:00) Azores', supportsDaylightSavingTime: true }, { id: 'Cape Verde Standard Time', offset: -60, offsetHours: -1, displayName: '(UTC-01:00) Cape Verde Is.', supportsDaylightSavingTime: false }, { id: 'Morocco Standard Time', offset: 0, offsetHours: 0, displayName: '(UTC) Casablanca', supportsDaylightSavingTime: true }, { id: 'UTC', offset: 0, offsetHours: 0, displayName: '(UTC) Coordinated Universal Time', supportsDaylightSavingTime: false }, { id: 'GMT Standard Time', offset: 0, offsetHours: 0, displayName: '(UTC) Dublin, Edinburgh, Lisbon, London', supportsDaylightSavingTime: true }, { id: 'Greenwich Standard Time', offset: 0, offsetHours: 0, displayName: '(UTC) Monrovia, Reykjavik', supportsDaylightSavingTime: false }, { id: 'Central European Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb', supportsDaylightSavingTime: true }, { id: 'Namibia Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Windhoek', supportsDaylightSavingTime: true }, { id: 'W. Central Africa Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) West Central Africa', supportsDaylightSavingTime: false }, { id: 'W. Europe Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna', supportsDaylightSavingTime: true }, { id: 'Central Europe Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague', supportsDaylightSavingTime: true }, { id: 'Romance Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Brussels, Copenhagen, Madrid, Paris', supportsDaylightSavingTime: true }, { id: 'FLE Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius', supportsDaylightSavingTime: true }, { id: 'South Africa Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Harare, Pretoria', supportsDaylightSavingTime: false }, { id: 'Turkey Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Istanbul', supportsDaylightSavingTime: true }, { id: 'GTB Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Athens, Bucharest', supportsDaylightSavingTime: true }, { id: 'Libya Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Tripoli', supportsDaylightSavingTime: true }, { id: 'E. Europe Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) E. Europe', supportsDaylightSavingTime: true }, { id: 'Jordan Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Amman', supportsDaylightSavingTime: true }, { id: 'Middle East Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Beirut', supportsDaylightSavingTime: true }, { id: 'Egypt Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Cairo', supportsDaylightSavingTime: true }, { id: 'Syria Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Damascus', supportsDaylightSavingTime: true }, { id: 'Israel Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Jerusalem', supportsDaylightSavingTime: true }, { id: 'Arab Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Kuwait, Riyadh', supportsDaylightSavingTime: false }, { id: 'E. Africa Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Nairobi', supportsDaylightSavingTime: false }, { id: 'Arabic Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Baghdad', supportsDaylightSavingTime: true }, { id: 'Kaliningrad Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Kaliningrad, Minsk', supportsDaylightSavingTime: true }, { id: 'Iran Standard Time', offset: 210, offsetHours: 3.5, displayName: '(UTC+03:30) Tehran', supportsDaylightSavingTime: true }, { id: 'Mauritius Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Port Louis', supportsDaylightSavingTime: true }, { id: 'Georgian Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Tbilisi', supportsDaylightSavingTime: false }, { id: 'Caucasus Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Yerevan', supportsDaylightSavingTime: true }, { id: 'Arabian Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Abu Dhabi, Muscat', supportsDaylightSavingTime: false }, { id: 'Azerbaijan Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Baku', supportsDaylightSavingTime: true }, { id: 'Russian Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Moscow, St. Petersburg, Volgograd', supportsDaylightSavingTime: true }, { id: 'Afghanistan Standard Time', offset: 270, offsetHours: 4.5, displayName: '(UTC+04:30) Kabul', supportsDaylightSavingTime: false }, { id: 'Pakistan Standard Time', offset: 300, offsetHours: 5, displayName: '(UTC+05:00) Islamabad, Karachi', supportsDaylightSavingTime: true }, { id: 'West Asia Standard Time', offset: 300, offsetHours: 5, displayName: '(UTC+05:00) Ashgabat, Tashkent', supportsDaylightSavingTime: false }, { id: 'India Standard Time', offset: 330, offsetHours: 5.5, displayName: '(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi', supportsDaylightSavingTime: false }, { id: 'Sri Lanka Standard Time', offset: 330, offsetHours: 5.5, displayName: '(UTC+05:30) Sri Jayawardenepura', supportsDaylightSavingTime: false }, { id: 'Nepal Standard Time', offset: 345, offsetHours: 5.75, displayName: '(UTC+05:45) Kathmandu', supportsDaylightSavingTime: false }, { id: 'Central Asia Standard Time', offset: 360, offsetHours: 6, displayName: '(UTC+06:00) Astana', supportsDaylightSavingTime: false }, { id: 'Bangladesh Standard Time', offset: 360, offsetHours: 6, displayName: '(UTC+06:00) Dhaka', supportsDaylightSavingTime: true }, { id: 'Ekaterinburg Standard Time', offset: 360, offsetHours: 6, displayName: '(UTC+06:00) Ekaterinburg', supportsDaylightSavingTime: true }, { id: 'Myanmar Standard Time', offset: 390, offsetHours: 6.5, displayName: '(UTC+06:30) Yangon (Rangoon)', supportsDaylightSavingTime: false }, { id: 'SE Asia Standard Time', offset: 420, offsetHours: 7, displayName: '(UTC+07:00) Bangkok, Hanoi, Jakarta', supportsDaylightSavingTime: false }, { id: 'N. Central Asia Standard Time', offset: 420, offsetHours: 7, displayName: '(UTC+07:00) Novosibirsk', supportsDaylightSavingTime: true }, { id: 'Ulaanbaatar Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Ulaanbaatar', supportsDaylightSavingTime: false }, { id: 'China Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi', supportsDaylightSavingTime: false }, { id: 'Singapore Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Kuala Lumpur, Singapore', supportsDaylightSavingTime: false }, { id: 'North Asia Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Krasnoyarsk', supportsDaylightSavingTime: true }, { id: 'Taipei Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Taipei', supportsDaylightSavingTime: false }, { id: 'W. Australia Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Perth', supportsDaylightSavingTime: true }, { id: 'Korea Standard Time', offset: 540, offsetHours: 9, displayName: '(UTC+09:00) Seoul', supportsDaylightSavingTime: false }, { id: 'North Asia East Standard Time', offset: 540, offsetHours: 9, displayName: '(UTC+09:00) Irkutsk', supportsDaylightSavingTime: true }, { id: 'Tokyo Standard Time', offset: 540, offsetHours: 9, displayName: '(UTC+09:00) Osaka, Sapporo, Tokyo', supportsDaylightSavingTime: false }, { id: 'AUS Central Standard Time', offset: 570, offsetHours: 9.5, displayName: '(UTC+09:30) Darwin', supportsDaylightSavingTime: false }, { id: 'Cen. Australia Standard Time', offset: 570, offsetHours: 9.5, displayName: '(UTC+09:30) Adelaide', supportsDaylightSavingTime: true }, { id: 'West Pacific Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Guam, Port Moresby', supportsDaylightSavingTime: false }, { id: 'Tasmania Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Hobart', supportsDaylightSavingTime: true }, { id: 'E. Australia Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Brisbane', supportsDaylightSavingTime: false }, { id: 'AUS Eastern Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Canberra, Melbourne, Sydney', supportsDaylightSavingTime: true }, { id: 'Yakutsk Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Yakutsk', supportsDaylightSavingTime: true }, { id: 'Vladivostok Standard Time', offset: 660, offsetHours: 11, displayName: '(UTC+11:00) Vladivostok', supportsDaylightSavingTime: true }, { id: 'Central Pacific Standard Time', offset: 660, offsetHours: 11, displayName: '(UTC+11:00) Solomon Is., New Caledonia', supportsDaylightSavingTime: false }, { id: 'Magadan Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Magadan', supportsDaylightSavingTime: true }, { id: 'Kamchatka Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Petropavlovsk-Kamchatsky - Old', supportsDaylightSavingTime: true }, { id: 'Fiji Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Fiji', supportsDaylightSavingTime: true }, { id: 'New Zealand Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Auckland, Wellington', supportsDaylightSavingTime: true }, { id: 'UTC+12', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Coordinated Universal Time+12', supportsDaylightSavingTime: false }, { id: 'Tonga Standard Time', offset: 780, offsetHours: 13, displayName: '(UTC+13:00) Nuku\'alofa', supportsDaylightSavingTime: false }, { id: 'Samoa Standard Time', offset: 780, offsetHours: 13, displayName: '(UTC+13:00) Samoa', supportsDaylightSavingTime: true } ], __daysToMonth365 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], __daysToMonth366 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366], __daysPer4Years = 365 * 4 + 1, __daysPer100Years = (365 * 4 + 1) * 25 - 1, __daysPer400Years = ((365 * 4 + 1) * 25 - 1) * 4 + 1, // Number of days from 1/1/0001 to 12/31/1600 __daysTo1601 = (((365 * 4 + 1) * 25 - 1) * 4 + 1) * 4, // Number of days from 1/1/0001 to 12/30/1899 __daysTo1899 = (((365 * 4 + 1) * 25 - 1) * 4 + 1) * 4 + ((365 * 4 + 1) * 25 - 1) * 3 - 367, // Number of days from 1/1/0001 to 12/31/9999 __daysTo10000 = (((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366, __minTicks = 0, __maxTicks = ((((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366) * (1000 * 10000 * 3600 * 24) - 1, __maxMillis = ((((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366) * (1000 * 60 * 60 * 24); LW.Utilities.Assign('TimeSpan', class TimeSpan { constructor() { const that = this; that.ticksPerMillisecond = 10000; that.millisecondsPerTick = 1 / 10000; that.ticksPerSecond = 1000 * 10000; that.secondsPerTick = 1 / (1000 * 10000); that.ticksPerMinute = 1000 * 10000 * 60; that.minutesPerTick = 1 / (1000 * 10000 * 60); that.ticksPerHour = 1000 * 10000 * 3600; that.hoursPerTick = 1 / (1000 * 10000 * 3600); that.ticksPerDay = 1000 * 10000 * 3600 * 24; that.daysPerTick = 1 / (1000 * 10000 * 3600 * 24); that.millisPerSecond = 1000; that.millisPerMinute = 1000 * 60; that.millisPerHour = 1000 * 60 * 60; that.millisPerDay = 1000 * 60 * 60 * 24; that._ticks = 0; if (arguments.length === 1) { if (isNaN(arguments[0])) { throw new Error('Argument must be a number.'); } that._ticks = arguments[0]; } else if (arguments.length === 3) { that._ticks = that.timeToMS(arguments[0], arguments[1], arguments[2], 0); } else if (arguments.length === 4) { const days = arguments[0], hours = arguments[1], minutes = arguments[2], seconds = arguments[3], milliseconds = 0, totalMilliSeconds = (days * 3600 * 24 + hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds; that._ticks = totalMilliSeconds * that.ticksPerMillisecond; } else if (arguments.length === 5) { const days = arguments[0], hours = arguments[1], minutes = arguments[2], seconds = arguments[3], milliseconds = arguments[4], totalMilliSeconds = (days * 3600 * 24 + hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds; that._ticks = totalMilliSeconds * that.ticksPerMillisecond; } } ticks() { return this._ticks; } days() { const that = this; return parseInt(that._ticks / that.ticksPerDay); } timeToMS(hour, minute, second, milliseconds) { const totalSeconds = hour * 3600 + minute * 60 + second + milliseconds / 1000; return parseInt(totalSeconds * this.ticksPerSecond); } hours() { const that = this; return parseInt(that._ticks / that.ticksPerHour) % 24; } milliseconds() { const that = this; return parseInt(that._ticks / that.ticksPerMillisecond) % 1000; } minutes() { const that = this; return parseInt(that._ticks / that.ticksPerMinute) % 60; } seconds() { const that = this; return parseInt(that._ticks / that.ticksPerSecond) % 60; } totalDays() { const that = this; return parseInt(that._ticks * that.daysPerTick); } totalHours() { const that = this; return parseInt(that._ticks * that.hoursPerTick); } totalMilliseconds() { const that = this, temp = that._ticks * that.millisecondsPerTick; return parseInt(temp); } totalMinutes() { const that = this; return parseInt(that._ticks * that.minutesPerTick); } totalSeconds() { const that = this; return parseInt(that._ticks * that.secondsPerTick); } add(ts) { const result = this._ticks + ts._ticks, timeSpan = new LW.Utilities.TimeSpan(result); return timeSpan; } subtract(ts) { const result = this._ticks - ts._ticks; return new LW.Utilities.TimeSpan(result); } duration() { const that = this; if (that._ticks >= 0) { return new LW.Utilities.TimeSpan(that._ticks); } else { return new LW.Utilities.TimeSpan(-that._ticks); } } equals(ts) { return this._ticks === ts._ticks; } valueOf() { return this._ticks } compare(t1, t2) { if (t1._ticks > t2._ticks) { return 1; } if (t1._ticks < t2._ticks) { return -1; } return 0; } interval(value, scale) { const tmp = value * scale, millis = tmp + (value >= 0 ? 0.5 : -0.5); return new LW.Utilities.TimeSpan(millis * this.ticksPerMillisecond); } fromDays(value) { const that = this; return that.interval(value, that.millisPerDay); } fromHours(value) { const that = this; return that.interval(value, that.millisPerHour); } fromMilliseconds(value) { return this.interval(value, 1); } fromMinutes(value) { const that = this; return that.interval(value, that.millisPerMinute); } fromSeconds(value) { const that = this; return that.interval(value, that.millisPerSecond); } fromTicks(value) { return new LW.Utilities.TimeSpan(value); } toString() { return this.totalMilliseconds().toString(); } negate() { return new LW.Utilities.TimeSpan(-this._ticks); } }); LW.Utilities.Assign('DateTime', class DateTime { constructor() { function getUTCDate(ISOString) { const parseResult = that.regexISOString.exec(ISOString); UTCDate = new LW.Utilities.DateTime( parseFloat(parseResult[1]), parseFloat(parseResult[2]), parseFloat(parseResult[3]), parseFloat(parseResult[4]), parseFloat(parseResult[5]), parseFloat(parseResult[6]), parseFloat(parseResult[7]), 0, 0, 0, 0, 0, 0, 0, 'UTC' ); } const that = this; let UTCDate; that.ticksPerMillisecond = 10000; that.millisecondsPerTick = 1 / 10000; that.ticksPerSecond = 1000 * 10000; that.secondsPerTick = 1 / (1000 * 10000); that.ticksPerMinute = 1000 * 10000 * 60; that.minutesPerTick = 1 / (1000 * 10000 * 60); that.ticksPerHour = 1000 * 10000 * 3600; that.hoursPerTick = 1 / (1000 * 10000 * 3600); that.ticksPerDay = 1000 * 10000 * 3600 * 24; that.daysPerTick = 1 / (1000 * 10000 * 3600 * 24); that.millisPerSecond = 1000; that.millisPerMinute = 1000 * 60; that.millisPerHour = 1000 * 60 * 60; that.millisPerDay = 1000 * 60 * 60 * 24; that.daysPerYear = 365; that.daysPer4Years = __daysPer4Years; that.daysPer100Years = __daysPer100Years; that.daysPer400Years = __daysPer400Years; // Number of days from 1/1/0001 to 12/31/1600 that.daysTo1601 = __daysTo1601; // Number of days from 1/1/0001 to 12/30/1899 that.daysTo1899 = __daysTo1899; // Number of days from 1/1/0001 to 12/31/9999 that.daysTo10000 = __daysTo10000; that.minTicks = 0; that.maxTicks = __maxTicks; that.maxMillis = __maxMillis; that.datePartYear = 0; that.datePartDayOfYear = 1; that.datePartMonth = 2; that.datePartDay = 3; that.daysToMonth365 = __daysToMonth365; that.daysToMonth366 = __daysToMonth366; that.minValue = new Date(0); that.maxValue = new Date(((((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366) * (1000 * 10000 * 3600 * 24) - 1); that.ticksMask = 0x3FFFFFFFFFFFFFFF; that.flagsMask = 0xC000000000000000; that.localMask = 0x8000000000000000; that.ticksCeiling = 0x4000000000000000; that.kindUnspecified = 0x0000000000000000; that.kindUtc = 0x4000000000000000; that.kindLocal = 0x8000000000000000; that.kindLocalAmbiguousDst = 0xC000000000000000; that.kindShift = 62; that.regexTrim = /^\s+|\s+$/g; that.regexInfinity = /^[+-]?infinity$/i; that.regexHex = /^0x[a-f0-9]+$/i; that.regexParseFloat = /^[+-]?\d*\.?\d*(e[+-]?\d+)?$/; that.regexISOString = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}).(\d{3})Z$/; that.calendar = { // separator of parts of a date (e.g. '/' in 11/05/1955) '/': '/', // separator of parts of a time (e.g. ':' in 05:44 PM) ':': ':', // the first day of the week (0 = Sunday, 1 = Monday, etc) firstDay: 0, days: { // full day names names: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // abbreviated day names namesAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // shortest day names namesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'] }, months: { // full month names (13 months for lunar calendards -- 13th month should be '' if not lunar) names: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', ''], // abbreviated month names namesAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', ''] }, // AM and PM designators in one of these forms: // The usual view, and the upper and lower case versions // [standard,lowercase,uppercase] // The culture does not use AM or PM (likely all standard date formats use 24 hour time) // null AM: ['AM', 'am', 'AM'], PM: ['PM', 'pm', 'PM'], eras: [ // eras in reverse chronological order. // name: the name of the era in this culture (e.g. A.D., C.E.) // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era. // offset: offset in years from gregorian calendar { 'name': 'A.D.', 'start': null, 'offset': 0 } ], twoDigitYearMax: 2029, patterns: { // short date pattern d: 'M/d/yyyy', // long date pattern D: 'dddd, MMMM dd, yyyy', // short time pattern t: 'h:mm tt', // long time pattern T: 'h:mm:ss tt', // long date, short time pattern f: 'dddd, MMMM dd, yyyy h:mm tt', // long date, long time pattern F: 'dddd, MMMM dd, yyyy h:mm:ss tt', // month/day pattern M: 'MMMM dd', // month/year pattern Y: 'yyyy MMMM', // S is a sortable format that does not vary by culture S: 'yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss', // formatting of dates in MySQL DataBases ISO: 'yyyy-MM-dd hh:mm:ss', ISO2: 'yyyy-MM-dd HH:mm:ss', d1: 'dd.MM.yyyy', d2: 'dd-MM-yyyy', zone1: 'yyyy-MM-ddTHH:mm:ss-HH:mm', zone2: 'yyyy-MM-ddTHH:mm:ss+HH:mm', custom: 'yyyy-MM-ddTHH:mm:ss.fff', custom2: 'yyyy-MM-dd HH:mm:ss.fff', // full precision (from year to yoctoseconds) FP: 'yyyy-MM-dd HH:mm:ss:fff:uu:nn:pp:ee:aa:xx:oo', // alternative full precision (from year to yoctoseconds, no delimiters) FPA: 'yyyy/MM/dd HH:mm:ss:fffuunnppeeaaxxoo', // alternative full precision (from year to yoctoseconds, no delimiters) FPA2: 'yyyy-MM-dd HH:mm:ss:fffuunnppeeaaxxoo', // full precision time (from hours to yoctoseconds) FT: 'HH:mm:ss:fff:uu:nn:pp:ee:aa:xx:oo', // processor precision (from year to picoseconds) PP: 'yyyy-MM-dd HH:mm:ss:fff:uu:nn:pp', // processor precision time (from hours to picoseconds) PT: 'HH:mm:ss:fff:uu:nn:pp' }, percentsymbol: '%', currencysymbol: '$', currencysymbolposition: 'before', decimalseparator: '.', thousandsseparator: ',' }; that.dateData = 0; that.timeZone = null; that.timeZones = __timeZones; that._codeToUnit = { 'u': '_microsecond', 'uu': '_microsecond', 'n': '_nanosecond', 'nn': '_nanosecond', 'p': '_picosecond', 'pp': '_picosecond', 'e': '_femtosecond', 'ee': '_femtosecond', 'a': '_attosecond', 'aa': '_attosecond', 'x': '_zeptosecond', 'xx': '_zeptosecond', 'o': '_yoctosecond', 'oo': '_yoctosecond' }; that._smallUnits = ['_microsecond', '_nanosecond', '_picosecond', '_femtosecond', '_attosecond', '_zeptosecond', '_yoctosecond']; that._microsecond = 0; that._nanosecond = 0; that._picosecond = 0; that._femtosecond = 0; that._attosecond = 0; that._zeptosecond = 0; that._yoctosecond = 0; if (arguments.length === 0) { const date = new Date(); that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()); } else if (arguments.length === 1) { if (arguments[0] === undefined) arguments[0] = 'todayDate'; const isNumber = typeof arguments[0] === 'number' && isFinite(arguments[0]); if (!isNumber && typeof arguments[0] === 'string') { let date; if (arguments[0] === 'today') { date = new Date(); } else if (arguments[0] === 'todayDate') { date = new Date(); date.setHours(0, 0, 0, 0); } else if (that.regexISOString.test(arguments[0])) { getUTCDate(arguments[0]); } else { date = that.tryparseDate(arguments[0]); } if (date) { that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()); } } else { if (typeof (arguments[0]) === 'number') { that.dateData = arguments[0]; } else { if (arguments[0] instanceof Date) { const date = arguments[0]; that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()); } else { that.dateData = arguments[0]; } } } } else if (arguments.length === 2) { if (arguments[0] === undefined) arguments[0] = 'todayDate'; const isNumber = typeof arguments[0] === 'number' && isFinite(arguments[0]); if (!isNumber && typeof arguments[0] === 'string') { let date; if (arguments[0] === 'today') { date = new Date(); } else if (arguments[0] === 'todayDate') { date = new Date(); date.setHours(0, 0, 0, 0); } else if (that.regexISOString.test(arguments[0])) { getUTCDate(arguments[0]); } else { date = that.tryparseDate(arguments[0]); } if (date) { that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()); } } else { if (typeof (arguments[0]) === 'number') { that.dateData = arguments[0]; } else { if (arguments[0] instanceof Date) { const date = arguments[0]; that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()); } else { that.dateData = arguments[0]; } } } that.validateTimeZone(arguments[1]); } else if (arguments.length > 2) { if (typeof arguments[0] === 'string') { const date = that.tryparseDate(arguments[0], arguments[2], arguments[1]); that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()); } else { const year = arguments[0], month = arguments[1] - 1, day = arguments[2], hour = arguments[3] || 0, minute = arguments[4] || 0, second = arguments[5] || 0, millisecond = arguments[6] || 0, microsecond = arguments[7] || 0, nanosecond = arguments[8] || 0, picosecond = arguments[9] || 0, femtosecond = arguments[10] || 0, attosecond = arguments[11] || 0, zeptosecond = arguments[12] || 0, yoctosecond = arguments[13] || 0, date = new Date(year, month, day, hour, minute, second, millisecond); if (year < 1970) { date.setFullYear(year); } that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()); that._microsecond = microsecond; that._nanosecond = nanosecond; that._picosecond = picosecond; that._femtosecond = femtosecond; that._attosecond = attosecond; that._zeptosecond = zeptosecond; that._yoctosecond = yoctosecond; if (arguments[14]) { that.validateTimeZone(arguments[14]); } } } if (!that.timeZone) { that.validateTimeZone('Local'); } if (UTCDate) { const convertedUTCDate = UTCDate.toTimeZone(that.timeZone); that.dateData = convertedUTCDate.dateData; } } static validateDate(value, referenceValue, formatString) { if (value instanceof LW.Utilities.DateTime) { return value; } if (value instanceof Date) { return new LW.Utilities.DateTime(value); } try { if (new RegExp(/^\d{1,2}\/\d{1,2}\/\d{4}(, \d{1,2}:\d{2}:\d{1,2} [A|P]M)?$/).test(value)) { const constructedDate = new Date(value); if (!isNaN(constructedDate.getTime())) { return new LW.Utilities.DateTime(constructedDate); } } if (typeof value === 'string') { return this.parseDateString(value, referenceValue, formatString); } if (typeof value === 'number') { return new LW.Utilities.DateTime(new Date(value)); } } catch (error) { // } return referenceValue; } static parseDateString(value, referenceValue, formatString) { const parseAttemptDate = new Date(value); if (!isNaN(parseAttemptDate.getTime())) { return new LW.Utilities.DateTime(parseAttemptDate); } const indexOfDate = value.indexOf('Date('), indexOfDateTime = value.indexOf('DateTime('), indexOfBracket = value.lastIndexOf(')'); let validValue = value; if ((indexOfDate !== -1 || indexOfDateTime !== -1) && indexOfBracket !== -1) { if (indexOfDate !== -1) { validValue = value.slice(indexOfDate + 5, indexOfBracket); } else { validValue = value.slice(indexOfDateTime + 9, indexOfBracket); } validValue = validValue.replace(/'/g, '').replace(/"/g, '').replace(/^\s+|\s+$|\s+(?=\s)/g, ''); if (validValue.trim() === '') { return new LW.Utilities.DateTime(); } if (new RegExp(/(^(\d+)(\s*,\s*\d+)+(\s*,\s*[a-zA-Z ]+)?$)/g).test(validValue)) { validValue = validValue.split(','); validValue.map(function (argument, index) { if (!isNaN(validValue[index])) { validValue[index] = parseInt(argument); } else { validValue[index] = argument.trim(); } }); if (indexOfDate !== -1) { validValue[1]++; } validValue.unshift(null); validValue = new (Function.prototype.bind.apply(LW.Utilities.DateTime, validValue)); return validValue; } } else { const parseAttemptDateTime = new LW.Utilities.DateTime(), parseAttempt = parseAttemptDateTime.parseDate(value, formatString); if (parseAttempt) { validValue = new LW.Utilities.DateTime(parseAttempt); parseAttemptDateTime.copySmallTimePartValues(validValue); return validValue; } } if (validValue.trim() === '') { return referenceValue; } if (!isNaN(validValue)) { validValue = new Date(parseInt(validValue, 10)); return new LW.Utilities.DateTime(validValue); } try { const splitValue = validValue.split(','); if (splitValue.length === 2) { splitValue[1] = splitValue[1].trim(); splitValue.unshift(null); validValue = new (Function.prototype.bind.apply(LW.Utilities.DateTime, splitValue)); } else { validValue = new LW.Utilities.DateTime(validValue); } } catch (error) { validValue = referenceValue; } return validValue; } static fromFullTimeStamp(timeStamp) { timeStamp = timeStamp.toString(); const dateTime = new LW.Utilities.DateTime(parseFloat(timeStamp.slice(0, timeStamp.length - 21))); let smallTimeParts = timeStamp.slice(timeStamp.length - 21), unitIndex = 0; while (smallTimeParts.length > 0) { dateTime[dateTime._smallUnits[unitIndex]] = parseInt(smallTimeParts.slice(0, 3), 10); smallTimeParts = smallTimeParts.slice(3); unitIndex++; } return dateTime; } /** * Returns full DateTime constructor parameters. */ static getConstructorParameters(oldValue) { return [ oldValue.year(), oldValue.month(), oldValue.day(), oldValue.hour(), oldValue.minute(), oldValue.second(), oldValue.millisecond(), oldValue._microsecond, oldValue._nanosecond, oldValue._picosecond, oldValue._femtosecond, oldValue._attosecond, oldValue._zeptosecond, oldValue._yoctosecond, oldValue.timeZone ]; } /** * Detects whether the formatString contains only date or time information, or both. */ static detectDisplayMode(value, formatString, formatStringRegExp) { if (value.calendar.patterns[formatString]) { if (['d', 'D', 'M', 'Y', 'd1', 'd2'].indexOf(formatString) !== -1) { return 'calendar'; } if (['t', 'T', 'FT', 'PT'].indexOf(formatString) !== -1) { return 'timePicker'; } return 'default'; } const dateParts = ['d', 'M', 'y'], timeParts = ['h', 'H', 'm', 's', 't', 'f', 'u', 'n', 'p', 'e', 'a', 'x', 'o'], groups = formatStringRegExp.groups; let calendar = false, timePicker = false; for (let i = 0; i < groups.length; i++) { const char = groups[i].charAt(0); if (dateParts.indexOf(char) !== -1) { calendar = true; } else if (timeParts.indexOf(char) !== -1) { timePicker = true; } if (calendar && timePicker) { break; } } if (calendar === timePicker) { return 'default'; } if (calendar) { return 'calendar'; } return 'timePicker'; } /** * Gets and stores month and day names based on locale. */ static getLocalizedNames(locale) { const days = { names: [], namesAbbr: [], namesShort: [] }, months = { names: [], namesAbbr: [] }; if (this[locale]) { return this[locale]; } for (let i = 23; i < 30; i++) { const date = new Date(2017, 6, i), name = date.toLocaleString(locale, { 'weekday': 'long' }); days.names.push(name); days.namesAbbr.push(date.toLocaleString(locale, { 'weekday': 'short' })); days.namesShort.push(name.substring(0, 2)); } for (let i = 0; i < 12; i++) { const date = new Date(2017, i, 1), name = date.toLocaleString(locale, { 'month': 'long' }); months.names.push(name); months.namesAbbr.push(name.substring(0, 3)); } months.names.push(''); months.namesAbbr.push(''); this[locale] = { days: days, months: months }; return this[locale]; } internalMS() { return this.dateData; } // Returns a given date part of this DateTithat. This method is used // to compute the year, day-of-year, month, or day part. getDatePart(part) { const that = this, ms = that.internalMS(); // n = number of days since 1/1/0001 let n = parseInt(ms / that.millisPerDay); // y400 = number of whole 400-year periods since 1/1/0001 const y400 = parseInt(n / that.daysPer400Years); // n = day number within 400-year period n -= y400 * that.daysPer400Years; // y100 = number of whole 100-year periods within 400-year period let y100 = parseInt(n / that.daysPer100Years); // Last 100-year period has an extra day, so decrement result if 4 if (y100 === 4) y100 = 3; // n = day number within 100-year period n -= y100 * that.daysPer100Years; // y4 = number of whole 4-year periods within 100-year period const y4 = parseInt(n / that.daysPer4Years); // n = day number within 4-year period n -= y4 * that.daysPer4Years; // y1 = number of whole years within 4-year period let y1 = parseInt(n / that.daysPerYear); // Last year has an extra day, so decrement result if 4 if (y1 === 4) y1 = 3; // If year was requested, compute and return it if (part === that.datePartYear) { return parseInt(y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1); } // n = day number within year n -= y1 * that.daysPerYear; // If day-of-year was requested, return it if (part === that.datePartDayOfYear) return parseInt(n + 1); // Leap year calculation looks different from IsLeapYear since y1, y4, // and y100 are relative to year 1, not year 0 const leapYear = y1 === 3 && (y4 !== 24 || y100 === 3), days = leapYear ? that.daysToMonth366 : that.daysToMonth365; // All months have less than 32 days, so n >> 5 is a good conservative // estimate for the month let m = n >> 5 + 1; // m = 1-based month number while (n >= days[m]) m++; // If month was requested, return it if (part === that.datePartMonth) return parseInt(m); // Return 1-based day-of-month return parseInt(n - days[m - 1] + 1); } dayOfWeek() { const that = this, ms = that.dateData, dayOfWeek = parseInt(ms / that.millisPerDay + 1) % 7; return dayOfWeek; } dayOfYear() { const that = this; return that.getDatePart(that.datePartDayOfYear); } weekOfYear(firstDay) { const that = this, dateObj = that.toDate(), dowOffset = firstDay || that.calendar.firstDay, //default dowOffset to zero newYear = new Date(dateObj.getFullYear(), 0, 1), daynum = Math.floor((dateObj.getTime() - newYear.getTime() - (dateObj.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1; let day = newYear.getDay() - dowOffset; //the day of week the year begins on day = (day >= 0 ? day : day + 7); let weeknum; //if the year starts before the middle of a week if (day < 4) { weeknum = Math.floor((daynum + day - 1) / 7) + 1; if (weeknum > 52) { const nYear = new Date(dateObj.getFullYear() + 1, 0, 1); let nday = nYear.getDay() - dowOffset; nday = nday >= 0 ? nday : nday + 7; /*if the next year starts before the middle of the week, it is week #1 of that year*/ weeknum = nday < 4 ? 1 : 53; } } else { weeknum = Math.floor((daynum + day - 1) / 7); } return weeknum; } subtract(date) { const that = this; return new LW.Utilities.TimeSpan(that.dateData * that.ticksPerMillisecond - date.dateData * that.ticksPerMillisecond); } dateToMS(year, month, day) { const that = this; if (year >= 1 && year <= 9999 && month >= 1 && month <= 12) { year = parseInt(year); const days = that.isLeapYear(year) ? that.daysToMonth366 : that.daysToMonth365; if (day >= 1 && day <= days[month] - days[month - 1]) { const y = year - 1; const n = y * 365 + parseInt(y / 4) - parseInt(y / 100) + parseInt(y / 400) + days[month - 1] + day - 1; return n * that.millisPerDay; } } } isLeapYear(year) { if (year < 1 || year > 9999) { throw new Error('Year out of Range'); } return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0); } timeToMS(hour, minute, second, ms) { const that = this; if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60) { const totalSeconds = parseInt(hour * 3600 + minute * 60 + second); if (ms > 0 && ms < 1000) { return (totalSeconds * that.millisPerSecond) + ms; } return totalSeconds * that.millisPerSecond; } } daysInMonth(year, month) { if (month < 1 || month > 12) { throw new Error('Month out of Range'); } const that = this, days = that.isLeapYear(year) ? that.daysToMonth366 : that.daysToMonth365; return days[month] - days[month - 1]; } arrayIndexOf(array, item) { return array.indexOf(item); } startsWith(value, pattern) { return value.indexOf(pattern) === 0; } endsWith(value, pattern) { return value.substr(value.length - pattern.length) === pattern; } trim(value) { return (value + '').replace(this.regexTrim, ''); } expandFormat(calendar, format) { // expands unspecified or single character date formats into the full pattern. format = format || 'F'; let pattern, patterns = calendar.patterns, len = format.length; if (patterns[format]) { return patterns[format]; } if (len === 1) { pattern = patterns[format]; if (!pattern) { throw 'Invalid date format string \'' + format + '\'.'; } format = pattern; } else if (len === 2 && format.charAt(0) === '%') { // %X escape format -- intended as a custom format string that is only one character, not a built-in format. format = format.charAt(1); } return format; } getEra(date, eras) { if (!eras) return 0; if (typeof date === 'string') { return 0; } let start, ticks = date.getTime(); for (let i = 0, l = eras.length; i < l; i++) { start = eras[i].start; if (start === null || ticks >= start) { return i; } } return 0; } toUpper(value) { // 'he-IL' has non-breaking space in weekday names. return value.split('\u00A0').join(' ').toUpperCase(); } toUpperArray(arr) { const results = []; for (let i = 0, l = arr.length; i < l; i++) { results[i] = this.toUpper(arr[i]); } return results; } getEraYear(date, cal, era, sortable) { let year = date.getFullYear(); if (!sortable && cal.eras) { // convert normal gregorian year to era-shifted gregorian // year by subtracting the era offset year -= cal.eras[era].offset; } return year; } getDayIndex(cal, value, abbr) { const that = this, days = cal.days; let ret, upperDays = cal._upperDays; if (!upperDays) { cal._upperDays = upperDays = [ that.toUpperArray(days.names), that.toUpperArray(days.namesAbbr), that.toUpperArray(days.namesShort) ]; } value = value.toUpperCase(); if (abbr) { ret = that.arrayIndexOf(upperDays[1], value); if (ret === -1) { ret = that.arrayIndexOf(upperDays[2], value); } } else { ret = that.arrayIndexOf(upperDays[0], value); } return ret; } getMonthIndex(cal, value, abbr) { const that = this; let months = cal.months, monthsGen = cal.monthsGenitive || cal.months, upperMonths = cal._upperMonths, upperMonthsGen = cal._upperMonthsGen; if (!upperMonths) { cal._upperMonths = upperMonths = [ that.toUpperArray(months.names), that.toUpperArray(months.namesAbbr) ]; cal._upperMonthsGen = upperMonthsGen = [ that.toUpperArray(monthsGen.names), that.toUpperArray(monthsGen.namesAbbr) ]; } value = that.toUpper(value); let i = that.arrayIndexOf(abbr ? upperMonths[1] : upperMonths[0], value); if (i < 0) { i = that.arrayIndexOf(abbr ? upperMonthsGen[1] : upperMonthsGen[0], value); } return i; } appendPreOrPostMatch(preMatch, strings) { // appends pre- and post- token match strings while removing escaped characters. // Returns a single quote count which is used to determine if the token occurs // in a string literal. let quoteCount = 0, escaped = false; for (let i = 0, il = preMatch.length; i < il; i++) { const c = preMatch.charAt(i); switch (c) { case '\'': if (escaped) { strings.push('\''); } else { quoteCount++; } escaped = false; break; case '\\': if (escaped) { strings.push('\\'); } escaped = !escaped; break; default: strings.push(c); escaped = false; break; } } return quoteCount; } getTokenRegExp() { // regular expression for matching date and time tokens in format strings. return /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyyy|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|uu|u|nn|n|pp|p|ee|e|aa|a|xx|x|oo|o|i{1,24}|zzz|zz|z|gg|g/g; } tryparseDate(value, calendar, format) { const that = this; if (calendar === undefined || calendar === null) { calendar = that.calendar; } if (format !== undefined) { if (Array.isArray(format)) { for (let i = 0; i < format.length; i++) { const tryParse = that.parseDate(value, format[i], calendar); if (tryParse) { return tryParse; } } } const tryParse = that.parseDate(value, format, calendar); if (tryParse) return tryParse; } if (value === '') return null; if (value !== null && value !== undefined && !value.substring) { value = value.toString(); } if (value !== null && value !== undefined && value.substring(0, 6) === '/Date(') { const jsonDateRE = /^\/Date\((-?\d+)(\+|-)?(\d+)?\)\/$/; let date = new Date(+value.replace(/\/Date\((\d+)\)\//, '$1')); if (date === 'Invalid Date') { const m = value.match(/^\/Date\((\d+)([-+]\d\d)(\d\d)\)\/$/); date = null; if (m) { date = new Date(1 * m[1] + 3600000 * m[2] + 60000 * m[3]); } } if (date === null || date === undefined || date === 'Invalid Date' || isNaN(date)) { const arr = jsonDateRE.exec(value); if (arr) { // 0 - complete results; 1 - ticks; 2 - sign; 3 - minutes const result = new Date(parseInt(arr[1])); if (arr[2]) { let mins = parseInt(arr[3]); if (arr[2] === '-') { mins = -mins; } const current = result.getUTCMinutes(); result.setUTCMinutes(current - mins); } if (!isNaN(result.valueOf())) { return result; } } } return date; } const defaultPatterns = { lwdate: 'yyyy-MM-dd HH:mm:ss', // short date pattern d: 'M/d/yyyy', // long date pattern D: 'dddd, MMMM dd, yyyy', // short time pattern t: 'h:mm tt', // long time pattern T: 'h:mm:ss tt', // long date, short time pattern f: 'dddd, MMMM dd, yyyy h:mm tt', // long date, long time pattern F: 'dddd, MMMM dd, yyyy h:mm:ss tt', // month/day pattern M: 'MMMM dd', // month/year pattern Y: 'yyyy MMMM', // S is a sortable format that does not vary by culture S: 'yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss', // formatting of dates in MySQL DataBases ISO: 'yyyy-MM-dd hh:mm:ss', ISO2: 'yyyy-MM-dd HH:mm:ss', ISO8601: 'yyyy-MM-ddTHH:mm:ss.sssZ', d1: 'dd.MM.yyyy', d2: 'dd-MM-yyyy', d3: 'MM-dd-yyyy', d4: 'MM.dd.yyyy', zone1: 'yyyy-MM-ddTHH:mm:ss-HH:mm', zone2: 'yyyy-MM-ddTHH:mm:ss+HH:mm', custom: 'yyyy-MM-ddTHH:mm:ss.fff', custom2: 'yyyy-MM-dd HH:mm:ss.fff', iso: 'yyyy-MM-ddTHH:mm:ssZ', iso_date1: 'yyyy-MM-dd', iso_date2: 'yyyy-MM-dd', iso_date3: 'yyyy-ddd', iso_date4: 'yyyy-MM-dd HH:mm', iso_date5: 'yyyy-MM-dd HH:mm Z', iso_date6: 'yyyy-MMM-dd', iso_date7: 'yyyy-MM', iso_date8: 'yyyy-MMM', iso_date9: 'yyyy-MMMM', iso_date10: 'yyyy-MMMM-dd', iso_time1: 'HH:mm:ss.tttt', iso_time2: 'HH:mm:ss', iso_time3: 'HH:mm', iso_time4: 'HH', iso_time5: 'yyyyyy-MM-dd', iso_time6: 'yyyyyy-MM-dd' }; for (let prop in defaultPatterns) { const date = that.parseDate(value, defaultPatterns[prop], calendar); if (date) { return date; } } const patterns = calendar.patterns; for (let prop in patterns) { const date = that.parseDate(value, patterns[prop], calendar); if (date) { if (prop === 'ISO') { const tmpDate = that.parseDate(value, patterns['ISO2'], calendar); if (tmpDate) return tmpDate; } return date; } } let dateParts; if (typeof value === 'string') { value = that.trim(value); const splitParts = [':', '/', '-', ' ', ',']; const replaceAll = function (find, replace, str) { return str.replace(new RegExp(find, 'g'), replace); } value = replaceAll(', ', ',', value); let timePart = ''; let datePart = value; if (value.indexOf(':') >= 0) { timePart = value.substring(value.indexOf(':') - 2); timePart = that.trim(timePart); datePart = value.substring(0, value.indexOf(':') - 2); } else if (value.toUpperCase().indexOf('AM') >= 0) { timePart = value.substring(value.toUpperCase().indexOf('AM') - 2); timePart = that.trim(timePart); datePart = value.substring(0, value.toUpperCase().indexOf('AM') - 2); } else if (value.toUpperCase().indexOf('PM') >= 0) { timePart = value.substring(value.toUpperCase().indexOf('PM') - 2); timePart = that.trim(timePart); datePart = value.substring(0, value.toUpperCase().indexOf('PM') - 2); } let parseDate = new Date(); let parsed = false; if (datePart) { for (let i = 0; i < splitParts.length; i++) { if (datePart.indexOf(splitParts[i]) >= 0) { dateParts = datePart.split(splitParts[i]); break; } } if (!dateParts) { return null; } let days = new Array(); let months = new Array(); let years = new Array(); let dayPart = null; let monthPart = null; for (let i = 0; i < dateParts.length; i++) { const part = dateParts[i]; const isDay = that.parseDate(part, 'd', calendar) || that.parseDate(part, 'dd', calendar) || that.parseDate(part, 'ddd', calendar) || that.parseDate(part, 'dddd', calendar); if (isDay) { days.push(isDay.getDate()); if (part.length > 2) { dayPart = i; break; } } } for (let i = 0; i < dateParts.length; i++) { const part = dateParts[i], isMonth = that.parseDate(part, 'M', calendar) || that.parseDate(part, 'MM', calendar) || that.parseDate(part, 'MMM', calendar) || that.parseDate(part, 'MMMM', calendar); if (isMonth) { if (dayPart !== null && dayPart !== undefined && dayPart === i) continue; months.push(isMonth.getMonth()); if (part.length > 2) { monthPart = i; break; } } } for (let i = 0; i < dateParts.length; i++) { const part = dateParts[i]; const isYear = that.parseDate(part, 'yyyy', calendar); if (isYear) { if (dayPart !== null && dayPart !== undefined && dayPart === i) continue; if (monthPart !== null && monthPart !== undefined && monthPart === i) continue; years.push(isYear.getFullYear()); } } const dates = new Array(); for (let d = days.length - 1; d >= 0; d--) { for (let m = 0; m < months.length; m++) { for (let y = 0; y < years.length; y++) { const result = new Date(years[y], months[m], days[d]); if (years[y] < 1970) result.setFullYear(years[y]); if (!isNaN(result.getTime())) { dates.push(result); } } } } if (dates.length > 0) { parseDate = dates[0]; parsed = true; } } if (timePart) { const timeParts = timePart.indexOf(':') >= 0 ? timePart.split(':') : timePart; const parsedTime = that.parseDate(timePart, 'h:mm tt', calendar) || that.parseDate(timePart, 'HH:mm:ss.fff', calendar) || that.parseDate(timePart, 'HH:mm:ss.ff', calendar) || that.parseDate(timePart, 'h:mm:ss tt', calendar) || that.parseDate(timePart, 'HH:mm:ss.tttt', calendar) || that.parseDate(timePart, 'HH:mm:ss', calendar) || that.parseDate(timePart, 'HH:mm', calendar) || that.parseDate(timePart, 'HH', calendar); let hour = 0, minute = 0, second = 0, milisecond = 0; if (parsedTime && !isNaN(parsedTime.getTime())) { hour = parsedTime.getHours(); minute = parsedTime.getMinutes(); second = parsedTime.getSeconds(); milisecond = parsedTime.getMilliseconds(); } else { if (timeParts.length === 1) { hour = parseInt(timeParts[0]); } if (timeParts.length === 2) { hour = parseInt(timeParts[0]); minute = parseInt(timeParts[1]); } if (timeParts.length === 3) { hour = parseInt(timeParts[0]); minute = parseInt(timeParts[1]); if (timeParts[2].indexOf('.') >= 0) { second = parseInt(timeParts[2].toString().split('.')[0]); milisecond = parseInt(timeParts[2].toString().split('.')[1]); } else { second = parseInt(timeParts[2]); } } if (timeParts.length === 4) { hour = parseInt(timeParts[0]); minute = parseInt(timeParts[1]); second = parseInt(timeParts[2]); milisecond = parseInt(timeParts[3]); } } if (parseDate && !isNaN(hour) && !isNaN(minute) && !isNaN(second) && !isNaN(milisecond)) { parseDate.setHours(hour, minute, second, milisecond); parsed = true; } } if (parsed) { return parseDate; } } if (value !== null && value !== undefined) { dateParts = [':', '/', '-']; let canParse = true; for (let part = 0; part < dateParts.length; part++) { if (value.indexOf(dateParts[part]) !== -1) { canParse = false; } } if (canParse) { const number = new Number(value); if (!isNaN(number)) { return new Date(number); } } } return null; } getParseRegExp(cal, format) { const that = this; // converts a format string into a regular expression with groups that // can be used to extract date fields from a date string. // check for a cached parse regex. let re = cal._parseRegExp; if (!re) { cal._parseRegExp = re = {}; } else { const reFormat = re[format]; if (reFormat) { return reFormat; } } // expand single digit formats, then escape regular expression characters. let expFormat = that.expandFormat(cal, format).replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, '\\\\$1'), regexp = ['^'], groups = [], index = 0, quoteCount = 0, tokenRegExp = that.getTokenRegExp(), match; // iterate through each date token found. while ((match = tokenRegExp.exec(expFormat)) !== null) { const preMatch = expFormat.slice(index, match.index); index = tokenRegExp.lastIndex; // don't replace any matches that occur inside a string literal. quoteCount += that.appendPreOrPostMatch(preMatch, regexp); if (quoteCount % 2) { regexp.push(match[0]); continue; } // add a regex group for the token. let m = match[0], len = m.length, add; switch (m) { case 'dddd': case 'ddd': case 'MMMM': case 'MMM': case 'gg': case 'g': add = '(\\D+)'; break; case 'tt': case 't': add = '(\\D*)'; break; case 'yyyyy': add = '(\\d{1,4})'; break; case 'yyyy': add = '(\\d{' + len + '})'; break; case 'fff': case 'ff': case 'f': add = '(\\d{1,' + len + '})'; break; case 'dd': case 'd': case 'MM': case 'M': case 'yy': case 'y': case 'HH': case 'H': case 'hh': case 'h': case 'mm': case 'm': case 'ss': case 's': add = '(\\d\\d?)'; break; case 'uu': case 'nn': case 'pp': case 'ee': case 'aa': case 'xx': case 'oo': add = '(\\d{1,3})'; break; case 'zzz': add = '([+-]?\\d\\d?:\\d{2})'; break; case 'zz': case 'z': add = '([+-]?\\d\\d?)'; break; case '/': add = '/'; // To include slash in a capturing group  add = '(\\' + cal['/'] + ')'; break; default: if ((/i{1,24}/).test(m)) { add = '(\\d{' + m.length + '})'; } else { throw 'Invalid date format pattern \'' + m + '\'.'; } } if (add) { regexp.push(add); } if (m === '/') { continue; } groups.push(match[0]); } that.appendPreOrPostMatch(expFormat.slice(index), regexp); regexp.push('$'); // allow whitespace to differ when matching formats. const regexpStr = regexp.join('').replace(/\s+/g, '\\s+'), parseRegExp = { 'regExp': regexpStr, 'groups': groups }; // cache the regex for this format. return re[format] = parseRegExp; } outOfRange(value, low, high) { return value < low || value > high; } expandYear(cal, year) { const that = this; // expands 2-digit year into 4 digits. const now = new Date(), era = that.getEra(now); if (year < 100) { let twoDigitYearMax = cal.twoDigitYearMax; twoDigitYearMax = typeof twoDigitYearMax === 'string' ? new Date().getFullYear() % 100 + parseInt(twoDigitYearMax, 10) : twoDigitYearMax; const curr = that.getEraYear(now, cal, era); year += curr - (curr % 100); if (year > twoDigitYearMax) { year -= 100; } } return year; } padZeros(num, c) { let r, s = num + '', zeros = ['0', '00', '000']; if (c > 1 && s.length < c) { r = (zeros[c - 2] + s); return r.substr(r.length - c, c); } else { r = s; } return r; } parseDate(value, format, calendar) { const that = this; if (calendar === undefined || calendar === null) { calendar = that.calendar; } // try to parse the date string by matching against the format string // while using the specified culture for date field names. value = that.trim(value); const cal = calendar, // convert date formats into regular expressions with groupings. // use the regexp to determine the input format and extract the date fields. parseInfo = that.getParseRegExp(cal, format), match = new RegExp(parseInfo.regExp).exec(value); if (match === null) { return null; } // found a date format that matches the input. let groups = parseInfo.groups, era = null, year = null, month = null, date = null, weekDay = null, hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null, pmHour = false; // iterate the format groups to extract and set the date fields. for (let j = 0, jl = groups.length; j < jl; j++) { const matchGroup = match[j + 1]; if (matchGroup) { const current = groups[j], clength = current.length, matchInt = parseInt(matchGroup, 10); switch (current) { case 'dd': case 'd': // Day of month. date = matchInt; // check that date is generally in valid range, also checking overflow below. if (that.outOfRange(date, 1, 31)) return null; break; case 'MMM': case 'MMMM': case 'MMMMM': case 'MMMMMM': case 'MMMMMMM': case 'MMMMMMMM': month = that.getMonthIndex(cal, matchGroup, clength === 3); if (that.outOfRange(month, 0, 11)) return null; break; case 'M': case 'MM': // Month. month = matchInt - 1; if (that.outOfRange(month, 0, 11)) return null; break; case 'y': case 'yy': case 'yyyy': year = clength < 4 ? that.expandYear(cal, matchInt) : matchInt; if (that.outOfRange(year, 0, 9999)) return null; break; case 'h': case 'hh': // Hours (12-hour clock). hour = matchInt; if (hour === 12) hour = 0; if (that.outOfRange(hour, 0, 11)) return null; break; case 'H': case 'HH': // Hours (24-hour clock). hour = matchInt; if (that.outOfRange(hour, 0, 23)) return null; break; case 'm': case 'mm': // Minutes. min = matchInt; if (that.outOfRange(min, 0, 59)) return null; break; case 's': case 'ss': // Seconds. sec = matchInt; if (that.outOfRange(sec, 0, 59)) return null; break; case 'tt': case 't': // AM/PM designator. // see if it is standard, upper, or lower case PM. If not, ensure it is at least one of // the AM tokens. If not, fail the parse for this format. pmHour = cal.PM && (matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2]); if (!pmHour && (!cal.AM || (matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2]))) return null; break; case 'f': // Deciseconds. case 'ff': // Centiseconds. case 'fff': // Milliseconds. msec = matchInt * Math.pow(10, 3 - clength); if (that.outOfRange(msec, 0, 999)) return null; break; case 'uu': case 'nn': case 'pp': case 'ee': case 'aa': case 'xx': case 'oo': if (that.outOfRange(matchInt, 0, 1000)) { return null; } that[that._codeToUnit[current]] = matchInt; break; case 'ddd': // Day of week. case 'dddd': // Day of week. weekDay = that.getDayIndex(cal, matchGroup, clength === 3); if (that.outOfRange(weekDay, 0, 6)) return null; break; case 'zzz': { // Time zone offset in +/- hours:min. const offsets = matchGroup.split(/:/); if (offsets.length !== 2) return null; hourOffset = parseInt(offsets[0], 10); if (that.outOfRange(hourOffset, -12, 13)) return null; const minOffset = parseInt(offsets[1], 10); if (that.outOfRange(minOffset, 0, 59)) return null; tzMinOffset = (hourOffset * 60) + (that.startsWith(matchGroup, '-') ? -minOffset : minOffset); break; } case 'z': case 'zz': // Time zone offset in +/- hours. hourOffset = matchInt; if (that.outOfRange(hourOffset, -12, 13)) return null; tzMinOffset = hourOffset * 60; break; case 'g': case 'gg': { let eraName = matchGroup; if (!eraName || !cal.eras) return null; eraName = this.trim(eraName.toLowerCase()); for (let i = 0, l = cal.eras.length; i < l; i++) { if (eraName === cal.eras[i].nathat.toLowerCase()) { era = i; break; } } // could not find an era with that name if (era === null) return null; break; } default: { let precisionDigits = matchGroup; if (precisionDigits.length % 3 === 1) { precisionDigits += '00'; } else if (precisionDigits.length % 3 === 2) { precisionDigits += '0'; } msec = parseInt(precisionDigits.slice(0, 3), 10); precisionDigits = precisionDigits.slice(3); let unitIndex = 0; while (precisionDigits.length > 0) { that[that._smallUnits[unitIndex]] = parseInt(precisionDigits.slice(0, 3), 10); precisionDigits = precisionDigits.slice(3); unitIndex++; } } } } } let result = new Date(), defaultYear, convert = cal.convert; defaultYear = result.getFullYear(); if (year === null) { year = defaultYear; } else if (cal.eras) { // year must be shifted to normal gregorian year // but not if year was not specified, its already normal gregorian // per the main if clause above. year += cal.eras[(era || 0)].offset; } // set default day and month to 1 and January, so if unspecified, these are the defaults // instead of the current day/month. if (month === null) { month = 0; } if (date === null) { date = 1; } // now have year, month, and date, but in the culture's calendar. // convert to gregorian if necessary if (convert) { result = convert.toGregorian(year, month, date); // conversion failed, must be an invalid match if (result === null) return null; } else { // have to set year, month and date together to avoid overflow based on current date. result.setFullYear(year, month, date); // check to see if date overflowed for specified month (only checked 1-31 above). if (result.getDate() !== date) return null; // invalid day of week. if (weekDay !== null && result.getDay() !== weekDay) { return null; } } // if pm designator token was found make sure the hours fit the 24-hour clock. if (pmHour && hour < 12) { hour += 12; } result.setHours(hour, min, sec, msec); if (tzMinOffset !== null) { // adjust timezone to utc before applying local offset. const adjustedMin = result.getMinutes() - (tzMinOffset + result.getTimezoneOffset()); // Safari limits hours and minutes to the range of -127 to 127. We need to use setHours // to ensure both these fields will not exceed this range. adjustedMin will range // somewhere between -1440 and 1500, so we only need to split this into hours. result.setHours(result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60); } return result; } toString(format, calendar) { const that = this; if (format === undefined) { format = 'yyyy-MM-dd HH:mm:ss'; } const formatStamp = that.dateData.toString() + that.getFractionsOfSecondStamp() + format + (that.timeZone || ''); if (LW.Utilities.DateTime.cache && LW.Utilities.DateTime.cache[formatStamp]) { return LW.Utilities.DateTime.cache[formatStamp]; } const value = that.toDate(); if (calendar === undefined || calendar === null) { calendar = that.calendar; } if (typeof value === 'string') { return value; } if (!format || !format.length || format === 'i') { let ret; ret = that.formatDate(value, calendar.patterns.F, calendar); return ret; } const eras = calendar.eras, sortable = format === 's'; format = that.expandFormat(calendar, format); // Start with an empty string const ret = []; let hour, quoteCount = 0, tokenRegExp = that.getTokenRegExp(), converted; function getPart(date, part) { if (converted) { return converted[part]; } if (date.getMonth !== undefined) { switch (part) { case 0: return date.getFullYear(); case 1: return date.getMonth(); case 2: return date.getDate(); } } } for (; ;) { // Save the current index const index = tokenRegExp.lastIndex, // Look for the next pattern ar = tokenRegExp.exec(format); // Append the text before the pattern (or the end of the string if not found) const preMatch = format.slice(index, ar ? ar.index : format.length); quoteCount += that.appendPreOrPostMatch(preMatch, ret); if (!ar) { break; } // do not replace any matches that occur inside a string literal. if (quoteCount % 2) { ret.push(ar[0]); continue; } const current = ar[0], clength = current.length; let part; if ((/i{1,24}/).test(current)) { ret.push(that.getFirstNDigitsOfPrecision(current.length)); continue; } switch (current) { case 'ddd': //Day of the week, as a three-letter abbreviation case 'dddd': { // Day of the week, using the full name const names = (clength === 3) ? calendar.days.namesAbbr : calendar.days.names; ret.push(names[value.getDay()]); break; } case 'd': // Day of month, without leading zero for single-digit days case 'dd': // Day of month, with leading zero for single-digit days ret.push(that.padZeros(getPart(value, 2), clength)); break; case 'MMM': // Month, as a three-letter abbreviation case 'MMMM': // Month, using the full name part = getPart(value, 1); ret.push(calendar.months[clength === 3 ? 'namesAbbr' : 'names'][part]); break; case 'M': // Month, as digits, with no leading zero for single-digit months case 'MM': // Month, as digits, with leading zero for single-digit months ret.push(that.padZeros(getPart(value, 1) + 1, clength)); break; case 'y': // Year, as two digits, but with no leading zero for years less than 10 case 'yy': // Year, as two digits, with leading zero for years less than 10 case 'yyyy': // Year represented by four full digits part = that.getEraYear(value, calendar, that.getEra(value, eras), sortable); if (clength < 4) { part = part % 100; } ret.push(that.padZeros(part, clength)); break; case 'h': // Hours with no leading zero for single-digit hours, using 12-hour clock case 'hh': // Hours with leading zero for single-digit hours, using 12-hour clock hour = value.getHours() % 12; if (hour === 0) hour = 12; ret.push(that.padZeros(hour, clength)); break; case 'H': // Hours with no leading zero for single-digit hours, using 24-hour clock case 'HH': // Hours with leading zero for single-digit hours, using 24-hour clock ret.push(that.padZeros(value.getHours(), clength)); break; case 'm': // Minutes with no leading zero for single-digit minutes case 'mm': // Minutes with leading zero for single-digit minutes ret.push(that.padZeros(value.getMinutes(), clength)); break; case 's': // Seconds with no leading zero for single-digit seconds case 'ss': // Seconds with leading zero for single-digit seconds ret.push(that.padZeros(value.getSeconds(), clength)); break; case 't': // One character am/pm indicator ('a' or 'p') case 'tt': // Multicharacter am/pm indicator part = value.getHours() < 12 ? (calendar.AM ? calendar.AM[0] : ' ') : (calendar.PM ? calendar.PM[0] : ' '); ret.push(clength === 1 ? part.charAt(0) : part); break; case 'f': // Deciseconds case 'ff': // Centiseconds case 'fff': // Milliseconds ret.push(that.padZeros(value.getMilliseconds(), 3).substr(0, clength)); break; case 'u': case 'n': case 'p': case 'e': case 'a': case 'x': case 'o': ret.push(that[that._codeToUnit[current]]); break; case 'uu': case 'nn': case 'pp': case 'ee': case 'aa': case 'xx': case 'oo': ret.push(that.padZeros(that[that._codeToUnit[current]], 3)); break; case 'z': // Time zone offset, no leading zero case 'zz': // Time zone offset with leading zero //hour = value.getTimezoneOffset() / 60; //ret.push((hour <= 0 ? '+' : '-') + that.padZeros(Math.floor(Math.abs(hour)), clength)); ret.push((that.timeZoneOffsetHours >= 0 ? '+' : '-') + that.padZeros(Math.floor(Math.abs(that.timeZoneOffsetHours)), clength)); break; case 'zzz': // // Time zone offset with leading zero // hour = value.getTimezoneOffset() / 60; // ret.push((hour <= 0 ? '+' : '-') + that.padZeros(Math.floor(Math.abs(hour)), 2) + // // Hard coded ':' separator, rather than using calendar.TimeSeparator // // Repeated here for consistency, plus ':' was already assumed in date parsing. //':' + that.padZeros(Math.abs(value.getTimezoneOffset() % 60), 2)); ret.push((that.timeZoneOffsetHours >= 0 ? '+' : '-') + that.padZeros(Math.floor(Math.abs(that.timeZoneOffsetHours)), 2) + ':' + that.padZeros(Math.abs(that.timeZoneOffsetHours % 1) * 60, 2)); break; case 'g': case 'gg': if (calendar.eras) { ret.push(calendar.eras[that.getEra(value, eras)].name); } break; case '/': ret.push(calendar['/']); break; default: throw 'Invalid date format pattern \'' + current + '\'.'; } } const result = ret.join(''); if (!LW.Utilities.DateTime.cache) { LW.Utilities.DateTime.cache = new Array(); } LW.Utilities.DateTime.cache[formatStamp] = result; return result; } /** * Returns a time stamp from the microseconds, nanoseconds, picoseconds, femtoseconds, attoseconds, zeptoseconds and yoctoseconds. */ getFractionsOfSecondStamp() { const that = this; return that._microsecond.toString() + that._nanosecond + that._picosecond + that._femtosecond + that._attosecond + that._zeptosecond + that._yoctosecond; } getFirstNDigitsOfPrecision(precision, noMilliseconds) { const that = this, result = '' + (noMilliseconds !== true ? that.padZeros(that.millisecond(), 3) : '') + that.padZeros(that._microsecond, 3) + that.padZeros(that._nanosecond, 3) + that.padZeros(that._picosecond, 3) + that.padZeros(that._femtosecond, 3) + that.padZeros(that._attosecond, 3) + that.padZeros(that._zeptosecond, 3) + that.padZeros(that._yoctosecond, 3); return result.slice(0, precision); } copySmallTimePartValues(newDate) { const that = this; newDate._microsecond = that._microsecond; newDate._nanosecond = that._nanosecond; newDate._picosecond = that._picosecond; newDate._femtosecond = that._femtosecond; newDate._attosecond = that._attosecond; newDate._zeptosecond = that._zeptosecond; newDate._yoctosecond = that._yoctosecond; } add(value, scale, createNew) { const that = this; const ms = that.internalMS(); if (scale === undefined) { if (createNew === false) { that.dateData = (ms + parseInt(value._ticks / that.ticksPerMillisecond)); return that; } const newDate = new LW.Utilities.DateTime((ms + parseInt(value._ticks / that.ticksPerMillisecond))); that.copyTimeZone(newDate); that.copySmallTimePartValues(newDate); return newDate; } const millis = (value * scale); if (millis <= -that.maxMillis || millis >= that.maxMillis) throw new Error('Out of Range'); if (createNew === false) { that.dateData = (ms + millis); return that; } const newDate = new LW.Utilities.DateTime(ms + millis); that.copyTimeZone(newDate); that.copySmallTimePartValues(newDate); return newDate; } addDays(value, createNew) { const that = this; return that.add(value, that.millisPerDay, createNew); } /** * Clones a DateTime object. */ clone() { const that = this, date = new LW.Utilities.DateTime(that.dateData); that.copyTimeZone(date); that.copySmallTimePartValues(date); return date; } clearTime() { const that = this, month = that.month(), year = that.year(), day = that.day(), newDate = new LW.Utilities.DateTime(year, month, day, 0, 0, 0, 0); that.copyTimeZone(newDate); return newDate; } addHours(value, createNew) { const that = this; return that.add(value, that.millisPerHour, createNew); } addDeciseconds(value, createNew) { return this.add(value * 100, 1, createNew); } addCentiseconds(value, createNew) { return this.add(value * 10, 1, createNew); } addMilliseconds(value, createNew) { return this.add(value, 1, createNew); } addMinutes(value, createNew) { const that = this; return that.add(value, that.millisPerMinute, createNew); } addMonths(months, createNew) { const that = this; if (months < -120000 || months > 120000) throw new Error('Invalid Months Value'); let y = parseInt(that.getDatePart(that.datePartYear)), m = parseInt(that.getDatePart(that.datePartMonth)), d = parseInt(that.getDatePart(that.datePartDay)); if (months % 12 === 0) { y = y + months / 12; } else { const i = m - 1 + months; if (i >= 0) { m = i % 12 + 1; y = y + i / 12; } else { m = 12 + (i + 1) % 12; y = y + (i - 11) / 12; } y = parseInt(y); } if (y < 1 || y > 9999) { throw new Error('Year out of range'); } const days = that.daysInMonth(y, m); if (d > days) d = days; if (createNew === false) { that.dateData = (that.dateToMS(y, m, d) + that.internalMS() % that.millisPerDay); return that; } const newDate = new LW.Utilities.DateTime((that.dateToMS(y, m, d) + that.internalMS() % that.millisPerDay)); that.copyTimeZone(newDate); that.copySmallTimePartValues(newDate); return newDate; } addSeconds(value, createNew) { const that = this; return that.add(value, that.millisPerSecond, createNew); } addYears(value, createNew) { return this.addMonths(value * 12, createNew); } /** * Adds or removes microseconds. */ addMicroseconds(value, createNew) { if (value === 0) { return; } const that = this; let millisecondsToAdd, microseconds; if (value < 0 && that.hour() === 0 && that.minute() === 0 && that.second() === 0 && that.millisecond() === 0 && that._microsecond === 0) { millisecondsToAdd = parseInt(value / 1000, 10) - 1; microseconds = 1000 + (value % 1000); } const totalMilliseconds = that.timeToMS(that.hour(), that.minute(), that.second(), that.millisecond()) * 1000 + that._microsecond, updatedTotalMilliseconds = totalMilliseconds + value; if (millisecondsToAdd === undefined) { millisecondsToAdd = parseInt(updatedTotalMilliseconds / 1000, 10) - parseInt(totalMilliseconds / 1000, 10); } if (microseconds === undefined) { microseconds = parseInt(updatedTotalMilliseconds % 1000, 10); } let newDateTimeObject; if (millisecondsToAdd !== 0) { newDateTimeObject = that.addMilliseconds(millisecondsToAdd, createNew); } if (createNew === false) { that._microsecond = microseconds; } else { if (!newDateTimeObject) { newDateTimeObject = that.clone(); } newDateTimeObject._microsecond = microseconds; return newDateTimeObject; } } /** * Adds or removes parts of a second. */ addFractionsOfSecond(value, createNew, unit, biggerUnit, biggerUnitMethod) { if (value === 0) { return; } const that = this, total = that[biggerUnit] * 1000 + that[unit], updatedTotal = value + total; let biggerUnitToAdd = parseInt(updatedTotal / 1000, 10) - parseInt(total / 1000, 10), units = parseInt(updatedTotal % 1000, 10), newDateTimeObject; if (value < 0 && updatedTotal < 0 && units < 0) { biggerUnitToAdd--; units = 1000 + units; } if (biggerUnitToAdd !== 0) { newDateTimeObject = that[biggerUnitMethod](biggerUnitToAdd, createNew); } if (createNew === false) { that[unit] = units; } else { if (!newDateTimeObject) { newDateTimeObject = that.clone(); } newDateTimeObject[unit] = units; return newDateTimeObject; } } /** * Adds or removes nanoseconds. */ addNanoseconds(value, createNew) { return this.addFractionsOfSecond(value, createNew, '_nanosecond', '_microsecond', 'addMicroseconds'); } /** * Adds or removes picoseconds. */ addPicoseconds(value, createNew) { return this.addFractionsOfSecond(value, createNew, '_picosecond', '_nanosecond', 'addNanoseconds'); } /** * Adds or removes femtoseconds. */ addFemtoseconds(value, createNew) { return this.addFractionsOfSecond(value, createNew, '_femtosecond', '_picosecond', 'addPicoseconds'); } /** * Adds or removes attoseconds. */ addAttoseconds(value, createNew) { return this.addFractionsOfSecond(value, createNew, '_attosecond', '_femtosecond', 'addFemtoseconds'); } /** * Adds or removes zeptoseconds. */ addZeptoseconds(value, createNew) { return this.addFractionsOfSecond(value, createNew, '_zeptosecond', '_attosecond', 'addAttoseconds'); } /** * Adds or removes yoctoseconds. */ addYoctoseconds(value, createNew) { return this.addFractionsOfSecond(value, createNew, '_yoctosecond', '_zeptosecond', 'addZeptoseconds'); } getTimeZoneOffset() { const today = new Date(), jan = new Date(today.getFullYear(), 0, 1), jul = new Date(today.getFullYear(), 6, 1), dst = today.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset()); return { offset: -(today.getTimezoneOffset() / 60), dst: +dst }; } isInDaylightSavingTime() { const today = new Date(), winter = new Date(today.getFullYear(), 0, 1), summer = new Date(today.getFullYear(), 6, 1); return this.date().getTimezoneOffset() < Math.max(winter.getTimezoneOffset(), summer.getTimezoneOffset()); } supportsDaylightSavingTime() { const today = new Date(), winter = new Date(today.getFullYear(), 0, 1), summer = new Date(today.getFullYear(), 6, 1); return winter.getTimezoneOffset() !== summer.getTimezoneOffset(); } date() { const that = this, month = that.month(), year = that.year(), day = that.day(), newDate = new LW.Utilities.DateTime(year, month, day); that.copyTimeZone(newDate); return newDate; } isWeekend() { const that = this; return that.dayOfWeek() === 0 || that.dayOfWeek() === 6; } toDate(timeZone) { const that = this, month = that.month(), year = that.year(), day = that.day(), hour = that.hour(), minute = that.minute(), second = that.second(), millisecond = that.millisecond(); let result = new Date(year, month - 1, day); if (year < 1970) { result.setFullYear(year); } result.setHours(hour, minute, second, millisecond); if (timeZone) { const matches = that.timeZones.filter(function (zone) { return zone.id === timeZone; }); if (matches.length) { let tzMinOffset = matches[0].offset; const localTime = result.getTime(); let localOffset = result.getTimezoneOffset() * 60 * 1000; if (that.timeZone) { const timeZoneMatches = that.timeZones.filter(function (zone) { return zone.id === that.timeZone; }); if (timeZoneMatches.length) { localOffset = -timeZoneMatches[0].offset * 60 * 1000; } } // obtain UTC time in msec const utc = localTime + localOffset; // create new Date object for different city // using supplied offset result = new Date(utc + (60 * 1000 * tzMinOffset)); } } return result; } toTimeZone(timeZone) { const that = this; let tz = timeZone; if (tz === null || tz === undefined) { tz = 'Local'; } if (that.timeZone === tz) { return that.clone(); } const matches = that.timeZones.filter(function (zone) { return zone.id === tz; }); if (matches.length === 0) { return that.clone(); } const date = this.toDate(tz), lwDate = new LW.Utilities.DateTime(date); lwDate.timeZone = tz; lwDate.timeZoneOffset = matches[0].offset; lwDate.timeZoneOffsetHours = matches[0].offsetHours; that.copySmallTimePartValues(lwDate); return lwDate; } day() { const that = this; return that.getDatePart(that.datePartDay); } month() { const that = this; return that.getDatePart(that.datePartMonth); } year() { const that = this; return that.getDatePart(that.datePartYear); } millisecond() { return parseInt((this.internalMS()) % 1000); } hour() { const that = this; return parseInt(Math.floor(that.internalMS() / that.millisPerHour) % 24); } minute() { const that = this; return parseInt((that.internalMS() / that.millisPerMinute) % 60); } second() { const that = this; return parseInt((that.internalMS() / that.millisPerSecond) % 60); } microsecond() { return this._microsecond; } nanosecond() { return this._nanosecond; } picosecond() { return this._picosecond; } femtosecond() { return this._femtosecond; } attosecond() { return this._attosecond; } zeptosecond() { return this._zeptosecond; } yoctosecond() { return this._yoctosecond; } valueOf() { return this.dateData; } equals(date) { const that = this; return that.dateData === date.dateData && that._microsecond === date._microsecond && that._nanosecond === date._nanosecond && that._picosecond === date._picosecond && that._femtosecond === date._femtosecond && that._attosecond === date._attosecond && that._zeptosecond === date._zeptosecond && that._yoctosecond === date._yoctosecond; } equalDateParts(date) { const that = this; if (that.year() === date.year() && that.month() === date.month() && that.day() === date.day()) { return true; } return false; } /** * Compares two dates. */ compare(date) { const that = this; if (that.equals(date)) { return 0; } const timeParts = ['dateData', '_microsecond', '_nanosecond', '_picosecond', '_femtosecond', '_attosecond', '_zeptosecond', '_yoctosecond']; for (let i = 0; i < timeParts.length; i++) { const timePart = timeParts[i]; if (that[timePart] > date[timePart]) { return 1; } else if (that[timePart] < date[timePart]) { return -1; } } return 0; } toDateString() { return this.toDate().toDateString(); } toLocaleDateString() { const that = this; return that.toDate().toLocaleDateString(that.calendar.locale); } toLocaleString() { const that = this; return that.toDate().toLocaleString(that.calendar.locale); } toLocaleTimeString() { const that = this; return that.toDate().toLocaleTimeString(that.calendar.locale); } validateTimeZone(timeZone) { const that = this; if (typeof timeZone !== 'string') { return; } const matches = that.timeZones.filter(function (zone) { return zone.id === timeZone; }); if (matches.length === 0) { return; } that.timeZone = timeZone; that.timeZoneOffset = matches[0].offset; that.timeZoneOffsetHours = matches[0].offsetHours; } copyTimeZone(newDateTime) { const that = this; newDateTime.timeZone = that.timeZone; newDateTime.timeZoneOffset = that.timeZoneOffset; newDateTime.timeZoneOffsetHours = that.timeZoneOffsetHours; } getTimeStamp() { const that = this, timeStamp = new LW.Utilities.BigNumber(that.dateData.toString() + that.getFirstNDigitsOfPrecision(undefined, true)); return timeStamp; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // // Draw class LW.Utilities.Assign('Draw', class Draw { constructor(host, renderEngine) { const that = this; that.host = host; that.renderEngine = renderEngine || ''; that.refresh(); const functions = [ 'clear', 'removeElement', 'attr', 'getAttr', 'line', 'circle', 'rect', 'path', 'pieslice', 'pieSlicePath', 'text', 'measureText' ]; for (let i in functions) { that._addFn(LW.Utilities.Draw.prototype, functions[i]); } } _addFn(target, name) { if (target[name]) return; target[name] = function () { return this.renderer[name].apply(this.renderer, arguments); }; } _initRenderer(host) { return this.createRenderer(this, host); } _internalRefresh() { const self = this; if (!self.renderer) { self.host.innerHTML = ''; self._initRenderer(self.host); } // validate visiblity if (window.getComputedStyle(self.host).display === 'none') { return; } const renderer = self.renderer; if (!renderer) return; const rect = renderer.getRect(); self._render({ x: 1, y: 1, width: rect.width, height: rect.height }); } _render(rect) { this._plotRect = rect; } // Public API refresh() { this._internalRefresh(); } getSize() { const rect = this._plotRect; return { width: rect.width, height: rect.height }; } toGreyScale(color) { if (color.indexOf('#') === -1) return color; const rgb = this.cssToRgb(color); rgb[0] = rgb[1] = rgb[2] = Math.round(0.3 * rgb[0] + 0.59 * rgb[1] + 0.11 * rgb[2]); const hex = this.rgbToHex(rgb[0], rgb[1], rgb[2]); return '#' + hex[0] + hex[1] + hex[2]; } decToHex(dec) { return dec.toString(16); } hexToDec(hex) { return parseInt(hex, 16); } rgbToHex(r, g, b) { return [this.decToHex(r), this.decToHex(g), this.decToHex(b)]; } hexToRgb(h, e, x) { return [this.hexToDec(h), this.hexToDec(e), this.hexToDec(x)]; } cssToRgb(color) { if (color.indexOf('rgb') <= -1) { return this.hexToRgb(color.substring(1, 3), color.substring(3, 5), color.substring(5, 7)); } return color.substring(4, color.length - 1).split(','); } hslToRgb(hsl) { let r, g, b; const h = parseFloat(hsl[0]); const s = parseFloat(hsl[1]); const l = parseFloat(hsl[2]); if (s === 0) { r = g = b = l; } else { const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q; r = this.hueToRgb(p, q, h + 1 / 3); g = this.hueToRgb(p, q, h); b = this.hueToRgb(p, q, h - 1 / 3); } return [r * 255, g * 255, b * 255]; } hueToRgb(p, q, t) { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1 / 6) return p + (q - p) * 6 * t; else if (t < 1 / 2) return q; else if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6; return p; } rgbToHsl(rgb) { const r = parseFloat(rgb[0]) / 255; const g = parseFloat(rgb[1]) / 255; const b = parseFloat(rgb[2]) / 255; const max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, l = (max + min) / 2; if (max === min) { h = s = 0; } else { const diff = max - min; s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min); switch (max) { case r: h = (g - b) / diff + (g < b ? 6 : 0); break; case g: h = (b - r) / diff + 2; break; case b: h = (r - g) / diff + 4; break; } h /= 6; } return [h, s, l]; } swap(x, y) { const tmp = x; x = y; y = tmp; } getNum(arr) { if (arr.constructor !== Array) { if (isNaN(arr)) return 0; } else { for (let i = 0; i < arr.length; i++) if (!isNaN(arr[i])) return arr[i]; } return 0; } _ptRotate(x, y, cx, cy, angle) { const radius = Math.sqrt(Math.pow(Math.abs(x - cx), 2) + Math.pow(Math.abs(y - cy), 2)); const currAngle = Math.asin((x - cx) / radius); const newAngle = currAngle + angle; x = cx + Math.cos(newAngle) * radius; y = cy + Math.sin(newAngle) * radius; return { x: x, y: y }; } log(val, base) { return Math.log(val) / (base ? Math.log(base) : 1); } _mod(a, b) { const min = Math.abs(a > b ? b : a); let scale = 1; if (min !== 0) { while (min * scale < 100) scale *= 10; } a = a * scale; b = b * scale; return (a % b) / scale; } createRenderer(widgetInstance, host) { const self = widgetInstance; let renderer = self.renderer = null; if (document.createElementNS && self.renderEngine !== 'HTML5') { renderer = new LW.Utilities.SvgRenderer(this); } if (renderer === null && (self.renderEngine === 'HTML5' || self.renderEngine === undefined)) { renderer = new LW.Utilities.HTML5Renderer(this); } renderer.init(host); self.renderer = renderer; return renderer; } getByPriority(arr) { let value = undefined; for (let i = 0; i < arr.length; i++) { const current = arr[i]; if (current !== undefined && current !== null && current !== '') { value = current; break; } } return value; } get(array, index, key) { return key !== undefined ? array[index][key] : array[index]; } min(array, key) { let min = NaN; for (let i = 0; i < array.length; i++) { const val = this.get(array, i, key); if (isNaN(min) || val < min) min = val; } return min; } max(array, key) { let max = NaN; for (let i = 0; i < array.length; i++) { const val = this.get(array, i, key); if (isNaN(max) || val > max) max = val; } return max; } sum(array, key) { let sum = 0; for (let i = 0; i < array.length; i++) { const val = this.get(array, i, key); if (!isNaN(val)) sum += val; } return sum; } count(array, key) { let count = 0; for (let i = 0; i < array.length; i++) { const val = this.get(array, i, key); if (!isNaN(val)) count++; } return count; } avg(array, key) { return this.sum(array, key) / Math.max(1, this.count(array, key)); } filter(array, fn) { if (!fn) return array; const out = []; for (let i = 0; i < array.length; i++) if (fn(array[i])) out.push(array[i]); return out; } scale(val, range, scale_range, params) { if (isNaN(val)) return NaN; if (val < Math.min(range.min, range.max) || val > Math.max(range.min, range.max)) { if (!params || params['ignore_range'] !== true) return NaN; } let outVal = NaN; let percent = 1; if (range.type === undefined || range.type !== 'logarithmic') { let denom = Math.abs(range.max - range.min); if (!denom) denom = 1; percent = Math.abs(val - Math.min(range.min, range.max)) / denom; } else if (range.type === 'logarithmic') { let logBase = range.base; if (isNaN(logBase)) logBase = 10; let min = Math.min(range.min, range.max); if (min <= 0) min = 1; let max = Math.max(range.min, range.max); if (max <= 0) max = 1; const maxPow = this.log(max, logBase); max = Math.pow(logBase, maxPow); const minPow = this.log(min, logBase); min = Math.pow(logBase, minPow); const valPow = this.log(val, logBase); percent = Math.abs(valPow - minPow) / (maxPow - minPow); } if (scale_range.type === 'logarithmic') { let logBase = scale_range.base; if (isNaN(logBase)) logBase = 10; const maxPow = this.log(scale_range.max, logBase), minPow = this.log(scale_range.min, logBase); if (scale_range.flip) percent = 1 - percent; const valPow = Math.min(minPow, maxPow) + percent * Math.abs(maxPow - minPow); outVal = Math.pow(logBase, valPow); } else { outVal = Math.min(scale_range.min, scale_range.max) + percent * Math.abs(scale_range.max - scale_range.min); if (scale_range.flip) outVal = Math.max(scale_range.min, scale_range.max) - outVal + scale_range.min; } return outVal; } axis(min, max, preferedCount) { if (preferedCount <= 1) return [max, min]; if (isNaN(preferedCount) || preferedCount < 2) preferedCount = 2; let decimalPlaces = 0; while (Math.round(min) !== min && Math.round(max) !== max && decimalPlaces < 10) { min *= 10; max *= 10; decimalPlaces++; } let preferedIntSize = (max - min) / preferedCount; while (decimalPlaces < 10 && Math.round(preferedIntSize) !== preferedIntSize) { min *= 10; max *= 10; preferedIntSize *= 10; decimalPlaces++; } const scale = [1, 2, 5]; let i = 0, intSizeNext; // eslint-disable-next-line while (true) { let idx = i % scale.length; let pow = Math.floor(i / scale.length); let intSizeCurr = Math.pow(10, pow) * scale[idx]; idx = (i + 1) % scale.length; pow = Math.floor((i + 1) / scale.length); intSizeNext = Math.pow(10, pow) * scale[idx]; if (preferedIntSize >= intSizeCurr && preferedIntSize < intSizeNext) break; i++; } const intSizeSelected = intSizeNext; const out = []; let curr = this.renderer._rnd(min, intSizeSelected, false); const denominator = decimalPlaces <= 0 ? 1 : Math.pow(10, decimalPlaces); while (curr < max + intSizeSelected) { out.push(curr / denominator); curr += intSizeSelected; } return out; } _widgetToImage(widgetInstance, type, fileName, fnCallback, pageOrientation) { let self = widgetInstance; if (!self) return false; if (fileName === undefined || fileName === '') fileName = 'image.' + type; let renderEngineSaved = self.renderEngine; let enableAnimationsSaved = self.animation; self.animation = 'none'; // try switching to HTML5 self.renderEngine = 'HTML5'; if (self.renderEngine !== renderEngineSaved) { try { self.refresh(); } catch (e) { self.renderEngine = renderEngineSaved; self.refresh(); self.animation = enableAnimationsSaved; return false; } } let canvas = self.renderer.getContainer().firstElementChild; let continueExport = true; if (typeof fnCallback === 'function') { continueExport = fnCallback(widgetInstance, canvas); } let result = true; if (continueExport) result = this.exportImage(widgetInstance, canvas, type, fileName, pageOrientation); // switch back to existing engine if (self.renderEngine !== renderEngineSaved) { self.renderEngine = renderEngineSaved; self.refresh(); self.animation = enableAnimationsSaved; } return result; } _saveAsImage(type, fileName) { return this._widgetToImage(this, type, fileName); } saveAsPNG(filename) { return this._saveAsImage('png', filename); } saveAsJPEG(filename) { return this._saveAsImage('jpeg', filename); } exportImage(widgetInstance, canvas, type, fileName, pageOrientation) { if (!canvas) return false; let isPDF = type.toLowerCase() === 'pdf'; if (isPDF) type = 'jpeg'; if (fileName === undefined || fileName === '') fileName = 'image.' + type; let result = true; if (type === 'print') { const newWindow = window.open('', '', 'width=800,height=500'), printDocument = newWindow.document.open(), pageContent = '<!DOCTYPE html>' + '<html>' + '<head>' + '<meta charset="utf-8" />' + '<title>jQWidgets Chart</title>' + '</head>' + '<body><img src="' + canvas.toDataURL() + '" /></html>'; try { printDocument.write(pageContent); printDocument.close(); setTimeout(function () { newWindow.print(); newWindow.close(); }, 100); } catch (error) { // } return; } try { if (canvas) { if (isPDF) { pageOrientation = pageOrientation || 'portrait'; const data = canvas.toDataURL('image/' + type), docDefinition = { content: { image: data, width: Math.min(canvas.width / 1.35, (pageOrientation === 'portrait' ? 515 : 762)) }, pageOrientation: pageOrientation }; try { pdfMake.createPdf(docDefinition).download(fileName); } catch (error) { widgetInstance.error(widgetInstance.localize('missingReference', { files: 'pdfmake.min.js' })); } } else { if (!LW.Utilities.DataExporter) { widgetInstance.error(widgetInstance.localize('missingReference', { files: 'lw.export.js' })); } const dataExporter = new LW.Utilities.DataExporter(); canvas.toBlob(function (blob) { dataExporter.downloadFile(blob, type, fileName); }); } } } catch (e) { result = false; } return result; } }); // SvgRenderer class LW.Utilities.Assign('Renderer', class Renderer { constructor(draw) { const that = this; that.draw = draw; that._gradients = {}; that._toRadiansCoefficient = Math.PI * 2 / 360; } pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset) { if (!outerRadius) outerRadius = 1; const diff = Math.abs(angleFrom - angleTo); const lFlag = diff > 180 ? 1 : 0; if (diff >= 360) { angleTo = angleFrom + 359.99; } const radFrom = angleFrom * this._toRadiansCoefficient; const radTo = angleTo * this._toRadiansCoefficient; let x1 = x, x2 = x, y1 = y, y2 = y; const isDonut = !isNaN(innerRadius) && innerRadius > 0; if (isDonut) centerOffset = 0; const radFromCos = Math.cos(radFrom), radFromSin = Math.sin(radFrom), radToCos = Math.cos(radTo), radToSin = Math.sin(radTo); if (centerOffset + innerRadius > 0) { if (centerOffset > 0) { const midAngle = diff / 2 + angleFrom; const radMid = midAngle * this._toRadiansCoefficient; x += centerOffset * Math.cos(radMid); y -= centerOffset * Math.sin(radMid); } if (isDonut) { x1 = x + innerRadius * radFromCos; y1 = y - innerRadius * radFromSin; x2 = x + innerRadius * radToCos; y2 = y - innerRadius * radToSin; } } const x3 = x + outerRadius * radFromCos; const x4 = x + outerRadius * radToCos; const y3 = y - outerRadius * radFromSin; const y4 = y - outerRadius * radToSin; let path = ''; const isPartialCircle = (Math.abs(Math.abs(angleTo - angleFrom) - 360) > 0.02); if (isDonut) { path = 'M ' + x2 + ',' + y2; path += ' a' + innerRadius + ',' + innerRadius; path += ' 0 ' + lFlag + ',1 ' + (x1 - x2) + ',' + (y1 - y2); if (isPartialCircle) path += ' L' + x3 + ',' + y3; else path += ' M' + x3 + ',' + y3; path += ' a' + outerRadius + ',' + outerRadius; path += ' 0 ' + lFlag + ',0 ' + (x4 - x3) + ',' + (y4 - y3); if (isPartialCircle) path += ' Z'; } else { path = 'M ' + x4 + ',' + y4; path += ' a' + outerRadius + ',' + outerRadius; path += ' 0 ' + lFlag + ',1 ' + (x3 - x4) + ',' + (y3 - y4); if (isPartialCircle) { path += ' L' + x + ',' + y; path += ' Z'; } } return path; } measureText(text, angle, params, includeTextPartsInfo) { const textPartsInfo = this._getTextParts(text, angle, params); const tw = textPartsInfo.width; let th = textPartsInfo.height; if (false === includeTextPartsInfo) th /= 0.6; let retVal = {}; if (isNaN(angle)) angle = 0; if (angle === 0) { retVal = { width: this._rup(tw), height: this._rup(th) }; } else { const rads = angle * Math.PI * 2 / 360; const sn = Math.abs(Math.sin(rads)); const cs = Math.abs(Math.cos(rads)); const bh = Math.abs(tw * sn + th * cs); const bw = Math.abs(tw * cs + th * sn); retVal = { width: this._rup(bw), height: this._rup(bh) }; } if (includeTextPartsInfo) retVal.textPartsInfo = textPartsInfo; //retVal.height += 5; return retVal; } alignTextInRect(x, y, width, height, textWidth, textHeight, halign, valign, angle, rotateAround) { const rads = angle * Math.PI * 2 / 360; const sn = Math.sin(rads); const cs = Math.cos(rads); const h2 = textWidth * sn; const w2 = textWidth * cs; if (halign === 'center' || halign === '' || halign === 'undefined') x = x + width / 2; else if (halign === 'right') x = x + width; if (valign === 'center' || valign === 'middle' || valign === '' || valign === 'undefined') y = y + height / 2; else if (valign === 'bottom') y += height - textHeight / 2; else if (valign === 'top') y += textHeight / 2; rotateAround = rotateAround || ''; let adjustY = 'middle'; if (rotateAround.indexOf('top') !== -1) adjustY = 'top'; else if (rotateAround.indexOf('bottom') !== -1) adjustY = 'bottom'; let adjustX = 'center'; if (rotateAround.indexOf('left') !== -1) adjustX = 'left'; else if (rotateAround.indexOf('right') !== -1) adjustX = 'right'; if (adjustX === 'center') { x -= w2 / 2; y -= h2 / 2; } else if (adjustX === 'right') { x -= w2; y -= h2; } if (adjustY === 'top') { x -= textHeight * sn; y += textHeight * cs; } else if (adjustY === 'middle') { x -= textHeight * sn / 2; y += textHeight * cs / 2; } x = this._rup(x); y = this._rup(y); return { x: x, y: y }; } adjustColor(color, adj) { if (typeof (color) !== 'string') return '#000000'; if (color.indexOf('#') === -1) return color; const draw = this.draw; let rgb = draw.cssToRgb(color); const hsl = draw.rgbToHsl(rgb); hsl[2] = Math.min(1, hsl[2] * adj); hsl[1] = Math.min(1, hsl[1] * adj * 1.1); rgb = draw.hslToRgb(hsl); color = '#'; for (let i = 0; i < 3; i++) { let c = Math.round(rgb[i]); c = draw.decToHex(c); if (c.toString().length === 1) color += '0'; color += c; } return color.toUpperCase(); } _rup(n) { let nr = Math.round(n); if (n > nr) nr++; return nr; } _ptdist(x1, y1, x2, y2) { return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)); } _rnd(num, unit, toGreater, fast) { if (isNaN(num)) return num; if (undefined === fast) fast = true; let a = num - ((fast === true) ? num % unit : this._mod(num, unit)); if (num === a) return a; if (toGreater) { if (num > a) a += unit; } else { if (a > num) a -= unit; } return (unit === 1) ? Math.round(a) : a; } _ptrnd(val) { if (!document.createElementNS) { if (Math.round(val) === val) return val; return this._rnd(val, 1, false, true); } const rnd = this._rnd(val, 0.5, false, true); if (Math.abs(rnd - Math.round(rnd)) !== 0.5) { return rnd > val ? rnd - 0.5 : rnd + 0.5; } return rnd; } _getContrastColor(color) { if (color === undefined) { return undefined; } let rgb = this.draw.hexToRgb(color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)), luminance = (0.299 * rgb[0] + 0.61 * rgb[1] + 0.114 * rgb[2]) / 255; if (luminance > 0.6) { return '#000000'; } else { return '#FFFFFF'; } } }); // SvgRenderer class LW.Utilities.Assign('SvgRenderer', class SvgRenderer extends LW.Utilities.Renderer { constructor(draw) { super(draw); const that = this; that._svgns = 'http://www.w3.org/2000/svg'; that._openGroups = []; that._clipId = 0; } init(host) { const container = document.createElement('div'); container.className = 'drawContainer'; container.onselectstart = function () { return false; } host.appendChild(container); this.host = host; this.container = container; try { const svg = document.createElementNS(this._svgns, 'svg'); svg.setAttribute('version', '1.1'); svg.setAttribute('width', '100%'); svg.setAttribute('height', '100%'); svg.setAttribute('overflow', 'hidden'); container.appendChild(svg); this.canvas = svg; } catch (e) { return false; } this._id = new Date().getTime(); this.clear(); return true; } getType() { return 'SVG'; } refresh() { } getRect() { return { x: 0, y: 0, width: Math.max(this._rup(this.host.offsetWidth) - 1, 0), height: Math.max(this._rup(this.host.offsetHeight) - 1, 0) }; } getContainer() { return this.container; } clear() { while (this.canvas.childNodes.length > 0) { this.removeElement(this.canvas.firstElementChild); } this._defaultParent = undefined; this._defs = document.createElementNS(this._svgns, 'defs'); this._gradients = {}; this.canvas.appendChild(this._defs); } removeElement(element) { if (undefined === element) return; try { while (element.firstChild) { this.removeElement(element.firstChild); } if (element.parentNode) element.parentNode.removeChild(element); else this.canvas.removeChild(element); } catch (error) { // } } beginGroup() { const parent = this._activeParent(); const g = document.createElementNS(this._svgns, 'g'); parent.appendChild(g); this._openGroups.push(g); return g; } endGroup() { if (this._openGroups.length === 0) return; this._openGroups.pop(); } _activeParent() { return this._openGroups.length === 0 ? this.canvas : this._openGroups[this._openGroups.length - 1]; } createClipRect(rect) { const c = document.createElementNS(this._svgns, 'clipPath'); const r = document.createElementNS(this._svgns, 'rect'); this.attr(r, { x: rect.x, y: rect.y, width: rect.width, height: rect.height, fill: 'none' }); this._clipId = this._clipId || 0; c.id = 'cl' + this._id + '_' + (++this._clipId).toString(); c.appendChild(r); this._defs.appendChild(c); return c; } getWindowHref() { // Get modified href. This is needed to handle cases where the page uses <base> tags. let href = window.location.href; if (!href) return href; href = href.replace(/([\('\)])/g, '\\$1'); // escape brackets & quotes (Chrome) href = href.replace(/#.*$/, ''); // remove bookmark links return href; } setClip(elem, clip) { const url = 'url(' + this.getWindowHref() + '#' + clip.id + ')'; return this.attr(elem, { 'clip-path': url }); } addHandler(element, event, fn) { element.addEventListener(event, fn); } removeHandler(/*element, event, fn*/) { //if ($(element).off) // $(element).off(event, fn); //else // $(element).unbind(event, fn); } on(element, event, fn) { this.addHandler(element, event, fn); } off(element, event, fn) { this.removeHandler(element, event, fn); } shape(name, params) { const s = document.createElementNS(this._svgns, name); if (!s) return undefined; for (let param in params) s.setAttribute(param, params[param]); this._activeParent().appendChild(s); return s; } _getTextParts(text, angle, params) { const textPartsInfo = { width: 0, height: 0, parts: [] }; if (undefined === text) return textPartsInfo; const coeff = 0.6; const textParts = text.toString().split('<br>'); const parent = this._activeParent(); const txt = document.createElementNS(this._svgns, 'text'); this.attr(txt, params); for (let i = 0; i < textParts.length; i++) { const textPart = textParts[i]; const txtNode = txt.ownerDocument.createTextNode(textPart); txt.appendChild(txtNode); parent.appendChild(txt); let bbox; try { bbox = txt.getBBox(); } catch (e) { // } const tw = this._rup(bbox.width); const th = this._rup(bbox.height * coeff); txt.removeChild(txtNode); textPartsInfo.width = Math.max(textPartsInfo.width, tw); textPartsInfo.height += th + (i > 0 ? 4 : 0); textPartsInfo.parts.push({ width: tw, height: th, text: textPart }); } parent.removeChild(txt); return textPartsInfo; } _measureText(text, angle, params, includeTextPartsInfo) { return super.measureText(text, angle, params, includeTextPartsInfo); } measureText(text, angle, params) { return this._measureText(text, angle, params, false); } text(text, x, y, width, height, angle, params, clip, halign, valign, rotateAround) { const sz = this._measureText(text, angle, params, true, this); const textPartsInfo = sz.textPartsInfo; const textParts = textPartsInfo.parts; const color = this._getContrastColor(arguments[11]); let gClip; if (!halign) halign = 'center'; if (!valign) valign = 'center'; if (textParts.length > 1 || clip) gClip = this.beginGroup(); if (clip) { const crect = this.createClipRect({ x: this._rup(x) - 1, y: this._rup(y) - 1, width: this._rup(width) + 2, height: this._rup(height) + 2 }); this.setClip(gClip, crect); } //this.rect(x, y, width, height, {fill: 'yellow', stroke: 'red'}); let parent = this._activeParent(); let tw = 0, th = 0; tw = textPartsInfo.width; th = textPartsInfo.height; if (isNaN(width) || width <= 0) width = tw; if (isNaN(height) || height <= 0) height = th; const w = width || 0; const h = height || 0; let yOffset = 0; if (!angle || angle === 0) { y += th; if (valign === 'center' || valign === 'middle') y += (h - th) / 2; else if (valign === 'bottom') y += h - th; if (!width) width = tw; if (!height) height = th; parent = this._activeParent(); let txt; for (let i = textParts.length - 1; i >= 0; i--) { txt = document.createElementNS(this._svgns, 'text'); this.attr(txt, params); this.attr(txt, { cursor: 'default' }); const txtNode = txt.ownerDocument.createTextNode(textParts[i].text); txt.appendChild(txtNode); let xOffset = x; const wPart = textParts[i].width; const hPart = textParts[i].height; if (halign === 'center') xOffset += (w - wPart) / 2; else if (halign === 'right') xOffset += (w - wPart); this.attr(txt, { x: this._rup(xOffset), y: this._rup(y + yOffset), width: this._rup(wPart), height: this._rup(hPart) }); if (color !== undefined) { txt.style.fill = color; } parent.appendChild(txt); yOffset -= textParts[i].height + 4; } if (gClip) { this.endGroup(); return gClip; } return txt; } const point = this.alignTextInRect(x, y, width, height, tw, th, halign, valign, angle, rotateAround); x = point.x; y = point.y; const gTranslate = this.shape('g', { transform: 'translate(' + x + ',' + y + ')' }); const gRotate = this.shape('g', { transform: 'rotate(' + angle + ')' }); gTranslate.appendChild(gRotate); // add the text blocks yOffset = 0; for (let i = textParts.length - 1; i >= 0; i--) { const tx = document.createElementNS(this._svgns, 'text'); this.attr(tx, params); this.attr(tx, { cursor: 'default' }); const txtNode = tx.ownerDocument.createTextNode(textParts[i].text); tx.appendChild(txtNode); let xOffset = 0; const wPart = textParts[i].width; const hPart = textParts[i].height; if (halign === 'center') xOffset += (textPartsInfo.width - wPart) / 2; else if (halign === 'right') xOffset += (textPartsInfo.width - wPart); this.attr(tx, { x: this._rup(xOffset), y: this._rup(yOffset), width: this._rup(wPart), height: this._rup(hPart) }); gRotate.appendChild(tx); yOffset -= hPart + 4; } parent.appendChild(gTranslate); if (gClip) this.endGroup(); return gTranslate; } line(x1, y1, x2, y2, params) { const line = this.shape('line', { x1: x1, y1: y1, x2: x2, y2: y2 }); this.attr(line, params); return line; } path(points, params) { const s = this.shape('path'); s.setAttribute('d', points); if (params) { this.attr(s, params); } return s; } rect(x, y, w, h, params) { x = this._ptrnd(x); y = this._ptrnd(y); w = Math.max(1, this._rnd(w, 1, false)); h = Math.max(1, this._rnd(h, 1, false)); const s = this.shape('rect', { x: x, y: y, width: w, height: h }); if (params) this.attr(s, params); return s; } circle(x, y, r, params) { const s = this.shape('circle', { cx: x, cy: y, r: r }); if (params) this.attr(s, params); return s; } pieslice(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset, params) { const pathCmd = this.pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset); const s = this.shape('path'); s.setAttribute('d', pathCmd); if (params) this.attr(s, params); return s; } attr(element, params) { if (!element || !params) return; for (let param in params) { if (param === 'textContent') element.textContent = params[param]; else { if (param === 'width' || param === 'height') { element.setAttribute(param, Math.max(0, params[param])); } else { element.setAttribute(param, params[param]); } } } } removeAttr(element, params) { if (!element || !params) return; for (let param in params) { if (param === 'textContent') element.textContent = ''; else { element.removeAttribute(params[param]); } } } getAttr(element, key) { return element['getAttribute'](key); } _toLinearGradient(color, isVertical, stops) { const id = 'grd' + this._id + color.replace('#', '') + (isVertical ? 'v' : 'h'); const url = 'url(' + this.getWindowHref() + '#' + id + ')'; if (this._gradients[url]) return url; const gr = document.createElementNS(this._svgns, 'linearGradient'); this.attr(gr, { x1: '0%', y1: '0%', x2: isVertical ? '0%' : '100%', y2: isVertical ? '100%' : '0%', id: id }); for (let i = 0; i < stops.length; i++) { const stop = stops[i]; const s = document.createElementNS(this._svgns, 'stop'); const st = 'stop-color:' + this.adjustColor(color, stop[1]); this.attr(s, { offset: stop[0] + '%', style: st }); gr.appendChild(s); } this._defs.appendChild(gr); this._gradients[url] = true; return url; } _toRadialGradient(color, stops, coords) { const id = 'grd' + this._id + color.replace('#', '') + 'r' + (coords !== undefined ? coords.key : ''); const url = 'url(' + this.getWindowHref() + '#' + id + ')'; if (this._gradients[url]) return url; const gr = document.createElementNS(this._svgns, 'radialGradient'); if (coords === undefined) this.attr(gr, { cx: '50%', cy: '50%', r: '100%', fx: '50%', fy: '50%', id: id }); else this.attr(gr, { cx: coords.x, cy: coords.y, r: coords.outerRadius, id: id, gradientUnits: 'userSpaceOnUse' }); for (let i = 0; i < stops.length; i++) { const stop = stops[i]; const s = document.createElementNS(this._svgns, 'stop'); const st = 'stop-color:' + this.adjustColor(color, stop[1]); this.attr(s, { offset: stop[0] + '%', style: st }); gr.appendChild(s); } this._defs.appendChild(gr); this._gradients[url] = true; return url; } }); // HTML5Renderer class LW.Utilities.Assign('HTML5Renderer', class HTML5Renderer extends LW.Utilities.Renderer { constructor(draw) { super(draw); const that = this; that._renderers = new LW.Utilities.HTML5RenderHelpers(that); } init(host) { try { this.host = host; const chartContainer = document.createElement('div'), canvas = document.createElement('canvas'); chartContainer.className = 'chartContainer'; chartContainer.style.position = 'relative'; chartContainer.onselectstart = function () { return false; } canvas.id = '__lwCanvasWrap'; canvas.style.width = '100%'; canvas.style.height = '100%'; chartContainer.appendChild(canvas); host.appendChild(chartContainer); this.canvas = canvas; canvas.width = host.offsetWidth; canvas.height = host.offsetHeight; this.ctx = canvas.getContext('2d'); this._elements = {}; this._maxId = 0; this._gradientId = 0; this._gradients = {}; this._currentPoint = { x: 0, y: 0 }; this._lastCmd = ''; this._pos = 0; } catch (e) { return false; } return true; } getType() { return 'HTML5'; } getContainer() { let container = this.host.getElementsByClassName('chartContainer')[0]; return container; } getRect() { return { x: 0, y: 0, width: this.canvas.width - 1, height: this.canvas.height - 1 }; } beginGroup() { } endGroup() { } setClip() { } createClipRect() { } addHandler() { // unsupported } removeHandler() { // unsupported } on(element, event, fn) { this.addHandler(element, event, fn); } off(element, event, fn) { this.removeHandler(element, event, fn); } clear() { this._elements = {}; this._maxId = 0; this._renderers._gradients = {}; this._gradientId = 0; } removeElement(element) { if (undefined === element) return; if (this._elements[element.id]) delete this._elements[element.id]; } shape(name, params) { let s = { type: name, id: this._maxId++ }; for (let param in params) s[param] = params[param]; this._elements[s.id] = s; return s; } attr(element, params) { for (let param in params) element[param] = params[param]; } removeAttr(element, params) { for (let param in params) { delete element[params[param]]; } } rect(x, y, w, h, params) { if (isNaN(x)) throw 'Invalid value for "x"'; if (isNaN(y)) throw 'Invalid value for "y"'; if (isNaN(w)) throw 'Invalid value for "width"'; if (isNaN(h)) throw 'Invalid value for "height"'; let s = this.shape('rect', { x: x, y: y, width: w, height: h }); if (params) this.attr(s, params); return s; } path(pathCmd, params) { let s = this.shape('path', params); this.attr(s, { d: pathCmd }); return s; } line(x1, y1, x2, y2, params) { return this.path('M ' + x1 + ',' + y1 + ' L ' + x2 + ',' + y2, params); } circle(x, y, r, params) { let s = this.shape('circle', { x: x, y: y, r: r }); if (params) this.attr(s, params); return s; } pieslice(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset, params) { let element = this.path(this.pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset), params); this.attr(element, { x: x, y: y, innerRadius: innerRadius, outerRadius: outerRadius, angleFrom: angleFrom, angleTo: angleTo }); return element; } _getCSSStyle(name) { const measureElement = document.createElement('div'); measureElement.className = name; measureElement.style.position = 'absolute'; measureElement.style.visibility = 'hidden'; this.host.appendChild(measureElement); let style = window.getComputedStyle(measureElement); style = { color: style.color, fontFamily: style.fontFamily, fontSize: style.fontSize, fontWeight: style.fontWeight }; this.host.removeChild(measureElement); return style; } _getTextParts(text, angle, params) { let fontFamily = 'Arial'; let fontSize = '10pt'; let fontWeight = ''; if (params && params['class']) { let style = this._getCSSStyle(params['class']); if (style['fontSize']) fontSize = style['fontSize']; if (style['fontFamily']) fontFamily = style['fontFamily']; if (style['fontWeight']) fontWeight = style['fontWeight']; } this.ctx.font = fontWeight + ' ' + fontSize + ' ' + fontFamily; let textPartsInfo = { width: 0, height: 0, parts: [] }; let coeff = 0.6; let textParts = text.toString().split('<br>'); for (let i = 0; i < textParts.length; i++) { let textPart = textParts[i]; let tw = this.ctx.measureText(textPart).width; let span = document.createElement('span'); span.className = 'chart'; span.font = this.ctx.font; span.textContent = textPart; this.host.appendChild(span); let th = span.offsetHeight * coeff; this.host.removeChild(span); textPartsInfo.width = Math.max(textPartsInfo.width, this._rup(tw)); textPartsInfo.height += th + (i > 0 ? 4 : 0); textPartsInfo.parts.push({ width: tw, height: th, text: textPart }); } return textPartsInfo; } _measureText(text, angle, params, includeTextPartsInfo) { return super.measureText(text, angle, params, includeTextPartsInfo); } measureText(text, angle, params) { return this._measureText(text, angle, params, false); } text(text, x, y, width, height, angle, params, clip, halign, valign, rotateAround) { let t = this.shape('text', { text: text, x: x, y: y, width: width, height: height, angle: angle, clip: clip, halign: halign, valign: valign, rotateAround: rotateAround }); if (params) this.attr(t, params); t.fontFamily = 'Arial'; t.fontSize = '10pt'; t.fontWeight = ''; t.color = this._getContrastColor(arguments[11]); if (params && params['class']) { let style = this._getCSSStyle(params['class']); t.fontFamily = style.fontFamily || t.fontFamily; t.fontSize = style.fontSize || t.fontSize; t.fontWeight = style['fontWeight'] || t.fontWeight; t.color = t.color || style.color; } t.color = t.color || '#000000'; let sz = this._measureText(text, 0, params, true); this.attr(t, { textPartsInfo: sz.textPartsInfo, textWidth: sz.width, textHeight: sz.height }); if (width <= 0 || isNaN(width)) this.attr(t, { width: sz.width }); if (height <= 0 || isNaN(height)) this.attr(t, { height: sz.height }); return t; } _toLinearGradient(color, isVertical, stops) { if (this._renderers._gradients[color]) return color; let colorStops = []; for (let i = 0; i < stops.length; i++) colorStops.push({ percent: stops[i][0] / 100, color: this.adjustColor(color, stops[i][1]) }); let name = 'gr' + this._gradientId++; this.createGradient(name, isVertical ? 'vertical' : 'horizontal', colorStops); return name; } _toRadialGradient(color, stops) { if (this._renderers._gradients[color]) return color; let colorStops = []; for (let i = 0; i < stops.length; i++) colorStops.push({ percent: stops[i][0] / 100, color: this.adjustColor(color, stops[i][1]) }); let name = 'gr' + this._gradientId++; this.createGradient(name, 'radial', colorStops); return name; } createGradient(name, orientation, colorStops) { this._renderers.createGradient(this, name, orientation, colorStops); } refresh() { this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); for (let element in this._elements) { let params = this._elements[element]; this._renderers.setFillStyle(this, params); this._renderers.setStroke(this, params); this._renderers[this._elements[element].type](this.ctx, params); } } }); // HTML5RenderHelpers class LW.Utilities.Assign('HTML5RenderHelpers', class HTML5RenderHelpers { constructor(HTML5Renderer) { this.HTML5Renderer = HTML5Renderer; this._cmds = 'mlcazq'; } ptrnd(val) { if (Math.abs(Math.round(val) - val) === 0.5) return val; let rnd = Math.round(val); if (rnd < val) rnd = rnd - 1; return rnd + 0.5; } createGradient(context, name, orientation, colorStops) { context._gradients[name] = { orientation: orientation, colorStops: colorStops }; } setStroke(context, params) { let ctx = context.ctx, strokeWidth = params['stroke-width']; ctx.strokeStyle = params['stroke'] || 'transparent'; if (strokeWidth === 0) { ctx.lineWidth = 0.01; } else if (strokeWidth !== undefined) { ctx.lineWidth = strokeWidth; } else { ctx.lineWidth = 1; } if (params['fill-opacity'] !== undefined) { ctx.globalAlpha = params['fill-opacity']; } else if (params['opacity'] !== undefined) { ctx.globalAlpha = params['opacity']; } else { ctx.globalAlpha = 1; } if (ctx.setLineDash) { if (params['stroke-dasharray']) ctx.setLineDash(params['stroke-dasharray'].split(',')); else ctx.setLineDash([]); } } setFillStyle(context, params) { let ctx = context.ctx; ctx.fillStyle = 'transparent'; if (params['fill-opacity'] !== undefined) { ctx.globalAlpha = params['fill-opacity']; } else if (params['opacity'] !== undefined) { ctx.globalAlpha = params['opacity']; } else { ctx.globalAlpha = 1; } if (params.fill && params.fill.indexOf('#') === -1 && context._gradients[params.fill]) { let isVertical = context._gradients[params.fill].orientation !== 'horizontal'; let isRadial = context._gradients[params.fill].orientation === 'radial'; let x1 = this.ptrnd(params.x); let y1 = this.ptrnd(params.y); let x2 = this.ptrnd(params.x + (isVertical ? 0 : params.width)); let y2 = this.ptrnd(params.y + (isVertical ? params.height : 0)); let gradient; if ((params.type === 'circle' || params.type === 'path' || params.type === 'rect') && isRadial) { let x = this.ptrnd(params.x), y = this.ptrnd(params.y); const r1 = params.innerRadius || 0, r2 = params.outerRadius || params.r || 0; if (params.type === 'rect') { x += params.width / 2; y += params.height / 2; } gradient = ctx.createRadialGradient(x, y, r1, x, y, r2); } if (!isRadial) { if (isNaN(x1) || isNaN(x2) || isNaN(y1) || isNaN(y2)) { x1 = 0; y1 = 0; x2 = isVertical ? 0 : ctx.canvas.width; y2 = isVertical ? ctx.canvas.height : 0; } gradient = ctx.createLinearGradient(x1, y1, x2, y2); } let colorStops = context._gradients[params.fill].colorStops; for (let i = 0; i < colorStops.length; i++) gradient.addColorStop(colorStops[i].percent, colorStops[i].color); ctx.fillStyle = gradient; } else if (params.fill) { ctx.fillStyle = params.fill; } } rect(ctx, params) { if (params.width === 0 || params.height === 0) return; ctx.fillRect(this.ptrnd(params.x), this.ptrnd(params.y), params.width, params.height); ctx.strokeRect(this.ptrnd(params.x), this.ptrnd(params.y), params.width, params.height); } circle(ctx, params) { if (params.r === 0) return; ctx.beginPath(); ctx.arc(this.ptrnd(params.x), this.ptrnd(params.y), params.r, 0, Math.PI * 2, false); ctx.closePath(); ctx.fill(); ctx.stroke(); } _parsePoint(str) { let x = this._parseNumber(str); let y = this._parseNumber(str); return ({ x: x, y: y }); } _parseNumber(str) { let numStarted = false, i; for (i = this._pos; i < str.length; i++) { if ((str[i] >= '0' && str[i] <= '9') || str[i] === '.' || str[i] === 'e' || (str[i] === '-' && !numStarted) || (str[i] === '-' && i >= 1 && str[i - 1] === 'e')) { numStarted = true; continue; } if (!numStarted && (str[i] === ' ' || str[i] === ',')) { this._pos++; continue; } break; } let val = parseFloat(str.substring(this._pos, i)); if (isNaN(val)) return undefined; this._pos = i; return val; } _isRelativeCmd(cmd) { return this._cmds.indexOf(cmd) !== -1; } _parseCmd(string) { for (let i = this._pos; i < string.length; i++) { if (this._cmds.toLowerCase().indexOf(string[i].toLowerCase()) !== -1) { this._pos = i + 1; this._lastCmd = string[i]; return this._lastCmd; } if (string[i] === ' ') { this._pos++; continue; } if (string[i] >= '0' && string[i] <= '9') { this._pos = i; if (this._lastCmd === '') break; else return this._lastCmd; } } return undefined; } _toAbsolutePoint(point) { return { x: this._currentPoint.x + point.x, y: this._currentPoint.y + point.y }; } path(ctx, params) { let path = params.d; this._pos = 0; this._lastCmd = ''; let firstPoint = undefined; this._currentPoint = { x: 0, y: 0 }; ctx.beginPath(); while (this._pos < path.length) { let cmd = this._parseCmd(path); if (cmd === undefined) break; if (cmd === 'M' || cmd === 'm') { let point = this._parsePoint(path); if (point === undefined) break; ctx.moveTo(point.x, point.y); this._currentPoint = point; if (firstPoint === undefined) firstPoint = point; continue; } if (cmd === 'L' || cmd === 'l') { let point = this._parsePoint(path); if (point === undefined) break; ctx.lineTo(point.x, point.y); this._currentPoint = point; continue; } if (cmd === 'A' || cmd === 'a') { let rx = this._parseNumber(path); let ry = this._parseNumber(path); let angle = this._parseNumber(path) * (Math.PI / 180.0); let largeFlag = this._parseNumber(path); let sweepFlag = this._parseNumber(path); let endPoint = this._parsePoint(path); if (this._isRelativeCmd(cmd)) { endPoint = this._toAbsolutePoint(endPoint); } if (rx === 0 || ry === 0) continue; let cp = this._currentPoint; /// START // x1', y1' let cp2 = { x: Math.cos(angle) * (cp.x - endPoint.x) / 2.0 + Math.sin(angle) * (cp.y - endPoint.y) / 2.0, y: -Math.sin(angle) * (cp.x - endPoint.x) / 2.0 + Math.cos(angle) * (cp.y - endPoint.y) / 2.0 }; // adjust radii let adj = Math.pow(cp2.x, 2) / Math.pow(rx, 2) + Math.pow(cp2.y, 2) / Math.pow(ry, 2); if (adj > 1) { rx *= Math.sqrt(adj); ry *= Math.sqrt(adj); } // cx', cy' let s = (largeFlag === sweepFlag ? -1 : 1) * Math.sqrt( ((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(cp2.y, 2)) - (Math.pow(ry, 2) * Math.pow(cp2.x, 2))) / (Math.pow(rx, 2) * Math.pow(cp2.y, 2) + Math.pow(ry, 2) * Math.pow(cp2.x, 2)) ); if (isNaN(s)) s = 0; let cp3 = { x: s * rx * cp2.y / ry, y: s * -ry * cp2.x / rx }; // cx, cy let centerPoint = { x: (cp.x + endPoint.x) / 2.0 + Math.cos(angle) * cp3.x - Math.sin(angle) * cp3.y, y: (cp.y + endPoint.y) / 2.0 + Math.sin(angle) * cp3.x + Math.cos(angle) * cp3.y }; // vector magnitude let m = function (v) { return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)); } // ratio between two vectors let r = function (u, v) { return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v)); } // angle between two vectors let a = function (u, v) { return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v)); } // initial angle let startAngle = a([1, 0], [(cp2.x - cp3.x) / rx, (cp2.y - cp3.y) / ry]); // angle delta let u = [(cp2.x - cp3.x) / rx, (cp2.y - cp3.y) / ry]; let v = [(-cp2.x - cp3.x) / rx, (-cp2.y - cp3.y) / ry]; let deltaAngle = a(u, v); if (r(u, v) <= -1) deltaAngle = Math.PI; if (r(u, v) >= 1) deltaAngle = 0; if (sweepFlag === 0 && deltaAngle > 0) deltaAngle = deltaAngle - 2 * Math.PI; if (sweepFlag === 1 && deltaAngle < 0) deltaAngle = deltaAngle + 2 * Math.PI; let r1 = (rx > ry) ? rx : ry; let sx = (rx > ry) ? 1 : rx / ry; let sy = (rx > ry) ? ry / rx : 1; ctx.translate(centerPoint.x, centerPoint.y); ctx.rotate(angle); ctx.scale(sx, sy); ctx.arc(0, 0, r1, startAngle, startAngle + deltaAngle, 1 - sweepFlag); ctx.scale(1 / sx, 1 / sy); ctx.rotate(-angle); ctx.translate(-centerPoint.x, -centerPoint.y); continue; } if ((cmd === 'Z' || cmd === 'z') && firstPoint !== undefined) { ctx.lineTo(firstPoint.x, firstPoint.y); this._currentPoint = firstPoint; continue; } if (cmd === 'C' || cmd === 'c') { let p1 = this._parsePoint(path); let p2 = this._parsePoint(path); let p3 = this._parsePoint(path); ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y); this._currentPoint = p3; continue; } if (cmd === 'Q' || cmd === 'q') { let p1 = this._parsePoint(path); let p2 = this._parsePoint(path); ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y); this._currentPoint = p2; continue; } } ctx.fill(); ctx.stroke(); ctx.closePath(); } text(ctx, params) { let x = this.ptrnd(params.x); let y = this.ptrnd(params.y); let width = this.ptrnd(params.width); let height = this.ptrnd(params.height); let halign = params.halign; let valign = params.valign; let angle = params.angle; let rotateAround = params.rotateAround; let textPartsInfo = params.textPartsInfo; let textParts = textPartsInfo.parts; let clip = params.clip; if (clip === undefined) clip = true; ctx.save(); if (!halign) halign = 'center'; if (!valign) valign = 'center'; if (clip) { ctx.rect(x, y, width, height); ctx.clip(); } let tw = params.textWidth; let th = params.textHeight; let w = width || 0; let h = height || 0; ctx.fillStyle = params.color; ctx.font = params.fontWeight + ' ' + params.fontSize + ' ' + params.fontFamily; if (!angle || angle === 0) { y += th; if (valign === 'center' || valign === 'middle') y += (h - th) / 2; else if (valign === 'bottom') y += h - th; if (!width) width = tw; if (!height) height = th; let yOffset = 0; for (let i = textParts.length - 1; i >= 0; i--) { let textPart = textParts[i]; let xOffset = x; let wPart = textParts[i].width; if (halign === 'center') xOffset += (w - wPart) / 2; else if (halign === 'right') xOffset += (w - wPart); ctx.fillText(textPart.text, xOffset, y + yOffset); yOffset -= textPart.height + (i > 0 ? 4 : 0); } ctx.restore(); return; } let point = this.HTML5Renderer.alignTextInRect(x, y, width, height, tw, th, halign, valign, angle, rotateAround); x = point.x; y = point.y; let rads = angle * Math.PI * 2 / 360; ctx.translate(x, y); ctx.rotate(rads); let yOffset = 0; let maxW = textPartsInfo.width; for (let i = textParts.length - 1; i >= 0; i--) { let xOffset = 0; if (halign === 'center') xOffset += (maxW - textParts[i].width) / 2; else if (halign === 'right') xOffset += (maxW - textParts[i].width); ctx.fillText(textParts[i].text, xOffset, yOffset); yOffset -= textParts[i].height + 4; } ctx.restore(); } }); // Plot class LW.Utilities.Assign('Plot', class Plot { constructor(renderer) { this.renderer = renderer; } get(array, index, key) { return key !== undefined ? array[index][key] : array[index]; } min(array, key) { let min = NaN; for (let i = 0; i < array.length; i++) { let val = this.get(array, i, key); if (isNaN(min) || val < min) min = val; } return min; } max(array, key) { let max = NaN; for (let i = 0; i < array.length; i++) { let val = this.get(array, i, key); if (isNaN(max) || val > max) max = val; } return max; } sum(array, key) { let sum = 0; for (let i = 0; i < array.length; i++) { let val = this.get(array, i, key); if (!isNaN(val)) sum += val; } return sum; } count(array, key) { let count = 0; for (let i = 0; i < array.length; i++) { let val = this.get(array, i, key); if (!isNaN(val)) count++; } return count; } avg(array, key) { return this.sum(array, key) / Math.max(1, this.count(array, key)); } filter(array, fn) { if (!fn) return array; let out = []; for (let i = 0; i < array.length; i++) if (fn(array[i])) out.push(array[i]); return out; } scale(val, range, scale_range, params) { if (isNaN(val)) return NaN; if (val < Math.min(range.min, range.max) || val > Math.max(range.min, range.max)) { if (!params || params['ignore_range'] !== true) return NaN; } let outVal = NaN; let percent = 1; if (range.type === undefined || range.type !== 'logarithmic') { let denom = Math.abs(range.max - range.min); if (!denom) denom = 1; percent = Math.abs(val - Math.min(range.min, range.max)) / denom; } else if (range.type === 'logarithmic') { let logBase = range.base; if (isNaN(logBase)) logBase = 10; let min = Math.min(range.min, range.max); if (min <= 0) min = 1; let max = Math.max(range.min, range.max); if (max <= 0) max = 1; let maxPow = Math.log(max) / Math.log(logBase); max = Math.pow(logBase, maxPow); let minPow = Math.log(min) / Math.log(logBase); min = Math.pow(logBase, minPow); let valPow = Math.log(val) / Math.log(logBase); percent = Math.abs(valPow - minPow) / (maxPow - minPow); } if (scale_range.type === 'logarithmic') { let logBase = scale_range.base; if (isNaN(logBase)) logBase = 10; let maxPow = Math.log(scale_range.max) / Math.log(logBase); let minPow = Math.log(scale_range.min) / Math.log(logBase); if (scale_range.flip) percent = 1 - percent; let valPow = Math.min(minPow, maxPow) + percent * Math.abs(maxPow - minPow); outVal = Math.pow(logBase, valPow); } else { outVal = Math.min(scale_range.min, scale_range.max) + percent * Math.abs(scale_range.max - scale_range.min); if (scale_range.flip) outVal = Math.max(scale_range.min, scale_range.max) - outVal + scale_range.min; } return outVal; } axis(min, max, preferedCount) { if (preferedCount <= 1) return [max, min]; //let minSave = min; //let maxSave = max; if (isNaN(preferedCount) || preferedCount < 2) preferedCount = 2; let decimalPlaces = 0; while (Math.round(min) !== min && Math.round(max) !== max && decimalPlaces < 10) { min *= 10; max *= 10; decimalPlaces++; } let preferedIntSize = (max - min) / preferedCount; while (decimalPlaces < 10 && Math.round(preferedIntSize) !== preferedIntSize) { min *= 10; max *= 10; preferedIntSize *= 10; decimalPlaces++; } let scale = [1, 2, 5]; //let itemsCount = 0; let i = 0; let intSizeNext; // eslint-disable-next-line while (true) { let idx = i % scale.length; let pow = Math.floor(i / scale.length); let intSizeCurr = Math.pow(10, pow) * scale[idx]; idx = (i + 1) % scale.length; pow = Math.floor((i + 1) / scale.length); intSizeNext = Math.pow(10, pow) * scale[idx]; if (preferedIntSize >= intSizeCurr && preferedIntSize < intSizeNext) break; i++; } let intSizeSelected = intSizeNext; let out = []; let curr = this.renderer._rnd(min, intSizeSelected, false); let denominator = decimalPlaces <= 0 ? 1 : Math.pow(10, decimalPlaces); while (curr < max + intSizeSelected) { out.push(curr / denominator); curr += intSizeSelected; } return out; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('DataExporter', class DataExporter { constructor(exportDetails, groupBy, filterBy, conditionalFormatting) { const that = this; if (!exportDetails) { exportDetails = {}; } /* * "style" object definition (all properties are optional): * * any valid CSS property - applied to whole table * header (Object) * any valid CSS property - applied to header cells * any column name (Object) * any valid CSS property - applied to particular column header cell * columns (Object) * any valid CSS property - applied to column cells * any column name (Object) * any valid CSS property - applied to the cells of particular column * format - applicable to numeric and date columns * n (Object), where n is a row index (related to use of "ConditionalFormatting" object) * background * border * color * rows (Object) * any valid CSS property - applied to rows * alternationCount * alternationStart * alternationEnd * alternationIndexnColor, where n is an integer * alternationIndexnBorderColor, where n is an integer * alternationIndexnBackgroundColor, where n is an integer * n (Object), where n is a row index * any valid CSS property - applied to particular row */ that.style = exportDetails.style; that.header = exportDetails.header; that.exportHeader = exportDetails.exportHeader !== undefined ? exportDetails.exportHeader : true; that.hierarchical = exportDetails.hierarchical; that.expandChar = exportDetails.expandChar || '+'; that.collapseChar = exportDetails.collapseChar || '-'; that.pageOrientation = exportDetails.pageOrientation; that.allowNull = exportDetails.allowNull || false; if (!that.hierarchical && groupBy && groupBy.length > 0) { that.groupBy = groupBy; } else { that.mergedCells = exportDetails.mergedCells; } if (!that.groupBy && filterBy && Object.keys(filterBy).length > 0) { that.filterBy = filterBy; } if (conditionalFormatting) { that.conditionalFormatting = conditionalFormatting; } that.timeBetween1900And1970 = new Date(1970, 0, 1).getTime() - new Date(1900, 0, 1).getTime(); } /** * Generates and downloads a file. */ downloadFile(data, type, fileName) { let file; if (!fileName) { return data; } if (data instanceof Blob) { file = data; } else { file = new Blob([data], { type: type }); } if (window.navigator.msSaveOrOpenBlob) { // Edge window.navigator.msSaveOrOpenBlob(file, fileName); } else { // Chrome, Firefox, Safari const a = document.createElement('a'), url = URL.createObjectURL(file); a.href = url; a.download = fileName; a.style.position = 'absolute'; a.style.visibility = 'hidden'; document.body.appendChild(a); a.click(); setTimeout(function () { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100); } } /** * Exports data. */ exportData(data, format, fileName, callback) { const that = this; that.actualHierarchy = that.hierarchical; format = format.toLowerCase(); if (that.exportHeader) { if (that.header) { data = data.slice(0); if (data.length === 0) { that.actualHierarchy = false; } that.processComplexHeader(that.header, data, format); } else if (data.length === 1) { that.actualHierarchy = false; } } if (data.length === 0) { // eslint-disable-next-line console.warn('No data to export.'); return; } if (format === 'xlsx') { that.xlsxStartIndex = that.complexHeader ? that.complexHeader.length : +that.exportHeader; } if (that.actualHierarchy) { data = that.processHierarchicalData(data, format); } that.getDatafields(data); if (fileName && fileName.slice(fileName.length - format.length - 1, fileName.length) !== '.' + format) { fileName += '.' + format; } let output = null; switch (format) { case 'csv': output = that.exportToCSVAndTSV(data, { delimiter: ', ', MIME: 'text/csv', toRemove: 2 }, fileName); break; case 'html': output = that.exportToHTML(data, fileName); break; case 'jpeg': case 'png': that.exportToImage(data, fileName, format, callback); break; case 'json': output = that.exportToJSON(data, fileName); break; case 'pdf': output = that.exportToPDF(data, fileName); break; case 'tsv': output = that.exportToCSVAndTSV(data, { delimiter: '\t', MIME: 'text/tab-separated-values', toRemove: 1 }, fileName); break; case 'xlsx': output = that.exportToXLSX(data, fileName); break; case 'xml': output = that.exportToXML(data, fileName); break; } if (callback && output) { callback(output); } delete that.complexHeader; return output; } /** * Exports to CSV and TSV. */ exportToCSVAndTSV(data, formatOptions, fileName) { const that = this, datafields = that.datafields; let stringResult = ''; for (let i = 0; i < data.length; i++) { const currentRecord = data[i]; let stringifiedCurrentRecord = ''; for (let j = 0; j < datafields.length; j++) { if (that.actualHierarchy && j === 0) { stringifiedCurrentRecord += ('""' + formatOptions.delimiter).repeat(currentRecord._level - 1) + '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter + ('""' + formatOptions.delimiter).repeat(that.maxLevel - currentRecord._level); continue; } stringifiedCurrentRecord += '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter; } stringifiedCurrentRecord = stringifiedCurrentRecord.slice(0, stringifiedCurrentRecord.length - formatOptions.toRemove) + '\n'; stringResult += stringifiedCurrentRecord; } return this.downloadFile(stringResult, formatOptions.MIME, fileName); } /** * Exports to HTML. */ exportToHTML(data, fileName) { const that = this, datafields = that.datafields, style = that.style; let header = '', startIndex = 0, html2canvas = ''; data = that.processGroupingInformation(data); that.data = data; if (that.exportHeader) { header = that.getHTMLHeader(datafields, data); startIndex = 1; } if (arguments[2]) { const scripts = Array.from(document.getElementsByTagName('script')), html2canvasScript = scripts.find(script => script.src.indexOf('html2canvas') !== -1); html2canvas = `<script type="text/javascript" src="${html2canvasScript.src}"></script>`; } let htmlContent = `<!DOCTYPE html> <html> <head> <meta charset="UTF-8"> <style type="text/css"> ${that.getRowStyle()}${that.getColumnStyle()} </style>${html2canvas}${that.toggleableFunctionality()} </head> <body> <table${that.getTableStyle()}>${header} <tbody>\n`; const mergedMainCells = {}, mergedSecondaryCells = {}, groupsHandled = []; that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells); mainLoop: for (let i = startIndex; i < data.length; i++) { const currentRecord = data[i], row = i - startIndex; let n = that.getAlternationIndex(row, ' rowN'), toCollapse = '', level = '', groupId = '', outlineLevel = 0; if (that.actualHierarchy) { if (currentRecord._collapsed) { toCollapse = ' collapsed'; } level = ` level="${currentRecord._level}"`; } else if (that.groupBy) { for (let k = 0; k < that.groupBy.length; k++) { const datafield = that.groupBy[k], currentGroup = currentRecord[datafield], currentGroupLabel = that.groups[datafield][currentGroup]; groupId += currentGroup; if (groupsHandled.indexOf(groupId) === -1) { htmlContent += ` <tr class="row"> <td class="column group" style="padding-left: ${outlineLevel * 25}px;" colspan="${that.datafields.length}">${currentGroupLabel}</td> </tr>`; groupsHandled.push(groupId); i--; continue mainLoop; } outlineLevel++; } } let currentContent = ` <tr class="row row${row}${n}${toCollapse}"${level}`; if (!fileName) { currentContent += ' style="page-break-inside: avoid;"' } currentContent += '>\n'; for (let j = 0; j < datafields.length; j++) { const cellCode = j + ',' + (row); let colspan = 1, rowspan = 1; if (mergedMainCells[cellCode]) { colspan = mergedMainCells[cellCode].colspan; rowspan = mergedMainCells[cellCode].rowspan; } else if (mergedSecondaryCells[cellCode]) { continue; } const datafield = datafields[j]; let value = currentRecord[datafield], indent = ''; if (that.actualHierarchy && j === 0) { let sign = ''; if (currentRecord._expanded) { sign = that.collapseChar; } else if (currentRecord._expanded === false) { sign = that.expandChar; } indent = `<div class="toggle-element" style="margin-left: ${25 * (currentRecord._level - 1) + 5}px;" expanded>${sign}</div>`; } value = that.getFormattedValue(value, datafield); let css = ''; if (style && style.columns && style.columns[datafield] && style.columns[datafield][row]) { const uniqueStyle = style.columns[datafield][row]; css += `border-color: ${uniqueStyle.border}; background-color: ${uniqueStyle.background}; color: ${uniqueStyle.color};"`; } if (j === 0 && outlineLevel > 1) { css += `padding-left: ${(outlineLevel - 1) * 25}px;"`; } if (css) { css = ` style="${css}"`; } currentContent += ` <td class="column column${datafield}"${css} colspan="${colspan}" rowspan="${rowspan}">${indent + value}</td>\n`; } htmlContent += currentContent + ' </tr>\n'; } htmlContent += ` </tbody> </table> </body> </html>`; if (arguments[2]) { return htmlContent; } return this.downloadFile(htmlContent, 'text/html', fileName); } /** * Exports to an image (PNG/JPEG). */ exportToImage(data, fileName, fileExtension, callback) { const that = this; try { html2canvas; } catch (error) { throw new Error('lw-grid: Missing reference to \'html2canvas.min.js\'.'); } let imageData = null; const htmlContent = that.exportToHTML(data, fileName, true), iframe = document.createElement('iframe'); iframe.style.position = 'absolute'; iframe.style.top = 0; iframe.style.left = 0; iframe.style.border = 'none'; iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.opacity = 0; iframe.style.pointerEvents = 'none'; document.body.appendChild(iframe); iframe.contentDocument.write(htmlContent); function checkIframePopulated() { if (!iframe.contentDocument.body || !iframe.contentDocument.body.firstElementChild) { requestAnimationFrame(checkIframePopulated); } else { iframe.contentWindow.html2canvas(iframe.contentDocument.body.firstElementChild).then(canvas => { const draw = new LW.Utilities.Draw(document.createElement('div')); imageData = canvas.toDataURL('image/png'); if (callback) { callback(imageData); } else { document.body.appendChild(canvas); draw.exportImage(undefined, canvas, fileExtension, fileName); } iframe.remove(); canvas.remove(); }); } } checkIframePopulated(); return imageData; } /** * Gets merged cells information (for use in HTML and PDF export). */ getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping) { const that = this; if (!that.mergedCells) { return; } const multipleTables = mapping && mapping[that.datafields.length - 1] !== 0; that.mergedCellsPDF = that.mergedCells.slice(0); for (let i = 0; i < that.mergedCellsPDF.length; i++) { const cellDefinition = that.mergedCellsPDF[i]; let colspan = cellDefinition.colspan, rowspan = cellDefinition.rowspan; if (rowspan < 2 && colspan < 2) { continue; } const row = cellDefinition.cell[1]; let col = cellDefinition.cell[0]; if (multipleTables && colspan > 1) { const startTable = mapping[col], endTable = mapping[col + colspan - 1], splitCells = []; if (endTable > startTable) { let currentTable = startTable, currentColumn = col, overal = 0; mainLoop: for (let i = startTable; i <= endTable; i++) { let start = currentColumn, span = 0; while (mapping[currentColumn] === currentTable) { currentColumn++; overal++; span++; if (overal === colspan) { splitCells.push({ start: start, span: span }); break mainLoop; } } splitCells.push({ start: start, span: span }); currentTable = mapping[currentColumn]; } colspan = splitCells[0].span; for (let i = 1; i < splitCells.length; i++) { that.mergedCellsPDF.push({ cell: [splitCells[i].start, row], colspan: splitCells[i].span, rowspan: rowspan, originalCell: col }); } } } for (let j = col; j < col + colspan; j++) { for (let k = row; k < row + rowspan; k++) { const code = j + ',' + k; if (j === col && k === row) { mergedMainCells[code] = { colspan: colspan, rowspan: rowspan, originalCell: cellDefinition.originalCell }; continue; } mergedSecondaryCells[code] = true; } } } } /** * Gets alternation index. */ getAlternationIndex(row, prefix) { const that = this; if (!that.style) { return ''; } const rowsDefinition = that.style.rows, alternationCount = rowsDefinition && rowsDefinition.alternationCount; if (alternationCount && (((rowsDefinition.alternationStart === undefined || row >= rowsDefinition.alternationStart) && (rowsDefinition.alternationEnd === undefined || row <= rowsDefinition.alternationEnd)) || rowsDefinition.alternationStart === rowsDefinition.alternationEnd)) { return prefix + (row % rowsDefinition.alternationCount); } return ''; } /** * Gets formatted numeric or date value (for use in HTML and PDF export). */ getFormattedValue(value, datafield) { const that = this, style = that.style; if (value === null) { return that.allowNull ? 'null' : ''; } if (datafield && style && style.columns && style.columns[datafield] && style.columns[datafield].format) { if (typeof value === 'number') { return that.formatNumber(value, style.columns[datafield].format); } else if (value instanceof Date) { return that.formatDate(value, style.columns[datafield].format); } } else if (value instanceof Date) { return that.formatDate(value, 'd'); } return value; } /** * Exports to JSON. */ exportToJSON(data, fileName) { return this.downloadFile(JSON.stringify(data, this.datafields.concat('rows')), 'application/json', fileName); } /** * Exports to PDF. */ exportToPDF(data, fileName) { try { pdfMake; } catch (error) { throw new Error('Missing reference to \'pdfmake.min.js\'.'); } const that = this, datafields = that.datafields, startIndex = +that.exportHeader, groupsHandled = [], mergedMainCells = {}, mergedSecondaryCells = {}, mapping = {}, headerRows = startIndex ? that.complexHeader ? that.complexHeader.length : 1 : 0, docDefinition = { pageOrientation: that.pageOrientation || 'portrait' }; let header = [], content = [], tables; function createTableRow() { let tableRow = []; for (let i = 0; i < tables.length; i++) { tableRow.push([]); } return tableRow; } data = that.processGroupingInformation(data); that.data = data; that.headerRows = headerRows; that.getPDFStyle(); const styleInfo = that.styleInfo; tables = styleInfo ? that.wrapPDFColumns(docDefinition, mapping) : [{ body: header, datafields: datafields }]; if (startIndex) { header = that.getPDFHeader(datafields, tables, mapping); } that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping); mainLoop: for (let i = startIndex; i < data.length; i++) { const currentRecord = data[i]; let groupId = '', outlineLevel = 0; if (that.groupBy) { for (let k = 0; k < that.groupBy.length; k++) { const datafield = that.groupBy[k], currentGroup = currentRecord[datafield], currentGroupLabel = that.groups[datafield][currentGroup]; groupId += currentGroup; if (groupsHandled.indexOf(groupId) === -1) { that.createGroupHeaderRow(tables, { text: currentGroupLabel, style: ['row', 'cell', 'group'], marginLeft: outlineLevel * 7.5 }); groupsHandled.push(groupId); i--; continue mainLoop; } outlineLevel++; } } const tableRow = createTableRow(), row = i - startIndex; let n = that.getAlternationIndex(row, ''); for (let j = 0; j < datafields.length; j++) { const datafield = datafields[j], entry = { style: ['row', 'row' + row, 'cell', 'cell' + datafield] }, tableIndex = mapping[j] || 0; if (n !== undefined) { entry.style.splice(1, 0, 'rowN' + n); } if (that.mergedCellsPDF) { const cellCode = j + ',' + row, mergeInfo = mergedMainCells[cellCode]; if (mergeInfo) { entry.colSpan = mergeInfo.colspan; entry.rowSpan = mergeInfo.rowspan; if (mergeInfo.originalCell !== undefined) { entry.text = ''; entry.style[entry.style.length - 1] = 'cell' + datafields[mergeInfo.originalCell]; tableRow[tableIndex].push(entry); continue; } } else if (mergedSecondaryCells[cellCode]) { tableRow[tableIndex].push({}); continue; } } const value = that.getFormattedValue(currentRecord[datafield], datafield); entry.text = value.toString(); that.getUniqueStylePDF(entry, datafield, row); that.setIndentation(entry, { j: j, currentRecord: currentRecord, value: value, outlineLevel: outlineLevel }); tableRow[tableIndex].push(entry); } for (let k = 0; k < tables.length; k++) { tables[k].body.push(tableRow[k]); } } if (styleInfo) { for (let i = 0; i < tables.length; i++) { const body = tables[i].body; for (let j = headerRows - 1; j >= 0; j--) { body.unshift(header[i][j]); } content.push({ table: { headerRows: headerRows, widths: tables[i].widths, heights: function (row) { if (styleInfo.heights[row]) { return styleInfo.heights[row]; } if (styleInfo.defaultHeight) { return styleInfo.defaultHeight; } }, body: body }, pageBreak: 'after' }); } delete content[tables.length - 1].pageBreak; docDefinition.styles = styleInfo.styles; } else { const body = tables[0].body; for (let j = headerRows - 1; j >= 0; j--) { body.unshift(header[0][j]); } content = [{ table: { headerRows: headerRows, body: body } }]; docDefinition.styles = { header: { bold: true }, group: { bold: true } }; } docDefinition.content = content; pdfMake.createPdf(docDefinition).download(fileName); delete that.mergedCellsPDF; delete that.styleInfo; } /** * Gets the header content when exporting to PDF. */ getPDFStyle() { const that = this, style = that.style; if (!style) { return ''; } const sampleRecord = that.data[0], headerDefinition = style.header, columnsDefinition = style.columns, rowsDefinition = style.rows, styleInfo = { heights: [], widths: Array(that.datafields.length).fill('*'), styles: { header: {}, row: {}, cell: {}, group: { fillColor: '#FFFFFF', color: '#000000', bold: true } } }; that.styleInfo = styleInfo; function processStyleDefinition(definition, type) { if (!definition) { return; } for (let prop in definition) { if (!definition.hasOwnProperty(prop)) { continue; } if (sampleRecord[prop] === undefined) { if (prop === 'height' && type === 'header') { for (let i = 0; i < that.headerRows; i++) { styleInfo.heights[i] = (parseInt(definition[prop], 10) / that.headerRows) / 1.4; } } else { that.storePDFStyle({ prop: prop, value: definition[prop], toUpdate: type }); } } else { for (let columnProp in definition[prop]) { if (!isNaN(columnProp) || !definition[prop].hasOwnProperty(columnProp)) { continue; } const value = definition[prop][columnProp], index = that.datafields.indexOf(prop); if (columnProp === 'width' && styleInfo.widths[index] === '*') { styleInfo.widths[index] = value; } else { that.storePDFStyle({ prop: columnProp, value: value, toUpdate: type + prop }); } } } } } processStyleDefinition(headerDefinition, 'header'); processStyleDefinition(columnsDefinition, 'cell'); if (!rowsDefinition) { return; } for (let prop in rowsDefinition) { if (!rowsDefinition.hasOwnProperty(prop) || prop.indexOf('alt') !== -1) { continue; } const value = rowsDefinition[prop]; if (!isNaN(prop)) { for (let rowProp in value) { if (value.hasOwnProperty(rowProp)) { if (rowProp === 'height') { styleInfo.heights[parseFloat(prop) + that.headerRows] = parseFloat(value[rowProp]) / 1.4; } else { that.storePDFStyle({ prop: rowProp, value: value[rowProp], toUpdate: 'row' + prop }); } } } continue; } if (prop === 'height') { styleInfo.defaultHeight = parseFloat(value) / 1.4; } else { that.storePDFStyle({ prop: prop, value: value, toUpdate: 'row' }); } } if (!rowsDefinition.alternationCount) { return; } for (let i = 0; i < rowsDefinition.alternationCount; i++) { const styleN = {}; if (rowsDefinition[`alternationIndex${i}Color`]) { styleN.color = rowsDefinition[`alternationIndex${i}Color`]; } if (rowsDefinition[`alternationIndex${i}BackgroundColor`]) { styleN.fillColor = rowsDefinition[`alternationIndex${i}BackgroundColor`]; } styleInfo.styles['rowN' + i] = styleN; } } /** * Stores style in object to be applied to generated PDF. */ storePDFStyle(details) { const that = this; let objectToUpdate = that.styleInfo.styles[details.toUpdate]; if (!objectToUpdate) { objectToUpdate = {}; that.styleInfo.styles[details.toUpdate] = objectToUpdate; } let value = details.value; switch (details.prop) { case 'backgroundColor': objectToUpdate.fillColor = value; break; case 'color': objectToUpdate.color = value; break; case 'fontSize': objectToUpdate.fontSize = parseFloat(value); break; case 'fontStyle': if (value === 'italic') { objectToUpdate.italics = true; } break; case 'fontWeight': if (value === 'bold') { objectToUpdate.bold = true; } break; case 'textAlign': objectToUpdate.alignment = value; break; } } /** * Enables column wrapping when exporting to PDF. */ wrapPDFColumns(docDefinition, mapping) { const that = this, styleInfo = this.styleInfo, maxPerPage = docDefinition.pageOrientation === 'portrait' ? 775 : 1155, // maximum of 775px (portrait) or 1155px (landscape) per A4 page tables = []; let currentPage = 0; for (let i = 0; i < styleInfo.widths.length; i++) { let currentWidth = styleInfo.widths[i], numericWidth; if (currentWidth === '*') { numericWidth = 150; } else if (typeof currentWidth === 'string' && currentWidth.indexOf('%') !== -1) { numericWidth = Math.min(maxPerPage, Math.floor((parseFloat(currentWidth) / 100) * maxPerPage)); if (numericWidth === maxPerPage) { currentWidth = '*'; } } else { currentWidth = parseFloat(currentWidth); if (currentWidth >= maxPerPage) { numericWidth = maxPerPage currentWidth = '*'; } else { numericWidth = currentWidth; currentWidth /= 1.4; } } if (tables[currentPage] === undefined) { const body = []; tables[currentPage] = { body: body, width: numericWidth, widths: [currentWidth], datafields: [that.datafields[i]] }; mapping[i] = currentPage; continue; } const table = tables[currentPage]; if (table.width + numericWidth > maxPerPage) { currentPage++; i--; continue; } mapping[i] = currentPage; table.width += numericWidth; table.widths.push(currentWidth); table.datafields.push(that.datafields[i]); } return tables; } /** * Gets the header content when exporting to PDF. */ getPDFHeader(datafields, tables, mapping) { const that = this, headerArray = [], headerRows = that.headerRows, headerStructure = that.complexHeader ? that.complexHeader : [Object.values(that.data[0])], headers = []; let result = []; for (let i = 0; i < headerRows; i++) { const row = headerStructure[i]; for (let k = 0; k < row.length; k++) { let tableIndex = mapping[k] || 0; if (!headers[tableIndex]) { headers[tableIndex] = []; } if (!headers[tableIndex][i]) { headers[tableIndex][i] = []; } headers[tableIndex][i].push(row[k]); } } function processHeader(header, result, table) { for (let j = 0; j < headerRows; j++) { const row = header[j]; const tableRow = []; for (let k = 0; k < row.length; k++) { const currentLabel = row[k]; let colspan = 1, rowspan = 1; if ((row[k - 1] && row[k - 1] === currentLabel) || (header[j - 1] && (header[j - 1][k] === currentLabel))) { tableRow.push({}); continue; } let iterator = k + 1; while (row[iterator] && row[iterator] === row[iterator - 1]) { colspan++; iterator++; } iterator = j + 1; while (header[iterator] && header[iterator][k] === currentLabel) { rowspan++; iterator++; } const datafield = j === headerRows - 1 || rowspan + j === headerRows ? table.datafields[k] : null, entry = { text: currentLabel, colSpan: colspan, rowSpan: rowspan }; if (!datafield) { entry.alignment = 'center'; entry.style = 'header'; } else { entry.style = ['header', 'header' + datafield]; } tableRow.push(entry); } result.push(tableRow); } } for (let i = 0; i < tables.length; i++) { result = []; processHeader(headers[i], result, tables[i]); headerArray.push(result); } return headerArray; } /** * Creates group header rows when exporting to PDF. */ createGroupHeaderRow(tables, entryTemplate) { for (let i = 0; i < tables.length; i++) { const entry = Object.assign({}, entryTemplate), colspan = tables[i].datafields.length, tableRow = [entry]; entry.colSpan = colspan; tableRow.length = colspan; tableRow.fill({}, 1, colspan - 1); tables[i].body.push(tableRow); } } /** * Gets unique cell style when exporting to PDF. */ getUniqueStylePDF(entry, datafield, row) { const style = this.style; function toHex(background) { const parts = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(background.replace(/\s/g, '')); if (parts === null) { return background; } const r = parseFloat(parts[1]).toString(16).toUpperCase(), g = parseFloat(parts[2]).toString(16).toUpperCase(), b = parseFloat(parts[3]).toString(16).toUpperCase(); return '#' + ('0').repeat(2 - r.length) + r + ('0').repeat(2 - g.length) + g + ('0').repeat(2 - b.length) + b; } if (!style || !style.columns || !style.columns[datafield]) { return; } const uniqueStyle = style.columns[datafield][row]; if (!uniqueStyle) { return; } entry.fillColor = toHex(uniqueStyle.background); entry.color = uniqueStyle.color.toLowerCase(); } /** * Sets the indentation of a PDF cell. */ setIndentation(entry, details) { if (details.j !== 0) { return; } const that = this; if (that.actualHierarchy) { const currentRecord = details.currentRecord; if (currentRecord._expanded !== undefined) { entry.marginLeft = 25 * (currentRecord._level - 1); entry.text = that.collapseChar + ' ' + details.value; } else { entry.marginLeft = 25 * (currentRecord._level - 1) + 6; } } else if (details.outlineLevel > 1) { entry.marginLeft = (details.outlineLevel - 1) * 7.5; } } /** * Exports to XLSX. */ exportToXLSX(data, fileName) { try { JSZip; } catch (error) { throw new Error('Missing reference to \'jszip.min.js\'.'); } const that = this; let style = that.style; data = that.processGroupingInformation(data, true); that.data = data; that.getColumnsArray(); that.complexHeaderMergedCells = []; if (that.complexHeaderMergeInfo) { for (let cell in that.complexHeaderMergeInfo) { if (that.complexHeaderMergeInfo.hasOwnProperty(cell)) { const currentEntry = that.complexHeaderMergeInfo[cell]; if (currentEntry.from[0] === currentEntry.to[0] && currentEntry.from[1] === currentEntry.to[1]) { continue; } that.complexHeaderMergedCells.push({ from: that.columnsArray[currentEntry.from[1]] + (currentEntry.from[0] + 1), to: that.columnsArray[currentEntry.to[1]] + (currentEntry.to[0] + 1) }); } } } that.getConditionalFormatting(); if (!style) { style = that.generateDefaultStyle(data); } const sharedStrings = that.generateSharedStrings(data), sharedStringsCollection = sharedStrings.collection, sharedStringsXML = sharedStrings.xml, stylesXML = that.generateStyles(style), sheet1XML = that.groupBy ? that.generateSheet1WithGrouping(data, sharedStringsCollection) : that.generateSheet1(data, sharedStringsCollection), auxiliaryFiles = that.generateAuxiliaryFiles(), // eslint-disable-next-line zip = new JSZip(), _rels = zip.folder('_rels'), docProps = zip.folder('docProps'), xl = zip.folder('xl'), xl_rels = xl.folder('_rels'), theme = xl.folder('theme'), worksheets = xl.folder('worksheets'); _rels.file('.rels', auxiliaryFiles._relsRels); docProps.file('app.xml', auxiliaryFiles.docPropsAppXml); docProps.file('core.xml', auxiliaryFiles.docPropsCoreXml); xl_rels.file('workbook.xml.rels', auxiliaryFiles.xl_relsWorkbookXmlRels); theme.file('theme1.xml', auxiliaryFiles.xlThemeTheme1Xml); worksheets.file('sheet1.xml', sheet1XML); xl.file('sharedStrings.xml', sharedStringsXML); xl.file('styles.xml', stylesXML); xl.file('workbook.xml', auxiliaryFiles.xlWorkbookXml); zip.file('[Content_Types].xml', auxiliaryFiles.Content_TypesXml); zip.generateAsync({ type: 'blob', mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }) .then(function (content) { return that.downloadFile(content, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', fileName); }); delete that.conditionalFormattingXLSX; delete that.complexHeaderMergeInfo; delete that.defaultRowHeight; delete that.rowHeight; } /** * Processes grouping information. */ processGroupingInformation(data, xlsx) { const that = this; if (!that.groupBy) { return data; } let header; data = data.slice(0); if (that.exportHeader) { if (xlsx && that.complexHeader) { header = data.slice(0, that.complexHeader.length); data.splice(0, that.complexHeader.length); } else { header = [data[0]]; data.splice(0, 1); } } if (data.length > 1) { const getCompareFunction = function (a, knownDataType) { // gets data type of column (not necessary if the Grid provides this information) const dataType = knownDataType || typeof a; let compareFunction; switch (dataType) { case 'string': compareFunction = new Intl.Collator().compare; break; case 'number': compareFunction = function (a, b) { return a - b; }; break; case 'boolean': case 'bool': compareFunction = function (a, b) { if (a === b) { return 0; } else if (a === false) { return -1; } else { return 1; } }; break; case 'date': case 'time': case 'dateTime': if (a instanceof Date) { compareFunction = function (a, b) { return a.getTime() - b.getTime(); }; } else if (a instanceof LW.Utilities.DateTime || a instanceof LW.Utilities.BigNumber) { compareFunction = function (a, b) { return a.compare(b); }; } break; case 'object': if (a instanceof Date) { compareFunction = function (a, b) { return a.getTime() - b.getTime(); }; } else if (a instanceof LW.Utilities.DateTime || a instanceof LW.Utilities.BigNumber) { compareFunction = function (a, b) { return a.compare(b); }; } else if (a instanceof LW.Utilities.Complex || (window.NIComplex && a instanceof window.NIComplex)) { const complexNumericProcessor = new LW.Utilities.ComplexNumericProcessor(); compareFunction = function (a, b) { return complexNumericProcessor.compareComplexNumbers(a, b); } } break; } return compareFunction; } const sortByMultipleColumns = function (dataSource, sortColumns, directions, customSortingCallback) { if (!dataSource || !(Array.isArray(dataSource)) || dataSource.length === 0 || !sortColumns || Array.isArray(sortColumns) && sortColumns.length === 0) { return; } if (typeof sortColumns === 'string') { sortColumns = [sortColumns]; } const directionCoefficients = [], compareFunctions = []; if (directions === undefined) { directions = []; } for (let i = 0; i < sortColumns.length; i++) { if (directions[i] === undefined || directions[i] === 'asc' || directions[i] === 'ascending') { directionCoefficients[i] = 1; } else { directionCoefficients[i] = -1; } compareFunctions[i] = getCompareFunction(dataSource[0][sortColumns[i]]); } if (customSortingCallback) { customSortingCallback(dataSource, sortColumns, directions, compareFunctions); return; } dataSource.sort(function (a, b) { for (let i = 0; i < sortColumns.length; i++) { const result = compareFunctions[i](a[sortColumns[i]], b[sortColumns[i]]); if (result === 0) { if (sortColumns[i + 1]) { continue; } else if (a._index !== undefined) { // makes sorting stable return (a._index - b._index) * directionCoefficients[i]; } return 0; } return result * directionCoefficients[i]; } }); } sortByMultipleColumns(data, that.groupBy); } if (header) { data = header.concat(data); } that.getGroupLabels(data); return data; } /** * Exports to XML. */ exportToXML(data, fileName) { const datafields = this.datafields.slice(0); let xmlContent = '<?xml version="1.0" encoding="UTF-8" ?>\n<table>\n'; if (datafields.indexOf('rows') === -1) { datafields.push('rows'); } function recursion(records, indent) { let content = ''; for (let i = 0; i < records.length; i++) { const currentRecord = records[i]; content += indent + '<row>\n'; for (let j = 0; j < datafields.length; j++) { const datafield = datafields[j]; if (datafield === 'rows') { if (!currentRecord.rows) { continue; } content += `${indent} <rows>\n${recursion(currentRecord.rows, indent + ' ')}${indent} </rows>\n`; continue; } content += indent + ` <${datafield}>${currentRecord[datafield]}</${datafield}>\n`; } content += indent + '</row>\n'; } return content; } xmlContent += recursion(data, ' ') + '</table>'; return this.downloadFile(xmlContent, 'application/xml', fileName); } /** * Formats a date. */ formatDate(value, format) { if (!LW.Utilities.DateTime) { return value; } try { return new LW.Utilities.DateTime(value).toString(format); } catch (error) { return value; } } /** * Formats a number. */ formatNumber(value, format) { if (!LW.Utilities.NumberRenderer) { return value; } const renderer = new LW.Utilities.NumberRenderer(), result = renderer.formatNumber(value, format); if (result === undefined) { return value; } return result; } /** * Generates auxiliary files necessary for XLSX. */ generateAuxiliaryFiles() { // _rels\.rels const _relsRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>`; // docProps\app.xml const docPropsAppXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>`; // docProps\core.xml const now = new Date().toISOString(), docPropsCoreXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>LW HTML Elements</dc:creator><cp:lastModifiedBy>LW HTML Elements</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">${now}</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">${now}</dcterms:modified></cp:coreProperties>`; // xl\_rels\workbook.xml.rels const xl_relsWorkbookXmlRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/><Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/></Relationships>`; // xl\theme\theme1.xml const xlThemeTheme1Xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=" Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=""/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>`; // xl\workbook.xml const xlWorkbookXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15 xr xr6 xr10 xr2" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr6="http://schemas.microsoft.com/office/spreadsheetml/2016/revision6" xmlns:xr10="http://schemas.microsoft.com/office/spreadsheetml/2016/revision10" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2"><fileVersion appName="xl" lastEdited="7" lowestEdited="7" rupBuild="20325"/><workbookPr defaultThemeVersion="166925"/><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="x15"><x15ac:absPath url="C:\Users\jqwidgets\Desktop\" xmlns:x15ac="http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac"/></mc:Choice></mc:AlternateContent><xr:revisionPtr revIDLastSave="0" documentId="13_ncr:1_{0DEDCB6D-5403-4CD8-AAA5-59B6D238A8B6}" xr6:coauthVersionLast="34" xr6:coauthVersionMax="34" xr10:uidLastSave="{00000000-0000-0000-0000-000000000000}"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="19200" windowHeight="6950" xr2:uid="{0CB664E6-3800-4A88-B158-B46A682E7484}"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="179021"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>`; // [Content_Types].xml const Content_TypesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="bin" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings"/><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/><Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>`; return { _relsRels: _relsRels, docPropsAppXml: docPropsAppXml, docPropsCoreXml: docPropsCoreXml, xl_relsWorkbookXmlRels: xl_relsWorkbookXmlRels, xlThemeTheme1Xml: xlThemeTheme1Xml, xlWorkbookXml: xlWorkbookXml, Content_TypesXml: Content_TypesXml }; } /** * Generates default style object (for use in XLSX export). */ generateDefaultStyle(data) { const that = this, defaultStyle = {}, datafields = that.datafields, firstRecord = that.complexHeader ? data[that.complexHeader.length] : data[+that.exportHeader]; if (!firstRecord) { return defaultStyle; } for (let i = 0; i < datafields.length; i++) { const sampleValue = firstRecord[datafields[i]]; if (sampleValue instanceof Date) { if (!defaultStyle.columns) { defaultStyle.columns = []; } defaultStyle.columns[datafields[i]] = { format: 'd' }; } } return defaultStyle; } /** * Generates group row. */ generateGroupRow(details) { const rowNumber = details.rowNumber, from = 'A' + rowNumber, recordXML = ` <row r="${rowNumber}" outlineLevel="${details.outlineLevel}" spans="1:${details.numberOfColumns}"${this.getCustomRowHeight(rowNumber - 1)} x14ac:dyDescent="0.45"> <c r="${from}" t="s" s="0"> <v>${details.sharedStringIndex}</v> </c> </row>\n`; details.mergedCells.push({ from: from, to: this.columnsArray[details.numberOfColumns - 1] + rowNumber }); return recordXML; } /** * Generates sharedStrings.xml. */ generateSharedStrings(data) { const that = this, datafields = that.datafields, collection = []; let xml = '', count = 0, uniqueCount = 0; function addSharedString(currentValue) { count++; if (collection.indexOf(currentValue) === -1) { uniqueCount++; collection.push(currentValue); currentValue = currentValue.replace(/&(?!amp;)/g, '&amp;'); currentValue = currentValue.replace(/'/g, '&apos;'); currentValue = currentValue.replace(/"/g, '&quot;'); currentValue = currentValue.replace(/>/g, '&gt;'); currentValue = currentValue.replace(/</g, '&lt;'); xml += `<si><t>${currentValue}</t></si>`; } } for (let i = 0; i < data.length; i++) { const currentRecord = data[i]; for (let j = 0; j < datafields.length; j++) { let currentValue = currentRecord[datafields[j]]; if (currentValue === null && !that.allowNull) { currentValue = ''; } if (typeof currentValue !== 'string') { continue; } addSharedString(currentValue); } } if (that.groupLabels) { for (let i = 0; i < that.groupLabels.length; i++) { addSharedString(that.groupLabels[i]); } } xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${count}" uniqueCount="${uniqueCount}">${xml}</sst>`; return { collection: collection, xml: xml }; } /** * Generates sheet1.xml. */ generateSheet1(data, sharedStrings) { const that = this, numberOfColumns = that.columnsArray.length, numberOfRows = data.length, dimensionEnd = that.columnsArray[numberOfColumns - 1] + numberOfRows, datafields = that.datafields, autoFilter = that.getFilters(), mergedCells = [].concat(that.complexHeaderMergedCells); let xmlContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}"> <sheetPr filterMode="${autoFilter !== ''}" /> <dimension ref="A1:${dimensionEnd}" /> <sheetViews> <sheetView tabSelected="1" workbookViewId="0" /> </sheetViews> <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${that.getCustomColumnWidths()} <sheetData>\n`; function r(col, row) { return that.columnsArray[col] + row; } for (let i = 0; i <= data.length; i++) { const currentRecord = data[i], rowNumber = i + 1; let collapsed = ''; if (that.actualHierarchy) { const previousRecord = data[i - 1]; if (previousRecord && previousRecord._collapsed && (!currentRecord || previousRecord._level > currentRecord._level)) { collapsed = ' collapsed="true"'; } } if (i === data.length) { if (collapsed) { xmlContent += ` <row r="${rowNumber}" outlineLevel="${Math.max(data[i - 1]._level - 2, 0)}" hidden="false" collapsed="true" />\n`; } break; } let recordXML = ` <row r="${rowNumber}"${that.getOutlineLevel(currentRecord)} hidden="${currentRecord._hidden || currentRecord._collapsed || false}"${collapsed} spans="1:${numberOfColumns}"${that.getCustomRowHeight(rowNumber - 1)} x14ac:dyDescent="0.45">\n`; for (let j = 0; j < datafields.length; j++) { const s = that.getXLSXCellStyle(r(j, rowNumber)); recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings); } recordXML += ' </row>\n'; xmlContent += recordXML; } xmlContent += ` </sheetData>${that.conditionalFormattingXLSX.conditions}${autoFilter}${that.getMergedCells(mergedCells)} <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" /> <pageSetup paperSize="9" orientation="portrait" r:id="rId1" /> </worksheet>`; return xmlContent; } /** * Generates sheet1.xml with grouping. */ generateSheet1WithGrouping(data, sharedStrings) { const that = this, numberOfColumns = that.columnsArray.length, numberOfRows = data.length, dimensionEnd = that.columnsArray[numberOfColumns - 1] + numberOfRows, datafields = that.datafields, mergedCells = [].concat(that.complexHeaderMergedCells); let xmlContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}"> <dimension ref="A1:${dimensionEnd}" /> <sheetViews> <sheetView tabSelected="1" workbookViewId="0" /> </sheetViews> <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${that.getCustomColumnWidths()} <sheetData>\n`, rowNumberCorrection = 0, groupsHandled = []; function r(col, row) { return that.columnsArray[col] + row; } mainLoop: for (let i = 0; i < data.length; i++) { const currentRecord = data[i], rowNumber = i + 1 + rowNumberCorrection; let outlineLevel = 0, outlineXML = ''; if (!that.exportHeader || (!that.complexHeader && i !== 0) || (that.complexHeader && i >= that.complexHeader.length)) { let groupId = ''; for (let k = 0; k < that.groupBy.length; k++) { const datafield = that.groupBy[k], currentGroup = currentRecord[datafield], currentGroupLabel = that.groups[datafield][currentGroup]; groupId += currentGroup; if (groupsHandled.indexOf(groupId) === -1) { let sharedStringIndex = sharedStrings.indexOf(currentGroupLabel); xmlContent += that.generateGroupRow({ rowNumber: rowNumber, outlineLevel: outlineLevel, numberOfColumns: numberOfColumns, sharedStringIndex: sharedStringIndex, mergedCells: mergedCells }); groupsHandled.push(groupId); i--; rowNumberCorrection++; continue mainLoop; } outlineLevel++; } outlineXML = ` outlineLevel="${outlineLevel}"`; } let recordXML = ` <row r="${rowNumber}"${outlineXML} spans="1:${numberOfColumns}"${that.getCustomRowHeight(rowNumber - 1)} x14ac:dyDescent="0.45">\n`; for (let j = 0; j < datafields.length; j++) { const s = that.getXLSXCellStyle(r(j, i + 1)); recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings); } recordXML += ' </row>\n'; xmlContent += recordXML; } xmlContent += ` </sheetData>${that.getMergedCells(mergedCells)} <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" /> <pageSetup paperSize="9" orientation="portrait" r:id="rId1" /> </worksheet>`; return xmlContent; } /** * Gets actual spreadsheet cell data. */ getActualCellData(currentValue, details, sharedStrings) { const r = details.r, s = details.s || ' s="0"'; if (currentValue === null && !this.allowNull) { currentValue = ''; } if (typeof currentValue === 'string') { return ` <c r="${r}" t="s"${s}> <v>${sharedStrings.indexOf(currentValue)}</v> </c>\n`; } if (typeof currentValue === 'boolean') { return ` <c r="${r}" t="b"${s}> <v>${+currentValue}</v> </c>\n`; } if (currentValue instanceof Date) { const excelDate = (currentValue.getTime() + this.timeBetween1900And1970) / 86400000 + 2; return ` <c r="${r}"${s}> <v>${excelDate}</v> </c>\n`; } // numeric cells return ` <c r="${r}"${s}> <v>${currentValue}</v> </c>\n`; } /** * Gets column labels. */ getColumnsArray() { const that = this, numberOfColumns = that.datafields.length, columnsCollection = []; function getIterator(i) { if (i < 26) { return ''; } return String.fromCharCode(64 + Math.floor(i / 26)); } for (let i = 0; i < numberOfColumns; i++) { columnsCollection.push(getIterator(i) + String.fromCharCode(65 + (i < 26 ? i : i % 26))); } that.columnsArray = columnsCollection; } /** * Gets column style. */ getColumnStyle() { const that = this, style = that.style; if (!style) { return ` .header { border: 1px solid black; padding: 5px; } .column { border: 1px solid black; padding: 5px; } .group { background-color: #FFFFFF; color: #000000; font-weight: bold; }`; } const styles = { header: 'border: 1px solid black; padding: 5px; ', column: 'white-space: nowrap; overflow: hidden; border: 1px solid black; padding: 5px; ', group: 'background-color: #FFFFFF; color: #000000; font-weight: bold; ' }, sampleRecord = that.data[0]; let generatedStyle = ''; const headerDefinition = style.header || {}; for (let prop in headerDefinition) { if (!headerDefinition.hasOwnProperty(prop)) { continue; } const value = headerDefinition[prop]; if (sampleRecord[prop]) { if (!styles['header' + prop]) { styles['header' + prop] = ''; } for (let columnProp in value) { if (value.hasOwnProperty(columnProp)) { const css = LW.Utilities.Core.toDash(columnProp) + ': ' + value[columnProp] + '; '; styles['header' + prop] += css; if (columnProp === 'width') { if (!styles['column' + prop]) { styles['column' + prop] = ''; } styles['column' + prop] += css; } } } continue; } if (prop === 'height' && that.complexHeader) { styles.header += 'height: ' + parseInt(headerDefinition[prop], 10) / that.complexHeader.length + 'px; '; } else { styles.header += LW.Utilities.Core.toDash(prop) + ': ' + headerDefinition[prop] + '; '; } } const columnsDefinition = style.columns || {}; for (let prop in columnsDefinition) { if (!columnsDefinition.hasOwnProperty(prop)) { continue; } const value = columnsDefinition[prop]; if (sampleRecord[prop]) { if (!styles['column' + prop]) { styles['column' + prop] = ''; } for (let columnProp in value) { if (isNaN(columnProp) && value.hasOwnProperty(columnProp) && columnProp !== 'format') { styles['column' + prop] += LW.Utilities.Core.toDash(columnProp) + ': ' + value[columnProp] + '; '; } } continue; } styles.column += LW.Utilities.Core.toDash(prop) + ': ' + value + '; '; } for (let prop in styles) { if (styles.hasOwnProperty(prop)) { generatedStyle += ` .${prop} { ${styles[prop]}}\n`; } } return generatedStyle; } /** * Gets custom column widths. */ getCustomColumnWidths() { const that = this; if (!that.style || !that.columnWidth || that.columnWidth.length === 0) { return ''; } let xml = '\n <cols>\n'; for (let i = 0; i < that.columnWidth.length; i++) { let width = that.columnWidth[i]; if (width !== undefined) { width = Math.round(parseFloat(width)) / 7; xml += ` <col min="${i + 1}" max="${i + 1}" width="${width}" customWidth="1" />\n`; } } xml += ' </cols>'; return xml; } /** * Returns customFilter tag. */ getCustomFilter(value, condition) { let operator = 'equal', val; if (value instanceof Date) { value = (value.getTime() + this.timeBetween1900And1970) / 86400000 + 2; } condition = condition.toUpperCase(); switch (condition) { case 'EMPTY': val = ''; break; case 'NOT_EMPTY': val = ''; operator = 'notEqual'; break; case 'CONTAINS': case 'CONTAINS_CASE_SENSITIVE': val = `*${value}*`; break; case 'DOES_NOT_CONTAIN': case 'DOES_NOT_CONTAIN_CASE_SENSITIVE': val = `*${value}*`; operator = 'notEqual'; break; case 'STARTS_WITH': case 'STARTS_WITH_CASE_SENSITIVE': val = `${value}*`; break; case 'ENDS_WITH': case 'ENDS_WITH_CASE_SENSITIVE': val = `*${value}`; break; case 'EQUAL': case 'EQUAL_CASE_SENSITIVE': val = value; break; case 'NULL': val = null; break; case 'NOT_NULL': val = null; operator = 'notEqual'; break; case 'NOT_EQUAL': val = value; operator = 'notEqual'; break; case 'LESS_THAN': val = value; operator = 'lessThan'; break; case 'LESS_THAN_OR_EQUAL': val = value; operator = 'lessThanOrEqual'; break; case 'GREATER_THAN': val = value; operator = 'greaterThan'; break; case 'GREATER_THAN_OR_EQUAL': val = value; operator = 'greaterThanOrEqual'; break; } return ` <customFilter val="${val}" operator="${operator}"/>\n`; } /** * Gets custom row height. */ getCustomRowHeight(row) { const that = this; if (that.style) { return that.rowHeight[row] || that.defaultRowHeight || ''; } return ''; } /** * Gets datafields. */ getDatafields(data) { const that = this, sampleRecord = data[0], datafields = []; for (let prop in sampleRecord) { if (sampleRecord.hasOwnProperty(prop) && prop.charAt(0) !== '_') { datafields.push(prop); } } that.datafields = datafields; } /** * Returns autoFilter XML. */ getFilters() { const that = this, filterBy = that.filterBy; if (!filterBy) { return ''; } let xml = ''; for (let datafield in filterBy) { if (filterBy.hasOwnProperty(datafield)) { const colId = that.datafields.indexOf(datafield); if (colId === -1) { continue; } const filterDetails = filterBy[datafield], filters = filterDetails.filters; xml += ` <filterColumn colId="${colId}"> <customFilters and="${!filterDetails.operator}">\n`; for (let i = 0; i < filters.length; i++) { xml += that.getCustomFilter(filters[i].value, filters[i].condition); } xml += ` </customFilters> </filterColumn>`; } } if (!xml) { return ''; } xml = `\n <autoFilter ref="A1:${that.columnsArray[that.columnsArray.length - 1] + that.data.length}">\n${xml}\n </autoFilter>`; return xml; } /** * Gets group labels based on data. */ getGroupLabels(data) { const that = this, startIndex = that.xlsxStartIndex !== undefined ? that.xlsxStartIndex : +that.exportHeader, groups = {}, groupLabels = []; for (let i = startIndex; i < data.length; i++) { const currentRecord = data[i]; for (let j = 0; j < that.groupBy.length; j++) { const datafield = that.groupBy[j], currentValue = currentRecord[datafield]; let group = groups[datafield]; if (group === undefined) { groups[datafield] = {}; group = groups[datafield]; } if (group[currentValue] === undefined) { group[currentValue] = (that.exportHeader ? data[startIndex - 1][datafield] : datafield) + ': ' + currentValue; groupLabels.push(group[currentValue]); } } } that.groups = groups; that.groupLabels = groupLabels; } /** * Gets the header content when exporting to HTML. */ getHTMLHeader(datafields, data) { const that = this; let header = '\n <thead>\n'; if (!that.complexHeader) { header += ' <tr>\n'; for (let j = 0; j < datafields.length; j++) { const datafield = datafields[j]; header += ` <th class="header header${datafield}">${data[0][datafield]}</th>\n`; } header += ' </tr>\n </thead>'; return header; } for (let j = 0; j < that.complexHeader.length; j++) { const row = that.complexHeader[j]; header += ' <tr>\n'; for (let k = 0; k < row.length; k++) { const currentLabel = row[k]; let colspan = 1, rowspan = 1; if ((row[k - 1] && row[k - 1] === currentLabel) || (that.complexHeader[j - 1] && (that.complexHeader[j - 1][k] === currentLabel))) { continue; } let iterator = k + 1; while (row[iterator] && row[iterator] === row[iterator - 1]) { colspan++; iterator++; } iterator = j + 1; while (that.complexHeader[iterator] && that.complexHeader[iterator][k] === currentLabel) { rowspan++; iterator++; } const datafield = j === that.complexHeader.length - 1 || rowspan + j === that.complexHeader.length ? ' header' + datafields[k] : ''; header += ` <th class="header${datafield}" colspan="${colspan}" rowspan="${rowspan}">${currentLabel}</th>\n`; } header += ' </tr>\n'; } header += ' </thead>'; return header; } /** * Gets conditional formatting XML. */ getConditionalFormatting() { const that = this, conditionalFormatting = that.conditionalFormatting; if (!conditionalFormatting) { that.conditionalFormattingXLSX = { conditions: '', styles: '' }; return; } const dxfCodes = []; let conditionsXml = '', stylesXml = ''; for (let i = conditionalFormatting.length - 1; i >= 0; i--) { const columnFormat = conditionalFormatting[i], columnLetter = that.columnsArray[that.datafields.indexOf(columnFormat.column)], startCell = columnLetter + (that.xlsxStartIndex + 1), sqref = startCell + ':' + columnLetter + (that.data.length), dxfCode = columnFormat.background + columnFormat.color, attr = that.getConditionalAttributes(columnFormat, startCell); let dxfId = dxfCodes.indexOf(dxfCode); if (dxfId === -1) { const newDxf = ` <dxf> <font> <b val="0"/> <i val="0"/> <color rgb="${columnFormat.color === 'White' ? 'FFFFFFFF' : 'FF000000'}"/> <sz val="10"/> </font> <fill> <patternFill> <bgColor rgb="${that.toARGB(columnFormat.background)}"/> </patternFill> </fill> </dxf>\n`; stylesXml += newDxf; dxfId = dxfCodes.length; dxfCodes.push(dxfCode); } conditionsXml += ` <conditionalFormatting sqref="${sqref}"> <cfRule dxfId="${dxfId}" text="${attr.text}" rank="${attr.rank}" percent="${attr.percent}" bottom="${attr.bottom}" equalAverage="${attr.equalAverage}" aboveAverage="${attr.aboveAverage}"${attr.operator}${attr.timePeriod} priority="${i + 2}" type="${attr.type}"> ${attr.formula} </cfRule> </conditionalFormatting>\n`; } stylesXml = ` <dxfs count="${dxfCodes.length}">\n${stylesXml} </dxfs>`; that.conditionalFormattingXLSX = { conditions: conditionsXml, styles: stylesXml }; } /** * Gets conditional formatting XML attributes. */ getConditionalAttributes(columnFormat, startCell) { let condition = columnFormat.condition, comparator = columnFormat.comparator, text = '', rank = 0, percent = 0, bottom = 0, equalAverage = 0, aboveAverage = 0, operator = '', timePeriod = '', type = '', formula = ''; switch (condition) { case 'equal': operator = 'equal'; type = 'cellIs'; formula = ` <formula>${comparator}</formula>\n`; break; case 'lessThan': operator = 'lessThan'; type = 'cellIs'; formula = ` <formula>${comparator}</formula>\n`; break; case 'greaterThan': operator = 'greaterThan'; type = 'cellIs'; formula = ` <formula>${comparator}</formula>\n`; break; case 'notEqual': operator = 'notEqual'; type = 'cellIs'; formula = ` <formula>${comparator}</formula>\n`; break; case 'between': operator = 'between'; type = 'cellIs'; formula = ` <formula>${columnFormat.min}</formula> <formula>${columnFormat.max}</formula>\n`; break; case 'duplicate': type = 'duplicateValues'; formula = ' <formula>0</formula>\n'; break; case 'topNItems': rank = comparator; type = 'top10'; break; case 'bottomNItems': rank = comparator; bottom = 1; type = 'top10'; break; case 'topNPercent': rank = comparator; percent = 1; type = 'top10'; break; case 'bottomNPercent': rank = comparator; percent = 1; bottom = 1; type = 'top10'; break; case 'aboveAverage': aboveAverage = 1; type = 'aboveAverage'; formula = ' <formula>0</formula>\n'; break; case 'belowAverage': type = 'aboveAverage'; formula = ' <formula>0</formula>\n'; break; case 'contains': text = comparator; operator = 'containsText'; type = 'containsText'; formula = ` <formula>NOT(ISERROR(SEARCH("${comparator}",${startCell})))</formula>\n`; break; case 'doesNotContain': text = comparator; operator = 'notContains'; type = 'notContainsText'; formula = ` <formula>ISERROR(SEARCH("${comparator}",${startCell}))</formula>\n`; break; case 'dateOccur': timePeriod = ` timePeriod="${comparator}"`; type = 'timePeriod'; break; } if (operator) { operator = ` operator="${operator}" `; } return { text: text, rank: rank, percent: percent, bottom: bottom, equalAverage: equalAverage, aboveAverage: aboveAverage, operator: operator, timePeriod: timePeriod, type: type, formula: formula } } /** * Gets merged cells XML. */ getMergedCells(mergedCells) { const that = this; let mergeCellsXml = ''; for (let i = 0; i < mergedCells.length; i++) { if (mergedCells[i].from === mergedCells[i].to) { continue; } mergeCellsXml += `\n <mergeCell ref="${mergedCells[i].from}:${mergedCells[i].to}" />\n`; } if (that.mergedCells) { for (let i = 0; i < that.mergedCells.length; i++) { const cellDefinition = that.mergedCells[i]; if (cellDefinition.rowspan < 2 && cellDefinition.colspan < 2) { continue; } const from = that.columnsArray[cellDefinition.cell[0]] + (cellDefinition.cell[1] + that.xlsxStartIndex + 1), to = that.columnsArray[cellDefinition.cell[0] + cellDefinition.colspan - 1] + (cellDefinition.cell[1] + that.xlsxStartIndex + cellDefinition.rowspan); mergeCellsXml += `\n <mergeCell ref="${from}:${to}" />\n`; } } if (mergeCellsXml) { mergeCellsXml = `\n <mergeCells count="${mergedCells.length}">${mergeCellsXml} </mergeCells>`; } return mergeCellsXml; } /** * Gets numFmt index. */ getNumFmtIndex(format, numFmts) { let index = numFmts.collection.indexOf(format); if (index === -1) { index = numFmts.collection.length + 100; numFmts.collection.push(format); numFmts.xml += `<numFmt numFmtId="${index}" formatCode="${format}"/>`; } else { index += 100; } return index; } /** * Returns outlineLevel. */ getOutlineLevel(record) { if (!this.actualHierarchy || record._level === 1) { return ''; } return ` outlineLevel="${record._level - 1}"`; } /** * Gets row style. */ getRowStyle() { const that = this, style = that.style; if (!style) { return ''; } const rowsDefinition = style.rows; if (!rowsDefinition) { return ''; } const styles = { row: '' }; let generatedStyle = ''; for (let prop in rowsDefinition) { if (!rowsDefinition.hasOwnProperty(prop) || prop === 'alternationCount' || prop === 'alternationStart' || prop === 'alternationEnd') { continue; } const value = rowsDefinition[prop]; if (prop.indexOf('alt') !== -1) { const i = prop.slice(16, 17), property = prop.slice(17); if (!styles['rowN' + i]) { styles['rowN' + i] = ''; } if (property === 'Color') { styles['rowN' + i] += 'color : ' + value + '; '; } else if (property === 'BorderColor') { styles['rowN' + i] += 'border-color : ' + value + '; '; } else { styles['rowN' + i] += 'background-color : ' + value + '; '; } continue; } if (!isNaN(prop)) { if (!styles['row' + prop]) { styles['row' + prop] = ''; } for (let rowProp in value) { if (value.hasOwnProperty(rowProp)) { styles['row' + prop] += LW.Utilities.Core.toDash(rowProp) + ': ' + value[rowProp] + '; '; } } continue; } styles.row += LW.Utilities.Core.toDash(prop) + ': ' + rowsDefinition[prop] + '; '; } let keys = Object.keys(styles); keys.sort(function (a, b) { if (a === 'row') { return -1; } if (b === 'row') { return 1; } const aIsNum = !isNaN(a.slice(3)), bIsNum = !isNaN(b.slice(3)); if (aIsNum && !bIsNum) { return 1; } if (!aIsNum && bIsNum) { return -1; } return +(a < b); }); for (let i = 0; i < keys.length; i++) { generatedStyle += ` .${keys[i]} { ${styles[keys[i]]}}\n`; } return generatedStyle; } /** * Gets table style. */ getTableStyle() { const that = this, style = that.style; if (!style) { return ' style="table-layout: fixed; border: 1px solid black; border-collapse: collapse;"'; } let generatedStyle = 'table-layout: fixed; '; for (let prop in style) { if (style.hasOwnProperty(prop) && ['header', 'columns', 'rows'].indexOf(prop) === -1) { generatedStyle += LW.Utilities.Core.toDash(prop) + ': ' + style[prop] + '; '; } } if (generatedStyle) { generatedStyle = ' style="' + generatedStyle + '"'; } return generatedStyle; } /** * Gets the "s" (style) attribute of an XLSX cell. */ getXLSXCellStyle(r) { const that = this; if (that.cellStyleMapping[r] !== undefined) { return ` s="${that.cellStyleMapping[r]}"`; } return ''; } /** * Gets the "s" (style) attribute of an XLSX cell. */ getXLSXFormat(format, cellValue) { if (typeof cellValue === 'number') { if (!/^([a-zA-Z]\d*)$/g.test(format)) { return format; } let precision = parseFloat(format.slice(1)) || 0, precisionCode = precision > 0 ? '.' + ('0').repeat(precision) : ''; format = format.slice(0, 1); switch (format) { case 'C': case 'c': return '\$#,0' + precisionCode; case 'D': case 'd': if (precision) { return ('0').repeat(precision); } return '0'; case 'E': case 'e': return '0' + precisionCode + format + '000'; case 'F': case 'f': return '0' + precisionCode; case 'N': case 'n': return '#,0' + precisionCode; case 'P': case 'p': return '#,0' + precisionCode + ' %'; default: return; } } else if (cellValue instanceof Date) { switch (format) { case 'd': return 'm/d/yyyy'; case 'D': return 'nnnnmmmm dd, yyyy'; case 't': return 'h:m AM/PM'; case 'T': return 'h:mm:ss AM/PM'; case 'f': return 'nnnnmmmm dd, yyyy h:m AM/PM'; case 'F': return 'nnnnmmmm dd, yyyy h:mm:ss AM/PM'; case 'M': return 'mmmm d'; case 'Y': return 'yyyy mmmm'; case 'FP': case 'PP': return 'yyyy-mm-dd hh:mm:ss'; case 'FT': case 'PT': return 'hh:mm:ss'; } format = format.replace(/f|u|n|p|e|a|x|o/gi, ''); format = format.replace(/tt/gi, 'AM/PM'); format = format.replace(/:{2,}|:\s|:$|\.$/g, ''); format = format.trim(); return format; } } /** * Processes column styles. */ processColumnStyle(style) { const that = this, headerDefinition = style.header, columnsDefinition = style.columns, sampleRecord = that.data[0], startIndex = that.xlsxStartIndex; that.columnWidth = []; if (startIndex && headerDefinition) { for (let i = 0; i < that.columnsArray.length; i++) { const columnLetter = that.columnsArray[i], cell = columnLetter + startIndex, columnSpecific = headerDefinition[that.datafields[i]]; for (let prop in headerDefinition) { if (headerDefinition.hasOwnProperty(prop) && sampleRecord[prop] === undefined) { if (that.complexHeader) { for (let j = 0; j < that.complexHeader.length; j++) { if (prop === 'height') { that.rowHeight[j] = ` ht="${(parseFloat(headerDefinition.height) / that.complexHeader.length) / 2}"`; continue; } else { that.storeCellStyle(columnLetter + (j + 1), prop, headerDefinition[prop]); } } } else { if (prop === 'height') { that.rowHeight[0] = ` ht="${parseFloat(headerDefinition.height) / 2}"`; continue; } that.storeCellStyle(cell, prop, headerDefinition[prop]); } } } if (!columnSpecific) { continue; } for (let prop in columnSpecific) { if (columnSpecific.hasOwnProperty(prop)) { if (prop === 'width') { that.columnWidth[i] = columnSpecific.width; continue; } that.storeCellStyle(cell, prop, columnSpecific[prop]); } } } } else if (headerDefinition) { for (let i = 0; i < that.columnsArray.length; i++) { const columnSpecific = headerDefinition[that.datafields[i]]; if (columnSpecific && columnSpecific.width !== undefined) { that.columnWidth[i] = columnSpecific.width; } } } if (!columnsDefinition) { return ''; } for (let i = startIndex; i < that.data.length; i++) { for (let j = 0; j < that.columnsArray.length; j++) { const columnLetter = that.columnsArray[j], cell = columnLetter + (i + 1), datafield = that.datafields[j], columnSpecific = columnsDefinition[datafield]; for (let prop in columnsDefinition) { if (columnsDefinition.hasOwnProperty(prop) && sampleRecord[prop] === undefined) { that.storeCellStyle(cell, prop, columnsDefinition[prop]); } } if (!columnSpecific) { continue; } for (let prop in columnSpecific) { if (!isNaN(prop) || !columnSpecific.hasOwnProperty(prop)) { continue; } that.storeCellStyle(cell, prop, columnSpecific[prop], that.data[i][datafield]); } } } } /** * Processes complex header object. */ processComplexHeader(header, data, format) { const that = this, flatHeader = {}, processGrouping = ['html', 'jpeg', 'pdf', 'png', 'xlsx'].indexOf(format) !== -1 && header.columngroups, datafieldMapping = [], columnGroupHierarchy = {}, complexHeader = []; let headerDepth = 0; function getColumnGroup(columnGroup) { for (let i = 0; i < header.columngroups.length; i++) { const currentGroupDefinition = header.columngroups[i]; if (currentGroupDefinition.name === columnGroup) { return currentGroupDefinition; } } } function getColumnGroupHierarchy(groupDefinition) { const columnGroups = []; while (groupDefinition) { columnGroups.unshift(groupDefinition.label); if (groupDefinition.parentGroup) { groupDefinition = getColumnGroup(groupDefinition.parentGroup); } else { return columnGroups; } } } if (processGrouping) { for (let i = 0; i < header.columngroups.length; i++) { const currentGroupDefinition = header.columngroups[i], groupHierarchy = getColumnGroupHierarchy(currentGroupDefinition); columnGroupHierarchy[currentGroupDefinition.name] = groupHierarchy; headerDepth = Math.max(headerDepth, groupHierarchy.length); } headerDepth++; for (let i = 0; i < headerDepth; i++) { complexHeader[i] = []; } } for (let i = 0; i < header.columns.length; i++) { const currentColumn = header.columns[i]; flatHeader[currentColumn.dataField] = currentColumn.label; if (!processGrouping) { continue; } datafieldMapping[i] = currentColumn.dataField; complexHeader[headerDepth - 1][i] = currentColumn.label; if (!currentColumn.columnGroup) { continue; } const columnGroups = columnGroupHierarchy[currentColumn.columnGroup]; for (let j = 0; j < columnGroups.length; j++) { complexHeader[j][i] = columnGroups[j]; } } if (complexHeader.length > 1) { const numberOfDatafields = Object.keys(flatHeader).length; for (let i = 0; i < headerDepth - 1; i++) { const entry = {}; for (let j = 0; j < numberOfDatafields; j++) { if (complexHeader[i][j] === undefined) { let iterator = i + 1; while (complexHeader[iterator][j] === undefined) { iterator++; } complexHeader[i][j] = complexHeader[iterator][j]; } entry[datafieldMapping[j]] = complexHeader[i][j]; } if (format === 'xlsx') { data.splice(i, 0, entry); } } that.complexHeader = complexHeader; if (format !== 'xlsx') { data.unshift(flatHeader); } else { data.splice(headerDepth - 1, 0, flatHeader); const toMerge = {}; for (let i = 0; i < headerDepth; i++) { for (let j = 0; j < numberOfDatafields; j++) { const label = complexHeader[i][j]; if (!toMerge[label]) { toMerge[label] = { from: [i, j] }; toMerge[label].to = toMerge[label].from; } else { toMerge[label].to = [i, j]; } } } that.complexHeaderMergeInfo = toMerge; } } else { data.unshift(flatHeader); } } /** * Processes hierarchical data. */ processHierarchicalData(data, format) { const that = this, startIndex = format !== 'xlsx' ? +that.exportHeader : that.xlsxStartIndex, siblingGroups = {}, processedData = []; let maxLevel = 0, actualHierarchy = false; function process(parentKey, level, collapsed) { const group = siblingGroups[parentKey]; maxLevel = Math.max(maxLevel, level); if (group === undefined) { return; } for (let i = 0; i < group.length; i++) { const currentRecord = group[i], keyDataField = currentRecord._keyDataField; currentRecord._collapsed = collapsed; currentRecord._level = level; processedData.push(currentRecord); if (siblingGroups[keyDataField]) { actualHierarchy = true; currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true; process(keyDataField, level + 1, collapsed || !currentRecord._expanded); } } } function processJSONXML(parentKey, level, parent) { const group = siblingGroups[parentKey]; maxLevel = Math.max(maxLevel, level); if (group === undefined) { return; } for (let i = 0; i < group.length; i++) { const currentRecord = group[i], keyDataField = currentRecord._keyDataField; let cleanedRecord; if (format === 'json') { cleanedRecord = {}; for (let prop in currentRecord) { if (currentRecord.hasOwnProperty(prop) && prop.charAt(0) !== '_') { cleanedRecord[prop] = currentRecord[prop]; } } } else { cleanedRecord = Object.assign({}, currentRecord); } parent.push(cleanedRecord); if (siblingGroups[keyDataField]) { actualHierarchy = true; cleanedRecord.rows = []; processJSONXML(keyDataField, level + 1, cleanedRecord.rows); } } } if (data[startIndex]._keyDataField === undefined) { return that.processNestedData(data, format, startIndex); } for (let i = startIndex; i < data.length; i++) { const currentRecord = Object.assign({}, data[i]); let parentKey = currentRecord._parentDataField; if (parentKey === undefined) { parentKey = null; } if (siblingGroups[parentKey] === undefined) { siblingGroups[parentKey] = [currentRecord]; } else { siblingGroups[parentKey].push(currentRecord); } } if (startIndex) { for (let i = 0; i < startIndex; i++) { processedData.push(Object.assign({}, data[i])); if (['json', 'pdf', 'xml'].indexOf(format) === -1) { processedData[i]._level = 1; } } } if (format !== 'json' && format !== 'xml') { process(null, 1, false); } else { processJSONXML(null, 1, processedData); } if (!actualHierarchy) { that.actualHierarchy = false; } that.maxLevel = maxLevel; return processedData; } /** * Processes nested hierarchical data. */ processNestedData(data, format, startIndex) { const that = this, processedData = []; let maxLevel = 0, actualHierarchy = false; function process(start, children, level, collapsed) { maxLevel = Math.max(maxLevel, level); for (let i = start; i < children.length; i++) { const currentRecord = Object.assign({}, children[i]); currentRecord._collapsed = collapsed; currentRecord._level = level; processedData.push(currentRecord); if (currentRecord.children && currentRecord.children.length > 0) { actualHierarchy = true; currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true; process(0, currentRecord.children, level + 1, collapsed || !currentRecord._expanded); } delete currentRecord.children; } } function processJSONXML(start, children, rows, level) { maxLevel = Math.max(maxLevel, level); for (let i = start; i < children.length; i++) { const currentRecord = Object.assign({}, children[i]); if (level === 1) { processedData[i] = currentRecord; } else { rows[i] = currentRecord; } if (currentRecord.children && currentRecord.children.length > 0) { actualHierarchy = true; currentRecord.rows = []; processJSONXML(0, currentRecord.children, currentRecord.rows, level + 1); } delete currentRecord.children; } } if (startIndex) { for (let i = 0; i < startIndex; i++) { processedData.push(Object.assign({}, data[i])); if (['json', 'pdf', 'xml'].indexOf(format) === -1) { processedData[i]._level = 1; } } } if (format !== 'json' && format !== 'xml') { process(startIndex, data, 1, false); } else { processJSONXML(startIndex, data, undefined, 1); } if (!actualHierarchy) { that.actualHierarchy = false; } that.maxLevel = maxLevel; return processedData; } /** * Processes row styles. */ processRowStyle(style) { const that = this, rowsDefinition = style.rows; that.rowHeight = []; if (!rowsDefinition) { return; } const startIndex = that.xlsxStartIndex; function applyToRowCells(row, prop, value) { for (let j = 0; j < that.columnsArray.length; j++) { const currentCell = that.columnsArray[j] + (row + 1 + startIndex); that.storeCellStyle(currentCell, prop, value); } } if (rowsDefinition.height) { that.defaultRowHeight = ` ht="${parseFloat(rowsDefinition.height) / 2}"`; } for (let i = startIndex; i < that.data.length; i++) { const row = i - startIndex; for (let prop in rowsDefinition) { if (rowsDefinition.hasOwnProperty(prop) && prop.indexOf('alt') === -1 && isNaN(prop) && prop !== 'height') { applyToRowCells(row, prop, rowsDefinition[prop]); } } if (rowsDefinition.alternationCount && (((rowsDefinition.alternationStart === undefined || row >= rowsDefinition.alternationStart) && (rowsDefinition.alternationEnd === undefined || row <= rowsDefinition.alternationEnd)) || rowsDefinition.alternationStart === rowsDefinition.alternationEnd)) { const start = rowsDefinition.alternationStart || 0, i = (row - start) % rowsDefinition.alternationCount; if (rowsDefinition[`alternationIndex${i}Color`]) { applyToRowCells(row, 'color', rowsDefinition[`alternationIndex${i}Color`]); } if (rowsDefinition[`alternationIndex${i}BorderColor`]) { applyToRowCells(row, 'borderColor', rowsDefinition[`alternationIndex${i}BorderColor`]); } if (rowsDefinition[`alternationIndex${i}BackgroundColor`]) { applyToRowCells(row, 'backgroundColor', rowsDefinition[`alternationIndex${i}BackgroundColor`]); } } if (rowsDefinition[row]) { for (let prop in rowsDefinition[row]) { if (rowsDefinition[row].hasOwnProperty(prop)) { if (prop === 'height') { that.rowHeight[i] = ` ht="${parseFloat(rowsDefinition[row].height) / 2}"`; continue; } applyToRowCells(row, prop, rowsDefinition[row][prop]); } } } } } /** * Stores cell style in "styleMap" object. */ storeCellStyle(cell, prop, value) { const that = this, cellMap = that.styleMap[cell]; switch (prop) { case 'backgroundColor': cellMap.fills.fgColor = value; break; case 'color': cellMap.fonts.color = value; break; case 'fontFamily': cellMap.fonts.name = value.replace(/"/g, '\''); break; case 'fontSize': cellMap.fonts.sz = parseFloat(value); break; case 'fontStyle': if (value === 'italic') { cellMap.fonts.i = true; } else { delete cellMap.fonts.i; } break; case 'fontWeight': if (value === 'bold') { cellMap.fonts.b = true; } else { delete cellMap.fonts.b; } break; case 'numFmt': { cellMap.numFmt = value; break; } case 'textAlign': cellMap.alignment.horizontal = value; break; case 'textDecoration': if (value === 'underline') { cellMap.fonts.u = true; } else { delete cellMap.fonts.u; } break; case 'verticalAlign': if (value === 'middle') { value = 'center'; } cellMap.alignment.vertical = value; break; } } /** * Returns an Alpha Red Green Blue color value. */ toARGB(color) { color = color.replace(/\s/g, ''); const rgbResult = /rgb\((\d+),(\d+),(\d+)\)/gi.exec(color); if (rgbResult !== null) { const r = parseFloat(rgbResult[1]).toString(16).toUpperCase(), g = parseFloat(rgbResult[2]).toString(16).toUpperCase(), b = parseFloat(rgbResult[3]).toString(16).toUpperCase(); return 'FF' + ('0').repeat(2 - r.length) + r + ('0').repeat(2 - g.length) + g + ('0').repeat(2 - b.length) + b; } const rgbaResult = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(color); if (rgbaResult !== null) { const a = Math.round(parseFloat(rgbaResult[4]) * 255).toString(16).toUpperCase(), r = parseFloat(rgbaResult[1]).toString(16).toUpperCase(), g = parseFloat(rgbaResult[2]).toString(16).toUpperCase(), b = parseFloat(rgbaResult[3]).toString(16).toUpperCase(); return ('0').repeat(2 - a.length) + a + ('0').repeat(2 - r.length) + r + ('0').repeat(2 - g.length) + g + ('0').repeat(2 - b.length) + b; } const shortHexResult = /^#(.)(.)(.)$/gi.exec(color); if (shortHexResult !== null) { const r = shortHexResult[1].toUpperCase(), g = shortHexResult[2].toUpperCase(), b = shortHexResult[3].toUpperCase(); return 'FF' + r + r + g + g + b + b; } return 'FF' + color.toUpperCase().slice(1); } /** * Adds toggleable functionality. */ toggleableFunctionality() { const that = this; if (!that.actualHierarchy) { return ''; } return `\n <style type="text/css"> .toggle-element { width: 5px; height: 1px; padding-right: 5px; float: left; text-align: right; cursor: pointer; user-select: none; } .collapsed { display: none; } </style> <script type="text/javascript"> window.onload = function () { var expandChar = '${that.expandChar}', collapseChar = '${that.collapseChar}', toggleElements = document.getElementsByClassName('toggle-element'); function getParent(child) { var prevSibling = child.previousElementSibling; while (prevSibling) { if (child.getAttribute('level') > prevSibling.getAttribute('level')) { return prevSibling; } prevSibling = prevSibling.previousElementSibling; } } function getFirstCollapsedAncestor(child) { var parent = getParent(child); while (parent) { if (parent.firstElementChild.firstElementChild.innerHTML === expandChar) { return parent; } parent = getParent(parent); } } for (var i = 0; i < toggleElements.length; i++) { toggleElements[i].addEventListener('click', function (event) { var expanded = this.innerHTML === collapseChar, row = this.parentElement.parentElement, sibling = row.nextElementSibling; if (expanded) { this.innerHTML = expandChar; } else { this.innerHTML = collapseChar; } while (sibling && row.getAttribute('level') < sibling.getAttribute('level')) { if (expanded) { sibling.style.display = 'none'; } else { var firstCollapsedAncestor = getFirstCollapsedAncestor(sibling); if (!firstCollapsedAncestor || firstCollapsedAncestor === row) { sibling.classList.remove('collapsed'); sibling.style.display = null; } } sibling = sibling.nextElementSibling; } }); } } </script>`; } /** * Generates styles.xml. */ generateStyles(style) { const that = this; that.cellStyleMapping = {}; if (Object.keys(style).length === 0 && !that.complexHeader) { // default style return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><charset val="204"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${that.conditionalFormattingXLSX.styles || '<dxfs count="0"/>'}<tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`; } that.styleMap = {}; for (let i = 0; i < that.data.length; i++) { for (let j = 0; j < that.columnsArray.length; j++) { that.styleMap[that.columnsArray[j] + (i + 1)] = { numFmts: {}, fonts: {}, fills: {}, borders: {}, alignment: {} } } } if (style && style.columns) { for (let i = 0; i < that.columnsArray.length; i++) { const datafield = that.datafields[i]; if (!style.columns[datafield] || !style.columns[datafield].format) { continue; } const XLSXFormat = that.getXLSXFormat(style.columns[datafield].format, that.data[that.data.length - 1][datafield]); if (XLSXFormat) { style.columns[datafield].numFmt = XLSXFormat; } } } that.processRowStyle(style); that.processColumnStyle(style); const cellAliases = {}; for (let i = 0; i < that.complexHeaderMergedCells.length; i++) { const currentCell = that.complexHeaderMergedCells[i]; if (parseFloat(currentCell.to[1]) === that.complexHeader.length) { cellAliases[currentCell.to] = currentCell.from; continue; } that.styleMap[currentCell.from].alignment.horizontal = 'center'; that.styleMap[currentCell.from].alignment.vertical = 'center'; } const fonts = { xml: '<font><sz val="11" /><color theme="1" /><name val="Calibri" /><family val="2" /><charset val="204" /><scheme val="minor" /></font>', collection: ['default'] }, fills = { xml: '<fill><patternFill patternType="none" /></fill><fill><patternFill patternType="gray125" /></fill>', collection: ['default', 'gray125'] }, numFmts = { xml: '', collection: [] }, cellXfs = { xml: '<xf fontId="0" fillId="0" borderId="1"/>', collection: ['default'] }; for (let i = 0; i < that.data.length; i++) { // iterate rows for (let j = 0; j < that.columnsArray.length; j++) { // iterate columns const currentCell = that.columnsArray[j] + (i + 1), currentCellStyle = that.styleMap[currentCell]; let currentFont = '', currentFill = '', currentAlignment = '', currentFontCode = [], currentFillCode = [], currentAlignmentCode = [], xf = []; for (let prop in currentCellStyle.fonts) { if (currentCellStyle.fonts.hasOwnProperty(prop)) { const value = currentCellStyle.fonts[prop]; switch (prop) { case 'color': currentFontCode[0] = value; currentFont += `<color rgb="${that.toARGB(value)}" />`; break; case 'name': currentFontCode[1] = value; currentFont += `<name val="${value}" />`; break; case 'sz': currentFontCode[2] = value; currentFont += `<sz val="${value}" />`; break; case 'i': currentFontCode[3] = value; currentFont += '<i />'; break; case 'b': currentFontCode[4] = value; currentFont += '<b />'; break; case 'u': currentFontCode[5] = value; currentFont += '<u />'; break; } } } for (let prop in currentCellStyle.fills) { if (currentCellStyle.fills.hasOwnProperty(prop)) { const value = currentCellStyle.fills[prop]; switch (prop) { case 'fgColor': currentFillCode[0] = value; currentFill += `<fgColor rgb="${that.toARGB(value)}" />`; break; } } } for (let prop in currentCellStyle.alignment) { if (currentCellStyle.alignment.hasOwnProperty(prop)) { const value = currentCellStyle.alignment[prop]; switch (prop) { case 'horizontal': currentAlignmentCode[0] = value; currentAlignment += `horizontal="${value}" `; break; case 'vertical': currentAlignmentCode[1] = value; currentAlignment += `vertical="${value}" `; break; } } } currentFontCode = currentFontCode.toString(); currentFillCode = currentFillCode.toString(); if (currentFont !== '') { let fontIndex = fonts.collection.indexOf(currentFontCode); if (fontIndex === -1) { fontIndex = fonts.collection.length; fonts.xml += '<font>' + currentFont + '</font>'; fonts.collection.push(currentFontCode); } xf[0] = fontIndex; } if (currentFill !== '') { let fillIndex = fills.collection.indexOf(currentFillCode); if (fillIndex === -1) { fillIndex = fills.collection.length; fills.xml += '<fill><patternFill patternType="solid">' + currentFill + '</patternFill></fill>'; fills.collection.push(currentFillCode); } xf[1] = fillIndex; } if (currentAlignmentCode.length > 0) { xf[2] = currentAlignment; } if (currentCellStyle.numFmt !== undefined) { xf[3] = that.getNumFmtIndex(currentCellStyle.numFmt, numFmts); } const xfCode = xf.toString(); if (xfCode !== '') { let xfIndex = cellXfs.collection.indexOf(xfCode); if (xfIndex === -1) { let newXfXML = '<xf '; xfIndex = cellXfs.collection.length; if (xf[0] !== undefined) { newXfXML += `fontId="${xf[0]}" `; } if (xf[1] !== undefined) { newXfXML += `fillId="${xf[1]}" `; } if (xf[3] !== undefined) { newXfXML += `numFmtId="${xf[3]}" `; } if (xf[2] !== undefined) { newXfXML += `applyAlignment="1" borderId="1"><alignment ${currentAlignment}/></xf>`; } else { newXfXML += ' borderId="1"/>'; } cellXfs.xml += newXfXML; cellXfs.collection.push(xfCode); } that.cellStyleMapping[cellAliases[currentCell] || currentCell] = xfIndex; } } } if (numFmts.collection.length) { numFmts.xml = `<numFmts count="${numFmts.collection.length}">${numFmts.xml}</numFmts>`; } return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?> <styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision">${numFmts.xml}<fonts count="${fonts.collection.length}" x14ac:knownFonts="1">${fonts.xml}</fonts><fills count="${fills.collection.length}">${fills.xml}</fills><borders count="2"><border><left/><right/><top/><bottom/></border><border><left style="hair"/><right style="hair"/><top style="hair"/><bottom style="hair"/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="${cellXfs.collection.length}">${cellXfs.xml}</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${that.conditionalFormattingXLSX.styles}<dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('FilterGroup', class FilterGroup { constructor() { const that = this; that.stringConditions = ['EMPTY', 'NOT_EMPTY', 'CONTAINS', 'CONTAINS_CASE_SENSITIVE', 'DOES_NOT_CONTAIN', 'DOES_NOT_CONTAIN_CASE_SENSITIVE', 'STARTS_WITH', 'STARTS_WITH_CASE_SENSITIVE', 'ENDS_WITH', 'ENDS_WITH_CASE_SENSITIVE', 'EQUAL', 'NOT_EQUAL', 'EQUAL_CASE_SENSITIVE', 'NOT_EQUAL_CASE_SENSITIVE', 'NULL', 'NOT_NULL']; that.numericConditions = ['EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL']; that.dateConditions = ['EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL']; that.booleanConditions = ['EQUAL', 'NOT_EQUAL', 'NULL', 'NOT_NULL']; that.filters = new Array(); that.logicalOperators = new Array(); } evaluate(value) { const that = this; let result = true; for (let i = 0; i < that.filters.length; i++) { let currentResult = that.filters[i].evaluate(value); if (i === 0) { result = currentResult; } else { if (that.logicalOperators[i] === 1 || that.logicalOperators[i] === 'or') { result = result || currentResult; } else { result = result && currentResult; } } } return result; } getFiltersCount() { return this.filters.length; } setConditions(filterType, conditions) { const that = this; switch (filterType) { case 'numeric': that.numericConditions = conditions; break; case 'string': that.stringConditions = conditions; break; case 'date': case 'time': that.dateConditions = conditions; break; case 'bool': case 'boolean': that.booleanConditions = conditions; break; } } getConditions(filterType) { const that = this; let array = new Array(); switch (filterType) { case 'numeric': array = that.numericConditions.slice(0); break; case 'string': array = that.stringConditions.slice(0); break; case 'date': case 'time': array = that.dateConditions.slice(0); break; case 'bool': case 'boolean': array = that.booleanConditions.slice(0); break; } return array; } generateFilterKey() { const S4 = function () { return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1); }; return (S4() + '-' + S4() + '-' + S4()); } createFilter(filterType, filterValue, filterCondition, customfilter, formatString, locale, timeOnly) { if (filterType === null || filterType === undefined) { return null; } switch (filterType) { case 'int': case 'float': case 'int64': case 'double': case 'numeric': case 'number': case 'numericFilter': return new LW.Utilities.NumericFilter(filterValue, filterCondition.toUpperCase()); case 'string': case 'stringFilter': return new LW.Utilities.StringFilter(filterValue, filterCondition.toUpperCase(), locale); case 'date': case 'time': case 'dateFilter': return new LW.Utilities.DateFilter(filterValue, filterCondition.toUpperCase(), formatString, locale, timeOnly); case 'bool': case 'boolean': case 'booleanFilter': return new LW.Utilities.BooleanFilter(filterValue, filterCondition.toUpperCase()); case 'custom': return new LW.Utilities.CustomFilter(filterValue, filterCondition.toUpperCase(), customfilter); } throw new Error('lwGrid: There is no such filter type. The available filter types are: "numericFilter", "stringFilter", "dateFilter" and "booleanFilter"'); } getFilters() { const that = this; let filtersArray = new Array(); for (let i = 0; i < that.filters.length; i++) { const filter = that.filters[i]; if (filter instanceof FilterGroup) { let filters = filter.getFilters(); filtersArray.push({ value: filters, logicalOperator: that.logicalOperators[i], type: 'FilterGroup' }); } else { const filterObject = { value: filter.value, condition: filter.condition, logicalOperator: that.logicalOperators[i], type: filter.type }; if (filter.data) { filterObject.id = filter.data; } filtersArray.push(filterObject); } } return filtersArray; } addFilter(logicalOperator, filter) { const that = this; that.filters[that.filters.length] = filter; filter.key = that.generateFilterKey(); that.logicalOperators[that.logicalOperators.length] = logicalOperator; } removeFilter(filter) { const that = this; for (let i = 0; i < that.filters.length; i++) { if (that.filters[i].key === filter.key) { that.filters.splice(i, 1); that.logicalOperators.splice(i, 1); break; } } } getOperatorAt(index) { const that = this; if (index === undefined || index === null) { return null; } if (index < 0 || index > that.filters.length) { return null; } return that.logicalOperators[index]; } setOperatorAt(index, logicalOperator) { const that = this; if (index === undefined || index === null) { return null; } if (index < 0 || index > that.filters.length) { return null; } that.logicalOperators[logicalOperator] = logicalOperator; } getFilterAt(index) { const that = this; if (index === undefined || index === null) { return null; } if (index < 0 || index > that.filters.length) { return null; } return that.filters[index]; } setFilterAt(index, filter) { const that = this; if (index === undefined || index === null) { return null; } if (index < 0 || index > that.filters.length) { return null; } filter.key = that.generateFilterKey(); that.filters[index] = filter; } clear() { const that = this; that.filters = new Array(); that.logicalOperators = new Array(); } getUniqueValues(details, context) { const data = details.data, uniqueValues = [], treeViewSource = [], timeOnly = details.filterType === 'dateFilter' && details.displayMode === 'timePicker'; let compareFunction, blanks = false; for (let i = 0; i < data.length; i++) { let currentValue = data[i][details.dataField]; if (currentValue === '' || currentValue === null || currentValue === undefined) { blanks = true; continue; } let label; if (timeOnly) { label = new LW.Utilities.DateTime(currentValue).toString(details.formatString); } else { label = currentValue.toString(); } if (uniqueValues.indexOf(label) === -1) { uniqueValues.push(label); treeViewSource.push({ label: label, value: currentValue, customAttribute: 'default-item' }); } } switch (details.filterType) { case 'numericFilter': case 'booleanFilter': compareFunction = function (a, b) { return a.value - b.value; }; break; case 'stringFilter': compareFunction = function (a, b) { return new Intl.Collator().compare(a.value, b.value); }; break; case 'dateFilter': if (timeOnly) { compareFunction = function (a, b) { try { const aHours = a.value.getHours(), bHours = b.value.getHours(); if (aHours !== bHours) { return aHours - bHours; } const aMinutes = a.value.getMinutes(), bMinutes = b.value.getMinutes(); if (aMinutes !== bMinutes) { return aMinutes - bMinutes; } const aSeconds = a.value.getSeconds(), bSeconds = b.value.getSeconds(); if (aSeconds !== bSeconds) { return aSeconds - bSeconds; } return 0; } catch (error) { return -1; } }; } else { compareFunction = function (a, b) { try { return a.value.getTime() - b.value.getTime(); } catch (error) { return -1; } }; } break; } treeViewSource.sort(compareFunction); if (details.filterType === 'booleanFilter') { treeViewSource.map(function (item) { item.label = item.label.toUpperCase(); }); } if (blanks) { treeViewSource.push({ label: context.localize('blanks'), value: '', customAttribute: 'default-item' }); } return treeViewSource; } }); LW.Utilities.Assign('StringFilter', class StringFilter { constructor(filterValue, condition, locale) { const that = this; that.value = filterValue; that.condition = condition; that.locale = locale || 'en'; that.type = 'stringFilter'; } evaluate(value) { const that = this, filterValue = that.value, condition = that.condition; if (value === null || value === undefined || value === '') { if (condition === 'NULL') return true; if (condition === 'EQUAL' && value === filterValue) { return true; } if (condition === 'NOT_EQUAL' && value !== filterValue) { return true; } if (condition !== 'EMPTY') return false; else if (value === '') return true; } let val = ''; try { val = value.toString(); } catch (error) { return true; } const compare = function (val, filterValue) { const locale = that.locale; switch (condition) { case 'EQUAL': return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0; case 'EQUAL_CASE_SENSITIVE': return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0; case 'NOT_EQUAL': return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) !== 0; case 'NOT_EQUAL_CASE_SENSITIVE': return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) !== 0; case 'CONTAINS': return val.toLowerCase().indexOf(filterValue.toLowerCase()) !== -1; case 'CONTAINS_CASE_SENSITIVE': return val.indexOf(filterValue) !== -1; case 'DOES_NOT_CONTAIN': return val.toLowerCase().indexOf(filterValue.toLowerCase()) === -1; case 'DOES_NOT_CONTAIN_CASE_SENSITIVE': return val.indexOf(filterValue) === -1; case 'EMPTY': return val === ''; case 'NOT_EMPTY': return val !== ''; case 'NOT_NULL': return val !== null; case 'STARTS_WITH': val = val.substring(0, filterValue.length); return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0; case 'ENDS_WITH': val = val.substring(val.length - filterValue.length, val.length); return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0; case 'ENDS_WITH_CASE_SENSITIVE': val = val.substring(val.length - filterValue.length, val.length); return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0; case 'STARTS_WITH_CASE_SENSITIVE': val = val.substring(0, filterValue.length); return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0; default: return false; } } const filterValues = new Array(); if (filterValue && filterValue.indexOf) if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) { const result = compare(val, filterValue); if (result) { return result; } const andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(), orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(), delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array(); let andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(), orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array(); if (delimiterFilters.length > 0) { for (let i = 0; i < delimiterFilters.length; i++) { delimiterFilters[i] = delimiterFilters[i].trim; } } const commaFilters = filterValue.indexOf(' ') >= 0 ? filterValue.split(' ') : new Array(); if (commaFilters.length > 0) { for (let i = 0; i < commaFilters.length; i++) { commaFilters[i] = commaFilters[i].trim; } } andFilters = andFilters.concat(commaFilters); andFilters = andFilters.concat(andLowerCaseFilters); orFilters = orFilters.concat(delimiterFilters); orFilters = orFilters.concat(orLowerCaseFilters); if (andFilters.length > 0) { for (let i = 0; i < andFilters.length; i++) { if (!andFilters[i].indexOf(' OR ') >= 0) { filterValues.push(andFilters[i]); } } } if (orFilters.length > 0) { for (let i = 0; i < orFilters.length; i++) { if (!orFilters[i].indexOf(' AND ') >= 0) { filterValues.push(orFilters[i]); } } } let filterresult = undefined; for (let j = 0; j < filterValues.length; j++) { const value = filterValues[j], result = compare(val, value), filteroperator = j < andFilters.length ? 'and' : 'or'; if (filterresult === undefined) { filterresult = result; } else { if (filteroperator === 'or') { filterresult = filterresult || result; } else { filterresult = filterresult && result; } } } return filterresult; } return compare(val, filterValue); } }); LW.Utilities.Assign('BooleanFilter', class BooleanFilter { constructor(filterValue, condition) { const that = this; that.value = filterValue; that.condition = condition; that.type = 'booleanFilter'; } evaluate(value) { const that = this, filterValue = that.value, condition = that.condition; const val = value; switch (condition) { case 'EQUAL': return val === filterValue; case 'NOT_EQUAL': return val !== filterValue; case 'NULL': return value === null || value === undefined || value === ''; case 'NOT_NULL': return !(value === null || value === undefined || value === ''); default: return false; } } }); LW.Utilities.Assign('NumericFilter', class NumericFilter { constructor(filterValue, condition) { const that = this; that.value = filterValue; that.condition = condition; that.type = 'numericFilter'; } evaluate(value) { const that = this; let filterValue = that.value, condition = that.condition; if (value === null || value === undefined || value === '') { if (condition === 'NOT_NULL') return false; if (condition === 'NULL') return true; else { switch (condition) { case 'EQUAL': return value === filterValue; case 'NOT_EQUAL': return value !== filterValue; } return false; } } else { if (condition === 'NULL') return false; if (condition === 'NOT_NULL') return true; } let val = value; try { val = parseFloat(val); } catch (error) { if (value.toString() !== '') return false; } const compare = function (val, filterValue) { if (typeof val === 'number' && typeof filterValue !== 'number') { filterValue = parseFloat(filterValue); } switch (condition) { case 'EQUAL': return val === filterValue; case 'NOT_EQUAL': return val !== filterValue; case 'GREATER_THAN': return val > filterValue; case 'GREATER_THAN_OR_EQUAL': return val >= filterValue; case 'LESS_THAN': return val < filterValue; case 'LESS_THAN_OR_EQUAL': return val <= filterValue; case 'STARTS_WITH': filterValue = filterValue.toString().toLowerCase(); return val.toString().toLowerCase().substring(0, filterValue.length) === filterValue; case 'ENDS_WITH': val = val.toString().toLowerCase(); filterValue = filterValue.toString().toLowerCase(); return val.substring(val.length - filterValue.length, val.length) === filterValue; case 'ENDS_WITH_CASE_SENSITIVE': val = val.toString(); filterValue = filterValue.toString(); return val.substring(val.length - filterValue.length, val.length) === filterValue; case 'STARTS_WITH_CASE_SENSITIVE': filterValue = filterValue.toString(); return val.toString().substring(0, filterValue.length) === filterValue; case 'CONTAINS': return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) !== -1; case 'CONTAINS_CASE_SENSITIVE': return val.toString().indexOf(filterValue.toString()) !== -1; case 'DOES_NOT_CONTAIN': return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) === -1; case 'DOES_NOT_CONTAIN_CASE_SENSITIVE': return val.toString().indexOf(filterValue.toString()) === -1; default: return true; } } let filterValues = new Array(); if (filterValue && filterValue.indexOf) if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) { let result = compare(val, filterValue); if (result) { return result; } filterValue = filterValue.toString(); const andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(), orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(), delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array(); let andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(), orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array(); andFilters = andFilters.concat(andLowerCaseFilters); orFilters = orFilters.concat(orLowerCaseFilters); if (delimiterFilters.length > 0) { for (let i = 0; i < delimiterFilters.length; i++) { delimiterFilters[i] = delimiterFilters[i].trim; } } orFilters = orFilters.concat(delimiterFilters); if (andFilters.length > 0) { for (let i = 0; i < andFilters.length; i++) { if (!andFilters[i].indexOf(' OR ') >= 0) { filterValues.push(andFilters[i]); } } } if (orFilters.length > 0) { for (let i = 0; i < orFilters.length; i++) { if (!orFilters[i].indexOf(' AND ') >= 0) { filterValues.push(orFilters[i]); } } } let filterresult = undefined; for (let j = 0; j < filterValues.length; j++) { const value = filterValues[j]; if (value && value.indexOf && value.indexOf('..') >= 0) { const values = value.toString().split('..'); if (values.length === 2) { result = val >= values[0] && val <= values[1]; } } else { result = compare(val, value); } const filteroperator = j < andFilters.length ? 'and' : 'or'; if (filterresult === undefined) { filterresult = result; } else { if (filteroperator === 'or') { filterresult = filterresult || result; } else { filterresult = filterresult && result; } } } return filterresult; } if (filterValue && filterValue.indexOf && filterValue.indexOf('..') >= 0) { filterValues = filterValue.toString().split('..'); if (filterValues.length === 2) { return val >= filterValues[0] && val <= filterValues[1]; } } return compare(val, filterValue); } }); LW.Utilities.Assign('DateFilter', class DateFilter { constructor(filterValue, condition, formatString, locale, timeOnly) { const that = this, parseAttemptDateTime = new LW.Utilities.DateTime(); that.value = filterValue; that.type = 'dateFilter'; if (formatString !== undefined) { const parsedDate = parseAttemptDateTime.parseDate(filterValue, formatString); if (parsedDate !== null) { that.filterdate = parsedDate; } else { const result = parseAttemptDateTime.tryparseDate(filterValue); if (result !== null) { that.filterdate = result; } } } else { const tmpvalue = new Date(filterValue); if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') { that.filterdate = parseAttemptDateTime.tryparseDate(filterValue); } else { that.filterdate = tmpvalue; } } if (!that.filterdate) { const tmpvalue = new Date(filterValue); if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') { that.filterdate = parseAttemptDateTime.tryparseDate(filterValue); } else { that.filterdate = tmpvalue; } } that.condition = condition; that.formatString = formatString; that.timeOnly = timeOnly; } evaluate(value) { const that = this, condition = that.condition, formatString = that.formatString; let filterValue = that.value; if (that.timeOnly) { return that.evaluateTimeOnly(value); } if (value === null || value === undefined || value === '') { if (condition === 'NOT_NULL') { return false; } if (condition === 'NULL') { return true; } else { switch (condition) { case 'EQUAL': return value === filterValue; case 'NOT_EQUAL': return value !== filterValue; } return false; } } else { if (condition === 'NULL') return false; if (condition === 'NOT_NULL') return true; } let val = new Date(), compareTimePart; val.setFullYear(1900, 0, 1); val.setHours(12, 0, 0, 0); try { const parseAttemptDateTime = new LW.Utilities.DateTime(), tmpvalue = new Date(value); if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') { value = parseAttemptDateTime.tryparseDate(value); } else { value = tmpvalue; } val = value; compareTimePart = false; if (formatString !== undefined) { if (formatString.indexOf('t') >= 0 || formatString.indexOf('T') >= 0 || formatString.indexOf(':') >= 0 || formatString.indexOf('f') >= 0) { compareTimePart = true; if (filterValue && filterValue.toString().indexOf(':') === -1) { const result = parseAttemptDateTime.tryparseDate(filterValue.toString() + ':00'); if (result !== null) { that.filterdate = result; } } } } if (!compareTimePart) { val.setHours(0); val.setMinutes(0); val.setSeconds(0); } } catch (error) { if (value.toString() !== '') return false; } if (that.filterdate !== null) { filterValue = that.filterdate; } else if (filterValue && filterValue.indexOf && (filterValue.indexOf(':') !== -1 || !isNaN(parseInt(filterValue)))) { const tmpFilter = new Date(val); tmpFilter.setHours(12, 0, 0, 0); const timeStrings = filterValue.split(':'); for (let i = 0; i < timeStrings.length; i++) { if (i === 0) { tmpFilter.setHours(timeStrings[i]); } if (i === 1) { tmpFilter.setMinutes(timeStrings[i]); } if (i === 2) { tmpFilter.setSeconds(timeStrings[i]); } } filterValue = tmpFilter; } if (compareTimePart) { if (filterValue && filterValue.setFullYear) { if (val && val.getFullYear) { if (formatString.indexOf('d') === -1 && formatString.indexOf('M') === -1 && formatString.indexOf('y') === -1) { filterValue.setFullYear(val.getFullYear(), val.getMonth(), val.getDate()); } } } } const compare = function (val, filterValue) { if (val === null) val = ''; switch (condition) { case 'EQUAL': return val.toString() === filterValue.toString(); case 'NOT_EQUAL': return val.toString() !== filterValue.toString(); case 'GREATER_THAN': return val > filterValue; case 'GREATER_THAN_OR_EQUAL': return val >= filterValue; case 'LESS_THAN': return val < filterValue; case 'LESS_THAN_OR_EQUAL': return val <= filterValue; case 'STARTS_WITH': filterValue = filterValue.toString().toLowerCase(); return val.toString().toLowerCase().substring(0, filterValue.length) === filterValue; case 'ENDS_WITH': val = val.toString().toLowerCase(); filterValue = filterValue.toString().toLowerCase(); return val.substring(val.length - filterValue.length, val.length) === filterValue; case 'ENDS_WITH_CASE_SENSITIVE': val = val.toString(); filterValue = filterValue.toString(); return val.substring(val.length - filterValue.length, val.length) === filterValue; case 'STARTS_WITH_CASE_SENSITIVE': filterValue = filterValue.toString(); return val.toString().substring(0, filterValue.length) === filterValue; case 'CONTAINS': return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) !== -1; case 'CONTAINS_CASE_SENSITIVE': return val.toString().indexOf(filterValue.toString()) !== -1; case 'DOES_NOT_CONTAIN': return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) === -1; case 'DOES_NOT_CONTAIN_CASE_SENSITIVE': return val.toString().indexOf(filterValue.toString()) === -1; default: return true; } } let filterValues = new Array(); if (filterValue && filterValue.indexOf) if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) { let result = compare(val, filterValue); if (result) { return result; } const andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(), orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(), delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array(); let andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(), orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array(); andFilters = andFilters.concat(andLowerCaseFilters); orFilters = orFilters.concat(orLowerCaseFilters); if (delimiterFilters.length > 0) { for (let i = 0; i < delimiterFilters.length; i++) { delimiterFilters[i] = delimiterFilters[i].trim; } } orFilters = orFilters.concat(delimiterFilters); if (andFilters.length > 0) { for (let i = 0; i < andFilters.length; i++) { if (!andFilters[i].indexOf(' OR ') >= 0) { filterValues.push(andFilters[i]); } } } if (orFilters.length > 0) { for (let i = 0; i < orFilters.length; i++) { if (!orFilters[i].indexOf(' AND ') >= 0) { filterValues.push(orFilters[i]); } } } let filterresult = undefined; for (let j = 0; j < filterValues.length; j++) { const value = filterValues[j]; if (value && value.indexOf && value.indexOf('..') >= 0) { const values = value.toString().split('..'); if (values.length === 2) { result = val >= values[0] && val <= values[1]; } } else { result = compare(val, value); } const filteroperator = j < andFilters.length ? 'and' : 'or'; if (filterresult === undefined) { filterresult = result; } else { if (filteroperator === 'or') { filterresult = filterresult || result; } else { filterresult = filterresult && result; } } } return filterresult; } if (filterValue && filterValue.indexOf && filterValue.indexOf('..') >= 0) { filterValues = filterValue.toString().split('..'); if (filterValues.length === 2) { return val >= filterValues[0] && val <= filterValues[1]; } } return compare(val, filterValue); } evaluateTimeOnly(value) { const that = this, filterValue = that.value; if (!filterValue) { if (!value) { return true; } return false; } else if (!value || !(value instanceof Date)) { return false; } const valueHours = value.getHours(), filterValueHours = filterValue.getHours(); if (valueHours !== filterValueHours) { return false; } const valueMinutes = value.getMinutes(), filterValueMinutes = filterValue.getMinutes(); if (valueMinutes !== filterValueMinutes) { return false; } const valueSeconds = value.getSeconds(), filterValueSeconds = filterValue.getSeconds(); if (valueSeconds !== filterValueSeconds) { return false; } return true; } }); LW.Utilities.Assign('CustomFilter', class CustomFilter { constructor(filterValue, condition, customfilter) { const that = this; that.value = filterValue; that.condition = condition; that.customfilter = customfilter; } evaluate(value) { const that = this; return that.customfilter(that.value, value, that.condition); } }); LW.FilterGroup = LW.Utilities.FilterGroup; LW.StringFilter = LW.Utilities.StringFilter; LW.NumericFilter = LW.Utilities.NumericFilter; LW.DateFilter = LW.Utilities.DateFilter; LW.CustomFilter = LW.Utilities.CustomFilter; /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // let bigIntNativeSupport; try { BigInt; bigIntNativeSupport = true; } catch (error) { bigIntNativeSupport = false; } // BigNumber class in LW.Utilities LW.Utilities.Assign('BigNumber', class UtilitiesBigNumber { //+ Jonas Raoni Soares Silva //@ http://jsfromhell.com/classes/bignumber [rev. #4] constructor(n, p, r) { var o = this, i; if (LW.Utilities.BigNumber.bigIntSupport) { if (n instanceof LW.Utilities.BigNumber) { if (Array.isArray(n._d)) { n = (n._s ? '-' : '') + (n._d.slice(0, n._f).join('') || '0') + (n._f != n._d.length ? '.' + n._d.slice(n._f).join('') : ''); } else { return new LW.Utilities.BigNumber(n._d); } } try { if (n === null) { o._d = BigInt(0); } else if (typeof n === 'string' && n.toLowerCase().indexOf('e') !== -1) { o._d = BigInt(parseFloat(n)); } else { o._d = BigInt(n); } } catch (error) { try { const numberParts = n.toString().split('.'); let result = BigInt(numberParts[0]), firstDecimalDigit = parseInt(numberParts[1].charAt(0)); if (result >= 0 && firstDecimalDigit >= 5) { result = result + BigInt(1); } else if (result < 0) { if (firstDecimalDigit > 5) { result = result - BigInt(1); } else if (firstDecimalDigit === 5) { let iterator = 1, nextChar = numberParts[1].charAt(iterator), roundDown = false; while (nextChar !== '') { iterator++; nextChar = numberParts[1].charAt(iterator); if (nextChar !== '0') { roundDown = true; break; } } if (roundDown) { result = result - BigInt(1); } } } o._d = result; } catch (error) { o._d = BigInt(0); } } o._f = o._d.toString().replace('-', '').length; o._s = o._d < 0; return; } if (n instanceof LW.Utilities.BigNumber) { if (typeof n._d === 'bigint') { return new LW.Utilities.BigNumber(n._d.toString()); } for (i in { precision: 0, roundType: 0, _s: 0, _f: 0 }) o[i] = n[i]; o._d = n._d.slice(); if (n._s && n._d.length === 1 && n._d[0] === 0) { // n is -0 o._s = false; } return; } if (n !== undefined) { if (n === '-0') { n = '0'; } // exponential notation support if (new RegExp(/e/i).test(n)) { var stringExponential = n.toString().toLowerCase(), indexOfE = stringExponential.indexOf('e'), mantissa = new LW.Utilities.BigNumber(stringExponential.slice(0, indexOfE)), exponent = stringExponential.slice(indexOfE + 2), sign = stringExponential.slice(indexOfE + 1, indexOfE + 2), bigTen = new LW.Utilities.BigNumber(10), multyplyBy = bigTen.pow(sign + exponent), result = mantissa.multiply(multyplyBy); n = result.toString(); } } o.precision = isNaN(p = Math.abs(p)) ? LW.Utilities.BigNumber.defaultPrecision : p; o.roundType = isNaN(r = Math.abs(r)) ? LW.Utilities.BigNumber.defaultRoundType : r; o._s = (n += '').charAt(0) == '-'; o._f = ((n = n.replace(/[^\d.]/g, '').split('.', 2))[0] = n[0].replace(/^0+/, '') || '0').length; for (i = (n = o._d = (n.join('') || '0').split('')).length; i; n[--i] = +n[i]); o.round(); } static get defaultPrecision() { return 40; } static get defaultRoundType() { return 4; } static get bigIntSupport() { return bigIntNativeSupport && LW.Utilities.BigNumber.ignoreBigIntNativeSupport !== true; } add(n) { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d + new LW.Utilities.BigNumber(n)._d); } let that = this.normalizeOperand(this); n = that.normalizeOperand(n); if (that.isZero() && that._s) { // that.toString() is '-0' that._s = false; } if (n === 0 || (n.constructor === LW.Utilities.BigNumber && n._d.length === 1 && n._d[0] === 0)) { return new LW.Utilities.BigNumber(that); } if (that._s != (n = new LW.Utilities.BigNumber(n))._s) return n._s ^= 1, that.subtract(n); var o = new LW.Utilities.BigNumber(that), a = o._d, b = n._d, la = o._f, lb = n._f, i, r; n = Math.max(la, lb); la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1)); i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length; for (r = 0; i; r = (a[--i] = a[i] + b[i] + r) / 10 >>> 0, a[i] %= 10); return r && ++n && a.unshift(r), o._f = n, o.round(); } subtract(n) { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d - new LW.Utilities.BigNumber(n)._d); } let that = this.normalizeOperand(this); n = that.normalizeOperand(n); if (that.isZero() && that._s) { // that.toString() is '-0' that._s = false; } if (n === 0 || (n.constructor === LW.Utilities.BigNumber && n._d.length === 1 && n._d[0] === 0)) { return new LW.Utilities.BigNumber(that); } if (that._s != (n = new LW.Utilities.BigNumber(n))._s) return n._s ^= 1, that.add(n); var o = new LW.Utilities.BigNumber(that), c = o.abs().compare(n.abs()) + 1, a = c ? o : n, b = c ? n : o, la = a._f, lb = b._f, d = la, i, j; a = a._d, b = b._d, la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1)); for (i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length; i;) { if (a[--i] < b[i]) { for (j = i; j && !a[--j]; a[j] = 9); --a[j], a[i] += 10; } b[i] = a[i] - b[i]; } return c || (o._s ^= 1), o._f = d, o._d = b, o.round(); } multiply(n) { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d * new LW.Utilities.BigNumber(n)._d); } let that = this.normalizeOperand(this); n = that.normalizeOperand(n); var o = new LW.Utilities.BigNumber(that), r = o._d.length >= (n = new LW.Utilities.BigNumber(n))._d.length, a = (r ? o : n)._d, b = (r ? n : o)._d, la = a.length, lb = b.length, x = new LW.Utilities.BigNumber, i, j, s; for (i = lb; i; r && s.unshift(r), x.set(x.add(new LW.Utilities.BigNumber(s.join(''))))) for (s = (new Array(lb - --i)).join('0').split(''), r = 0, j = la; j; r += a[--j] * b[i], s.unshift(r % 10), r = (r / 10) >>> 0); return o._s = o._s != n._s, o._f = ((r = la + lb - o._f - n._f) >= (j = (o._d = x._d).length) ? that._zeroes(o._d, r - j + 1, 1).length : j) - r, o.round(); } divide(n) { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d / new LW.Utilities.BigNumber(n)._d); } let that = this.normalizeOperand(this); n = that.normalizeOperand(n); if ((n = new LW.Utilities.BigNumber(n)) == '0') throw new Error('Division by 0'); else if (that == '0') return new LW.Utilities.BigNumber; var o = new LW.Utilities.BigNumber(that), a = o._d, b = n._d, la = a.length - o._f, lb = b.length - n._f, r = new LW.Utilities.BigNumber, i = 0, j, s, l, f = 1, c = 0, e = 0; r._s = o._s != n._s, r.precision = Math.max(o.precision, n.precision), r._f = +r._d.pop(), la != lb && o._zeroes(la > lb ? b : a, Math.abs(la - lb)); n._f = b.length, b = n, b._s = false, b = b.round(); for (n = new LW.Utilities.BigNumber; a[0] == '0'; a.shift()); out: do { for (l = c = 0, n == '0' && (n._d = [], n._f = 0); i < a.length && n.compare(b) == -1; ++i) { (l = i + 1 == a.length, (!f && ++c > 1 || (e = l && n == '0' && a[i] == '0'))) && (r._f == r._d.length && ++r._f, r._d.push(0)); (a[i] == '0' && n == '0') || (n._d.push(a[i]), ++n._f); if (e) break out; if ((l && n.compare(b) == -1 && (r._f == r._d.length && ++r._f, 1)) || (l = 0)) while (r._d.push(0), n._d.push(0), ++n._f, n.compare(b) == -1); } if (f = 0, n.compare(b) == -1 && !(l = 0)) while (l ? r._d.push(0) : l = 1, n._d.push(0), ++n._f, n.compare(b) == -1); var y; for (s = new LW.Utilities.BigNumber, j = 0; n.compare(y = s.add(b)) + 1 && ++j; s.set(y)); n.set(n.subtract(s)), !l && r._f == r._d.length && ++r._f, r._d.push(j); } while ((i < a.length || n != '0') && (r._d.length - r._f) <= r.precision); return r.round(); } mod(n) { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d % new LW.Utilities.BigNumber(n)._d); } let that = this.normalizeOperand(this); n = that.normalizeOperand(n); var result = that.subtract(that.divide(n).intPart().multiply(n)); if (result.isZero() && result._s) { result._s = !(result._s); } return result; } pow(n) { if (LW.Utilities.BigNumber.bigIntSupport) { let result = BigInt(1); for (let i = BigInt(0); i < new LW.Utilities.BigNumber(n)._d; i = i + BigInt(1)) { result = result * this._d; } return new LW.Utilities.BigNumber(result); // Use the following solution when UglifyJS supports ** //return new LW.Utilities.BigNumber(this._d ** new LW.Utilities.BigNumber(n)._d); } let that = this.normalizeOperand(this); n = that.normalizeOperand(n); var o = new LW.Utilities.BigNumber(that), i; if ((n = (new LW.Utilities.BigNumber(n)).intPart()) == 0) return o.set(1); for (i = Math.abs(n); --i; o.set(o.multiply(that))); return n < 0 ? o.set((new LW.Utilities.BigNumber(1)).divide(o)) : o; } set(n) { n = new LW.Utilities.BigNumber(n); this._d = n._d; this._f = n._f; this._s = n._s; return this; } compare(n) { if (LW.Utilities.BigNumber.bigIntSupport) { const otherNumber = new LW.Utilities.BigNumber(n)._d; if (this._d === otherNumber) { return 0; } if (this._d > otherNumber) { return 1; } return -1; } let that = this.normalizeOperand(this); n = that.normalizeOperand(n); var a = that, la = that._f, b = new LW.Utilities.BigNumber(n), lb = b._f, r = [-1, 1], i, l, arr; if (a.isZero() && b.isZero()) { return 0; } if (a._s != b._s) return a._s ? -1 : 1; if (la != lb) return r[(la > lb) ^ a._s]; for (la = (arr = a._d).length, lb = (b = b._d).length, i = -1, l = Math.min(la, lb); ++i < l;) if (arr[i] != b[i]) return r[(arr[i] > b[i]) ^ a._s]; return la != lb ? r[(la > lb) ^ a._s] : 0; } negate() { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d * BigInt(-1)); } let that = this.normalizeOperand(this); var n = new LW.Utilities.BigNumber(that); return n._s ^= 1, n; } abs() { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d < 0 ? this._d * BigInt(-1) : this._d); } let that = this.normalizeOperand(this); var n = new LW.Utilities.BigNumber(that); return n._s = 0, n; } intPart() { if (LW.Utilities.BigNumber.bigIntSupport) { return new LW.Utilities.BigNumber(this._d); } let that = this.normalizeOperand(this); return new LW.Utilities.BigNumber((that._s ? '-' : '') + (that._d.slice(0, that._f).join('') || '0')); } valueOf(radix, wordLength) { let that = this.normalizeOperand(this); return that.toString(radix, wordLength); } toString(radix, wordLength, leadingZeros) { function negativeBinary(result, radix, wordLength) { var reversedResult = ''; if (String.prototype.repeat) { var zeroPadding = '0'.repeat(wordLength - result.length); result = zeroPadding + result; } { while (result.length < wordLength) { result = '0' + result; } } reversedResult = result.replace(/0/g, 'a'); reversedResult = reversedResult.replace(/1/g, 'b'); reversedResult = reversedResult.replace(/a/g, '1'); reversedResult = reversedResult.replace(/b/g, '0'); var plusOne = true; var finalResult = ''; for (var j = reversedResult.length - 1; j >= 0; j--) { var currentDigit = reversedResult.charAt(j); var newDigit; if (currentDigit === '0') { if (plusOne === true) { newDigit = '1'; plusOne = false; } else { newDigit = '0'; } } else { if (plusOne === true) { newDigit = '0'; } else { newDigit = '1'; } } finalResult = newDigit + '' + finalResult; } switch (radix) { case 2: return finalResult; case 8: var totalOct, zeroesToAdd; switch (wordLength) { case 8: totalOct = 3; zeroesToAdd = '0'; break; case 16: totalOct = 6; zeroesToAdd = '00'; break; case 32: totalOct = 11; zeroesToAdd = '0'; break; case 64: totalOct = 22; zeroesToAdd = '00'; break; } finalResult = zeroesToAdd + finalResult; var octResult = ''; for (var k = totalOct; k >= 1; k--) { var currentOct = finalResult[k * 3 - 3] + '' + finalResult[k * 3 - 2] + '' + finalResult[k * 3 - 1]; octResult = parseInt(currentOct, 2).toString(8) + '' + octResult; } return octResult; case 16: var totalHex; switch (wordLength) { case 8: totalHex = 2; break; case 16: totalHex = 4; break; case 32: totalHex = 8; break; case 64: totalHex = 16; break; } var hexResult = ''; for (var l = totalHex; l >= 1; l--) { var currentHex = finalResult[l * 4 - 4] + '' + finalResult[l * 4 - 3] + '' + finalResult[l * 4 - 2] + '' + finalResult[l * 4 - 1]; hexResult = parseInt(currentHex, 2).toString(16) + '' + hexResult; } return hexResult.toUpperCase(); } } function toBinary(positiveNumber) { var two = new LW.Utilities.BigNumber(2), remainder, remaindersArray = [], temp; if (positiveNumber === undefined) { temp = o; } else { temp = positiveNumber; } do { remainder = temp.mod(two); remaindersArray.push(remainder.toString()); temp = temp.subtract(remainder).divide(two).intPart(); } while (temp.compare(new LW.Utilities.BigNumber(0)) === 1); return remaindersArray.reverse().join(''); } function toOctal(binary) { var result = ''; while (binary.length % 3 !== 0) { binary = '0' + binary; } for (var k = binary.length / 3; k >= 1; k--) { var currentOct = binary[k * 3 - 3] + '' + binary[k * 3 - 2] + '' + binary[k * 3 - 1]; result = parseInt(currentOct, 2).toString(8) + '' + result; } return result; } function toHexadecimal(binary) { var result = ''; while (binary.length % 4 !== 0) { binary = '0' + binary; } for (var l = binary.length / 4; l >= 1; l--) { var currentHex = binary[l * 4 - 4] + '' + binary[l * 4 - 3] + '' + binary[l * 4 - 2] + '' + binary[l * 4 - 1]; result = parseInt(currentHex, 2).toString(16) + '' + result; } return result; } let o, decimal; if (LW.Utilities.BigNumber.bigIntSupport) { o = this; if (Array.isArray(o._d)) { decimal = (o._s ? '-' : '') + (o._d.slice(0, o._f).join('') || '0') + (o._f != o._d.length ? '.' + o._d.slice(o._f).join('') : ''); } else { decimal = this._d.toString(); } } else { o = this.normalizeOperand(this); decimal = (o._s ? '-' : '') + (o._d.slice(0, o._f).join('') || '0') + (o._f != o._d.length ? '.' + o._d.slice(o._f).join('') : ''); } if (radix === undefined || radix === 10) { return decimal; } let result; if (o.compare(0) > -1) { switch (radix) { case 2: result = toBinary(); if (leadingZeros) { result = result.padStart(wordLength, '0'); } break; case 8: result = toOctal(toBinary()); break; case 16: result = toHexadecimal(toBinary()).toUpperCase(); if (leadingZeros) { result = result.padStart(wordLength / 4, '0'); } break; } } else { var positiveNumber = o.negate(), positiveBinary = toBinary(positiveNumber); result = negativeBinary(positiveBinary, radix, wordLength); } return result; } _zeroes(n, l, t) { var s = ['push', 'unshift'][t || 0]; for (++l; --l; n[s](0)); return n; } round() { if ('_rounding' in this) return this; var $ = LW.Utilities.BigNumber, r = this.roundType, b = this._d, d, p, n, x; for (this._rounding = true; this._f > 1 && !b[0]; --this._f, b.shift()); for (d = this._f, p = this.precision + d, n = b[p]; b.length > d && !b[b.length - 1]; b.pop()); x = (this._s ? '-' : '') + (p - d ? '0.' + this._zeroes([], p - d - 1).join('') : '') + 1; if (b.length > p) { n && (r == $.DOWN ? false : r == $.UP ? true : r == $.CEIL ? !this._s : r == $.FLOOR ? this._s : r == $.HALF_UP ? n >= 5 : r == $.HALF_DOWN ? n > 5 : r == $.HALF_EVEN ? n >= 5 && b[p - 1] & 1 : false) && this.add(x); b.splice(p, b.length - p); } return delete this._rounding, this; } isZero() { return this._d.length === 1 && this._d[0] === 0; } normalizeOperand(n) { if (n instanceof LW.Utilities.BigNumber && typeof n._d === 'bigint') { return new LW.Utilities.BigNumber(n._d.toString()); } return n; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-input', class Input extends LW.BaseElement { // Button's properties. static get properties() { return { 'autoCompleteDelay': { value: 100, type: 'number' }, 'dataSource': { type: 'any', value: [], reflectToAttribute: false }, 'dropDownDataSource': { type: 'any', value: [] }, 'dropDownHeight': { type: 'any', value: 200 }, 'dropDownWidth': { type: 'any', value: null }, 'dropDownButtonPosition': { allowedValues: ['none', 'left', 'right'], value: 'none', type: 'string' }, 'hint': { type: 'string', value: '' }, 'inputPurpose': { type: 'string', value: 'off' }, 'items': { type: 'number', value: 8 }, 'minLength': { type: 'number', value: 1 }, 'name': { value: '', type: 'string' }, 'opened': { value: false, type: 'boolean' }, 'query': { type: 'string', value: '' }, 'queryMode': { allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'], type: 'string', value: 'containsIgnoreCase' }, 'placeholder': { value: '', type: 'string' }, 'readonly': { type: 'boolean', value: false }, 'sorted': { value: false, type: 'boolean' }, 'sortDirection': { value: 'asc', type: 'string' }, 'type': { type: 'string' }, 'value': { type: 'string', value: '' } }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.textbox.css' ] } /** Input's template. */ template() { return '<div id="inputContainer" role="presentation"><input class="lw-input" id=\'input\' readonly=\'[[readonly]]\' placeholder=\'[[placeholder]]\' type=\'[[type]]\' name=\'[[name]]\' value=\'{{value::keyup}}\' disabled=\'[[disabled]]\' aria-label="[[placeholder]]" /><span class="lw-hidden lw-hint" id="span">[[hint]]</span><div id="dropDownButton" tabindex=-1 class="lw-drop-down-button" role="button" aria-label="Toggle popup"><div id="arrow" class="arrow" aria-hidden="true"></div></div></div>'; } static get listeners() { return { 'input.focus': '_focusHandler', 'input.blur': '_blurHandler', 'input.keydown': '_keyDownHandler', 'input.keyup': '_keyUpHandler', 'input.keypress': '_keyPressHandler', 'dropDownButton.down': '_dropDownButtonDownHandler', 'inputContainer.down': '_downHandler', 'document.up': '_documentUpHandler' }; } focus() { const that = this; that.$.input.focus(); } select() { const that = this; if (!that.readonly) { that.$.input.select(); } else { that.$.input.focus(); } } _documentUpHandler(event) { const that = this; const target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (target === that || target === that.$.dropDownButton || target === that.$.input || target === that.$.arrow) { return; } if (that.$.scrollView.contains(target.shadowParent || target)) { if (that._isPointerDown) { that._isPointerDown = false; if (that.opened) { that._preventLookup = true; } that.$.input.focus(); } return; } if (that.opened) { that._preventLookup = true; } if (!that._isPointerDown) { that.close(); } that._isPointerDown = false; } _focusHandler() { const that = this; that.setAttribute('focus', ''); if (!that.readonly && that.minLength === 0 && that.$.input.value.length === 0 && !that._preventLookup) { that._lookup(); return; } that.$.fireEvent('focus'); delete that._preventLookup; } _blurHandler() { const that = this; if (!that.opened) { that.removeAttribute('focus'); } that.$.fireEvent('blur'); delete that._preventLookup; } _refreshMenu() { const that = this; that.$.menu.classList.remove('scroll'); if (that.$.scrollView.computedVerticalScrollBarVisibility) { that.$.menu.classList.add('scroll'); } } _performSelect() { const that = this; const targetItem = that.$.menu.querySelector('.active'), label = targetItem.getAttribute('data-label'), value = targetItem.getAttribute('value'), oldLabel = that.value, oldValue = that.$.input.dataValue; that.value = label; that.$.input.dataValue = value; if (label !== oldLabel || value !== oldValue) { that.$.fireEvent('change', { value: value, label: label, oldValue: oldValue, oldLabel: oldLabel }); } that.close(); } _open() { const that = this; if (that.opened) { return; } const rect = that.getBoundingClientRect(), scrollX = window.scrollX, scrollY = window.scrollY; let xCorrection = 0, yCorrection = 0; if (that.timer) { clearTimeout(that.timer); } if (that.getRootNode() && that.getRootNode().host) { that.getRootNode().host.shadowRoot.appendChild(that.$.scrollView); } else { document.body.appendChild(that.$.scrollView); } that.setAttribute('aria-owns', that.$.scrollView.id); if (!that.readonly) { that.$.input.setAttribute('aria-controls', that.$.scrollView.id); } if (that.$.scrollView.enableShadowDOM && !that._importedStyle) { that.$.scrollView.importStyle(that._getStyleUrl('lw.textbox.css')); that._importedStyle = true; } if (getComputedStyle(document.body).position !== 'static') { const bodyRect = document.body.getBoundingClientRect(); xCorrection = bodyRect.left; yCorrection = bodyRect.top; } that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', ''); that.$.scrollView.style.left = -3 + rect.left + scrollX - xCorrection + 'px'; that.$.scrollView.style.top = rect.bottom + scrollY - yCorrection + 1 + 'px'; that.$.scrollView.classList.remove('open'); that.$.scrollView.onpointerdown = function () { that._isPointerDown = true; } requestAnimationFrame(function () { const dropDownWidth = that.dropDownWidth; if (that.$.scrollView.refresh) { that.$.scrollView.refresh(); } that._refreshMenu(); that.$.scrollView.setAttribute('open', ''); that.setAttribute('open', ''); that.$.dropDownButton.setAttribute('open', ''); that.$.input.setAttribute('open', ''); if (dropDownWidth && typeof dropDownWidth === 'string' && dropDownWidth.indexOf('%') !== -1) { const fraction = parseFloat(dropDownWidth) / 100; that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', that.offsetWidth * fraction + 'px'); } else if (dropDownWidth !== 'auto' && dropDownWidth) { that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', parseFloat(dropDownWidth) + 'px'); } else if (dropDownWidth === 'auto') { that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', ''); if (that.$.scrollView.$.scrollViewerContainer.classList.contains('vscroll')) { // compensates for scrollbar's width const autoWidth = that.$.scrollView.offsetWidth + parseFloat(getComputedStyle(that.$.scrollView).getPropertyValue('--lw-scroll-bar-size')); that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', autoWidth + 'px'); } } else { that.$.menu.style.width = 'auto'; let menuWidth = that.$.menu.offsetWidth; const listItems = that.$.menu.querySelectorAll('li'); for (let i = 0; i < listItems.length; i++) { that._maxDropDownWidth = Math.max((listItems[i].firstElementChild || listItems[i]).offsetWidth, that._maxDropDownWidth); } if (that.$.scrollView.computedVerticalScrollBarVisibility) { menuWidth += that.$.scrollView.$ && that.$.scrollView.$.verticalScrollBar ? that.$.scrollView.$.verticalScrollBar.offsetWidth : 30; } that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', Math.max(menuWidth, that.offsetWidth - 8) + 'px'); that.$.menu.style.width = ''; } //ShadowDOM ScrollBar styles are not loaded when the method is invoked if ((that.shadowRoot || that.isInShadowDOM) && that.$.scrollView._scrollView && LW.ScrollBar) { requestAnimationFrame(() => that.$.scrollView._scrollView.vScrollBar.refresh()); } }); if (that.$.scrollView.refresh) { that.$.scrollView.refresh(); } that._refreshMenu(); this.opened = true; that.setAttribute('aria-expanded', true); } close() { const that = this; if (!that.opened) { return false; } if (that.timer) { clearTimeout(that.timer); } that.timer = setTimeout(function () { if (that.$.scrollView.parentNode && !that.opened) { that.$.scrollView.remove(); that.removeAttribute('aria-owns'); if (!that.readonly) { that.$.input.removeAttribute('aria-controls'); } } }, 1000); that.$.scrollView.removeAttribute('open'); that.$.dropDownButton.removeAttribute('open'); that.$.input.removeAttribute('open'); that.removeAttribute('open'); that.opened = false; that.setAttribute('aria-expanded', false); that.$.input.focus(); return true; } _lookup(event) { const that = this; let items = []; that.query = that.$.input.value; if (that.$.input.readonly) { if (!that._incrementalSearchQuery) { that._incrementalSearchQuery = ''; } that._incrementalSearchQuery += event.key; if (that._incrementalSearchTimer) { clearTimeout(that._incrementalSearchTimer); } that.query = that._incrementalSearchQuery; that._incrementalSearchTimer = setTimeout(function () { that._incrementalSearchQuery = ''; }, 700); } if (that.query.length < that.minLength) { that.close(); return; } items = typeof that.dataSource === 'function' ? that.dataSource(that.query) : that.dataSource; clearTimeout(that._autoCompleteTimeout); that._autoCompleteTimeout = setTimeout(function () { const oldContext = that.context; that.context = that; that._process(items); that.context = oldContext; }, that.autoCompleteDelay); } _downHandler(event) { const that = this; if (that.readonly) { that._dropDownButtonDownHandler(event); } } _dropDownButtonDownHandler(event) { const that = this; that._toggle(); event.preventDefault(); event.stopPropagation(); event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); return false; } _toggle() { const that = this; if (that.opened) { that.close(); } else { that.open(); } } open() { const that = this; let items; if (!that.dropDownDataSource) { items = typeof that.dropDownDataSource === 'function' ? that.dropDownDataSource(that.query) : that.dropDownDataSource; } else { that.query = ''; items = typeof that.dataSource === 'function' ? that.dataSource(that.query) : that.dataSource; } that._process(items); const active = that.$.menu.querySelector('.active'); if (active) { const dataValue = that.$.input.dataValue; for (let i = 0; i < that.$.menu.children.length; i++) { const item = that.$.menu.children[i]; const label = item.getAttribute('data-label'), value = item.getAttribute('value'); if (dataValue !== undefined && value === dataValue || dataValue === undefined && label === that.$.input.value) { active.classList.remove('active'); item.classList.add('active'); that._setActiveDescendant(item); that.$.input.dataValue = value; break; } } } that.ensureVisible(); that.$.input.focus(); setTimeout(function () { that.$.input.focus(); }, 25); } _process(items) { const that = this; if (typeof items === 'string') { items = that.$.deserialize(items, 'array'); } items = items.filter(function (item) { return that.matcher ? that.matcher(item) : that._matcher(item); }) items = that._sorter(items); if (that.sorted) { items.sort((a, b) => { if (a.label !== undefined) { return a.label.localeCompare(b.label); } return a.localeCompare(b); }); if (that.sortDirection === 'desc') { items.reverse(); } } if (!items.length && that.opened) { that.close(); } if (items.length === 0) { return; } if (that.query.length > 0) { that._render(items.slice(0, that.items)); } else { that._render(items); } that._open(); if (that.$.scrollView.refresh) { that.$.scrollView.refresh(); } that._refreshMenu(); that.ensureVisible(); } _matcher(item) { const that = this; const text = that.query; item = item.label || item; switch (that.queryMode) { case 'startsWith': return item.startsWith(text); case 'startsWithIgnoreCase': return item.toLowerCase().startsWith(text.toLowerCase()); case 'doesNotContain': return item.indexOf(text) < 0; case 'doesNotContainIgnoreCase': return item.toLowerCase().indexOf(text.toLowerCase()) < 0; case 'contains': return item.indexOf(text) > -1; default: case 'containsIgnoreCase': return ~item.toLowerCase().indexOf(text.toLowerCase()); case 'equals': return item.localeCompare(text) === 0; case 'equalsIgnoreCase': return (item.toLowerCase().localeCompare(text.toLowerCase()) === 0); case 'endsWith': return item.endsWith(text); case 'endsWithIgnoreCase': return item.toLowerCase().endsWith(text.toLowerCase()); } } _sorter(items) { const that = this; let beginswith = [] , caseSensitive = [] , caseInsensitive = [] , item // eslint-disable-next-line while (item = items.shift()) { const label = item.label || item; if (!label.toLowerCase().indexOf(that.query.toLowerCase())) { beginswith.push(item) } else if (~label.indexOf(that.query)) { caseSensitive.push(item) } else { caseInsensitive.push(item) } } return beginswith.concat(caseSensitive, caseInsensitive) } _highlighter(item) { const that = this; const query = that.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&'); return item.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) { return '<strong>' + match + '</strong>' }) } _render(items) { const that = this; const listItems = items.map(function (item) { let label = item, value = item; if (typeof item === 'object') { label = item.label; value = item.value || label; } const listItem = document.createElement('li'); const anchor = document.createElement('a'); anchor.href = '#'; listItem.id = that.id + 'Item' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); listItem.setAttribute('data-label', label); listItem.setAttribute('value', value); listItem.setAttribute('role', 'option'); listItem.setAttribute('aria-label', label); anchor.innerHTML = that.highlighter ? that.highlighter(label) : that._highlighter(label); anchor.setAttribute('aria-hidden', true); if (item.icon) { anchor.classList.add('icon'); anchor.classList.add(item.icon); } listItem.appendChild(anchor); return listItem; }) if (listItems.length > 0) { listItems[0].classList.add('active'); that._setActiveDescendant(listItems[0]); } that.$.menu.innerHTML = ''; function setActiveState() { const previouslyActive = that.$.menu.getElementsByClassName('active'); if (previouslyActive[0]) { previouslyActive[0].classList.remove('active'); } this.classList.add('active'); that._setActiveDescendant(this); } for (let i = 0; i < listItems.length; i++) { const listItem = listItems[i]; that.$.menu.appendChild(listItem); listItem.onmouseenter = setActiveState; listItem.onmouseleave = function () { this.classList.remove('active'); that._setActiveDescendant(null); } listItem.onclick = setActiveState; } } ensureVisible() { const that = this; const item = that.$.menu.querySelector('.active'); if (!item) { return; } if (item.offsetTop + item.offsetHeight >= that.$.scrollView.scrollTop + that.$.scrollView.offsetHeight) { that.$.scrollView.scrollTop = item.offsetTop + item.offsetHeight; } if (item.offsetTop <= that.$.scrollView.scrollTop || item.offsetTop >= that.$.scrollView.scrollTop + that.$.scrollView.offsetHeight) { that.$.scrollView.scrollTop = item.offsetTop; } if ([...that.$.menu.children].indexOf(item) === 0) { that.$.scrollView.scrollTop = 0; } else if ([...that.$.menu.children].indexOf(item) === that.$.menu.children.length - 1) { that.$.scrollView.scrollTop = that.$.scrollView.scrollHeight; } } _next() { const that = this; const active = that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; first.classList.add('active'); that._setActiveDescendant(first); return; } active.classList.remove('active'); let next = active.nextElementSibling; if (!next) { next = that.$.menu.firstElementChild; } next.classList.add('active'); that._setActiveDescendant(next); that.ensureVisible(); } _prev() { const that = this; const active = that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; first.classList.add('active'); that._setActiveDescendant(first); return; } active.classList.remove('active'); let prev = active.previousElementSibling; if (!prev) { prev = that.$.menu.lastElementChild; } prev.classList.add('active'); that._setActiveDescendant(prev); that.ensureVisible(); } _move(event) { const that = this; if (!that.opened) { return; } switch (event.keyCode) { case 9: // tab case 13: // enter case 27: // escape event.preventDefault() break case 38: // up arrow event.preventDefault() that._prev() break case 40: // down arrow event.preventDefault() that._next() break } event.stopPropagation() } _keyDownHandler(event) { const that = this; that._suppressKeyPressRepeat = ![40, 38, 9, 13, 27, 16, 17, 18].includes(event.keyCode); if (event.shiftKey || event.altKey || event.ctrlKey) { return; } that._move(event); } _keyPressHandler(event) { const that = this; if (that._suppressKeyPressRepeat) { return; } if (event.shiftKey || event.altKey || event.ctrlKey) { return; } that._move(event) } _keyUpHandler(event) { const that = this; if (event.shiftKey) { return; } switch (event.keyCode) { case 40: // down arrow case 38: // up arrow case 16: // shift case 17: // ctrl case 18: // alt if (event.keyCode === 40 && event.altKey) { that.open(); } if (event.keyCode === 38 && event.altKey) { that.close(); } break; case 9: // tab case 13: // enter if (!that.opened) { return; } that._performSelect(); event.stopPropagation() event.preventDefault() break case 27: // escape if (!that.opened) { return; } that.close(); event.stopPropagation() event.preventDefault() break default: that._lookup(event); if (that.opened && !event.ctrlKey && !event.shiftKey) { event.stopPropagation() event.preventDefault() } that.$.input.dataValue = that.$.input.value; } } propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (propertyName === 'dropDownHeight') { that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-height', that.dropDownHeight + 'px'); } else if (propertyName === 'opened') { that.opened = oldValue; if (newValue) { that.open(); } else { that.close(); } } else if (propertyName === 'placeholder') { if (that.readonly) { const label = that.getAttribute('aria-label'); if (label && label !== oldValue) { return; } if (newValue) { that.setAttribute('aria-label', newValue); } else { that.removeAttribute('aria-label'); } } } else if (propertyName === 'value') { if (that.displayMember !== that.valueMember && typeof newValue !== 'string') { that.value = newValue[that.displayMember]; that.$.input.dataValue = newValue[that.valueMember]; } else { that.$.input.value = newValue; } } else if (propertyName === 'readonly') { that._setAriaRelations(); that._setInputPurpose(); } else if (propertyName === 'theme' || propertyName === 'rightToLeft') { that.$.scrollView[propertyName] = newValue; } else if (propertyName === 'inputPurpose') { that._setInputPurpose(); } else if (propertyName === 'inverted') { newValue ? that.$.scrollView.setAttribute('inverted', '') : that.$.scrollView.removeAttribute('inverted'); } } render() { const that = this; if (!that.hint) { that.hint = that.placeholder; } if (that._createElement) { that._createElement(); } if (that.opened) { that.opened = false; that.open(); } const scrollView = that.$.scrollView; const menu = that.$.menu; if (menu) { menu.setAttribute('role', 'presentation'); scrollView.appendChild(menu); } scrollView.style.setProperty('--lw-input-drop-down-menu-height', that.dropDownHeight + 'px'); scrollView.classList.add('lw-input-drop-down-menu'); scrollView.id = that.id + '_' + that.tagName.toLowerCase() + '_menu_' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); scrollView.ownerElement = that; that._setAriaRelations(); that._setInputPurpose(); super.render(); } _createElement() { const that = this; const menu = document.createElement('ul'); const scrollView = document.createElement('lw-scroll-viewer'); scrollView.rightToLeft = that.rightToLeft; scrollView.theme = that.theme; scrollView.horizontalScrollBarVisibility = 'hidden'; that.inverted ? scrollView.setAttribute('inverted', '') : scrollView.removeAttribute('inverted'); that.$.scrollView = scrollView; that.$.menu = menu; //that.$.inputContainer.tabIndex = 0; that.$.menu.onclick = function (event) { event.stopPropagation() event.preventDefault() that._performSelect(); that.$.input.focus(); } } /** * Sets WAI-ARIA relations. */ _setAriaRelations() { const that = this, label = that.getAttribute('aria-label'); if (that.readonly) { that.setAttribute('role', 'button'); if (!label && that.placeholder) { that.setAttribute('aria-label', that.placeholder); } that.removeAttribute('aria-readonly'); that.$.input.setAttribute('aria-hidden', true); that.$.input.removeAttribute('aria-activedescendant'); that.$.input.removeAttribute('aria-controls'); that.$.dropDownButton.setAttribute('aria-hidden', true); } else { that.setAttribute('role', 'combobox'); if (label && label === that.placeholder) { that.removeAttribute('aria-label'); } that.$.input.setAttribute('role', 'searchbox'); that.$.input.removeAttribute('aria-hidden', true); that.$.dropDownButton.removeAttribute('aria-hidden'); } that.setAttribute('aria-expanded', that.opened); that.setAttribute('aria-haspopup', 'listbox'); that.$.scrollView.setAttribute('role', 'listbox'); } /** * Sets WAI-ARIA property aria-activedescendant. */ _setActiveDescendant(item) { const that = this; if (!that.readonly) { if (item) { that.setAttribute('aria-activedescendant', item.id); } else { that.removeAttribute('aria-activedescendant'); } } } /** * Sets the HTML autocomplete attribute based on the property "inputPurpose". */ _setInputPurpose() { const that = this; if (that.readonly) { that.$.input.removeAttribute('autocomplete'); } else { that.$.input.setAttribute('autocomplete', that.inputPurpose); } } }); LW('lw-text-area', class TextArea extends LW.Input { /** Input's template. */ template() { return '<div id="inputContainer" role="presentation"><textarea class="lw-input" id=\'input\' readonly=\'[[readonly]]\' placeholder=\'[[placeholder]]\' name=\'[[name]]\' value=\'{{value::keyup}}\' disabled=\'[[disabled]]\' aria-label="[[placeholder]]"></textarea><span class="lw-hidden lw-hint" id="span">[[hint]]</span><div id="dropDownButton" tabindex=-1 class="lw-drop-down-button" role="button" aria-label="Toggle popup"><div id="arrow" class="arrow" aria-hidden="true"></div></div></div>'; } render() { const that = this; super.render(); that.classList.add('lw-input'); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'DragDrop', class DragDrop { constructor ( element ) { const that = this; that.ownerElement = element; that._dragDetails = null; that._items = null; that._showFeedback = true; } capture( item, event ) { const that = this; that._dragDetails = { element: item.element || item, item: item, x: event.pageX, y: event.pageY }; } get isDragging() { return this.feedback !== null; } get items() { return this._items; } set items( value ) { this._items = value; } get showFeedback() { return this._showFeedback; } set showFeedback( value ) { this._showFeedback = value; } findTarget( event ) { const that = this; let originalTarget = null; if ( !that._itemCoordinates ) { return null; } for ( let i = 0; i < that._itemCoordinates.coordinates.length; i++ ) { that._itemCoordinates.coordinates[ i ].forEach( ( item, index ) => { if ( that._items[ index ] && ( that._items[ index ].classList.contains( 'lw-visibility-hidden' ) || that._items[ index ].classList.contains( 'lw-hidden' ) ) ) { return true; } if ( that._items[ item.index ] && ( that._items[ item.index ].classList.contains( 'lw-visibility-hidden' ) || that._items[ item.index ].classList.contains( 'lw-hidden' ) ) ) { return true; } const rect = item.rect; if ( rect.top <= event.clientY ) { if ( rect.left <= event.clientX ) { originalTarget = that._items[ item.index ]; } } } ) } return originalTarget; } createFeedback( event ) { const that = this; const dragDetails = that.dragDetails; let feedback; if ( !that.showFeedback ) { return; } if ( !dragDetails ) { return null; } if ( dragDetails.feedback ) { return dragDetails.feedback; } if ( Math.abs( dragDetails.x - event.pageX ) > 5 || Math.abs( dragDetails.y - event.pageY ) > 5 ) { feedback = document.createElement( 'div' ); feedback.className = 'lw-breadcrumb-feedback'; feedback.style.height = that.dragDetails.element.offsetHeight + 'px'; feedback.innerHTML = that.dragDetails.element.innerHTML; document.body.appendChild( feedback ); dragDetails.feedback = feedback; dragDetails.element.classList.add( 'dragged' ); that.getItemCoordinates( that.items ); that.ownerElement.$.fireEvent( 'dragStart', { item: dragDetails.item, element: dragDetails.element, target: dragDetails.item, originalEvent: event.originalEvent } ); if ( that.ownerElement.rightToLeft ) { feedback.setAttribute( 'right-to-left', true ); } else { feedback.removeAttribute( 'right-to-left' ); } return feedback; } return null; } get feedback() { const that = this; return that.dragDetails && that.dragDetails.feedback ? that.dragDetails.feedback : null; } removeFeedback( event ) { const that = this; const dragDetails = that.dragDetails; if ( !that.showFeedback ) { that.removeCapture(); return; } if ( !dragDetails ) { return; } if ( dragDetails.feedback ) { document.body.removeChild( dragDetails.feedback ); } if ( !that.ownerElement.allowDrop ) { that.removeCapture(); return; } if ( event.key === 'Escape' ) { that.ownerElement.$.fireEvent( 'dragCancel', { item: dragDetails.item, element: dragDetails.element, originalEvent: event.originalEvent } ); that.removeCapture(); return; } that.ownerElement.$.fireEvent( 'dragEnd', { item: dragDetails.item, element: dragDetails.element, target: dragDetails.target, droppedBeforeTarget: dragDetails.before, originalEvent: event.originalEvent } ); that.removeCapture(); } removeCapture() { const that = this; const dragDetails = that.dragDetails; if ( !dragDetails ) { return; } that.clearItemDragClass(); dragDetails.element.classList.remove( 'dragged' ); that._dragDetails = null; } moveFeedback( left, top ) { const that = this; const dragDetails = that.dragDetails; if ( !that.showFeedback ) { return; } if ( !dragDetails ) { return; } const feedback = that.dragDetails.feedback; if ( feedback ) { feedback.style.left = left + 'px'; feedback.style.top = top + 'px'; } delete dragDetails.target; } drag( event ) { const that = this; if ( !that.dragDetails ) { return; } that.createFeedback( event ); that.moveFeedback( event.pageX + 5, event.pageY + 5 ); const target = that.findTarget( event ); if ( target ) { let targetItem = target.element ? target.element : target; if ( targetItem ) { that.applyItemDragClass( targetItem, targetItem.getBoundingClientRect(), event ); return; } } else { that.ownerElement.$.fireEvent( 'dragging', { item: that.dragDetails.item, element: that.dragDetails.element, target: null, originalEvent: event.pageX ? event : event.originalEvent } ); that.clearItemDragClass(); } } error() { const that = this; if ( that.dragDetails && that.dragDetails.feedback ) { that.dragDetails.feedback.classList.add( 'error' ); } } data() { const that = this; if ( that.dragDetails && that.dragDetails.feedback ) { that.dragDetails.feedback.classList.add( 'data' ); } } success() { const that = this; if ( that.dragDetails && that.dragDetails.feedback ) { that.dragDetails.feedback.classList.remove( 'error' ); that.dragDetails.feedback.classList.remove( 'data' ); } } /** * Clears the item class related to dragging. */ applyItemDragClass( targetItem, targetRect, event ) { const that = this, dragDetails = that._dragDetails; let coordinate, position, dimension; that.clearItemDragClass(); dragDetails.target = targetItem; if ( dragDetails && that.showFeedback && dragDetails.feedback ) { dragDetails.feedback.classList.remove( 'error' ); dragDetails.before = false; } if ( !that._minimized ) { coordinate = event.clientX; position = 'left'; dimension = 'width'; } else { coordinate = event.clientY; position = 'top'; dimension = 'height'; } const nextElementSibling = targetItem[ ( that.rightToLeft ? 'previous' : 'next' ) + 'ElementSibling' ]; if ( coordinate <= targetRect[ position ] + targetRect[ dimension ] / 2 ) { targetItem.classList.add( 'target' ); if ( dragDetails ) { dragDetails.before = true; } } else if ( nextElementSibling ) { nextElementSibling.classList.add( 'target' ); } else { targetItem.classList.add( 'afterTarget' ); } if ( !dragDetails ) { return; } if ( that.rightToLeft ) { dragDetails.before = !dragDetails.before; } that.ownerElement.$.fireEvent( 'dragging', { item: dragDetails.item, element: dragDetails.element, target: targetItem, originalEvent: event.originalEvent } ); } /** * Clears the item class related to dragging. */ clearItemDragClass() { const that = this; if ( that.items ) { that.items.forEach( ( item ) => { const element = item instanceof HTMLElement ? item : item.element; element.classList.remove( 'target' ); element.classList.remove( 'afterTarget' ); } ); } } /** * Gets item coordinates. */ getItemCoordinates( items ) { if ( !items ) { return { coordinate: [], rows: [] }; } const elements = items.map( ( item ) => { if ( item.nodeName ) { return item; } return item.element; } ); const that = this, coordinates = [ [] ], rows = []; let previousTop = elements[ 0 ].offsetTop, level = 0; coordinates[ 0 ].push( { index: 0, rect: elements[ 0 ].getBoundingClientRect() } ); rows[ 0 ] = { top: coordinates[ 0 ][ 0 ].rect.top, bottom: coordinates[ 0 ][ 0 ].rect.bottom }; for ( let i = 1; i < elements.length; i++ ) { const item = elements[ i ], rect = item.getBoundingClientRect(), top = elements[ i ].offsetTop; if ( top > previousTop ) { previousTop = top; level++; coordinates[ level ] = []; rows[ level ] = { top: rect.top, bottom: rect.bottom }; } coordinates[ level ].push( { index: i, rect: rect } ); } that._itemCoordinates = { coordinates: coordinates, rows: rows }; } get dragDetails() { return this._dragDetails; } } ); /** * Breadcrumb custom element. */ LW( 'lw-breadcrumb', class Breadcrumb extends LW.BaseElement { // Breadcrumb's properties. static get properties() { return { 'addNewItem': { value: false, type: 'boolean' }, 'allowDrag': { value: false, type: 'boolean' }, 'allowDrop': { value: false, type: 'boolean' }, 'closeButtons': { value: false, type: 'boolean' }, 'dataSource': { value: [], type: 'array', reflectToAttribute: false }, 'itemTemplate': { value: null, type: 'any' }, 'minimizeWidth': { value: 150, type: 'number?' }, 'placeholder': { value: '', type: 'string' } }; } /** * Breadcrumb's event listeners. */ static get listeners() { return { 'move': '_moveHandler', 'resize': '_resizeHandler', 'container.click': '_containerClickHandler', 'container.down': '_containerDownHandler', 'container.transitionend': '_containerTransitionendHandler', 'hamburgerIcon.click': '_hamburgerIconClickHandler', 'document.move': '_documentMoveHandler', 'document.keyup': '_documentKeyUpHandler', 'document.up': '_documentUpHandler' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.breadcrumb.css' ] } /** * Breadcrumb's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="minimizedHeader" class="lw-header lw-minimized-header lw-hidden" role="presentation"> <div id="hamburgerIcon" class="lw-hamburger-icon" role="button" aria-label="Toggle" aria-haspopup="dialog" aria-expanded="false"> <div id="hamburgerIconLineTop" class="lw-hamburger-icon-line lw-hamburger-icon-line-top" role="presentation"></div> <div id="hamburgerIconLineCenter" class="lw-hamburger-icon-line lw-hamburger-icon-line-center" role="presentation"></div> <div id="hamburgerIconLineBottom" class="lw-hamburger-icon-line lw-hamburger-icon-line-bottom" role="presentation"></div> </div> </div> <template> <div class="lw-breadcrumb-items" *items={{dataSource}} role="list"> <div class="lw-breadcrumb-item" role="listitem" aria-label={{item.label}}> <div class="lw-breadcrumb-item-label" inner-H-T-M-L={{item.label}} role="presentation"></div> <div class="lw-close-button" role="button" aria-label="Close"></div> </div> </div> </template> <div id="placeholder" class="lw-breadcrumb-placeholder lw-hidden" inner-H-T-M-L={{placeholder}}></div> </div>`; } /** * Updates the Breadcrumb when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler( propertyName, oldValue, newValue ) { super.propertyChangedHandler( propertyName, oldValue, newValue ); const that = this; switch ( propertyName ) { case 'addNewItem': if ( newValue ) { that._appendNewItemButton(); } else { that.$.templateContainer.firstElementChild.removeChild( that._addNewItemButton ); delete that._addNewItemButton; } that._setIndentation(); break; case 'animation': case 'disabled': case 'unfocusable': if ( that.addNewItem ) { that._addNewItemButton[ propertyName ] = newValue; } if ( propertyName === 'disabled' && that._minimizedDropDownOpened ) { that._hamburgerIconClickHandler(); } break; case 'itemTemplate': for ( let i = 0; i < that._items.length; i++ ) { that._items[ i ].firstElementChild.innerHTML = that.dataSource[ i ].label; } if ( newValue ) { that._applyTemplate(); } break; case 'minimizeWidth': if ( newValue !== null && that.offsetWidth <= newValue ) { that.minimize(); } else { that.maximize(); } break; case 'closeButtons': if ( !that._minimized ) { that._setIndentation(); } break; } } ready() { super.ready(); const that = this; that.setAttribute( 'role', 'navigation' ); that.$.container.children[ 1 ].setAttribute( 'id', that.id + 'TemplateContainer' ); that.$.container.children[ 1 ].setAttribute( 'role', 'presentation' ); that.$.hamburgerIcon.setAttribute( 'aria-controls', that.id + 'TemplateContainer' ); that._edgeMacFF = LW.Utilities.Core.Browser.Edge || LW.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf( 'mac' ) !== -1; that.templateContainer = that.$.container.children[ 1 ]; that._dragDrop = new LW.Utilities.DragDrop( that ); if ( that.minimizeWidth !== null && that.offsetWidth <= that.minimizeWidth ) { that.minimize(); } } templateAttached() { this._handleDataSourceRefresh(); } /** * Adds an item. * * @param {Object} itemDetails An Object with the fields "index", "label", and "value". */ addItem( itemDetails ) { const that = this, newSource = that.dataSource.slice( 0 ); if ( !itemDetails || typeof itemDetails !== 'object' || isNaN( itemDetails.index ) || itemDetails.index < 0 ) { return; } newSource.splice( itemDetails.index, 0, { label: itemDetails.label, value: itemDetails.value } ); that.dataSource = newSource; } /** * Maximizes the Breadcrumb. */ maximize() { const that = this; if ( !that._minimized ) { return; } that.$minimizedHeader.addClass( 'lw-hidden' ); that.templateContainer.classList.remove( 'lw-visibility-hidden' ); if ( that._edgeMacFF ) { that.templateContainer.classList.remove( 'not-in-view' ); } that.$hamburgerIcon.removeClass( 'lw-close-button' ); that.removeAttribute( 'minimized' ); that.$.container.children[ 1 ].setAttribute( 'role', 'presentation' ); that._minimizedDropDownOpened = false; that._minimized = false; that.$.fireEvent( 'maximize' ); that._setIndentation(); } /** * Minimizes the Breadcrumb. */ minimize() { const that = this; if ( that._minimized || that.offsetWidth === 0 || that.offsetHeight === 0 ) { return; } const animationType = that.animation, restoreAnimation = that.hasAnimation; if ( restoreAnimation ) { that.animation = 'none'; } that.$minimizedHeader.removeClass( 'lw-hidden' ); that.templateContainer.classList.add( 'lw-visibility-hidden' ); if ( that._edgeMacFF ) { that.templateContainer.classList.add( 'not-in-view' ); } if ( restoreAnimation ) { setTimeout( function () { that.animation = animationType; }, 0 ); } that.setAttribute( 'minimized', '' ); that.$.container.children[ 1 ].setAttribute( 'role', 'dialog' ); that._minimized = true; that.$.fireEvent( 'minimize' ); that._setIndentation(); } /** * Removes an item. * * @param {HTMLElement} item The item to remove. */ removeItem( item ) { const that = this, index = that._items.indexOf( item ), newSource = that.dataSource.slice( 0 ); if ( index === -1 ) { return; } newSource.splice( index, 1 ); that.dataSource = newSource; } /** * move handler. */ _moveHandler( event ) { if ( event.originalEvent.type === 'touchmove' ) { event.originalEvent.preventDefault(); } } /** * resize handler. */ _resizeHandler() { const that = this; if ( that.minimizeWidth !== null && that.offsetWidth <= that.minimizeWidth ) { that.minimize(); } else if ( that._minimized ) { that.maximize(); } else { that._setIndentation(); } } /** * container click handler. */ _containerClickHandler( event ) { const that = this; if ( that.disabled || !that.templateContainer.contains( event.target ) ) { return; } const closeButton = event.target.closest( '.lw-close-button' ); if ( !closeButton ) { const item = event.target.closest( '.lw-breadcrumb-item' ); const dataItem = that.dataSource[ that._items.indexOf( item ) ]; that.$.fireEvent( 'itemClick', { item: dataItem, element: item } ); return; } const item = closeButton.closest( '.lw-breadcrumb-item' ); const dataItem = that.dataSource[ that._items.indexOf( item ) ]; const closingEvent = that.$.fireEvent( 'closing', { item: dataItem, element: item } ); if ( !closingEvent.defaultPrevented ) { const newSource = that.dataSource.slice( 0 ); newSource.splice( that._items.indexOf( item ), 1 ); that.dataSource = newSource; that.$.fireEvent( 'close', { item: dataItem, element: item } ); } } /** * container down handler. */ _containerDownHandler( event ) { const that = this, target = event.originalEvent.target; if ( !that.allowDrag || that.disabled || target.classList.contains( 'lw-close-button' ) ) { return; } const item = target.closest( '.lw-breadcrumb-item' ); if ( !item ) { return; } that._dragDrop.items = that._items; that._dragDrop.capture( item, event ); } /** * container transitionend handler. */ _containerTransitionendHandler( event ) { const that = this; if ( that._edgeMacFF && event.target === that.templateContainer && !that._minimizedDropDownOpened && that.hasAnimation ) { that.templateContainer.classList.add( 'not-in-view' ); } } /** * hamburger icon click handler. */ _hamburgerIconClickHandler() { const that = this; if ( that._minimizedDropDownOpened ) { that.$hamburgerIcon.removeClass( 'lw-close-button' ); that.templateContainer.classList.add( 'lw-visibility-hidden' ); that.$.hamburgerIcon.setAttribute( 'aria-expanded', false ); that._minimizedDropDownOpened = false; } else { that.$hamburgerIcon.addClass( 'lw-close-button' ); if ( that._edgeMacFF ) { that.templateContainer.classList.remove( 'not-in-view' ); } that.templateContainer.classList.remove( 'lw-visibility-hidden' ); that.$.hamburgerIcon.setAttribute( 'aria-expanded', true ); that._minimizedDropDownOpened = true; } } /** * document key up handler. */ _documentKeyUpHandler( event ) { if ( event.key === 'Escape' ) { this.dragDrop.removeFeedback( event ); } } /** * document move handler. */ _documentMoveHandler( event ) { const that = this, dragDetails = that._dragDrop.dragDetails; if ( !dragDetails ) { return; } event.originalEvent.preventDefault(); that._dragDrop.drag( event ); } /** * document up handler. */ _documentUpHandler( event ) { const that = this, dragDetails = that._dragDrop.dragDetails; if ( !dragDetails ) { return; } if ( dragDetails.feedback ) { const items = that._items.slice( 0 ), itemIndex = items.indexOf( dragDetails.item ), newSource = that.dataSource.slice( 0 ), toMove = newSource.splice( itemIndex, 1 ); items.splice( itemIndex, 1 ); const targetIndex = items.indexOf( dragDetails.target ) + ( dragDetails.before ? 0 : 1 ); if ( itemIndex !== targetIndex && itemIndex >= 0 ) { newSource.splice( targetIndex, 0, toMove[ 0 ] ); that.dataSource = newSource; } that._dragDrop.removeFeedback( event ); } else { that._dragDrop.removeCapture(); } } /** * Handles dataSource refresh. */ _handleDataSourceRefresh() { const that = this; that._items = Array.from( that.$.templateContainer.firstElementChild.children ); that._items.forEach( ( item, index ) => { item.data = that.dataSource[ index ]; } ); if ( that.addNewItem ) { that._appendNewItemButton(); } that._applyTemplate(); that._setIndentation(); that._items.length === 0 ? that.$.placeholder.classList.remove( 'lw-hidden' ) : that.$.placeholder.classList.add( 'lw-hidden' ); } /** * Appends "Add new item" button. */ _appendNewItemButton() { const that = this, addNewItemButton = document.createElement( 'lw-button' ); addNewItemButton.innerHTML = '+'; addNewItemButton.animation = that.animation; addNewItemButton.disabled = that.disabled; addNewItemButton.unfocusable = that.unfocusable; addNewItemButton.setAttribute( 'aria-label', 'Add' ); addNewItemButton.addEventListener( 'click', function () { that.$.fireEvent( 'addNewItem' ); } ); that.$.templateContainer.firstElementChild.appendChild( addNewItemButton ); that._addNewItemButton = addNewItemButton; } /** * Sets item indentation. */ _setIndentation() { const that = this, items = that._items.slice( 0 ); if ( that._addNewItemButton ) { items.push( that._addNewItemButton ); } if ( items.length === 0 ) { return; } let previousTop = items[ 0 ].offsetTop, level = 0; items.forEach( function ( item ) { item.style.marginLeft = item.style.marginRight = null; } ); if ( that._minimized ) { return; } for ( let i = 1; i < items.length; i++ ) { const item = items[ i ], top = items[ i ].offsetTop; if ( top > previousTop ) { previousTop = top; level++ item.style[ 'margin' + ( that.rightToLeft ? 'Right' : 'Left' ) ] = ( level * 10 ) + 'px'; } } } /** * Applies item template. */ _applyTemplate() { const that = this, itemTemplate = that.itemTemplate; if ( itemTemplate === null ) { return; } let potentialHTMLTemplate; if ( itemTemplate instanceof HTMLTemplateElement ) { potentialHTMLTemplate = itemTemplate; } else { potentialHTMLTemplate = document.getElementById( itemTemplate ); } if ( potentialHTMLTemplate !== null && potentialHTMLTemplate instanceof HTMLTemplateElement ) { const templateContent = document.importNode( potentialHTMLTemplate.content, true ), div = document.createElement( 'div' ); div.appendChild( templateContent ); const templateText = div.innerHTML; for ( let i = 0; i < that._items.length; i++ ) { const dataSource = that.dataSource, label = dataSource[ i ].label, value = dataSource[ i ].value, labelElement = that._items[ i ].firstElementChild; labelElement.innerHTML = templateText.replace( /{{label}}/g, label ).replace( /{{value}}/g, value ); } } } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * A class for instantiating a number processor object. */ LW.Utilities.Assign('NumericProcessor', class NumericProcessor { constructor(context, numericFormatProperty) { switch (context[numericFormatProperty]) { case 'integer': return new LW.Utilities.IntegerNumericProcessor(context, numericFormatProperty); case 'floatingPoint': return new LW.Utilities.DecimalNumericProcessor(context, numericFormatProperty); case 'complex': return new LW.Utilities.ComplexNumericProcessor(context, numericFormatProperty); } } }); /** * A base class for processesing numbers. */ LW.Utilities.Assign('BaseNumericProcessor', class BaseNumericProcessor { constructor(context, numericFormatProperty) { const that = this; that.context = context; that._longestLabelSize = 0; that.numericFormatProperty = numericFormatProperty; that.regexScientificNotation = new RegExp(/^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)(Y|Z|E|P|T|G|M|k|m|u|n|p|f|a|z|y){1}$/); // regular expressions for scientific notation that.regexNoLeadingZero = new RegExp(/^(-)?[.]\d+$/); that.regexLeadingZero = new RegExp(/^[+\-]?(0+)[1-9]+|^[+\-]?(0{2,})[.]|^(0{2,})$/); that.prefixesToPowers = { 'Y': 24, 'Z': 21, 'E': 18, 'P': 15, 'T': 12, 'G': 9, 'M': 6, 'k': 3, 'm': -3, 'u': -6, 'n': -9, 'p': -12, 'f': -15, 'a': -18, 'z': -21, 'y': -24 }; if (window.NIComplex) { that.complexConstructor = window.NIComplex; } else { that.complexConstructor = LW.Utilities.Complex; } } prepareForValidation(initialValidation, programmaticValue, value) { const that = this.context, initialOrProgrammatic = initialValidation || programmaticValue !== undefined; value = value.toString(); value = value.replace(/\s/g, ''); value = that._discardDecimalSeparator(value); if (this.regexLeadingZero.test(value)) { const testResult = this.regexLeadingZero.exec(value); if (testResult[1]) { value = value.replace(testResult[1], ''); } else if (testResult[2]) { value = value.replace(testResult[2], '0'); } else { value = value.replace(testResult[3], '0'); } } if (this.regexNoLeadingZero.test(value)) { if (value.charAt(0) === '-') { value = '-0' + value.slice(1); } else { value = '0' + value; } } else if ((that[this.numericFormatProperty] === 'integer' && (that._radixNumber === 10 || initialOrProgrammatic) || that[this.numericFormatProperty] === 'floatingPoint') && this.regexScientificNotation.test(value)) { // scientific notation test value = this.scientificToDecimal(value); } let complexNumberIsEntered = false, enteredComplexNumber; if (that[this.numericFormatProperty] === 'complex' && that._regexSpecial.nonNumericValue.test(value) === false) { try { if (that._regexSpecial.exaValue.test(value)) { // handles ambiguous "exa" case const indexOfExa = value.indexOf('E'), realPart = parseFloat(value.slice(0, indexOfExa)) * Math.pow(10, 18), imaginaryPart = parseFloat(value.slice(indexOfExa + 1, -1)); enteredComplexNumber = new this.complexConstructor(realPart, imaginaryPart); } else { enteredComplexNumber = new this.complexConstructor(value); } complexNumberIsEntered = true; } catch (error) { complexNumberIsEntered = false; } } // if the entered value is not a number if (complexNumberIsEntered === false && (!initialOrProgrammatic && that._regex[that._radixNumber].test(value) === false || initialOrProgrammatic && that._regex[10].test(value) === false)) { that._handleNonNumericValue(initialValidation, programmaticValue, value); return; } return { value: value, enteredComplexNumber: enteredComplexNumber }; } /** * Checks if a number is in exponential notation. */ isENotation(value) { const eNotationRegex = new RegExp(/e/i); return eNotationRegex.test(value.toString()); } /** * Converts a number in scientific notation to a plain number. */ scientificToDecimal(scientificValue) { const parts = this.regexScientificNotation.exec(scientificValue), numericPart = parts[1], prefix = parts[2], number = parseFloat(numericPart) * (Math.pow(10, this.prefixesToPowers[prefix])); return number; } /** * Creates a label dummy element. */ _createMeasureLabel() { const context = this.context, measureLabel = document.createElement('div'); measureLabel.className = 'lw-label'; measureLabel.style.position = 'absolute'; measureLabel.style.visibility = 'hidden'; if (context.scalePosition !== 'far') { context._measureLabelScale = context.$.scaleNear; } else { context._measureLabelScale = context.$.scaleFar; } context._measureLabelScale.appendChild(measureLabel); return measureLabel; } /** * Adds a major tick and its respective label. */ _addMajorTickAndLabel(htmlValue, labelSize, plot, value, middle) { const that = this.context, leftOrTop = that._settings.leftOrTop, offset = this.valueToPx(value); let currentTick = '', currentLabel = ''; if (parseInt(offset) > parseInt(that._measurements.trackLength)) { return { tick: currentTick, label: currentLabel }; } if (that.logarithmicScale) { htmlValue = that._formatLabel(Math.pow(10, value)); } if (that.nodeName.toLowerCase() === 'lw-tank' || that._intervalHasChanged) { let tickIntervalLabelSize = that._tickIntervalHandler.labelsSize; if (middle) { that._labelDummy.innerHTML = htmlValue; let tickPosition = this.valueToPx(value), maxPosition = this.valueToPx(that._drawMax), minPosition = this.valueToPx(that._drawMin), labelSize = that._labelDummy[that._settings.size], labelOtherSize = that.orientation === 'vertical' ? that._labelDummy.offsetWidth : that._labelDummy.offsetHeight, distanceToMin = (labelSize + tickIntervalLabelSize.minLabelSize) / 2, distanceToMax = (labelSize + tickIntervalLabelSize.maxLabelSize) / 2; that._normalLayout ? plot = (tickPosition + distanceToMax < maxPosition) && (tickPosition - distanceToMin > minPosition) : plot = (tickPosition - distanceToMax > maxPosition) && (tickPosition + distanceToMin < minPosition); if (labelOtherSize > this._longestLabelSize) { this._longestLabelSize = labelOtherSize; } } else { this._longestLabelSize = Math.max(tickIntervalLabelSize.minLabelOtherSize, tickIntervalLabelSize.maxLabelOtherSize, this._longestLabelSize); } } that._tickValues.push(value); currentTick = '<div style="' + leftOrTop + ': ' + offset + 'px;" class="lw-tick"></div>'; if (plot !== false) { if (labelSize === undefined) { that._labelDummy.innerHTML = htmlValue; labelSize = that._labelDummy[that._settings.size]; } const labelOffset = offset - labelSize / 2; currentLabel += '<div class="lw-label' + (middle ? ' lw-label-middle' : '') + '" style="' + leftOrTop + ': ' + labelOffset + 'px;">' + htmlValue + '</div>'; } return { tick: currentTick, label: currentLabel }; } /** * Gets the internal numeric word length based on the "wordLength" property. */ getWordLength(wordLength) { this.context._unsigned = wordLength.charAt(0) === 'u'; switch (wordLength) { case 'int8': case 'uint8': return 8; case 'int16': case 'uint16': return 16; case 'int32': case 'uint32': return 32; case 'int64': case 'uint64': return 64; } } /** * Returns the angle equivalent of a value. */ getAngleByValue(value, calculateDrawValue, returnDegrees) { const that = this.context; if (calculateDrawValue !== false && that.logarithmicScale) { value = Math.log10(value); } const angleOffset = (value - that._drawMin) * that._angleRangeCoefficient; let degrees; if (that.inverted === undefined || (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { degrees = that.endAngle - angleOffset; } else { degrees = that.startAngle + angleOffset; } if (returnDegrees) { return degrees; } return degrees * Math.PI / 180 + Math.PI / 2; } /** * Returns the value equivalent of an angle. */ getValueByAngle(angle, integer) { const that = this.context; let minuendAngle, subtrahendAngle, value; if (that.inverted === undefined || (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { minuendAngle = that.endAngle; subtrahendAngle = angle; } else { minuendAngle = angle; subtrahendAngle = that._normalizedStartAngle; } while (minuendAngle < subtrahendAngle) minuendAngle += 360; value = ((minuendAngle - subtrahendAngle) / that._angleDifference) * that._range + parseFloat(that._drawMin); if (that.logarithmicScale) { if (that.customInterval) { return parseFloat(Math.pow(10, this.getCoercedValue(value, true)).toFixed(12)); } value = Math.pow(10, value); } if (integer && !that.coerce) { return Math.round(value); } value = this.createDescriptor(value, undefined, true, true); return this.getCoercedValue(value, false); } /** * Updates the values of the Gauge and its digital display and fires the "change" event. */ updateGaugeValue(newValue) { const that = this.context, oldValue = that.value; that.value = newValue; that._drawValue = that.logarithmicScale ? Math.log10(newValue).toString() : newValue; that._number = this.createDescriptor(that.value); that.$.digitalDisplay.value = newValue; that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue }); that._setAriaValue('valuenow'); delete that._valueBeforeCoercion; } /** * Validates the start or end value of a Gauge color range. */ validateColorRange(value) { const that = this.context; return Math.min(Math.max(value, that.min), that.max); } /** * Returns a value based on the passed "draw" value. */ getActualValue(value) { if (!this.context.logarithmicScale) { return value; } else { return Math.pow(10, value); } } /** * Draws minor ticks on a Gauge logarithmic scale. */ drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor) { const that = this.context; let firstWholePower; if (majorStep instanceof LW.Utilities.BigNumber) { majorStep = parseFloat(majorStep.toString()); } for (let i in majorTickValues) { firstWholePower = i; if (i >= 0 && i % 1 === 0) { break; } } // positive powers for (let i = parseFloat(firstWholePower); i < that._drawMax; i += majorStep) { for (let j = 2; j <= 9; j++) { const value = j * Math.pow(10, i + majorStep - 1); if (value < that.max) { drawMinor(value); } } } // negative powers for (let i = parseFloat(firstWholePower); i > that._drawMin; i -= majorStep) { for (let j = 2; j <= 9; j++) { const value = j * Math.pow(10, i - 1); if (value > that.min) { drawMinor(value); } } } } /** * Returns the difference between two angles. */ _getAngleDifference(angle1, angle2) { const phi = Math.abs(angle2 - angle1) % 360, distance = phi > 180 ? 360 - phi : phi; return distance; } /** * Plots custom ticks. */ addCustomTicks() { const numericProcessor = this, that = numericProcessor.context, normalScale = !that.logarithmicScale; let ticks = '', labels = ''; function createTickAndLabel(i) { const currentLabel = that.customTicks[i], value = normalScale ? numericProcessor.createDescriptor(currentLabel) : Math.log10(currentLabel), middle = i > 0 && i < that.customTicks.length - 1, currentTickAndLabel = numericProcessor._addMajorTickAndLabel(that._formatLabel(currentLabel), undefined, true, value, middle); ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; } numericProcessor._longestLabelSize = 0; that._tickValues = []; that._labelDummy = numericProcessor._createMeasureLabel(); if (!that._normalLayout) { for (let i = that.customTicks.length - 1; i >= 0; i--) { createTickAndLabel(i); } } else { for (let i = 0; i < that.customTicks.length; i++) { createTickAndLabel(i); } } if (that.nodeName.toLowerCase() === 'lw-tank') { that._updateScaleWidth(numericProcessor._longestLabelSize); } that._appendTicksAndLabelsToScales(ticks, labels); } /** * Plots the Gauge's custom ticks. */ addGaugeCustomTicks() { const numericProcessor = this, that = numericProcessor.context, distance = that._distance, majorTickWidth = that._measurements.radius - distance.majorTickDistance; let drawTick, drawLabel; if (that.ticksVisibility !== 'none' && that._plotTicks !== false) { drawTick = function (angle) { that._drawTick(angle, majorTickWidth, 'major'); }; } else { drawTick = function () { }; } if (that.labelsVisibility !== 'none' && that._plotLabels !== false) { drawLabel = function (angle, currentLabel, middle) { that._drawLabel(angle, currentLabel, distance.labelDistance, middle); }; } else { drawLabel = function () { }; } function createTickAndLabel(i) { const currentLabel = that.customTicks[i], value = numericProcessor.createDescriptor(currentLabel), angle = numericProcessor.getAngleByValue(value, true), middle = i > 0 && i < that.customTicks.length - 1; drawTick(angle); drawLabel(angle, currentLabel, middle); } for (let i = that.customTicks.length - 1; i >= 0; i--) { createTickAndLabel(i); } } }); /** * A class for processesing integer numbers. */ LW.Utilities.Assign('IntegerNumericProcessor', class IntegerNumericProcessor extends LW.Utilities.BaseNumericProcessor { constructor(context, numericFormatProperty) { super(context, numericFormatProperty); const that = this; that.context = context; that.defaultMins = { int8: '-128', uint8: '0', int16: '-32768', uint16: '0', int32: '-2147483648', uint32: '0', int64: '-9223372036854775808', uint64: '0' }; that.defaultMaxs = { int8: '127', uint8: '255', int16: '32767', uint16: '65535', int32: '2147483647', uint32: '4294967295', int64: '9223372036854775807', uint64: '18446744073709551615' }; } createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax, discardRadix) { const that = this.context; let returnValue; if (initialValue.constructor !== LW.Utilities.BigNumber) { let radix = !discardRadix && that._radixNumber ? that._radixNumber : 10; if (radix === 10 && supportsENotation && initialValue.constructor !== LW.Utilities.BigNumber && this.isENotation(initialValue)) { if (LW.Utilities.BigNumber.bigIntSupport) { initialValue = new LW.Utilities.BigNumber(Math.round(initialValue)); } else { initialValue = new LW.Utilities.NumberRenderer(initialValue).largeExponentialToDecimal(); } } if (that._toBigNumberDecimal) { returnValue = that._toBigNumberDecimal(initialValue.toString(radix, that._wordLengthNumber), radix); } else { returnValue = new LW.Utilities.BigNumber(initialValue); } } else { returnValue = new LW.Utilities.BigNumber(initialValue); } if (validateConstruction) { // if the entered number is negative and the "wordLength" is "uint", the number is set to 0 if (that._unsigned && returnValue.compare(0) === -1) { returnValue = returnValue.set(0); } if (validateMinMax) { // if the entered number is outside the range defined by "min" and "max", the number is changed to the value of "min" or "max" returnValue = this.validate(returnValue, that._minObject, that._maxObject); } returnValue = this.round(returnValue); } return returnValue; } /** * Returns a rounded BigNumber object */ round(value) { const context = this.context; // eslint-disable-next-line if (value instanceof window.LW.Utilities.BigNumber && typeof value._d === 'bigint') { return value; } else if (value instanceof window.LW.Utilities.BigNumber === false || !context._wordLengthNumber || context._wordLengthNumber < 64) { return new LW.Utilities.BigNumber(Math.round(value.toString())); } const fraction = value.mod(1); if (!(fraction._d.length === 1 && fraction._d[0] === 0)) { // if the entered number is with a decimal value, it is rounded up or down to its nearest integer equivalent value = value.intPart(); if (!value._s) { // round positive number if (fraction._d[1] > 4) { value = value.add(1); } } else { // round negative number if (fraction._d[1] > 5 || fraction._d[1] === 5 && fraction._d[2]) { value = value.add(-1); } } } return value; } /** * Validates value. */ validate(initialValue, min, max) { let returnValue; if (initialValue.compare(min) === -1) { returnValue = min; } else if (initialValue.compare(max) === 1) { returnValue = max } else { returnValue = initialValue; } return returnValue; } /** * Validates min/max. */ validateMinMax(validateMin, validateMax) { const that = this.context; let defaultMin = this.defaultMins[that.wordLength], defaultBigMin = new LW.Utilities.BigNumber(defaultMin), defaultMax = this.defaultMaxs[that.wordLength], defaultBigMax = new LW.Utilities.BigNumber(defaultMax), numericScale = that.mode !== 'date'; if (that._numberRenderer === undefined) { that._numberRenderer = new LW.Utilities.NumberRenderer(); } if (validateMin && numericScale) { if (that.min !== null) { that.min = that.min.toString().replace(/\s/g, ''); if (this.regexScientificNotation.test(that.min)) { that.min = this.scientificToDecimal(that.min); } } let currentBigMin = this.round(new LW.Utilities.BigNumber(that.min)); if (that.min !== null && (!that._minIsNull || !that._initialized) && currentBigMin.compare(defaultBigMin) >= 0) { that._minObject = currentBigMin; } else { that._minIsNull = true; that.min = defaultMin; that._minObject = defaultBigMin; } } if (validateMax && numericScale) { if (that.max !== null) { that.max = that.max.toString().replace(/\s/g, ''); if (this.regexScientificNotation.test(that.max)) { that.max = this.scientificToDecimal(that.max); } } let currentBigMax = this.round(new LW.Utilities.BigNumber(that.max)); if (that.max !== null && (!that._maxIsNull || !that._initialized) && currentBigMax.compare(defaultBigMax) <= 0) { that._maxObject = currentBigMax; } else { that._maxIsNull = true; that.max = defaultMax; that._maxObject = defaultBigMax; } } if (!numericScale) { that._minObject = new LW.Utilities.BigNumber(that.min); that._maxObject = new LW.Utilities.BigNumber(that.max); } if (!this.compare(that._minObject, that._maxObject)) { //Set default values that._minObject = defaultBigMin; that._maxObject = defaultBigMax; that._drawMin = that.logarithmicScale ? 0 : defaultMin; that._drawMax = that.logarithmicScale ? 10 : defaultMax; that.min = defaultMin; that.max = defaultMax; } if (!numericScale) { that._minDate = LW.Utilities.DateTime.fromFullTimeStamp(that.min); that._maxDate = LW.Utilities.DateTime.fromFullTimeStamp(that.max); } } /** * Converts value to pixels. */ valueToPx(value) { const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; const that = this.context, lengthRangeRatio = new LW.Utilities.BigNumber(that._measurements.trackLength).divide(new LW.Utilities.BigNumber(that._range)); let result; if (that._normalLayout) { const drawMin = that._drawMin instanceof LW.Utilities.BigNumber ? that._drawMin : new LW.Utilities.BigNumber(that._drawMin); value = new LW.Utilities.BigNumber(value); result = parseFloat((lengthRangeRatio.multiply(value.subtract(drawMin))).toString()); } else { const drawMax = that._drawMax instanceof LW.Utilities.BigNumber ? that._drawMax : new LW.Utilities.BigNumber(that._drawMax); result = parseFloat(this.round(((drawMax.subtract(value)).multiply(lengthRangeRatio))).toString()); } LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; return result; } /** * Returns the value equivalent of a pixel offset. */ pxToValue(px) { const that = this.context, ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; let result; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; if (that._normalLayout) { result = that._valuePerPx.multiply(px - that._trackStart); } else { result = that._valuePerPx.multiply(that._trackEnd - px); } result = this.round(result).toString(); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; if (that.logarithmicScale) { let power = parseFloat(result) + parseFloat(that._drawMin); //that._drawValue = power; return new LW.Utilities.BigNumber(Math.round(Math.pow(10, power))); } let returnedValue = this.createDescriptor(that._minObject.add(result), false, true, true); //that._drawValue = returnedValue; return returnedValue; } /** * BigNumber compare method. */ compare(initialValue, otherValue, thorough) { if ((initialValue === null || otherValue === null) && initialValue !== otherValue) { return true; } if (initialValue.constructor !== LW.Utilities.BigNumber) { initialValue = new LW.Utilities.BigNumber(initialValue); } const result = initialValue.compare(otherValue); if (thorough !== true) { return result !== 0; } return result; } /** * Increments/Decrements value. Keyboard navigation operations. */ incrementDecrement(initialValue, operation, stepObject) { const that = this.context; let returnValue; if (initialValue.constructor !== LW.Utilities.BigNumber) { initialValue = new LW.Utilities.BigNumber(initialValue); } if (operation === 'add') { returnValue = initialValue.add(stepObject); if (that._drawMax !== undefined) { return returnValue.compare(that._drawMax) > 0 ? new LW.Utilities.BigNumber(that._drawMax) : returnValue; } } else { returnValue = initialValue.subtract(stepObject); if (that._drawMin !== undefined) { return returnValue.compare(that._drawMin) < 0 ? new LW.Utilities.BigNumber(that._drawMin) : returnValue; } } return returnValue; } /** * Renders the value. Scientific notation renderer. */ render(initialValue, ignoreRadixNumber) { const context = this.context; if (!context.scientificNotation && ignoreRadixNumber === true) { return new LW.Utilities.NumberRenderer(new LW.Utilities.BigNumber(initialValue)).bigNumberToExponent(context.significantDigits); } // scientific notation let returnValue = initialValue; if (context.scientificNotation && ignoreRadixNumber === true) { returnValue = new LW.Utilities.NumberRenderer(returnValue).toScientific(context.significantDigits, context.precisionDigits); } else if (typeof initialValue !== 'string') { returnValue = initialValue.toString(context._radixNumber, context._wordLengthNumber, context.leadingZeros); } return returnValue; } /** * Adds tank\'s ticks and labels. */ addTicksAndLabels() { const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; const that = this.context, trackLength = that._measurements.trackLength, normalLayout = that._normalLayout, ticksFrequency = that._majorTicksInterval, tickscount = this.round(new LW.Utilities.BigNumber(that._range).divide(ticksFrequency)), ticksDistance = trackLength / tickscount, min = new LW.Utilities.BigNumber(that._drawMin), max = new LW.Utilities.BigNumber(that._drawMax); let first, second, distanceModifier, last, firstLabelValue, firstLabelSize, lastLabelValue, lastLabelSize, currentTickAndLabel, ticks = '', labels = ''; that._tickValues = []; this._longestLabelSize = 0; if (normalLayout) { first = min; second = ticksFrequency.add(first.subtract(first.mod(ticksFrequency))); distanceModifier = second.subtract(first); firstLabelValue = that._formatLabel(min); firstLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize; last = max; lastLabelValue = that._formatLabel(max); lastLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize; } else { first = max; second = first.subtract(first.mod(ticksFrequency)); distanceModifier = first.subtract(second); firstLabelValue = that._formatLabel(max); firstLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize; last = min; lastLabelValue = that._formatLabel(min); lastLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize; } that._labelDummy = this._createMeasureLabel(); currentTickAndLabel = this._addMajorTickAndLabel(firstLabelValue, firstLabelSize, true, first); // first tick and label ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; // special case for second tick and label const distanceFromFirstToSecond = distanceModifier.divide(ticksFrequency).multiply(ticksDistance); if (second.compare(that.max) !== 0 && distanceFromFirstToSecond.compare(trackLength) < 0) { // second item rendering const secondItemHtmlValue = that._formatLabel(second.toString()), plotSecond = distanceFromFirstToSecond.compare(firstLabelSize) > 0; currentTickAndLabel = this._addMajorTickAndLabel(secondItemHtmlValue, undefined, plotSecond, second, true); ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; } currentTickAndLabel = this.addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency); ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; currentTickAndLabel = this._addMajorTickAndLabel(lastLabelValue, lastLabelSize, true, last); // last tick and label ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; if (that.mode !== 'date') { ticks += this.addMinorTicks(normalLayout); } that._measureLabelScale.removeChild(that._labelDummy); delete that._labelDummy; delete that._measureLabelScale; if (that.nodeName.toLowerCase() === 'lw-tank') { that._updateScaleWidth(this._longestLabelSize); } that._appendTicksAndLabelsToScales(ticks, labels); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; } /** * Adds the middle major ticks and their respective labels. */ addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency) { const that = this.context; let majorTicks = '', majorLabels = '', valuePlusExponent; for (let i = 1; i < tickscount; i++) { let number = distanceFromFirstToSecond.add(i * ticksDistance), value; if (normalLayout) { value = ticksFrequency.multiply(i).add(distanceModifier.add(new LW.Utilities.BigNumber(that._drawMin))); } else { value = new LW.Utilities.BigNumber(that._drawMax).subtract(distanceModifier).subtract(ticksFrequency.multiply(i)); // if the value of the penultimate is 0 we add the exponent to accurately calculate its size if (i === tickscount - 1 && value.compare(0) === 0) { that._numberRenderer.numericValue = that._tickIntervalHandler.nearestPowerOfTen; valuePlusExponent = that._numberRenderer.bigNumberToExponent(1); } } if (value.compare(that._drawMax) !== 0) { let htmlValue = that._formatLabel(value.toString()), plot = true; that._labelDummy.innerHTML = valuePlusExponent ? valuePlusExponent : htmlValue; let dimensionValue = that._labelDummy[that._settings.size]; if (number.add(dimensionValue).compare(tickscount * ticksDistance) >= 0) { // + 5 is an experimental value plot = false; // does not plot the second to last label if it intersects with the last one } const currentTickAndLabel = this._addMajorTickAndLabel(htmlValue, undefined, plot, value, true); majorTicks += currentTickAndLabel.tick; majorLabels += currentTickAndLabel.label; } } return { tick: majorTicks, label: majorLabels }; } /** * Adds minor ticks. */ addMinorTicks(normalLayout) { function addMinorTick(i) { if (tickValues.indexOf(i) === -1 && i % minorTicksInterval === 0) { minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(i) + 'px;" class="lw-tick lw-tick-minor"></div>'; } } const that = this.context, tickValues = that._tickValues, nearestPowerOfTen = that._tickIntervalHandler.nearestPowerOfTen, minorTicksInterval = that._minorTicksInterval, leftOrTop = that._settings.leftOrTop; let firstTickValue, secondTickValue, lastTickValue, minorTicks = ''; if (normalLayout) { firstTickValue = tickValues[0]; secondTickValue = tickValues[1]; lastTickValue = tickValues[tickValues.length - 1] } else { firstTickValue = tickValues[tickValues.length - 1]; secondTickValue = tickValues[tickValues.length - 2]; lastTickValue = tickValues[0] } if (that.logarithmicScale) { addMinorTickOnLogarithmicScale(); } else { // minor ticks from the beginning to the second major tick for (let i = secondTickValue; firstTickValue.compare(i) < 0; i = i.subtract(nearestPowerOfTen)) { addMinorTick(i); } // minor ticks from the second major tick to the end for (let i = secondTickValue.add(nearestPowerOfTen); lastTickValue.compare(i) > 0; i = i.add(nearestPowerOfTen)) { addMinorTick(i); } } function addMinorTickOnLogarithmicScale() { let trackLength = that._measurements.trackLength, partialTrackLength = trackLength / tickValues.length, modifierCoef = 0.1; if (partialTrackLength < 20) { modifierCoef = 1; } else if ((partialTrackLength >= 20) && (partialTrackLength < 40)) { modifierCoef = (secondTickValue - firstTickValue) > 1 ? 1 : 0.5; } else if ((partialTrackLength >= 40) && (partialTrackLength < 80)) { modifierCoef = 0.2; } let nearestPowerOf10BelowMax = Math.floor(that._drawMax), distanceToNearestPowerOf10 = that._drawMax - nearestPowerOf10BelowMax, ticksOnPowerOf10 = (that._drawMax - that._drawMin) > tickValues.length; for (let j = that._drawMax; j > 0; j = j - 1) { let range = distanceToNearestPowerOf10 > 0 ? Math.pow(10, j - distanceToNearestPowerOf10 + 1) : Math.pow(10, j), modifier = range * modifierCoef; for (let i = range; i > 0; i = (i - modifier)) { if ((i < that.max) && (i > that.min)) { let value = new LW.Utilities.BigNumber(Math.log10(i)); if (((value % 1 === 0) && ticksOnPowerOf10) || !ticksOnPowerOf10) { minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(value) + 'px;" class="lw-tick lw-tick-minor"></div>'; } } } } } return minorTicks; } /** * Validates custom ticks. */ validateCustomTicks() { const that = this.context, numericScale = that.mode !== 'date'; let validCustomTicks = []; for (let i = 0; i < that.customTicks.length; i++) { let currentTick = that.customTicks[i]; if (numericScale) { currentTick = this.createDescriptor(currentTick, false, true); } else if (currentTick._d === undefined) { currentTick = LW.Utilities.DateTime.validateDate(currentTick).getTimeStamp(); } if (currentTick.compare(that._minObject) >= 0 && currentTick.compare(that._maxObject) <= 0) { validCustomTicks.push(currentTick); } } validCustomTicks.sort(function (a, b) { return a.compare(b); }); if (numericScale) { for (let i = 0; i < validCustomTicks.length; i++) { validCustomTicks[i] = validCustomTicks[i].toString(); } validCustomTicks = validCustomTicks.filter(function (element, index, array) { return !index || element !== array[index - 1]; }); } that.customTicks = validCustomTicks.slice(0); } /** * Plots the Gauge's ticks and labels. */ addGaugeTicksAndLabels() { const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; const that = this.context, numericProcessor = this, maxLabelHeight = Math.max(that._tickIntervalHandler.labelsSize.minLabelSize, that._tickIntervalHandler.labelsSize.maxLabelSize), majorStep = that._majorTicksInterval, minorStep = that._minorTicksInterval, majorTickValues = {}, distance = that._distance, radius = that._measurements.radius, majorTickWidth = radius - distance.majorTickDistance, minorTickWidth = radius - distance.minorTickDistance, bigDrawMin = new LW.Utilities.BigNumber(that._drawMin), bigDrawMax = new LW.Utilities.BigNumber(that._drawMax); let drawMajor, drawMinor, addLabel, currentAngle, angleAtMin, angleAtMax; if (that.ticksVisibility !== 'none' && that._plotTicks !== false) { drawMajor = function (angle) { that._drawTick(angle, majorTickWidth, 'major'); }; drawMinor = function (value) { that._drawTick(numericProcessor.getAngleByValue(value, true), minorTickWidth, 'minor'); }; } else { drawMajor = function () { }; drawMinor = function () { }; } if (that.labelsVisibility !== 'none' && that._plotLabels !== false) { addLabel = function (angle, currentLabel, middle) { that._drawLabel(angle, currentLabel, distance.labelDistance, middle); }; } else { addLabel = function () { }; } if (that.inverted === undefined || (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { angleAtMin = that.endAngle; angleAtMax = that.startAngle; } else { angleAtMin = that.startAngle; angleAtMax = that.endAngle; } // first major tick and label currentAngle = numericProcessor.getAngleByValue(bigDrawMin, false); drawMajor(currentAngle); majorTickValues[that._drawMin.toString()] = true; addLabel(currentAngle, that.min, false); let second = bigDrawMin.subtract(bigDrawMin.mod(majorStep)), firstMinTick; if (bigDrawMin.compare(0) !== -1) { second = second.add(majorStep); } // determines the value at the first minor tick for (let i = new LW.Utilities.BigNumber(second); i.compare(bigDrawMin) !== -1; i = i.subtract(minorStep)) { firstMinTick = i; } // second major tick and label currentAngle = numericProcessor.getAngleByValue(second, false); drawMajor(currentAngle); majorTickValues[second.toString()] = true; if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMin, numericProcessor.getAngleByValue(second, false, true)) / 360) > maxLabelHeight) { addLabel(currentAngle, this.getActualValue(second), second.compare(bigDrawMax) === -1); } let i; // middle major ticks and labels for (i = second.add(majorStep); i.compare(bigDrawMax.subtract(majorStep)) === -1; i = i.add(majorStep)) { currentAngle = numericProcessor.getAngleByValue(i, false); drawMajor(currentAngle); majorTickValues[i.toString()] = true; addLabel(currentAngle, this.getActualValue(i), true); } if (majorTickValues[i.toString()] === undefined && i.compare(bigDrawMax) !== 1) { // second-to-last major tick and label currentAngle = numericProcessor.getAngleByValue(i, false); drawMajor(currentAngle); majorTickValues[i.toString()] = true; if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, numericProcessor.getAngleByValue(i, false, true)) / 360) >= maxLabelHeight) { addLabel(currentAngle, this.getActualValue(i), true); } if (that._normalizedStartAngle !== that.endAngle) { // last major tick and label currentAngle = numericProcessor.getAngleByValue(bigDrawMax, false); drawMajor(currentAngle); if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, angleAtMin) / 360) >= maxLabelHeight) { addLabel(currentAngle, that.max, false); } } } if (that.mode === 'date') { LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; return; } // minor ticks if (!that.logarithmicScale) { for (let j = firstMinTick; j.compare(bigDrawMax) === -1; j = j.add(minorStep)) { if (majorTickValues[j.toString()]) { continue; // does not plot minor ticks over major ones } drawMinor(j); } } else { this.drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor); } LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; } /** * Sets toolTip's value and updates the value of the element. */ updateToolTipAndValue(value, oldValue, changeValue) { const that = this.context, logarithmicScale = that.logarithmicScale; that._updateTooltipValue(value.toString()); if (logarithmicScale) { value = parseFloat(Math.pow(10, parseFloat(value)).toFixed(11)); } value = value instanceof LW.Utilities.BigNumber ? value : new LW.Utilities.BigNumber(value); const stringifiedValue = value.toString(); that._number = value; that._drawValue = logarithmicScale ? Math.log10(stringifiedValue) : value; // eslint-disable-next-line if (value.compare(oldValue) !== 0 && changeValue) { if (that.mode === 'numeric') { that.value = stringifiedValue; value = stringifiedValue; } else { oldValue = that._valueDate; that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(stringifiedValue); that.value = value; value = that._valueDate; } if (!that._programmaticValueIsSet) { that.$.fireEvent('change', { 'value': value, 'oldValue': oldValue }); } if (that.$.hiddenInput) { that.$.hiddenInput.value = value; } that._setAriaValue('valuenow'); } } /** * Validates the interval property. */ validateInterval(interval) { const that = this.context, range = that._maxObject.subtract(that._minObject); that._validInterval = new LW.Utilities.BigNumber(interval); that._validInterval = this.round(that._validInterval); if (that._validInterval.compare(0) <= 0) { that._validInterval = new LW.Utilities.BigNumber(1); } if (that._validInterval.compare(range) === 1) { that._validInterval = range; } that.interval = that._validInterval.toString(); } /** * Returns a coerced value based on the interval. */ getCoercedValue(value, useDrawVariables, logarithmicGauge) { const that = this.context; if (!that.coerce) { return value; } const normalScale = !that.logarithmicScale; value = value instanceof LW.Utilities.BigNumber ? value : new LW.Utilities.BigNumber(value); let minValue, maxValue; if (that.customInterval) { const customTicks = that.customTicks; if (customTicks.length === 0) { return value; } let difference, closestValue; if (normalScale || logarithmicGauge) { minValue = that._minObject; difference = minValue.subtract(value).abs(); closestValue = minValue; for (let i = 0; i < customTicks.length; i++) { const currentTickObject = this.createDescriptor(customTicks[i]), currentDifference = currentTickObject.subtract(value).abs(); if (currentDifference.compare(difference) === -1) { difference = currentDifference; closestValue = currentTickObject; } } } else { minValue = that._drawMin; difference = Math.abs(minValue - parseFloat(value.toString())); closestValue = minValue; for (let i = 0; i < customTicks.length; i++) { const currentTickObject = Math.log10(customTicks[i]), currentDifference = Math.abs(currentTickObject - value); if (currentDifference < difference) { difference = currentDifference; closestValue = currentTickObject; } } closestValue = new LW.Utilities.BigNumber(closestValue); } return closestValue; } let interval = that._validInterval; if (that.mode === 'date') { if (that._dateIncrementMethod === 'addYears') { return this.coerceYear(value); } else if (that._dateIncrementMethod === 'addMonths') { return this.coerceMonth(value); } else { interval = new LW.Utilities.BigNumber(that._dateIntervalNumber).multiply(interval); } } if (useDrawVariables !== false) { minValue = new LW.Utilities.BigNumber(that._drawMin); maxValue = new LW.Utilities.BigNumber(that._drawMax); } else { minValue = new LW.Utilities.BigNumber(that.min); maxValue = new LW.Utilities.BigNumber(that.max); } let noMin = value.subtract(minValue), remainder = noMin.mod(interval); if (remainder.compare(0) === 0) { return value; } let lowerValue = noMin.subtract(remainder), greaterValue = lowerValue.add(interval); if ((noMin.subtract(lowerValue)).abs().compare((noMin.subtract(greaterValue)).abs()) < 0) { return lowerValue.add(minValue); } else { const biggerValue = greaterValue.add(minValue); return biggerValue.compare(maxValue) <= 0 ? biggerValue : lowerValue.add(minValue); } } coerceMonth(value) { const that = this.context, interval = parseFloat(that._validInterval), date = LW.Utilities.DateTime.fromFullTimeStamp(value), year = date.year(), month = date.month(), day = date.day(), minYear = that._minDate.year(), minMonth = that._minDate.month(), totalMonths = (that._maxDate.year() - minYear - 1) * 12 + 12 - minMonth + that._maxDate.month(); let currentMonths = (year - 1 - minYear) * 12 + (12 - minMonth) + (month); if (interval === 1) { if ([1, 3, 5, 7, 8, 10, 12].indexOf(month) !== -1) { if (day > 16 || day === 16 && date.hour() > 11) { currentMonths++; } } else if (month === 2) { if (date.isLeapYear(year)) { if (day > 15 || day === 15 && date.hour() > 11) { currentMonths++; } } else if (day > 14) { currentMonths++; } } else if (day > 15) { currentMonths++; } } currentMonths = this.getCoercedTimePart(0, totalMonths, currentMonths, interval); let result = that._minDate.addMonths(currentMonths, true); if (result.compare(that._maxDate) === 1) { result = that._minDate.addMonths(currentMonths - interval, true); } that._drawValue = new LW.Utilities.BigNumber(result.getTimeStamp()); return that._drawValue; } coerceYear(value) { const that = this.context, interval = parseFloat(that._validInterval), date = LW.Utilities.DateTime.fromFullTimeStamp(value), maxYear = that._maxDate.year(), updatedValueConstructorParameters = LW.Utilities.DateTime.getConstructorParameters(that._minDate); let year = date.year(); if (date.month() > 6) { year++; } let coercedTimePart = this.getCoercedTimePart(that._minDate.year(), maxYear, year, interval); if (coercedTimePart > maxYear) { coercedTimePart -= interval; } updatedValueConstructorParameters[0] = coercedTimePart; updatedValueConstructorParameters.unshift(null); const valueDate = new (Function.prototype.bind.apply(LW.Utilities.DateTime, updatedValueConstructorParameters)); that._drawValue = new LW.Utilities.BigNumber(valueDate.getTimeStamp()); return that._drawValue; } getCoercedTimePart(min, max, value, interval) { let noMin = value - min, remainder = noMin % interval; if (remainder === 0) { return value; } let lowerValue = parseFloat((noMin - remainder).toFixed(12)), greaterValue = lowerValue + interval; if (max - min <= interval) { return value >= min + (max - min) / 2 ? max : min; } if (Math.abs(noMin - lowerValue) < Math.abs(noMin - greaterValue)) { return lowerValue + min; } else { const biggerValue = greaterValue + min; return biggerValue > max ? lowerValue + min : biggerValue; } } /** * Updates the value of the Tank and the "value" property and triggers the respective events. */ updateValue(value) { const that = this.context; value = value instanceof LW.Utilities.BigNumber ? value : new LW.Utilities.BigNumber(value); const renderedValue = this.validate(value, that._minObject, that._maxObject); let oldValue = that.value, valueDetail, difference; that._number = renderedValue; that._drawValue = that.logarithmicScale ? Math.log10(renderedValue) : renderedValue; if (that.mode === 'numeric') { valueDetail = value.toString(); that.value = valueDetail; difference = this.compare(value, oldValue); } else { oldValue = LW.Utilities.DateTime.fromFullTimeStamp(oldValue); that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(value); that.value = value; value = that._valueDate; valueDetail = value; difference = value.compare(oldValue) !== 0; } if (!that._programmaticValueIsSet && (difference || that._scaleTypeChangedFlag)) { that.$.fireEvent('change', { 'value': valueDetail, 'oldValue': oldValue }); } if (that.$.hiddenInput) { that.$.hiddenInput.value = value; } that._setAriaValue('valuenow'); that._moveThumbBasedOnValue(that._drawValue); } /** * Returns value per pixel. */ getValuePerPx(range, pxRange) { const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; const result = new LW.Utilities.BigNumber(range).divide(pxRange); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; return result; } /** * Restricts the thumbs to not pass each other. */ restrictValue(values) { if (values[1].constructor === LW.Utilities.BigNumber) { if (values[1].compare(values[0]) === -1) { values[1].set(values[0]); } } else { if (values[1] < values[0]) { values[1] = values[0]; } } } /** * Returns the angle equivalent of a value. */ getAngleByValue(value, calculateDrawValue, returnDegrees) { const that = this.context, ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; if (that._wordLengthNumber < 64) { LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; return super.getAngleByValue(parseFloat(value.toString()), calculateDrawValue, returnDegrees); } if (value instanceof LW.Utilities.BigNumber === false) { value = new LW.Utilities.BigNumber(value); } if (calculateDrawValue !== false && that.logarithmicScale) { value = new LW.Utilities.BigNumber(Math.log10(value.toString())); } const angleOffset = value.subtract(that._drawMin).multiply(that._angleRangeCoefficient); let degrees; if (that.inverted === undefined || (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { degrees = angleOffset.multiply(-1).add(that.endAngle); } else { degrees = angleOffset.add(that.startAngle); } degrees = parseFloat(degrees.toString()); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; if (returnDegrees) { return degrees; } return degrees * Math.PI / 180 + Math.PI / 2; } /** * Returns the value equivalent of an angle. */ getValueByAngle(angle) { const that = this.context; if (that._wordLengthNumber < 64) { return super.getValueByAngle(angle, true); } const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; let minuendAngle, subtrahendAngle, value; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; if (that.inverted === undefined || (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { minuendAngle = that.endAngle; subtrahendAngle = angle; } else { minuendAngle = angle; subtrahendAngle = that._normalizedStartAngle; } while (minuendAngle < subtrahendAngle) minuendAngle += 360; value = new LW.Utilities.BigNumber((minuendAngle - subtrahendAngle) / that._angleDifference).multiply(that._range).add(that._drawMin); if (that.logarithmicScale) { value = new LW.Utilities.BigNumber(Math.pow(10, value.toString())); } let result; if (that.coerce) { result = this.getCoercedValue(value, false); } else { result = this.round(value); } LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; return new LW.Utilities.BigNumber(result); } /** * Updates the values of the Gauge and its digital display and fires the "change" event. */ updateGaugeValue(newValue) { if (newValue instanceof LW.Utilities.BigNumber === false) { return super.updateGaugeValue(newValue); } const that = this.context, oldValue = that._getEventValue(); if (that.mode === 'numeric') { that.value = newValue.toString(); that.$.digitalDisplay.value = that.value; } else { that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(newValue); that.value = newValue; } that._drawValue = that.logarithmicScale ? Math.log10(that.value).toString() : that.value; that._number = newValue; that.$.fireEvent('change', { 'value': that._getEventValue(), 'oldValue': oldValue }); that._setAriaValue('valuenow'); } /** * Validates the start or end value of a Gauge color range. */ validateColorRange(value) { const that = this.context; if (that._wordLengthNumber < 64) { return super.validateColorRange(value); } if (that.mode === 'numeric') { value = new LW.Utilities.BigNumber(value); } else { value = LW.Utilities.DateTime.validateDate(value); value = value.getTimeStamp(); } const bigMin = new LW.Utilities.BigNumber(that.min), bigMax = new LW.Utilities.BigNumber(that.max); if (value.compare(bigMin) === -1) { value = bigMin; } if (value.compare(bigMax) === 1) { value = bigMax; } return value; } /** * Locks the Gauge's interaction with the mouse. */ lockRotation(directionCondition, newValue) { const that = this.context; if (newValue instanceof LW.Utilities.BigNumber === false) { newValue = new LW.Utilities.BigNumber(newValue); } if (directionCondition && newValue.compare(that._number) === -1) { that._lockCW = true; if (newValue.compare(that._maxObject) === -1) { return new LW.Utilities.BigNumber(that._maxObject); } } else if (!directionCondition && newValue.compare(that._number) === 1) { that._lockCCW = true; if (newValue.compare(that._minObject) === 1) { return new LW.Utilities.BigNumber(that._minObject); } } } /** * Gets the angle-range coefficient. */ getAngleRangeCoefficient() { const that = this.context, ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; that._angleRangeCoefficient = new LW.Utilities.BigNumber(that._angleDifference).divide(that._range); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; } }); /** * A class for processesing floating point numbers. */ LW.Utilities.Assign('DecimalNumericProcessor', class DecimalNumericProcessor extends LW.Utilities.BaseNumericProcessor { constructor(context, numericFormatProperty) { super(context, numericFormatProperty); this.context = context; } /** * Returns the precise modulo of the mod operation. */ getPreciseModulo(dividend, divisor, moduloCoefficient) { const sign = dividend >= 0 ? 1 : -1; dividend = Math.abs(dividend); divisor = Math.abs(divisor); if (typeof moduloCoefficient === 'undefined') { const dividendExponential = dividend.toExponential(), divisorExponential = divisor.toExponential(), dividendExponent = parseInt(dividendExponential.slice(dividendExponential.indexOf('e') + 1), 10), divisorExponent = parseInt(divisorExponential.slice(divisorExponential.indexOf('e') + 1), 10), dividendRoundCoefficient = dividendExponent < 0 ? Math.abs(dividendExponent) : 0, divisorRoundCoefficient = divisorExponent < 0 ? Math.abs(divisorExponent) : 0, roundCoefficient = Math.max(dividendRoundCoefficient, divisorRoundCoefficient); this.roundCoefficient = roundCoefficient; if (dividend < divisor) { return sign * dividend; } if (dividend === divisor) { return 0; } if ((dividend < -1 || dividend > 1) && (divisor < -1 || divisor > 1 || divisor === 1)) { if (dividend % 1 === 0 && divisor % 1 === 0) { return sign * (dividend % divisor); } else { const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; const result = sign * parseFloat(new LW.Utilities.BigNumber(dividend).mod(divisor).toString()); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; return result; } } const moduloCoefficient = Math.pow(10, roundCoefficient); return sign * (((dividend * moduloCoefficient) % (divisor * moduloCoefficient)) / moduloCoefficient); } return sign * (Math.round(dividend * moduloCoefficient) % Math.round(divisor * moduloCoefficient)); } /** * Creates a descriptor. */ createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax) { let returnValue = parseFloat(initialValue); if (validateMinMax) { returnValue = this.validate(returnValue, this.context._minObject, this.context._maxObject); } return returnValue; } /** * Returns a rounded number */ round(value) { return Math.round(value); } /** * Validates the value. */ validate(initialValue, min, max) { let returnValue; if (initialValue < min) { returnValue = min; } else if (initialValue > max) { returnValue = max; } else { returnValue = initialValue; } return returnValue; } /** * Validates min/max. */ validateMinMax(validateMin, validateMax) { const that = this.context, checkSpecialRegexMin = typeof (that._regexSpecial) !== 'undefined' ? that._regexSpecial.inf.test(that.min) : false, checkSpecialRegexMax = typeof (that._regexSpecial) !== 'undefined' ? that._regexSpecial.inf.test(that.max) : false; if (validateMin) { if (that.min === null || checkSpecialRegexMin) { that.min = -Infinity; that._minObject = -Infinity; } else { that.min = that.min.toString().replace(/\s/g, ''); if (this.regexScientificNotation.test(that.min)) { that.min = this.scientificToDecimal(that.min); } that._minObject = that._discardDecimalSeparator(that.min); } } if (validateMax) { if (that.max === null || checkSpecialRegexMax) { that.max = Infinity; that._maxObject = Infinity; } else { that.max = that.max.toString().replace(/\s/g, ''); if (this.regexScientificNotation.test(that.max)) { that.max = this.scientificToDecimal(that.max); } that._maxObject = that._discardDecimalSeparator(that.max); } } if (!this.compare(that._minObject, that._maxObject)) { //Set default values that._maxObject = parseFloat(that._maxObject) + 1; that.max = that._maxObject; } } /** * Returns the pixel equivalent of a value. */ valueToPx(value) { const that = this.context, lengthRangeRatio = that._measurements.trackLength / that._range; let result; if (that._normalLayout) { result = lengthRangeRatio * (value - that._drawMin); } else { result = lengthRangeRatio * (that._drawMax - value); } return Math.round(result); } /** * Returns the value equivalent of a pixel offset. */ pxToValue(px) { const that = this.context; let result; if (that._normalLayout) { result = (px - that._trackStart) * that._valuePerPx; } else { result = (that._trackEnd - px) * that._valuePerPx; } if (that.logarithmicScale) { const power = result + parseFloat(that._drawMin); return Math.pow(10, power); } return this.validate(result + that._minObject, that._minObject, that._maxObject); } /** * Decimal compare method. */ compare(initialValue, otherValue, thorough) { initialValue = parseFloat(initialValue); otherValue = parseFloat(otherValue); if (thorough !== true) { return initialValue !== otherValue; } if (initialValue < otherValue) { return -1; } if (initialValue > otherValue) { return 1; } return 0; } /** * Increments/Decrements value. Keyboard navigation operations. */ incrementDecrement(initialValue, operation, stepObject) { const that = this.context; let returnValue; if (operation === 'add') { returnValue = parseFloat(initialValue) + parseFloat(stepObject); if (that._drawMax !== undefined) { return returnValue > parseFloat(that._drawMax) ? that._drawMax : returnValue; } } else { returnValue = parseFloat(initialValue) - parseFloat(stepObject); if (that._drawMin !== undefined) { return returnValue < parseFloat(that._drawMin) ? that._drawMin : returnValue; } } return returnValue; } /** * Renders the value. */ render(initialValue) { const that = this.context, checkSpecialRegex = typeof (that._regexSpecial) !== 'undefined' ? that._regexSpecial.nonNumericValue.test(initialValue) : false; if (checkSpecialRegex) { return initialValue; } else { const numberRenderer = new LW.Utilities.NumberRenderer(initialValue); if (that.scientificNotation) { return numberRenderer.toScientific(that.significantDigits, that.precisionDigits); } else { return numberRenderer.toDigits(that.significantDigits, that.precisionDigits); } } } /** * Adds tank's ticks and labels. */ addTicksAndLabels() { const that = this.context, trackLength = that._measurements.trackLength, normalLayout = that._normalLayout, ticksFrequency = that._majorTicksInterval, tickscount = Math.round(that._range / parseFloat((ticksFrequency.toString()))), ticksDistance = trackLength / tickscount, min = parseFloat(that._drawMin), max = parseFloat(that._drawMax); let first, second, distanceModifier, last, firstLabelValue, firstLabelSize, lastLabelValue, lastLabelSize, currentTickAndLabel, ticks = '', labels = ''; that._tickValues = []; this._longestLabelSize = 0; if (normalLayout) { first = min; //handling specific case if (that.logarithmicScale && min < 0 && min !== -1) { second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency)); } else { second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency) + parseFloat(ticksFrequency)); } distanceModifier = second - first; firstLabelValue = that._formatLabel(min); firstLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize; last = max; lastLabelValue = that._formatLabel(max); lastLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize; } else { first = max; second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency)); distanceModifier = first - second; firstLabelValue = that._formatLabel(max); firstLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize; last = min; lastLabelValue = that._formatLabel(min); lastLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize; } that._labelDummy = this._createMeasureLabel(); currentTickAndLabel = this._addMajorTickAndLabel(firstLabelValue, firstLabelSize, true, first); // first tick and label ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; // special case for second tick and label const distanceFromFirstToSecond = distanceModifier / ticksFrequency * ticksDistance; if (second.toString() !== that._drawMax.toString() && distanceFromFirstToSecond < trackLength) { // second item rendering const secondItemHtmlValue = that._formatLabel(second.toString()), plotSecond = firstLabelSize < distanceFromFirstToSecond; currentTickAndLabel = this._addMajorTickAndLabel(secondItemHtmlValue, undefined, plotSecond, second, true); ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; } currentTickAndLabel = this.addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency); ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; currentTickAndLabel = this._addMajorTickAndLabel(lastLabelValue, lastLabelSize, true, last); // last tick and label ticks += currentTickAndLabel.tick; labels += currentTickAndLabel.label; ticks += this.addMinorTicks(normalLayout); that._measureLabelScale.removeChild(that._labelDummy); delete that._labelDummy; delete that._measureLabelScale; if (that.nodeName.toLowerCase() === 'lw-tank') { that._updateScaleWidth(this._longestLabelSize); } that._appendTicksAndLabelsToScales(ticks, labels); } /** * Adds the middle major ticks and their respective labels. */ addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency) { const that = this.context; let majorTicks = '', majorLabels = ''; for (let i = 1; i < tickscount; i++) { let number = i * ticksDistance + distanceFromFirstToSecond, value; if (normalLayout) { value = parseFloat(that._drawMin) + ticksFrequency * i + distanceModifier; } else { value = parseFloat(that._drawMax) - ticksFrequency * i - distanceModifier; } if (value.toString() !== that._drawMax.toString()) { let htmlValue = that._formatLabel(value.toString()), plot = true; that._labelDummy.innerHTML = htmlValue; let dimensionValue = that._labelDummy[that._settings.size]; if (number + dimensionValue >= tickscount * ticksDistance) { // + 32 is an Experimental value plot = false; } const currentTickAndLabel = this._addMajorTickAndLabel(htmlValue, undefined, plot, value, true); majorTicks += currentTickAndLabel.tick; majorLabels += currentTickAndLabel.label; } } return { tick: majorTicks, label: majorLabels }; } /** * Adds minor ticks. */ addMinorTicks(normalLayout) { function getPreciseFraction(i) { return parseFloat((i).toFixed(roundCoefficient)); } function addMinorTick(i) { if (tickValues.indexOf(i) === -1 && that._numericProcessor.getPreciseModulo(i, minorTicksInterval, moduloCoefficient) === 0) { minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(i) + 'px;" class="lw-tick lw-tick-minor"></div>'; } } const that = this.context, tickValues = that._tickValues, nearestPowerOfTen = that._tickIntervalHandler.nearestPowerOfTen, minorTicksInterval = that._minorTicksInterval, roundCoefficient = Math.log10(nearestPowerOfTen) < 0 ? Math.round(Math.abs(Math.log10(nearestPowerOfTen))) : 0, moduloCoefficient = Math.pow(10, roundCoefficient), leftOrTop = that._settings.leftOrTop; let firstTickValue, secondTickValue, lastTickValue, minorTicks = ''; if (normalLayout) { firstTickValue = tickValues[0]; secondTickValue = tickValues[1]; lastTickValue = tickValues[tickValues.length - 1] } else { firstTickValue = tickValues[tickValues.length - 1]; secondTickValue = tickValues[tickValues.length - 2]; lastTickValue = tickValues[0] } if (that.logarithmicScale) { addMinorTickOnLogarithmicScale(); } else { // minor ticks from the beginning to the second major tick for (let i = secondTickValue; i > firstTickValue; i = getPreciseFraction(i - nearestPowerOfTen)) { addMinorTick(i); } // minor ticks from the second major tick to the end for (let i = getPreciseFraction(secondTickValue + nearestPowerOfTen); i < lastTickValue; i = getPreciseFraction(i + nearestPowerOfTen)) { addMinorTick(i); } } function addMinorTickOnLogarithmicScale() { let trackLength = that._measurements.trackLength, partialTrackLength = trackLength / tickValues.length, modifierCoef = 0.1; if (partialTrackLength < 20) { modifierCoef = 1; } else if ((partialTrackLength >= 20) && (partialTrackLength < 40)) { modifierCoef = (secondTickValue - firstTickValue) > 1 ? 1 : 0.5; } else if ((partialTrackLength >= 40) && (partialTrackLength < 80)) { modifierCoef = 0.2; } let nearestPowerOf10BelowMax = Math.floor(that._drawMax), distanceToNearestPowerOf10 = that._drawMax - nearestPowerOf10BelowMax, ticksOnPowerOf10 = (that._drawMax - that._drawMin) > tickValues.length; for (let j = that._drawMax; j > that._drawMin - 1; j = j - 1) { let range = distanceToNearestPowerOf10 > 0 ? Math.pow(10, j - distanceToNearestPowerOf10 + 1) : Math.pow(10, j), modifier = range * modifierCoef; for (let i = range; i > 0; i = (i - modifier)) { if ((i < that.max) && (i > that.min)) { let value = new LW.Utilities.BigNumber(Math.log10(i)); if (((value % 1 === 0) && ticksOnPowerOf10) || !ticksOnPowerOf10) { minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(value) + 'px;" class="lw-tick lw-tick-minor"></div>'; } } } } } return minorTicks; } /** * Validates custom ticks. */ validateCustomTicks() { const that = this.context; let validCustomTicks = []; for (let i = 0; i < that.customTicks.length; i++) { const currentTick = that.customTicks[i], currentTickObject = this.createDescriptor(currentTick); if (currentTickObject >= that._minObject && currentTickObject <= that._maxObject) { validCustomTicks.push(currentTickObject.toString()); } } validCustomTicks.sort(function (a, b) { return a - b; }); validCustomTicks = validCustomTicks.filter(function (element, index, array) { return !index || element !== array[index - 1]; }); that.customTicks = validCustomTicks.slice(0); } /** * Plots the Gauge's ticks and labels. */ addGaugeTicksAndLabels() { const that = this.context, numericProcessor = this, maxLabelHeight = Math.max(that._tickIntervalHandler.labelsSize.minLabelSize, that._tickIntervalHandler.labelsSize.maxLabelSize), majorStep = that._majorTicksInterval, minorStep = that._minorTicksInterval, majorTickValues = {}, distance = that._distance, radius = that._measurements.radius, majorTickWidth = radius - distance.majorTickDistance, minorTickWidth = radius - distance.minorTickDistance; let drawMajor, drawMinor, addLabel, currentAngle, angleAtMin, angleAtMax; if (that.ticksVisibility !== 'none' && that._plotTicks !== false) { drawMajor = function (angle) { that._drawTick(angle, majorTickWidth, 'major'); }; drawMinor = function (value) { that._drawTick(numericProcessor.getAngleByValue(value, true), minorTickWidth, 'minor'); }; } else { drawMajor = function () { }; drawMinor = function () { }; } if (that.labelsVisibility !== 'none' && that._plotLabels !== false) { addLabel = function (angle, currentLabel, middle) { that._drawLabel(angle, currentLabel, distance.labelDistance, middle); }; } else { addLabel = function () { }; } if (that.inverted === undefined || (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { angleAtMin = that.endAngle; angleAtMax = that.startAngle; } else { angleAtMin = that.startAngle; angleAtMax = that.endAngle; } // first major tick and label currentAngle = numericProcessor.getAngleByValue(that._drawMin, false); drawMajor(currentAngle); majorTickValues[that._drawMin] = true; addLabel(currentAngle, that.min, false); let second = that._drawMin - numericProcessor.getPreciseModulo(that._drawMin, majorStep), firstMinTick; if (that._drawMin >= 0) { second += majorStep; } // determines the value at the first minor tick for (let i = second; i >= that._drawMin; i = i - minorStep) { firstMinTick = i; } // second major tick and label currentAngle = numericProcessor.getAngleByValue(second, false); drawMajor(currentAngle); majorTickValues[second] = true; if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMin, numericProcessor.getAngleByValue(second, false, true)) / 360) > maxLabelHeight) { addLabel(currentAngle, this.getActualValue(second), second < that._drawMax); } let i; // middle major ticks and labels for (i = second + majorStep; i < that._drawMax - majorStep; i += majorStep) { currentAngle = numericProcessor.getAngleByValue(i, false); drawMajor(currentAngle); majorTickValues[i] = true; addLabel(currentAngle, this.getActualValue(i), true); } if (majorTickValues[i] === undefined && i <= that._drawMax) { // second-to-last major tick and label currentAngle = numericProcessor.getAngleByValue(i, false); drawMajor(currentAngle); majorTickValues[i] = true; if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, numericProcessor.getAngleByValue(i, false, true)) / 360) >= maxLabelHeight) { addLabel(currentAngle, this.getActualValue(i), true); } if (that._normalizedStartAngle !== that.endAngle) { // last major tick and label currentAngle = numericProcessor.getAngleByValue(that._drawMax, false); drawMajor(currentAngle); majorTickValues[that._drawMax] = true; if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, angleAtMin) / 360) >= maxLabelHeight) { addLabel(currentAngle, that.max, false); } } } // minor ticks if (!that.logarithmicScale) { for (let j = firstMinTick; j < that._drawMax; j += minorStep) { if (majorTickValues[j]) { continue; // does not plot minor ticks over major ones } drawMinor(j); } } else { this.drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor); } } /** * Sets toolTip's value and updates the value of the element. */ updateToolTipAndValue(value, oldValue, changeValue) { const that = this.context, logarithmicScale = that.logarithmicScale; that._updateTooltipValue(value); if (logarithmicScale) { value = parseFloat(Math.pow(10, parseFloat(value)).toFixed(11)); } const stringifiedValue = value.toString(); that._number = value; that._drawValue = logarithmicScale ? Math.log10(stringifiedValue) : value; // eslint-disable-next-line if (stringifiedValue !== oldValue && changeValue) { that.value = that._discardDecimalSeparator(stringifiedValue); if (!that._programmaticValueIsSet) { that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue }); } if (that.$.hiddenInput) { that.$.hiddenInput.value = that.value; } that._setAriaValue('valuenow'); } } /** * Validates the interval property. */ validateInterval(interval) { const that = this.context, range = that._maxObject - that._minObject; if (interval <= 0) { interval = 1; } that._validInterval = Math.min(parseFloat(interval), range); that.interval = that._validInterval; } /** * Returns a coerced value based on the interval. */ getCoercedValue(value, useDrawVariables, logarithmicGauge) { const that = this.context; if (!that.coerce) { return value; } let normalScale = !that.logarithmicScale, minValue, maxValue; if (that.customInterval) { const customTicks = that.customTicks; if (customTicks.length === 0) { return value; } normalScale = normalScale || logarithmicGauge; if (useDrawVariables !== false) { minValue = parseFloat(that._drawMin); } else { minValue = that._minObject; } let difference = Math.abs(minValue - value), closestValue = minValue; for (let i = 0; i < customTicks.length; i++) { const currentTickObject = this.createDescriptor(customTicks[i]), currentTickValue = normalScale ? currentTickObject : Math.log10(currentTickObject), currentDifference = Math.abs(currentTickValue - value); if (currentDifference < difference) { difference = currentDifference; closestValue = currentTickValue; } } return closestValue; } if (useDrawVariables !== false) { minValue = parseFloat(that._drawMin); maxValue = parseFloat(that._drawMax); } else { minValue = parseFloat(that.min); maxValue = parseFloat(that.max); } let noMin = value - minValue, remainder = this.getPreciseModulo(noMin, parseFloat(that.interval)), coef = this.roundCoefficient; if (remainder === 0) { return value; } if (this.roundCoefficient === 0) { coef = 12; } let lowerValue = parseFloat((noMin - remainder).toFixed(coef)), greaterValue = lowerValue + parseFloat(that.interval); if (((that.max - that.min) <= parseFloat(that.interval)) && normalScale) { let min = minValue, max = maxValue; return value >= min + (max - min) / 2 ? max : min; } if (Math.abs(noMin - lowerValue) < Math.abs(noMin - greaterValue)) { return lowerValue + minValue; } else { const biggerValue = greaterValue + minValue; return biggerValue > maxValue ? lowerValue + minValue : biggerValue; } } /** * Updates the value of the Tank and the "value" property and triggers the respective events. */ updateValue(value) { const that = this.context, renderedValue = this.validate(value, that._minObject, that._maxObject), oldActualValue = that.value; if (value.toString() !== oldActualValue.toString() || that._scaleTypeChangedFlag) { that.value = value.toString(); that._number = renderedValue; if (!that._programmaticValueIsSet) { that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldActualValue }); } } else { that.value = typeof (value) === 'string' ? value : value.toString(); } that._drawValue = that.logarithmicScale ? Math.log10(renderedValue).toString() : renderedValue.toString(); that._moveThumbBasedOnValue(that._drawValue); if (that.$.hiddenInput) { that.$.hiddenInput.value = that.value; } that._setAriaValue('valuenow'); } /** * Returns value per pixel. */ getValuePerPx(range, pxRange) { return parseFloat(range) / pxRange; } /** * Restricts the thumbs to not pass each other. */ restrictValue(values) { if (values[1] < values[0]) { values[1] = values[0]; } } /** * Locks the Gauge's interaction with the mouse. */ lockRotation(directionCondition, newValue) { const that = this.context; if (directionCondition && newValue < that._number) { that._lockCW = true; if (newValue < that._maxObject) { return that._maxObject; } } else if (!directionCondition && newValue > that._number) { that._lockCCW = true; if (newValue > that._minObject) { return that._minObject; } } } /** * Gets the angle-range coefficient. */ getAngleRangeCoefficient() { const that = this.context; that._angleRangeCoefficient = that._angleDifference / that._range; } }); /** * A class for processesing complex numbers. */ LW.Utilities.Assign('ComplexNumericProcessor', class ComplexNumericProcessor extends LW.Utilities.BaseNumericProcessor { constructor(context, numericFormatProperty) { super(context, numericFormatProperty); this.context = context; } /** * Creates a Complex number descriptor. */ createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax, discardRadix, presetComplexNumber) { let returnValue; if (presetComplexNumber) { returnValue = presetComplexNumber; } else { if (initialValue.constructor === this.complexConstructor) { returnValue = new this.complexConstructor(initialValue.realPart, initialValue.imaginaryPart); } else { returnValue = new this.complexConstructor(initialValue); } } if (validateMinMax) { returnValue = this.validate(returnValue, this.context._minObject, this.context._maxObject); } return returnValue; } /** * Validates value. */ validate(initialValue, min, max) { let returnValue = initialValue; if (min !== -Infinity) { if (this.compareComplexNumbers(initialValue, min) === -1) { returnValue = new this.complexConstructor(min.realPart, min.imaginaryPart); } } else if (max !== Infinity) { if (this.compareComplexNumbers(initialValue, max) === 1) { returnValue = new this.complexConstructor(max.realPart, max.imaginaryPart); } } return returnValue; } /** * Complex number compare method. */ compare(initialValue, otherValue, thorough) { if (thorough !== true) { return this.compareComplexNumbers(initialValue, otherValue) !== 0; } return this.compareComplexNumbers(initialValue, otherValue); } /** * Validates min/max. */ validateMinMax(validateMin, validateMax) { const that = this.context; if (validateMin) { if (that.min === null || that._regexSpecial.inf.test(that.min)) { that.min = -Infinity; that._minObject = -Infinity; } else { that._minObject = new this.complexConstructor(that.min); } } if (validateMax) { if (that.max === null || that._regexSpecial.inf.test(that.max)) { that.max = Infinity; that._maxObject = Infinity; } else { that._maxObject = new this.complexConstructor(that.max); } } } /** * Increments/Decrements value. Keyboard navigation operations. */ incrementDecrement(initialValue, operation) { let returnValue = new this.complexConstructor(initialValue.realPart, initialValue.imaginaryPart), spinButtonsStepObject = this.context._spinButtonsStepObject; if (operation === 'add') { returnValue.realPart += spinButtonsStepObject.realPart; returnValue.imaginaryPart += spinButtonsStepObject.imaginaryPart; } else { returnValue.realPart -= spinButtonsStepObject.realPart; returnValue.imaginaryPart -= spinButtonsStepObject.imaginaryPart; } return returnValue; } /** * Renders the value. Complex number renderer. */ render(initialValue) { let returnValue = initialValue; if (this.context._regexSpecial.nonNumericValue.test(initialValue) === false) { let realPart = returnValue.realPart, imaginaryPart = returnValue.imaginaryPart, sign, significantDigits = this.context.significantDigits, precisionDigits = this.context.precisionDigits; if (imaginaryPart >= 0) { sign = '+'; } else { sign = '-'; imaginaryPart = Math.abs(imaginaryPart); } const realPartRenderer = new LW.Utilities.NumberRenderer(realPart), imaginaryPartRenderer = new LW.Utilities.NumberRenderer(imaginaryPart); if (this.context.scientificNotation) { realPart = realPartRenderer.toScientific(significantDigits, precisionDigits); imaginaryPart = imaginaryPartRenderer.toScientific(significantDigits, precisionDigits); } else { realPart = realPartRenderer.toDigits(significantDigits, precisionDigits); imaginaryPart = imaginaryPartRenderer.toDigits(significantDigits, precisionDigits); } returnValue = `${realPart} ${sign} ${imaginaryPart}i`; } return returnValue; } /** * Complex number compare method. */ compareComplexNumbers(left, right) { if ((left instanceof this.complexConstructor === false) || (right instanceof this.complexConstructor === false)) { // if at least one of the numbers is not an LW.Utilities.Complex object, the numbers are different return -1; } const leftReal = left.realPart, rightReal = right.realPart; if (leftReal < rightReal) { return -1; } else if (leftReal > rightReal) { return 1; } else { const leftImaginary = left.imaginaryPart, rightImaginary = right.imaginaryPart; if (leftImaginary < rightImaginary) { return -1; } else if (leftImaginary > rightImaginary) { return 1; } else { return 0; } } } }); LW.Utilities.Assign('NumberRenderer', class NumberRenderer { constructor(numericValue) { const that = this; that.numericValue = numericValue; that.powersToPrefixes = { '24': 'Y', '21': 'Z', '18': 'E', '15': 'P', '12': 'T', '9': 'G', '6': 'M', '3': 'k', '0': '', '-3': 'm', '-6': 'u', '-9': 'n', '-12': 'p', '-15': 'f', '-18': 'a', '-21': 'z', '-24': 'y' }; // dummy localization object that.localizationObject = { currencysymbol: '$', currencysymbolposition: 'before', decimalseparator: '.', thousandsseparator: ',', defaultPrecision: 2 } } isENotation(value) { return new RegExp(/e/i).test(value); } /** * Converts a large exponential value to its decimal representation (used when "inputFormat" is 'integer'). */ largeExponentialToDecimal(exponential) { let validateExponent; if (exponential === undefined) { exponential = this.numericValue; validateExponent = true; } let stringExponential = exponential.toString().toLowerCase(), indexOfE = stringExponential.indexOf('e'), mantissa = new LW.Utilities.BigNumber(stringExponential.slice(0, indexOfE)), sign = stringExponential.slice(indexOfE + 1, indexOfE + 2); if (sign !== '+' && sign !== '-') { stringExponential = stringExponential.slice(0, indexOfE) + 'e+' + stringExponential.slice(indexOfE + 1); sign = '+'; } let exponent = stringExponential.slice(indexOfE + 2), bigTen = new LW.Utilities.BigNumber(10), multyplyBy = bigTen.pow(sign + (validateExponent ? Math.min(20, exponent) : exponent)), result = mantissa.multiply(multyplyBy); return result.toString(); } /** * Converts a BigNumber integer value to an exponential value */ bigNumberToExponent(significantDigits, forceExponentialResult) { let value = this.numericValue; if (value.constructor !== LW.Utilities.BigNumber) { value = new LW.Utilities.BigNumber(value); } const numberLength = value._f; let numericString = value.toString(); if (numberLength <= 10) { // 32-bit or lower if (forceExponentialResult) { return parseFloat(numericString).toExponential(significantDigits !== null ? significantDigits - 1 : undefined); } else { return new LW.Utilities.NumberRenderer(parseFloat(numericString)).toDigits(significantDigits); } } else { // 64-bit if (significantDigits >= numberLength && !forceExponentialResult) { return numericString; } else { let sign; if (value._s === false) { sign = ''; } else { sign = '-'; numericString = numericString.slice(1); } const nextDigit = parseFloat(numericString.slice(significantDigits, significantDigits + 1)); if (nextDigit >= 5) { numericString = new LW.Utilities.BigNumber(numericString.slice(0, significantDigits)).add(1).toString(); } let digitsAfterDecimalSeparator = numericString.slice(1, significantDigits); if (forceExponentialResult) { significantDigits--; if (digitsAfterDecimalSeparator.length > 0 && significantDigits > digitsAfterDecimalSeparator.length) { digitsAfterDecimalSeparator = digitsAfterDecimalSeparator + ('0').repeat(significantDigits - digitsAfterDecimalSeparator.length); } else if (digitsAfterDecimalSeparator.length === 0) { digitsAfterDecimalSeparator = ('0').repeat(significantDigits); } } else { while (digitsAfterDecimalSeparator.length > 0 && digitsAfterDecimalSeparator.charAt(digitsAfterDecimalSeparator.length - 1) === '0') { digitsAfterDecimalSeparator = digitsAfterDecimalSeparator.slice(0, digitsAfterDecimalSeparator.length - 1); } } const decimalSeparator = digitsAfterDecimalSeparator.length > 0 ? '.' : '', power = numberLength - 1; return sign + numericString.slice(0, 1) + decimalSeparator + digitsAfterDecimalSeparator + 'E+' + power; } } } /** * Converts a plain number to scientific notation. */ toScientific() { const that = this; let exponentialValue; if (that.numericValue._d) { exponentialValue = that.bigNumberToExponent(arguments[0] !== null ? arguments[0] : arguments[1] + 1, true).toLowerCase(); } else { if (that.numericValue <= -1 || that.numericValue >= 1) { exponentialValue = Number(that.toDigits(arguments[0], arguments[1])).toExponential(); } else { exponentialValue = Number(that.numericValue).toExponential(); } } if (isNaN(exponentialValue)) { return exponentialValue; } const indexOfE = exponentialValue.indexOf('e'); let power = parseInt(exponentialValue.slice(indexOfE + 1), 10), coefficient = parseFloat(exponentialValue.slice(0, indexOfE)), coefficientRenderer = new LW.Utilities.NumberRenderer(coefficient); if (power < 0) { let test = coefficientRenderer.toDigits(arguments[0], arguments[1]); test = parseFloat(test).toExponential(); if (test.charAt(test.length - 1) === '0') { let i = 0; while (power % 3 !== 0) { power--; i++; } if (i) { const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; coefficient = parseFloat(new LW.Utilities.BigNumber(coefficient).multiply(Math.pow(10, i)).toString()); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; } coefficientRenderer.numericValue = coefficient; coefficient = coefficientRenderer.toDigits(arguments[0], arguments[1]); // test for alternative, more concise representation coefficientRenderer.numericValue = coefficient / 1000; const alternativeCoefficient = coefficientRenderer.toDigits(arguments[0], arguments[1]); if (alternativeCoefficient >= 1) { coefficient = alternativeCoefficient; power += 3; } return coefficient + that.powersToPrefixes[power.toString()]; } } let remainderPower = 0; if (Math.abs(power) > 24) { const sign = power / Math.abs(power); remainderPower = power - sign * 24; } else { remainderPower = power % 3; } if (remainderPower > 0) { for (let i = 0; i < remainderPower; i++) { coefficient = coefficient * 10; } } else if (remainderPower < 0) { const ignored = LW.Utilities.BigNumber.ignoreBigIntNativeSupport; LW.Utilities.BigNumber.ignoreBigIntNativeSupport = true; coefficient = parseFloat(new LW.Utilities.BigNumber(coefficient).multiply(Math.pow(10, remainderPower)).toString()); LW.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored; } if (power > 0) { const removeSign = coefficient >= 0 ? 0 : 1, floatFix = exponentialValue.slice(removeSign, indexOfE).length - remainderPower - 2; if (floatFix >= 0) { coefficient = coefficient.toFixed(floatFix); } } let oldCoefficientPower = Number(coefficient).toExponential(); oldCoefficientPower = parseFloat(oldCoefficientPower.charAt(oldCoefficientPower.length - 1)); coefficientRenderer.numericValue = coefficient; coefficient = coefficientRenderer.toDigits(arguments[0], arguments[1]); let newCoefficientPower = Number(coefficient).toExponential(), powerCorrection = 0; newCoefficientPower = parseFloat(newCoefficientPower.charAt(newCoefficientPower.length - 1)); if (newCoefficientPower !== oldCoefficientPower && newCoefficientPower % 3 === 0) { coefficient = parseFloat(coefficient) / (Math.pow(10, newCoefficientPower)); coefficientRenderer.numericValue = coefficient; coefficient = coefficientRenderer.toDigits(arguments[0], arguments[1]); powerCorrection = newCoefficientPower; } const finalPower = power - remainderPower + powerCorrection, scientificValue = coefficient + that.powersToPrefixes[finalPower.toString()]; return scientificValue; } /** * Converts a BigNumber to scientific notation. */ bigNumberToScientific() { const that = this, power = that.numericValue._f - 1, remainderPower = parseInt(power, 10) % 3, finalPower = parseInt(power, 10) - remainderPower; let stringRepresentation = that.numericValue.toString(), sign, scientificValue; if (stringRepresentation.charAt(0) === '-') { sign = '-'; stringRepresentation = stringRepresentation.slice(1); } else { sign = ''; } if (arguments[0] !== null) { scientificValue = stringRepresentation.slice(0, arguments[0]); if (parseFloat(stringRepresentation.slice(arguments[0], arguments[0] + 1)) >= 5) { scientificValue = new LW.Utilities.BigNumber(scientificValue).add(1).toString(); } while (scientificValue.length > 1 + remainderPower && scientificValue.charAt(scientificValue.length - 1) === '0') { scientificValue = scientificValue.slice(0, scientificValue.length - 1); } } else if (arguments[1] !== null) { scientificValue = stringRepresentation.slice(0, arguments[1] + 1); if (parseFloat(stringRepresentation.slice(arguments[1] + 1, arguments[1] + 2)) >= 5) { scientificValue = new LW.Utilities.BigNumber(scientificValue).add(1).toString(); } if (arguments[1] + remainderPower > scientificValue.length - 1) { scientificValue = scientificValue + ('0').repeat(arguments[1] + remainderPower - scientificValue.length + 1); } } if (scientificValue.length > 1 + remainderPower) { scientificValue = scientificValue.slice(0, 1 + remainderPower) + '.' + scientificValue.slice(1 + remainderPower); } return sign + scientificValue + that.powersToPrefixes[finalPower.toString()]; } /** * Applies the significant digits or precision digits settings to the number. */ toDigits(significantDigits, precisionDigits) { const that = this; let renderedValue; if (significantDigits !== null) { renderedValue = that.applySignificantDigits(significantDigits); } else if (precisionDigits !== null) { renderedValue = that.applyPrecisionDigits(precisionDigits); } else { renderedValue = that.applySignificantDigits(8); } return renderedValue; } /** * Returns the number with a specified number of significant digits. */ applySignificantDigits(significantDigits) { const that = this; significantDigits = Math.max(1, Math.min(significantDigits, 21)); // removes insignificant trailing zeroes function removeTrailingZeroes(value) { while (value.charAt(value.length - 1) === '0') { value = value.slice(0, -1); } if (value.charAt(value.length - 1) === '.') { value = value.slice(0, -1); } return value; } let renderedValue = parseFloat(that.numericValue).toPrecision(significantDigits).toUpperCase(); if (renderedValue.indexOf('.') !== -1) { if (that.isENotation(renderedValue)) { const indexOfDecimalSeparator = renderedValue.indexOf('.'), indexOfE = renderedValue.indexOf('E') let digitsAfterDecimalSeparator = renderedValue.slice(indexOfDecimalSeparator, indexOfE); digitsAfterDecimalSeparator = removeTrailingZeroes(digitsAfterDecimalSeparator); renderedValue = renderedValue.slice(0, indexOfDecimalSeparator) + digitsAfterDecimalSeparator + renderedValue.slice(indexOfE); } else { renderedValue = removeTrailingZeroes(renderedValue); } } return renderedValue; } /** * Returns the number with a specified number of precision digits. */ applyPrecisionDigits(precisionDigits) { const that = this; precisionDigits = Math.max(0, Math.min(precisionDigits, 20)); let renderedValue = parseFloat(that.numericValue).toFixed(precisionDigits); if (that.isENotation(renderedValue)) { renderedValue = that.largeExponentialToDecimal(renderedValue) + '.' + '0'.repeat(precisionDigits); } return renderedValue; } /** * Returns the logarithm of a value (for use in logarithmic scales). */ getLogarithm(base) { const value = this.numericValue; let result; if (base === undefined) { base = 10; } if (base === 10) { try { result = Math.log10(value); } catch (error) { result = Math.log(value) / Math.log(10); } } else { result = Math.log(value) / Math.log(base); } return result; } /** * Applies separators. */ applySeparators(number, noThousandsSeparator) { const that = this; number = number.toString(); const dotIndex = number.indexOf('.'); if (dotIndex !== -1) { const integerPart = number.slice(0, dotIndex), fractionalPart = number.slice(dotIndex + 1); return that.applyThousandsSeparator(integerPart, noThousandsSeparator) + that.localizationObject.decimalseparator + fractionalPart; } else { return that.applyThousandsSeparator(number, noThousandsSeparator); } } /** * Applies thousands separator. */ applyThousandsSeparator(number, noThousandsSeparator) { if (noThousandsSeparator) { return number; } let sign = ''; number = number.toString(); if (number.charAt(0) === '-') { sign = '-'; number = number.slice(1); } let digits = number.split('').reverse(); for (let i = 2; i < digits.length - 1; i += 3) { digits[i] = this.localizationObject.thousandsseparator + digits[i]; } digits.reverse(); digits = digits.join(''); return sign + digits; } /** * Returns a formatted representation of a number. */ formatNumber(number, formatSpecifier, wordLength) { const that = this; if (arguments[3] === undefined) { delete that._ignoreMinus; } delete that._wordLengthNumber; if (!/^([a-zA-Z]\d*)$/g.test(formatSpecifier)) { try { const result = that.applyCustomFormat(number, formatSpecifier); return result; } catch (error) { return number.toString(); } } const format = formatSpecifier.slice(0, 1); let precision = formatSpecifier.slice(1); if (precision !== '') { if (isNaN(parseFloat(precision)) || parseFloat(precision) < 0 || parseFloat(precision) > 99) { precision = ''; } else if (parseFloat(precision) % 1 !== 0) { precision = Math.round(precision); } } if (number._d) { that.inputFormat = 'integer'; } else if (number.imaginaryPart) { return that.formatComplexNumber(number, formatSpecifier, format, precision); } else { that.inputFormat = 'floatingPoint'; } let numericProcessor = new LW.Utilities.NumericProcessor(that, 'inputFormat'), numericObject = numericProcessor.createDescriptor(number), result; that._wordLengthNumber = numericProcessor.getWordLength(wordLength ? wordLength : 'int32'); if (that.inputFormat === 'integer') { numericObject = numericProcessor.round(numericObject); } that.numericValue = numericObject; switch (format) { case 'C': case 'c': // Currency if (precision === '') { precision = that.localizationObject.defaultPrecision; } precision = parseFloat(precision); if (that.inputFormat === 'floatingPoint') { result = that.applyPrecisionDigits(precision); } else { result = numericObject.toString() + (precision > 0 ? '.' + ('0').repeat(precision) : ''); } result = that.applySeparators(result); if (that.localizationObject.currencysymbolposition === 'before') { if (result.charAt(0) === '-') { return '-' + that.localizationObject.currencysymbol + result.slice(1); } return that.localizationObject.currencysymbol + result; } return result + ' ' + that.localizationObject.currencysymbol; case 'D': case 'd': { // Decimal; integer-only result = numericObject; if (that.inputFormat === 'floatingPoint') { result = Math.round(numericObject); } result = result.toString(); if (precision === '') { return result; } let sign = ''; if (result.charAt(0) === '-') { sign = '-'; result = result.slice(1); } const difference = precision - result.length; if (difference > 0) { result = ('0').repeat(difference) + result; } return sign + result; } case 'E': case 'e': case 'U': case 'u': { // Exponential (scientific) if (precision === '') { precision = 6; } if (that.inputFormat === 'floatingPoint') { result = numericObject.toExponential(precision); } else { result = that.bigNumberToExponent(parseFloat(precision) + 1, true).toLowerCase(); } const indexOfE = result.indexOf('e'), numbersInExponent = result.slice(indexOfE + 2).length; if (numbersInExponent < 3) { result = result.slice(0, indexOfE + 2) + ('0').repeat(3 - numbersInExponent) + result.slice(indexOfE + 2); } if (format.toLowerCase() === 'u') { return that.exponentialToSuperscript(that.applySeparators(result, true)); } if (format === 'E') { result = result.toUpperCase(); } return that.applySeparators(result, true); } case 'F': case 'f': case 'N': case 'n': // Fixed-point and Number if (precision === '') { precision = that.localizationObject.defaultPrecision; } precision = parseFloat(precision); if (that.inputFormat === 'floatingPoint') { result = that.applyPrecisionDigits(precision); } else { result = numericObject.toString() + (precision > 0 ? '.' + ('0').repeat(precision) : ''); } return that.applySeparators(result, format.toLowerCase() === 'f'); case 'G': case 'g': { // General if (precision === '' || precision === '0') { if (that.inputFormat === 'floatingPoint') { precision = 15; } else { switch (wordLength) { case 'int8': case 'uint8': precision = 3; break; case 'int16': case 'uint16': precision = 5; break; case 'int64': precision = 19; break; case 'uint64': precision = 20; break; default: precision = 10; } } } precision = parseFloat(precision); let scientificRepresentation = that.formatNumber(number, 'E' + precision, wordLength), eIndex = scientificRepresentation.indexOf('E'); const exponent = parseInt(scientificRepresentation.slice(eIndex + 1), 10); if (exponent > -5 && exponent < precision) { if (that.inputFormat === 'floatingPoint') { return that.applySeparators(that.applySignificantDigits(precision), true); } else { return numericObject.toString(); } } // removes leading zero in exponent if (exponent > -100 && exponent < 100) { scientificRepresentation = scientificRepresentation.slice(0, eIndex + 2) + scientificRepresentation.slice(eIndex + 3); } // removes trailing zeros if (scientificRepresentation.indexOf(that.localizationObject.decimalseparator) !== -1) { while (scientificRepresentation.charAt(eIndex - 1) === '0') { scientificRepresentation = scientificRepresentation.slice(0, eIndex - 1) + scientificRepresentation.slice(eIndex); eIndex = scientificRepresentation.indexOf('E'); } if (scientificRepresentation.charAt(eIndex - 1) === that.localizationObject.decimalseparator) { scientificRepresentation = scientificRepresentation.slice(0, eIndex - 1) + scientificRepresentation.slice(eIndex); } } if (format === 'g') { scientificRepresentation = scientificRepresentation.toLowerCase(); } return scientificRepresentation; } case 'P': case 'p': // Percent if (precision === '') { precision = that.localizationObject.defaultPrecision; } precision = parseFloat(precision); if (that.inputFormat === 'floatingPoint') { that.numericValue = numericObject * 100; result = that.applyPrecisionDigits(precision); } else { result = (numericObject.multiply(100)).toString() + (precision > 0 ? '.' + ('0').repeat(precision) : ''); } return that.applySeparators(result) + ' %'; case 'B': case 'b': case 'O': case 'o': case 'X': case 'x': { // Binary, Octal, and Hexadecimal; integer-only if (that.inputFormat !== 'integer') { that.inputFormat = 'integer'; numericProcessor = new LW.Utilities.NumericProcessor(that, 'inputFormat'); numericObject = numericProcessor.round(numericProcessor.createDescriptor(number)); } let radix; switch (format) { case 'B': case 'b': radix = 2; break; case 'O': case 'o': radix = 8; break; default: radix = 16; } result = numericObject.toString(radix, that._wordLengthNumber); if (precision !== '') { const leadingZeros = parseFloat(precision) - result.length; if (leadingZeros > 0) { result = ('0').repeat(leadingZeros) + result; } } if (format === 'x') { result = result.toLowerCase(); } return result; } case 'S': case 's': if (precision === '') { precision = that.localizationObject.defaultPrecision; } precision = parseFloat(precision); return that.toScientific(null, precision).replace('.', that.localizationObject.decimalseparator); default: return number.toString(); } } /** * Returns a formatted representation of a complex number. */ formatComplexNumber(number, formatSpecifier, format) { const that = this; switch (format) { case 'E': case 'e': case 'U': case 'u': case 'F': case 'f': case 'G': case 'g': case 'N': case 'n': case 'S': case 's': if (number.imaginaryPart >= 0) { return that.formatNumber(number.realPart, formatSpecifier) + ' + ' + that.formatNumber(number.imaginaryPart, formatSpecifier) + 'i'; } else { return that.formatNumber(number.realPart, formatSpecifier) + ' - ' + that.formatNumber(Math.abs(number.imaginaryPart), formatSpecifier) + 'i'; } default: return number.toString(); } } /** * Returns a formatted representation of a number. */ toString(number, formatSpecifier, wordLength) { if (formatSpecifier) { return this.formatNumber(number, formatSpecifier, wordLength); } else { return number.toString(); } } /** * Applies a custom number format. */ applyCustomFormat(number, formatSpecifier) { const that = this; //formatSpecifier = formatSpecifier.replace(/_.|\[\w*\]|.\*|\*./g, ''); formatSpecifier = formatSpecifier.replace(/_.|\[\w*\]|\*/g, ''); formatSpecifier = formatSpecifier.replace(/\?/g, '#'); const sections = formatSpecifier.split(';'); if (typeof number === 'string' && isNaN(number)) { return sections[sections.length - 1].replace(/"/g, '').replace(/@/g, number.toString()); } if (number._d) { that.inputFormat = 'integer'; } else if (number.imaginaryPart) { return number.toString(); } else { number = parseFloat(number); that.inputFormat = 'floatingPoint'; } let numericProcessor = new LW.Utilities.NumericProcessor(that, 'inputFormat'), numericObject = numericProcessor.createDescriptor(number); if (that.inputFormat === 'integer') { numericObject = numericProcessor.round(numericObject); } that.numericProcessor = numericProcessor; const currentSection = that.getRelevantFormatSection(sections, numericObject); if (currentSection === undefined) { return number.toString(); } if (currentSection.indexOf('@') !== -1) { return sections[sections.length - 1].replace(/"/g, '').replace(/@/g, number.toString()); } const percentage = currentSection.replace(/".*"/g, '').indexOf('%') !== -1, textParts = that.getTextParts(currentSection); if (textParts.main.toLowerCase().indexOf('e') !== -1) { return that.applyCustomExponentialFormat(numericObject, textParts, numericProcessor); } if (textParts.main.indexOf('/') !== -1) { return that.applyCustomFractionalFormat(numericObject, textParts, numericProcessor); } if (percentage) { if (that.inputFormat === 'integer') { numericObject = numericObject.multiply(100); } else { numericObject = numericObject * 100; } } if (textParts.main === '') { if (!percentage) { return textParts.suffix; } let stringifiedNumber = numericObject.toString(); if (that._ignoreMinus && stringifiedNumber.charAt(0) === '-') { stringifiedNumber = stringifiedNumber.slice(1); } return stringifiedNumber + textParts.suffix; } let numberFormat = textParts.main.replace(/[^0#,. \/]/g, ''), indexOfPoint = numberFormat.indexOf('.'); if (indexOfPoint !== -1) { numberFormat = numberFormat.substring(0, indexOfPoint + 1) + numberFormat.substring(indexOfPoint + 1).replace(/\./g, ''); // removes unnecessary trailing zero if (numberFormat.charAt(numberFormat.length - 1) === '.') { numberFormat = numberFormat.slice(0, numberFormat.length - 1); } if (indexOfPoint === 0) { numberFormat = '#' + numberFormat; } } // scales the number down by 1000 for every trailing comma while (numberFormat.charAt(numberFormat.length - 1) === ',') { numberFormat = numberFormat.slice(0, numberFormat.length - 1); if (that.inputFormat === 'floatingPoint') { numericObject /= 1000; } else { numericObject = numericObject.multiply(0.001); } } if (that.inputFormat === 'integer') { numericObject = numericProcessor.round(numericObject); } const thousandsSeparator = numberFormat.indexOf(',') !== -1; numberFormat = numberFormat.replace(/,/g, ''); const numberFormatParts = numberFormat.split('.'), wholePartFormat = numberFormatParts[0]; let decimalPartFormat = numberFormatParts[1], result = ''; if (numberFormatParts.length === 1) { if (that.inputFormat === 'floatingPoint') { numericObject = numericProcessor.round(numericObject); } result = numericObject.toString(); return that.setTextParts(that.formatWholeNumber(result, wholePartFormat, thousandsSeparator), textParts); } result = numericObject.toString(); let numberParts = result.split('.'), formattedWholeNumber = that.formatWholeNumber(numberParts[0], wholePartFormat, thousandsSeparator), decimalNumber = numberParts[1] || ''; if (decimalPartFormat.length <= decimalNumber.length) { result = parseFloat(numericObject.toFixed(decimalPartFormat.length)).toString(); numberParts = result.split('.'); formattedWholeNumber = that.formatWholeNumber(numberParts[0], wholePartFormat, thousandsSeparator); decimalNumber = numberParts[1] || ''; if (decimalNumber) { return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber.slice(0, decimalPartFormat.length), textParts); } } decimalPartFormat = decimalPartFormat.slice(decimalNumber.length - decimalPartFormat.length); let lastZeroIndex = decimalPartFormat.lastIndexOf('0'); if (lastZeroIndex === -1) { if (decimalNumber === '') { return that.setTextParts(formattedWholeNumber, textParts); } return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber, textParts); } else { return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber + '0'.repeat(lastZeroIndex + 1), textParts); } } /** * Returns relevant section of custom format specifier. */ getRelevantFormatSection(sections, number) { const that = this, compareResult = that.numericProcessor.compare(number, 0, true); if (compareResult === 1) { return sections[0]; } let negativeNumberGroup, zeroGroup; if (sections.length >= 3) { that._ignoreMinus = true; negativeNumberGroup = 1; zeroGroup = 2; } else if (sections.length === 2) { that._ignoreMinus = true; zeroGroup = 0; negativeNumberGroup = 1; } else if (sections.length === 1) { zeroGroup = 0; negativeNumberGroup = 0; } if (compareResult === 0) { return sections[zeroGroup]; } if (compareResult === -1) { return sections[negativeNumberGroup]; } } /** * Gets text parts of custom number format. */ getTextParts(currentSection) { const withoutQuotedText = currentSection.replace(/"[^"]*"/g, ''), quotedSections = currentSection.match(/"[^"]*"/g), firstMainIndex = withoutQuotedText.search(/0|#|\./g), lastMainIndex = Math.max(withoutQuotedText.lastIndexOf('0'), withoutQuotedText.lastIndexOf('#'), withoutQuotedText.lastIndexOf('.'), withoutQuotedText.lastIndexOf(',')), main = withoutQuotedText.slice(firstMainIndex, lastMainIndex + 1); if (main === '') { return { prefix: '', main: '', suffix: currentSection.replace(/"/g, '') }; } let firstIndex = currentSection.indexOf(main), lastIndex = firstIndex + main.length; if (quotedSections) { for (let i = 0; i < quotedSections.length; i++) { const sectionIndex = currentSection.indexOf(quotedSections[i]); if (firstIndex >= sectionIndex && lastIndex <= sectionIndex + quotedSections[i].length) { firstIndex = currentSection.indexOf(main, sectionIndex + quotedSections[i].length); lastIndex = firstIndex + main.length; } } } const prefix = currentSection.slice(0, firstIndex).replace(/"/g, ''), suffix = currentSection.slice(lastIndex).replace(/"/g, ''); return { prefix: prefix, main: main, suffix: suffix }; } /** * Applies custom exponential format. */ applyCustomExponentialFormat(number, textParts, numericProcessor) { const that = this; let format = textParts.main, result; const thousandsSeparator = format.indexOf(',') !== -1; // format validation - start format = format.replace(/[^0#.eE+-]/g, ''); const indexOfE = format.toLowerCase().indexOf('e'); format = format.substring(0, indexOfE + 1) + format.substring(indexOfE + 1).replace(/[eE\.]/g, ''); const eLetter = format.charAt(indexOfE), indexOfPoint = format.indexOf('.'); if (indexOfPoint !== -1) { format = format.substring(0, indexOfPoint + 1) + format.substring(indexOfPoint + 1).replace(/\./g, ''); } if (format.charAt(format.length - 1) === '.') { format = format.slice(0, format.length - 1); } // format validation - end const parts = format.split(eLetter); let firstPart = parts[0]; const significantParts = firstPart.split('.'), significantPart1 = significantParts[0], significantPart2 = significantParts[1], secondPart = parts[1]; let numberWholePart = number.toString().split('.')[0].replace(/-/, ''), exponentModifier = 0; if (numberWholePart === '0' && numericProcessor.compare(number, 0)) { let difference = significantPart1.length - 1; while (parseInt(number) === 0) { exponentModifier++; number *= 10; } numberWholePart = number.toString().split('.')[0].replace(/-/, ''); exponentModifier += difference; number *= Math.pow(10, difference); } if (thousandsSeparator) { firstPart = firstPart.slice(0, 1) + ',' + firstPart.slice(1); } if (numberWholePart.length <= significantPart1.length) { result = that.formatNumber(number, firstPart, undefined, true) + eLetter + that.formatExponent(0 - exponentModifier, secondPart); } else { const exponent = numberWholePart.length - significantPart1.length; let visibleNumber = that.inputFormat === 'floatingPoint' ? number / (Math.pow(10, exponent)) : number.divide(Math.pow(10, exponent)); if (!significantPart2) { let roundedVisibleNumber = that.applyThousandsSeparator(numericProcessor.round(visibleNumber).toString(), !thousandsSeparator); result = roundedVisibleNumber + eLetter + that.formatExponent(exponent - exponentModifier, secondPart); } let decimalPartofVisibleNumber = visibleNumber.toString().split('.')[1] || ''; if (decimalPartofVisibleNumber.length === significantPart2.length) { result = that.applySeparators(visibleNumber, !thousandsSeparator) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart); } else if (decimalPartofVisibleNumber.length < significantPart2.length) { result = that.formatNumber(visibleNumber, firstPart, undefined, true) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart); } else { visibleNumber = that.inputFormat === 'floatingPoint' ? visibleNumber.toFixed(significantPart2.length) : visibleNumber = numericProcessor.round(number.divide(Math.pow(10, exponent - significantPart2.length))).divide(Math.pow(10, significantPart2.length)); result = that.formatNumber(parseFloat(visibleNumber), firstPart, undefined, true) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart); } } return that.setTextParts(result, textParts); } /** * Formats exponent. */ formatExponent(exponent, format) { let sign; if (['+', '-'].indexOf(format.charAt(0)) !== -1) { sign = format.charAt(0); if (exponent > 0 && sign === '-' || exponent < 0 && sign === '+') { sign = undefined; } } if (exponent < 0) { exponent = Math.abs(exponent); sign = '-'; } format = format.replace(/[+-]/g, ''); exponent = this.formatNumber(exponent, format, undefined, true); return (sign ? sign : '') + exponent; } /** * Formats a whole number. */ formatWholeNumber(wholeNumber, format, thousandsSeparator) { const that = this; let sign = ''; if (wholeNumber.charAt(0) === '-') { if (!that._ignoreMinus) { sign = '-'; } wholeNumber = wholeNumber.slice(1); } if (wholeNumber === '0') { if (format === '#'.repeat(format.length)) { return sign; } wholeNumber = ''; } if (format.length <= wholeNumber.length) { return sign + that.applyThousandsSeparator(wholeNumber, !thousandsSeparator); } format = format.slice(0, format.length - wholeNumber.length); for (let i = format.length - 1; i >= 0; i--) { if (format.charAt(i) === '0') { wholeNumber = '0' + '' + wholeNumber; } } return sign + that.applyThousandsSeparator(wholeNumber, !thousandsSeparator); } /** * Sets prefix and suffix around formatted number. */ setTextParts(result, textParts) { return textParts.prefix + result + textParts.suffix; } /** * Applies custom format with fraction. */ applyCustomFractionalFormat(numericObject, textParts, numericProcessor) { const that = this, regex = /^([0#,]+[ ]+)?([0#,]+\/[0#,]+)$/; let format = textParts.main.trim(), result; if (!regex.test(format)) { return numericObject.toString(); } const formatParts = regex.exec(format); formatParts[2] = formatParts[2].replace(/,/g, ''); if (that.inputFormat === 'integer') { const fractionFormatParts = formatParts[2].split('/'); if (formatParts[1] === undefined) { result = that.formatNumber(numericObject, fractionFormatParts[0], undefined, true) + '/' + that.formatNumber(1, fractionFormatParts[1], undefined, true); } else { result = that.formatNumber(numericObject, formatParts[1].trim(), undefined, true); if (formatParts[2].indexOf('0') !== -1) { result += ' ' + that.formatNumber(0, fractionFormatParts[0], undefined, true) + '/' + that.formatNumber(1, fractionFormatParts[1], undefined, true); } } return that.setTextParts(result, textParts); } if (formatParts[1] === undefined) { result = (numericObject < 0 ? '-' : '') + that.formatAsFraction(Math.abs(numericObject), formatParts[2]); } else { const wholePartFormat = formatParts[1].trim(), decimalPartFormat = formatParts[2]; result = that.formatNumber(parseInt(numericObject, 10), wholePartFormat, undefined, true) + ' ' + that.formatAsFraction(numericProcessor.getPreciseModulo(Math.abs(numericObject), 1), decimalPartFormat); } return that.setTextParts(result.trim(), textParts); } /** * Formats a decimal number as a fraction. */ formatAsFraction(number, format) { const that = this, formatParts = format.split('/'); if (number === 0) { if (format.indexOf('0') === -1) { return ''; } return that.formatNumber(0, formatParts[0], undefined, true) + '/' + that.formatNumber(1, formatParts[1], undefined, true); } if (number % 1 === 0) { return that.formatNumber(number, formatParts[0], undefined, true) + '/' + that.formatNumber(1, formatParts[1], undefined, true); } const approximations = []; that.approximateFractions(number, approximations); const length = formatParts[1].length >= 2 ? 2 : 1; let bestApproximationDifference = [], bestApproximationIndex = []; approximations.forEach(function (approximation, index) { const length = approximation.denominator.toString().length, currentDifference = Math.abs(number - approximation.numerator / approximation.denominator); if (bestApproximationDifference[length] === undefined) { bestApproximationIndex[length] = index; bestApproximationDifference[length] = currentDifference; return; } if (currentDifference < bestApproximationDifference[length]) { bestApproximationIndex[length] = index; bestApproximationDifference[length] = currentDifference; } }); let bestApproximation = bestApproximationIndex[length] ? approximations[bestApproximationIndex[length]] : approximations[bestApproximationIndex[1]]; return that.formatNumber(bestApproximation.numerator, formatParts[0], undefined, true) + '/' + that.formatNumber(bestApproximation.denominator, formatParts[1], undefined, true); } /** * Approximates fractions. */ approximateFractions(d, approximations) { const numerators = [0, 1]; const denominators = [1, 0]; const maxNumerator = this.getMaxNumerator(d); let d2 = d; let calcD, prevCalcD = NaN; for (let i = 2; i < 1000; i++) { const L2 = Math.floor(d2); numerators[i] = L2 * numerators[i - 1] + numerators[i - 2]; if (Math.abs(numerators[i]) > maxNumerator) return; denominators[i] = L2 * denominators[i - 1] + denominators[i - 2]; calcD = numerators[i] / denominators[i]; if (calcD === prevCalcD) return; approximations.push({ numerator: numerators[i], denominator: denominators[i] }); if (calcD === d) return; prevCalcD = calcD; d2 = 1 / (d2 - L2); } } /** * Gets maximal numerator. */ getMaxNumerator(f) { let f2 = null; let ixe = f.toString().indexOf('E'); if (ixe === -1) ixe = f.toString().indexOf('e'); if (ixe === -1) f2 = f.toString(); else f2 = f.toString().substring(0, ixe); let digits = null; const ix = f2.toString().indexOf('.'); if (ix === -1) digits = f2; else if (ix === 0) digits = f2.substring(1, f2.length); else if (ix < f2.length) digits = f2.substring(0, ix) + f2.substring(ix + 1, f2.length); let L = digits; const numDigits = L.toString().length; const L2 = f; let numIntDigits = L2.toString().length; if (L2 === 0) numIntDigits = 0; const numDigitsPastDecimal = numDigits - numIntDigits; for (let i = numDigitsPastDecimal; i > 0 && L % 2 === 0; i--) L /= 2; for (let i = numDigitsPastDecimal; i > 0 && L % 5 === 0; i--) L /= 5; return L; } /** * Represents an exponential value with superscripts. */ exponentialToSuperscript(exponentialValue) { const indexOfE = exponentialValue.indexOf('e'), power = exponentialValue.slice(indexOfE + 1).replace(/0{1,2}/, ''); let scientificValue = exponentialValue.slice(0, indexOfE + 1); scientificValue = scientificValue.replace('e', '10'); scientificValue += this.toSuperscript(power); scientificValue = scientificValue.replace('+', ''); return scientificValue; } /** * Converts a number to superscript. */ toSuperscript(value, supToNormal) { const chars = '-0123456789', sup = ''; let result = ''; for (let i = 0; i < value.length; i++) { if (supToNormal === true) { const m = sup.indexOf(value.charAt(i)); result += (m !== -1 ? chars[m] : value[i]); } else { const n = chars.indexOf(value.charAt(i)); result += (n !== -1 ? sup[n] : value[i]); } } return result; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('TickIntervalHandler', class TickIntervalHandler { constructor(context, minLabel, maxLabel, labelClass, dimension, integer, logarithmic) { const that = this; that.context = context; that.minLabel = minLabel; that.maxLabel = maxLabel; that.labelClass = labelClass; that.dimension = dimension; that.logarithmic = logarithmic; if (!context.customInterval) { that.labelsSize = that.getMinAndMaxLabelSize(); } else if (context.customTicks.length > 0) { that.labelsSize = that.getCustomTicksLabelSize(); } else { that.labelsSize = { minLabelSize: 0, minLabelOtherSize: 0, maxLabelSize: 0, maxLabelOtherSize: 0 }; } if (!integer) { that.getNiceInterval = that.getNiceIntervalFloatingPoint; that.getPossibleBiggerLabel = that.getPossibleBiggerLabelFloatingPoint; } else { that.getNiceInterval = that.getNiceIntervalInteger; that.getPossibleBiggerLabel = that.getPossibleBiggerLabelInteger; } } getInterval(type, min, max, track) { function getSectorArcLength() { let arcLength = 2 * Math.PI * radius * (Math.abs(context.startAngle - context.endAngle) / 360); // for angles in degrees //let arcLength = Math.abs(context.startAngle - context.endAngle) * radius; // for angles in radians return Math.round(arcLength); } const context = this.context, radius = context._measurements.innerRadius; let largestLabelSize, multiplier = 1; if (type === 'radial') { largestLabelSize = Math.max(this.labelsSize.minLabelSize, this.labelsSize.minLabelOtherSize, this.labelsSize.maxLabelSize, this.labelsSize.maxLabelOtherSize); multiplier = 1.35; //multiplier = 5.25 / Math.max(1, Math.log10(radius * 2)); // original formula: 5.25 / Math.Max(1.0, Math.Log10(panelLogicalSize.Height)) } else { largestLabelSize = Math.max(this.labelsSize.minLabelSize, this.labelsSize.maxLabelSize); multiplier = 1.45; } largestLabelSize *= multiplier; let trackDimension; if (type === 'radial') { trackDimension = getSectorArcLength(); } else { trackDimension = context[this.dimension] - this.labelsSize.minLabelSize / 2 - this.labelsSize.maxLabelSize / 2; // track[this.dimension]; } trackDimension = Math.max(10, trackDimension); const divisionCountEstimate = Math.ceil(trackDimension / largestLabelSize), minorDivisionCountEstimate = type === 'radial' ? divisionCountEstimate * 4 : divisionCountEstimate * 3; let majorInterval = this.getNiceInterval(min, max, divisionCountEstimate, true), minorInterval = this.getNiceInterval(min, max, minorDivisionCountEstimate); context._cachedLabelsSize = this.labelsSize; if (divisionCountEstimate > 2 && !context.customInterval) { const possibleSecondLabel = this.getPossibleBiggerLabel(divisionCountEstimate, majorInterval); if (possibleSecondLabel.length > Math.max(this.minLabel.length, this.maxLabel.length)) { const oldMinLabel = this.minLabel; this.minLabel = possibleSecondLabel; this.labelsSize = this.getMinAndMaxLabelSize(); context._cachedLabelsSize = this.labelsSize; const adjustedResult = this.getInterval(type, min, max, track); this.minLabel = oldMinLabel; this.labelsSize = this.getMinAndMaxLabelSize(); return adjustedResult; } } return { major: majorInterval, minor: minorInterval }; } getNiceIntervalFloatingPoint(min, max, divisionCountEstimate, majorInterval) { const rangeDelta = max - min, exponent = Math.floor(Math.log10(rangeDelta) - Math.log10(divisionCountEstimate)); let nearestPowerOfTen = Math.pow(10, exponent), factor = divisionCountEstimate * nearestPowerOfTen; let niceFactor; if (rangeDelta < 2 * factor) { niceFactor = 1; } else if (rangeDelta < 3 * factor) { niceFactor = 2; } else if (rangeDelta < 7 * factor) { niceFactor = 5; } else { niceFactor = 10; } let niceInterval = niceFactor * nearestPowerOfTen; if (majorInterval && this.context._range / niceInterval > divisionCountEstimate) { switch (niceFactor) { case 5: niceFactor = 10; break; case 2: niceFactor = 5; break; case 1: niceFactor = 2; break; } niceInterval = niceFactor * nearestPowerOfTen; } this.nearestPowerOfTen = nearestPowerOfTen; if (this.logarithmic && majorInterval) { return Math.max(1, niceInterval); } return niceInterval; } getPossibleBiggerLabelFloatingPoint(divisionCountEstimate, majorInterval) { const context = this.context; let secondValue = parseFloat(context.min - context._numericProcessor.getPreciseModulo(parseFloat(context.min), majorInterval) + parseFloat(majorInterval)), currentDrawValue = secondValue, largestLabel, currentLabel; if (this.logarithmic) { secondValue = Math.pow(10, secondValue); } largestLabel = context._formatLabel(secondValue); for (let i = 1; i < divisionCountEstimate; i++) { currentDrawValue = currentDrawValue + majorInterval; if (currentDrawValue >= context._drawMax) { break; } if (!this.logarithmic) { currentLabel = currentDrawValue; } else { currentLabel = Math.pow(10, currentDrawValue); } currentLabel = context._formatLabel(currentLabel); if (currentLabel.length > largestLabel.length) { largestLabel = currentLabel; } } return largestLabel; } getNiceIntervalInteger(min, max, divisionCountEstimate, majorInterval) { const rangeDelta = new LW.Utilities.BigNumber(max).subtract(new LW.Utilities.BigNumber(min)), exponent = Math.floor(Math.log10(rangeDelta.toString()) - Math.log10(divisionCountEstimate)), nearestPowerOfTen = new LW.Utilities.BigNumber(10).pow(new LW.Utilities.BigNumber(exponent)), factor = new LW.Utilities.BigNumber(divisionCountEstimate).multiply(nearestPowerOfTen); let niceFactor; if (rangeDelta.compare(new LW.Utilities.BigNumber(2 * factor)) === -1) { niceFactor = 1; } else if (rangeDelta.compare(new LW.Utilities.BigNumber(3 * factor)) === -1) { niceFactor = 2; } else if (rangeDelta.compare(new LW.Utilities.BigNumber(7 * factor)) === -1) { niceFactor = 5; } else { niceFactor = 10; } let niceInterval = new LW.Utilities.BigNumber(niceFactor).multiply(nearestPowerOfTen); if (majorInterval && new LW.Utilities.BigNumber(this.context._range).divide(niceInterval).compare(divisionCountEstimate) === 1) { switch (niceFactor) { case 5: niceFactor = 10; break; case 2: niceFactor = 5; break; case 1: niceFactor = 2; break; } niceInterval = new LW.Utilities.BigNumber(niceFactor).multiply(nearestPowerOfTen); } if (niceInterval.compare(1) === -1) { niceInterval = new LW.Utilities.BigNumber(1); } this.nearestPowerOfTen = nearestPowerOfTen; return niceInterval; } getPossibleBiggerLabelInteger(divisionCountEstimate, majorInterval) { const context = this.context, bigTen = new LW.Utilities.BigNumber(10); let secondValue = new LW.Utilities.BigNumber(context.min).subtract(new LW.Utilities.BigNumber(context.min).mod(majorInterval)).add(majorInterval), currentDrawValue = secondValue, largestLabel, currentLabel; if (this.logarithmic) { secondValue = bigTen.pow(secondValue); } largestLabel = context._formatLabel(secondValue); for (let i = 1; i < divisionCountEstimate; i++) { currentDrawValue = currentDrawValue.add(majorInterval); if (currentDrawValue.compare(context._drawMax) !== -1) { break; } if (!this.logarithmic) { currentLabel = currentDrawValue; } else { currentLabel = bigTen.pow(currentDrawValue); } currentLabel = context._formatLabel(currentLabel); if (currentLabel.length > largestLabel.length) { largestLabel = currentLabel; } } return largestLabel; } getMinAndMaxLabelSize() { const that = this, context = that.context, container = context.$.container, measureLabel = document.createElement('span'); measureLabel.className = that.labelClass; measureLabel.style.position = 'absolute'; measureLabel.style.visibility = 'hidden'; container.appendChild(measureLabel); measureLabel.innerHTML = that.minLabel; const minLabelSize = measureLabel[that.dimension], minLabelOtherSize = measureLabel[context._settings.otherSize]; measureLabel.innerHTML = that.maxLabel; const maxLabelSize = measureLabel[that.dimension], maxLabelOtherSize = measureLabel[context._settings.otherSize]; container.removeChild(measureLabel); return { minLabelSize: minLabelSize, minLabelOtherSize: minLabelOtherSize, maxLabelSize: maxLabelSize, maxLabelOtherSize: maxLabelOtherSize }; } getCustomTicksLabelSize() { const that = this, context = that.context, container = context.$.container, measureLabel = document.createElement('span'), customTicks = context.customTicks; measureLabel.className = that.labelClass; measureLabel.style.position = 'absolute'; measureLabel.style.visibility = 'hidden'; container.appendChild(measureLabel); measureLabel.innerHTML = context._formatLabel(customTicks[0]); let labelSize = measureLabel[that.dimension], labelOtherSize = measureLabel[context._settings.otherSize]; for (let i = 1; i < context.customTicks.length; i++) { measureLabel.innerHTML = context._formatLabel(context.customTicks[i]); const currentSize = measureLabel[that.dimension], currentOtherSize = measureLabel[context._settings.otherSize]; if (currentSize > labelSize) { labelSize = currentSize; } if (currentOtherSize > labelOtherSize) { labelOtherSize = currentOtherSize; } } container.removeChild(measureLabel); return { minLabelSize: labelSize, minLabelOtherSize: labelOtherSize, maxLabelSize: labelSize, maxLabelOtherSize: labelOtherSize }; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * GridPanel custom element. */ LW('lw-grid-panel', class GridPanel extends LW.BaseElement { // GridPanel's properties. static get properties() { return { 'closeButtonPosition': { value: 'left', allowedValues: ['left', 'right'], type: 'string' }, 'dataSource': { value: [], type: 'array', reflectToAttribute: false }, 'messages': { value: { 'en': { 'apply': 'Apply', 'booleanFirst': '', 'booleanLast': '', 'cancel': 'Cancel', 'dateFirst': '1', 'dateLast': '9', 'from': 'from', 'numberFirst': '1', 'numberLast': '9', 'stringFirst': 'A', 'stringLast': 'Z', 'thenBy': 'then by' } }, type: 'object', extend: true } }; } /** * GridPanel's event listeners. */ static get listeners() { return { 'change': '_changeHandler', 'click': '_clickHandler', 'keydown': '_keydownHandler', 'sortable.dragEnd': '_sortableDragEndHandler' }; } /** * GridPanel's required files. */ static get requires() { return { 'LW.Input': 'lw.input.js', 'LW.Sortable': 'lw.sortable.js' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.gridpanel.css' ] } /** * GridPanel's HTML template. */ template() { return `<div id="container" role="presentation"> <lw-sortable id="sortable" animation="[[animation]]" disabled="[[readonly]]" right-to-left="[[rightToLeft]]" drag-mode="handle" handle-position="right" handle-visibility="visible" theme="[[theme]]"> </lw-sortable> <div id="footer" class="lw-grid-panel-container-footer" role="presentation"> <lw-input id="inputNotSorted" right-to-left="[[rightToLeft]]" animation="[[animation]]" readonly theme="[[theme]]"></lw-input> <div id="buttonsContainer" class="lw-grid-panel-buttons-container lw-unselectable" role="presentation"> <span class="lw-grid-panel-cancel-button" role="button"></span> <span class="lw-grid-panel-apply-button" role="button"></span> </div> </div> </div>`; } /** * Called when the element is ready */ ready() { super.ready(); } render() { const that = this; that.setAttribute('role', 'dialog'); if (that.closeButtonPosition === 'right') { that.$.sortable.handlePosition = 'left'; } that._localize(); that._createSources(); super.render(); } /** * Updates the GridPanel when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'animation': case 'theme': { const inputs = Array.from(that.$.sortable.getElementsByTagName('lw-input')); inputs.forEach(input => input[propertyName] = newValue); break; } case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'closeButtonPosition': if (that.closeButtonPosition === 'right') { that.$.sortable.handlePosition = 'left'; } else { that.$.sortable.handlePosition = 'right'; } break; case 'dataSource': that.$.sortable.$.container.innerHTML = ''; that._createSources(); break; case 'locale': case 'messages': { const items = that.$.sortable._items; that._localize(); if (items.length) { items[0].children[1].innerHTML = that.localize('firstBy'); items.forEach(function (item, index) { if (index !== 0) { item.children[1].innerHTML = that.localize('thenBy'); } const itemInfo = that._HTMLToSourceMap.get(item), ascDescTemplates = that._ascDescTemplates[itemInfo.dataType] || that._ascDescTemplates.string; item.children[3].innerHTML = that.localize('from'); item.children[4].firstElementChild.innerHTML = ascDescTemplates[0]; item.children[4].children[1].innerHTML = ascDescTemplates[1]; }); } break; } case 'maxLevel': if (newValue !== undefined && newValue !== null) { while (that.$.sortable._items.length > 0 && that.$.sortable._items.length > newValue) { that._interactionHandler(that.$.sortable._items[that.$.sortable._items.length - 1].firstElementChild); } } that._disableItemAddition(); break; case 'rightToLeft': that.$.inputNotSorted.rightToLeft = newValue; that.$.inputNotSorted.dropDownButtonPosition = newValue ? 'left' : 'right'; that.$.sortable._items.forEach(item => { const input = item.querySelector('lw-input'); input.rightToLeft = newValue; input.dropDownButtonPosition = newValue ? 'left' : 'right'; }); break; } } /** * change handler. */ _changeHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target; if (that.$.inputNotSorted.contains(target)) { const value = that.$.inputNotSorted.value, newInfo = that._labelToSourceMap.get(value); that._createSortItem(newInfo, that.$.sortable._items.length); that.$.sortable.updateItems(); that._visibleLabels.push(value); that._updateHiddenSource(); that._disableItemAddition(); that.$.inputNotSorted.value = ''; return; } const input = target.closest('lw-input'); if (!input) { return; } const sortItem = input.parentElement.parentElement, sortAsc = sortItem.children[4].firstElementChild, sortDesc = sortItem.children[4].children[1], value = input.value, oldValue = that._HTMLToSourceMap.get(sortItem).label, newInfo = that._labelToSourceMap.get(value), ascDescTemplates = that._ascDescTemplates[newInfo.dataType] || that._ascDescTemplates.string; that._HTMLToSourceMap.set(sortItem, newInfo); that._visibleLabels.splice(that._visibleLabels.indexOf(oldValue), 1, value); that._updateHiddenSource(); sortAsc.innerHTML = ascDescTemplates[0]; sortDesc.innerHTML = ascDescTemplates[1]; if (!newInfo.sortDirection || newInfo.sortDirection.indexOf('asc') !== -1) { sortAsc.classList.add('selected'); sortDesc.classList.remove('selected'); } else { sortDesc.classList.add('selected'); sortAsc.classList.remove('selected'); } } /** * Updates the list of unsorted columns. */ _updateHiddenSource() { const that = this; that._hiddenSource = that.dataSource.map(item => { return { label: item.label, value: item.dataField, icon: item.icon }; }).filter(item => that._visibleLabels.indexOf(item.label) === -1); that.$.inputNotSorted.dataSource = that._hiddenSource; that.$.sortable._items.forEach(item => item.getElementsByTagName('lw-input')[0].dataSource = that._hiddenSource); that._disableItemAddition(); that.$.fireEvent('dataSourceChange'); } /** * click handler. */ _clickHandler(event) { const that = this; that._interactionHandler(that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target, event); } /** * Interaction handler. */ _interactionHandler(target, event) { const that = this; if (that.disabled || that.readonly) { return true; } const sortItem = target.closest('.lw-grid-panel-item'); if (sortItem) { if (target === sortItem.firstElementChild) { // close button is clicked const itemInfo = that._HTMLToSourceMap.get(sortItem), label = itemInfo.label; that.$.sortable.$.container.removeChild(sortItem); that.$.sortable.updateItems(); that._visibleLabels.splice(that._visibleLabels.indexOf(label), 1); that._updateHiddenSource(); that._disableItemAddition(); if (that.$.sortable._items.length) { that.$.sortable._items[0].children[1].innerHTML = that.localize('firstBy'); } that.$.fireEvent('remove'); } else if (sortItem.children[4].contains(target)) { // sort direction buttons are clicked const sortAsc = sortItem.children[4].firstElementChild, sortDesc = sortItem.children[4].children[1]; if (event.type === 'click') { if (!target.classList.contains('selected')) { if (target === sortAsc) { sortDesc.classList.remove('selected'); sortAsc.classList.add('selected'); that._HTMLToSourceMap.get(sortItem).sortDirection = 'ascending'; } else if (target === sortDesc) { sortAsc.classList.remove('selected'); sortDesc.classList.add('selected'); that._HTMLToSourceMap.get(sortItem).sortDirection = 'descending'; } } } else { sortAsc.classList.toggle('selected'); sortDesc.classList.toggle('selected'); that._HTMLToSourceMap.get(sortItem).sortDirection = sortAsc.classList.contains('selected') ? 'ascending' : 'descending'; } } return true; } if (target === that.$.buttonsContainer.firstElementChild) { // "Cancel" button is clicked that.$.fireEvent('cancel'); return true; } if (target === that.$.buttonsContainer.children[1]) { // "Apply" button is clicked const value = [], sortByInfo = { dataFields: [], dataTypes: [], orderBy: [] }, detail = { value: value }; that.$.sortable._items.forEach(item => { const itemInfo = that._HTMLToSourceMap.get(item); value.push({ dataField: itemInfo.dataField, sortDirection: itemInfo.sortDirection }); sortByInfo.dataFields.push(itemInfo.dataField); sortByInfo.dataTypes.push(itemInfo.dataType); sortByInfo.orderBy.push(itemInfo.sortDirection); }); if (that instanceof LW.SortPanel || that instanceof LW.GroupPanel) { detail.sortByInfo = sortByInfo; } that.$.fireEvent('apply', detail); return true; } } /** * keydown handler. */ _keydownHandler(event) { const that = this, key = event.key; if (key === ' ' || key === 'Enter') { event.preventDefault(); that._interactionHandler((that.shadowRoot || that.getRootNode()).activeElement, event); } } /** * sortable dragEnd handler. */ _sortableDragEndHandler(event) { const that = this, oldIndex = event.detail.oldIndex, newIndex = event.detail.newIndex, maxIndex = Math.max(oldIndex, newIndex), items = that.$.sortable._items; if ((oldIndex && newIndex) === 0) { items[0].children[1].innerHTML = that.localize('firstBy'); items[1].children[1].innerHTML = that.localize('thenBy'); if (maxIndex > 1) { items[maxIndex].children[1].innerHTML = that.localize('thenBy'); } } } /** * Localizes labels in template */ _localize() { const that = this; that.$.inputNotSorted.placeholder = that.localize('pickAnother'); that.$.buttonsContainer.firstElementChild.innerHTML = that.localize('cancel'); that.$.buttonsContainer.children[1].innerHTML = that.localize('apply'); that._ascDescTemplates = { boolean: [that.localize('booleanFirst') + '  ' + that.localize('booleanLast'), that.localize('booleanLast') + '  ' + that.localize('booleanFirst')], date: [that.localize('dateFirst') + '  ' + that.localize('dateLast'), that.localize('dateLast') + '  ' + that.localize('dateFirst')], number: [that.localize('numberFirst') + '  ' + that.localize('numberLast'), that.localize('numberLast') + '  ' + that.localize('numberFirst')], string: [that.localize('stringFirst') + '  ' + that.localize('stringLast'), that.localize('stringLast') + '  ' + that.localize('stringFirst')] }; } /** * Gets items collection. */ _createSources() { const that = this, positioningIndex = (that instanceof LW.SortPanel ? 'sort' : 'group') + 'Index', visible = [], visibleLabels = []; that._HTMLToSourceMap = new Map(); that._labelToSourceMap = new Map(); that.dataSource.forEach((item) => { that._labelToSourceMap.set(item.label, item); if (item[positioningIndex] !== -1 && item[positioningIndex] !== undefined) { visible.push(item); } }); visible.sort((a, b) => a[positioningIndex] - b[positioningIndex]); if (that.maxLevel !== undefined && that.maxLevel !== null) { while (visible.length > 0 && visible.length > that.maxLevel) { visible.pop(); } } that.$.inputNotSorted.dropDownButtonPosition = that.rightToLeft ? 'left' : 'right'; visible.forEach(item => visibleLabels.push(item.label)); that._visibleLabels = visibleLabels; that._updateHiddenSource(); visible.forEach((item, index) => { that._createSortItem(item, index); }); that.$.sortable.updateItems(); that._disableItemAddition(); that._setFocusable(); } /** * Creates a sort item. */ _createSortItem(item, index) { const that = this, tabindex = (that.disabled || that.unfocusable) ? -1 : 0, sortItem = document.createElement('div'), ascDescTemplates = that._ascDescTemplates[item.dataType] || that._ascDescTemplates.string; sortItem.className = 'lw-grid-panel-item'; sortItem.innerHTML = `<div class="lw-grid-panel-item-close-button" tabindex="${tabindex}" role="button" aria-label="Close"></div> <div class="lw-grid-panel-label-by lw-unselectable" role="presentation">${that.localize(index > 0 ? 'thenBy' : 'firstBy')}</div> <div class="lw-grid-panel-field-container" role="presentation"><lw-input class="lw-grid-panel-field-selection" value="${item.label}" animation="${that.animation}" readonly theme="${that.theme}" aria-label="Field name"></lw-input></div> <div class="lw-grid-panel-from lw-unselectable" role="presentation">${that.localize('from')}</div > <div class="lw-grid-panel-direction lw-unselectable" tabindex="${tabindex}" role="presentation"> <div class="lw-grid-panel-asc" role="button" aria-label="Ascending">${ascDescTemplates[0]}</div > <div class="lw-grid-panel-desc" role="button" aria-label="Descending">${ascDescTemplates[1]}</div> </div> `; const inputElement = sortItem.querySelector('lw-input'); inputElement.dataSource = that._hiddenSource; inputElement.rightToLeft = that.rightToLeft; inputElement.dropDownButtonPosition = that.rightToLeft ? 'left' : 'right'; that.$.sortable.$.container.appendChild(sortItem); inputElement.tabIndex = tabindex; if (!item.sortDirection || item.sortDirection.indexOf('asc') !== -1) { item.sortDirection = 'ascending'; sortItem.children[4].firstElementChild.classList.add('selected'); } else { sortItem.children[4].children[1].classList.add('selected'); } that._HTMLToSourceMap.set(sortItem, item); } /** * Disables or enables item addition. */ _disableItemAddition() { const that = this, maxLevel = that.maxLevel, disabled = that._hiddenSource.length === 0 || maxLevel !== undefined && maxLevel !== null && Math.max(0, maxLevel) === that.$.sortable._items.length; that.$.inputNotSorted.disabled = disabled; if (disabled) { that.$.inputNotSorted.removeAttribute('focus'); } } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this, tabindex = (that.disabled || that.unfocusable) ? -1 : 0, closeButtons = Array.from(that.getElementsByClassName('lw-grid-panel-item-close-button')), directions = Array.from(that.getElementsByClassName('lw-grid-panel-direction')), inputs = Array.from(that.getElementsByTagName('input')), allFocusable = closeButtons.concat(directions).concat(inputs); that.$.buttonsContainer.firstElementChild.tabIndex = tabindex; that.$.buttonsContainer.children[1].tabIndex = tabindex; allFocusable.forEach(element => element.tabIndex = tabindex); } }); /** * SortPanel custom element. */ LW('lw-sort-panel', class SortPanel extends LW.GridPanel { // SortPanel's properties. static get properties() { return { 'messages': { value: { 'en': { 'firstBy': 'Sort by', 'noSorting': 'No sorting applied', 'pickAnother': 'Pick another field to sort by' } }, type: 'object', extend: true } }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.textbox.css' ] } /** * Localizes labels in template */ _localize() { super._localize(); const that = this; that.$.sortable.$.container.setAttribute('no-sorting', that.localize('noSorting')); } }); /** * GroupPanel custom element. */ LW('lw-group-panel', class GroupPanel extends LW.GridPanel { // GroupPanel's properties. static get properties() { return { 'maxLevel': { value: 8, type: 'number?' }, 'messages': { value: { 'en': { 'collapseAll': 'Collapse all', 'expandAll': 'Expand all', 'firstBy': 'Group by', 'noGrouping': 'No grouping', 'pickAnother': 'Pick another field to group by' } }, type: 'object', extend: true } }; } /** * GroupPanel's HTML template. */ template() { return `<div id="container" role="presentation"> <lw-sortable right-to-left="[[rightToLeft]]" id="sortable" animation="[[animation]]" disabled="[[readonly]]" drag-mode="handle" handle-position="right" handle-visibility="visible" theme="[[theme]]"></lw-sortable> <div id="expandCollapseContainer" class="lw-grid-panel-buttons-container lw-grid-panel-expand-collapse lw-unselectable" role="presentation"> <span class="lw-group-panel-collapse-button" role="button"></span> <span class="lw-group-panel-expand-button" role="button"></span> </div> <div id="footer" class="lw-grid-panel-container-footer" role="presentation"> <lw-input right-to-left="[[rightToLeft]]" id="inputNotSorted" animation="[[animation]]" readonly theme="[[theme]]"></lw-input> <div id="buttonsContainer" class="lw-grid-panel-buttons-container lw-unselectable" role="presentation"> <span class="lw-grid-panel-cancel-button" role="button"></span> <span class="lw-grid-panel-apply-button" role="button"></span> </div> </div> </div>`; } /** * Interaction handler. */ _interactionHandler(target, event) { const that = this, result = super._interactionHandler(target, event); if (result) { return; } if (target === that.$.expandCollapseContainer.firstElementChild) { // "Collapse all" button is clicked that.$.fireEvent('collapseAll'); } else if (target === that.$.expandCollapseContainer.children[1]) { // "Expand all" button is clicked that.$.fireEvent('expandAll'); } } /** * Localizes labels in template */ _localize() { super._localize(); const that = this; that.$.expandCollapseContainer.firstElementChild.innerHTML = that.localize('collapseAll'); that.$.expandCollapseContainer.children[1].innerHTML = that.localize('expandAll'); that.$.sortable.$.container.setAttribute('no-grouping', that.localize('noGrouping')); } /** * Sets whether the element can be focused. */ _setFocusable() { super._setFocusable(); const that = this, tabindex = (that.disabled || that.unfocusable) ? -1 : 0; that.$.expandCollapseContainer.firstElementChild.tabIndex = tabindex; that.$.expandCollapseContainer.children[1].tabIndex = tabindex; } }); /** * MultiColumnFilterPanel custom element. */ LW('lw-multi-column-filter-panel', class MultiColumnFilterPanel extends LW.BaseElement { // MultiColumnFilterPanel's properties. static get properties() { return { 'closeButtonPosition': { value: 'left', allowedValues: ['left', 'right'], type: 'string' }, 'dataSource': { value: [], type: 'array', reflectToAttribute: false }, 'editorCallback': { value: null, type: 'function?', reflectToAttribute: false }, 'editorPlaceholder': { value: 'Value', type: 'string' }, 'messages': { value: { 'en': { 'addFilter': '+ Add filter', 'and': 'And', 'apply': 'Apply', 'cancel': 'Cancel', 'CONTAINS': 'contains', 'CONTAINS_CASE_SENSITIVE': 'contains (case sensitive)', 'DOES_NOT_CONTAIN': 'does not contain', 'DOES_NOT_CONTAIN_CASE_SENSITIVE': 'does not contain (case sensitive)', 'EMPTY': 'empty', 'ENDS_WITH': 'ends with', 'ENDS_WITH_CASE_SENSITIVE': 'ends with (case sensitive)', 'EQUAL': 'equal', 'EQUAL_CASE_SENSITIVE': 'equal (case sensitive)', 'GREATER_THAN': 'greater than', 'GREATER_THAN_OR_EQUAL': 'greater than or equal', 'LESS_THAN': 'less than', 'LESS_THAN_OR_EQUAL': 'less than or equal', 'noFilters': 'No filters applied', 'NOT_EMPTY': 'not empty', 'NOT_EQUAL': 'not equal', 'NOT_NULL': 'not null', 'NULL': 'null', 'or': 'Or', 'STARTS_WITH': 'starts with', 'STARTS_WITH_CASE_SENSITIVE': 'starts with (case sensitive)', 'where': 'Where', } }, type: 'object', extend: true }, 'operator': { value: 'and', allowedValues: ['and', 'or'], type: 'string', }, 'value': { value: [], type: 'array' } }; } /** * MultiColumnFilterPanel's event listeners. */ static get listeners() { return { 'change': '_changeHandler', 'click': '_interactionHandler', 'keydown': '_interactionHandler' }; } /** * MultiColumnFilterPanel's required files. */ static get requires() { return { 'LW.Button': 'lw.button.js', 'LW.CheckBox': 'lw.checkbox.js', 'LW.DateTimePicker': 'lw.datetimepicker.js', 'LW.FilterGroup': 'lw.filter.js', 'LW.Input': 'lw.input.js', 'LW.NumericTextBox': 'lw.numerictextbox.js' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.gridpanel.css' ] } /** * MultiColumnFilterPanel's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="itemsContainer" class="lw-filter-panel-items-container lw-unselectable"></div> <div id="footer" class="lw-grid-panel-container-footer" role="presentation"> <div id="addFilterButton" class="lw-filter-panel-add-filter-button lw-unselectable" role="button"></div> <div id="buttonsContainer" class="lw-grid-panel-buttons-container lw-unselectable" role="presentation"> <span class="lw-grid-panel-cancel-button" role="button"></span> <span class="lw-grid-panel-apply-button" role="button"></span> </div> </div> </div>`; } /** * Called when the element is ready */ ready() { super.ready(); } render() { const that = this; that.setAttribute('role', 'dialog'); that._setFocusable(); that._localize(); that._applyValue(); super.render(); } /** * Updates the MultiColumnFilterPanel when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'animation': case 'theme': case 'rightToLeft': Array.from(that.$.itemsContainer.querySelectorAll('lw-date-time-picker, lw-numeric-text-box, lw-check-box, lw-input')) .forEach(element => { element[propertyName] = newValue; if (element.tagName.toLowerCase() === 'lw-input' && propertyName === 'rightToLeft' && element.dropDownButtonPosition !== 'none') { element.dropDownButtonPosition = newValue ? 'left' : 'right'; } }); break; case 'disabled': case 'unfocusable': that._setFocusable(true); break; case 'dataSource': case 'value': that._applyValue(); break; case 'editorPlaceholder': Array.from(that.$.itemsContainer.getElementsByClassName('editor')) .forEach(element => element.placeholder = newValue); break; case 'locale': case 'messages': that._localize(true); break; case 'operator': that._setOperator(); break; } } /** * Sets operator. */ _setOperator() { const that = this, label = that.localize(that.operator); for (let i = 2; i < that._items.length; i++) { that._items[i].children[1].innerHTML = label; } } /** * change handler. */ _changeHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target; if (target instanceof LW.Input === false) { return; } const item = target.parentElement, itemElements = item.children; if (target === itemElements[1]) { // operator that.operator = target.$.input.dataValue; that._setOperator(); } else if (target === itemElements[2]) { // data field const oldDataType = that.dataSource.find(col => col.dataField === event.detail.oldValue).dataType, newColumn = that.dataSource.find(col => col.dataField === event.detail.value), newDataType = newColumn.dataType; if (newDataType !== 'enum' && newDataType === oldDataType) { if (that.editorCallback) { that.editorCallback(itemElements[4], newColumn); } return; } const currentCondition = itemElements[3].value; let conditionsSource, newEditor; switch (newDataType) { case 'date': conditionsSource = that._numberAndDateConditions; newEditor = document.createElement('lw-date-time-picker'); newEditor.calendarButton = true; newEditor.dropDownAppendTo = 'body'; newEditor.dropDownDisplayMode = 'auto'; newEditor.formatString = 'M/d/yy H:mm'; break; case 'number': conditionsSource = that._numberAndDateConditions; newEditor = document.createElement('lw-numeric-text-box'); break; case 'boolean': conditionsSource = that._booleanConditions; newEditor = document.createElement('lw-check-box'); break; case 'enum': conditionsSource = that._enumConditions; newEditor = document.createElement('lw-input'); newEditor.dataSource = newColumn.options; newEditor.readonly = true; newEditor.dropDownButtonPosition = 'right'; break; default: conditionsSource = that._stringConditions; newEditor = document.createElement('lw-input'); break; } newEditor.rightToLeft = that.rightToLeft; newEditor.animation = that.animation; newEditor.theme = that.theme; newEditor.unfocusable = that.disabled || that.unfocusable; newEditor.classList.add('underlined'); if (newDataType !== 'boolean') { newEditor.placeholder = that.editorPlaceholder; } if (that.editorCallback) { that.editorCallback(newEditor, newColumn); } itemElements[4].remove(); item.appendChild(newEditor); if (currentCondition !== '' && !conditionsSource.find(condition => condition.label === currentCondition)) { itemElements[3].value = ''; } itemElements[3].dataSource = conditionsSource; item.dataType = newDataType; } else if (target === itemElements[3]) { // condition const editor = itemElements[4], dataValue = target.$.input.dataValue; if (dataValue.indexOf('NULL') !== -1 || dataValue.indexOf('EMPTY') !== -1) { editor.value = ''; editor.checked = false; editor.classList.add('lw-visibility-hidden'); } else { editor.classList.remove('lw-visibility-hidden'); } target.condition = dataValue; } } /** * Interaction handler. */ _interactionHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } if (event.type === 'keydown') { if (event.key === ' ' || event.key === 'Enter') { event.preventDefault(); } else { return; } } const target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target, item = target.closest('.lw-grid-panel-item'); if (item) { if (target === item.firstElementChild) { const itemIndex = that._items.indexOf(item); let operator; that._items.splice(itemIndex, 1); item.remove(); if (that._items.length > 0 && itemIndex < 2) { if (itemIndex === 0) { that._items[0].children[1].remove(); operator = document.createElement('div'); operator.innerHTML = that.localize('where'); that._items[0].insertBefore(operator, that._items[0].children[1]); } if (that._items.length > 1) { that._items[1].children[1].remove(); operator = document.createElement('lw-input'); operator.className = 'underlined'; operator.dataSource = [{ value: 'and', label: that.localize('and') }, { value: 'or', label: that.localize('or') }]; operator.dropDownButtonPosition = that.rightToLeft ? 'left' : 'right'; operator.readonly = true; operator.value = that.localize(that.operator); operator.animation = that.animation; operator.theme = that.theme; operator.rightToLeft = that.rightToLeft; operator.unfocusable = that.disabled || that.unfocusable; that._items[1].insertBefore(operator, that._items[1].children[1]); } } } return; } if (target === that.$.addFilterButton && that.dataSource.length > 0) { that.$.itemsContainer.appendChild( that._createItem(that.dataSource[0], '', '', that._items.length)); return; } if (target === that.$.buttonsContainer.firstElementChild) { // "Cancel" button is clicked that.$.fireEvent('cancel'); return; } if (target === that.$.buttonsContainer.children[1]) { // "Apply" button is clicked const allConditions = that._stringConditions.concat(that._numberAndDateConditions), operator = that.operator, validValue = [], filterGroups = {}, result = []; that._items.forEach(item => { const column = that.dataSource.find(col => col.label === item.children[2].value), filter = []; let condition = item.children[3].value; if (condition === '') { return; } let dataType = column.dataType; condition = allConditions.find(cond => cond.label === condition).value; filter.push(column.dataField, condition); if (condition.indexOf('NULL') === -1 && condition.indexOf('EMPTY') === -1) { if (dataType === 'boolean') { filter.push(item.children[4].checked); } else if (dataType === 'date') { filter.push(item.children[4].value.toDate()); } else if (dataType === 'enum') { let value = item.children[4].$.input.dataValue; if (value === undefined) { const selectedOption = column.options.find(option => option.label === item.children[4].value); if (!selectedOption) { return; } value = selectedOption.value; } dataType = 'string'; filter.push(value); } else { filter.push(item.children[4].value); } } let filterGroup = filterGroups[filter[0]]; if (filterGroup === undefined) { filterGroup = new LW.Utilities.FilterGroup(); filterGroups[filter[0]] = filterGroup; } const filterObject = filterGroup.createFilter(dataType, filter[2], filter[1]); filterGroup.addFilter(operator, filterObject); validValue.push(filter); }); for (let dataField in filterGroups) { result.push([dataField, filterGroups[dataField]]); } that.value = validValue; that.$.fireEvent('apply', { filters: result, operator: operator, value: validValue }); } } /** * Applies filter value. */ _applyValue() { const that = this, structure = document.createDocumentFragment(); let index = 0; that._items = []; while (that.$.itemsContainer.firstElementChild) { that.$.itemsContainer.firstElementChild.remove(); } if (that.dataSource.length === 0) { return; } that.value.forEach(filter => { if (!Array.isArray(filter)) { return; } const dataField = filter[0], column = that.dataSource.find(col => col.dataField === dataField); if (!column) { return; } const item = that._createItem(column, filter[1], filter[2], index); structure.appendChild(item); index++; }); that.$.itemsContainer.appendChild(structure); } /** * Creates an item. */ _createItem(column, condition, value, index) { const that = this, tabindex = (that.disabled || that.unfocusable) ? -1 : 0, item = document.createElement('div'), structure = document.createDocumentFragment(), closeButton = document.createElement('div'), fieldInput = document.createElement('lw-input'), conditionInput = document.createElement('lw-input'); let operator, editor; closeButton.className = 'lw-grid-panel-item-close-button'; closeButton.tabIndex = tabindex; closeButton.setAttribute('role', 'button'); closeButton.setAttribute('aria-label', 'button'); structure.appendChild(closeButton); if (index === 0) { operator = document.createElement('div'); operator.innerHTML = that.localize('where'); operator.setAttribute('role', 'presentation'); } else if (index === 1) { operator = document.createElement('lw-input'); operator.className = 'underlined'; operator.dataSource = [{ value: 'and', label: that.localize('and') }, { value: 'or', label: that.localize('or') }]; operator.dropDownButtonPosition = that.rightToLeft ? 'left' : 'right'; operator.readonly = true; operator.value = that.localize(that.operator); operator.animation = that.animation; operator.theme = that.theme; operator.rightToLeft = that.rightToLeft; operator.unfocusable = that.disabled || that.unfocusable; operator.setAttribute('aria-label', 'Operator'); } else { operator = document.createElement('div'); operator.innerHTML = that.localize(that.operator); operator.setAttribute('role', 'presentation'); } structure.appendChild(operator); fieldInput.className = 'underlined'; fieldInput.dataSource = that.dataSource.map(col => { return { value: col.dataField, label: col.label, icon: col.icon }; }); fieldInput.dropDownButtonPosition = that.rightToLeft ? 'left' : 'right'; fieldInput.readonly = true; fieldInput.value = column.label; fieldInput.animation = that.animation; fieldInput.theme = that.theme; fieldInput.rightToLeft = that.rightToLeft; fieldInput.unfocusable = that.disabled || that.unfocusable; fieldInput.setAttribute('aria-label', 'Field'); structure.appendChild(fieldInput); if (column.dataType === 'boolean') { conditionInput.dataSource = that._booleanConditions; editor = document.createElement('lw-check-box'); editor.checked = typeof value === 'boolean' ? value : false; } else if (column.dataType === 'date') { conditionInput.dataSource = that._numberAndDateConditions; editor = document.createElement('lw-date-time-picker'); editor.dropDownDisplayMode = 'auto'; editor.calendarButton = true; editor.dropDownAppendTo = 'body'; editor.formatString = 'M/d/yy H:mm'; editor.value = value; } else if (column.dataType === 'number') { conditionInput.dataSource = that._numberAndDateConditions; editor = document.createElement('lw-numeric-text-box'); editor.value = typeof value === 'number' || typeof value === 'string' ? value : 0; } else if (column.dataType === 'enum') { conditionInput.dataSource = that._enumConditions; editor = document.createElement('lw-input'); editor.dataSource = column.options; editor.readonly = true; editor.dropDownButtonPosition = 'right'; editor.value = value ? column.options.find(option => option.value === value).label : ''; } else { conditionInput.dataSource = that._stringConditions; editor = document.createElement('lw-input'); editor.value = value !== undefined && value !== null ? value.toString() : ''; } conditionInput.className = 'underlined'; conditionInput.dropDownButtonPosition = that.rightToLeft ? 'left' : 'right'; conditionInput.readonly = true; conditionInput.animation = that.animation; conditionInput.theme = that.theme; conditionInput.rightToLeft = that.rightToLeft; conditionInput.unfocusable = that.disabled || that.unfocusable; conditionInput.setAttribute('aria-label', 'Condition'); if (conditionInput.dataSource.find(defaultCondition => defaultCondition.value === condition)) { conditionInput.value = that.localize(condition); conditionInput.condition = condition; } else { editor.value = ''; editor.checked = false; } if (condition !== undefined && (condition.indexOf('NULL') !== -1 || condition.indexOf('EMPTY') !== -1)) { editor.value = ''; editor.checked = false; editor.classList.add('lw-visibility-hidden'); } editor.animation = that.animation; editor.classList.add('editor'); editor.rightToLeft = that.rightToLeft; editor.theme = that.theme; editor.unfocusable = that.disabled || that.unfocusable; editor.classList.add('underlined'); if (column.dataType !== 'boolean') { editor.placeholder = that.editorPlaceholder; } if (that.editorCallback) { that.editorCallback(editor, column); } structure.appendChild(conditionInput); structure.appendChild(editor); item.appendChild(structure); item.className = 'lw-grid-panel-item'; that._items.push(item); item.dataType = column.dataType; return item; } /** * Localizes labels in template */ _localize(propertyChangedHandler) { const that = this; that.$.addFilterButton.innerHTML = that.localize('addFilter'); that.$.buttonsContainer.firstElementChild.innerHTML = that.localize('cancel'); that.$.buttonsContainer.children[1].innerHTML = that.localize('apply'); that.$.itemsContainer.setAttribute('no-filters', that.localize('noFilters')); that._stringConditions = [ { value: 'EMPTY', label: that.localize('EMPTY') }, { value: 'NOT_EMPTY', label: that.localize('NOT_EMPTY') }, { value: 'CONTAINS', label: that.localize('CONTAINS') }, { value: 'CONTAINS_CASE_SENSITIVE', label: that.localize('CONTAINS_CASE_SENSITIVE') }, { value: 'DOES_NOT_CONTAIN', label: that.localize('DOES_NOT_CONTAIN') }, { value: 'DOES_NOT_CONTAIN_CASE_SENSITIVE', label: that.localize('DOES_NOT_CONTAIN_CASE_SENSITIVE') }, { value: 'STARTS_WITH', label: that.localize('STARTS_WITH') }, { value: 'STARTS_WITH_CASE_SENSITIVE', label: that.localize('STARTS_WITH_CASE_SENSITIVE') }, { value: 'ENDS_WITH', label: that.localize('ENDS_WITH') }, { value: 'ENDS_WITH_CASE_SENSITIVE', label: that.localize('ENDS_WITH_CASE_SENSITIVE') }, { value: 'EQUAL', label: that.localize('EQUAL') }, { value: 'EQUAL_CASE_SENSITIVE', label: that.localize('EQUAL_CASE_SENSITIVE') }, { value: 'NULL', label: that.localize('NULL') }, { value: 'NOT_NULL', label: that.localize('NOT_NULL') } ]; that._enumConditions = [ { value: 'EQUAL', label: that.localize('EQUAL') }, { value: 'NOT_EQUAL', label: that.localize('NOT_EQUAL') } ]; that._numberAndDateConditions = [ { value: 'EQUAL', label: that.localize('EQUAL') }, { value: 'NOT_EQUAL', label: that.localize('NOT_EQUAL') }, { value: 'LESS_THAN', label: that.localize('LESS_THAN') }, { value: 'LESS_THAN_OR_EQUAL', label: that.localize('LESS_THAN_OR_EQUAL') }, { value: 'GREATER_THAN', label: that.localize('GREATER_THAN') }, { value: 'GREATER_THAN_OR_EQUAL', label: that.localize('GREATER_THAN_OR_EQUAL') }, { value: 'NULL', label: that.localize('NULL') }, { value: 'NOT_NULL', label: that.localize('NOT_NULL') } ]; that._booleanConditions = [ { value: 'EQUAL', label: that.localize('EQUAL') }, { value: 'NOT_EQUAL', label: that.localize('NOT_EQUAL') }, { value: 'NULL', label: that.localize('NULL') }, { value: 'NOT_NULL', label: that.localize('NOT_NULL') } ]; if (!propertyChangedHandler) { return; } that._items.forEach((item, index) => { const operatorElement = item.children[1], conditionElement = item.children[3]; if (index === 0) { operatorElement.innerHTML = that.localize('where'); } else if (index === 1) { operatorElement.dataSource = [{ value: 'and', label: that.localize('and') }, { value: 'or', label: that.localize('or') }]; operatorElement.value = that.localize(that.operator); } else { operatorElement.innerHTML = that.localize(that.operator); } if (item.dataType === 'string') { conditionElement.dataSource = that._stringConditions; } else if (item.dataType === 'enum') { conditionElement.dataSource = that._enumConditions; } else if (item.dataType === 'boolean') { conditionElement.dataSource = that._booleanConditions; } else { conditionElement.dataSource = that._numberAndDateConditions; } conditionElement.value = conditionElement.condition ? that.localize(conditionElement.condition) : ''; }); } /** * Sets whether the element can be focused. */ _setFocusable(propertyChangedHandler) { const that = this, tabindex = (that.disabled || that.unfocusable) ? -1 : 0; that.$.addFilterButton.tabIndex = tabindex; that.$.buttonsContainer.firstElementChild.tabIndex = tabindex; that.$.buttonsContainer.children[1].tabIndex = tabindex; if (propertyChangedHandler) { const closeButtons = Array.from(that.$.itemsContainer.getElementsByClassName('lw-grid-panel-item-close-button')), customElements = Array.from(that.$.itemsContainer.querySelectorAll('lw-date-time-picker, lw-numeric-text-box, lw-check-box, lw-input')); closeButtons.forEach(closeButton => closeButton.tabIndex = tabindex); customElements.forEach(element => element.unfocusable = that.disabled || that.unfocusable); } } }); /** * ColumnPanel custom element. */ LW('lw-column-panel', class ColumnPanel extends LW.BaseElement { // ColumnPanel's properties. static get properties() { return { 'dataSource': { value: [], type: 'array', reflectToAttribute: false }, 'messages': { value: { 'en': { 'apply': 'Apply', 'cancel': 'Cancel', 'find': 'Find a field', 'noResults': 'No results' } }, type: 'object', extend: true } }; } /** * ColumnPanel's event listeners. */ static get listeners() { return { 'click': '_interactionHandler', 'keydown': '_interactionHandler', 'find.keyup': '_findKeyupHandler', 'sortable.dragEnd': '_sortableDragEndHandler' }; } /** * ColumnPanel's required files. */ static get requires() { return { 'LW.Sortable': 'lw.sortable.js' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.gridpanel.css' ] } /** * ColumnPanel's HTML template. */ template() { return `<div id="container" role="presentation"> <div class="lw-column-panel-find-container" role="search"> <input id="find" readonly="[[readonly]]" role="searchbox" aria-label="Find a field"></input> <span id="clearButton" class="clear-button lw-hidden" role="button" aria-label="Clear"></span> </div> <lw-sortable id="sortable" right-to-left="[[rightToLeft]]" animation="[[animation]]" disabled="[[readonly]]" drag-mode="handle" handle-position="right" handle-visibility="visible" theme="[[theme]]"></lw-sortable> <div id="footer" class="lw-grid-panel-container-footer" role="presentation"> <div id="buttonsContainer" class="lw-grid-panel-buttons-container lw-unselectable" role="presentation"> <span class="lw-grid-panel-cancel-button" role="button"></span> <span class="lw-grid-panel-apply-button" role="button"></span> </div> </div> </div>`; } /** * Called when the element is ready */ ready() { super.ready(); } render() { const that = this; that.setAttribute('role', 'dialog'); that._positionChanged = false; that._localize(); that._createSortItems(); super.render(); } /** * Updates the ColumnPanel when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'dataSource': { const container = that.$.sortable.$.container; while (container.firstChild) { container.removeChild(container.firstChild); } that._createSortItems(); that._positionChanged = false; that.$.find.value = ''; that.$.clearButton.classList.add('lw-hidden'); break; } case 'locale': case 'messages': that._localize(); break; } } /** * Creates sort items. */ _createSortItems() { const that = this, fragment = document.createDocumentFragment(); that._HTMLToSourceMap = new Map(); that.dataSource.forEach(column => fragment.appendChild(that._createSortItem(column))); that.$.sortable.$.container.appendChild(fragment); that.$.sortable.updateItems(); that._setFocusable(); } /** * Creates a sort item. */ _createSortItem(column) { const that = this, sortItem = document.createElement('div'), labelId = that.id + 'Label' + column.dataField; that._HTMLToSourceMap.set(sortItem, column); sortItem.className = 'lw-grid-panel-item'; sortItem.innerHTML = `<div class="toggle-visibility${column.visible !== false ? '' : ' hidden'}${column.disableToggle ? ' disable-toggle' : ''}" role="button" aria-controls="${labelId}" aria-label="Toggle visibility"></div> <span id="${labelId}" class="lw-column-panel-label lw-unselectable${column.icon ? ' icon ' + column.icon : ''}">${column.label}</span>`; if (column.allowHide === false) { sortItem.style.pointerEvents = 'none'; sortItem.style.opacity = 0.8; } return sortItem; } /** * click/keydown handler. */ _interactionHandler(event) { const that = this; if (that.disabled || that.readonly || event.type === 'keydown' && [' ', 'Enter'].indexOf(event.key) === -1) { return; } const target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target; if (target.classList.contains('toggle-visibility')) { target.classList.toggle('hidden'); } else if (target.parentElement === that.$.buttonsContainer) { if (target === that.$.buttonsContainer.firstElementChild) { // "Cancel" button is clicked that.$.fireEvent('cancel'); return; } if (target === that.$.buttonsContainer.children[1]) { // "Apply" button is clicked const value = []; that.$.sortable._items.forEach(item => { const column = Object.assign({}, that._HTMLToSourceMap.get(item)); column.visible = !item.firstElementChild.classList.contains('hidden'); value.push(column); }); that.$.fireEvent('apply', { value: value, positionChanged: that._positionChanged }); that._positionChanged = false; } } else if (target.classList.contains('clear-button')) { that.$.find.value = ''; that._findKeyupHandler(); } } /** * "Find a field" input keyup handler. */ _findKeyupHandler() { const that = this; if (that.disabled || that.readonly) { return; } const input = that.$.find, value = input.value, items = that.$.sortable._items; if (that._disabledSortable === undefined) { that._disabledSortable = that.$.sortable.disabled; } if (value === '') { input.parentElement.classList.remove('no-results'); that.$.clearButton.classList.add('lw-hidden'); items.forEach(item => item.classList.remove('lw-hidden')); that.$.sortable.disabled = that._disabledSortable || that.readonly; delete that._disabledSortable; return; } let noResults = true; that.$.clearButton.classList.remove('lw-hidden'); items.forEach(item => { const column = that._HTMLToSourceMap.get(item); if (column.label.toLowerCase().indexOf(value.toLowerCase()) === -1) { item.classList.add('lw-hidden'); } else { item.classList.remove('lw-hidden'); noResults = false; } }); that.$.sortable.disabled = true; if (noResults) { input.parentElement.classList.add('no-results'); } else { input.parentElement.classList.remove('no-results'); } } /** * sortable dragEnd handler. */ _sortableDragEndHandler() { this._positionChanged = true; } /** * Localizes labels in template */ _localize() { const that = this; that.$.find.placeholder = that.localize('find'); that.$.buttonsContainer.firstElementChild.innerHTML = that.localize('cancel'); that.$.buttonsContainer.children[1].innerHTML = that.localize('apply'); that.$.container.firstElementChild.setAttribute('no-results', that.localize('noResults')); } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this, tabIndex = (that.disabled || that.unfocusable) ? -1 : 0, toggleIcons = Array.from(that.$.sortable.getElementsByClassName('toggle-visibility')); that.$.find.tabIndex = tabIndex; that.$.clearButton.tabIndex = tabIndex; that.$.buttonsContainer.firstElementChild.tabIndex = tabIndex; that.$.buttonsContainer.children[1].tabIndex = tabIndex; toggleIcons.forEach(icon => icon.tabIndex = icon.classList.contains('disable-toggle') ? -1 : tabIndex); } }); /** * DataView parent class. */ LW('lw-data-view', class DataView extends LW.BaseElement { // DataView's properties. static get properties() { return { 'addNewButton': { value: false, type: 'boolean' }, 'allowDrag': { value: false, type: 'boolean' }, 'collapsible': { value: false, type: 'boolean' }, 'columns': { value: [], type: 'object', reflectToAttribute: false }, 'dataSource': { value: null, type: 'object?', reflectToAttribute: false }, 'editable': { value: false, type: 'boolean' }, 'headerPosition': { value: 'none', allowedValues: ['none', 'top', 'bottom'], type: 'string' }, 'messages': { value: { 'en': { 'addFilter': '+ Add filter', 'and': 'And', 'apply': 'Apply', 'booleanFirst': '', 'booleanLast': '', 'cancel': 'Cancel', 'CONTAINS': 'contains', 'CONTAINS_CASE_SENSITIVE': 'contains (case sensitive)', 'dateFirst': '1', 'dateLast': '9', 'DOES_NOT_CONTAIN': 'does not contain', 'DOES_NOT_CONTAIN_CASE_SENSITIVE': 'does not contain (case sensitive)', 'EMPTY': 'empty', 'ENDS_WITH': 'ends with', 'ENDS_WITH_CASE_SENSITIVE': 'ends with (case sensitive)', 'EQUAL': 'equal', 'EQUAL_CASE_SENSITIVE': 'equal (case sensitive)', 'filter': 'Filter', 'customize': 'Customize Columns', 'filteredByMultiple': '{{n}} filters', 'filteredByOne': '1 filter', 'filterValuePlaceholder': 'Value', 'find': 'Find a field', 'findInView': 'Find in view', 'firstBy': 'Sort by', 'found': '{{nth}} of {{n}}', 'from': 'from', 'GREATER_THAN': 'greater than', 'GREATER_THAN_OR_EQUAL': 'greater than or equal', 'LESS_THAN': 'less than', 'LESS_THAN_OR_EQUAL': 'less than or equal', 'noFilters': 'No filters applied', 'noResults': 'No results', 'noSorting': 'No sorting applied', 'NOT_EMPTY': 'not empty', 'NOT_EQUAL': 'not equal', 'NOT_NULL': 'not null', 'NULL': 'null', 'numberFirst': '1', 'numberLast': '9', 'ok': 'OK', 'or': 'Or', 'pickAnother': 'Pick another field to sort by', 'sort': 'Sort', 'group': 'Group', 'sortedByMultiple': 'Sorted by {{n}} fields', 'sortedByOne': 'Sorted by 1 field', 'STARTS_WITH': 'starts with', 'STARTS_WITH_CASE_SENSITIVE': 'starts with (case sensitive)', 'stringFirst': 'A', 'stringLast': 'Z', 'thenBy': 'then by', 'where': 'Where', 'collapseAll': 'Collapse all', 'expandAll': 'Expand all', 'noGrouping': 'No grouping', 'groupedByMultiple': '{{n}} groups', 'groupedByOne': '1 group', 'firstByGroup': 'Group by', 'pickAnotherGroupBy': 'Pick another field to group by' } } } }; } /** * DataView's event listeners. */ static get listeners() { return { 'header.apply': '_applyHandler', 'header.cancel': 'closePanel', 'headerDropDown.transitionend': '_headerDropDownTransitionendHandler', 'searchInput.keyup': '_searchInputKeyupHandler', 'resize': '_resizeHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler' }; } render() { const that = this; if (!that.$.headerDropDown.id) { that.$.headerDropDown.id = that.id + 'HeaderDropDown'; } that.setAttribute('role', 'group'); that._isMobile = LW.Utilities.Core.isMobile; super.render(); } /** * Adds filtering. * * @param {Array} filters Filter information. * @param {String} operator Optional Logical operator between the filters of different fields. */ addFilter(filters, operator = 'and') { const that = this; if (!Array.isArray(filters) || filters.length > 0 && !Array.isArray(filters[0])) { return; } let newFiltering; that.closePanel(); if (arguments[2]) { newFiltering = { filters: arguments[2], operator: operator }; } else { newFiltering = { filters: [], operator: operator }; filters.forEach(filterGroup => { filterGroup[1].filters.forEach(filterObject => { newFiltering.filters.push([filterGroup[0], filterObject.condition, filterObject.value]); }); }); } if (JSON.stringify(newFiltering) === JSON.stringify(that._appliedFiltering)) { return; } that._applyFilter(filters, operator); that.$.fireEvent('filter'); that._appliedFiltering = newFiltering; that._refreshFilterButton(); } _refreshFilterButton() { const that = this; const numberOfFilters = that._appliedFiltering.filters ? that._appliedFiltering.filters.length : 0; if (numberOfFilters === 0) { that.$.filterButton.firstElementChild.innerHTML = that.localize('filter'); that.$.filterButton.classList.remove('filtered'); return; } if (numberOfFilters === 1) { that.$.filterButton.firstElementChild.innerHTML = that.localize('filteredByOne'); } else { that.$.filterButton.firstElementChild.innerHTML = that.localize('filteredByMultiple', { n: numberOfFilters }); } that.$.filterButton.classList.add('filtered'); } /** * Adds sorting. * * @param {Array/String} dataFields The data field(s) to sort by. * @param {Array/String} orderBy The sort direction(s) to sort the data field(s) by. */ addSort(dataFields, orderBy) { const that = this, dataSource = that.dataSource, oldSorting = JSON.stringify(that._appliedSorting); let sortByInfo; function validate(dataField, index) { const column = that.columns.find(col => col.dataField === dataField); if (column) { let columnOrderBy = Array.isArray(orderBy) ? orderBy[index] : typeof orderBy === 'string' ? orderBy : 'ascending'; sortByInfo.dataFields.push(dataField); sortByInfo.dataTypes.push(dataSource.dataFields.find(sourceField => sourceField.name === dataField).dataType); columnOrderBy = columnOrderBy ? columnOrderBy.indexOf('desc') !== -1 ? 'descending' : 'ascending' : 'ascending'; sortByInfo.orderBy.push(columnOrderBy); } } if (arguments.length === 0 || !dataSource || dataSource.length === 0) { return; } that.closePanel(); if (arguments.length === 1 && typeof dataFields === 'object') { sortByInfo = dataFields; } else { sortByInfo = { dataFields: [], dataTypes: [], orderBy: [] }; if (Array.isArray(dataFields)) { dataFields.forEach(validate); } else if (typeof dataFields === 'string') { validate(dataFields, 0); } else { return; } } that.closePanel(); that._appliedSorting = sortByInfo; if (oldSorting === JSON.stringify(that._appliedSorting)) { return; } that._applySort(); that.$.fireEvent('sort'); that._refreshSortButton(); } _refreshSortButton() { const that = this; const sortedFields = that._appliedSorting.dataFields.length; if (sortedFields === 0) { that.$.sortButton.firstElementChild.innerHTML = that.localize('sort'); that.$.sortButton.classList.remove('sorted'); return; } if (sortedFields === 1) { that.$.sortButton.firstElementChild.innerHTML = that.localize('sortedByOne'); } else { that.$.sortButton.firstElementChild.innerHTML = that.localize('sortedByMultiple', { n: sortedFields }); } that.$.sortButton.classList.add('sorted'); } /** * Closes any open header panel (drop down). */ closePanel() { const that = this, headerDropDown = that.$.headerDropDown; headerDropDown.classList.remove('open'); setTimeout(() => { headerDropDown.classList.add('lw-visibility-hidden'); }, 150); that._closeSearchPanel(); if (headerDropDown.controlledBy) { headerDropDown.controlledBy.removeAttribute('aria-controls'); headerDropDown.controlledBy.setAttribute('aria-expanded', false); delete headerDropDown.controlledBy; } } _closeSearchPanel() { const that = this; if (that._searchInfo) { delete that._searchInfo; } } _closeDialog() { const that = this; if (that._editInfo) { that._editInfo.window.close(); } } /** * Opens the "Filter" header panel (drop down). */ openFilterPanel(filterPanelDataSource, filterPanelEditorCallback) { const that = this, dataSource = that.dataSource; if (!dataSource || dataSource.length === 0 || that.disabled || that.headerPosition === 'none') { return; } let filterPanel; if (that._editInfo) { that._editInfo.window.close(); } that.$.headerDropDown.classList.add('filter-panel'); that.$.headerDropDown.classList.remove('customize-panel', 'sort-panel', 'search-panel'); that.$.filter.classList.remove('lw-hidden'); that.$.customize.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); if (that.$.group) { that.$.group.classList.add('lw-hidden'); } that.$.search.classList.add('lw-hidden'); that._closeSearchPanel(); if (!that._filterPartCreated) { filterPanel = document.createElement('lw-multi-column-filter-panel'); filterPanel.rightToLeft = that.rightToLeft; filterPanel.animation = that.animation; filterPanel.dataSource = filterPanelDataSource; filterPanel.locale = that.locale; filterPanel.messages = that._innerElementMessages.multiColumnFilterPanel; filterPanel.operator = that._appliedFiltering.operator; filterPanel.editorPlaceholder = that.localize('filterValuePlaceholder'); filterPanel.theme = that.theme; filterPanel.value = that._appliedFiltering.filters; filterPanel.editorCallback = filterPanelEditorCallback; that.$.filter.appendChild(filterPanel); that._filterPartCreated = true; } else { filterPanel = that.$.filter.firstElementChild; filterPanel.set('operator', that._appliedFiltering.operator); filterPanel.set('value', that._appliedFiltering.filters); filterPanel._applyValue(); filterPanel.rightToLeft = that.rightToLeft; } that._openHeaderDropDown(that.$.filterButton); } /** * Opens the "Sort" header panel (drop down). */ openSortPanel(sortPanelDataSource) { const that = this, dataSource = that.dataSource; if (!dataSource || dataSource.length === 0 || that.disabled || that.headerPosition === 'none') { return; } let sortPanel; that._closeDialog(); that.$.headerDropDown.classList.add('sort-panel'); that.$.headerDropDown.classList.remove('customize-panel', 'filter-panel', 'search-panel'); that.$.sort.classList.remove('lw-hidden'); that.$.customize.classList.add('lw-hidden'); that.$.filter.classList.add('lw-hidden'); if (that.$.group) { that.$.group.classList.add('lw-hidden'); } that.$.search.classList.add('lw-hidden'); that._closeSearchPanel(); if (!that._sortPartCreated) { sortPanel = document.createElement('lw-sort-panel'); sortPanel.rightToLeft = that.rightToLeft; sortPanel.animation = that.animation; sortPanel.dataSource = sortPanelDataSource; sortPanel.locale = that.locale; sortPanel.messages = that._innerElementMessages.sortPanel; sortPanel.theme = that.theme; that.$.sort.appendChild(sortPanel); that._sortPartCreated = true; } else { sortPanel = that.$.sort.firstElementChild; sortPanel.rightToLeft = that.rightToLeft; sortPanel.set('dataSource', sortPanelDataSource); sortPanel.propertyChangedHandler('dataSource', undefined, sortPanelDataSource); } that._openHeaderDropDown(that.$.sortButton); } /** * Removes filtering. */ removeFilter() { this.addFilter([]); } /** * Removes sorting. */ removeSort() { this.addSort({ dataFields: [], dataTypes: [], orderBy: [] }); } /** * Clears filter and sort classes and flags. */ _clearFilterAndSortUI() { const that = this; that._appliedFiltering = { filters: [], operator: 'and' }; that._appliedSorting = { dataFields: [], dataTypes: [], orderBy: [] }; that._appliedGrouping = { dataFields: [] }; that.$.filterButton.classList.remove('filtered'); that.$.sortButton.classList.remove('sorted'); that.$.filterButton.firstElementChild.innerHTML = that.localize('filter'); that.$.sortButton.firstElementChild.innerHTML = that.localize('sort'); } /** * Gets messages used for localization of inner custom elements. */ _getInnerElementMessages() { const that = this, locale = that.locale, innerElementMessages = {}; innerElementMessages.columnPanel = {}; innerElementMessages.groupPanel = {}; innerElementMessages.multiColumnFilterPanel = {}; innerElementMessages.sortPanel = {}; innerElementMessages.dateTimePicker = {}; innerElementMessages.columnPanel[locale] = { 'apply': that.localize('apply'), 'cancel': that.localize('cancel'), 'find': that.localize('find'), 'noResults': that.localize('noResults') }; innerElementMessages.groupPanel[locale] = { 'apply': that.localize('apply'), 'cancel': that.localize('cancel'), 'collapseAll': that.localize('collapseAll'), 'expandAll': that.localize('expandAll'), 'firstBy': that.localize('firstByGroup'), 'noGrouping': that.localize('noGrouping'), 'pickAnother': that.localize('pickAnotherGroupBy'), 'stringFirst': that.localize('stringFirst'), 'stringLast': that.localize('stringLast'), 'thenBy': that.localize('thenBy'), 'from': that.localize('from'), 'booleanFirst': that.localize('booleanFirst'), 'booleanLast': that.localize('booleanLast'), 'dateFirst': that.localize('dateFirst'), 'dateLast': that.localize('dateLast'), 'numberFirst': that.localize('numberFirst'), 'numberLast': that.localize('numberLast') }; innerElementMessages.multiColumnFilterPanel[locale] = { 'addFilter': that.localize('addFilter'), 'and': that.localize('and'), 'apply': that.localize('apply'), 'cancel': that.localize('cancel'), 'CONTAINS': that.localize('CONTAINS'), 'CONTAINS_CASE_SENSITIVE': that.localize('CONTAINS_CASE_SENSITIVE'), 'DOES_NOT_CONTAIN': that.localize('DOES_NOT_CONTAIN'), 'DOES_NOT_CONTAIN_CASE_SENSITIVE': that.localize('DOES_NOT_CONTAIN_CASE_SENSITIVE'), 'EMPTY': that.localize('EMPTY'), 'ENDS_WITH': that.localize('ENDS_WITH'), 'ENDS_WITH_CASE_SENSITIVE': that.localize('ENDS_WITH_CASE_SENSITIVE'), 'EQUAL': that.localize('EQUAL'), 'EQUAL_CASE_SENSITIVE': that.localize('EQUAL_CASE_SENSITIVE'), 'GREATER_THAN': that.localize('GREATER_THAN'), 'GREATER_THAN_OR_EQUAL': that.localize('GREATER_THAN_OR_EQUAL'), 'LESS_THAN': that.localize('LESS_THAN'), 'LESS_THAN_OR_EQUAL': that.localize('LESS_THAN_OR_EQUAL'), 'noFilters': that.localize('noFilters'), 'NOT_EMPTY': that.localize('NOT_EMPTY'), 'NOT_EQUAL': that.localize('NOT_EQUAL'), 'NOT_NULL': that.localize('NOT_NULL'), 'NULL': that.localize('NULL'), 'or': that.localize('or'), 'STARTS_WITH': that.localize('STARTS_WITH'), 'STARTS_WITH_CASE_SENSITIVE': that.localize('STARTS_WITH_CASE_SENSITIVE'), 'where': that.localize('where') }; innerElementMessages.sortPanel[locale] = { 'apply': that.localize('apply'), 'booleanFirst': that.localize('booleanFirst'), 'booleanLast': that.localize('booleanLast'), 'cancel': that.localize('cancel'), 'dateFirst': that.localize('dateFirst'), 'dateLast': that.localize('dateLast'), 'firstBy': that.localize('firstBy'), 'from': that.localize('from'), 'numberFirst': that.localize('numberFirst'), 'numberLast': that.localize('numberLast'), 'noSorting': that.localize('noSorting'), 'pickAnother': that.localize('pickAnother'), 'stringFirst': that.localize('stringFirst'), 'stringLast': that.localize('stringLast'), 'thenBy': that.localize('thenBy') }; innerElementMessages.dateTimePicker[locale] = { 'now': that.localize('now'), 'dateTabLabel': that.localize('dateTabLabel'), 'timeTabLabel': that.localize('timeTabLabel') }; that._innerElementMessages = innerElementMessages; } /** * Handles header position. */ _handleHeaderPosition(mainContainer) { const that = this, headerPosition = that.headerPosition, header = that.$.header; if (headerPosition === 'none') { header.classList.add('lw-hidden'); return; } header.classList.remove('lw-hidden'); if (headerPosition === 'top' && header.nextElementSibling !== mainContainer) { that.$.container.insertBefore(header, mainContainer); } else if (headerPosition === 'bottom' && header.previousElementSibling !== mainContainer) { that.$.container.insertBefore(header, that.$.loadingIndicatorContainer); } } /** * Header click handler. */ _headerClickHandler(target) { const that = this, headerDropDown = that.$.headerDropDown; function toggle(part, openMethod) { if (headerDropDown.classList.contains('lw-visibility-hidden') || part.classList.contains('lw-hidden')) { that[openMethod](); } else { that.closePanel(); } } if (that.$.customizeButton.contains(target)) { toggle(that.$.customize, 'openCustomizePanel'); } else if (that.$.filterButton.contains(target)) { toggle(that.$.filter, 'openFilterPanel'); } else if (that.$.sortButton.contains(target)) { toggle(that.$.sort, 'openSortPanel'); } else if (target === that.$.searchButton) { toggle(that.$.search, '_openSearchPanel'); } else if (that.$.groupButton && that.$.groupButton.contains(target)) { toggle(that.$.group, 'openGroupPanel'); } else if (target === that.$.searchClose) { that.closePanel(); } else if (target === that.$.searchPrev || target === that.$.searchNext) { const searchInfo = that._searchInfo, foundIdsArray = searchInfo.foundIdsArray, next = target === that.$.searchNext, numberOfFoundItems = foundIdsArray.length; let indexToHighlight; if (searchInfo.highlighted === undefined) { indexToHighlight = next ? 0 : numberOfFoundItems - 1; } else if (foundIdsArray.length === 1) { return; } else { const previousHighlightedIndex = foundIdsArray.indexOf(searchInfo.highlighted); indexToHighlight = next ? (previousHighlightedIndex + 1) % numberOfFoundItems : previousHighlightedIndex - 1 >= 0 ? previousHighlightedIndex - 1 : numberOfFoundItems - 1; } searchInfo.highlighted = foundIdsArray[indexToHighlight]; that.grid.highlighted = searchInfo.highlighted; that.grid.ensureVisible(searchInfo.highlighted); that.grid._recycle(false); that.$.searchLabel.innerHTML = that.localize('found', { nth: indexToHighlight + 1, n: foundIdsArray.length }); } } /** * Header drop down transitionend handler. */ _headerDropDownTransitionendHandler(event) { const that = this, dropDown = that.$.headerDropDown; if (event && (event.propertyName !== 'visibility' || dropDown.classList.contains('lw-visibility-hidden'))) { return; } if (dropDown.classList.contains('search-panel')) { that.$.searchInput.focus(); return; } if (that.unfocusable === false) { if (!that._isMobile && dropDown.classList.contains('customize-panel')) { dropDown.querySelector('lw-column-panel').$.find.focus(); } else if (dropDown.classList.contains('filter-panel')) { dropDown.querySelector('lw-multi-column-filter-panel').$.addFilterButton.focus(); } else if (dropDown.classList.contains('sort-panel')) { dropDown.querySelector('lw-sort-panel').$.inputNotSorted.focus(); } } } /** * Localizes labels in the header. */ _localizeHeader() { const that = this; that.$.customizeButton.firstElementChild.innerHTML = that.localize('customize'); if (that.$.groupButton) { that.$.groupButton.firstElementChild.innerHTML = that.localize('group'); } if (that._appliedFiltering.filters.length === 0) { that.$.filterButton.firstElementChild.innerHTML = that.localize('filter'); } else if (that._appliedFiltering.filters.length === 1) { that.$.filterButton.firstElementChild.innerHTML = that.localize('filteredByOne'); } else { that.$.filterButton.firstElementChild.innerHTML = that.localize('filteredByMultiple', { n: that._appliedFiltering.filters.length }); } if (that._appliedSorting.dataFields.length === 0) { that.$.sortButton.firstElementChild.innerHTML = that.localize('sort'); } else if (that._appliedSorting.dataFields.length === 1) { that.$.sortButton.firstElementChild.innerHTML = that.localize('sortedByOne'); } else { that.$.sortButton.firstElementChild.innerHTML = that.localize('sortedByMultiple', { n: that._appliedSorting.dataFields.length }); } that.$.searchInput.placeholder = that.localize('findInView'); } /** * Opens header drop down. */ _openHeaderDropDown(target) { const that = this, dropDown = that.$.headerDropDown; if (that.headerPosition === 'top') { dropDown.style.bottom = null; dropDown.style.top = '100%'; } else { dropDown.style.top = null; dropDown.style.bottom = '100%'; } if (target !== that.$.searchButton) { dropDown.style.left = target.offsetLeft - (that.rightToLeft ? dropDown.offsetWidth - target.offsetWidth : 0) + 'px'; } else { dropDown.style.left = (that.rightToLeft ? target.offsetLeft : target.offsetLeft + Math.max(25, target.offsetWidth) - dropDown.offsetWidth) + 'px'; } dropDown.classList.remove('lw-visibility-hidden'); dropDown.classList.add('open'); if (dropDown.controlledBy) { dropDown.controlledBy.removeAttribute('aria-controls'); dropDown.controlledBy.setAttribute('aria-expanded', false); } dropDown.controlledBy = target; target.setAttribute('aria-controls', dropDown.id); target.setAttribute('aria-expanded', true); that._headerDropDownTransitionendHandler(); } /** * Search input keyup handler. */ _searchInputKeyupHandler() { const that = this; function executeSearch() { if (that._searchInfo && that.$.searchInput.value !== that._searchInfo.query) { that._search(that.$.searchInput.value); } } clearTimeout(that._searchInputTimeout); if (event.key === 'Enter' && that._searchInfo.foundIdsArray && that._searchInfo.foundIdsArray.length > 1) { executeSearch(); that._headerClickHandler(that.$.searchNext, that.$.cardContainer || that.$.body); return; } that._searchInputTimeout = setTimeout(executeSearch, 500); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-multi-input', class MultiInput extends LW.Input { // Button's properties. static get properties() { return { 'separator': { value: ', ', type: 'string' } }; } _performSelect(event) { const that = this; if (!event) { that.close(); return; } const targetItem = !event.target ? event : event.target.closest('li'); if (!targetItem) { return; } if (!that._selectedItems) { that._selectedItems = []; } targetItem.classList.toggle('active'); const isActive = targetItem.classList.contains('active'), itemData = { label: targetItem.getAttribute('data-label'), value: targetItem.getAttribute('value') }; if (isActive) { that._selectedItems.push(itemData); targetItem.setAttribute('aria-selected', true); that._setActiveDescendant(targetItem); } else { const itemIndex = that._selectedItems.findIndex(item => item.label === itemData.label && item.value === itemData.value); if (itemIndex > -1) { that._selectedItems.splice(itemIndex, 1); } targetItem.setAttribute('aria-selected', false); } targetItem.setAttribute('aria-selected', isActive); const targetItems = that._selectedItems, oldLabel = that.value, oldValue = that.$.input.dataValue; let [label, value] = [[], []]; for (let i = 0; i < targetItems.length; i++) { const item = targetItems[i]; label.push(item.label); value.push(item.value); } label = label.join(that.separator); that.set('value', label); that.$.input.dataValue = value = value.join(that.separator); if (label !== oldLabel || value !== oldValue) { that.$.fireEvent('change', { value: value, label: label, oldValue: oldValue, oldLabel: oldLabel }); } } close() { const that = this; if (!that.opened) { return false; } if (that.timer) { clearTimeout(that.timer); } that.timer = setTimeout(function () { if (that.$.scrollView.parentNode && !that.opened) { that.$.scrollView.remove(); that.removeAttribute('aria-owns'); if (!that.readonly) { that.$.input.removeAttribute('aria-controls'); } } }, 1000); that.$.scrollView.removeAttribute('open'); that.$.dropDownButton.removeAttribute('open'); that.$.input.removeAttribute('open'); that.removeAttribute('open'); that.opened = false; that.setAttribute('aria-expanded', false); that.$.input.focus(); return true; } open() { const that = this; let items; if (!that.dropDownDataSource) { items = typeof that.dropDownDataSource === 'function' ? that.dropDownDataSource(that.query) : that.dropDownDataSource; } else { that.query = ''; items = typeof that.dataSource === 'function' ? that.dataSource(that.query) : that.dataSource; } that._process(items); that.ensureVisible(); that.$.input.focus(); setTimeout(function () { that.$.input.focus(); }, 25); } _render(items) { const that = this; const listItems = items.map(function (item) { let label = item, value = item; if (typeof item === 'object') { label = item.label; value = item.value || label; } const listItem = document.createElement('li'); const anchor = document.createElement('a'); anchor.href = '#'; listItem.id = that.id + 'Item' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); listItem.setAttribute('data-label', label); listItem.setAttribute('value', value); listItem.setAttribute('role', 'option'); listItem.setAttribute('aria-selected', false); listItem.setAttribute('aria-label', label); anchor.innerHTML = that.highlighter ? that.highlighter(label) : that._highlighter(label); anchor.setAttribute('aria-hidden', true); if (item.icon) { anchor.classList.add('icon'); anchor.classList.add(item.icon); } listItem.appendChild(anchor); return listItem; }) that.$.menu.innerHTML = ''; if (!that._selectedItems) { that._selectedItems = []; } const selectedValues = (that.$.input.dataValue || that.$.input.value).split(',').map(v => v.trim()), selectedLabels = that.$.input.value.split(',').map(l => l.trim()); for (let i = 0; i < listItems.length; i++) { const listItem = listItems[i], value = listItem.getAttribute('value'), label = listItem.getAttribute('data-label'), itemIndex = selectedValues.indexOf(value); if (itemIndex > -1 && selectedLabels[itemIndex] === label) { listItem.classList.add('active'); listItem.setAttribute('aria-selected', true); that._setActiveDescendant(listItem); const itemIndex = that._selectedItems.findIndex(item => item.label === label && item.value === value); if (itemIndex < 0) { that._selectedItems.push({ label: listItem.getAttribute('data-label'), value: listItem.getAttribute('value') }); } } that.$.menu.appendChild(listItem); } } _next() { const that = this; let activeItem = that._selectedItems ? that._selectedItems[that._selectedItems.length - 1] : undefined; if (activeItem) { activeItem = that.$.menu.querySelector(`.active[data-label="${activeItem.label}"][value="${activeItem.value}"]`); } const active = activeItem || that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; that._performSelect(first); return; } if (that._selectedItems) { that._selectedItems = []; } const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('active'); items[i].setAttribute('aria-selected', false); } that._setActiveDescendant(); let next = active.nextElementSibling; if (!next) { next = that.$.menu.firstElementChild; } that._performSelect(next); that.ensureVisible(); } _prev() { const that = this; let activeItem = that._selectedItems ? that._selectedItems[that._selectedItems.length - 1] : undefined; if (activeItem) { activeItem = that.$.menu.querySelector(`.active[data-label="${activeItem.label}"][value="${activeItem.value}"]`); } const active = activeItem || that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; that._performSelect(first); return; } if (that._selectedItems) { that._selectedItems = []; } const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('active'); items[i].setAttribute('aria-selected', false); } that._setActiveDescendant(); let prev = active.previousElementSibling; if (!prev) { prev = that.$.menu.lastElementChild; } that._performSelect(prev); that.ensureVisible(); } _keyUpHandler(event) { const that = this; if (event.shiftKey) { return; } switch (event.keyCode) { case 40: // down arrow case 38: // up arrow case 16: // shift case 17: // ctrl case 18: // alt if (event.keyCode === 40 && event.altKey) { that.open(); } if (event.keyCode === 38 && event.altKey) { that.close(); } break; case 9: // tab case 13: // enter if (!that.opened) { return; } that._performSelect(); event.stopPropagation() event.preventDefault() break case 27: // escape if (!that.opened) { return; } that.close(); event.stopPropagation() event.preventDefault() break default: that._lookup(event); if (that.opened && !event.ctrlKey && !event.shiftKey) { event.stopPropagation() event.preventDefault() } if (!that.readonly) { that.$.input.dataValue = that.$.input.value; } } } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (propertyName === 'value') { if (that.displayMember !== that.valueMember && typeof newValue !== 'string') { that.value = newValue[that.displayMember]; that.$.input.dataValue = newValue[that.valueMember]; } else { that.$.input.value = newValue; } that._selectedItems = []; //Unselect all items const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('active'); items[i].setAttribute('aria-selected', false); } that._setActiveDescendant(); } else if (propertyName === 'separator') { that.set('value', that.value.replace(new RegExp(oldValue, 'g'), newValue)); if (that.$.input.dataValue) { that.$.input.dataValue = that.$.input.dataValue.replace(new RegExp(oldValue, 'g'), newValue); } } else { super.propertyChangedHandler(propertyName, oldValue, newValue); } } _createElement() { const that = this; const menu = document.createElement('ul'); const scrollView = document.createElement('lw-scroll-viewer'); scrollView.rightToLeft = that.rightToLeft; scrollView.theme = that.theme; scrollView.horizontalScrollBarVisibility = 'hidden'; scrollView.classList.add('lw-multi-input-drop-down-menu'); that.inverted ? scrollView.setAttribute('inverted', '') : scrollView.removeAttribute('inverted'); that.classList.add('lw-input'); menu.setAttribute('aria-multiselectable', true); that.$.scrollView = scrollView; that.$.menu = menu; //that.$.inputContainer.tabIndex = 0; that.$.menu.onclick = function (event) { event.stopPropagation() event.preventDefault() that._performSelect(event); that.$.input.focus(); } } /** * Sets WAI-ARIA property aria-activedescendant. */ _setActiveDescendant(item) { const that = this; if (!that.readonly) { if (item) { that.setAttribute('aria-activedescendant', item.id); } else { that.removeAttribute('aria-activedescendant'); } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-check-input', class CheckInput extends LW.MultiInput { // Button's properties. static get properties() { return { 'inverted': { type: 'boolean', value: false } }; } _performSelect(event) { const that = this; if (!event) { that.close(); return; } const targetItem = !event.target ? event : event.target.closest('li'); if (!targetItem) { return; } if (!that._selectedItems) { that._selectedItems = []; } targetItem.classList.toggle('selected'); const isActive = targetItem.classList.contains('selected'), itemData = { label: targetItem.getAttribute('data-label'), value: targetItem.getAttribute('value') }, items = that.$.menu.children; //Remove active state(checkbox bubble) for (let i = 0; i < items.length; i++) { items[i].classList.remove('active'); } if (isActive) { that._selectedItems.push(itemData); that._setActiveDescendant(targetItem); targetItem.classList.add('active'); targetItem.setAttribute('aria-selected', true); } else { const itemIndex = that._selectedItems.findIndex(item => item.label === itemData.label && item.value === itemData.value); if (itemIndex > -1) { that._selectedItems.splice(itemIndex, 1); } targetItem.classList.remove('active'); targetItem.setAttribute('aria-selected', false); } targetItem.setAttribute('aria-selected', isActive); const targetItems = that._selectedItems, oldLabel = that.value, oldValue = that.$.input.dataValue; let [label, value] = [[], []]; for (let i = 0; i < targetItems.length; i++) { const item = targetItems[i]; label.push(item.label); value.push(item.value); } label = label.join(', '); that.set('value', label); that.$.input.dataValue = value = value.join(', '); if (label !== oldLabel || value !== oldValue) { that.$.fireEvent('change', { value: value, label: label, oldValue: oldValue, oldLabel: oldLabel }); } } _render(items) { const that = this; const listItems = items.map(function (item) { let label = item, value = item; if (typeof item === 'object') { label = item.label; value = item.value || label; } const listItem = document.createElement('li'); const anchor = document.createElement('a'); anchor.href = '#'; listItem.id = that.id + 'Item' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); listItem.setAttribute('data-label', label); listItem.setAttribute('value', value); listItem.setAttribute('role', 'option'); listItem.setAttribute('aria-selected', false); listItem.setAttribute('aria-label', label); anchor.innerHTML = that.highlighter ? that.highlighter(label) : that._highlighter(label); anchor.setAttribute('aria-hidden', true); if (item.icon) { anchor.classList.add('icon'); anchor.classList.add(item.icon); } listItem.appendChild(anchor); return listItem; }) that.$.menu.innerHTML = ''; if (!that._selectedItems) { that._selectedItems = []; } const selectedValues = (that.$.input.dataValue || that.$.input.value).split(',').map(v => v.trim()), selectedLabels = that.$.input.value.split(',').map(l => l.trim()); for (let i = 0; i < listItems.length; i++) { const listItem = listItems[i], value = listItem.getAttribute('value'), label = listItem.getAttribute('data-label'), itemIndex = selectedValues.indexOf(value); if (itemIndex > -1 && selectedLabels[itemIndex] === label) { listItem.classList.add('selected'); listItem.setAttribute('aria-selected', true); that._setActiveDescendant(listItem); const itemIndex = that._selectedItems.findIndex(item => item.label === label && item.value === value); if (itemIndex < 0) { that._selectedItems.push({ label: listItem.getAttribute('data-label'), value: listItem.getAttribute('value') }); } } that.$.menu.appendChild(listItem); } } _next() { const that = this; let activeItem = that._selectedItems ? that._selectedItems[that._selectedItems.length - 1] : undefined; if (activeItem) { activeItem = that.$.menu.querySelector(`.active[data-label="${activeItem.label}"][value="${activeItem.value}"]`); } const active = activeItem || that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; first.classList.add('active', 'focused'); that._setActiveDescendant(first); return; } const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('active', 'focused'); } that._setActiveDescendant(); let next = active.nextElementSibling; if (!next) { next = that.$.menu.firstElementChild; } next.classList.add('active', 'focused'); that._setActiveDescendant(next); that.ensureVisible(); } _prev() { const that = this; let activeItem = that._selectedItems ? that._selectedItems[that._selectedItems.length - 1] : undefined; if (activeItem) { activeItem = that.$.menu.querySelector(`.active[data-label="${activeItem.label}"][value="${activeItem.value}"]`); } const active = activeItem || that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; first.classList.add('active', 'focused'); that._setActiveDescendant(first); return; } const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('active', 'focused'); } that._setActiveDescendant(); let prev = active.previousElementSibling; if (!prev) { prev = that.$.menu.lastElementChild; } prev.classList.add('active', 'focused'); that._setActiveDescendant(prev); that.ensureVisible(); } _keyUpHandler(event) { const that = this; if (event.shiftKey) { return; } switch (event.keyCode) { case 40: // down arrow case 38: // up arrow case 16: // shift case 17: // ctrl case 18: // alt if (event.keyCode === 40 && event.altKey) { that.open(); } if (event.keyCode === 38 && event.altKey) { that.close(); } break; case 9: // tab case 13: // enter if (!that.opened) { return; } that._performSelect(that.$.menu.querySelector('.active')); event.stopPropagation() event.preventDefault() break case 27: // escape if (!that.opened) { return; } that.close(); event.stopPropagation() event.preventDefault() break default: that._lookup(event); if (that.opened && !event.ctrlKey && !event.shiftKey) { event.stopPropagation() event.preventDefault() } if (!that.readonly) { that.$.input.dataValue = that.$.input.value; } } } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (propertyName === 'value') { if (that.displayMember !== that.valueMember && typeof newValue !== 'string') { that.value = newValue[that.displayMember]; that.$.input.dataValue = newValue[that.valueMember]; } else { that.$.input.value = newValue; } that._selectedItems = []; //Unselect all items const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('selected'); items[i].setAttribute('aria-selected', false); } that._setActiveDescendant(that.$.menu.querySelector('active')); } else { super.propertyChangedHandler(propertyName, oldValue, newValue); } } _createElement() { const that = this; super._createElement(); that.$.menu.setAttribute('aria-multiselectable', true); that.$.scrollView.classList.add('lw-check-input-drop-down-menu'); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-multi-combo-input', class MultiComboInput extends LW.CheckInput { // Button's properties. static get properties() { return { 'inputTagsMode': { allowedValues: ['one', 'many'], value: 'many', type: 'string' }, 'hideInputTagsCloseButton': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'tagLabel': ' item(s) selected', 'selectAll': 'Select All', 'unselectAll': 'Unselect All' } }, type: 'object', extend: true }, 'selectAll': { value: false, type: 'boolean' } }; } /** Button's template. */ template() { return '<div id="inputContainer" role="presentation"><div class="lw-action-button" role="presentation" id="actionButton"> <input class="lw-input" id=\'input\' readonly=\'[[readonly]]\' placeholder=\'[[placeholder]]\' type=\'[[type]]\' name=\'[[name]]\' disabled=\'[[disabled]]\' aria-label="[[placeholder]]" /></div><span class="lw-hidden lw-hint" id="span">[[hint]]</span><div id="dropDownButton" tabindex=-1 class="lw-drop-down-button" role="button" aria-label="Toggle popup"><div id="arrow" class="arrow" aria-hidden="true"></div></div></div>'; } _downHandler(event) { const that = this, target = event.originalEvent.target; if ((that._tokenCloseButtonClick = target.closest('.lw-drop-down-list-unselect-button'))) { return; } if (that.readonly) { that._dropDownButtonDownHandler(event); } } _documentUpHandler(event) { const that = this; const target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that._tokenCloseButtonClick && that._tokenCloseButtonClick === target.closest('.lw-drop-down-list-unselect-button')) { const token = target.closest('.lw-token'), [tokenLabel, tokenValue] = [token.getAttribute('data-label'), token.getAttribute('value')], itemIndex = that._selectedItems.findIndex(i => tokenLabel === i.label && tokenValue === i.value), [oldLabel, oldValue] = [that.value, that.$.input.dataValue]; let value, label; if (itemIndex > -1) { that._selectedItems.splice(itemIndex, 1); } that.set('value', label = that._selectedItems.map(i => i.label).join(that.separator)); that.$.input.dataValue = value = that._selectedItems.map(i => i.value).join(that.separator); if (that.$.actionButton.contains(token)) { that.$.actionButton.removeChild(token); } that.close(); if (label !== oldLabel || value !== oldValue) { that.$.fireEvent('change', { value: value, label: label, oldValue: oldValue, oldLabel: oldLabel }); } return; } if (that.contains(target)) { return; } if (that.$.dropDownContainer.contains(target.shadowParent || target)) { if (that._isPointerDown) { that._isPointerDown = false; if (that.opened) { that._preventLookup = true; } that.$.input.focus(); } return; } if (that.opened) { that._preventLookup = true; } if (!that._isPointerDown) { that.close(); } that._isPointerDown = false; } _performSelect(event, noChangeEvent) { const that = this; if (!event) { that.close(); return; } const targetItem = !event.target ? event : event.target.closest('li'); if (!targetItem) { return; } if (!that._selectedItems) { that._selectedItems = []; } targetItem.classList.toggle('selected'); const isActive = targetItem.classList.contains('selected'), itemData = { label: targetItem.getAttribute('data-label'), value: targetItem.getAttribute('value') }, items = that.$.menu.children; //Remove active state(checkbox bubble) for (let i = 0; i < items.length; i++) { items[i].classList.remove('active'); items[i].setAttribute('aria-selected', false); } if (isActive) { that._selectedItems.push(itemData); if (!event.noActiveState) { that._setActiveDescendant(targetItem); targetItem.classList.add('active'); } } else { const itemIndex = that._selectedItems.findIndex(item => item.label === itemData.label && item.value === itemData.value); if (itemIndex > -1) { that._selectedItems.splice(itemIndex, 1); } targetItem.classList.remove('active'); } targetItem.setAttribute('aria-selected', isActive); that._updateValue(noChangeEvent); } _updateValue(noChangeEvent) { const that = this; const targetItems = that._selectedItems, oldLabel = that.value, oldValue = that.$.input.dataValue; let [label, value] = [[], []]; for (let i = 0; i < targetItems.length; i++) { const item = targetItems[i]; label.push(item.label); value.push(item.value); } that._createTags(); label = label.join(that.separator); that.set('value', label); that.$.input.dataValue = value = value.join(that.separator); that.$.input.value = ''; if (that.value === '') { that.removeAttribute('value'); } else { that.setAttribute('value', that.value); } if (!noChangeEvent && (label !== oldLabel || value !== oldValue)) { that.$.fireEvent('change', { value: value, label: label, oldValue: oldValue, oldLabel: oldLabel }); } if (that.selectAll) { that._setSelectAllItemState(); } if (!that.opened) { return; } //Reposition the scrollView const rect = that.getBoundingClientRect(), scrollX = window.scrollX, scrollY = window.scrollY; that.$.dropDownContainer.style.left = -3 + rect.left + scrollX + 'px'; that.$.dropDownContainer.style.top = rect.bottom + scrollY + 1 + 'px'; } _createTags() { const that = this; const targetItems = that._selectedItems || []; let fragment = document.createDocumentFragment(); let token; while (that.$.actionButton.firstElementChild.nodeName === 'SPAN') { that.$.actionButton.removeChild(that.$.actionButton.firstElementChild) } for (let i = 0; i < targetItems.length; i++) { const item = targetItems[i]; if (that.inputTagsMode === 'one' && !token || that.inputTagsMode === 'many') { const itemLabel = that.inputTagsMode === 'one' ? targetItems.length + that.localize('tagLabel') : item.label; token = document.createElement('span'); token.classList.add('lw-token'); token.innerHTML = '<span class=\'lw-drop-down-list-selection-label\' role="presentation">' + itemLabel + '</span><span class=\'lw-drop-down-list-unselect-button\' role="button" aria-label="Unselect"></span>'; if (that.inputTagsMode === 'many') { token.setAttribute('data-label', item.label); token.setAttribute('value', item.value); token.setAttribute('separator', that.separator); } fragment.appendChild(token); } } that.$.actionButton.insertBefore(fragment, that.$.input); //Reposition the scrollView const rect = that.getBoundingClientRect(), scrollX = window.scrollX, scrollY = window.scrollY; that.$.scrollView.style.left = -3 + rect.left + scrollX + 'px'; that.$.scrollView.style.top = rect.bottom + scrollY + 1 + 'px'; } _render(items) { const that = this; const listItems = items.map(function (item) { let label = item, value = item; if (typeof item === 'object') { label = item.label; value = item.value || label; } const listItem = document.createElement('li'); const anchor = document.createElement('a'); anchor.href = '#'; listItem.id = that.id + 'Item' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); listItem.setAttribute('data-label', label); listItem.setAttribute('value', value); listItem.setAttribute('role', 'option'); listItem.setAttribute('aria-selected', false); listItem.setAttribute('aria-label', label); anchor.innerHTML = that.highlighter ? that.highlighter(label) : that._highlighter(label); anchor.setAttribute('aria-hidden', true); if (item.icon) { anchor.classList.add('icon'); anchor.classList.add(item.icon); } listItem.appendChild(anchor); return listItem; }) that.$.menu.innerHTML = ''; if (!that._selectedItems) { that._selectedItems = []; } let selectedValues = that._selectedItems.map(i => i.value); if (!selectedValues.length) { selectedValues = (that.$.input.dataValue || that.$.input.value).split(that.separator).map(v => v.trim()) } let selectedLabels = Array.from(that.$.actionButton.getElementsByClassName('lw-token')).map(i => i.textContent.trim()); for (let i = 0; i < listItems.length; i++) { const listItem = listItems[i], value = listItem.getAttribute('value'), label = listItem.getAttribute('data-label'), itemIndex = selectedValues.indexOf(value); if (itemIndex > -1 && (that.inputTagsMode === 'one' || selectedLabels[itemIndex] === label)) { listItem.classList.add('selected'); listItem.setAttribute('aria-selected', true); that._setActiveDescendant(listItem); const itemIndex = that._selectedItems.findIndex(item => item.label === label && item.value === value); if (itemIndex < 0) { that._selectedItems.push({ label: listItem.getAttribute('data-label'), value: listItem.getAttribute('value') }); } } that._setSelectAllItemState(); that.$.menu.appendChild(listItem); } } _next() { const that = this; let activeItem = that._selectedItems ? that._selectedItems[that._selectedItems.length - 1] : undefined; if (activeItem) { activeItem = that.$.menu.querySelector(`.active[data-label="${activeItem.label}"][value="${activeItem.value}"]`); } const active = activeItem || that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; first.classList.add('active', 'focused'); that._setActiveDescendant(first); return; } const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('active', 'focused'); } that._setActiveDescendant(); let next = active.nextElementSibling; if (!next) { next = that.$.menu.firstElementChild; } next.classList.add('active', 'focused'); that._setActiveDescendant(next); that.ensureVisible(); } _prev() { const that = this; let activeItem = that._selectedItems ? that._selectedItems[that._selectedItems.length - 1] : undefined; if (activeItem) { activeItem = that.$.menu.querySelector(`.active[data-label="${activeItem.label}"][value="${activeItem.value}"]`); } const active = activeItem || that.$.menu.querySelector('.active'); if (!active) { const first = that.$.menu.firstElementChild; first.classList.add('active', 'focused'); that._setActiveDescendant(first); return; } const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('active', 'focused'); } that._setActiveDescendant(); let prev = active.previousElementSibling; if (!prev) { prev = that.$.menu.lastElementChild; } prev.classList.add('active', 'focused'); that._setActiveDescendant(prev); that.ensureVisible(); } _keyDownHandler(event) { const that = this; that._suppressKeyPressRepeat = ![40, 38, 9, 13, 27, 16, 17, 18].includes(event.keyCode); if (event.shiftKey || event.altKey || event.ctrlKey) { delete that._inputValue; return; } that._move(event); that._inputValue = that.$.input.value; } _keyUpHandler(event) { const that = this; //update value let inputValue = that.$.input.value; if (that._selectedItems) { inputValue = that._selectedItems.map(i => i.label) inputValue.push(that.$.input.value); inputValue = inputValue.join(that.separator); } that.set('value', inputValue); if (that.value === '') { that.removeAttribute('value'); } else { that.setAttribute('value', inputValue); } if (event.shiftKey) { return; } switch (event.keyCode) { case 40: // down arrow case 38: // up arrow case 16: // shift case 17: // ctrl case 18: // alt if (event.keyCode === 40 && event.altKey) { that.open(); } if (event.keyCode === 38 && event.altKey) { that.close(); } break; case 8: { // Backspace if (that.readonly) { break; } if (that.opened) { that.close(); } if (that._inputValue && that._inputValue.length) { break; } if (!that._selectedItems) { if (!that.readonly) { that.$.input.dataValue = that.$.input.value; } break; } const lastSelectedItem = that._selectedItems[that._selectedItems.length - 1]; if (!lastSelectedItem) { break; } const targetItem = that.$.menu.querySelector(`li[data-label="${lastSelectedItem.label}"][value="${lastSelectedItem.value}"]`); if (targetItem) { that._performSelect(targetItem); } else { that._selectedItems.pop(); that._updateValue(); } break; } case 9: // tab case 13: // enter if (!that.opened) { return; } that._performSelect(that.$.menu.querySelector('.active')); event.stopPropagation() event.preventDefault() break case 27: // escape if (!that.opened) { return; } that.close(); event.stopPropagation() event.preventDefault() break default: that._lookup(event); if (that.opened && !event.ctrlKey && !event.shiftKey) { event.stopPropagation() event.preventDefault() } } delete that._inputValue; } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (propertyName === 'value') { if (that.displayMember !== that.valueMember && typeof newValue !== 'string') { that.value = newValue[that.displayMember]; that.$.input.dataValue = newValue[that.valueMember]; } else { that.$.input.dataValue = ''; that.$.input.value = newValue; } that._selectedItems = []; while (that.$.actionButton.firstElementChild.nodeName === 'SPAN') { that.$.actionButton.removeChild(that.$.actionButton.firstElementChild) } //Unselect all items const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('selected'); items[i].setAttribute('aria-selected', false); } that._setActiveDescendant(that.$.menu.querySelector('active')); } else if (propertyName === 'separator') { const tokens = that.$.actionButton.children; for (let i = 0; i < tokens.length; i++) { const token = tokens[i]; if (!token.classList.contains('lw-token')) { continue; } token.setAttribute('separator', newValue); } } else if (propertyName === 'inputTagsMode') { that._createTags(); } else if (propertyName === 'theme' || propertyName === 'rightToLeft') { that.$.scrollView[propertyName] = newValue; if (newValue) { that.$.dropDownContainer.setAttribute(LW.Utilities.Core.toDash(propertyName), ''); } else { that.$.dropDownContainer.removeAttribute(LW.Utilities.Core.toDash(propertyName)); } } else if (propertyName === 'inverted') { newValue ? that.$.dropDownContainer.setAttribute('inverted', '') : that.$.dropDownContainer.removeAttribute('inverted'); } else if (propertyName === 'selectAll') { that._handleSelectAllItem(); } else { super.propertyChangedHandler(propertyName, oldValue, newValue); } } _createElement() { const that = this; const menu = document.createElement('ul'); const scrollView = document.createElement('lw-scroll-viewer'); const dropDownContainer = document.createElement('div'); scrollView.rightToLeft = that.rightToLeft; scrollView.theme = that.theme; scrollView.horizontalScrollBarVisibility = 'hidden'; scrollView.classList.add('lw-multi-combo-input-scroll-viewer'); if (that.rightToLeft) { dropDownContainer.setAttribute('right-to-left', ''); } dropDownContainer.setAttribute('theme', that.theme); dropDownContainer.classList.add('lw-multi-combo-input-drop-down-menu', 'lw-input-drop-down-menu', 'lw-check-input-drop-down-menu'); that.inverted ? dropDownContainer.setAttribute('inverted', '') : dropDownContainer.removeAttribute('inverted'); that.classList.add('lw-input'); dropDownContainer.appendChild(scrollView); menu.setAttribute('aria-multiselectable', true); that.$.scrollView = scrollView; that.$.menu = menu; that.$.dropDownContainer = dropDownContainer; //that.$.inputContainer.tabIndex = 0; that.$.menu.onclick = function (event) { event.stopPropagation() event.preventDefault() that._performSelect(event); that.$.input.focus(); } that.classList.add('lw-input'); that.$.input.value = that.value; that._handleSelectAllItem(); } _handleSelectAllItem() { const that = this; if (!that.selectAll) { if (that.$.selectAll) { that.$.selectAll.remove(); } return; } if (!that.$.selectAll) { const listContainer = document.createElement('ul'); const listItem = document.createElement('li'); const anchor = document.createElement('a'); anchor.href = '#'; anchor.innerHTML = that.localize('selectAll'); anchor.setAttribute('aria-hidden', true); listItem.id = that.id + 'Item' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); listItem.setAttribute('role', 'option'); listItem.setAttribute('value', that.localize('selectAll')); listItem.setAttribute('aria-label', that.localize('selectAll')); listItem.classList.add('lw-select-all'); listItem.appendChild(anchor); listItem.onclick = function (event) { event.stopPropagation() event.preventDefault(); if (Array.from(that.$.menu.children).find(item => !item.classList.contains('selected'))) { that._selectAll(); } else { that._clearSelection(); } that._setSelectAllItemState(); if (listItem.classList.contains('selected')) { listItem.classList.add('active'); } that.$.input.focus(); } listContainer.appendChild(listItem); that.$.selectAll = listContainer; } that._setSelectAllItemState(); that.$.dropDownContainer.insertBefore(that.$.selectAll, that.$.scrollView); } _setSelectAllItemState() { const that = this; if (!that.$.selectAll) { return; } const selectAllItem = that.$.selectAll.firstElementChild, anchor = selectAllItem.firstElementChild, areAllItemsSelected = !Array.from(that.$.menu.children).find(item => !item.classList.contains('selected')); selectAllItem.removeAttribute('indeterminate'); selectAllItem.classList.remove('selected', 'active'); anchor.innerHTML = that.localize('selectAll'); if (that._selectedItems && that._selectedItems.length > 0) { if (areAllItemsSelected) { selectAllItem.classList.add('selected'); anchor.innerHTML = that.localize('unselectAll'); } else { selectAllItem.setAttribute('indeterminate', ''); } } } _selectAll() { const that = this, selectedItemsCount = that._selectedItems.length, oldValue = that.$.input.dataValue, oldLabel = that.value; //Unselect all items that._clearSelection(true); //Unselect all items const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { const item = items[i]; if (!item.classList.contains('selected')) { that._performSelect({ target: items[i], noActiveState: true }, true); } } if (selectedItemsCount !== that._selectedItems.length) { that.$.fireEvent('change', { value: that.$.input.dataValue, label: that.value, oldValue: oldValue, oldLabel: oldLabel }); } } _clearSelection(noChangeEvent) { const that = this; if (!that._selectedItems.length) { return; } const oldValue = that.$.input.dataValue, oldLabel = that.value; that.$.input.dataValue = ''; that.value = that.$.input.value; that._selectedItems = []; while (that.$.actionButton.firstElementChild.nodeName === 'SPAN') { that.$.actionButton.removeChild(that.$.actionButton.firstElementChild) } //Unselect all items const items = that.$.menu.children; for (let i = 0; i < items.length; i++) { items[i].classList.remove('selected'); items[i].classList.remove('active'); items[i].setAttribute('aria-selected', false); } that._setActiveDescendant(that.$.menu.querySelector('active')); if (!noChangeEvent) { that.$.fireEvent('change', { value: '', label: '', oldValue: oldValue, oldLabel: oldLabel }); } //Reposition the scrollView const rect = that.getBoundingClientRect(), scrollX = window.scrollX, scrollY = window.scrollY; that.$.dropDownContainer.style.left = -3 + rect.left + scrollX + 'px'; that.$.dropDownContainer.style.top = rect.bottom + scrollY + 1 + 'px'; } _open() { const that = this; const rect = that.getBoundingClientRect(), scrollX = window.scrollX, scrollY = window.scrollY; let xCorrection = 0, yCorrection = 0; if (this.opened) { return; } if (that.timer) { clearTimeout(that.timer); } that.$.scrollView.classList.remove('lw-input-drop-down-menu'); that.$.dropDownContainer.id = that.id + '_' + that.tagName.toLowerCase() + '_menu_' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); document.body.appendChild(that.$.dropDownContainer); that.setAttribute('aria-owns', that.$.dropDownContainer.id); if (!that.readonly) { that.$.input.setAttribute('aria-controls', that.$.dropDownContainer.id); } if (that.$.scrollView.enableShadowDOM && !that._importedStyle) { that.$.scrollView.importStyle(that._getStyleUrl('lw.textbox.css')); that._importedStyle = true; } if (getComputedStyle(document.body).position !== 'static') { const bodyRect = document.body.getBoundingClientRect(); xCorrection = bodyRect.left; yCorrection = bodyRect.top; } that.$.dropDownContainer.style.setProperty('--lw-input-drop-down-menu-width', ''); that.$.dropDownContainer.style.left = -3 + rect.left + scrollX - xCorrection + 'px'; that.$.dropDownContainer.style.top = rect.bottom + scrollY - yCorrection + 1 + 'px'; that.$.dropDownContainer.classList.remove('open'); that.$.dropDownContainer.onpointerdown = function () { that._isPointerDown = true; } requestAnimationFrame(function () { const dropDownWidth = that.dropDownWidth; if (that.$.scrollView.refresh) { that.$.scrollView.refresh(); } that._refreshMenu(); that.$.dropDownContainer.setAttribute('open', ''); that.setAttribute('open', ''); that.$.dropDownButton.setAttribute('open', ''); that.$.input.setAttribute('open', ''); if (dropDownWidth && typeof dropDownWidth === 'string' && dropDownWidth.indexOf('%') !== -1) { const fraction = parseFloat(dropDownWidth) / 100; that.$.dropDownContainer.style.setProperty('--lw-input-drop-down-menu-width', that.offsetWidth * fraction + 'px'); } else if (dropDownWidth !== 'auto' && dropDownWidth) { that.$.dropDownContainer.style.setProperty('--lw-input-drop-down-menu-width', parseFloat(dropDownWidth) + 'px'); } else if (dropDownWidth === 'auto') { that.$.dropDownContainer.style.setProperty('--lw-input-drop-down-menu-width', ''); if (that.$.scrollView.$.scrollViewerContainer.classList.contains('vscroll')) { // compensates for scrollbar's width const autoWidth = that.$.scrollView.offsetWidth + parseFloat(getComputedStyle(that.$.scrollView).getPropertyValue('--lw-scroll-bar-size')); that.$.dropDownContainer.style.setProperty('--lw-input-drop-down-menu-width', autoWidth + 'px'); } } else { that.$.menu.style.width = 'auto'; let menuWidth = that.$.menu.offsetWidth; const listItems = that.$.menu.querySelectorAll('li'); for (let i = 0; i < listItems.length; i++) { that._maxDropDownWidth = Math.max((listItems[i].firstElementChild || listItems[i]).offsetWidth, that._maxDropDownWidth); } if (that.$.scrollView.computedVerticalScrollBarVisibility) { menuWidth += that.$.scrollView.$ && that.$.scrollView.$.verticalScrollBar ? that.$.scrollView.$.verticalScrollBar.offsetWidth : 30; } that.$.dropDownContainer.style.setProperty('--lw-input-drop-down-menu-width', Math.max(menuWidth, that.offsetWidth - 8) + 'px'); that.$.menu.style.width = ''; } //ShadowDOM ScrollBar styles are not loaded when the method is invoked if ((that.shadowRoot || that.isInShadowDOM) && that.$.scrollView._scrollView && LW.ScrollBar) { requestAnimationFrame(() => that.$.scrollView._scrollView.vScrollBar.refresh()); } }); if (that.$.scrollView.refresh) { that.$.scrollView.refresh(); } that._refreshMenu(); this.opened = true; that.setAttribute('aria-expanded', true); } close() { const that = this; if (!that.opened) { return false; } if (that.timer) { clearTimeout(that.timer); } that.timer = setTimeout(function () { if (that.$.dropDownContainer.parentNode && !that.opened) { document.body.removeChild(that.$.dropDownContainer); that.removeAttribute('aria-owns'); if (!that.readonly) { that.$.input.removeAttribute('aria-controls'); } } }, 1000); that.$.dropDownContainer.removeAttribute('open'); that.$.dropDownButton.removeAttribute('open'); that.$.input.removeAttribute('open'); that.removeAttribute('open'); that.opened = false; that.setAttribute('aria-expanded', false); that.$.input.focus(); return true; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-date-range-input', class DateRangeInput extends LW.Input { // DateRangeInput's properties. static get properties() { return { 'dateFormat': { type: 'object', value: { day: 'numeric', month: 'numeric', year: 'numeric' } }, 'dropDownHeight': { type: 'any', value: 'auto' }, 'icons': { type: 'boolean', value: false }, 'max': { value: new Date(2100, 1, 1), type: 'any', defaultValue: new Date(2100, 1, 1) }, 'messages': { value: { 'en': { 'done': 'Done', 'today': 'Today', 'clear': 'Clear', 'hours': 'Hours', 'minutes': 'Minutes', 'am': 'am', 'pm': 'pm' } }, type: 'object', extend: true }, 'min': { value: new Date(1900, 1, 1), type: 'any', defaultValue: new Date(1900, 1, 1) }, 'months': { value: 1, type: 'number', defaultValue: 1 }, 'separator': { value: ' - ', type: 'string' }, 'timeFormat': { type: 'object', value: { hour: '2-digit', minute: '2-digit' } }, 'timepicker': { value: false, type: 'boolean' }, 'value': { type: 'any', value: '', validator: '_valueValidator' }, 'valueType': { allowedValues: ['string', 'object'], value: 'string', type: 'string' } }; } /** Button's template. */ template() { return '<div id="inputContainer" role="presentation"><input class="lw-input" id=\'input\' readonly=\'[[readonly]]\' placeholder=\'[[placeholder]]\' type=\'[[type]]\' name=\'[[name]]\' disabled=\'[[disabled]]\' aria-label="[[placeholder]]" /><span class="lw-hidden lw-hint" id="span">[[hint]]</span><div id="dropDownButton" tabindex=-1 class="lw-drop-down-button" role="button" aria-label="Toggle popup"><div id="arrow" class="arrow" aria-hidden="true"></div></div></div>'; } static get listeners() { return { 'input.change': '_changeHandler', 'input.focus': '_focusHandler', 'input.blur': '_blurHandler', 'input.keydown': '_keyDownHandler', 'input.keyup': '_keyUpHandler', 'input.keypress': '_keyPressHandler', 'dropDownButton.down': '_dropDownButtonDownHandler', 'inputContainer.down': '_downHandler', 'document.up': '_documentUpHandler' }; } focus() { const that = this; that.$.input.focus(); } select() { const that = this; if (!that.readonly) { that.$.input.select(); } else { that.$.input.focus(); } } _documentUpHandler(event) { const that = this; const target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.contains(target)) { requestAnimationFrame(() => { const calendar = that.$.calendar; if (that.opened && calendar.selectedDates.length === 1 && !calendar._newRangeSelectionStarted) { calendar._newRangeSelectionStarted = true; } }) return; } if (that.$.scrollView.contains(target.shadowParent || target)) { if (that._isPointerDown) { that._isPointerDown = false; if (that.opened) { that._preventLookup = true; } that.$.input.focus(); } return; } if (that.opened) { that._preventLookup = true; } that._isPointerDown = false; that.close(); } _changeHandler(event) { const that = this; event.stopPropagation(); that._performSelect(undefined); } _focusHandler() { const that = this; that.setAttribute('focus', ''); if (!that.readonly && that.minLength === 0 && that.$.input.value.length === 0 && !that._preventLookup) { return; } that.$.fireEvent('focus'); delete that._preventLookup; } _blurHandler() { const that = this; if (!that.opened) { that.removeAttribute('focus'); } that.$.fireEvent('blur'); delete that._preventLookup; } _performSelect(event, noChangeEvent) { const that = this; let date = that.$.input.value.split(that.separator), dateFrom, dateTo, propertyChangedValue; if (event !== undefined && typeof event !== 'object') { propertyChangedValue = event; event = undefined; } let oldValue = that._oldValue ? that._oldValue : that._formatValue(propertyChangedValue !== undefined ? propertyChangedValue : that.value, 'string'); if (event) { let timeFrom, timeTo; if (event.type) { event.preventDefault(); event.stopPropagation(); } if (that.timepicker && that._timepicker) { timeFrom = that._timepicker._from; timeTo = that._timepicker._to; } date = event.detail.value.slice(0).sort((a, b) => a.getTime() - b.getTime()); if (!date.length) { date = ''; } else if (date.length === 1) { dateFrom = new Date(date[0]); if (timeFrom) { dateFrom.setHours(timeFrom.hours, timeFrom.minutes); } date = [dateFrom]; } else { dateFrom = new Date(date[0]); dateTo = new Date(date[date.length - 1]); if (timeFrom) { dateFrom.setHours(timeFrom.hours, timeFrom.minutes); } if (timeTo) { dateTo.setHours(timeTo.hours, timeTo.minutes); } date = [dateFrom, dateTo]; } } else { date = that.$.input.value.split(that.separator); if (!date.length) { date = ''; } else if (date.length === 1) { date = new Date(that.$.input.value.trim()); if (isNaN(date.getTime())) { date = ''; } else { dateFrom = new Date(date); that._noCalendarChange = true; that.$.calendar.selectedDates = [date]; date = [dateFrom]; } } else { date = date.map(d => new Date(d)).filter(d => !isNaN(d.getTime())); date.sort((a, b) => a.getTime() - b.getTime()); if (date.length) { //Store selectedDates as a range in Calendar let calendarDates = []; let dateTemp = date[0]; dateFrom = new Date(date[0]); if (date.length > 1) { dateTo = date[date.length - 1]; } calendarDates.push(new Date(dateTemp)); if (dateFrom && dateTo) { const newDate = new Date(dateTemp); dateTemp = new Date(newDate.setDate(newDate.getDate() + 1)); if (dateTemp.getTime() <= dateTo.getTime()) { while (dateTemp.getTime() < dateTo.getTime() && (dateTemp.getDate() !== dateTo.getDate() || dateTemp.getMonth() !== dateTo.getMonth() || dateTemp.getFullYear() !== dateTo.getFullYear())) { calendarDates.push(new Date(dateTemp)); dateTemp.setDate(dateTemp.getDate() + 1); } calendarDates.push(dateTemp); } } that._noCalendarChange = true; that.$.calendar.selectedDates = calendarDates; } } if ((!date || !date.length) && that.$.calendar.isRendered) { that._noCalendarChange = true; that.$.calendar.clearSelection(); if (that._timepicker) { that._timepicker.classList.add('lw-visibility-hidden'); const timepickerButtons = that.$.scrollView.querySelectorAll('.lw-timepicker-button'); for (let i = 0; i < timepickerButtons.length; i++) { timepickerButtons[i].removeAttribute('selected'); } } } } if (that.timepicker && that._timepicker) { if (dateFrom) { that._timepicker._from = { hours: dateFrom.getHours(), minutes: dateFrom.getMinutes() }; } if (dateTo) { that._timepicker._to = { hours: dateTo.getHours(), minutes: dateTo.getMinutes() }; } } const timeFromButton = that.$.scrollView.querySelector('.lw-timepicker-button.from'), timeToButton = that.$.scrollView.querySelector('.lw-timepicker-button.to'); if (timeFromButton) { if (dateFrom && !isNaN(dateFrom.getTime())) { timeFromButton.textContent = dateFrom.toLocaleTimeString(that.locale, that.timeFormat); } else { timeFromButton.textContent = ''; } } if (timeToButton) { if (dateTo && !isNaN(dateTo.getTime())) { timeToButton.textContent = dateTo.toLocaleTimeString(that.locale, that.timeFormat); } else { timeToButton.textContent = ''; } } that.set('value', that.$.input.value = that._oldValue = date = that._formatDate(date)); if (!noChangeEvent && date !== oldValue) { that.$.fireEvent('change', { value: that._formatValue(date), label: date, oldValue: that._formatValue(oldValue), oldLabel: oldValue }); } delete that._noCalendarChange; } _formatValue(value, type) { const that = this; if (!type) { type = that.valueType; } if (type === 'string' && typeof value === 'string' || type === 'object' && value.from) { return value; } let dateFrom, dateTo, date; if (Array.isArray(value)) { dateFrom = value[0]; dateTo = value[value.length - 1]; } else if (typeof value === 'object') { dateFrom = value.from; dateTo = value.to; } else { date = value.split(that.separator); if (date.length) { date = date.map(d => new Date(d)).filter(d => !isNaN(d.getTime())); date.sort((a, b) => a.getTime() - b.getTime()); dateFrom = date[0]; dateTo = date[date.length - 1]; } } if (type === 'string') { return that._formatDate([dateFrom, dateTo]); } else { return { from: new Date(dateFrom), to: new Date(dateTo) }; } } _formatDate(date) { const that = this; if (!date) { return ''; } if (date instanceof Date) { date = [date]; } date = date.filter(d => d !== undefined); if (that.timepicker) { date = date.map(d => new Date(d).toLocaleString(that.locale, Object.assign({}, that.dateFormat, that.timeFormat))); } else { date = date.map(d => new Date(d).toLocaleDateString(that.locale, that.dateFormat)); } return date.length === 1 ? date[0] : date.join(that.separator); } _open() { const that = this; const rect = that.getBoundingClientRect(), scrollX = window.scrollX, scrollY = window.scrollY; let xCorrection = 0, yCorrection = 0; if (this.opened) { return; } if (that.timer) { clearTimeout(that.timer); } document.body.appendChild(that.$.scrollView); that.setAttribute('aria-owns', that.$.scrollView.id); if (!that.readonly) { that.$.input.setAttribute('aria-controls', that.$.scrollView.id); } if (that.$.scrollView.enableShadowDOM && !that._importedStyle) { that.$.scrollView.importStyle(that._getStyleUrl('lw.textbox.css')); that._importedStyle = true; } if (getComputedStyle(document.body).position !== 'static') { const bodyRect = document.body.getBoundingClientRect(); xCorrection = bodyRect.left; yCorrection = bodyRect.top; } that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', ''); that.$.scrollView.style.left = -3 + rect.left + scrollX - xCorrection + 'px'; that.$.scrollView.style.top = rect.bottom + scrollY - yCorrection + 1 + 'px'; that.$.scrollView.classList.remove('open'); that.$.scrollView.onpointerdown = function () { that._isPointerDown = true; } requestAnimationFrame(function () { const dropDownWidth = that.dropDownWidth, calendar = that.$.calendar; that.$.scrollView.setAttribute('open', ''); that.setAttribute('open', ''); that.$.dropDownButton.setAttribute('open', ''); that.$.input.setAttribute('open', ''); if (dropDownWidth && typeof dropDownWidth === 'string' && dropDownWidth.indexOf('%') !== -1) { const fraction = parseFloat(dropDownWidth) / 100; that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', that.offsetWidth * fraction + 'px'); calendar.style.width = '100%'; } else if (dropDownWidth !== 'auto' && dropDownWidth) { that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', parseFloat(dropDownWidth) + 'px'); calendar.style.width = '100%'; } else if (dropDownWidth === 'auto') { calendar.style.width = null; that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', 'auto'); } else { calendar.style.width = null; let menuWidth = calendar.offsetWidth; that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-width', Math.max(menuWidth, that.offsetWidth - 8) + 'px'); } }); this.opened = true; } close() { const that = this; if (!that.opened) { return false; } if (that.timer) { clearTimeout(that.timer); } that.timer = setTimeout(function () { if (that.$.scrollView.parentNode && !that.opened) { document.body.removeChild(that.$.scrollView); that.removeAttribute('aria-owns'); if (!that.readonly) { that.$.input.removeAttribute('aria-controls'); } } }, 1000); if (that._timepicker) { that._timepicker.classList.add('lw-visibility-hidden'); const timepickerButtons = that.$.scrollView.querySelectorAll('.lw-timepicker-button'); for (let i = 0; i < timepickerButtons.length; i++) { timepickerButtons[i].removeAttribute('selected'); } } that.$.scrollView.removeAttribute('open'); that.$.dropDownButton.removeAttribute('open'); that.$.input.removeAttribute('open'); that.removeAttribute('open'); that.opened = false; return true; } _lookup() { } _downHandler(event) { const that = this; if (that.readonly) { that._dropDownButtonDownHandler(event); } } _dropDownButtonDownHandler(event) { const that = this; that._toggle(); event.preventDefault(); event.stopPropagation(); event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); return false; } _toggle() { const that = this; if (that.opened) { that.close(); } else { that.open(); } } open() { const that = this; //Set date that._process(); that.$.input.focus(); setTimeout(function () { that.$.input.focus(); }, 25); } _process() { const that = this; that._performSelect(undefined, true); that._open(); } _matcher() { } _sorter() { } _highlighter() { } _render() { } ensureVisible() { } _next() { } _prev() { } _move(event) { event.stopPropagation() } _keyDownHandler(event) { const that = this; that._suppressKeyPressRepeat = ![40, 38, 9, 13, 27, 16, 17, 18].includes(event.keyCode); if (event.shiftKey || event.altKey || event.ctrlKey) { return; } } _keyPressHandler(event) { const that = this; if (that._suppressKeyPressRepeat) { return; } if (event.shiftKey || event.altKey || event.ctrlKey) { return; } } _keyUpHandler(event) { const that = this; if (event.shiftKey) { return; } switch (event.keyCode) { case 40: // down arrow case 38: // up arrow case 16: // shift case 17: // ctrl case 18: // alt if (event.keyCode === 40 && event.altKey) { that.open(); } if (event.keyCode === 38 && event.altKey) { that.close(); } break; case 27: // escape if (!that.opened) { return; } that.close(); event.stopPropagation() event.preventDefault() break } } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'value': that.$.input.value = that._formatValue(newValue, 'string'); that._performSelect(oldValue); break; case 'month': case 'min': case 'max': that.$.calendar[propertyName] = newValue; break; case 'theme': case 'rightToLeft': case 'animation': case 'inverted': that.$.calendar[propertyName] = newValue; if (newValue) { that.$.scrollView.setAttribute(LW.Utilities.Core.toDash(propertyName), typeof newValue === 'boolean' ? '' : newValue); } else { that.$.scrollView.removeAttribute(LW.Utilities.Core.toDash(propertyName)); } break; case 'timepicker': case 'icons': newValue ? that.$.scrollView.setAttribute(propertyName, '') : that.$.scrollView.removeAttribute(propertyName); //Show/Hide Time that._performSelect(undefined); if (!newValue && that._timepicker) { that._timepicker.classList.add('lw-visibility-hidden'); that._timepicker.remove(); const timepickerButtons = that.$.scrollView.querySelectorAll('.lw-timepicker-button'); for (let i = 0; i < timepickerButtons.length; i++) { timepickerButtons[i].removeAttribute('selected'); } } break; case 'locale': { const todayIcon = that.$.calendar.querySelector('.lw-icon-today'), clearIcon = that.$.calendar.querySelector('.lw-icon-clear'); if (todayIcon) { todayIcon.innerHTML = that.localize('today'); } if (clearIcon) { todayIcon.innerHTML = that.localize('clear'); } that._performSelect(undefined, true); that.$.calendar.locale = newValue; break; } default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } _createElement() { const that = this; const scrollView = document.createElement('div'); const calendar = document.createElement('lw-calendar'), footerTemplate = document.createElement('template'); scrollView.classList.add('lw-input-drop-down-menu', 'lw-date-range-input-drop-down-menu'); scrollView.setAttribute('animation', that.animation); scrollView.setAttribute('role', 'presentation'); that.rightToLeft ? scrollView.setAttribute('right-to-left', '') : scrollView.removeAttribute('right-to-left'); that.inverted ? scrollView.setAttribute('inverted', '') : scrollView.removeAttribute('inverted'); scrollView.onclick = function (event) { event.stopPropagation(); event.preventDefault(); const target = event.target; that.$.input.focus(); const timepickerButton = target.closest('.lw-timepicker-button'); if (timepickerButton) { const timepickerButtons = scrollView.querySelectorAll('.lw-timepicker-button'); for (let i = 0; i < timepickerButtons.length; i++) { timepickerButtons[i].removeAttribute('selected'); } if (target.closest('.lw-icon-clear')) { that.$.calendar.clearSelection(); if (that._timepicker) { that._timepicker.classList.add('lw-visibility-hidden'); const timepickerButtons = that.$.scrollView.querySelectorAll('.lw-timepicker-button'); for (let i = 0; i < timepickerButtons.length; i++) { timepickerButtons[i].removeAttribute('selected'); timepickerButtons[i].setAttribute('aria-selected', false); } } return; } if (target.closest('.lw-icon-today')) { that.$.calendar.today(); return; } timepickerButton.setAttribute('selected', ''); that._toggleTimepicker(event); return; } if (target.closest('lw-done-button')) { that.close(); return; } if (target.closest('.lw-timepicker')) { that._handleTimeSelection(target.closest('.lw-calendar-cell')); return; } } Object.defineProperty(that, 'value', { get: function () { return that._formatValue(that.properties.value.value); }, set(value) { that.updateProperty(that, that._properties.value, value); } }); if (!scrollView.id) { const elementName = scrollView.tagName.toLowerCase(); scrollView.id = elementName.slice(0, 1).toLowerCase() + elementName.slice(1) + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); } that.$.scrollView = scrollView; that.classList.add('lw-input'); calendar.theme = that.theme; calendar.unfocusable = true; calendar.rightToLeft = that.rightToLeft; calendar.animation = that.animation; calendar.months = that.months; calendar.max = that.max; calendar.min = that.min; calendar.locale = that.locale; calendar.viewSections = ['header', 'footer']; calendar.selectionMode = 'range'; if (that.button) { scrollView.setAttribute('button', ''); } if (that.timepicker) { scrollView.setAttribute('timepicker', ''); } if (that.icons) { scrollView.setAttribute('icons', ''); } if (!that.$.calendar) { calendar.$.listen('change', () => { if (that._noCalendarChange) { delete that._noCalendarChange; return; } that._performSelect(event); }); } footerTemplate.innerHTML = ` <div class="lw-date-range-input-footer-controls"> <div class="lw-timepicker-buttons"> <div class="lw-timepicker-button from"></div> <div class="lw-timepicker-button to"></div> </div> <div class="lw-button-controls"> <div class="lw-icon-today lw-timepicker-button">${that.localize('today')}</div> <div class="lw-icon-clear lw-timepicker-button">${that.localize('clear')}</div> </div> </div>`; calendar.footerTemplate = footerTemplate; that.$.calendar = calendar; scrollView.appendChild(that.$.calendar); } _toggleTimepicker(event) { const that = this; if (!that.timepicker) { if (that._timepicker) { that._timepicker.classList.add('lw-visibility-hidden'); that._timepicker.remove(); } return; } if (!that._timepicker) { const timepicker = document.createElement('div'); timepicker.innerHTML = ` <div class="hour-selection lw-calendar-week" role="row"><div class="header" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="0">12</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="1">01</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="2">02</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="3">03</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="4">04</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="5">05</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="6">06</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="7">07</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="8">08</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="9">09</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="10">10</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="11">11</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="12" pm>12</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="13" pm>01</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="14" pm>02</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="15" pm>03</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="16" pm>04</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="17" pm>05</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="18" pm>06</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="19" pm>07</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="20" pm>08</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="21" pm>09</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="22" pm>10</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="23" pm>11</div> </div> <div class="minute-selection lw-calendar-week" role="row"><div class="header" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="0">00</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="5">05</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="10">10</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="15">15</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="20">20</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="25">25</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="30">30</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="35">35</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="40">40</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="45">45</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="50">50</div> <div class="lw-calendar-cell" role="gridcell" aria-selected="false" value="55">55</div> </div>`; timepicker.classList.add('lw-timepicker', 'lw-calendar', 'lw-visibility-hidden'); timepicker.setAttribute('role', 'grid'); //Handle hover if (!LW.Utilities.Core.isMobile) { timepicker.onmouseover = function (event) { const timepickerCell = event.target.closest('.lw-calendar-cell'); if (timepickerCell) { timepickerCell.setAttribute('hover', ''); } } timepicker.onmouseout = function (event) { const timepickerCell = event.target.closest('.lw-calendar-cell'); if (timepickerCell) { timepickerCell.removeAttribute('hover'); } } } that._timepicker = timepicker; //Set the initial timeFrom and timeTo const selectedDates = that.$.calendar.selectedDates; if (selectedDates.length) { let timeFrom, timeTo, dateFrom, dateTo; if (selectedDates.length === 1) { dateFrom = selectedDates[0]; timeFrom = { hours: dateFrom.getHours(), minutes: dateFrom.getMinutes() }; } else if (selectedDates.length > 1) { dateFrom = selectedDates[0]; dateTo = selectedDates[selectedDates.length - 1]; timeFrom = { hours: dateFrom.getHours(), minutes: dateFrom.getMinutes() }; timeTo = { hours: dateTo.getHours(), minutes: dateTo.getMinutes() }; } if (timeFrom) { that._timepicker._from = timeFrom; } if (timeTo) { that._timepicker._to = timeTo; } } } //Lozalize the labels and position the timepicker const hourSelection = that._timepicker.querySelector('.hour-selection'), minuteSelection = that._timepicker.querySelector('.minute-selection'), calendar = that.$.calendar; hourSelection.setAttribute('am-label', that.localize('am')); hourSelection.setAttribute('pm-label', that.localize('pm')); hourSelection.querySelector('.header').textContent = that.localize('hours'); minuteSelection.querySelector('.header').textContent = that.localize('minutes'); that._timepicker.style.top = calendar.offsetTop + 'px'; that._timepicker.style.left = calendar.offsetLeft + 'px'; that._timepicker.style.width = calendar.offsetWidth + 'px'; const oldRangeType = that._timepicker._rangeType; delete that._timepicker._rangeType; const timepickerButton = event.target.closest('.lw-timepicker-button'), rangeType = timepickerButton.classList.contains('from') ? 'from' : 'to'; if (timepickerButton) { that._timepicker._rangeType = rangeType; } //Referesh the time selection Array.from(that._timepicker.querySelectorAll('div[selected]')).map(i => { i.removeAttribute('selected'); i.setAttribute('aria-selected', false); }); const targetTime = that._timepicker[`_${rangeType}`]; if (targetTime) { const targetCells = that._timepicker.querySelectorAll(`.hour-selection div[value="${targetTime.hours}"], .minute-selection div[value="${targetTime.minutes}"]`); for (let i = 0; i < targetCells.length; i++) { const cell = targetCells[i]; if (cell) { cell.setAttribute('selected', true); cell.setAttribute('aria-selected', true); } } } const isTimepickerHidden = that._timepicker.classList.contains('lw-visibility-hidden') if (!isTimepickerHidden && oldRangeType && oldRangeType !== rangeType) { return; } const isInDom = that._timepicker.parentElement; if (!isInDom) { that.$.scrollView.appendChild(that._timepicker); } if (isTimepickerHidden) { if (!isInDom) { requestAnimationFrame(() => that._timepicker.classList.remove('lw-visibility-hidden')); } else { that._timepicker.classList.remove('lw-visibility-hidden'); } } else { that._timepicker.classList.add('lw-visibility-hidden'); const timepickerButtons = that.$.scrollView.querySelectorAll('.lw-timepicker-button'); for (let i = 0; i < timepickerButtons.length; i++) { timepickerButtons[i].removeAttribute('selected'); timepickerButtons[i].setAttribute('aria-selected', false); } } } _handleTimeSelection(target, noChangeEvent) { const that = this; if (!target) { return; } if (target.closest('.hour-selection')) { Array.from(that._timepicker.querySelectorAll('.hour-selection div[selected]')).map(i => { i.removeAttribute('selected'); i.setAttribute('aria-selected', false); }); } else { Array.from(that._timepicker.querySelectorAll('.minute-selection div[selected]')).map(i => { i.removeAttribute('selected'); i.setAttribute('aria-selected', false); }); } target.setAttribute('selected', true); target.setAttribute('aria-selected', true); const rangeType = that._timepicker._rangeType; if (!rangeType) { return; } let targetTime = that._timepicker[`_${rangeType}`], [hours, minutes] = targetTime ? [targetTime.hours, targetTime.minutes] : [0, 0]; if (target.closest('.hour-selection')) { //Handle hour selection hours = parseInt(target.getAttribute('value')) || 0; } else { //Handle minutes selection minutes = parseInt(target.getAttribute('value')) || 0; } that._timepicker[`_${rangeType}`] = { hours: hours, minutes: minutes }; const selectedDates = that.$.calendar.selectedDates; if (!selectedDates.length) { return; } //Update the value that._performSelect({ detail: { value: selectedDates }, noChangeEvent }); } _valueValidator(oldValue, newValue) { const that = this; if ((that.valueType === 'object' && newValue.from) || typeof newValue === 'string') { return newValue; } return that.valueType === 'object' ? {} : '' } _refreshMenu() { } _setAriaRelations() { const that = this, label = that.getAttribute('aria-label'); if (that.readonly) { that.setAttribute('role', 'button'); if (!label && that.placeholder) { that.setAttribute('aria-label', that.placeholder); } that.removeAttribute('aria-readonly'); that.$.input.setAttribute('aria-hidden', true); that.$.input.removeAttribute('aria-controls'); that.$.dropDownButton.setAttribute('aria-hidden', true); } else { that.setAttribute('role', 'presentation'); if (label && label === that.placeholder) { that.removeAttribute('aria-label'); } that.$.input.removeAttribute('aria-hidden'); that.$.dropDownButton.removeAttribute('aria-hidden'); } that.setAttribute('aria-haspopup', 'dialog'); that.$.scrollView.setAttribute('role', 'dialog'); } _setActiveDescendant() { } _setInputPurpose() { } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // class Control { constructor(formState = null) { const that = this; that._parent = null; that._updating = false; that._touched = false; that._pristine = true; that._disabled = false; that.status = 'valid'; that._onChange = []; that.registerOnChange((value) => { that.writeValue(value); }); that._applyFormState(formState); } registerOnChange(fn) { this._onChange.push(fn); } get parent() { return this._parent; } set parent(value) { this._parent = value; } get valid() { return this.status === 'valid'; } get invalid() { return this.status === 'invalid'; } get dirty() { return !this._pristine; } get untouched() { return !this._touched; } get disabled() { return this._disabled; } get enabled() { return this._disabled === false; } get value() { const that = this; if (that._value && typeof(that._value) === 'object' && that._value.toDate) { return that._value.toDate(); } return that._value; } set value(value) { this.setValue(value); } setValue(value, options = {}) { const that = this; that._value = that._pendingValue = value; if (that._onChange.length && options.emitModelToViewChange !== false) { that._onChange.forEach(( (changeFn) => changeFn(that.value, options.emitViewToModelChange !== false))); } that.updateValueAndValidate(options); } /** * Patches the value of a control. * * This function is functionally the same as {\@link FormControl#setValue setValue} at this level. * It exists for symmetry with {\@link FormGroup#patchValue patchValue} on `FormGroups` and * `FormArrays`, where it does behave differently. */ patchValue(value, options = {}) { this.setValue(value, options); } reset(formState = null, options = {}) { this._applyFormState(formState); this.markAsPristine(options); this.markAsUntouched(options); this.setValue(this.value, options); this._pendingChange = false; } _isBoxedValue(formState) { return typeof formState === 'object' && formState !== null && Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState; } _applyFormState(formState) { if (this._isBoxedValue(formState)) { (( (this))).value = this._pendingValue = formState.value; formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) : this.enable({ onlySelf: true, emitEvent: false }); } else { this._value = this._pendingValue = formState; } } _runValidator() { return this._validate(); } _validate() { return null; } updateValueAndValidate(options={}) { const that = this; that._setInitialStatus(); that._updateValue(); if (that.enabled) { that.errors = that._runValidator(); that.status = that._calculateStatus(); } if (options.emitEvent !== false) { if (that.onValueChanges) { that.onValueChanges(that.value); } if (that.onStatusChanges) { that.onStatusChanges(that.status); } } if (that._onValueAndStatusUpdate) { that._onValueAndStatusUpdate(); } if (that._parent && !options.onlySelf) { that._parent.updateValueAndValidate(options); } if (that.tabItem) { that.tabItem.tab.classList.remove('lw-invalid'); that.tabItem.row.classList.remove('lw-invalid'); that.tabItem.tab.classList.remove('lw-valid'); that.tabItem.row.classList.remove('lw-valid'); if (that.status === 'invalid') { that.tabItem.tab.classList.add('lw-invalid'); that.tabItem.row.classList.add('lw-invalid'); if (that.tabItem.tab.classList.contains('selected')) { that.nextButton.disabled = true; that.backButton.disabled = true; } } else { that.tabItem.tab.classList.add('lw-valid'); that.tabItem.row.classList.add('lw-valid'); if (that.tabItem.tab.classList.contains('selected')) { that.nextButton.disabled = false; that.backButton.disabled = false; } } } } _setInitialStatus() { this.status = this._allControlsDisabled() ? 'disabled' : 'valid'; } _updateValue() { } _allControlsDisabled() { return this._allControls('disabled'); } _allControls(condition) { return this[condition]; } _anyControls(condition) { return this[condition]; } _anyControlsTouched() { return this._anyControls(( (control) => control.touched)); } _calculateStatus() { const that = this; if (that._allControls('disabled')) { return 'disabled'; } if (that.errors) { return 'invalid'; } if (that._anyControls('pending')) { return 'pending'; } if (that._anyControls('invalid')) { return 'invalid'; } return 'valid'; } markAsUntouched(opts={}) { this._touched = false; this._forEachChild(( (control)=>{ control.markAsUntouched({ onlySelf: true }); } )); if (this._parent && !opts.onlySelf) { this._parent._updateTouched(opts); } } markAsTouched(opts = {}) { this._touched = true; if (this._parent && !opts.onlySelf) { this._parent.markAsTouched(opts); } } _updateTouched(opts={}) { (( (this)))._touched = this._anyControlsTouched(); if (this._parent && !opts.onlySelf) { this._parent._updateTouched(opts); } } markAsPristine(opts={}) { this._pristine = true; this._forEachChild(( (control)=>{ control.markAsPristine({ onlySelf: true }); } )); if (this._parent && !opts.onlySelf) { this._parent._updatePristine(opts); } } markAsDirty(opts = {}) { this._pristine = false; if (this._parent && !opts.onlySelf) { this._parent.markAsDirty(opts); } } _updatePristine(opts = {}) { const that = this; that._pristine = !this._anyControls('dirty'); if (that._parent) { that._parent._updatePristine(opts); } } _parentMarkedDirty(onlySelf) { const parentDirty = this._parent && this._parent.dirty; return !onlySelf && parentDirty && !this._parent._anyControlsDirty(); } _forEachChild() { } disable(opts = {}) { const that = this; const skipPristineCheck = that._parentMarkedDirty(opts.onlySelf); that.status = 'disabled'; that.errors = null; that._disabled = true; that._forEachChild(( (control) => { control.disable(Object.assign({}, opts, { onlySelf: true })); })); that._updateValue(); if (opts.emitEvent !== false) { if (that.onValueChanges) { that.onValueChanges(this.value); } if (that.onStatusChanges) { that.onStatusChanges(this.status); } } that._updateAncestors(Object.assign({}, opts, { skipPristineCheck })); } enable(opts = {}) { const that = this; const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf); that.status = 'valid'; that._forEachChild(( (control) => { control.enable(Object.assign({}, opts, { onlySelf: true })); })); that.updateValueAndValidate({ onlySelf: true, emitEvent: opts.emitEvent }); that._updateAncestors(Object.assign({}, opts, { skipPristineCheck })); } _updateAncestors(opts) { if (this._parent && !opts.onlySelf) { this._parent.updateValueAndValidate(opts); if (!opts.skipPristineCheck) { this._parent._updatePristine(); } this._parent._updateTouched(); } } } LW('lw-form-control', class HTMLFormControl extends LW.BaseElement { static get properties() { return { 'action': { value: '', type: 'string' }, 'controlType': { value: 'input', type: 'string' }, 'columnSpan': { value: 1, type: 'number?' }, 'dataField': { value: '', type: 'string' }, 'disabled': { value: false, type: 'boolean' }, 'hint': { value: '', type: 'string' }, 'info': { value: '', type: 'string' }, 'label': { value: '', type: 'string' }, 'labelPosition': { value: 'left', type: 'string' }, 'placeholder': { value: '', type: 'string' }, 'readonly': { value: false, type: 'boolean' }, 'required': { value: false, type: 'boolean' }, 'validationRules': { value: [], type: 'any' }, 'value': { value: '', type: 'any' } } } template() { return '<div id="control"></div>' } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; let parent = that.parentElement; while(parent) { if (parent.nodeName === 'LW-FORM') { const control = parent.getControl(that.controlOptions.dataField); control[propertyName] = newValue; break; } parent = parent.parentElement; } that.controlOptions[propertyName] = newValue; } render() { super.render(); } get controlOptions() { const that = this; if (!that._controlOptions && that._properties) { let controlOptions = {}; for (let propertyName in that._properties) { if (that._properties[propertyName].value !== that._properties[propertyName].defaultValue) { controlOptions[propertyName] = that._properties[propertyName].value; } } that.classList.remove('lw-element'); that.classList.remove('lw-form-control'); controlOptions.cssClass = that.className; if (controlOptions.controlType === 'template') { controlOptions.template = that.innerHTML; that.innerHTML = ''; } controlOptions.custom = true; that._controlOptions = controlOptions; } return that._controlOptions; } }); class FormControl extends Control { constructor(element, value, controlOptions) { super(value, controlOptions); const that = this; that.element = element; that._initProps(controlOptions); if (controlOptions.custom) { that._setupCustomInput(); } else { const parentElement = that.element.parentElement; that.input = element; that.input.value = value; that.labelElement = that.element.parentElement.querySelector('label'); that.label = that.labelElement ? that.labelElement.innerHTML.trim() : ''; that.element = document.createElement('div'); that.element.setAttribute('form-control-name', that.input.getAttribute('form-control-name')); that.element.appendChild(that.input); parentElement.appendChild(that.element); } that.element.classList.add('lw-untouched'); that.element.classList.add('lw-pristine'); that.element.classList.add('lw-form-control'); that._disabled = that.input.disabled !== undefined ? that.input.disabled : false; that._setupInput(); that.updateValueAndValidate(); that._onValueAndStatusUpdate = () => { if (that.element) { that.element.classList.remove('lw-valid'); that.element.classList.remove('lw-invalid'); that.element.classList.add('lw-' + that.status); } } that.refresh(); } _initProps(controlOptions) { const that = this; Object.keys(controlOptions).forEach((value) => { that['_' + value] = controlOptions[value]; }); if (!that.name) { that.name = controlOptions.name; } if (!that.name) { const id = that.element.nodeName.toLowerCase() + LW.Utilities.Core.createGUID(); that.name = id.replace(/-/ig, ''); } if (!that._validationRules) { that._validationRules = []; } if (!that._readonly) { that._readonly = false; } if (!that._controlType) { that._controlType = 'text'; } if (!that._labelPosition) { that._labelPosition = 'left'; } if (!that._label) { that._label = ''; } if (!that._hint) { that._hint = ''; } if (!that._controlOptions) { that._controlOptions = {}; } if (!that._info) { that._info = ''; } if (that._placeholder) { that._controlOptions.placeholder = that._placeholder; } if (!that._columnSpan) { that._columnSpan = 1; } } _setupCustomInput() { const that = this; let element = that.element; let input = null; switch(that._controlType) { case 'submit': case 'button': { if (LW.Button) { input = document.createElement('lw-button'); } else { input = document.createElement('button'); input.classList.add('lw-button'); input.innerHTML = that._label || ''; } input.type = that._controlType; input.innerHTML = that._label || ''; if (that._action === 'submit') { input.type = 'submit'; } if (input.type === 'submit') { that._action = 'submit'; } if (that._action) { input.onclick = ()=> { switch(that._action) { case 'reset': if (that.root) { that.root.reset(); } break; case 'submit': if (that.root) { that.root.submit(); } break; } } } break; } case 'boolean': case 'bool': case 'checkBox': case 'checkbox': case 'radio': case 'radioButton': case 'option': { input = document.createElement('div'); const isRadio = that._controlType.toLowerCase() === 'checkbox' || that._controlType === 'boolean' || that._controlType === 'bool' ? false : true; const createOption = (option) => { const optionElement = document.createElement('div'); const label = typeof option === 'string' ? option : option.label || option.value; const value = typeof option === 'string' ? '' : option.value || ''; let btn = document.createElement('input'); optionElement.classList.add('lw-form-option'); if (LW.RadioButton && LW.CheckBox) { btn = isRadio ? document.createElement('lw-radio-button') : document.createElement('lw-check-box'); btn.value = value; btn.innerHTML = label; btn.name = that.name; btn.groupName = that.name; optionElement.appendChild(btn); } else { const labelElement = document.createElement('span'); labelElement.innerHTML = label; btn.value = value; btn.type = isRadio ? 'radio': 'checkbox'; btn.name = that.name; labelElement.onpointerdown = () => { btn.click(); } optionElement.appendChild(btn); optionElement.appendChild(labelElement); } input.appendChild(optionElement); } if (that._options) { for(let i = 0; i < that._options.length; i++) { const option = that._options[i]; createOption(option); } } else { createOption(that.label); } if (that._optionsLayout === 'horizontal') { input.classList.add('lw-form-options-horizontal'); } break; } case 'textArea': case 'textarea': { if (LW.TextArea) { input = document.createElement('lw-text-area'); input.dropDownAppendTo = 'body'; } else { input = document.createElement('textarea'); input.classList.add('lw-input'); } break; } case 'text': case 'input': { if (LW.Input) { input = document.createElement('lw-input'); input.dropDownAppendTo = 'body'; } else { input = document.createElement('input'); input.classList.add('lw-input'); } break; } case 'mask': if (LW.MaskedTextBox) { input = document.createElement('lw-masked-text-box'); } else { input = document.createElement('input'); input.classList.add('lw-input'); break; } break; case 'date': case 'time': case 'datetime': { if (LW.DateTimePicker) { input = document.createElement('lw-date-time-picker'); input.calendarButton = true; if (that._controlType === 'datetime') { input.formatString = 'F'; input.dropDownDisplayMode = 'default'; } else if (that._controlType === 'date') { input.formatString = 'd'; input.dropDownDisplayMode = 'calendar'; } else if (that._controlType === 'time') { input.formatString = 'T'; input.dropDownDisplayMode = 'timePicker'; } input.dropDownAppendTo = 'body'; } else if (LW.DateRangeInput) { input = document.createElement('lw-date-range-input'); input.dropDownAppendTo = 'body'; } else { input = document.createElement('input'); input.classList.add('lw-input'); input.type = 'date'; break; } break; } case 'numberinput': case 'numberInput': case 'numeric': case 'number': if (LW.NumericTextBox) { input = document.createElement('lw-numeric-text-box'); input.spinButtons = true; } else { input = document.createElement('input'); input.type = 'number'; input.classList.add('lw-input'); break; } break; case 'password': case 'passwordInput': case 'passwordinput': { if (LW.PasswordTextBox) { input = document.createElement('lw-password-text-box'); } else { input = document.createElement('input'); input.type = 'password'; input.classList.add('lw-input'); break; } break; } case 'checkInput': case 'checkinput': { input = document.createElement('lw-check-input'); input.dropDownAppendTo = 'body'; break; } case 'multiInput': case 'multiinput': { input = document.createElement('lw-multi-input'); input.dropDownAppendTo = 'body'; break; } case 'multiComboInput': case 'multicomboinput': { input = document.createElement('lw-multi-combo-input'); input.dropDownAppendTo = 'body'; break; } case 'comboBox': case 'combobox': { input = document.createElement('lw-drop-down-list'); input.dropDownAppendTo = 'body'; break; } case 'dropDownList': case 'dropdownlist': { input = document.createElement('lw-drop-down-list'); input.dropDownAppendTo = 'body'; break; } case 'template': { input = document.createElement('div'); input.innerHTML = '<div class="lw-form-template">' + that._template || that._value + '</div>'; break; } case 'label': { input = document.createElement('label'); input.innerHTML = that.label; break; } } input.setAttribute('editor', that._controlType); for(let option in that._controlOptions) { input[option] = that._controlOptions[option]; } that.input = input; if (this.value) { this.writeValue(this.value); } element.appendChild(input); } _setupInput() { const that = this; const _onTouched = that.onTouched.bind(that); const _onChange = that.onChange.bind(that); const attach = () => { if (!that._attached) { that.input.addEventListener('blur', _onTouched); that.input.addEventListener('change', _onChange); if (that.input.nodeName === 'INPUT') { that.input.addEventListener('keyup', _onChange); } else if (that.input.querySelector('input')) { that.input.querySelector('input').addEventListener('keyup', _onChange); } if (that.input instanceof HTMLDivElement) { const inputs = that.input.querySelectorAll('input'); const radios = that.input.querySelectorAll('lw-radio-button'); const checks = that.input.querySelectorAll('lw-check-box'); const switches = that.input.querySelectorAll('lw-switch-button'); for(let i = 0; i < radios.length; i++){ radios[i].addEventListener('blur', _onTouched); } for(let i = 0; i < checks.length; i++){ checks[i].addEventListener('blur', _onTouched); } for(let i = 0; i < switches.length; i++){ switches[i].addEventListener('blur', _onTouched); } for(let i = 0; i < inputs.length; i++){ inputs[i].addEventListener('blur', _onTouched); inputs[i].addEventListener('change', _onChange); } } that._attached = true; } } that.input.whenRendered ? that.input.whenRendered(() => { attach(); }) : attach(); that.input.onAttached = () => { attach(); } that.input.onDetached = () => { that.input.removeEventListener('blur', _onTouched); that.input.removeEventListener('change', _onChange); if (that.input.nodeName === 'INPUT') { that.input.removeEventListener('keyup', _onChange); } else if (that.input.querySelector('input')) { that.input.querySelector('input').removeEventListener('keyup', _onChange); } if (that.input instanceof HTMLDivElement) { const inputs = that.input.querySelectorAll('input'); const radios = that.input.querySelectorAll('lw-radio-button'); const checks = that.input.querySelectorAll('lw-check-box'); const switches = that.input.querySelectorAll('lw-switch-button'); for(let i = 0; i < radios.length; i++){ radios[i].removeEventListener('blur', _onTouched); } for(let i = 0; i < checks.length; i++){ checks[i].removeEventListener('blur', _onTouched); } for(let i = 0; i < switches.length; i++){ switches[i].removeEventListener('blur', _onTouched); } for(let i = 0; i < inputs.length; i++){ inputs[i].removeEventListener('blur', _onTouched); inputs[i].removeEventListener('change', _onChange); } } that._attached = false; } that.element.name = that.name; that.input.name = that.element.name; if (that.input instanceof HTMLDivElement) { const children = that.input.querySelectorAll('input'); for(let i = 0; i < children.length; i++) { children[i].name = that.name; } } that.input.setAttribute('name', that.input.name); if (!that.input.id) { if (!document.getElementById(that.name)){ that.input.id = that.name } else { const id = that.name + '_' + LW.Utilities.Core.createGUID(); that.input.id = id.replace(/-/ig, ''); } } that.input.classList.add('lw-form-editor'); } get root() { let x = this; while (x.parent) { x = x.parent; } return x; } get prepend() { return this._prepend; } get append() { return this._append; } get columnSpan() { return this._columnSpan; } set columnSpan(value) { const that = this; that._columnSpan = value; if (that._parent) { that._parent.refresh(); } } get cssClass() { return this._cssClass; } set cssClass(value) { const that = this; that.input.classList.remove(that.cssClass); that._cssClass = value; that.input.classList.add(that.cssClass); } get required() { return this._required; } get controlType() { return this._controlType; } get validationRules() { return this._validationRules; } set validationRules(value) { this._validationRules = value; this.refresh(); } get readonly() { return this._readonly; } set readonly(value) { const that = this; that._readonly = value; if (!that.element) { return; } if (value) { if (that.labelElement) { that.labelElement.setAttribute('readonly', ''); } that.element.setAttribute('readonly', ''); } else { that.element.removeAttribute('readonly'); if (that.labelElement) { that.labelElement.removeAttribute('readonly'); } } } get label() { return this._label; } set label(value) { this._label = value; this.refresh(); } get labelPosition() { return this._labelPosition; } set labelPosition(value) { this._labelPosition = value; this.refresh(); } get hint() { return this._hint; } set hint(value) { this._hint = value; this.refresh(); } get info () { return this._info ; } set info (value) { this._info = value; this.refresh(); } refresh() { const that = this; if (that.infoElement) { that.infoElement.remove(); } if (that.appendElement) { that.appendElement.remove(); } if (that.prependElement) { that.prependElement.remove(); } if (that.cssClass) { that.input.classList.add(that.cssClass); } if (that.controlType === 'blank' || that.controlType === 'separator' || that.controlType === 'label' || that.controlType === 'boolean' || that.controlType === 'radio' || that.controlType === 'checkBox' || that.controlType === 'checkbox') { return; } if (that._align) { that.element.classList.remove('left'); that.element.classList.remove('center'); that.element.classList.remove('right'); that.element.classList.add(that._align); } that.infoElement = document.createElement('div'); that.infoElementInner = document.createElement('span'); that.infoElementInner.classList.add('lw-grid-icon', 'lw-form-control-icon', 'lw-icon-help-circled', 'show', 'lw-visibility-hidden'); that.infoElementInner.setAttribute('tooltip', that.info); that.infoElement.appendChild(that.infoElementInner); that.appendElement = document.createElement('div'); that.appendElement.classList.add('lw-form-control-addon'); that.prependElement = document.createElement('div'); that.prependElement.classList.add('lw-form-control-addon'); if (that.info) { that.infoElementInner.classList.remove('lw-hidden'); that.infoElementInner.classList.remove('lw-visibility-hidden'); } if (that.append) { that.appendElement.innerHTML = '<span>' + that.append + '</span>'; that.element.appendChild(that.appendElement); } if (that.prepend) { that.prependElement.innerHTML = '<span>' + that.prepend + '</span>'; that.element.insertBefore(that.prependElement, that.input); } that.element.appendChild(that.infoElement); if (that.label && that.controlType !== 'button' && that.controlType !== 'submit') { const labelElement = !that.labelElement ? document.createElement('label') : that.labelElement; labelElement.classList.add('lw-form-control-label'); labelElement.setAttribute('for', that.input.id); if (that.validationRules.length > 0 || that.required) { labelElement.setAttribute('required', ''); } labelElement.innerHTML = that.label; that.labelElement = labelElement; } if (that.parent) { that.parent.refresh(); } } writeValue(value) { const that = this; that._setControlValue(value); } _setControlValue(value) { const that = this; that._updating = true; if (value === null) { if (that.input.selectedValues) { that.input.selectedValues = []; } if (that.input.selectedDates) { that.input.selectedDates = []; } if (that.input.checked !== undefined) { that.input.checked = false; } that.input.value = ''; that._updating = false; return; } if (that.input.selectedValues) { if (Array.isArray(value)) { that.input.selectedValues = value; } else { that.input.selectedValues = [value]; } that._updating = false; return; } if (that.input.selectedDates) { if (Array.isArray(value)) { that.input.selectedDates = value; } else { that.input.selectedDates =[value]; } that._updating = false; return; } if (that.input.checked !== undefined) { if (value === '') { value = null; } const normalizedValue = typeof value === 'string' ? (value === 'true' ? true : false) : value; that.input.checked = normalizedValue; } if (that.input instanceof HTMLDivElement) { const inputs = that.input.querySelectorAll('input'); const radioButtons = that.input.querySelectorAll('lw-radio-button'); const checkBoxes = that.input.querySelectorAll('lw-check-box'); const imageTemplate = that.input.querySelector('.lw-form-image-template'); const template = that.input.querySelector('.lw-form-template'); const setValues = (inputs) => { for(let i = 0; i < inputs.length; i++) { const input = inputs[i]; if (typeof value === 'string') { if (input.value === value) { input.checked = true; } else { input.checked = false; } } else if (Array.isArray(value)) { if(value.indexOf(input.value) >= 0) { input.checked = true; } else { input.checked = false; } } else if (typeof value === 'boolean') { input.checked = value; } } } setValues( radioButtons.length > 0 ? radioButtons : (checkBoxes.length > 0 ? checkBoxes : inputs)); if (imageTemplate) { imageTemplate.innerHTML = '<img src="' + value + '"/>'; } else if (template) { template.innerHTML = value; } } that.input.value = value; that._updating = false; } _getControlValue() { const that = this; const selectedValues = that.input.selectedValues !== undefined ? 'selectedValues' : that.input.selectedDates !== undefined ? 'selectedDates' : null; if (selectedValues) { if (that.input[selectedValues].length > 1) { return that.input.selectedValues; } else if (that.input[selectedValues].length === 1) { if (that.input.selectedDates !== undefined) { return that.input.selectedDates[0].toDate(); } return that.input.selectedValues[0]; } else if (that.input.querySelector('input')) { return that.input.querySelector('input').value; } else { return null; } } else if (that.input.checked !== undefined && this.input.nodeName.toLowerCase().startsWith('lw')) { return that.input.checked; } else if (that.input instanceof HTMLDivElement) { const inputs = that.input.querySelectorAll('input'); const radioButtons = that.input.querySelectorAll('lw-radio-button'); const checkBoxes = that.input.querySelectorAll('lw-check-box'); const getValues = (inputs) => { let values = []; for(let i = 0; i < inputs.length; i++) { const input = inputs[i]; if (input.value === '' && input.checked) { values.push(true); } else if (input.value === '' && input.checked === false) { values.push(false); } else if (input.checked) { values.push(input.value); } } if (values.length === 1) { return values[0]; } if (values.length === 0) { return ''; } return values; } return getValues( radioButtons.length > 0 ? radioButtons : (checkBoxes.length > 0 ? checkBoxes : inputs)) } else { return that.input.value; } } reset() { const that = this; super.reset(); that.element.classList.remove('lw-untouched'); that.element.classList.remove('lw-touched'); that.element.classList.remove('lw-dirty'); that.element.classList.remove('lw-pristine'); that.element.classList.remove('lw-valid'); that.element.classList.remove('lw-invalid'); } onTouched() { const that = this; if (that._updating) { return; } that.element.classList.remove('lw-untouched'); that.element.classList.add('lw-touched'); that.element.touched = true; that.markAsTouched(); that.updateValueAndValidate(); } onChange() { const that = this; if (that._updating) { return; } setTimeout(() => { that.element.classList.remove('lw-pristine'); that.element.classList.add('lw-dirty'); that.element.pristine = false; that._pristine = false; that._pendingValue = that._getControlValue(); that._pendingChange = true; that._pendingDirty = true; that.updateControl(that); }); } updateControl(control) { if (control._pendingDirty) control.markAsDirty(); control.setValue(control._pendingValue, { emitModelToViewChange: false }); control._pendingChange = false; } _validate() { const that = this; const input = that.input; if (that.form && that.form.validator) { that.form.validator.validate(null, '#' + input.id); } const errors = {}; let hasErrors = false; for (let error in input.errors) { if (input.errors[error] === true) { errors[error] = true; hasErrors = true; } } return hasErrors ? errors : null; } disable() { super.disable(); this.element.disabled = true; this.input.disabled = true; } enable() { super.enable(); this.element.disabled = false; this.input.disabled = false; } show() { this.element.parentElement.classList.remove('lw-hidden'); } hide() { this.element.parentElement.classList.add('lw-hidden'); } } LW('lw-form-group', class HTMLFormGroup extends LW.BaseElement { static get properties() { return { 'controlType': { value: 'input', type: 'string' }, 'columnSpan': { value: 1, type: 'number?' }, 'columns': { value: 1, type: 'number?' }, 'dataField': { value: '', type: 'string' }, 'disabled': { value: false, type: 'boolean' }, 'hint': { value: '', type: 'string' }, 'info': { value: '', type: 'string' }, 'label': { value: '', type: 'string' }, 'labelPosition': { value: 'left', type: 'string' }, 'onValueChanges': { value: null, type: 'any', reflectToAttribute: false }, 'onStatusChanges': { value: null, type: 'any', reflectToAttribute: false }, 'showColorAfterLabel': { value: false, type: 'boolean' }, 'viewMode': { value: '', type: 'string' }, 'readonly': { value: false, type: 'boolean' }, 'validationRules': { value: [], type: 'any' }, 'value': { value: '', type: 'any' } } } template() { return '<div id="group"></div>' } render() { const that = this; const controls = []; if (that.value && that.value.indexOf && that.value.indexOf('{') >= 0) { that.value = JSON.parse(that.value); } for(let i = 0; i < that.$.group.children.length; i++) { const childControl = that.$.group.children[i]; controls.push(childControl.controlOptions); } that.controlOptions.controls = controls; that.controlOptions.controlType = 'group'; super.render(); } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; let parent = that.parentElement; while(parent) { if (parent.nodeName === 'LW-FORM') { const control = parent.getControl(that.controlOptions.dataField); control[propertyName] = newValue; break; } parent = parent.parentElement; } that.controlOptions[propertyName] = newValue; } get controlOptions() { const that = this; if (!that._controlOptions && that._properties) { let controlOptions = {}; for (let propertyName in that._properties) { if (that._properties[propertyName].value !== that._properties[propertyName].defaultValue) { controlOptions[propertyName] = that._properties[propertyName].value; } } controlOptions.custom = true; that._controlOptions = controlOptions; } return that._controlOptions; } }); LW('lw-form', class HTMLForm extends LW.FormGroup { render() { super.render(); const that = this; const controlOptions = that.controlOptions; that.form = new Form('#' + that.id, controlOptions); } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (that.form) { that.form[propertyName] = newValue; } } getControl(controlName) { return this.form.getControl(controlName); } validate() { this.form.validate(); } submit(options) { this.form.submit(options); } reset() { this.form.reset(); } get state() { if (this.form) { return this.form.state; } return null; } set state(value) { } }); class FormGroup extends Control { constructor(template, config) { super(null, config); const that = this; if (template.value && !template.controls) { let controls = []; for (let name in template.value) { const controlValue = template.value[name]; let controlType = name.toLowerCase().indexOf('date') >= 0 || controlValue instanceof Date ? 'date' : controlValue.length < 40 ? 'text' : 'textarea'; if (typeof controlValue === 'number' || (controlType !== 'date' && !isNaN(new Number(controlValue)))) { controlType = 'number'; } if (controlValue === 'true' || controlValue === 'false' || controlValue === true || controlValue === false) { controlType = 'boolean'; } if (controlValue.indexOf('.jpg') >= 0 || controlValue.indexOf('.png') >= 0 || controlValue.indexOf('.gif') >= 0) { controlType = 'template'; } const control = { dataField: name, label: name, value: controlValue, controlType: controlType } if (controlType === 'template') { control.template = '<div class="lw-form-image-template"><img src="' + controlValue + '"/></div>' } controls.push(control); } template.controls = controls; } if (template.controls) { that._labelPosition = template.labelPosition || ''; that._labelOffset = template.labelOffset || 10; that._showColonAfterLabel = template.showColonAfterLabel || false; that._columnSpan = template.columnSpan || 1; that._controls = {}; that._columns = template.columns || 1; that._label = template.label || ''; that._viewMode = template.viewMode || ''; that._readonly = template.readonly || false; that._labelAlign = template.labelAlign || ''; that._showButtons = template.showButtons || ''; that._nextButtonLabel = template.nextButtonLabel || 'Next'; that._backButtonLabel = template.backButtonLabel || 'Back'; if (template.onValueChanges) { that.onValueChanges = template.onValueChanges; } if (template.onStatusChanges) { that.onStatusChanges = template.onStatusChanges; } if (!template.name) { template.name = template.dataField; } else if (!template.dataField) { template.dataField = template.name; } that.name = template.name || ''; that.dataField = template.dataField || ''; that.element = document.createElement('div'); that.labelElement = document.createElement('div'); that.contentElement = document.createElement('div'); that.element.appendChild(that.labelElement); that.element.appendChild(that.contentElement); that.labelElement.classList.add('lw-form-group-label'); that.contentElement.classList.add('lw-form-group-content'); if (!that.label) { that.labelElement.classList.add('lw-hidden'); } that.element.classList.add('lw-form-group'); if (that.viewMode === '') { that.element.setAttribute('columns', that.columns); } that.labelElement.innerHTML = that.label + (that._showColonAfterLabel ? ':' : ''); for(let i = 0; i < template.controls.length; i++) { let templateControl = template.controls[i]; if (typeof templateControl === 'string') { const normalizedControl = { dataField: templateControl, label: templateControl, type: 'text' }; templateControl = normalizedControl; } const formControlOptions = templateControl; that._addControl = (formControlOptions) => { const rowElement = document.createElement('div'); if (!formControlOptions.labelPosition) { formControlOptions.labelPosition = that._labelPosition; } if (!formControlOptions.name) { formControlOptions.name = formControlOptions.dataField; } else if (!formControlOptions.dataField) { formControlOptions.dataField = formControlOptions.name; } const control = that._createControl(formControlOptions.name, formControlOptions); if (formControlOptions.name) { that._controls[formControlOptions.name] = control; } if (!that._controls.$) { that._controls.$ = []; } that._controls.$.push(control); control._parent = this; rowElement.classList.add('lw-form-row'); if (control.labelElement) { rowElement.appendChild(control.labelElement); } rowElement.appendChild(control.element); that.contentElement.appendChild(rowElement); return control; } that._addControl(formControlOptions); } that.refresh(); } else { that._controls = that._reduceControls(template); } that._onValueAndStatusUpdate = () => { if (that.element) { that.element.classList.remove('lw-valid'); that.element.classList.remove('lw-invalid'); that.element.classList.add('lw-' + that.status); } } that._setUpControls(); that.updateValueAndValidate({ onlySelf: true, emitEvent: false }); } addControl(controlOptions) { const that = this; const control = that._addControl(controlOptions); that[control.name] = control; that.refresh(); } insertControl(index, controlOptions) { const that = this; const row = that.contentElement.querySelectorAll('.lw-form-row')[index]; const control = that._addControl(controlOptions); that[control.name] = control; that.contentElement.insertBefore(control.element.parentElement, row); that.refresh(); } removeControl(controlName) { const that = this; if (that[controlName]) { that[controlName].element.parentElement.remove(); const index = that.controls.$.indexOf(that[controlName]); that.controls.$.splice(index, 1); delete that[controlName]; delete that._controls[controlName]; } } refresh() { const that = this; let longestLabel = ''; if (that.viewMode === '') { that.element.setAttribute('columns', that.columns); } that.labelElement.innerHTML = that.label + (that.controlType !== 'group' && that.showColonAfterLabel ? ':' : ''); that.labelElement.className = 'lw-form-group-label'; if (!that.label) { that.labelElement.classList.add('lw-hidden'); } if (that.labelAlign) { that.labelElement.classList.add(that.labelAlign); } if (!that._controls) { that._controls = {$: []}; } else if (that._controls && !that._controls.$) { that._controls.$ = []; } for(let i = 0; i < that._controls.$.length; i++) { const control = that._controls.$[i]; if (control._controlType === 'group') { continue; } if (control.labelElement) { if (longestLabel.length < control.label.length) { longestLabel = control.label; } } } const calculatedLabelWidth = (() => { const label = document.createElement('label'); label.classList.add('lw-form-control-label'); label.innerHTML = longestLabel; document.body.appendChild(label); const width = label.offsetWidth + that._labelOffset; label.remove(); return width; })(); for(let i = 0; i < that._controls.$.length; i++) { const control = that._controls.$[i]; const rowElement = control.element.parentElement; if (!control.labelElement || control.controlType === 'group') { continue; } if (control.labelPosition === 'left') { rowElement.style.display = 'grid'; rowElement.style.gridTemplateColumns = calculatedLabelWidth + 'px auto'; } else { rowElement.style.display = ''; rowElement.style.gridTemplateColumns = ''; } } const tabItems = []; for(let i = 0; i < that._controls.$.length; i++) { const control = that._controls.$[i]; const rowElement = control.element.parentElement; control.readonly = that.readonly; control.showColonAfterLabel = that.showColonAfterLabel; if (control.columnSpan > 1 && control.columnSpan <= that.columns) { rowElement.style.gridColumn = 'span ' + control.columnSpan; } else { rowElement.style.gridColumn = ''; } if (control.labelElement) { control.labelElement.innerHTML = control.label + (control.controlType !== 'group' && that._showColonAfterLabel ? ':' : ''); if (that.viewMode === 'tabs' || that.viewMode === 'accordion' || that.viewMode === 'breadcrumb') { if (control.label && control._controlType !== 'button' && control._controlType !== 'label' && control._controlType !== 'submit') { tabItems.push({label: control.label, control: control, id: control.name, row: rowElement}); } } } if (control.labelElement && !rowElement.contains(control.labelElement)) { rowElement.firstElementChild.remove(); rowElement.insertBefore(control.labelElement, control.element); } } that._refreshButtons(); if (that.viewMode === 'tabs' || that.viewMode === 'accordion' || that.viewMode === 'breadcrumb') { if (that.tabs) { that.tabs.remove(); } const tabs = document.createElement('div'); tabs.classList.add('lw-form-tab-strip'); if (that.viewMode === 'accordion') { tabs.setAttribute('vertical', ''); } else if (that.viewMode === 'breadcrumb') { tabs.setAttribute('breadcrumb', ''); } for(let i = 0; i < tabItems.length; i++) { const tab = document.createElement('div'); const tabItem = tabItems[i]; if (i === 0) { tab.classList.add('selected'); tabItem.row.classList.add('selected'); that._currentTabItem = tabItem; } tab.classList.add('lw-form-tab'); if (that.viewMode === 'breadcrumb') { tab.innerHTML = '<div class="lw-form-tab-label">' + '<span class="circle">' + (1+i) + '</span>' + '<span>' + tabItem.label + '</span>' + '</div>'; } else { tab.innerHTML = '<div class="lw-form-tab-label">' + tabItem.label + '</div>'; } if (that.viewMode === 'accordion') { tab.innerHTML += '<div class="lw-form-tab-button"><span class="lw-arrow lw-arrow-up"></span></div>' } tab.dataField = tabItem.control.name; tabItem.control.tabItem = tabItem; tabItem.control.nextButton = that.nextButton; tabItem.control.backButton = that.backButton; tab.onclick = function() { let currentTabItem = null; if (that._currentTabItem.control.status === 'invalid') { return; } for(let i = 0; i < tabItems.length; i++) { const tabItem = tabItems[i]; tabItem.tab.classList.remove('selected'); tabItem.row.classList.remove('selected'); if (tabItem.tab === this) { currentTabItem = tabItem; that._currentTabItem = tabItem; if (that.showButtons) { that.backButton.classList.remove('lw-hidden'); that.nextButton.classList.remove('lw-hidden'); if (i === 0) { that.backButton.classList.add('lw-hidden'); } else if (i === tabItems.length - 1) { that.nextButton.classList.add('lw-hidden'); } } } } this.classList.add('selected'); requestAnimationFrame(() => { currentTabItem.row.classList.add('selected'); if (that.viewMode === 'accordion') { tabs.insertBefore(currentTabItem.row, this.nextSibling); } }); } tabItem.tab = tab; tabItem.row.classList.add('lw-form-tab-control'); tabs.appendChild(tab); if (that.viewMode === 'accordion') { if (i === 0 ) { tabs.appendChild(tabItem.row); } tabItem.row.setAttribute('vertical', ''); } } that.tabs = tabs; that.contentElement.insertBefore(tabs, that.contentElement.firstElementChild); } } _refreshButtons() { const that = this; if (that.buttonsContainer) { that.buttonsContainer.remove(); } that.nextButton = document.createElement('lw-button'); that.backButton = document.createElement('lw-button'); that.nextButton.classList.add('primary'); that.backButton.classList.add('flat'); that.nextButton.innerHTML = that.nextButtonLabel; that.backButton.innerHTML = that.backButtonLabel; const buttonsContainer = document.createElement('div'); buttonsContainer.classList.add('lw-form-group-buttons', 'lw-form-row'); buttonsContainer.appendChild(that.backButton); buttonsContainer.appendChild(that.nextButton); that.contentElement.appendChild(buttonsContainer); that.buttonsContainer = buttonsContainer; that.backButton.classList.add('lw-hidden'); that.nextButton.onclick = () => { const tabs = that.contentElement.querySelectorAll('.lw-form-tab'); for(let i = 0; i < tabs.length; i++) { const tab = tabs[i]; if (tab.classList.contains('selected')) { const nextTab = tabs[i+1]; if (nextTab) { nextTab.click(); break; } } } } that.backButton.onclick = () => { const tabs = that.contentElement.querySelectorAll('.lw-form-tab'); for(let i = 0; i < tabs.length; i++) { const tab = tabs[i]; if (tab.classList.contains('selected')) { const prevTab = tabs[i-1]; if (prevTab) { prevTab.click(); break; } } } } if (!that.showButtons) { that.backButton.classList.add('lw-hidden'); that.nextButton.classList.add('lw-hidden'); } } get labelAlign() { return this._labelAlign; } set labelAlign(value) { this._labelAlign = value; this.refresh(); } get showButtons() { return this._showButtons; } set showButtons(value) { this._showButtons = value; this.refresh(); } get nextButtonLabel() { return this._nextButtonLabel; } set nextButtonLabel(value) { this._nextButtonLabel = value; this.refresh(); } get backButtonLabel() { return this._backButtonLabel; } set backButtonLabel(value) { this._backButtonLabel = value; this.refresh(); } get viewMode() { return this._viewMode; } set viewMode(value) { this._viewMode = value; this.refresh(); } get columnSpan() { return this._columnSpan; } set columnSpan(value) { const that = this; that._columnSpan = value; if (that._parent) { that._parent.refresh(); } } get controlType() { return 'group'; } get labelOffset() { return this._labelOffset; } set labelOffset(value) { const that = this; that._labelOffset = value; that.refresh(); } get readonly() { return this._readonly; } set readonly(value) { const that = this; that._readonly = value; that.refresh(); } get showColonAfterLabel() { return this._showColonAfterLabel; } set showColonAfterLabel(value) { const that = this; that._showColonAfterLabel = value; that.refresh(); } get labelPosition() { return this._labelPosition; } set labelPosition(value) { const that = this; that._labelPosition = value; for(let i = 0; i < that.controls.$.length; i++) { that.controls.$[i].labelPosition = value; } that.refresh(); } get columns() { return this._columns; } set columns(value) { const that = this; that._columns = value; that.refresh(); } get label() { return this._label; } set label(value) { const that = this; that._label = value; that.refresh(); } _group(controls, options) { controls = this._reduceControls(controls); const formGroup = new FormGroup(controls, options); return formGroup; } _reduceControls(controlsConfig) { const that = this; const controls = {}; Object.keys(controlsConfig).forEach(( controlName=>{ if (controlName !== '') { controls[controlName] = that._createControl(controlName, controlsConfig[controlName]); } } )); return controls; } _createControl(controlName, controlOptions) { const that = this; let control = document.querySelector(`[form-control-name="${controlName}"]`); let group = document.querySelector(`[form-group-name="${controlName}"]`); if (group && !(controlOptions instanceof FormGroup)) { return this._group(controlOptions, {}); } if (controlOptions instanceof FormControl || controlOptions instanceof FormGroup) { controlOptions.name = controlName; if (group) { controlOptions.element = group; } if (controlOptions instanceof FormControl) { controlOptions.element.setAttribute('form-control-name', controlName); } else if (controlOptions instanceof FormGroup) { controlOptions.element.setAttribute('form-group-name', controlName); } return controlOptions; } else if (Array.isArray(controlOptions)) { const value = controlOptions[0]; const controlConfig = controlOptions.length > 1 ? controlOptions[1] : {}; controlConfig.name = controlName; if (!control) { return that._createTemplateControl(controlConfig); } return new FormControl(control, value, controlConfig); } else { if (!control) { return that._createTemplateControl(controlName, controlOptions); } control.name = controlName; return new FormControl(control, ''); } } _createTemplateControl(controlName, controlOptions = {}) { const element = document.createElement('div'); if (controlName) { element.setAttribute('form-control-name', controlName); } controlOptions.custom = true; if (controlOptions.controlType === 'group') { return new FormGroup(controlOptions); } return new FormControl(element, controlOptions.value || '', controlOptions); } _setUpControls() { const that = this; this._forEachChild(( (control)=>{ control.parent = that; that[control.name] = control; } )); } _forEachChild(cb) { const that = this; const keys = Object.keys(that.controls); for(let i = 0; i < keys.length; i++) { const controlKey = keys[i]; if (controlKey === '$') { continue; } const control = that.controls[controlKey]; cb(control, controlKey); } } _checkAllValuesPresent(value) { this._forEachChild(( (control,name)=>{ if (name !== '$' && value[name] === undefined && value[name] !== '') { throw new Error(`Must supply a value for form control with name: '${name}'.`); } } )); } get controls() { return this._controls; } setValue(value, options={emitEvent:false}) { const that = this; if (value === null) { this._forEachChild(( (control)=>{ control.value = null; } )); that.updateValueAndValidate(options); return; } that._checkAllValuesPresent(value); Object.keys(value).forEach(( name=>{ that._throwIfControlMissing(name); that.controls[name].setValue(value[name], { onlySelf: true, emitEvent: options.emitEvent }); } )); that.updateValueAndValidate(options); } _throwIfControlMissing(index) { if (!this.at(index)) { throw new Error(`Cannot find form control at index ${index}`); } } at(index) { return this.controls[index]; } patchValue(value, options={emitEvent: false}) { Object.keys(value).forEach(( name=>{ if (this.controls[name]) { this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: options.emitEvent }); } } )); this.updateValueAndValidate(options); } get root() { let x = this; while (x.parent) { x = x.parent; } return x; } _allControls(condition) { let result = true; this._forEachChild(( (control)=>{ result = result && control[condition]; } )); return result; } _anyControls(condition) { let result = false; this._forEachChild(( (control)=>{ result = result || control[condition]; } )); return result; } _updateValue() { this._value = this._reduceValue(); } _reduceValue() { return this._reduceChildren({}, ( (acc,control,name)=>{ if (control.enabled || this.disabled) { acc[name] = control.value; } return acc; } )); } _reduceChildren(initValue, fn) { let res = initValue; this._forEachChild(( (control,name)=>{ res = fn(res, control, name); } )); return res; } } class Form extends Control { constructor(selector, options) { super(); const that = this; that.element = document.querySelector(selector); if (!that.element) { that.element = document.createElement('div'); } that.element.classList.add('lw-form'); that.submitted = false; that.selector = selector; that.rootFormGroup = new FormGroup(options); that.rootFormGroup.parent = that; if (that.rootFormGroup.element && !that.element.contains(that.rootFormGroup.element)) { that.element.appendChild(that.rootFormGroup.element); } else { that.rootFormGroup.element = that.element; } let validationRules = []; // Validator const summary = document.createElement('div'); summary.classList.add('lw-form-row', 'lw-validation-summary'); summary.id = that.element.id + '_validationSummary'; that.summary = summary; that.rootFormGroup._forEachChild(( (control, controlName)=>{ that[controlName] = control; control.form = that; const setupControlRules = (control) => { const controlName = control.name; if (control.validationRules && control.validationRules.length > 0) { for(let i = 0; i < control.validationRules.length; i++) { const rule = control.validationRules[i]; const validationRule = rule; if (!rule.type) { rule.type = 'required'; } if (!rule.message) { rule.message = 'Invalid Input'; } rule.input = '#' + control.input.id; rule.action = 'keyup, blur, change'; validationRules.push(validationRule); } } else if (control.required){ const rule = {type: 'required', message: `${controlName} is required`, action: 'keyup, blur, change', input: '#' + control.input.id} validationRules.push(rule); } } setupControlRules(control); const loopThroughChildren = (control) => { control._forEachChild((control) => { control.form = that; setupControlRules(control); if (control instanceof FormGroup) { loopThroughChildren(control); } }) } if (control instanceof FormGroup) { loopThroughChildren(control); } } )); that.element.appendChild(summary); that.validator = new LW.Utilities.Validator(validationRules, '#' + summary.id); const isValid = that.validator.validate(); that.element.addEventListener('submit', (event) => { if (that.async) { event.preventDefault(); that.submit({async: true}) } }); that.rootFormGroup._onValueAndStatusUpdate = () => { if (that.rootFormGroup.status === 'invalid') { that._handleValidity(false); } else { that._handleValidity(true); } that.element.classList.remove('lw-valid'); that.element.classList.remove('lw-invalid'); that.element.classList.add('lw-' + that.rootFormGroup.status); } that._showSummary = options.showSummary !== undefined ? options.showSummary : true; that._readonly = options.readonly || false; that._async = options.async || false; that._showColonAfterLabel = options.showColonAfterLabel || false; if (window.LW.RenderMode === 'manual') { window.LW.Render(); } that._handleSummaryVisibility(); that._handleValidity(isValid); if (options.value) { that.value = options.value; } that._updateStatus(); if (document.readyState !== 'complete') { window.addEventListener('load', () => { that._handleSummaryVisibility(); that._handleValidity(isValid); that._updateStatus(); }); } } _updateStatus() { const that = this; that.rootFormGroup._forEachChild(( (control)=>{ const loopThroughChildren = (control) => { control._forEachChild((control) => { if (control instanceof FormGroup) { loopThroughChildren(control); } else { control.updateValueAndValidate(); } }) } if (control instanceof FormGroup) { loopThroughChildren(control); } else { control.updateValueAndValidate(); } } )); } getControl(controlName) { const that = this; let formControl = null; that.rootFormGroup._forEachChild(( (control)=>{ const loopThroughChildren = (control) => { control._forEachChild((control) => { if (control instanceof FormGroup) { loopThroughChildren(control); } if (control.name === controlName){ formControl = control; } }) } if (control.dataField === controlName){ formControl = control; } if (control instanceof FormGroup) { loopThroughChildren(control); } } )); return formControl; } _handleValidity(isValid) { const that = this; const submitButton = that.element.querySelector('[type="submit"]'); if (!submitButton) { return; } submitButton.disabled = !isValid; } get readonly() { return this._readonly; } set readonly(value) { const that = this; that._readonly = value; if (this.rootFormGroup) { this.rootFormGroup.readonly = value; } } get showColonAfterLabel() { return this._showColonAfterLabel; } set showColonAfterLabel(value) { const that = this; that._showColonAfterLabel = value; if (this.rootFormGroup) { this.rootFormGroup.showColonAfterLabel = value; } } get showSummary() { return this._showSummary; } set showSummary(value) { const that = this; that._showSummary = value; that._handleSummaryVisibility(); } get async() { return this._async; } set async(value) { this._async = value; } addControl(controlOptions) { if (this.rootFormGroup) { this.rootFormGroup.addControl(controlOptions); } } insertControl(index, controlOptions) { if (this.rootFormGroup) { this.rootFormGroup.insertControl(index, controlOptions); } } removeControl(controlName) { if (this.rootFormGroup) { this.rootFormGroup.removeControl(controlName); } delete this[controlName]; } _handleSummaryVisibility() { const that = this; if (!that.showSummary) { that.summary.classList.add('lw-hidden'); } else { that.summary.classList.remove('lw-hidden'); } } get status() { if (this.rootFormGroup) { this.rootFormGroup._calculateStatus(); } return this.rootFormGroup.status; } set status(value) { } get labelPosition() { if (this.rootFormGroup) { return this.rootFormGroup.labelPosition; } return 'top'; } set labelPosition(value) { if (this.rootFormGroup) { this.rootFormGroup.labelPosition = value; } } get columns() { if (this.rootFormGroup) { return this.rootFormGroup.columns; } return 1; } set columns(value) { if (this.rootFormGroup) { this.rootFormGroup.columns = value; } } get onValueChanges() { return this.rootFormGroup ? this.rootFormGroup.onValueChanges : null; } set onValueChanges(value) { if (this.rootFormGroup) { this.rootFormGroup.onValueChanges = value; } } get onStatusChanges() { return this.rootFormGroup ? this.rootFormGroup.onStatusChanges : null; } set onStatusChanges(value) { const that = this; if (this.rootFormGroup) { this.rootFormGroup.onStatusChanges = () => { value(that.state); }; } } get state() { const that = this; const status = {'form': that.status}; const state = {}; status.state = state; that.rootFormGroup._forEachChild(( (control, controlName)=>{ const loopThroughChildren = (control) => { control._forEachChild((control, controlName) => { if (control instanceof FormGroup) { loopThroughChildren(control); } else { status[controlName] = control.status; } }) } if (control instanceof FormGroup) { loopThroughChildren(control); } else { status[controlName] = control.status; state[controlName] = {dirty: control.dirty, untouched: control.untouched, disabled: control.disabled} } } )); return status; } get control() { return this.rootFormGroup; } get value() { return this.control.value; } set value(value) { const that = this; that.control.setValue(value); if (that.validator) { const isValid = that.validator.validate(); that._handleValidity(isValid); } } patchValue(value, options) { this.control.patchValue(value, options); } setValue(value) { this.value = value; } getValue() { return this.value; } validate() { const that = this; if (that.validator) { const isValid = that.validator.validate(); that._handleValidity(isValid); } } submit (config) { const that = this; if (!config) { config = {}; if (that.element.action) { config.action = that.element.action; } if (that.element.target) { config.target = that.element.target; } if (that.element.method) { config.method = that.element.method; } } const action = config.action; const target = config.target; const method = config.method; const async = config.async || that.async; if (!async) { if (that.element.nodeName === 'form') { that.element.submit(); } else { let html = '<form id=\'lw_formToSubmit\''; if (action) { html += ' action="' + action + '"'; } if (target) { html += ' target="' + target + '"'; } if (method && method.toString().toLowerCase() === 'get') html += ' method="GET"'; else html += ' method="POST"'; if (config.acceptCharset) { html += ' accept-charset="' + config.acceptCharset + '"'; } if (config.enctype) { html += ' enctype="' + config.enctype + '"'; } if (config.name) { html += ' name="' + config.name + '"'; } if (config.enctype) { html += ' id="' + config.id + '"'; } html += '>'; that.rootFormGroup._forEachChild(( (control, controlName)=>{ const loopThroughChildren = (control) => { control._forEachChild((control, controlName) => { if (control instanceof FormGroup) { loopThroughChildren(control); } else { html += '<input type="hidden" '; html += ' name="' + controlName + '"'; html += ' value="' + control.value + '"'; html += '>'; } }) } if (control instanceof FormGroup) { loopThroughChildren(control); } else { html += '<input type="hidden" '; html += ' name="' + controlName + '"'; html += ' value="' + control.value + '"'; html += '>'; } } )); html += '</form>'; const form = document.createElement('div'); form.innerHTML = html; that.element.appendChild(form); form.querySelector('#lw_formToSubmit').submit(); that.element.removeChild(form); } } else { const XHR = new XMLHttpRequest(), FD = new FormData(); that.rootFormGroup._forEachChild(( (control, controlName)=>{ const loopThroughChildren = (control) => { control._forEachChild((control, controlName) => { if (control instanceof FormGroup) { loopThroughChildren(control); } else { FD.append( controlName, control.value ); } }) } if (control instanceof FormGroup) { loopThroughChildren(control); } else { // Push our data into our FormData object FD.append( controlName, control.value ); } } )); // Define what happens on successful data submission XHR.addEventListener( 'load', function( event ) { // eslint-disable-next-line console.log(event.target.responseText); } ); // Define what happens in case of error XHR.addEventListener(' error', function( event ) { // eslint-disable-next-line console.log(event.target.responseText); } ); // Set up our request XHR.open( 'POST', action, true ); // Send our FormData object; HTTP headers are set automatically XHR.send( FD ); } this.submitted = true; } reset() { const that = this; that.submitted = false; that.value = null; } } const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/; // eslint-disable-next-line function isEmptyInputValue(value) { // we don't check for string here so it also works with arrays return value === null || value.length === 0; } class FormValidator { static null(control) { return control.value === null; } static email(control) { if (isEmptyInputValue(control.value)) { return null; // don't validate empty values to allow optional controls } return EMAIL_REGEXP.test(control.value) ? null : { 'email': true }; } static min(control, min) { return ( (control) => { if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) { return null; // don't validate empty values to allow optional controls } const value = parseFloat(control.value); // Controls with NaN values after parsing should be treated as not having a // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min return !isNaN(value) && value < min ? { 'min': { 'min': min, 'actual': control.value } } : null; }); } static max(control, max) { return ( (control) => { if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) { return null; // don't validate empty values to allow optional controls } const value = parseFloat(control.value); // Controls with NaN values after parsing should be treated as not having a // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max return !isNaN(value) && value > max ? { 'max': { 'max': max, 'actual': control.value } } : null; }); } static required(control) { return isEmptyInputValue(control.value) ? { 'required': true } : null; } static requiredTrue(control) { return control.value === true ? null : { 'required': true }; } static minLength(control, minLength) { return ( (control) => { if (isEmptyInputValue(control.value)) { return null; // don't validate empty values to allow optional controls } const length = control.value ? control.value.length : 0; return length < minLength ? { 'minlength': { 'requiredLength': minLength, 'actualLength': length } } : null; }); } static maxLength(control, maxLength) { return ( (control) => { const length = control.value ? control.value.length : 0; return length > maxLength ? { 'maxlength': { 'requiredLength': maxLength, 'actualLength': length } } : null; }); } static pattern(control, pattern) { if (!pattern) return FormValidator.null; let regex; let regexStr; if (typeof pattern === 'string') { regexStr = ''; if (pattern.charAt(0) !== '^') regexStr += '^'; regexStr += pattern; if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$'; regex = new RegExp(regexStr); } else { regexStr = pattern.toString(); regex = pattern; } return ( (control) => { if (isEmptyInputValue(control.value)) { return null; // don't validate empty values to allow optional controls } const value = control.value; return regex.test(value) ? null : { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } }; }); } } LW.Form = Form; LW.FormControl = FormControl; LW.FormGroup = FormGroup; LW.FormValidator = FormValidator; /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Button custom element. */ LW('lw-button', class Button extends LW.ContentElement { // Button's properties. static get properties() { return { 'value': { type: 'string' }, 'name': { type: 'string' }, 'type': { value: 'button', type: 'string' }, 'clickMode': { allowedValues: ['hover', 'press', 'release', 'pressAndRelease'], type: 'string', value: 'release' } }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.button.css' ] } /** Button's template. */ template() { return '<button class="lw-button lw-unselectable" inner-h-t-m-l=\'[[innerHTML]]\' id=\'button\' type=\'[[type]]\' name=\'[[name]]\' value=\'[[value]]\' disabled=\'[[disabled]]\' role="presentation"></button>'; } static get listeners() { return { 'button.down': '_downHandler', 'button.mouseenter': '_mouseEnterHandler', 'button.mouseleave': '_mouseLeaveHandler', 'button.touchend': '_touchEndHandler', 'button.click': '_clickHandler', 'button.up': '_upHandler', 'up': '_upHandler', 'button.focus': '_focusHandler', 'button.blur': '_blurHandler' }; } focus() { const that = this; if (!that.$.button) { HTMLElement.prototype.focus.call(that); return; } that.$.button.focus(); } blur() { const that = this; if (!that.$.button) { HTMLElement.prototype.blur.call(that); return; } that.$.button.blur(); } _upHandler(event) { const that = this; event.stopPropagation(); that.$.setAttributeValue('active', false); } _focusHandler() { const that = this; that.$.setAttributeValue('focus', true); that.$.fireEvent('focus'); } _blurHandler() { const that = this; that.$.setAttributeValue('focus', false); that.$.fireEvent('blur'); } _clickHandler(event) { const that = this; if ((that.clickMode !== 'release' && that.clickMode !== 'pressAndRelease') || that.readonly) { event.preventDefault(); event.stopPropagation(); } } _downHandler(event) { const that = this; if (that.disabled) { return; } //if (!that.enableShadowDOM) { // event.originalEvent.stopPropagation(); //} if (that.hasRippleAnimation) { LW.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY); } that.$.setAttributeValue('active', true); if ((that.clickMode === 'press' || that.clickMode === 'pressAndRelease') && !that.readonly) { const buttons = ('buttons' in event) ? event.buttons : event.which; that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY }); } } _mouseEnterHandler(event) { const that = this; if (that.readonly) { return; } that.$button.setAttributeValue('hover', true); that.$.setAttributeValue('hover', true); if (that.clickMode === 'hover') { const buttons = ('buttons' in event) ? event.buttons : event.which; that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY }); } } _touchEndHandler() { const that = this; setTimeout(function () { that.$button.setAttributeValue('hover', false); that.$.setAttributeValue('hover', false); }, 300); } _mouseLeaveHandler() { const that = this; that.$button.setAttributeValue('hover', false); that.$.setAttributeValue('hover', false); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (propertyName === 'disabled') { that._setFocusable(); if (that.$button) { that.$button.setAttributeValue('hover', false); } that.$.setAttributeValue('hover', false); if (that instanceof LW.RepeatButton) { that._stopRepeat(); } } else if (propertyName === 'unfocusable') { that._setFocusable(); } } /** * Sets tab index */ _setFocusable() { const that = this; const target = that.$.button ? that.$.button : that; if (that.disabled || that.unfocusable) { target.removeAttribute('tabindex'); target.tabIndex = -1; return; } target.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0; } ready() { const that = this; super.ready(); that.setAttribute('role', 'button'); that._setFocusable(); if (that.enableShadowDOM && that.$.hiddenInput) { that.appendChild(that.$.hiddenInput); } } }); /** * Repeat Button. */ LW('lw-repeat-button', class RepeatButton extends LW.Button { // button's properties. static get properties() { return { 'delay': { value: 50, type: 'number' }, 'initialDelay': { value: 150, type: 'number' } }; } static get listeners() { return { 'button.down': '_startRepeat', 'button.mouseenter': '_overriddenHandler', 'button.mouseleave': '_overriddenHandler', 'button.pointerenter': '_updateInBoundsFlag', 'button.pointerleave': '_updateInBoundsFlag', 'button.touchmove': '_touchmoveHandler', 'document.up': '_stopRepeat' }; } _clickHandler(event) { const that = this; if (that.clickMode !== 'release' || that.preventDefaultClick || that.readonly || that.disabled) { event.preventDefault(); event.stopPropagation(); that.preventDefaultClick = false; } } _updateInBoundsFlag(event) { const that = this; if (event.type.indexOf('leave') !== -1) { that._isPointerInBounds = false; that.$button.setAttributeValue('hover', false); that.$.setAttributeValue('hover', false); } else { that._isPointerInBounds = true; that.$button.setAttributeValue('hover', true); that.$.setAttributeValue('hover', true); } const buttons = ('buttons' in event) ? event.buttons : event.which; if (buttons !== 1) { that._stopRepeat(event); } } _startRepeat(event) { const that = this; that.setAttribute('active', ''); if (!that._initialTimer && !that.readonly) { that._initialTimer = setTimeout(function () { that._repeatTimer = setInterval(() => { if (that._isPointerInBounds) { const buttons = ('buttons' in event) ? event.buttons : event.which; that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY }); that.preventDefaultClick = true; } }, that.delay); }, that.initialDelay); } } _stopRepeat(event) { const that = this; if (that.readonly || event && (event.type === 'pointercancel' || event.originalEvent && event.originalEvent.type === 'pointercancel')) { return; } that.$.setAttributeValue('active', false); if (that._repeatTimer) { clearInterval(that._repeatTimer); that._repeatTimer = null; } if (that._initialTimer) { clearTimeout(that._initialTimer); that._initialTimer = null; } } _touchmoveHandler(event) { if (this.preventDefaultClick && event.cancelable) { event.preventDefault(); event.stopPropagation(); } } _overriddenHandler() { } }); /** * Toggle Button. */ LW('lw-toggle-button', class ToggleButton extends LW.Button { // Toggle Button's properties. static get properties() { return { 'checked': { value: false, type: 'boolean?' }, 'falseContent': { value: '', reflectToAttribute: false, type: 'string' }, 'indeterminateContent': { value: '', reflectToAttribute: false, type: 'string' }, 'indeterminate': { value: false, type: 'boolean' }, 'trueContent': { value: '', reflectToAttribute: false, type: 'string' }, 'indeterminateTemplate': { value: null, type: 'any' }, 'trueTemplate': { value: null, type: 'any' }, 'falseTemplate': { value: null, type: 'any' }, 'type': { value: 'toggle', type: 'string', defaultReflectToAttribute: true, readonly: true } }; } /** * Toggle Button's event listeners. */ static get listeners() { return { 'keydown': '_keyHandler', 'keyup': '_keyHandler', 'dragstart': '_dragStartHandler', 'button.click': '_buttonClickHandler', 'button.mouseenter': '_buttonMouseEnterHandler', 'button.mouseleave': '_buttonMouseLeaveHandler', 'document.up': '_documentUpHandler' }; } /** Called when the element is ready. Used for one-time configuration of the ToggleButton. */ ready() { super.ready(); this._setAriaState(); } /** * Sets WAI-ARIA state. */ _setAriaState() { const that = this, checked = that.checked; if (checked === null) { that.setAttribute('aria-pressed', 'mixed'); return; } that.setAttribute('aria-pressed', checked); } /** * Overrides the inherited "click" handler of the inner button element. */ _buttonClickHandler() { } _buttonMouseLeaveHandler() { const that = this; that.removeAttribute('hover'); } /** * Changes the check state on hover. */ _buttonMouseEnterHandler() { const that = this; that.setAttribute('hover', ''); if ((that.disabled) || (that.readonly) || (that.clickMode !== 'hover')) { return; } that._changeCheckState('pointer'); that.focus(); that._updateHidenInputNameAndValue(); } /** Changes the check state wneh widget container is clicked. */ _documentUpHandler(event) { const that = this; if (!that._pressed) { return; } that._pressed = false; if ((that.disabled) || (that.readonly) || (that.clickMode === 'press') || event.originalEvent.type === 'pointercancel') { return; } that._changeCheckState('pointer'); that.focus(); that._updateHidenInputNameAndValue(); } _downHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } if (that.hasRippleAnimation) { LW.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY); } that._pressed = true; if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') { that._changeCheckState('pointer'); that.$.fireEvent('click'); that._updateHidenInputNameAndValue(); } if (that.clickMode === 'press') { event.preventDefault(); event.stopPropagation(); } } _dragStartHandler(event) { event.preventDefault(); } /** Changes the check state when spacebar is pressed. */ _keyHandler(event) { const that = this; if ((that.disabled !== true) && !that.readonly && (event.keyCode === 32)) { if (event.type === 'keydown') { event.preventDefault(); return; } if (that.switchMode === 'none') { return; } that._changeCheckState('keyboard'); that._updateHidenInputNameAndValue(); } } /** Changes the check state. */ _changeCheckState(changeType) { const that = this; let oldValue = null; if (that.checked === null) { that.checked = true; } else { oldValue = that.checked; that.checked = !that.checked; } that._handleTextSelection(); that.$.fireEvent('change', { 'value': that.checked, 'oldValue': oldValue, changeType: changeType }); that._setAriaState(); } _handleTextSelection() { const that = this; that.$.addClass('lw-unselectable'); if (that.timer) { clearTimeout(that.timer); } that.timer = setTimeout(() => that.$.removeClass('lw-unselectable'), 500); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (propertyName === 'checked') { that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, changeType: 'api' }); that._setAriaState(); return; } switch (propertyName) { case 'trueTemplate': that._handleTemplate(true); break; case 'falseTemplate': that._handleTemplate(false); break; case 'indeterminateTemplate': that._handleTemplate(); break; } } _htmlBindOnInitialization() { const that = this; that._bindContentProperty('trueContent', 'lw-true-content'); that._bindContentProperty('falseContent', 'lw-false-content'); that._bindContentProperty('indeterminateContent', 'lw-indeterminate-content'); } _bindContentProperty(propertyName, className) { const that = this; if (!that.$[propertyName + 'Container']) { return; } let testElement = document.createElement('div'); testElement.innerHTML = that.innerHTML; let elements = testElement.getElementsByClassName(className), element; if (elements.length > 0) { for (let i = 0; i < elements.length; i++) { element = elements[i]; } } if (that[propertyName] === '') { that[propertyName] = element === undefined ? '' : element.outerHTML; } that.$[propertyName + 'Container'].innerHTML = that[propertyName]; } _updateContentProperties() { const that = this; update('trueContent'); update('falseContent'); update('indeterminateContent'); function update(property) { if (that.$[property + 'Container']) { that[property] = that.$[property + 'Container'].innerHTML; } } } _updateHidenInputValue() { const that = this; if (!that.$.hiddenInput) { return; } let inputValue; if (that.checked === null) { inputValue = 'null'; } else if (that.checked === false) { inputValue = 'off'; } else { inputValue = that.value || 'on'; } that.$.hiddenInput.setAttribute('value', inputValue); } _updateHidenInputName() { const that = this; if (!that.$.hiddenInput) { return; } let inputName = that.checked === false ? '' : that.name || ''; that.$.hiddenInput.setAttribute('name', inputName); } _updateHidenInputNameAndValue() { const that = this; that._updateHidenInputName(); that._updateHidenInputValue(); } /** * Apply a template to true/false/indeterminate states of the elements. */ _handleTemplate(state, oldValue) { const that = this; let template, templateTarget, value; if (state === true) { template = that.trueTemplate; templateTarget = that.$.trueContentContainer; value = that.trueContent; } else if (state === false) { template = that.falseTemplate; templateTarget = that.$.falseContentContainer; value = that.falseContent; } else { template = that.indeterminateTemplate; templateTarget = that.$.indeterminateContentContainer; value = that.indeterminateContent; } if (oldValue) { templateTarget.innerHTML = value ? value : ''; } if (template === null || !template) { return; } if (typeof template === 'function') { template(templateTarget, { value: value }); return; } if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } template = document.getElementById(template); if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' })); return; } const content = template.content, childrenCount = content.childNodes.length, regex = /{{\w+}}/g; let bindingString, bindingDetails = []; for (let i = 0; i < childrenCount; i++) { bindingString = regex.exec(content.childNodes[i].innerHTML); while (bindingString) { bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] }); bindingString = regex.exec(content.childNodes[i].innerHTML); } } const bindingsCount = bindingDetails.length; let clone = document.importNode(template.content, true), bindingHolderElement, bindingStringsCount; for (let b = 0; b < bindingsCount; b++) { bindingHolderElement = clone.childNodes[bindingDetails[b].childNodeIndex]; bindingStringsCount = bindingDetails.length; for (let i = 0; i < bindingStringsCount; i++) { bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(bindingDetails[b].bindingString, value); } } templateTarget.innerHTML = ''; for (let i = 0; i < clone.childNodes.length; i++) { if (clone.childNodes[i].outerHTML) { templateTarget.innerHTML += clone.childNodes[i].outerHTML; } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * CheckBox custom element. */ LW('lw-check-box', class CheckBox extends LW.ToggleButton { // CheckBox's properties. static get properties() { return { 'checkMode': { value: 'both', allowedValues: ['both', 'input', 'label'], type: 'string' }, 'type': { value: 'checkbox', type: 'string', defaultReflectToAttribute: true, readonly: true } }; } /** CheckBox's Html template. */ template() { return `<div id='container' class='lw-container' role="presentation"> <div class='lw-overlay' role="presentation"></div> <span id='checkBoxInput' class='lw-input' aria-hidden="true"></span> <span id='checkBoxLabel' inner-h-t-m-l='[[innerHTML]]' class='lw-label'><content></content></span> <input id='hiddenInput' class='lw-hidden-input' type='hidden'> </div>`; } static get listeners() { return { 'down': '_downHandler', 'document.up': '_documentUpHandler', 'checkBoxInput.mouseenter': '_mouseEnterHandler', 'checkBoxInput.mouseleave': '_mouseLeaveHandler', 'focus': '_focusHandler', 'blur': '_blurHandler' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.toggle.css' ] } _focusHandler() { const that = this; that.$.setAttributeValue('focus', true); } _blurHandler() { const that = this; that.$.setAttributeValue('focus', false); } _mouseEnterHandler() { const that = this; that.$.setAttributeValue('hover', true); } _mouseLeaveHandler() { const that = this; that.$.setAttributeValue('hover', false); } /** Called when the element is ready. Used for one-time configuration of the CheckBox. */ ready() { const that = this; super.ready(); that.setAttribute('role', 'checkbox'); if (that.indeterminate) { that._valueCache = that.checked; that.checked = null; that._setAriaState(); } that.classList.add('lw-toggle-box'); that._updateHidenInputNameAndValue(); } /** * Updates CheckBox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; that._updateContentProperties(); switch (propertyName) { case 'indeterminate': if (newValue) { that._valueCache = that.checked; that.checked = null; } else { that.checked = that._valueCache; } that._setAriaState(); that._updateHidenInputNameAndValue(); break; case 'value': that._updateHidenInputNameAndValue(); break; case 'checked': that._updateHidenInputNameAndValue(); break; case 'name': that._updateHidenInputName(); break; } } /** Changes the check state on click. */ _documentUpHandler(event) { const that = this; if (!that._pressed || event.originalEvent.type === 'pointercancel') { return; } const target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; that._pressed = false; that.$.setAttributeValue('active', false); if (that.disabled || that.readonly || that.checkMode === 'input' && target !== that.$.checkBoxInput || that.checkMode === 'label' && target !== that.$.checkBoxLabel) { return; } if (that.clickMode === 'press') { event.preventDefault(); event.stopPropagation(); return; } that._changeCheckState('pointer'); that.focus(); that._handleTextSelection(); that._updateHidenInputNameAndValue(); } /** Changes the check state on mouse down. */ _downHandler(event) { const that = this, target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.disabled || that.readonly || that.checkMode === 'input' && target !== that.$.checkBoxInput || that.checkMode === 'label' && target !== that.$.checkBoxLabel) { return; } that.$.setAttributeValue('active', true); if (that.hasRippleAnimation) { const rect = that.$.checkBoxInput.getBoundingClientRect(), windowScrollX = window.scrollX || window.pageXOffset, windowScrollY = window.scrollY || window.pageYOffset; LW.Utilities.Animation.Ripple.animate(that.$.checkBoxInput, rect.left + rect.width / 2 + windowScrollX, rect.top + rect.height / 2 + windowScrollY); } that._pressed = true; if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') { that._changeCheckState('pointer'); that.$.fireEvent('click'); that.focus(); that._updateHidenInputNameAndValue(); } } /** * Sets WAI-ARIA state. */ _setAriaState() { const that = this, checked = that.checked; if (checked === null) { that.setAttribute('aria-checked', 'mixed'); return; } that.setAttribute('aria-checked', checked); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * LED custom element. */ LW('lw-led', class Led extends LW.ToggleButton { // LED's properties. static get properties() { return { 'shape': { value: 'round', allowedValues: ['round', 'square'], type: 'string' } }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.led.css' ] } /** LED's Html template. */ template() { return `<div id='container' class='lw-container' role="presentation"> <div id='ledAnimation' class='lw-animation' role="presentation"></div> <div id='button' class='lw-input' role="presentation"> <span id='falseContentContainer' inner-h-t-m-l='[[falseContent]]' class='lw-false-content-container'></span> <span id='indeterminateContentContainer' inner-h-t-m-l='[[indeterminateContent]]' class='lw-indeterminate-content-container'></span> <span id='trueContentContainer' inner-h-t-m-l='[[trueContent]]' class='lw-true-content-container'></span> </div> <input id='hiddenInput' class='lw-hidden-input' type='hidden'> </div>`; } /** Called when the element is ready. Used for one-time configuration of the Switch Button. */ ready() { const that = this; super.ready(); that._htmlBindOnInitialization(); if (that.indeterminate) { that._valueCashe = that.checked; that.checked = null; } that._handleTemplate(true); that._handleTemplate(false); that._handleTemplate(); that._updateHidenInputNameAndValue(); } /** * Updates the LED when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'indeterminate': if (newValue) { that._valueCashe = that.checked; that.checked = null; } else { that.checked = that._valueCashe; } that._updateHidenInputNameAndValue(); break; case 'trueContent': that.trueContent = newValue; that._handleTemplate(true); break; case 'falseContent': that.falseContent = newValue; that._handleTemplate(false); break; case 'indeterminateContent': that.indeterminateContent = newValue; that._handleTemplate(); break; case 'value': that._updateHidenInputNameAndValue(); break; case 'checked': that._updateHidenInputNameAndValue(); break; case 'name': that._updateHidenInputName(); break; } } /** Changes the state wneh widget is clicked. */ _documentUpHandler(event) { const that = this; if (!that._pressed || that.readonly) { return; } if (that.clickMode === 'press') { event.preventDefault(); event.stopPropagation(); that._pressed = false; return; } super._documentUpHandler(event); that.indeterminate = false; that._updateHidenInputNameAndValue(); that._pressed = false; } _mouseDownHandler() { const that = this; if (that.readonly || that.disabled) { return; } that._pressed = true; if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') { that._changeCheckState('pointer'); that.$.fireEvent('click'); that.indeterminate = false; that._updateHidenInputNameAndValue(); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Power Button custom element. */ LW('lw-power-button', class PowerButton extends LW.ToggleButton { /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.powerbutton.css' ] } /** PowerButton's Html template. */ template() { return `<div id='container' class='lw-container'> <div id='powerButtonAnimation' class='lw-animation'></div> <span id='button' class='lw-input' aria-hidden="true"></span> <input id='hiddenInput' class='lw-hidden-input' type='hidden'> </div>`; } /** Called when the element is ready. Used for one-time configuration of the PowerButton. */ ready() { const that = this; super.ready(); that._updateHidenInputNameAndValue(); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * RadioButton custom element. */ LW('lw-radio-button', class RadioButton extends LW.ToggleButton { // RadioButton's properties. static get properties() { return { 'checkMode': { value: 'both', allowedValues: ['both', 'input', 'label'], type: 'string' }, 'type': { value: 'radio', type: 'string', defaultReflectToAttribute: true, readonly: true }, 'groupName': { value: '', type: 'string' } }; } /** RadioButton's Html template. */ template() { return `<div id='container' class='lw-container'> <div class ='lw-overlay'></div> <span id='radioButtonInput' class ='lw-input'></span> <span id='radioButtonLabel' inner-h-t-m-l='[[innerHTML]]' class ='lw-label'><content></content></span> <input id='hiddenInput' class ='lw-hidden-input' type='hidden'> </div>`; } static get listeners() { return { 'down': '_downHandler', 'document.up': '_documentUpHandler', 'mouseenter': '_elementMouseEnterHandler', 'radioButtonInput.mouseenter': '_radioMouseEnterHandler', 'radioButtonInput.mouseleave': '_radioMouseLeaveHandler', 'focus': '_focusHandler', 'blur': '_blurHandler' }; } static get styleUrls() { return [ 'lw.toggle.css' ] } _radioMouseEnterHandler() { const that = this; that.$.setAttributeValue('hover', true); } _radioMouseLeaveHandler() { const that = this; that.$.setAttributeValue('hover', false); } _focusHandler() { const that = this; that.$.setAttributeValue('focus', true); } _blurHandler() { const that = this; that.$.setAttributeValue('focus', false); } _mouseEnterHandler() { const that = this; that.$.setAttributeValue('hover', true); } _mouseLeaveHandler() { const that = this; that.$.setAttributeValue('hover', false); } /** Called when the element is ready. Used for one-time configuration of the RadioButton. */ ready() { const that = this; super.ready(); that.classList.add('lw-toggle-box'); that._handleMultipleCheckedInstances(); that._updateHidenInputNameAndValue(); } /** * Radio button down handler. */ _downHandler(event) { const that = this, target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.disabled || that.readonly || that.checkMode === 'input' && target !== that.$.radioButtonInput || that.checkMode === 'label' && target !== that.$.radioButtonLabel) { return; } that.$.setAttributeValue('active', true); if (that.hasRippleAnimation) { const rect = that.$.radioButtonInput.getBoundingClientRect(), windowScrollX = window.scrollX || window.pageXOffset, windowScrollY = window.scrollY || window.pageYOffset; LW.Utilities.Animation.Ripple.animate(that.$.radioButtonInput, rect.left + rect.width / 2 + windowScrollX, rect.top + rect.height / 2 + windowScrollY); } if (that._preventAction) { that._preventAction = false; return; } if (that.clickMode === 'release' || that.clickMode === 'pressAndRelease') { that._pressed = true; } if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') { if (that.clickMode === 'pressAndRelease') { if (that.groupName === '') { that._checkedBeforeChange = that.parentNode.querySelector('lw-radio-button[checked]'); } else { that._checkedBeforeChange = document.querySelector('lw-radio-button[group-name="' + that.groupName + '"][checked]'); } } that._handleMouseInteraction(); } } /** * Radio button mouseenter handler. */ _elementMouseEnterHandler() { const that = this; if (that.clickMode === 'hover' && !that.disabled && !that.readonly) { that._handleMouseInteraction(); } } /** * Document up handler. */ _documentUpHandler(event) { const that = this, target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (!that._pressed || that.disabled || that.readonly || that.checkMode === 'input' && target !== that.$.radioButtonInput || that.checkMode === 'label' && target !== that.$.radioButtonLabel || event.originalEvent.type === 'pointercancel') { return; } if (that.clickMode === 'release') { that._handleMouseInteraction(); } else { // clickMode: 'pressAndRelease' if (that._checkedBeforeChange === null) { that.$.fireEvent('change', { 'value': false, 'oldValue': true, 'changeType': 'pointer' }); that.checked = false; } else { that._checkedBeforeChange._changeCheckState('pointer'); } that.focus(); that._updateHidenInputNameAndValue(); } that.$.setAttributeValue('active', false); that._pressed = false; } /** * Handles interaction with the mouse. */ _handleMouseInteraction() { const that = this; that._handleTextSelection(); that._changeCheckState('pointer'); that.focus(); that._updateHidenInputNameAndValue(); } /** * Reduce checked items in group to 1(latest selected item) */ _handleMultipleCheckedInstances() { const that = this, checkedRadioButtons = Array.from(document.querySelectorAll('lw-radio-button[group-name="' + that.groupName + '"][checked]')), checkedUIRadioButtons = Array.from(document.querySelectorAll('lw-ui-radio-button[group-name="' + that.groupName + '"][checked]')), count = checkedRadioButtons.length + checkedUIRadioButtons.length; if (count < 2) { return; } const items = checkedRadioButtons.concat(...checkedUIRadioButtons); items.forEach((item, i) => (i < (count - 1)) && (item.checked = false)); } /** Changes the check state. */ _changeCheckState(changeType) { const that = this; let radioButtonsGroup = document.querySelectorAll('lw-radio-button[group-name="' + that.groupName + '"]'); let radioUIButtonsGroup = document.querySelectorAll('lw-ui-radio-button[group-name="' + that.groupName + '"]'); let buttons = Array.from(radioButtonsGroup).concat(...radioUIButtonsGroup); if ((that.checked === true && changeType === 'api') || (that.checked === false)) { if (buttons.length > 0) { that._changeCheckStateInGroup(buttons, changeType); } else { let parent = that.parentNode; if (that.getRootNode().host) { parent = that.getRootNode().host.parentNode; radioButtonsGroup = parent.querySelectorAll('lw-radio-button:not([group-name])'); radioUIButtonsGroup = parent.querySelectorAll('lw-ui-radio-button:not([group-name])'); buttons = Array.from(radioButtonsGroup).concat(...radioUIButtonsGroup); } else { buttons = parent.querySelectorAll('lw-radio-button:not([group-name])'); } that._changeCheckStateInGroup(buttons, changeType); } } } /** Changes the check states in group of radio buttons. */ _changeCheckStateInGroup(elements, changeType) { const that = this; const button = that.getRootNode().host ? that.getRootNode().host : that; for (let i = 0; i < elements.length; i++) { elements[i]._isUpdating = true; if (elements[i] === button) { button.checked = true; if (button.nativeElement) { button.nativeElement.$.fireEvent('change', { 'value': true, 'oldValue': false, 'changeType': changeType }); } else { button.$.fireEvent('change', { 'value': true, 'oldValue': false, 'changeType': changeType }); } } else if (elements[i].checked) { elements[i].checked = false; } elements[i]._isUpdating = false; } } /** * Updates the radio button/radio group when checked property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'value': that._updateHidenInputNameAndValue(); break; case 'checked': if (!that._isUpdating) { that._changeCheckState('api'); } that._updateHidenInputNameAndValue(); break; case 'name': that._updateHidenInputName(); break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Switch Button custom element. */ LW('lw-switch-button', class SwitchButton extends LW.ToggleButton { // Switch Button's properties. static get properties() { return { 'inverted': { value: false, type: 'boolean' }, 'orientation': { value: 'horizontal', allowedValues: ['horizontal', 'vertical'], type: 'string' }, 'switchMode': { value: 'default', allowedValues: ['default', 'click', 'drag', 'none'], type: 'string' }, 'clickMode': { value: 'release', allowedValues: ['press', 'release', 'pressAndRelease'], type: 'string' } }; } /** * Switch Button's event listeners. */ static get listeners() { return { 'container.down': '_mouseDownHandler', 'document.move': '_drag', 'container.move': '_moveHandler', 'document.up': '_switchThumbDropHandler', 'mouseenter': '_switchButtonOnMouseEnter', 'mouseleave': '_switchButtonOnMouseLeave', 'resize': '_resizeHandler', 'container.resize': '_resizeHandler', 'document.selectstart': '_selectStartHandler' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.switchbutton.css' ] } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); that._updateContentProperties(); switch (propertyName) { case 'indeterminate': if (newValue) { that._valueCache = that.checked; that.checked = null; } else { that.checked = that._valueCache; } that._setAriaState(); break; case 'trueContent': that.trueContent = newValue; break; case 'falseContent': that.falseContent = newValue; break; case 'orientation': that._resizeHandler(); break; } that._getContainersSizeAndBreakPoint(); that._removeDragStyles(); that._resizeHandler(); } /** Switch Button's Html template. */ template() { return `<div id='container' class='lw-container' role="presentation"> <div id='innerContainer' class='lw-inner-container' role="presentation"> <span id='falseContentContainer' inner-h-t-m-l='[[falseContent]]' class='lw-false-content-container'></span> <span id='switchThumb' class='lw-thumb' role="presentation"></span> <span id='trueContentContainer' inner-h-t-m-l='[[trueContent]]' class='lw-true-content-container'></span> </div> <input id='hiddenInput' class='lw-hidden-input' type='hidden'> </div>`; } /** Called when the element is ready. Used for one-time configuration of the Switch Button. */ ready() { const that = this; super.ready(); that.setAttribute('role', 'switch'); let animationType = that.animation; if (that.hasAnimation) { that.animation = 'none'; } that._supportCSSVariables = LW.Utilities.Core.CSSVariablesSupport() && Boolean(window.getComputedStyle(that.$.container).getPropertyValue('--lw-switch-button-default-width')); that._htmlBindOnInitialization(); that._resizeHandler(); that._initializePrivateVariables(); that._getContainersSizeAndBreakPoint(); if (that.indeterminate) { that._valueCache = that.checked; that.checked = null; } that._setAriaState(); that._handleTemplate(true); //Set the True Content that._handleTemplate(false); //Set the False Content that._handleTemplate(); // Set the Indeterminate Content that._updateHidenInputNameAndValue(); that._updateThumbPosition(); that.animation = animationType; } /** Changes the check state and fires event on mouse up. */ _mouseDownHandler(event) { const that = this; if (that.disabled || that.readonly || that.switchMode === 'none') { return; } if (event.originalEvent.target.closest('.lw-thumb') === that.$.switchThumb && (that.switchMode === 'default' || that.switchMode === 'drag')) { that._switchThumbDragStartHandler(event); } that._isSwitchClicked = that; that._updateContentProperties(); if ((that.clickMode !== 'release') && (that.switchMode === 'click')) { that._updateStateOnClick(); that.$.fireEvent('click'); that.indeterminate = false; that._updateHidenInputNameAndValue(); } } /** Changes the check state and updates CSS variables */ _updateStateOnClick() { const that = this; that._changeCheckState(); that.focus(); } _drag(event) { const that = this; if (!that._mouseDown) { return; } if (LW.Utilities.Core.isMobile) { event.originalEvent.preventDefault(); } that._switchThumbDragHandler(event); } /** Changes the check state wneh widget's thumb is dragged. */ _switchThumbDragStartHandler(event) { const that = this; if (that.disabled) { return; } if ((that.switchMode === 'click') && (that.clickMode !== 'release')) { event.preventDefault(); event.stopPropagation(); } if (that._isInactiveOn('drag')) { return; } that._mouseDown = true; that._getContainersSizeAndBreakPoint(); that._pointerPosition = (that.orientation === 'vertical' ? event.pageY : event.pageX); event.preventDefault(); } _selectStartHandler(event) { const that = this; if (that._mouseDown) { event.preventDefault(); } } /** Changes the check state wneh widget's thumb is dragged. */ _switchThumbDragHandler(event) { const that = this; if (that._isInactiveOn('drag')) { return; } if (that._mouseDown === false) { that._removeDragStyles(); return; } if (!that.hasAttribute('dragged')) { if (Math.abs((that.orientation === 'vertical' ? event.pageY : event.pageX) - that._pointerPosition) <= 1.5) { return; } that.setAttribute('dragged', ''); } //delete that._isSwitchClicked; let innerContainer = that.$.innerContainer, offset = that.$.container.getBoundingClientRect(), scrollDistance = that.orientation === 'vertical' ? (document.body.scrollTop || document.documentElement.scrollTop) : (document.body.scrollLeft || document.documentElement.scrollLeft), containerOffset = that.orientation === 'vertical' ? offset.top + scrollDistance : offset.left + scrollDistance, diff = that.orientation === 'vertical' ? (that._pointerPosition - innerContainer.offsetTop) : (that._pointerPosition - innerContainer.offsetLeft), pointerInRange = (that._pointerPosition >= containerOffset && that._pointerPosition <= containerOffset + that._switchContainerSize); const maxLeft = -1 * (that.offsetWidth - that.$.switchThumb.offsetWidth), maxTop = -1 * (that.offsetHeight - that.$.switchThumb.offsetHeight); that._pointerPosition = that.orientation === 'vertical' ? event.pageY : event.pageX; if (pointerInRange) { let currentPosition = that._pointerPosition - diff; if (currentPosition < -that._switchTrackLength) currentPosition = -that._switchTrackLength; if (currentPosition > 0) currentPosition = 0; that.orientation === 'vertical' ? (that.$.innerContainer.style.top = Math.max(maxTop, currentPosition) + 'px') : (that.$.innerContainer.style.left = Math.max(maxLeft, currentPosition) + 'px'); } } /** Document Up Event Handler */ _switchThumbDropHandler() { const that = this; if (that.hasAttribute('dragged')) { that._endDrag(); } else if (that._isSwitchClicked) { that._endClick(); } that._mouseDown = false; delete that._isSwitchClicked; } /** * Ends the dragging operation */ _endDrag() { const that = this, isInverted = that.inverted && !that.rightToLeft || !that.inverted && that.rightToLeft; that.indeterminate = false; that._updateHidenInputNameAndValue(); if (that._isInactiveOn('drag') || !that._mouseDown) { return; } that.removeAttribute('dragged'); delete that._pointerPosition; let switchOnPosition = (that.orientation === 'vertical' ? (that.$.innerContainer.offsetTop + that.$.switchThumb.offsetTop + that.$.switchThumb.clientHeight / 2) : (that.$.innerContainer.offsetLeft + that.$.switchThumb.offsetLeft + that.$.switchThumb.clientWidth / 2)); const switchAfterBreakPoint = switchOnPosition > that._switchBreakPoint; if (that.checked !== null) { if (!isInverted === (switchAfterBreakPoint === that.checked)) { that._changeCheckState(!that.checked); } } else { switchAfterBreakPoint ? that._changeCheckState(isInverted) : that._changeCheckState(!isInverted); } that._removeDragStyles(); that._updateThumbPosition(); } /** * Ends the click operation */ _endClick() { const that = this; //Click Handler that._resizeHandler(); if (that.disabled || that.readonly) { return; } if (that._isInactiveOn('click')) { return; } if (that.clickMode !== 'release' && that.clickMode !== 'pressAndRelease') { //event.preventDefault(); //event.stopPropagation(); } else { that._updateStateOnClick(); } that.indeterminate = false; that._updateHidenInputNameAndValue(); } /** * Switch button onMouseEnter event handler. **/ _switchButtonOnMouseEnter() { const that = this; if (that.disabled || that.readonly) { return; } that.$.addClass('hovered'); } /** * Switch button onMouseLeave event handler. **/ _switchButtonOnMouseLeave() { const that = this; if (that.disabled || that.readonly) { return; } that.$.removeClass('hovered'); } /** Checks is handler active in particular switch mode. */ _isInactiveOn(switchMode) { const that = this, isInactive = ((that.disabled) || that.readonly || (that.switchMode !== switchMode)); if (that.switchMode === 'default') { return false; } return isInactive; } /** Changes the check state wneh spacebar is pressed. */ _keyUpHandler(event) { const that = this; if (that.disabled || that.readonly || (event.keyCode !== 32) || that.switchMode === 'none') { return; } that._getContainersSizeAndBreakPoint(); that._changeCheckState(); } /** Initializes private variables. */ _initializePrivateVariables() { const that = this; that._switchContainerSize = that._switchTrackLength = that._switchBreakPoint = that._pointerPosition = 0; that._mouseDown = false; } /** Changes the check state. */ _changeCheckState(optionalValue) { const that = this; let oldValue = that.checked; if ((oldValue === null) && (optionalValue !== undefined)) { that.$.fireEvent('change', { 'value': optionalValue, 'oldValue': null }); that.checked = optionalValue; that._updateThumbPosition(); return; } if (that.checked === null) { that.checked = true; } else { that.checked = !that.checked; } that._setAriaState(); that._updateThumbPosition(); that.$.fireEvent('change', { 'value': that.checked, 'oldValue': oldValue }); that._updateHidenInputNameAndValue(); } /** * Get the actual width of the Switch Button and Switch Button's breakpoint. */ _getContainersSizeAndBreakPoint() { const that = this; that._switchContainerSize = (that.orientation === 'vertical' ? that.$.container.clientHeight : that.$.container.clientWidth); that._switchTrackLength = (that.orientation === 'vertical' ? (that._switchContainerSize - that.$.switchThumb.clientHeight) : (that._switchContainerSize - that.$.switchThumb.clientWidth)); that._switchBreakPoint = that._switchContainerSize / 2; } /** * Remove styles, related to absolute positioning of the thumb when it's dragged */ _removeDragStyles() { const that = this; that._supportCSSVariables ? that.$.innerContainer.removeAttribute('style') : that.$.innerContainer.style.left = ''; that._supportCSSVariables ? that.$.innerContainer.removeAttribute('style') : that.$.innerContainer.style.top = ''; that._mouseDown = false; } /** * Element mousemove event handler. */ _moveHandler(event) { if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** Resize handler **/ _resizeHandler() { const that = this; if (!document.body.contains(that)) { return; } const computedStyles = window.getComputedStyle(that, null), borderTopWidth = parseInt(computedStyles.getPropertyValue('border-top-width')), borderRightWidth = parseInt(computedStyles.getPropertyValue('border-right-width')), borderBottomWidth = parseInt(computedStyles.getPropertyValue('border-bottom-width')), borderLeftWidth = parseInt(computedStyles.getPropertyValue('border-left-width')), newWidth = that.orientation === 'vertical' ? (that.offsetHeight - (borderTopWidth + borderBottomWidth)) : (that.offsetWidth - (borderLeftWidth + borderRightWidth)); that._getContainersSizeAndBreakPoint(); if (that._supportCSSVariables) { that.$.container.style.setProperty('--lw-switch-button-default-width', newWidth + 'px'); } else { that._innerContainerSize = newWidth; that.$.innerContainer.style.height = that.$.innerContainer.style.width = ''; that.$.trueContentContainer.style.height = that.$.trueContentContainer.style.width = ''; that.$.falseContentContainer.style.height = that.$.falseContentContainer.style.width = ''; if (that.orientation === 'horizontal') { that.$.innerContainer.style.setProperty('width', (2 * newWidth - that.$.switchThumb.clientWidth) + 'px'); that.$.trueContentContainer.style.setProperty('width', that._switchTrackLength + 'px'); that.$.falseContentContainer.style.setProperty('width', that._switchTrackLength + 'px'); } else { that.$.innerContainer.style.setProperty('height', (2 * newWidth - that.$.switchThumb.clientHeight) + 'px'); that.$.trueContentContainer.style.setProperty('height', that._switchTrackLength + 'px'); that.$.falseContentContainer.style.setProperty('height', that._switchTrackLength + 'px'); } that._updateThumbPosition(); } } /** * Updates the thumb position when the browser doesn't support CSS variables */ _updateThumbPosition() { const that = this, isInverted = that.inverted && !that.rightToLeft || !that.inverted && that.rightToLeft; if (that._supportCSSVariables || (isInverted ? that.checked === true : that.checked === false) || !that._innerContainerSize) { that.$.innerContainer.style.left = that.$.innerContainer.style.top = ''; return; } if (isInverted ? that.checked === false : that.checked) { if (that.orientation === 'horizontal') { that.$.innerContainer.style.left = (-1 * (that._innerContainerSize - that.$.switchThumb.offsetWidth)) + 'px'; that.$.innerContainer.style.top = ''; } else { that.$.innerContainer.style.top = (-1 * (that._innerContainerSize - that.$.switchThumb.offsetHeight)) + 'px'; that.$.innerContainer.style.left = ''; } } if (that.checked === null) { if (that.orientation === 'horizontal') { that.$.innerContainer.style.left = (-1 * (that._innerContainerSize / 2 - that.$.switchThumb.offsetWidth / 2)) + 'px'; that.$.innerContainer.style.top = ''; } else { that.$.innerContainer.style.top = (-1 * (that._innerContainerSize / 2 - that.$.switchThumb.offsetHeight / 2)) + 'px'; that.$.innerContainer.style.left = ''; } } } /** * Sets WAI-ARIA state. */ _setAriaState() { const that = this, checked = !!that.checked; that.setAttribute('aria-checked', checked); if (checked) { that.$.falseContentContainer.setAttribute('aria-hidden', true); that.$.trueContentContainer.removeAttribute('aria-hidden'); } else { that.$.trueContentContainer.setAttribute('aria-hidden', true); that.$.falseContentContainer.removeAttribute('aria-hidden'); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Chart custom element. */ LW('lw-chart', class Chart extends LW.BaseElement { /** * Chart's properties. */ static get properties() { return { 'animationDuration': { value: 300, type: 'number' }, 'backgroundColor': { value: null, type: 'string?' }, 'backgroundImage': { value: '', type: 'string' }, 'borderLineColor': { value: null, type: 'string?' }, 'borderLineWidth': { value: 1, type: 'number' }, 'caption': { value: 'Caption', type: 'string' }, 'clip': { value: true, type: 'boolean' }, 'colorScheme': { value: 'scheme01', type: 'string' }, 'columnSeriesOverlap': { value: false, type: 'boolean' }, 'crosshairsColor': { value: null, type: 'string?' }, 'crosshairsDashStyle': { value: '2,2', type: 'string' }, 'crosshairsLineWidth': { value: 1, type: 'number' }, 'dataSource': { value: [], type: 'object', reflectToAttribute: false }, 'description': { value: 'Description', type: 'string' }, 'draw': { value: null, type: 'function?' }, 'drawBefore': { value: null, type: 'function?' }, 'enableAxisTextAnimation': { value: false, type: 'boolean' }, 'enableCrosshairs': { value: false, type: 'boolean' }, 'greyScale': { value: false, type: 'boolean' }, 'legendLayout': { value: { 'flow': { value: 'horizontal', allowedValues: ['horizontal', 'vertical'], type: 'string' }, 'height': { value: null, type: 'number?' }, 'left': { value: null, type: 'number?' }, 'top': { value: null, type: 'number?' }, 'width': { value: null, type: 'number?' } }, type: 'object?' }, 'localization': { value: { 'decimalSeparator': { value: '.', type: 'string' }, 'patterns': { value: null, type: 'object?' }, 'thousandsSeparator': { value: '', type: 'string' } }, type: 'object' }, 'messages': { value: { 'en': { 'invalidRadiusDataField': 'lw-chart: Invalid radiusDataField value at [{{index}}]', 'invalidSeries': 'lw-chart: Invalid property: each series group must have a \'series\' property which must be a valid array.', 'invalidSeriesGroups': 'lw-chart: Invalid property: \'seriesGroups\' property is required and must be a valid array.', 'invalidType': 'lw-chart: Invalid serie type "{{type}}".', 'missingAxis': 'lw-chart: seriesGroup[{{index}}] is missing {{axis}} definition.', 'missingReference': 'lw-chart: Missing reference to {{files}}.', 'missingType': 'lw-chart: Invalid property: each series group must have a valid \'type\' property.' } }, type: 'object', extend: true }, 'padding': { value: { 'bottom': { value: 5, type: 'number' }, 'left': { value: 5, type: 'number' }, 'right': { value: 5, type: 'number' }, 'top': { value: 5, type: 'number' } }, type: 'object' }, 'renderEngine': { value: '', allowedValues: ['', 'SVG', 'HTML5'], type: 'string' }, 'rightToLeft': { value: false, type: 'boolean' }, 'seriesGroups': { value: [], type: 'any', reflectToAttribute: false }, 'showBorderLine': { value: true, type: 'boolean' }, 'showLegend': { value: true, type: 'boolean' }, 'showToolTips': { value: true, type: 'boolean' }, 'showToolTipsOnAllSeries': { value: false, type: 'boolean' }, 'theme': { value: 'light', allowedValues: ['light', 'dark'], type: 'string' }, 'titlePadding': { value: { 'bottom': { value: 10, type: 'number' }, 'left': { value: 5, type: 'number' }, 'right': { value: 5, type: 'number' }, 'top': { value: 5, type: 'number' } }, type: 'object' }, 'toolTipBackground': { value: null, type: 'string?' }, 'toolTipFormatFunction': { value: null, type: 'function?' }, 'toolTipHideDelay': { value: 4000, type: 'number' }, 'toolTipLineColor': { value: null, type: 'string?' }, 'toolTipShowDelay': { value: 300, type: 'number' }, 'valueAxis': { value: { 'alternatingBackgroundColor': { value: '', type: 'string' }, 'alternatingBackgroundColor2': { value: '', type: 'string' }, 'alternatingBackgroundOpacity': { value: 1, type: 'number' }, 'axisSize': { value: null, type: 'any' }, 'bands': { value: null, type: 'array?' }, 'baselineValue': { value: 0, type: 'any' }, 'customDraw': { value: false, type: 'boolean' }, 'flip': { value: false, type: 'boolean' }, 'formatFunction': { value: null, type: 'function?' }, 'formatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'gridLines': { value: { 'color': { value: '', type: 'string' }, 'custom': { value: null, type: 'array?' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'labels': { value: { 'angle': { value: 0, type: 'number' }, 'autoRotate': { value: false, type: 'boolean' }, 'class': { value: null, type: 'string?' }, 'custom': { value: null, type: 'array?' }, 'formatFunction': { value: null, type: 'function?' }, 'formatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'horizontalAlignment': { value: 'center', allowedValues: ['left', 'center', 'right'], type: 'string' }, 'offset': { value: { 'x': { value: 0, type: 'number' }, 'y': { value: 0, type: 'number' } }, type: 'object' }, 'rotationPoint': { value: 'auto', allowedValues: ['auto', 'left', 'center', 'right', 'topleft', 'topcenter', 'topright', 'bottomleft', 'bottomcenter', 'bottomright', 'centermiddle'], type: 'string' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'verticalAlignment': { value: 'center', allowedValues: ['top', 'center', 'bottom'], type: 'string' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'line': { value: { 'color': { value: '', type: 'string' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'logarithmicScale': { value: false, type: 'boolean' }, 'logarithmicScaleBase': { value: 10, type: 'number' }, 'maxValue': { value: NaN, type: 'any' }, 'minValue': { value: NaN, type: 'any' }, 'padding': { value: { 'bottom': { value: 0, type: 'number' }, 'left': { value: 0, type: 'number' }, 'right': { value: 0, type: 'number' }, 'top': { value: 0, type: 'number' } }, type: 'object' }, 'position': { value: 'left', allowedValues: ['left', 'right', 'top', 'bottom'], type: 'string' }, 'textRotationAngle': { value: null, type: 'number?' }, 'textRotationPoint': { value: 'auto', allowedValues: ['auto', 'left', 'center', 'right', 'topleft', 'topcenter', 'topright', 'bottomleft', 'bottomcenter', 'bottomright', 'centermiddle'], type: 'string' }, 'tickMarks': { value: { 'color': { value: '', type: 'string' }, 'custom': { value: null, type: 'array?' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'size': { value: 4, type: 'number' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'title': { value: { 'class': { value: null, type: 'string?' }, 'horizontalAlignment': { value: 'center', allowedValues: ['left', 'center', 'right'], type: 'string' }, 'text': { value: '', type: 'string' }, 'verticalAlignment': { value: 'center', allowedValues: ['top', 'center', 'bottom'], type: 'string' }, 'visible': { value: true, type: 'boolean' } }, type: 'object' }, 'unitInterval': { value: null, type: 'number?' }, 'valuesOnTicks': { value: true, type: 'boolean' }, 'visible': { value: true, type: 'boolean' } }, type: 'object' }, 'xAxis': { value: { 'alternatingBackgroundColor': { value: '', type: 'string' }, 'alternatingBackgroundColor2': { value: '', type: 'string' }, 'alternatingBackgroundOpacity': { value: 1, type: 'number' }, 'axisSize': { value: null, type: 'any' }, 'bands': { value: null, type: 'array?' }, 'baseUnit': { value: null, allowedValues: ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond', null], type: 'string?' }, 'customDraw': { value: false, type: 'boolean' }, 'dataField': { value: '', type: 'string' }, 'dateFormat': { value: null, type: 'string?' }, 'displayText': { value: null, type: 'string?' }, 'flip': { value: false, type: 'boolean' }, 'formatFunction': { value: null, type: 'function?' }, 'formatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'gridLines': { value: { 'color': { value: '', type: 'string' }, 'custom': { value: null, type: 'array?' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'labels': { value: { 'angle': { value: 0, type: 'number' }, 'autoRotate': { value: false, type: 'boolean' }, 'class': { value: null, type: 'string?' }, 'custom': { value: null, type: 'array?' }, 'formatFunction': { value: null, type: 'function?' }, 'formatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'horizontalAlignment': { value: 'center', allowedValues: ['left', 'center', 'right'], type: 'string' }, 'offset': { value: { 'x': { value: 0, type: 'number' }, 'y': { value: 0, type: 'number' } }, type: 'object' }, 'rotationPoint': { value: 'auto', allowedValues: ['auto', 'left', 'center', 'right', 'topleft', 'topcenter', 'topright', 'bottomleft', 'bottomcenter', 'bottomright', 'centermiddle'], type: 'string' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'verticalAlignment': { value: 'center', allowedValues: ['top', 'center', 'bottom'], type: 'string' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'line': { value: { 'color': { value: '', type: 'string' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'logarithmicScale': { value: false, type: 'boolean' }, 'logarithmicScaleBase': { value: 10, type: 'number' }, 'maxValue': { value: NaN, type: 'any' }, 'minValue': { value: NaN, type: 'any' }, 'padding': { value: { 'bottom': { value: 0, type: 'number' }, 'left': { value: 0, type: 'number' }, 'right': { value: 0, type: 'number' }, 'top': { value: 0, type: 'number' } }, type: 'object' }, 'position': { value: 'bottom', allowedValues: ['bottom', 'top', 'left', 'right'], type: 'string' }, 'rangeSelector': { value: { 'backgroundColor': { value: null, type: 'string?' }, 'backgroundImage': { value: '', type: 'string' }, 'baseUnit': { value: null, allowedValues: ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond', null], type: 'string?' }, 'borderLineColor': { value: null, type: 'string?' }, 'borderLineWidth': { value: null, type: 'number?' }, 'caption': { value: '', type: 'string' }, 'colorScheme': { value: null, type: 'string?' }, 'columnSeriesOverlap': { value: false, type: 'boolean' }, 'columnsGapPercent': { value: 25, type: 'number' }, 'dataField': { value: null, type: 'string?' }, 'description': { value: '', type: 'string' }, 'greyScale': { value: null, type: 'boolean?' }, 'gridLines': { value: { 'color': { value: '', type: 'string' }, 'custom': { value: null, type: 'array?' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'labels': { value: { 'angle': { value: 0, type: 'number' }, 'autoRotate': { value: false, type: 'boolean' }, 'class': { value: null, type: 'string?' }, 'custom': { value: null, type: 'array?' }, 'formatFunction': { value: null, type: 'function?' }, 'formatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'horizontalAlignment': { value: 'center', allowedValues: ['left', 'center', 'right'], type: 'string' }, 'offset': { value: { 'x': { value: 0, type: 'number' }, 'y': { value: 0, type: 'number' } }, type: 'object' }, 'rotationPoint': { value: 'auto', allowedValues: ['auto', 'left', 'center', 'right', 'topleft', 'topcenter', 'topright', 'bottomleft', 'bottomcenter', 'bottomright', 'centermiddle'], type: 'string' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'verticalAlignment': { value: 'center', allowedValues: ['top', 'center', 'bottom'], type: 'string' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'maxValue': { value: NaN, type: 'any' }, 'minValue': { value: NaN, type: 'any' }, 'padding': { value: { 'bottom': { value: 0, type: 'number' }, 'left': { value: 0, type: 'number' }, 'right': { value: 0, type: 'number' }, 'top': { value: 0, type: 'number' } }, type: 'object' }, 'position': { value: null, allowedValues: ['bottom', 'top', 'left', 'right'], type: 'string?' }, 'renderTo': { value: null, type: 'any' }, 'rightToLeft': { value: null, type: 'boolean?' }, 'seriesGapPercent': { value: 10, type: 'number' }, 'seriesGroups': { value: null, type: 'array?' }, 'serieType': { value: 'area', type: 'string' }, 'showBorderLine': { value: null, type: 'boolean?' }, 'size': { value: null, type: 'number?' }, 'skipOverlappingPoints': { value: true, type: 'boolean' }, 'titlePadding': { value: { 'bottom': { value: 10, type: 'number' }, 'left': { value: 5, type: 'number' }, 'right': { value: 5, type: 'number' }, 'top': { value: 5, type: 'number' } }, type: 'object' }, 'unitInterval': { value: null, type: 'number?' }, 'valueAxis': { value: { 'alternatingBackgroundColor': { value: '', type: 'string' }, 'alternatingBackgroundColor2': { value: '', type: 'string' }, 'alternatingBackgroundOpacity': { value: 1, type: 'number' }, 'axisSize': { value: null, type: 'any' }, 'bands': { value: null, type: 'array?' }, 'baselineValue': { value: 0, type: 'any' }, 'customDraw': { value: false, type: 'boolean' }, 'flip': { value: false, type: 'boolean' }, 'formatFunction': { value: null, type: 'function?' }, 'formatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'gridLines': { value: { 'color': { value: '', type: 'string' }, 'custom': { value: null, type: 'array?' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'labels': { value: { 'angle': { value: 0, type: 'number' }, 'autoRotate': { value: false, type: 'boolean' }, 'class': { value: null, type: 'string?' }, 'custom': { value: null, type: 'array?' }, 'formatFunction': { value: null, type: 'function?' }, 'formatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'horizontalAlignment': { value: 'center', allowedValues: ['left', 'center', 'right'], type: 'string' }, 'offset': { value: { 'x': { value: 0, type: 'number' }, 'y': { value: 0, type: 'number' } }, type: 'object' }, 'rotationPoint': { value: 'auto', allowedValues: ['auto', 'left', 'center', 'right', 'topleft', 'topcenter', 'topright', 'bottomleft', 'bottomcenter', 'bottomright', 'centermiddle'], type: 'string' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'verticalAlignment': { value: 'center', allowedValues: ['top', 'center', 'bottom'], type: 'string' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'line': { value: { 'color': { value: '', type: 'string' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'logarithmicScale': { value: false, type: 'boolean' }, 'logarithmicScaleBase': { value: 10, type: 'number' }, 'maxValue': { value: NaN, type: 'any' }, 'minValue': { value: NaN, type: 'any' }, 'padding': { value: { 'bottom': { value: 0, type: 'number' }, 'left': { value: 0, type: 'number' }, 'right': { value: 0, type: 'number' }, 'top': { value: 0, type: 'number' } }, type: 'object' }, 'position': { value: 'left', allowedValues: ['left', 'right', 'top', 'bottom'], type: 'string' }, 'textRotationAngle': { value: null, type: 'number?' }, 'textRotationPoint': { value: 'auto', allowedValues: ['auto', 'left', 'center', 'right', 'topleft', 'topcenter', 'topright', 'bottomleft', 'bottomcenter', 'bottomright', 'centermiddle'], type: 'string' }, 'tickMarks': { value: { 'color': { value: '', type: 'string' }, 'custom': { value: null, type: 'array?' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'size': { value: 4, type: 'number' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'title': { value: { 'class': { value: null, type: 'string?' }, 'horizontalAlignment': { value: 'center', allowedValues: ['left', 'center', 'right'], type: 'string' }, 'text': { value: '', type: 'string' }, 'verticalAlignment': { value: 'center', allowedValues: ['top', 'center', 'bottom'], type: 'string' }, 'visible': { value: true, type: 'boolean' } }, type: 'object' }, 'unitInterval': { value: null, type: 'number?' }, 'valuesOnTicks': { value: true, type: 'boolean' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' }, 'textRotationAngle': { value: null, type: 'number?' }, 'textRotationPoint': { value: 'auto', allowedValues: ['auto', 'left', 'center', 'right', 'topleft', 'topcenter', 'topright', 'bottomleft', 'bottomcenter', 'bottomright', 'centermiddle'], type: 'string' }, 'tickMarks': { value: { 'color': { value: '', type: 'string' }, 'custom': { value: null, type: 'array?' }, 'dashStyle': { value: '', type: 'string' }, 'lineWidth': { value: 1, type: 'number' }, 'size': { value: 4, type: 'number' }, 'step': { value: null, type: 'number?' }, 'unitInterval': { value: null, type: 'number?' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'title': { value: { 'class': { value: null, type: 'string?' }, 'horizontalAlignment': { value: 'center', allowedValues: ['left', 'center', 'right'], type: 'string' }, 'text': { value: '', type: 'string' }, 'verticalAlignment': { value: 'center', allowedValues: ['top', 'center', 'bottom'], type: 'string' }, 'visible': { value: true, type: 'boolean' } }, type: 'object' }, 'toolTipFormatFunction': { value: null, type: 'function?' }, 'toolTipFormatSettings': { value: { 'dateFormat': { value: null, type: 'string?' }, 'decimalPlaces': { value: null, type: 'number?' }, 'decimalSeparator': { value: null, type: 'string?' }, 'negativeWithBrackets': { value: false, type: 'boolean' }, 'prefix': { value: '', type: 'string' }, 'sufix': { value: '', type: 'string' }, 'thousandsSeparator': { value: null, type: 'string?' } }, type: 'object' }, 'type': { value: 'auto', allowedValues: ['auto', 'date', 'basic', 'linear'], type: 'string' }, 'unitInterval': { value: null, type: 'number?' }, 'valuesOnTicks': { value: true, type: 'boolean' }, 'visible': { value: true, type: 'boolean' } }, type: 'object', reflectToAttribute: false } }; } get _legendLayout() { const legendLayout = this.legendLayout; return legendLayout.height !== null || legendLayout.left !== null || legendLayout.top !== null || legendLayout.width !== null || legendLayout.flow === 'vertical'; } _getFormatSettings(obj, propertyName) { if (!obj) { return null; } const formatSettings = obj[propertyName ? propertyName : 'formatSettings']; if (!formatSettings) { return null; } return (formatSettings.dateFormat || formatSettings.decimalPlaces !== null || formatSettings.decimalSeparator || formatSettings.negativeWithBrackets || formatSettings.prefix || formatSettings.sufix || formatSettings.thousandsSeparator) ? formatSettings : null; } /** * Chart's event listeners. */ static get listeners() { return { 'click': '_clickHandler', 'down': '_downMoveHandler', 'mouseleave': '_mouseleaveHandler', 'move': '_moveHandler', 'resize': '_resizeHandler', 'document.move': '_downMoveHandler', 'document.up': '_documentUpHandler' }; } /** * Chart's required files. */ static get requires() { return { 'LW.Utilities.Draw': 'lw.draw.js' }; } static get styleUrls() { return [ 'lw.chart.css' ] } /** * Chart's HTML template. */ template() { return '<div role="presentation"></div>'; } /** * Called when the element is ready. Used for one-time configuration of the Array. */ ready() { super.ready(); this.checkLicense(); } render() { const that = this; that._observeSeriesGroups(); that._isTouchDevice = LW.Utilities.Core.isMobile; that._setDefaults(); that._createColorsCache(); that.refresh(); that._setAriaProperties(); super.render(); } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted || that._isRangeSelectorInstance) { return; } Object.values(that._rangeSelectorInstances).forEach(rangeSelector => { rangeSelector.parentDiv.parentDiv.appendChild(rangeSelector.parentDiv); }); } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); if (that._isRangeSelectorInstance) { return; } if (that._ttEl && that._ttEl.box) { that._ttEl.box.remove(); } delete that._ttEl; Object.values(that._rangeSelectorInstances).forEach(rangeSelector => { rangeSelector.parentDiv.remove(); }); } /** * Sets WAI-ARIA properties and generates a comprehensive description of the Chart. */ _setAriaProperties() { const that = this; if (that._isRangeSelectorInstance) { return; } const xAxis = that.xAxis, valueAxis = that.valueAxis, seriesGroups = that.seriesGroups; let descriptionContainer = that.$.content.children[1], description = '', flip = true; that.setAttribute('role', 'figure'); if (!descriptionContainer) { descriptionContainer = document.createElement('div'); descriptionContainer.id = that.id + 'DescriptionContainer'; descriptionContainer.className = 'lw-hidden'; that.$.content.appendChild(descriptionContainer); } that.setAttribute('aria-labelledby', that.id + 'TitleText'); that.setAttribute('aria-describedby', that.id + 'TitleDescription ' + descriptionContainer.id); //this._getXAxisStats(groupIndex, axis, axisSize) // inverted // x and y axis description // x and y axis from-to // data for (data fields) description += 'This chart displays:'; function processAxis(axis, name) { if (!axis || (!(axis.title && axis.title.text) && !axis.description && !axis.dataField)) { return; } description += '; "'; if (axis.title && axis.title.text) { description += axis.title.text; } else { description += axis.description || axis.dataField; } description += '" on the ' + name; if (!isNaN(axis.minValue)) { description += ' from ' + axis.minValue; } if (!isNaN(axis.maxValue)) { description += ' up to ' + axis.maxValue; } } processAxis(xAxis, 'x-axis'); processAxis(valueAxis, 'y-axis'); for (let i = 0; i < seriesGroups.length; i++) { const seriesGroup = seriesGroups[i]; processAxis(seriesGroup.valueAxis, 'y-axis'); if (!seriesGroup.series) { continue; } flip = flip && seriesGroup.orientation === 'horizontal'; for (let j = 0; j < seriesGroup.series.length; j++) { const series = seriesGroup.series[j]; if (j === 0) { if (i === 0) { description += ' for '; } else { description += '; '; } } description += '"' + (series.displayText || series.dataField) + '"'; if (j !== seriesGroup.series.length - 1) { description += ', '; } } } description = description.replace(':;', ':'); description = description.replace(/<.+?>/g, ''); if (flip) { description = description.replace(/x-axis/g, '@@@'); description = description.replace(/y-axis/g, 'x-axis'); description = description.replace(/@@@/g, 'y-axis'); } if (that.description) { description = '; ' + description; } descriptionContainer.innerHTML = description; } /** * Makes "seriesGroups" an observable array. */ _observeSeriesGroups() { const that = this; function notifyCallback(changeArgs) { if (that.context !== that && changeArgs.newValue !== changeArgs.oldValue) { that.update(); } } that._validateSeriesGroups(); that.seriesGroups = new LW.ObservableArray(that.seriesGroups); that.seriesGroups.canNotify = true; for (let i = 0; i < that.seriesGroups.length; i++) { that.seriesGroups[i].series = new LW.ObservableArray(that.seriesGroups[i].series); that.seriesGroups[i].series.canNotify = true; that.seriesGroups[i].series.notify(notifyCallback); } that.seriesGroups.notify(notifyCallback); } /** * down/document move handler. */ _downMoveHandler(event) { const that = this; let target = event.originalEvent.target; if (that.shadowRoot && target === that) { target = event.originalEvent.composedPath()[0]; } const rangeSelectorContainer = target.closest('.lw-chart-range-selector'); if (!rangeSelectorContainer) { return; } const rangeSelectorChart = rangeSelectorContainer.firstElementChild, parentChart = rangeSelectorChart.parentChart; if (that !== rangeSelectorChart && that !== parentChart) { return; } parentChart['_onSliderMouse' + event.type.slice(0, 1).toUpperCase() + event.type.slice(1)](event); } /** * document up handler. */ _documentUpHandler(event) { const that = this if (that._draggingRangeSelector) { that._onSliderMouseUp(event); } } /** * Sets the deefault values of private properties. */ _setDefaults() { const that = this; that.axisPadding = 5; that.enableEvents = true; that.enableSampling = true; that._itemsToggleState = []; that._isToggleRefresh = false; that._isSelectorRefresh = false; that._sliders = []; that._selectorRange = []; that._rangeSelectorInstances = {}; that._resizeState = {}; that._isRangeSelectorInstance = that._isRangeSelectorInstance || false; that._renderData = {}; that._lwPlot = null; that._animTickInt = 50; that._seriesTypes = [ 'line', 'stackedline', 'stackedline100', 'spline', 'stackedspline', 'stackedspline100', 'stepline', 'stackedstepline', 'stackedstepline100', 'area', 'stackedarea', 'stackedarea100', 'splinearea', 'stackedsplinearea', 'stackedsplinearea100', 'steparea', 'stackedsteparea', 'stackedsteparea100', 'rangearea', 'splinerangearea', 'steprangearea', 'column', 'stackedcolumn', 'stackedcolumn100', 'rangecolumn', 'scatter', 'stackedscatter', 'stackedscatter100', 'bubble', 'stackedbubble', 'stackedbubble100', 'pie', 'donut', 'candlestick', 'ohlc', 'waterfall', 'stackedwaterfall' ]; that.colorSchemes = [ { name: 'scheme01', colors: ['#307DD7', '#AA4643', '#89A54E', '#71588F', '#4198AF'] }, { name: 'scheme02', colors: ['#7FD13B', '#EA157A', '#FEB80A', '#00ADDC', '#738AC8'] }, { name: 'scheme03', colors: ['#E8601A', '#FF9639', '#F5BD6A', '#599994', '#115D6E'] }, { name: 'scheme04', colors: ['#D02841', '#FF7C41', '#FFC051', '#5B5F4D', '#364651'] }, { name: 'scheme05', colors: ['#25A0DA', '#309B46', '#8EBC00', '#FF7515', '#FFAE00'] }, { name: 'scheme06', colors: ['#0A3A4A', '#196674', '#33A6B2', '#9AC836', '#D0E64B'] }, { name: 'scheme07', colors: ['#CC6B32', '#FFAB48', '#FFE7AD', '#A7C9AE', '#888A63'] }, { name: 'scheme08', colors: ['#3F3943', '#01A2A6', '#29D9C2', '#BDF271', '#FFFFA6'] }, { name: 'scheme09', colors: ['#1B2B32', '#37646F', '#A3ABAF', '#E1E7E8', '#B22E2F'] }, { name: 'scheme10', colors: ['#5A4B53', '#9C3C58', '#DE2B5B', '#D86A41', '#D2A825'] }, { name: 'scheme11', colors: ['#993144', '#FFA257', '#CCA56A', '#ADA072', '#949681'] }, { name: 'scheme12', colors: ['#105B63', '#EEEAC5', '#FFD34E', '#DB9E36', '#BD4932'] }, { name: 'scheme13', colors: ['#BBEBBC', '#F0EE94', '#F5C465', '#FA7642', '#FF1E54'] }, { name: 'scheme14', colors: ['#60573E', '#F2EEAC', '#BFA575', '#A63841', '#BFB8A3'] }, { name: 'scheme15', colors: ['#444546', '#FFBB6E', '#F28D00', '#D94F00', '#7F203B'] }, { name: 'scheme16', colors: ['#583C39', '#674E49', '#948658', '#F0E99A', '#564E49'] }, { name: 'scheme17', colors: ['#142D58', '#447F6E', '#E1B65B', '#C8782A', '#9E3E17'] }, { name: 'scheme18', colors: ['#4D2B1F', '#635D61', '#7992A2', '#97BFD5', '#BFDCF5'] }, { name: 'scheme19', colors: ['#844341', '#D5CC92', '#BBA146', '#897B26', '#55591C'] }, { name: 'scheme20', colors: ['#56626B', '#6C9380', '#C0CA55', '#F07C6C', '#AD5472'] }, { name: 'scheme21', colors: ['#96003A', '#FF7347', '#FFBC7B', '#FF4154', '#642223'] }, { name: 'scheme22', colors: ['#5D7359', '#E0D697', '#D6AA5C', '#8C5430', '#661C0E'] }, { name: 'scheme23', colors: ['#16193B', '#35478C', '#4E7AC7', '#7FB2F0', '#ADD5F7'] }, { name: 'scheme24', colors: ['#7B1A25', '#BF5322', '#9DA860', '#CEA457', '#B67818'] }, { name: 'scheme25', colors: ['#0081DA', '#3AAFFF', '#99C900', '#FFEB3D', '#309B46'] }, { name: 'scheme26', colors: ['#0069A5', '#0098EE', '#7BD2F6', '#FFB800', '#FF6800'] }, { name: 'scheme27', colors: ['#FF6800', '#A0A700', '#FF8D00', '#678900', '#0069A5'] }, { name: 'scheme28', colors: ['#3A43BA', '#281E5D', '#48AAAD', '#0492C2', '#1E456E', '#59788D', '#52B2C0', '#82EDFD'] }, { name: 'scheme29', colors: ['#003F5C', '#BC5090', '#58508D', '#FF6361', '#FFA600'] }, { name: 'scheme30', colors: ['#16736F', '#A2D56A', '#1C515C', '#62B773', '#EEEF63', '#1F313F', '#309577'] }, { name: 'scheme31', colors: ['#74CC66', '#191A4D', '#2D867A', '#EEE3CD', '#224D19', '#0D261B', '#5771C7', '#B6D7E7', '#206052', '#6B5724', '#C3AF4B', '#603620', '#536722', '#B6E7B9', '#34819D', '#94ACDB'] }, { name: 'scheme32', colors: ['#87C5FF', '#5B5B60', '#9BE076', '#F7A384', '#7479D3', '#F13A80', '#E4D388', '#2BC6B2', '#F45B14'] } ]; } /** * click handler. */ _clickHandler(event) { const self = this; if (self.disabled || self._isRangeSelectorInstance) return; let x = event.pageX || event.clientX || event.screenX; let y = event.pageY || event.clientY || event.screenY; const pos = self.getBoundingClientRect(); if (self._isTouchDevice) { //var cursorPos = $.lw.position(event); x = event.pageX;// cursorPos.left; y = event.pageY;//cursorPos.top; } x -= pos.left; y -= pos.top; self._mouseX = x; self._mouseY = y; if (!isNaN(self._lastClickTs)) { if ((new Date()).valueOf() - self._lastClickTs < 100) return; } this._hostClickTimer = setTimeout(function () { if (!self._isTouchDevice) { self._cancelTooltipTimer(); self._hideToolTip(); self._unselect(); } if (self._pointMarker && self._pointMarker.element) { const group = self.seriesGroups[self._pointMarker.gidx]; const serie = group.series[self._pointMarker.sidx]; event.stopImmediatePropagation(); self._raiseItemEvent('click', group, serie, self._pointMarker.iidx); } }, 100); if (self.renderEngine === 'HTML5') { self._canvasClickHandler(x, y); } } /** * Canvas click handler. */ _canvasClickHandler(x, y) { const that = this, elements = that.renderer._elements; let clickedElement; for (let index in elements) { if (elements.hasOwnProperty(index) && index !== '0') { const element = elements[index]; if (y > element.y && y < element.y + element.height && x > element.x && x < element.x + element.width) { clickedElement = element; break; } } } if (!clickedElement) { return; } if (clickedElement.purpose && clickedElement.purpose === 'legend-toggle') { const data = clickedElement.data; that._toggleSerie(data.groupIndex, data.seriesIndex, data.itemIndex); } } /** * mouseleave handler. */ _mouseleaveHandler() { const self = this; if (self.disabled || self._isRangeSelectorInstance) return; const x = self._mouseX; const y = self._mouseY; const rect = self._plotRect; if (rect && x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) return; self._cancelTooltipTimer(); self._hideToolTip(0); self._unselect(); } /** * move handler. */ _moveHandler(event) { const self = this; if (self.disabled) return; if (self._isRangeSelectorInstance) { const parentChart = self.parentChart; if (parentChart.xAxis.rangeSelector.renderTo === null) { parentChart._unselect(); parentChart._hideToolTip(); } if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } else { self.style.cursor = 'default'; } let x = event.pageX || event.clientX || event.screenX; let y = event.pageY || event.clientY || event.screenY; const pos = self.getBoundingClientRect(); if (self._isTouchDevice) { x = event.pageX; y = event.pageY; } x -= pos.left; y -= pos.top; self.onmousemove(x, y); } /** * resize handler. */ _resizeHandler() { const self = this, animation = self.animation; if (self._isRangeSelectorInstance) { return; } self.animation = 'none'; self.refresh(); self.animation = animation; } /** @private */ //_refreshOnDownloadComlete() { // var self = this; // var source = this.dataSource; // if (source instanceof LW.DataAdapter) { // var adapteroptions = source._options; // if (adapteroptions === undefined || adapteroptions === null || (adapteroptions !== undefined && !adapteroptions.autoBind)) { // source.autoSync = false; // source.dataBind(); // } // var elementId = self.id; // if (source.length === 0) { // var updateFunc = function () { // // sends a callback function to the user. This allows him to add additional initialization logic before the chart is rendered. // if (self.onReady) // self.onReady(); // self.refresh(); // }; // source.unbindDownloadComplete(elementId); // source.bindDownloadComplete(elementId, updateFunc); // } // else { // // sends a callback function to the user. This allows him to add additional initialization logic before the chart is rendered. // if (self.onReady) // self.onReady(); // } // //source.unbindBindingUpdate(elementId); // //source.bindBindingUpdate(elementId, function () { // // if (self._supressBindingRefresh) // // return; // // self.refresh(); // //}); // } //} propertyChangedHandler(key, oldValue, value) { const that = this; //if (key === 'source') // this._refreshOnDownloadComlete(); switch (key) { case 'animation': case 'theme': if (that._ttEl) { that._ttEl.box.setAttribute(key, value); } break; case 'rightToLeft': if (!that._ttEl || !that._ttEl.box) { break; } value ? that._ttEl.box.setAttribute('right-to-left', value) : that._ttEl.box.removeAttribute('right-to-left'); break; case 'seriesGroups': that._observeSeriesGroups(); break; case 'xAxis_rangeSelector_renderTo': if (value === null) { const oldRangeSelector = oldValue.getElementsByClassName('lw-chart-range-selector')[0]; oldRangeSelector.parentElement.removeChild(oldRangeSelector); } break; } this.refresh(); } /** @private */ _initRenderer() { const that = this; that._draw = new LW.Utilities.Draw(that.$.content, that.renderEngine); that.renderer = that._draw.renderer; if (!that._lwPlot) that._lwPlot = new LW.Utilities.Plot(that.renderer); that.$.content.firstElementChild.setAttribute('role', 'presentation'); } /** @private */ _internalRefresh() { const self = this; // validate visiblity if (!(self.offsetWidth || self.offsetHeight || self.getClientRects().length)) { return; } self._stopAnimations(); if (!self.renderer || (!self._isToggleRefresh && !self._isUpdate)) { self._hideToolTip(0); self.$.content.innerHTML = ''; self._initRenderer(); } const renderer = self.renderer; if (!renderer) return; const rect = renderer.getRect(); self._render({ x: 1, y: 1, width: rect.width, height: rect.height }); this.$.fireEvent('refreshBegin', { instance: this }); if (renderer instanceof LW.Utilities.HTML5Renderer) renderer.refresh(); self._isUpdate = false; this.$.fireEvent('refreshEnd', { instance: this }); } saveAsPNG(filename) { return this._saveAsImage('png', filename); } saveAsJPEG(filename) { return this._saveAsImage('jpeg', filename); } saveAsPDF(filename, pageOrientation) { return this._saveAsImage('pdf', filename, pageOrientation); } print() { return this._saveAsImage('print'); } /** @private */ _saveAsImage(type, fileName, pageOrientation) { const that = this; return that._draw._widgetToImage(that, type, fileName, that._hasRangeSelector ? that._selectorSaveAsImageCallback : undefined, pageOrientation); } _selectorSaveAsImageCallback(instance, canvas) { let self = instance; for (let i = 0; i < self.seriesGroups.length; i++) { let xAxis = self._getXAxis(i); if (!xAxis || !xAxis.rangeSelector || !xAxis.rangeSelector.visible || xAxis.rangeSelector.renderTo) continue; let selectorInstance = self._rangeSelectorInstances[i]; if (!selectorInstance) continue; let rect = selectorInstance.renderer.getRect(); let selectorCanvas = selectorInstance.renderer.getContainer().getElementsByTagName('canvas')[0]; let selectorContext = selectorCanvas.getContext('2d'); let slider = self._sliders[i]; let swapXY = self.seriesGroups[i].orientation === 'horizontal'; let widthProp = !swapXY ? 'width' : 'height'; let rwidthProp = swapXY ? 'width' : 'height'; let posProp = !swapXY ? 'x' : 'y'; let rposProp = swapXY ? 'x' : 'y'; let selectedRect = {}; selectedRect[posProp] = slider.startOffset + slider.rect[posProp]; selectedRect[rposProp] = slider.rect[rposProp]; selectedRect[widthProp] = slider.endOffset - slider.startOffset; selectedRect[rwidthProp] = slider.rect[rwidthProp]; let colorSelectedRange = xAxis.rangeSelector.colorSelectedRange || 'blue'; let colorRangeLineColor = xAxis.rangeSelector.colorRangeLine || 'grey'; let elements = []; elements.push(selectorInstance.renderer.rect(selectedRect.x, selectedRect.y, selectedRect.width, selectedRect.height, { fill: colorSelectedRange, opacity: 0.1 })); const renderer = self.renderer; if (!swapXY) { elements.push(selectorInstance.renderer.line(renderer._ptrnd(slider.rect.x), renderer._ptrnd(slider.rect.y), renderer._ptrnd(selectedRect.x), renderer._ptrnd(slider.rect.y), { stroke: colorRangeLineColor, opacity: 0.5 })); elements.push(selectorInstance.renderer.line(renderer._ptrnd(selectedRect.x + selectedRect.width), renderer._ptrnd(slider.rect.y), renderer._ptrnd(slider.rect.x + slider.rect.width), renderer._ptrnd(slider.rect.y), { stroke: colorRangeLineColor, opacity: 0.5 })); elements.push(selectorInstance.renderer.line(renderer._ptrnd(selectedRect.x), renderer._ptrnd(slider.rect.y), renderer._ptrnd(selectedRect.x), renderer._ptrnd(slider.rect.y + slider.rect.height), { stroke: colorRangeLineColor, opacity: 0.5 })); elements.push(selectorInstance.renderer.line(renderer._ptrnd(selectedRect.x + selectedRect.width), renderer._ptrnd(slider.rect.y), renderer._ptrnd(selectedRect.x + selectedRect.width), renderer._ptrnd(slider.rect.y + slider.rect.height), { stroke: colorRangeLineColor, opacity: 0.5 })); } else { elements.push(selectorInstance.renderer.line(renderer._ptrnd(slider.rect.x + slider.rect.width), renderer._ptrnd(slider.rect.y), renderer._ptrnd(slider.rect.x + slider.rect.width), renderer._ptrnd(selectedRect.y), { stroke: colorRangeLineColor, opacity: 0.5 })); elements.push(selectorInstance.renderer.line(renderer._ptrnd(slider.rect.x + slider.rect.width), renderer._ptrnd(selectedRect.y + selectedRect.height), renderer._ptrnd(slider.rect.x + slider.rect.width), renderer._ptrnd(slider.rect.y + slider.rect.height), { stroke: colorRangeLineColor, opacity: 0.5 })); elements.push(selectorInstance.renderer.line(renderer._ptrnd(slider.rect.x), renderer._ptrnd(selectedRect.y), renderer._ptrnd(slider.rect.x + slider.rect.width), renderer._ptrnd(selectedRect.y), { stroke: colorRangeLineColor, opacity: 0.5 })); elements.push(selectorInstance.renderer.line(renderer._ptrnd(slider.rect.x), renderer._ptrnd(selectedRect.y + selectedRect.height), renderer._ptrnd(slider.rect.x + slider.rect.width), renderer._ptrnd(selectedRect.y + selectedRect.height), { stroke: colorRangeLineColor, opacity: 0.5 })); } selectorInstance.renderer.refresh(); let imgdata = selectorContext.getImageData(rect.x, rect.y, rect.width, rect.height); const hostContext = canvas.getContext('2d'), chartRect = self.getBoundingClientRect(), selectorInstanceRect = selectorInstance.getBoundingClientRect(); hostContext.putImageData( imgdata, selectorInstanceRect.left - chartRect.left, selectorInstanceRect.top - chartRect.top, 1, 1, rect.width, rect.height); for (let j = 0; j < elements.length; j++) selectorInstance.renderer.removeElement(elements[j]); selectorInstance.renderer.refresh(); } return true; } refresh() { const that = this; that._internalRefresh(); that._setAriaProperties(); } update() { this._isUpdate = true; this._internalRefresh(); } clear() { const self = this; //for (var setting in self._defaultSettings) // self[setting] = self._defaultSettings[setting]; self.caption = ''; self.description = ''; self.refresh(); } _validateSeriesGroups() { const that = this; if (!(Array.isArray(this.seriesGroups) || that.seriesGroups instanceof LW.ObservableArray)) that.error(that.localize('invalidSeriesGroups')); for (let i = 0; i < this.seriesGroups.length; i++) { const group = this.seriesGroups[i]; if (!group.type) that.error(that.localize('missingType')); if (!(Array.isArray(group.series) || group.series instanceof LW.ObservableArray)) that.error(that.localize('invalidSeries')); } } /** @private */ _render(rect) { var self = this; var renderer = self.renderer; self._colorsCache.clear(); if (!self._isToggleRefresh && self._isUpdate && self._renderData) self._renderDataClone(); self._renderData = []; renderer.clear(); self._unselect(); self._hideToolTip(0); var bckgImg = self.backgroundImage; if (bckgImg === undefined || bckgImg === null || bckgImg === '') self.style.backgroundImage = ''; //self.host.css({ 'background-image': '' }); else self.style.backgroundImage = (bckgImg.indexOf('(') !== -1 ? bckgImg : 'url("' + bckgImg + '")'); //self.host.css({ 'background-image': (bckgImg.indexOf('(') !== -1 ? bckgImg : 'url('' + bckgImg + '')') }); self._rect = rect; var padding = self.padding || { left: 5, top: 5, right: 5, bottom: 5 }; var clipAll = renderer.createClipRect(rect); var groupAll = renderer.beginGroup(); renderer.setClip(groupAll, clipAll); var rFill = renderer.rect(rect.x, rect.y, rect.width - 2, rect.height - 2); if (bckgImg === undefined || bckgImg === null || bckgImg === '') renderer.attr(rFill, { fill: self.backgroundColor || self._getThemeColor('background') }); else renderer.attr(rFill, { fill: 'transparent' }); if (self.showBorderLine !== false) { var borderLineWidth = this.borderLineWidth; if (isNaN(borderLineWidth) || borderLineWidth < 0 || borderLineWidth > 10) borderLineWidth = 1; renderer.attr(rFill, { 'stroke-width': borderLineWidth, stroke: self.borderLineColor || self._getThemeColor('line') }); } // Invoke user-defined drawing if (typeof self.drawBefore === 'function') { self.drawBefore(renderer, rect); } var paddedRect = { x: padding.left, y: padding.top, width: rect.width - padding.left - padding.right, height: rect.height - padding.top - padding.bottom }; self._paddedRect = paddedRect; var titlePadding = self.titlePadding || { left: 2, top: 2, right: 2, bottom: 2 }; var sz; if (self.caption && self.caption.length > 0) { sz = renderer.measureText(self.caption, 0, { 'class': 'lw-chart-title-text' }); const element = renderer.text(self.caption, paddedRect.x + titlePadding.left, paddedRect.y + titlePadding.top, paddedRect.width - (titlePadding.left + titlePadding.right), sz.height, 0, { 'class': 'lw-chart-title-text' }, true, 'center', 'center'); element.id = self.id + 'TitleText'; paddedRect.y += sz.height; paddedRect.height -= sz.height; } if (self.description && self.description.length > 0) { sz = renderer.measureText(self.description, 0, { 'class': 'lw-chart-title-description' }); const element = renderer.text(self.description, paddedRect.x + titlePadding.left, paddedRect.y + titlePadding.top, paddedRect.width - (titlePadding.left + titlePadding.right), sz.height, 0, { 'class': 'lw-chart-title-description' }, true, 'center', 'center'); element.id = self.id + 'TitleDescription'; paddedRect.y += sz.height; paddedRect.height -= sz.height; } if (self.caption || self.description) { paddedRect.y += (titlePadding.bottom + titlePadding.top); paddedRect.height -= (titlePadding.bottom + titlePadding.top); } var plotRect = { x: paddedRect.x, y: paddedRect.y, width: paddedRect.width, height: paddedRect.height }; self._plotRect = plotRect; // build stats self._buildStats(plotRect); var isPieOnly = self._isPieOnlySeries(); var seriesGroups = self.seriesGroups; // axis validation var swap; var hashAxis = { xAxis: {}, valueAxis: {} }; for (let i = 0; i < seriesGroups.length && !isPieOnly; i++) { if (seriesGroups[i].type === 'pie' || seriesGroups[i].type === 'donut') continue; var xAxis = self._getXAxis(i); if (!xAxis) self.error(self.localize('missingAxis', { index: i, axis: 'xAxis' })); let xAxisId = xAxis === self._getXAxis() ? -1 : i; hashAxis.xAxis[xAxisId] = 0x00; } var axisPadding = self.axisPadding; if (isNaN(axisPadding)) axisPadding = 5; // get vertical axis width var wYAxis = { left: 0, right: 0, leftCount: 0, rightCount: 0 }; var wYAxisArr = []; for (let i = 0; i < seriesGroups.length; i++) { const g = seriesGroups[i]; if (g.type === 'pie' || g.type === 'donut' || g.spider === true || g.polar === true) { wYAxisArr.push({ width: 0, position: 0, xRel: 0 }); continue; } swap = g.orientation === 'horizontal'; var xAxis = self._getXAxis(i); let xAxisId = xAxis === self._getXAxis() ? -1 : i; var valueAxis = self._getValueAxis(i); var valueAxisId = valueAxis === self._getValueAxis() ? -1 : i; var w = !swap ? valueAxis.axisSize : xAxis.axisSize; var axisR = { x: 0, y: plotRect.y, width: plotRect.width, height: plotRect.height }; var position = swap ? self._getXAxis(i).position : valueAxis.position; if (!w || w === 'auto') { if (swap) { w = this._renderXAxis(i, axisR, true, plotRect).width; if ((hashAxis.xAxis[xAxisId] & 0x01) === 0x01) w = 0; else if (w > 0) hashAxis.xAxis[xAxisId] |= 0x01; } else { w = self._renderValueAxis(i, axisR, true, plotRect).width; if ((hashAxis.valueAxis[valueAxisId] & 0x01) === 0x01) w = 0; else if (w > 0) hashAxis.valueAxis[valueAxisId] |= 0x01; } } if (position !== 'left' && self.rightToLeft === true) position = 'right'; if (position !== 'right') position = 'left'; if (wYAxis[position + 'Count'] > 0 && wYAxis[position] > 0 && w > 0) wYAxis[position] += axisPadding; wYAxisArr.push({ width: w, position: position, xRel: wYAxis[position] }); wYAxis[position] += w; wYAxis[position + 'Count']++; } var measureSize = Math.max(1, Math.max(rect.width, rect.height)); // get horizontal axis height var hXAxis = { top: 0, bottom: 0, topCount: 0, bottomCount: 0 }; var hXAxisArr = []; for (let i = 0; i < seriesGroups.length; i++) { const g = seriesGroups[i]; if (g.type === 'pie' || g.type === 'donut' || g.spider === true || g.polar === true) { hXAxisArr.push({ height: 0, position: 0, yRel: 0 }); continue; } swap = g.orientation === 'horizontal'; var valueAxis = this._getValueAxis(i); var valueAxisId = valueAxis === self._getValueAxis() ? -1 : i; var xAxis = self._getXAxis(i); let xAxisId = xAxis === self._getXAxis() ? -1 : i; let h = !swap ? xAxis.axisSize : valueAxis.axisSize; var position = swap ? valueAxis.position : xAxis.position; if (!h || h === 'auto') { if (swap) { h = self._renderValueAxis(i, { x: 0, y: 0, width: measureSize, height: 0 }, true, plotRect).height; if ((hashAxis.valueAxis[valueAxisId] & 0x02) === 0x02) h = 0; else if (h > 0) hashAxis.valueAxis[valueAxisId] |= 0x02; } else { h = self._renderXAxis(i, { x: 0, y: 0, width: measureSize, height: 0 }, true).height; if ((hashAxis.xAxis[xAxisId] & 0x02) === 0x02) h = 0; else if (h > 0) hashAxis.xAxis[xAxisId] |= 0x02; } } if (position !== 'top') position = 'bottom'; if (hXAxis[position + 'Count'] > 0 && hXAxis[position] > 0 && h > 0) hXAxis[position] += axisPadding; hXAxisArr.push({ height: h, position: position, yRel: hXAxis[position] }); hXAxis[position] += h; hXAxis[position + 'Count']++; } self._createAnimationGroup('series'); const showLegend = (self.showLegend !== false), customlegendLayout = self._legendLayout; var szLegend = !showLegend ? { width: 0, height: 0 } : self._renderLegend(customlegendLayout ? self._rect : paddedRect, true); if (customlegendLayout && (!isNaN(this.legendLayout.left) || !isNaN(this.legendLayout.top))) szLegend = { width: 0, height: 0 }; if (paddedRect.height < hXAxis.top + hXAxis.bottom + szLegend.height || paddedRect.width < wYAxis.left + wYAxis.right) { renderer.endGroup(); return; } plotRect.height -= hXAxis.top + hXAxis.bottom + szLegend.height; plotRect.x += wYAxis.left; plotRect.width -= wYAxis.left + wYAxis.right; plotRect.y += hXAxis.top; var xAxisRect = []; if (!isPieOnly) { for (let i = 0; i < seriesGroups.length; i++) { const g = seriesGroups[i]; if (g.polar === true || g.spider === true || g.type === 'pie' || g.type === 'donut') continue; swap = g.orientation === 'horizontal'; var xAxisId = self._getXAxis(i) === self._getXAxis() ? -1 : i; var valueAxisId = self._getValueAxis(i) === self._getValueAxis() ? -1 : i; let axisR = { x: plotRect.x, y: 0, width: plotRect.width, height: hXAxisArr[i].height }; if (hXAxisArr[i].position !== 'top') axisR.y = plotRect.y + plotRect.height + hXAxisArr[i].yRel; else axisR.y = plotRect.y - hXAxisArr[i].yRel - hXAxisArr[i].height; if (swap) { if ((hashAxis.valueAxis[valueAxisId] & 0x04) === 0x04) continue; if (!self._isGroupVisible(i)) continue; self._renderValueAxis(i, axisR, false, plotRect); hashAxis.valueAxis[valueAxisId] |= 0x04; } else { xAxisRect.push(axisR); if ((hashAxis.xAxis[xAxisId] & 0x04) === 0x04) continue; if (!self._isGroupVisible(i)) continue; self._renderXAxis(i, axisR, false, plotRect); hashAxis.xAxis[xAxisId] |= 0x04; } } } if (showLegend) { const customlegendLayout = self._legendLayout, containerRect = customlegendLayout ? self._rect : paddedRect; var x = paddedRect.x + this.renderer._ptrnd((paddedRect.width - szLegend.width) / 2); var y = plotRect.y + plotRect.height + hXAxis.bottom; var w = paddedRect.width; let h = szLegend.height; if (customlegendLayout) { if (!isNaN(self.legendLayout.left)) x = self.legendLayout.left; if (!isNaN(self.legendLayout.top)) y = self.legendLayout.top; if (!isNaN(self.legendLayout.width)) w = self.legendLayout.width; if (!isNaN(self.legendLayout.height)) h = self.legendLayout.height; } if (x + w > containerRect.x + containerRect.width) w = containerRect.x + containerRect.width - x; if (y + h > containerRect.y + containerRect.height) h = containerRect.y + containerRect.height - y; self._renderLegend({ x: x, y: y, width: w, height: h }); } self._hasHorizontalLines = false; if (!isPieOnly) { for (let i = 0; i < seriesGroups.length; i++) { const g = seriesGroups[i]; if (g.polar === true || g.spider === true || g.type === 'pie' || g.type === 'donut') continue; swap = seriesGroups[i].orientation === 'horizontal'; let axisR = { x: plotRect.x - wYAxisArr[i].xRel - wYAxisArr[i].width, y: plotRect.y, width: wYAxisArr[i].width, height: plotRect.height }; if (wYAxisArr[i].position !== 'left') axisR.x = plotRect.x + plotRect.width + wYAxisArr[i].xRel; var xAxisId = self._getXAxis(i) === self._getXAxis() ? -1 : i; var valueAxisId = self._getValueAxis(i) === self._getValueAxis() ? -1 : i; if (swap) { xAxisRect.push(axisR); if ((hashAxis.xAxis[xAxisId] & 0x08) === 0x08) continue; if (!self._isGroupVisible(i)) continue; self._renderXAxis(i, axisR, false, plotRect); hashAxis.xAxis[xAxisId] |= 0x08; } else { if ((hashAxis.valueAxis[valueAxisId] & 0x08) === 0x08) continue; if (!self._isGroupVisible(i)) continue; self._renderValueAxis(i, axisR, false, plotRect); hashAxis.valueAxis[valueAxisId] |= 0x08; } } } if (plotRect.width <= 0 || plotRect.height <= 0) return; self._plotRect = { x: plotRect.x, y: plotRect.y, width: plotRect.width, height: plotRect.height }; for (let i = 0; i < seriesGroups.length; i++) { this._drawPlotAreaLines(i, true, { gridLines: false, tickMarks: false, alternatingBackground: true }); this._drawPlotAreaLines(i, false, { gridLines: false, tickMarks: false, alternatingBackground: true }); } for (let i = 0; i < seriesGroups.length; i++) { this._drawPlotAreaLines(i, true, { gridLines: true, tickMarks: true, alternatingBackground: false }); this._drawPlotAreaLines(i, false, { gridLines: true, tickMarks: true, alternatingBackground: false }); } var hasCustomDraw = false; for (let i = 0; i < seriesGroups.length && !hasCustomDraw; i++) { const g = seriesGroups[i]; if (g.annotations !== undefined || typeof g.draw === 'function' || typeof g.drawBefore === 'function' ) { hasCustomDraw = true; break; } } var gPlot = renderer.beginGroup(); if (self.clip && !hasCustomDraw) { var clip = renderer.createClipRect({ x: plotRect.x - 2, y: plotRect.y, width: plotRect.width + 4, height: plotRect.height }); renderer.setClip(gPlot, clip); } for (let i = 0; i < seriesGroups.length; i++) { const g = seriesGroups[i]; var isValid = false; for (var validtype in self._seriesTypes) { if (self._seriesTypes[validtype] === g.type) { isValid = true; break; } } if (!isValid) self.error(self.localize('invalidType', { type: g.type })); // custom drawing before the group if (typeof g.drawBefore === 'function') g.drawBefore(renderer, rect, i, this); // polar series drawing if (g.polar === true || g.spider === true) { if (g.type.indexOf('pie') === -1 && g.type.indexOf('donut') === -1) self._renderSpiderAxis(i, plotRect); } self._renderAxisBands(i, plotRect, true); self._renderAxisBands(i, plotRect, false); } for (let i = 0; i < seriesGroups.length; i++) { const g = seriesGroups[i]; if (self._isColumnType(g.type)) self._renderColumnSeries(i, plotRect); else if (g.type.indexOf('pie') !== -1 || g.type.indexOf('donut') !== -1) self._renderPieSeries(i, plotRect); else if (g.type.indexOf('line') !== -1 || g.type.indexOf('area') !== -1) self._renderLineSeries(i, plotRect); else if (g.type.indexOf('scatter') !== -1 || g.type.indexOf('bubble') !== -1) self._renderScatterSeries(i, plotRect); else if (g.type.indexOf('candlestick') !== -1 || g.type.indexOf('ohlc') !== -1) self._renderCandleStickSeries(i, plotRect, g.type.indexOf('ohlc') !== -1); if (g.annotations) { if (!this._moduleAnnotations) self.error(self.localize('missingReference', { files: 'lw.chart.annotations.js' })); for (let j = 0; j < g.annotations.length; j++) self._renderAnnotation(i, g.annotations[j], plotRect); } // custom drawing after the group if (typeof g.draw === 'function') g.draw(renderer, rect, i, this); } renderer.endGroup(); if (self.disabled) { var el = renderer.rect(rect.x, rect.y, rect.width, rect.height); renderer.attr(el, { fill: '#777777', opacity: 0.5, stroke: '#00FFFFFF' }); } // Invoke user-defined drawing if (typeof self.draw === 'function') { self.draw(renderer, rect); } renderer.endGroup(); self._startAnimation('series'); if (self._credits) { self._credits(); } // render range selector var hasRangeSelector = false; for (let i = 0; i < self.seriesGroups.length && !hasRangeSelector; i++) { var xAxis = self._getXAxis(i); if (xAxis && xAxis.rangeSelector && xAxis.rangeSelector.visible) { hasRangeSelector = true; self._hasRangeSelector = true; } } if (hasRangeSelector) { if (!this._moduleRangeSelector) self.error(self.localize('missingReference', { files: 'lw.chart.rangeselector.js' })); var isRendered = []; if (!self._isSelectorRefresh) self._rangeSelectorInstances = {}; for (let i = 0; i < self.seriesGroups.length; i++) { var axis = this._getXAxis(i); if (isRendered.indexOf(axis) === -1) { if (this._renderXAxisRangeSelector(i, xAxisRect[i])) isRendered.push(axis); } } } } _credits() { //DEPRECATED } /** @private */ _isPieOnlySeries() { let seriesGroups = this.seriesGroups; if (seriesGroups.length === 0) return false; for (let i = 0; i < seriesGroups.length; i++) { if (seriesGroups[i].type !== 'pie' && seriesGroups[i].type !== 'donut') return false; } return true; } /** @private */ _renderChartLegend(data, rect, isMeasure, isVerticalFlow) { var self = this; var renderer = self.renderer; var r = { x: rect.x, y: rect.y, width: rect.width, height: rect.height }; var padding = 3; if (r.width >= 2 * padding) { r.x += padding; r.width -= 2 * padding; } if (r.height >= 2 * padding) { r.y += padding; r.height -= 2 * padding; } var szMeasure = { width: r.width, height: 0 }; var x = 0, y = 0; var rowH = 20; var rowW = 0; var barSize = 10; var space = 10; var maxWidth = 0; for (let i = 0; i < data.length; i++) { var css = data[i].css; if (!css) css = 'lw-chart-legend-text'; rowH = 20; var text = data[i].text; var sz = renderer.measureText(text, 0, { 'class': css }); if (sz.height > rowH) { rowH = sz.height; } if (sz.width > maxWidth) maxWidth = sz.width; if (isVerticalFlow) { if (i !== 0) y += rowH; if (y > r.height) { y = 0; x += maxWidth + 2 * space + barSize; maxWidth = sz.width; szMeasure.width = x + maxWidth; } } else { if (x !== 0) x += space; if (x + 2 * barSize + sz.width > r.width && sz.width < r.width) { x = 0; y += rowH; rowH = 20; rowW = r.width; szMeasure.height = y + rowH; } } var wrap = false; if (sz.width > r.width) { wrap = true; var wrapWidth = r.width; var legendInfo = text; var words = legendInfo.split(/\s+/); let textInfo = []; let currentLine = ''; for (let iWord = 0; iWord < words.length; iWord++) { var txt = currentLine + ((currentLine.length > 0) ? ' ' : '') + words[iWord]; var textSize = self.renderer.measureText(txt, 0, { 'class': css }); if (textSize.width > wrapWidth && txt.length > 0 && currentLine.length > 0) { textInfo.push({ text: currentLine }); currentLine = words[iWord]; } else currentLine = txt; if (iWord + 1 === words.length) textInfo.push({ text: currentLine }); } sz.width = 0; var height = 0; for (let t = 0; t < textInfo.length; t++) { var textItem = textInfo[t].text; var textSize = self.renderer.measureText(textItem, 0, { 'class': css }); sz.width = Math.max(sz.width, textSize.width); height += sz.height; } sz.height = height; } var renderInBounds = (x + sz.width < r.width) && (y + sz.height < rect.height); if (self._legendLayout) { var renderInBounds = r.x + x + sz.width < self._rect.x + self._rect.width && r.y + y + sz.height < self._rect.y + self._rect.height; } if (!isMeasure && renderInBounds ) { var sidx = data[i].seriesIndex; var gidx = data[i].groupIndex; var iidx = data[i].itemIndex; var fillColor = data[i].fillColor; var lineColor = data[i].lineColor; var isVisible = self._isSerieVisible(gidx, sidx, iidx); var g = renderer.beginGroup(); var opacity = isVisible ? data[i].opacity : 0.1; if (wrap) { var legendInfo = text; var wrapWidth = r.width; var words = legendInfo.split(/\s+/); var dy = 0; let textInfo = []; let currentLine = ''; for (let iWord = 0; iWord < words.length; iWord++) { var txt = currentLine + ((currentLine.length > 0) ? ' ' : '') + words[iWord]; var textSize = self.renderer.measureText(txt, 0, { 'class': css }); if (textSize.width > wrapWidth && txt.length > 0 && currentLine.length > 0) { textInfo.push({ text: currentLine, dy: dy }); dy += textSize.height; currentLine = words[iWord] } else currentLine = txt; if (iWord + 1 === words.length) textInfo.push({ text: currentLine, dy: dy }); } for (let t = 0; t < textInfo.length; t++) { var textItem = textInfo[t].text; dy = textInfo[t].dy; var textSize = self.renderer.measureText(textItem, 0, { 'class': css }); if (isVerticalFlow) { self.renderer.text(textItem, r.x + x + 1.5 * barSize, r.y + y + dy, sz.width, rowH, 0, { 'class': css }, false, 'left', 'center'); } else { self.renderer.text(textItem, r.x + x + 1.5 * barSize, r.y + y + dy, sz.width, rowH, 0, { 'class': css }, false, 'center', 'center'); } } let elem = renderer.rect(r.x + x, r.y + y + barSize / 2 + dy / 2, barSize, barSize); if (isVerticalFlow) y += dy; self.renderer.attr(elem, { fill: fillColor, 'fill-opacity': opacity, stroke: lineColor, 'stroke-width': 1, 'stroke-opacity': data[i].opacity }); } else { let elem = renderer.rect(r.x + x, r.y + y + barSize / 2, barSize, barSize); self.renderer.attr(elem, { fill: fillColor, 'fill-opacity': opacity, stroke: lineColor, 'stroke-width': 1, 'stroke-opacity': data[i].opacity, purpose: 'legend-toggle', data: data[i] }); let textElem; if (isVerticalFlow) { textElem = self.renderer.text(text, r.x + x + 1.5 * barSize, r.y + y, sz.width, sz.height + barSize / 2, 0, { 'class': css }, false, 'left', 'center'); } else { textElem = self.renderer.text(text, r.x + x + 1.5 * barSize, r.y + y, sz.width, rowH, 0, { 'class': css }, false, 'center', 'center'); } renderer.attr(textElem, { purpose: 'legend-toggle', data: data[i] }); } self.renderer.endGroup(); self._setLegendToggleHandler(gidx, sidx, iidx, g); } if (!isVerticalFlow) { x += sz.width + 2 * barSize; if (rowW < x) rowW = x; } } if (isMeasure) { szMeasure.height = this.renderer._ptrnd(y + rowH + 5); szMeasure.width = this.renderer._ptrnd(rowW); return szMeasure; } } isSerieVisible(groupIndex, serieIndex, itemIndex) { return this._isSerieVisible(groupIndex, serieIndex, itemIndex); } /** @private */ _isSerieVisible(groupIndex, serieIndex, itemIndex) { while (this._itemsToggleState.length < groupIndex + 1) this._itemsToggleState.push([]); let g = this._itemsToggleState[groupIndex]; while (g.length < serieIndex + 1) g.push(isNaN(itemIndex) ? true : []); let s = g[serieIndex]; if (isNaN(itemIndex)) return s; if (!Array.isArray(s)) g[serieIndex] = s = []; while (s.length < itemIndex + 1) s.push(true); return s[itemIndex]; } isGroupVisible(groupIndex) { return this._isGroupVisible(groupIndex); } /** @private */ _isGroupVisible(groupIndex) { let isGroupVisible = false; let series = this.seriesGroups[groupIndex].series; if (!series) return isGroupVisible; for (let i = 0; i < series.length; i++) { if (this._isSerieVisible(groupIndex, i)) { isGroupVisible = true; break; } } return isGroupVisible; } /** @private */ _toggleSerie(groupIndex, serieIndex, itemIndex, enable) { let state = !this._isSerieVisible(groupIndex, serieIndex, itemIndex); if (enable !== undefined) state = enable; let group = this.seriesGroups[groupIndex]; let serie = group.series[serieIndex]; this.$.fireEvent('toggle', { state: state, seriesGroup: group, serie: serie, elementIndex: itemIndex }); if (isNaN(itemIndex)) this._itemsToggleState[groupIndex][serieIndex] = state; else { let s = this._itemsToggleState[groupIndex][serieIndex]; if (!Array.isArray(s)) s = []; while (s.length < itemIndex) s.push(true); s[itemIndex] = state; } this._isToggleRefresh = true; this.update(); this._isToggleRefresh = false; } showSerie(groupIndex, serieIndex, itemIndex) { this._toggleSerie(groupIndex, serieIndex, itemIndex, true); } hideSerie(groupIndex, serieIndex, itemIndex) { this._toggleSerie(groupIndex, serieIndex, itemIndex, false); } /** @private */ _setLegendToggleHandler(groupIndex, serieIndex, itemIndex, element) { let g = this.seriesGroups[groupIndex]; let s = g.series[serieIndex]; let enableSeriesToggle = s.enableSeriesToggle; if (enableSeriesToggle === undefined || enableSeriesToggle === null) enableSeriesToggle = g.enableSeriesToggle !== false; if (enableSeriesToggle) { let self = this; this.renderer.addHandler(element, 'click', function () { //e.preventDefault(); self._toggleSerie(groupIndex, serieIndex, itemIndex); }); } } /** @private */ _renderLegend(rect, isMeasure) { let self = this; let legendData = []; for (let gidx = 0; gidx < self.seriesGroups.length; gidx++) { let g = self.seriesGroups[gidx]; if (g.showLegend === false) continue; for (let sidx = 0; sidx < g.series.length; sidx++) { let s = g.series[sidx]; if (s.showLegend === false) continue; let settings = self._getSerieSettings(gidx, sidx); let legendText; if (g.type === 'pie' || g.type === 'donut') { let xAxis = self._getXAxis(gidx); const fs = s.legendFormatSettings || g.legendFormatSettings || self._getFormatSettings(xAxis) || self._getFormatSettings(s) || self._getFormatSettings(g); let ff = s.legendFormatFunction || g.legendFormatFunction || xAxis.formatFunction || s.formatFunction || g.formatFunction; let dataLength = self._getDataLen(gidx); for (let i = 0; i < dataLength; i++) { legendText = self._getDataValue(i, s.displayText, gidx); legendText = self._formatValue(legendText, fs, ff, gidx, sidx, i); let colors = self._getColors(gidx, sidx, i); legendData.push({ groupIndex: gidx, seriesIndex: sidx, itemIndex: i, text: legendText, css: s.displayTextClass, fillColor: colors.fillColor, lineColor: colors.lineColor, opacity: settings.opacity }); } continue; } const fs = s.legendFormatSettings || g.legendFormatSettings; let ff = s.legendFormatFunction || g.legendFormatFunction; legendText = self._formatValue(s.displayText || s.dataField || '', fs, ff, gidx, sidx, NaN); let colors = self._getSeriesColors(gidx, sidx); let fillColor = this._get([s.legendFillColor, s.legendColor, colors.fillColor]); let lineColor = this._get([s.legendLineColor, s.legendColor, colors.lineColor]); legendData.push({ groupIndex: gidx, seriesIndex: sidx, text: legendText, css: s.displayTextClass, fillColor: fillColor, lineColor: lineColor, opacity: settings.opacity }); } } return self._renderChartLegend(legendData, rect, isMeasure, (self._legendLayout && self.legendLayout.flow === 'vertical')); } _getInterval(settings, baseUnitInterval) { if (!settings) return baseUnitInterval; let unitInterval = this._get([settings.unitInterval, baseUnitInterval]); if (!isNaN(settings.step) && settings.step !== null) unitInterval = settings.step * baseUnitInterval; return unitInterval; } _getOffsets(key, axis, size, stats, settings, padding, valuesOnTicks, baseUnitInterval, useMidVal) { let interval = this._getInterval(settings[key], baseUnitInterval); let vals = []; if (key === '' || (settings[key].visible && settings[key].visible !== 'custom')) vals = this._generateIntervalValues(stats, interval, baseUnitInterval, valuesOnTicks, useMidVal); let offs; if (key !== 'labels') { let xOffsetAdj = valuesOnTicks ? padding.left : 0; if (!valuesOnTicks && baseUnitInterval > 1) { xOffsetAdj = padding.left * (baseUnitInterval + 1); } // special case with a single value if (vals.length === 1) xOffsetAdj *= 2; offs = this._valuesToOffsets(vals, axis, stats, size, padding, false, xOffsetAdj); if (!valuesOnTicks) { let adjust = (padding.left + padding.right) * interval / baseUnitInterval; if (axis.flip) offs.unshift(offs[0] + adjust); else offs.push(offs[offs.length - 1] + adjust); } } else { let xOffsetAdj = padding.left; // special case with a single value if (vals.length === 1) xOffsetAdj *= 2; offs = this._valuesToOffsets(vals, axis, stats, size, padding, valuesOnTicks, xOffsetAdj); } let out = this._arraysToObjectsArray([vals, offs], ['value', 'offset']); if (axis[key] && axis[key].custom) { let customVals = this._objectsArraysToArray(axis[key].custom, 'value'); let customOffs = this._objectsArraysToArray(axis[key].custom, 'offset'); let customValsOffs = this._valuesToOffsets(customVals, axis, stats, size, padding, valuesOnTicks, padding.left); for (let i = 0; i < axis[key].custom.length; i++) { out.push({ value: customVals[i], offset: isNaN(customOffs[i]) ? customValsOffs[i] : customOffs[i] }); } } return out; } /** @private */ _renderXAxis(groupIndex, rect, isMeasure, chartRect) { let self = this; let axis = self._getXAxis(groupIndex); let g = self.seriesGroups[groupIndex]; let swapXY = g.orientation === 'horizontal'; let szMeasure = { width: 0, height: 0 }; let settings = self._getAxisSettings(axis); if (!axis || !settings.visible || g.type === 'spider') return szMeasure; // check if the group has visible series if (!self._isGroupVisible(groupIndex) || this._isPieGroup(groupIndex)) return szMeasure; let valuesOnTicks = self._alignValuesWithTicks(groupIndex); while (self._renderData.length < groupIndex + 1) self._renderData.push({}); // TODO: Update RTL/FLIP flag if (self.rightToLeft) axis.flip = true; let axisSize = swapXY ? rect.height : rect.width; let offsets = self._calculateXOffsets(groupIndex, axisSize); let axisStats = offsets.axisStats; let rangeSelector = axis.rangeSelector && axis.rangeSelector.visible; let selectorSize = 0; if (rangeSelector) { if (!this._moduleRangeSelector) self.error(self.localize('missingReference', { files: 'lw.chart.rangeselector.js' })); selectorSize = this._selectorGetSize(axis); } let isMirror = (swapXY && axis.position === 'right') || (!swapXY && axis.position === 'top'); if (!isMeasure && rangeSelector) { if (swapXY) { rect.width -= selectorSize; if (axis.position !== 'right') rect.x += selectorSize; } else { rect.height -= selectorSize; if (axis.position === 'top') rect.y += selectorSize; } } let renderData = { rangeLength: offsets.rangeLength, itemWidth: offsets.itemWidth, intervalWidth: offsets.intervalWidth, data: offsets, settings: settings, isMirror: isMirror, rect: rect }; self._renderData[groupIndex].xAxis = renderData; let ui = axisStats.interval; if (isNaN(ui)) return szMeasure; if (swapXY) { settings.title.angle -= 90; settings.labels.angle -= 90; } let gridLinesInterval = this._getInterval(settings.gridLines, ui); let tickMarksInterval = this._getInterval(settings.tickMarks, ui); let labelsInterval = this._getInterval(settings.labels, ui); let labelOffsets; let min = axisStats.min; let max = axisStats.max; let padding = offsets.padding; let flip = axis.flip === true || self.rightToLeft; let range = { min: min, max: max }; if (axisStats.logAxis.enabled) { range.min = axisStats.logAxis.minPow; range.max = axisStats.logAxis.maxPow; } if (axis.type === 'date') { settings.gridLines.offsets = this._generateDTOffsets(min, max, axisSize, padding, gridLinesInterval, ui, axisStats.dateTimeUnit, valuesOnTicks, NaN, false, flip); settings.tickMarks.offsets = this._generateDTOffsets(min, max, axisSize, padding, tickMarksInterval, ui, axisStats.dateTimeUnit, valuesOnTicks, NaN, false, flip); labelOffsets = this._generateDTOffsets(min, max, axisSize, padding, labelsInterval, ui, axisStats.dateTimeUnit, valuesOnTicks, NaN, true, flip); } else { settings.gridLines.offsets = this._getOffsets('gridLines', axis, axisSize, axisStats, settings, padding, valuesOnTicks, ui); settings.tickMarks.offsets = this._getOffsets('tickMarks', axis, axisSize, axisStats, settings, padding, valuesOnTicks, ui); labelOffsets = this._getOffsets('labels', axis, axisSize, axisStats, settings, padding, valuesOnTicks, ui); } let oldPositions; if (self._elementRenderInfo && self._elementRenderInfo.length > groupIndex) oldPositions = self._elementRenderInfo[groupIndex].xAxis; let items = []; // prepare the axis labels let ffn; if (settings.labels.formatFunction) ffn = settings.labels.formatFunction; const labelsFormatSettings = self._getFormatSettings(settings.labels); let fs; if (labelsFormatSettings) fs = Object.assign({}, labelsFormatSettings); if (axis.type === 'date') { if (axis.dateFormat && !ffn) { if (fs) fs.dateFormat = fs.dateFormat || axis.dateFormat; else fs = { dateFormat: axis.dateFormat }; } else if (!ffn && (!fs || (fs && !fs.dateFormat))) { ffn = this._getDefaultDTFormatFn(axis.baseUnit || 'day'); } } for (let i = 0; i < labelOffsets.length; i++) { let value = labelOffsets[i].value; let x = labelOffsets[i].offset; if (isNaN(x)) continue; let idx = undefined; if (axis.type !== 'date' && axisStats.useIndeces && axis.dataField) { idx = Math.round(value); value = self._getDataValue(idx, axis.dataField, groupIndex); if (value === undefined || value === null) value = ''; } let text = self._formatValue(value, fs, ffn, groupIndex, undefined, idx); if (text === undefined || text === null || text.toString() === '') { if (isNaN(idx)) idx = i; if (idx >= axisStats.filterRange.min && idx <= axisStats.filterRange.max) text = axisStats.useIndeces ? (axisStats.min + idx).toString() : (value === undefined ? '' : value.toString()); } let obj = { key: value, text: text, targetX: x, x: x }; if (oldPositions && oldPositions.itemOffsets[value]) { obj.x = oldPositions.itemOffsets[value].x; obj.y = oldPositions.itemOffsets[value].y; } items.push(obj); } /// let anim = self._getAnimProps(groupIndex); let duration = anim.enabled && items.length < 500 ? anim.duration : 0; if (self.enableAxisTextAnimation === false) duration = 0; let itemsInfo = { items: items, renderData: renderData }; let sz = self._renderAxis(swapXY, isMirror, settings, { x: rect.x, y: rect.y, width: rect.width, height: rect.height }, chartRect, ui, false, true /*valuesOnTicks*/, itemsInfo, isMeasure, duration); if (swapXY) sz.width += selectorSize; else sz.height += selectorSize; return sz; } /** @private */ _animateAxisText(context, percent) { let items = context.items; let textSettings = context.textSettings; for (let i = 0; i < items.length; i++) { let item = items[i]; if (!item) continue; if (!item.visible) continue; let x = item.targetX; let y = item.targetY; if (!isNaN(item.x) && !isNaN(item.y)) { x = item.x + (x - item.x) * percent; y = item.y + (y - item.y) * percent; } // TODO: Optimize via text reponsitioning. // Requires SVG text rendering changes if (item.element) { this.renderer.removeElement(item.element); item.element = undefined; } item.element = this.renderer.text( item.text, x, y, item.width, item.height, textSettings.angle, { 'class': textSettings.style }, false, textSettings.halign, textSettings.valign, textSettings.textRotationPoint); } } /** @private */ _getPolarAxisCoords(groupIndex, rect) { let group = this.seriesGroups[groupIndex]; let offsetX = rect.x + this._draw.getNum([group.offsetX, rect.width / 2]); let offsetY = rect.y + this._draw.getNum([group.offsetY, rect.height / 2]); let availableSize = Math.min(rect.width, rect.height); let radius = group.radius; if (this._isPercent(radius)) radius = parseFloat(radius) / 100 * availableSize / 2; if (isNaN(radius)) radius = availableSize / 2 * 0.6; let valuesOnTicks = this._alignValuesWithTicks(groupIndex); let startAngle = this._get([group.startAngle, group.minAngle, 0]) - 90; if (isNaN(startAngle)) startAngle = 0; else { startAngle = 2 * Math.PI * startAngle / 360; } let endAngle = this._get([group.endAngle, group.maxAngle, 360]) - 90; if (isNaN(endAngle)) endAngle = 2 * Math.PI; else { endAngle = 2 * Math.PI * endAngle / 360; } if (startAngle > endAngle) { let swap = startAngle; startAngle = endAngle; endAngle = swap; } let axisSizeRatio = this.renderer._rnd(Math.abs(startAngle - endAngle) / (Math.PI * 2), 0.001, true); let axisSize = Math.PI * 2 * radius * axisSizeRatio; let offsets = this._calcGroupOffsets(groupIndex, rect).xoffsets; if (!offsets) return; let isClosedCircle = !(Math.abs(Math.abs(endAngle - startAngle) - Math.PI * 2) > 0.00001), adjRadius; if (group.spider) { const axisStats = this._getXAxisStats(groupIndex, this._getXAxis(groupIndex), axisSize); let interval = axisStats.interval; if (isNaN(interval) || interval === 0) interval = 1; let slices = (axisStats.max - axisStats.min) / interval + (isClosedCircle ? 1 : 0); slices = Math.round(slices); if (slices > 2) { let cos = Math.cos(Math.abs(endAngle - startAngle) / 2 / slices); cos = this.renderer._rnd(cos, 0.01); if (cos === 0) cos = 1 adjRadius = radius / cos; if (adjRadius > radius && valuesOnTicks) radius = adjRadius; } } radius = this.renderer._ptrnd(radius); // axisSize = this.renderer._ptrnd(Math.PI * 2 * radius * axisSizeRatio); return { x: offsetX, y: offsetY, r: radius, adjR: this._get([adjRadius, radius]), itemWidth: offsets.itemWidth, rangeLength: offsets.rangeLength, valuesOnTicks: valuesOnTicks, startAngle: startAngle, endAngle: endAngle, isClosedCircle: isClosedCircle, axisSize: axisSize }; } /** @private */ _toPolarCoord(polarAxisCoords, rect, x, y) { let axisSizeRatio = Math.abs(polarAxisCoords.startAngle - polarAxisCoords.endAngle) / (Math.PI * 2); let angle = (x - rect.x) * 2 * Math.PI * axisSizeRatio / Math.max(1, rect.width) + polarAxisCoords.startAngle; let radius = ((rect.height + rect.y) - y) * polarAxisCoords.r / Math.max(1, rect.height); let px = polarAxisCoords.x + radius * Math.cos(angle); let py = polarAxisCoords.y + radius * Math.sin(angle); return { x: this.renderer._ptrnd(px), y: this.renderer._ptrnd(py) }; } /** @private */ _renderSpiderAxis(groupIndex, rect) { let self = this; let axis = self._getXAxis(groupIndex); let axisSettings = this._getAxisSettings(axis); if (!axis || !axisSettings.visible) return; let group = self.seriesGroups[groupIndex]; let polarCoords = self._getPolarAxisCoords(groupIndex, rect); if (!polarCoords) return; let offsetX = this.renderer._ptrnd(polarCoords.x); let offsetY = this.renderer._ptrnd(polarCoords.y); let radius = polarCoords.adjR; let startAngle = polarCoords.startAngle; let endAngle = polarCoords.endAngle; if (radius < 1) return; let axisSizeRatio = this.renderer._rnd(Math.abs(startAngle - endAngle) / (Math.PI * 2), 0.001, true); let axisSize = Math.PI * 2 * radius * axisSizeRatio; let isClosedCircle = polarCoords.isClosedCircle; let offsets = this._renderData[groupIndex].xoffsets; if (!offsets.rangeLength) return; let ui = offsets.axisStats.interval; if (isNaN(ui) || ui < 1) ui = 1; while (self._renderData.length < groupIndex + 1) self._renderData.push({}); let renderData = { rangeLength: offsets.rangeLength, itemWidth: offsets.itemWidth, data: offsets, rect: rect, settings: axisSettings }; self._renderData[groupIndex].xAxis = renderData; self._renderData[groupIndex].polarCoords = polarCoords; // dedup identical axis drawing let showXAxis = true; for (let i = 0; i < groupIndex; i++) { let polarCoordscompare = self._renderData[i].polarCoords; let xAxisCompare = self._getXAxis(i); let nomatch = false; for (let j in polarCoords) if (polarCoords[j] !== polarCoordscompare[j]) { nomatch = true; break; } if (!nomatch || xAxisCompare !== axis) showXAxis = false; } let gridLinesSettings = axisSettings.gridLines; let tickMarksSettings = axisSettings.tickMarks; let labelsSettings = axisSettings.labels; let gridLinesInterval = this._getInterval(gridLinesSettings, ui); let tickMarksInterval = this._getInterval(tickMarksSettings, ui); let labelsInterval = this._getInterval(labelsSettings, ui); let valuesOnTicks = self._alignValuesWithTicks(groupIndex); let renderer = self.renderer; let labelOffsets; let axisStats = offsets.axisStats; let min = axisStats.min; let max = axisStats.max; let padding = this._getPaddingSize(offsets.axisStats, axis, valuesOnTicks, axisSize, true, isClosedCircle, false); let flip = axis.flip === true || self.rightToLeft; if (axis.type === 'date') { gridLinesSettings.offsets = this._generateDTOffsets(min, max, axisSize, padding, gridLinesInterval, ui, axis.baseUnit, true, 0, false, flip); tickMarksSettings.offsets = this._generateDTOffsets(min, max, axisSize, padding, tickMarksInterval, ui, axis.baseUnit, true, 0, false, flip); labelOffsets = this._generateDTOffsets(min, max, axisSize, padding, labelsInterval, ui, axis.baseUnit, true, 0, true, flip); } else { axisSettings.gridLines.offsets = this._getOffsets('gridLines', axis, axisSize, axisStats, axisSettings, padding, true, ui); axisSettings.tickMarks.offsets = this._getOffsets('tickMarks', axis, axisSize, axisStats, axisSettings, padding, true, ui); labelOffsets = this._getOffsets('labels', axis, axisSize, axisStats, axisSettings, padding, true, ui); } let oldPositions; if (self._elementRenderInfo && self._elementRenderInfo.length > groupIndex) oldPositions = self._elementRenderInfo[groupIndex].xAxis; let items = []; let dataLen = this._getDataLen(groupIndex); for (let i = 0; i < labelOffsets.length; i++) { let x = labelOffsets[i].offset; let value = labelOffsets[i].value, idx; if (axis.type !== 'date' && axisStats.useIndeces && axis.dataField) { idx = Math.round(value); if (idx >= dataLen) continue; value = self._getDataValue(idx, axis.dataField); if (value === undefined || value === null) value = ''; } let text = self._formatValue(value, self._getFormatSettings(labelsSettings.formatSettings), labelsSettings.formatFunction, groupIndex, undefined, idx); if (text === undefined || text === null || text.toString() === '') text = axisStats.useIndeces ? (axisStats.min + i).toString() : (value === undefined || value === null ? '' : value.toString()); let obj = { key: value, text: text, targetX: x, x: x }; if (oldPositions && oldPositions.itemOffsets[value]) { obj.x = oldPositions.itemOffsets[value].x; obj.y = oldPositions.itemOffsets[value].y; } items.push(obj); } // draw the spider let strokeAttributes = { stroke: gridLinesSettings.color || self._getThemeColor('line'), fill: 'none', 'stroke-width': gridLinesSettings.width, 'stroke-dasharray': gridLinesSettings.dashStyle || '' }; if (!group.spider) { if (axisSizeRatio === 1) renderer.circle(offsetX, offsetY, radius, strokeAttributes); else { let aStart = -startAngle / Math.PI * 180; let aEnd = -endAngle / Math.PI * 180; this.renderer.pieslice( offsetX, offsetY, 0, // innerRadius radius, Math.min(aStart, aEnd), Math.max(aStart, aEnd), undefined, strokeAttributes); } } //let cnt = items.length; //let aIncrement = 2 * Math.PI / (cnt); let aIncrementAdj = startAngle; // draw x-axis grid lines if (gridLinesSettings.visible && showXAxis) { if (!valuesOnTicks && !isClosedCircle) { gridLinesSettings.offsets.unshift({ offset: -padding.right }); } for (let i = 0; i < gridLinesSettings.offsets.length; i++) { let offset = gridLinesSettings.offsets[i].offset; if (!valuesOnTicks) { if (isClosedCircle) offset += padding.right / 2; else offset += padding.right; } const angle = aIncrementAdj + offset * 2 * Math.PI * axisSizeRatio / Math.max(1, axisSize); if (angle - endAngle > 0.01) continue; let px = this.renderer._ptrnd(offsetX + radius * Math.cos(angle)); let py = this.renderer._ptrnd(offsetY + radius * Math.sin(angle)); renderer.line(offsetX, offsetY, px, py, strokeAttributes); } } // draw tick marks if (tickMarksSettings.visible && showXAxis) { let tickMarkSize = 5; let ticksStrokeAttributes = { stroke: tickMarksSettings.color || self._getThemeColor('line'), fill: 'none', 'stroke-width': tickMarksSettings.width, 'stroke-dasharray': tickMarksSettings.dashStyle || '' }; if (!valuesOnTicks && !isClosedCircle) { tickMarksSettings.offsets.unshift({ offset: -padding.right }); } for (let i = 0; i < tickMarksSettings.offsets.length; i++) { let offset = tickMarksSettings.offsets[i].offset; if (!valuesOnTicks) { if (isClosedCircle) offset += padding.right / 2; else offset += padding.right; } const angle = aIncrementAdj + offset * 2 * Math.PI * axisSizeRatio / Math.max(1, axisSize); if (angle - endAngle > 0.01) continue; let p1 = { x: offsetX + radius * Math.cos(angle), y: offsetY + radius * Math.sin(angle) }; let p2 = { x: offsetX + (radius + tickMarkSize) * Math.cos(angle), y: offsetY + (radius + tickMarkSize) * Math.sin(angle) }; renderer.line(this.renderer._ptrnd(p1.x), this.renderer._ptrnd(p1.y), this.renderer._ptrnd(p2.x), this.renderer._ptrnd(p2.y), ticksStrokeAttributes); } } let offsetAngles = []; // get spider angles if (group.spider) { let spiderOffsets = []; if (axis.type === 'date') spiderOffsets = this._generateDTOffsets(min, max, axisSize, padding, ui, ui, axis.baseUnit, true, 0, false, flip); else { spiderOffsets = this._getOffsets('', axis, axisSize, axisStats, axisSettings, padding, true, ui); } if (!valuesOnTicks && !isClosedCircle) spiderOffsets.unshift({ offset: -padding.right }); for (let i = 0; i < spiderOffsets.length; i++) { let offset = spiderOffsets[i].offset; if (!valuesOnTicks) { if (isClosedCircle) offset += padding.right / 2; else offset += padding.right; } const angle = aIncrementAdj + offset * 2 * Math.PI * axisSizeRatio / Math.max(1, axisSize); if (angle - endAngle > 0.01) continue; offsetAngles.push(angle); } renderData.offsetAngles = offsetAngles; } // draw value axis let arrRadius = self._renderSpiderValueAxis(groupIndex, rect, (valuesOnTicks ? polarCoords.adjR : polarCoords.r), offsetAngles); if (!arrRadius) arrRadius = []; // draw the spider lines if (group.spider) { if (!valuesOnTicks) { for (let i = 0; i < arrRadius.length; i++) arrRadius[i] = arrRadius[i] * polarCoords.adjR / polarCoords.r; } arrRadius.push(radius); this._renderSpiderLines(offsetX, offsetY, arrRadius, polarCoords, offsetAngles, strokeAttributes); } // draw text items if (showXAxis && labelsSettings.visible) { renderData.polarLabels = []; for (let i = 0; i < items.length; i++) { let offset = items[i].x; let angle = aIncrementAdj + offset * 2 * Math.PI * axisSizeRatio / Math.max(1, axisSize); angle = (360 - angle / (2 * Math.PI) * 360) % 360; if (angle < 0) angle = 360 + angle; let sz = renderer.measureText(items[i].text, 0, { 'class': axisSettings.labels.style }); let labelsRadius = (valuesOnTicks ? polarCoords.adjR : polarCoords.r) + (tickMarksSettings.visible ? 7 : 2); let labels = axisSettings.labels; let labelOffset; if (labels.autoRotate) { let pt1 = this._draw._ptRotate(offsetX - sz.width / 2, offsetY - labelsRadius - sz.height, offsetX, offsetY, -angle / 180 * Math.PI); let pt2 = this._draw._ptRotate(offsetX + sz.width / 2, offsetY - labelsRadius, offsetX, offsetY, -angle / 180 * Math.PI); sz.width = Math.abs(pt1.x - pt2.x); sz.height = Math.abs(pt1.y - pt2.y); labelOffset = { x: Math.min(pt1.x, pt2.x), y: Math.min(pt1.y, pt2.y) }; } else { labelOffset = this._adjustTextBoxPosition( offsetX, offsetY, sz, labelsRadius, angle, false, false, false ); } renderData.polarLabels.push({ x: labelOffset.x, y: labelOffset.y, value: items[i].text }); renderer.text( items[i].text, labelOffset.x, labelOffset.y, sz.width, sz.height, labels.autoRotate ? 90 - angle : labels.angle, { 'class': labels.style }, false, labels.halign, labels.valign); } } } _renderSpiderLines(x, y, arrRadius, polarCoords, offsetAngles, strokeAttributes) { let renderer = this.renderer; let isClosedCircle = polarCoords.isClosedCircle; for (let j = 0; j < arrRadius.length; j++) { let radius = arrRadius[j]; let ptPrev = undefined, ptFirst = undefined; for (let i = 0; i < offsetAngles.length; i++) { let angle = offsetAngles[i]; let px = this.renderer._ptrnd(x + radius * Math.cos(angle)); let py = this.renderer._ptrnd(y + radius * Math.sin(angle)); if (ptPrev) renderer.line(ptPrev.x, ptPrev.y, px, py, strokeAttributes); ptPrev = { x: px, y: py }; if (!ptFirst) ptFirst = { x: px, y: py }; } if (ptFirst && isClosedCircle) renderer.line(ptPrev.x, ptPrev.y, ptFirst.x, ptFirst.y, strokeAttributes); } } /** @private */ _renderSpiderValueAxis(groupIndex, rect, radius, offsetAngles) { var self = this; var group = this.seriesGroups[groupIndex]; var polarCoords = this._getPolarAxisCoords(groupIndex, rect); if (!polarCoords) return; var offsetX = this.renderer._ptrnd(polarCoords.x); var offsetY = this.renderer._ptrnd(polarCoords.y); radius = radius || polarCoords.r; var startAngle = polarCoords.startAngle; var endAngle = polarCoords.endAngle; var axisSizeRatio = this.renderer._rnd(Math.abs(startAngle - endAngle) / (Math.PI * 2), 0.001, true); if (radius < 1) return; radius = this.renderer._ptrnd(radius); var valueAxis = this._getValueAxis(groupIndex); const settings = this._getAxisSettings(valueAxis); if (!valueAxis || false === settings.visible) return; var ui = this._stats.seriesGroups[groupIndex].mu; var labelsSettings = settings.labels; var valueAxisformatSettings = self._getFormatSettings(labelsSettings); var isStacked100 = group.type.indexOf('stacked') !== -1 && group.type.indexOf('100') !== -1; if (isStacked100 && !valueAxisformatSettings) valueAxisformatSettings = { sufix: '%' }; var labelsFrequency = this._get([labelsSettings.step, labelsSettings.unitInterval / ui]); if (isNaN(labelsFrequency)) labelsFrequency = 1; labelsFrequency = Math.max(1, Math.round(labelsFrequency)); this._calcValueAxisItems(groupIndex, radius, labelsFrequency); var gridLines = settings.gridLines; var tickMarks = settings.tickMarks; var labels = settings.labels; var strokeAttributes = { stroke: gridLines.color || self._getThemeColor('line'), fill: 'none', 'stroke-width': 1, 'stroke-dasharray': gridLines.dashStyle || '' }; // draw value axis text var axisRenderData = this._renderData[groupIndex].valueAxis; var items = axisRenderData.items; var angle = startAngle; if (items.length && settings.line.visible) { if (!isNaN(settings.line.angle)) { angle = 2 * Math.PI * settings.line.angle / 360; } var x2 = offsetX + Math.cos(angle) * radius; var y2 = offsetY + Math.sin(angle) * radius; if (offsetAngles.indexOf(angle) === -1) { var lineAttributes = Object.assign({}, strokeAttributes); lineAttributes['stroke-width'] = settings.line.lineWidth; lineAttributes['stroke'] = settings.line.color || self._getThemeColor('line'); lineAttributes['stroke-dasharray'] = settings.line.dashStyle; this.renderer.line(offsetX, offsetY, x2, y2, lineAttributes); } } items = items.reverse(); var renderer = this.renderer; axisRenderData.polarLabels = []; for (let i = 0; i < items.length - 1; i++) { var value = items[i]; if (isNaN(value)) continue; var text = (labels.formatFunction) ? labels.formatFunction(value) : this._formatNumber(value, valueAxisformatSettings); var sz = renderer.measureText(text, 0, { 'class': labels.style }); var x = offsetX + (valueAxis.showTickMarks !== false ? 3 : 2); let y = offsetY - axisRenderData.itemWidth * i - sz.height / 2; { var pt1 = this._draw._ptRotate(x, y, offsetX, offsetY, angle); var pt2 = this._draw._ptRotate(x + sz.width, y + sz.height, offsetX, offsetY, angle); x = Math.min(pt1.x, pt2.x); y = Math.min(pt1.y, pt2.y); sz.width = Math.abs(pt1.x - pt2.x); sz.height = Math.abs(pt1.y - pt2.y); } x += settings.labels.textOffset.x; y += settings.labels.textOffset.y; axisRenderData.polarLabels.push({ x: x, y: y, value: text }); renderer.text( text, x, y, sz.width, sz.height, labels.autoRotate ? (90 + startAngle * 180 / Math.PI) : labels.angle, { 'class': labels.style }, false, labels.halign, labels.valign //'top','left' ); } var valuesOnTicks = valueAxis.valuesOnTicks !== false; var gstat = this._stats.seriesGroups[groupIndex]; var mu = gstat.mu; var logAxis = valueAxis.logarithmicScale === true; if (logAxis) mu = 1; var axisStats = { min: gstat.min, max: gstat.max, logAxis: { enabled: logAxis === true, base: valueAxis.logarithmicScaleBase, minPow: gstat.minPow, maxPow: gstat.maxPow } }; // draw value axis grid lines if (gridLines.visible || group.spider || valueAxis.alternatingBackgroundColor || valueAxis.alternatingBackgroundColor2) { gridLines.offsets = this._getOffsets('gridLines', valueAxis, radius, axisStats, settings, { left: 0, right: 0 }, valuesOnTicks, mu); } var arrRadius = []; if (gridLines.visible || group.spider) { let strokeAttributes = { stroke: gridLines.color || self._getThemeColor('line'), fill: 'none', 'stroke-width': 1, 'stroke-dasharray': gridLines.dashStyle || '' }; for (let i = 0; i < gridLines.offsets.length; i++) { let y = this.renderer._ptrnd(gridLines.offsets[i].offset); if (y === radius) continue; if (group.spider) { arrRadius.push(y); continue; } if (axisSizeRatio !== 1) { var aStart = -startAngle / Math.PI * 180; var aEnd = -endAngle / Math.PI * 180; this.renderer.pieslice( offsetX, offsetY, 0, // innerRadius y, Math.min(aStart, aEnd), Math.max(aStart, aEnd), undefined, strokeAttributes); } else { renderer.circle(offsetX, offsetY, y, strokeAttributes); } } } if (!valueAxis.tickMarks || (!valueAxis.tickMarks.visible && !valueAxis.showTickMarks)) tickMarks.visible = false; // draw value axis tick marks if (tickMarks.visible) { tickMarks.offsets = this._getOffsets('tickMarks', valueAxis, radius, axisStats, settings, { left: 0, right: 0 }, valuesOnTicks, mu); const tickMarkSize = tickMarks.size * 2; let strokeAttributes = { stroke: tickMarks.color || self._getThemeColor('line'), fill: 'none', 'stroke-width': 1, 'stroke-dasharray': tickMarks.dashStyle || '' }; for (let i = 0; i < tickMarks.offsets.length; i++) { var tickMarkRadius = tickMarks.offsets[i].offset; var pt1 = { x: offsetX + tickMarkRadius * Math.cos(angle) - tickMarkSize / 2 * Math.sin(angle + Math.PI / 2), y: offsetY + tickMarkRadius * Math.sin(angle) - tickMarkSize / 2 * Math.cos(angle + Math.PI / 2) }; var pt2 = { x: offsetX + tickMarkRadius * Math.cos(angle) + tickMarkSize / 2 * Math.sin(angle + Math.PI / 2), y: offsetY + tickMarkRadius * Math.sin(angle) + tickMarkSize / 2 * Math.cos(angle + Math.PI / 2) }; renderer.line(this.renderer._ptrnd(pt1.x), this.renderer._ptrnd(pt1.y), this.renderer._ptrnd(pt2.x), this.renderer._ptrnd(pt2.y), strokeAttributes); } } return arrRadius; } /** @private */ _renderAxis(isVertical, isMirror, axisSettings, rect, chartRect, ui, isLogAxis, valuesOnTicks, itemsInfo, isMeasure, animationDuration) { if (axisSettings.customDraw && !isMeasure) return { width: NaN, height: NaN }; let titleSettings = axisSettings.title, textSettings = axisSettings.labels, tickMarksSettings = axisSettings.tickMarks, axisPadding = axisSettings.padding; let tickMarkSize = tickMarksSettings.visible ? tickMarksSettings.size : 0; let padding = 2; let szMeasure = { width: 0, height: 0 }; let szMeasureDesc = { width: 0, height: 0 }; if (isVertical) szMeasure.height = szMeasureDesc.height = rect.height; else szMeasure.width = szMeasureDesc.width = rect.width; if (!isMeasure && isMirror) { if (isVertical) rect.x -= rect.width; } let renderData = itemsInfo.renderData; let itemWidth = renderData.itemWidth; if (titleSettings.visible && titleSettings.text !== undefined && titleSettings.text !== null && titleSettings !== '') { let angle = titleSettings.angle; let sz = this.renderer.measureText(titleSettings.text, angle, { 'class': titleSettings.style }); szMeasureDesc.width = sz.width; szMeasureDesc.height = sz.height; if (!isMeasure) { this.renderer.text( titleSettings.text, rect.x + titleSettings.offset.x + (isVertical ? (!isMirror ? padding + axisPadding.left : -axisPadding.right - padding + 2 * rect.width - szMeasureDesc.width) : 0), rect.y + titleSettings.offset.y + (!isVertical ? (!isMirror ? rect.height - padding - szMeasureDesc.height - axisPadding.bottom : axisPadding.top + padding) : 0), isVertical ? szMeasureDesc.width : rect.width, !isVertical ? szMeasureDesc.height : rect.height, angle, { 'class': titleSettings.style }, true, titleSettings.halign, titleSettings.valign, titleSettings.rotationPoint); } } let offset = 0; let textXAdjust = valuesOnTicks ? -itemWidth / 2 : 0; if (valuesOnTicks && !isVertical) { textSettings.halign = 'center'; } let baseX = rect.x; let baseY = rect.y; let userOffset = textSettings.textOffset; if (userOffset) { if (!isNaN(userOffset.x)) baseX += userOffset.x; if (!isNaN(userOffset.y)) baseY += userOffset.y; } if (!isVertical) { baseX += textXAdjust; if (isMirror) { baseY += szMeasureDesc.height > 0 ? szMeasureDesc.height + 3 * padding : 2 * padding; baseY += tickMarkSize - (valuesOnTicks ? tickMarkSize : tickMarkSize / 4); } else { baseY += valuesOnTicks ? tickMarkSize : tickMarkSize / 4; } baseY += axisPadding.top; } else { baseX += axisPadding.left + padding + (szMeasureDesc.width > 0 ? szMeasureDesc.width + padding : 0) + (isMirror ? rect.width - szMeasureDesc.width : 0); baseY += textXAdjust; } let h = 0; let w = 0; let items = itemsInfo.items; renderData.itemOffsets = {}; if (this._isToggleRefresh || !this._isUpdate) animationDuration = 0; let canAnimate = false; let widthSum = 0; for (let i = 0; i < items.length && textSettings.visible; i++ , offset += itemWidth) { if (!items[i] || isNaN(itemWidth)) continue; let text = items[i].text; if (!isNaN(items[i].targetX)) offset = items[i].targetX; let sz = this.renderer.measureText(text, textSettings.angle, { 'class': textSettings.style }); if (sz.width > w) w = sz.width; if (sz.height > h) h = sz.height; widthSum += isVertical ? h : w; if (!isMeasure) { if ((isVertical && offset > rect.height + 2) || (!isVertical && offset > rect.width + 2)) continue; const x = isVertical ? baseX + (isMirror ? (szMeasureDesc.width === 0 ? tickMarkSize : tickMarkSize - padding) : 0) : baseX + offset; let y = isVertical ? baseY + offset : baseY; renderData.itemOffsets[items[i].key] = { x: x, y: y }; if (!canAnimate) if (!isNaN(items[i].x) || !isNaN(items[i].y) && animationDuration) canAnimate = true; items[i].targetX = x; items[i].targetY = y; items[i].width = !isVertical ? itemWidth : rect.width - axisPadding.left - axisPadding.right - 2 * padding - tickMarkSize - ((szMeasureDesc.width > 0) ? szMeasureDesc.width + padding : 0); items[i].height = isVertical ? itemWidth : rect.height - axisPadding.top - axisPadding.bottom - 2 * padding - tickMarkSize - ((szMeasureDesc.height > 0) ? szMeasureDesc.height + padding : 0); items[i].visible = true; } } renderData.avgWidth = items.length === 0 ? 0 : widthSum / items.length; if (!isMeasure) { let ctx = { items: items, textSettings: textSettings }; if (isNaN(animationDuration) || !canAnimate) animationDuration = 0; this._animateAxisText(ctx, animationDuration === 0 ? 1 : 0); if (animationDuration !== 0) { let self = this; this._enqueueAnimation( 'series', undefined, undefined, animationDuration, function (element, ctx, percent) { self._animateAxisText(ctx, percent); }, ctx); } } szMeasure.width += 2 * padding + tickMarkSize + szMeasureDesc.width + w + (isVertical && szMeasureDesc.width > 0 ? padding : 0); szMeasure.height += 2 * padding + tickMarkSize + szMeasureDesc.height + h + (!isVertical && szMeasureDesc.height > 0 ? padding : 0); if (!isVertical) szMeasure.height += axisPadding.top + axisPadding.bottom; else szMeasure.width += axisPadding.left + axisPadding.right; if (!isMeasure && axisSettings.line.visible) { let lineAttributes = { stroke: axisSettings.line.color || self._getThemeColor('line'), 'stroke-width': axisSettings.line.width, 'stroke-dasharray': axisSettings.line.dashStyle || '' }; if (isVertical) { let x = rect.x + rect.width + (isMirror ? axisPadding.left : -axisPadding.right); x = this.renderer._ptrnd(x); this.renderer.line(x, rect.y, x, rect.y + rect.height, lineAttributes); } else { let y = this.renderer._ptrnd(rect.y + (isMirror ? rect.height - axisPadding.bottom : axisPadding.top)); this.renderer.line(this.renderer._ptrnd(rect.x), y, this.renderer._ptrnd(rect.x + rect.width + 1), y, lineAttributes); } } szMeasure.width = this.renderer._rup(szMeasure.width); szMeasure.height = this.renderer._rup(szMeasure.height); return szMeasure; } _drawPlotAreaLines(groupIndex, isValueAxis, itemsToDraw) { var g = this.seriesGroups[groupIndex]; var swapXY = g.orientation !== 'horizontal'; if (!this._renderData || this._renderData.length <= groupIndex) return; var key = isValueAxis ? 'valueAxis' : 'xAxis'; var renderData = this._renderData[groupIndex][key]; if (!renderData) return; var state = this._renderData.axisDrawState; if (!state) state = this._renderData.axisDrawState = {}; var axisKey = '', axis; if (isValueAxis) { axisKey = 'valueAxis_' + ((g.valueAxis) ? groupIndex : '') + (swapXY ? 'swap' : ''); axis = this._getValueAxis(groupIndex); } else { axisKey = 'xAxis_' + (g.xAxis ? groupIndex : '') + (swapXY ? 'swap' : ''); axis = this._getXAxis(groupIndex); } if (state[axisKey]) state = state[axisKey]; else state = state[axisKey] = {}; if (!isValueAxis) swapXY = !swapXY; var settings = renderData.settings; if (!settings) return; if (settings.customDraw) return; var gridLinesSettings = settings.gridLines, tickMarksSettings = settings.tickMarks, padding = settings.padding; var rect = renderData.rect; var chartRect = this._plotRect; if (!gridLinesSettings || !tickMarksSettings) return; var rndErr = 0.5 var gridLinePts = {}; let strokeAttributes = { stroke: gridLinesSettings.color || self._getThemeColor('line'), 'stroke-width': gridLinesSettings.width, 'stroke-dasharray': gridLinesSettings.dashStyle || '' }; // render grid lines & alternate background colors var startOffset = isValueAxis ? rect.y + rect.height : rect.x; var offsets = gridLinesSettings.offsets; if (isValueAxis && !axis.flip) { //offsets = $.extend([], offsets); offsets = offsets.slice(0); offsets = offsets.reverse(); } let lineOffset; if (offsets && offsets.length > 0) { var prevOffset = NaN; for (let i = 0; i < offsets.length; i++) { if (swapXY) { lineOffset = this.renderer._ptrnd(rect.y + offsets[i].offset); if (lineOffset < rect.y - rndErr) lineOffset = this.renderer._ptrnd(rect.y); if (lineOffset > rect.y + rect.height) lineOffset = rect.y + rect.height; } else { lineOffset = this.renderer._ptrnd(rect.x + offsets[i].offset); if (lineOffset > rect.x + rect.width + rndErr) lineOffset = this.renderer._ptrnd(rect.x + rect.width); } if (isNaN(lineOffset)) continue; if (!isNaN(prevOffset) && Math.abs(lineOffset - prevOffset) < 2) continue; prevOffset = lineOffset; if (itemsToDraw.gridLines && gridLinesSettings.visible !== false && state.gridLines !== true) { if (swapXY) this.renderer.line(this.renderer._ptrnd(chartRect.x), lineOffset, this.renderer._ptrnd(chartRect.x + chartRect.width), lineOffset, strokeAttributes); else this.renderer.line(lineOffset, this.renderer._ptrnd(chartRect.y), lineOffset, this.renderer._ptrnd(chartRect.y + chartRect.height), strokeAttributes); } gridLinePts[lineOffset] = true; if (itemsToDraw.alternatingBackground && (gridLinesSettings.alternatingBackgroundColor || gridLinesSettings.alternatingBackgroundColor2) && state.alternatingBackground !== true) { var fillColor = ((i % 2) === 0) ? gridLinesSettings.alternatingBackgroundColor2 : gridLinesSettings.alternatingBackgroundColor; if (i > 0 && fillColor) { var rectElement; if (swapXY) rectElement = this.renderer.rect(this.renderer._ptrnd(chartRect.x), startOffset, this.renderer._ptrnd(chartRect.width - 1), lineOffset - startOffset, strokeAttributes); else rectElement = this.renderer.rect(startOffset, this.renderer._ptrnd(chartRect.y), lineOffset - startOffset, this.renderer._ptrnd(chartRect.height), strokeAttributes); this.renderer.attr(rectElement, { 'stroke-width': 0, fill: fillColor, opacity: gridLinesSettings.alternatingBackgroundOpacity || 1 }); } } startOffset = lineOffset; } // for } // render axis tick marks strokeAttributes = { stroke: tickMarksSettings.color || self._getThemeColor('line'), 'stroke-width': tickMarksSettings.width, 'stroke-dasharray': tickMarksSettings.dashStyle || '' }; if (itemsToDraw.tickMarks && tickMarksSettings.visible && state.tickMarks !== true) { var tickMarkSize = tickMarksSettings.size; let offsets = tickMarksSettings.offsets; var prevOffset = NaN; for (let i = 0; i < offsets.length; i++) { if (swapXY) { lineOffset = this.renderer._ptrnd(rect.y + offsets[i].offset); if (lineOffset < rect.y - rndErr) lineOffset = this.renderer._ptrnd(rect.y); if (lineOffset > rect.y + rect.height) lineOffset = rect.y + rect.height; } else { lineOffset = this.renderer._ptrnd(rect.x + offsets[i].offset); if (lineOffset > rect.x + rect.width + rndErr) lineOffset = this.renderer._ptrnd(rect.x + rect.width); } if (isNaN(lineOffset)) continue; if (!isNaN(prevOffset) && Math.abs(lineOffset - prevOffset) < 2) continue; if (gridLinePts[lineOffset - 1]) lineOffset--; else if (gridLinePts[lineOffset + 1]) lineOffset++; if (swapXY) { if (lineOffset > rect.y + rect.height + rndErr) break; } else { if (lineOffset > rect.x + rect.width + rndErr) break; } prevOffset = lineOffset; var tickSize = !renderData.isMirror ? -tickMarkSize : tickMarkSize; if (swapXY) { var x = rect.x + rect.width + (axis.position === 'right' ? padding.left : -padding.right); if (!isValueAxis) x = rect.x + (renderData.isMirror ? padding.left : -padding.right + rect.width); this.renderer.line(x, lineOffset, x + tickSize, lineOffset, strokeAttributes); } else { var y = rect.y + (renderData.isMirror ? rect.height : 0); y += renderData.isMirror ? -padding.bottom : padding.top; y = this.renderer._ptrnd(y); this.renderer.line(lineOffset, y, lineOffset, y - tickSize, strokeAttributes); } } } state.tickMarks = state.tickMarks || itemsToDraw.tickMarks; state.gridLines = state.gridLines || itemsToDraw.gridLines; state.alternatingBackground = state.alternatingBackground || itemsToDraw.alternatingBackground; } /** @private */ _calcValueAxisItems(groupIndex, axisLength, labelsFrequency) { let gstat = this._stats.seriesGroups[groupIndex]; if (!gstat || !gstat.isValid) { return false; } let g = this.seriesGroups[groupIndex]; let axis = this._getValueAxis(groupIndex); let valuesOnTicks = axis.valuesOnTicks !== false; let ints = gstat.intervals; let unitH = axisLength / ints; let min = gstat.min; let mu = gstat.mu; let logAxis = axis.logarithmicScale === true; let logBase = axis.logarithmicScaleBase || 10; let isStacked100 = g.type.indexOf('stacked') !== -1 && g.type.indexOf('100') !== -1; if (logAxis) mu = !isNaN(axis.unitInterval) ? axis.unitInterval : 1; if (!valuesOnTicks) ints = Math.max(ints - 1, 1); while (this._renderData.length < groupIndex + 1) this._renderData.push({}); this._renderData[groupIndex].valueAxis = {}; let renderData = this._renderData[groupIndex].valueAxis; renderData.itemWidth = renderData.intervalWidth = unitH; renderData.items = []; let items = renderData.items; for (let i = 0; i <= ints; i++) { let value = 0; if (logAxis) { if (isStacked100) value = gstat.max / Math.pow(logBase, ints - i); else value = min * Math.pow(logBase, i); } else { value = valuesOnTicks ? min + i * mu : min + (i + 0.5) * mu; } if (i % labelsFrequency !== 0) { items.push(NaN); continue; } items.push(value); } renderData.rangeLength = logAxis && !isStacked100 ? gstat.intervals : (gstat.intervals) * mu; if (axis.flip !== true) items = items.reverse(); return true; } _getDecimalPlaces(arr, key, limit) { let decimalPlaces = 0; if (isNaN(limit)) limit = 10; for (let i = 0; i < arr.length; i++) { let value = key === undefined ? arr[i] : arr[i][key]; if (isNaN(value)) continue; let valueTxt = value.toString(); for (let j = 0; j < valueTxt.length; j++) { if (valueTxt[j] < '0' || valueTxt[j] > '9') { decimalPlaces = valueTxt.length - (j + 1); if (decimalPlaces >= 0) return Math.min(decimalPlaces, limit); } } if (decimalPlaces > 0) value *= Math.pow(10, decimalPlaces); while (Math.round(value) !== value && decimalPlaces < limit) { decimalPlaces++; value *= 10; } } return decimalPlaces; } /** @private */ _renderValueAxis(groupIndex, rect, isMeasure, chartRect) { let g = this.seriesGroups[groupIndex]; let swapXY = g.orientation === 'horizontal'; let axis = this._getValueAxis(groupIndex); if (!axis) this.error(this.localize('missingAxis', { index: groupIndex, axis: 'valueAxis' })); let szMeasure = { width: 0, height: 0 }; if (!this._isGroupVisible(groupIndex) || this._isPieOnlySeries() || g.type === 'spider') return szMeasure; let valuesOnTicks = axis.valuesOnTicks !== false; let gstat = this._stats.seriesGroups[groupIndex]; let mu = gstat.mu; let logAxis = axis.logarithmicScale === true; let logBase = axis.logarithmicScaleBase || 10; if (logAxis) mu = !isNaN(axis.unitInterval) ? axis.unitInterval : 1; if (mu === 0) mu = 1; if (isNaN(mu)) return szMeasure; let axisSettings = this._getAxisSettings(axis); let titleSettings = axisSettings.title, labelsSettings = axisSettings.labels; let labels = axis.labels || {}; let halign = this._get([axis.horizontalTextAlignment, labels.horizontalAlignment]); if (!halign && labelsSettings.angle === 0) labelsSettings.halign = swapXY ? 'center' : (axis.position === 'right' ? 'left' : 'right'); let labelsFrequency = this._get([labelsSettings.step, labelsSettings.unitInterval / mu]); if (isNaN(labelsFrequency)) labelsFrequency = 1; labelsFrequency = Math.max(1, Math.round(labelsFrequency)); if (!this._calcValueAxisItems(groupIndex, (swapXY ? rect.width : rect.height), labelsFrequency) || !axisSettings.visible) return szMeasure; if (!swapXY) { titleSettings.angle = (!this.rightToLeft ? -90 : 90); if (titleSettings.rotationPoint === 'centercenter') { if (titleSettings.valign === 'top') titleSettings.rotationPoint = 'rightcenter'; else if (titleSettings.valign === 'bottom') titleSettings.rotationPoint = 'leftcenter'; } } let renderData = this._renderData[groupIndex].valueAxis; let formatSettings = this._getFormatSettings(labelsSettings); let isStacked100 = g.type.indexOf('stacked') !== -1 && g.type.indexOf('100') !== -1; if (isStacked100 && !formatSettings) formatSettings = { sufix: '%' }; if (!labelsSettings.formatFunction && (!formatSettings || (formatSettings.decimalPlaces === null || formatSettings.decimalPlaces === undefined))) { formatSettings = formatSettings || {}; formatSettings.decimalPlaces = this._getDecimalPlaces([gstat.min, gstat.max, mu], undefined, 3); } let gridLines = axisSettings.gridLines; let axisSize = swapXY ? rect.width : rect.height; let flip = (axis.flip === true); // force verse due to y-axis layout axis.flip = !flip; let axisStats = { min: gstat.min, max: gstat.max, logAxis: { enabled: logAxis === true, base: logBase, minPow: gstat.minPow, maxPow: gstat.maxPow } }; if (gridLines.visible || axis.alternatingBackgroundColor || axis.alternatingBackgroundColor2) { gridLines.offsets = this._getOffsets('gridLines', axis, axisSize, axisStats, axisSettings, { left: 0, right: 0 }, valuesOnTicks, mu); } let tickMarks = axisSettings.tickMarks; if (tickMarks.visible) { tickMarks.offsets = this._getOffsets('tickMarks', axis, axisSize, axisStats, axisSettings, { left: 0, right: 0 }, valuesOnTicks, mu); } const labelOffsets = this._getOffsets('labels', axis, axisSize, axisStats, axisSettings, { left: 0, right: 0 }, valuesOnTicks, mu, !valuesOnTicks); // restore original value axis.flip = flip; let items = []; let oldPositions; if (this._elementRenderInfo && this._elementRenderInfo.length > groupIndex) oldPositions = this._elementRenderInfo[groupIndex].valueAxis; for (let i = 0; i < labelOffsets.length; i++) { let value = labelOffsets[i].value; if (isNaN(labelOffsets[i].offset)) { items.push(undefined); continue; } let text = (labelsSettings.formatFunction) ? labelsSettings.formatFunction(value) : (!isNaN(value)) ? this._formatNumber(value, formatSettings) : value; let obj = { key: value, text: text }; if (oldPositions && oldPositions.itemOffsets[value]) { obj.x = oldPositions.itemOffsets[value].x; obj.y = oldPositions.itemOffsets[value].y; } obj.targetX = labelOffsets[i].offset; if (!isNaN(obj.targetX)) items.push(obj); } let isMirror = (swapXY && axis.position === 'top') || (!swapXY && axis.position === 'right') || (!swapXY && this.rightToLeft && axis.position !== 'left'); let itemsInfo = { items: items, renderData: renderData }; let anim = this._getAnimProps(groupIndex); let duration = anim.enabled && items.length < 500 ? anim.duration : 0; if (this.enableAxisTextAnimation === false) duration = 0; renderData.settings = axisSettings; renderData.isMirror = isMirror; renderData.rect = rect; return this._renderAxis(!swapXY, isMirror, axisSettings, rect, chartRect, mu, logAxis, true, itemsInfo, isMeasure, duration); } _objectsArraysToArray(array, key) { let out = []; if (!Array.isArray(array)) return out; for (let i = 0; i < array.length; i++) out.push(array[i][key]); return out; } _arraysToObjectsArray(arrays, keys) { let out = []; if (arrays.length !== keys.length) return out; for (let i = 0; i < arrays.length; i++) { for (let j = 0; j < arrays[i].length; j++) { if (out.length <= j) out.push({}); out[j][keys[i]] = arrays[i][j]; } } return out; } _valuesToOffsets(values, axis, stats, size, padding, valuesOnTicks, offsetAdj) { let out = []; if (!axis || !Array.isArray(values)) return out; let logBase = stats.logAxis.base; let type = stats.logAxis.enabled ? 'logarithmic' : 'linear'; let flip = axis.flip; let paddedSize = size; let leftPadding = 0, rightPadding = 0; if (padding && !isNaN(padding.left)) { leftPadding = padding.left; } if (padding && !isNaN(padding.right)) { rightPadding = padding.right; } paddedSize = size - leftPadding - rightPadding; size = paddedSize; // TODO: values on ticks is not needed as param for (let i = 0; i < values.length; i++) { let x = this._lwPlot.scale( values[i], { min: stats.min.valueOf(), max: stats.max.valueOf(), type: type, base: logBase }, { min: 0, max: valuesOnTicks ? size : paddedSize, flip: flip }, { // 'ignore_range': true } ); if (!isNaN(x)) { if (!isNaN(offsetAdj)) x += offsetAdj; if (x <= size + leftPadding + rightPadding + 1) out.push(this.renderer._ptrnd(x)); else out.push(NaN); } else out.push(NaN); } return out; } _generateIntervalValues(axisStats, interval, baseInterval, valuesOnTicks, useMidVal) { let intervals = []; let min = axisStats.min; let max = axisStats.max; if (axisStats.logAxis && axisStats.logAxis.enabled) { min = axisStats.logAxis.minPow; max = axisStats.logAxis.maxPow; } if (min === undefined || min === null || max === undefined || max === null) return intervals; if (min === max) { if (axisStats.logAxis && axisStats.logAxis.enabled) return [Math.pow(axisStats.logAxis.base, min)]; else return [min]; } let factor = 1; if (baseInterval < 1) { // adjust to bigger number to avoid js rounding issues factor = 1000000; min *= factor; max *= factor; baseInterval *= factor; } for (let i = min; i <= max; i += baseInterval) intervals.push(i / factor + (useMidVal ? baseInterval / 2 : 0)); if (interval > baseInterval) { let out = []; let ratio = Math.round(interval / baseInterval); for (let i = 0; i < intervals.length; i++) if ((i % ratio) === 0) out.push(intervals[i]); intervals = out; } if (axisStats.logAxis && axisStats.logAxis.enabled) { for (let i = 0; i < intervals.length; i++) intervals[i] = Math.pow(axisStats.logAxis.base, intervals[i]); } return intervals; } /** @private */ _generateDTOffsets(min, max, axisSize, padding, interval, baseInterval, dateTimeUnit, isTicksMode, tickPadding, isValue, flip) { if (!dateTimeUnit) dateTimeUnit = 'day'; var offsets = []; if (min > max) return offsets; if (min === max) { if (isValue) offsets.push({ offset: isTicksMode ? axisSize / 2 : padding.left, value: min }); else if (isTicksMode) offsets.push({ offset: axisSize / 2, value: min }); return offsets; } var paddedSize = axisSize - padding.left - padding.right; var curr = min; var initialOffset = padding.left; var offset = initialOffset; baseInterval = Math.max(baseInterval, 1); var realInterval = baseInterval; var frac = Math.min(1, baseInterval); if (baseInterval > 1 && dateTimeUnit !== 'millisecond') baseInterval = 1; while (this.renderer._ptrnd(offset) <= this.renderer._ptrnd(padding.left + paddedSize + (isTicksMode ? 0 : padding.right))) { offsets.push({ offset: offset, value: curr }); var date = new Date(curr.valueOf()); if (dateTimeUnit === 'millisecond') date.setMilliseconds(curr.getMilliseconds() + baseInterval); else if (dateTimeUnit === 'second') date.setSeconds(curr.getSeconds() + baseInterval); else if (dateTimeUnit === 'minute') date.setMinutes(curr.getMinutes() + baseInterval); else if (dateTimeUnit === 'hour') { var before = date.valueOf(); date.setHours(curr.getHours() + baseInterval); if (before === date.valueOf()) // DST FF bug date.setHours(curr.getHours() + baseInterval + 1); } else if (dateTimeUnit === 'day') date.setDate(curr.getDate() + baseInterval); else if (dateTimeUnit === 'month') date.setMonth(curr.getMonth() + baseInterval); else if (dateTimeUnit === 'year') date.setFullYear(curr.getFullYear() + baseInterval); curr = date; offset = initialOffset + (curr.valueOf() - min.valueOf()) * frac / (max.valueOf() - min.valueOf()) * paddedSize; } if (flip) { for (let i = 0; i < offsets.length; i++) offsets[i].offset = axisSize - offsets[i].offset; } if (realInterval > 1 && dateTimeUnit !== 'millisecond') { var out = []; for (let i = 0; i < offsets.length; i += realInterval) out.push({ offset: offsets[i].offset, value: offsets[i].value }); offsets = out; } if (!isTicksMode && !isValue && offsets.length > 1) { var out = []; out.push({ offset: 0, value: undefined }); for (let i = 1; i < offsets.length; i++) { out.push({ offset: offsets[i - 1].offset + (offsets[i].offset - offsets[i - 1].offset) / 2, value: undefined }); } var len = out.length; if (len > 1) out.push({ offset: out[len - 1].offset + (out[len - 1].offset - out[len - 2].offset) }); else out.push({ offset: axisSize, value: undefined }); offsets = out; } if (interval > baseInterval) { var out = []; var ratio = Math.round(interval / realInterval); for (let i = 0; i < offsets.length; i++) if ((i % ratio) === 0) out.push({ offset: offsets[i].offset, value: offsets[i].value }); offsets = out; } return offsets; } _hasStackValueReversal(groupIndex, gbase) { let group = this.seriesGroups[groupIndex]; let isStacked = -1 !== group.type.indexOf('stacked'); if (!isStacked) return false; let isWaterfall = -1 !== group.type.indexOf('waterfall'); let len = this._getDataLen(groupIndex); let waterfallStackSum = 0; let stackIntialized = false; let seriesVisibility = []; for (let j = 0; j < group.series.length; j++) seriesVisibility[j] = this._isSerieVisible(groupIndex, j); for (let i = 0; i < len; i++) { let isDirectionDown = undefined; if (!isWaterfall) stackIntialized = false; for (let sidx = 0; sidx < group.series.length; sidx++) { if (!seriesVisibility[sidx]) continue; const val = this._getDataValueAsNumber(i, group.series[sidx].dataField, groupIndex); if (isNaN(val)) continue; if (group.series[sidx].summary) { let summary = this._getDataValue(i, group.series[sidx].summary, groupIndex); if (undefined !== summary) continue; } let currDirectionDown = !stackIntialized ? val < gbase : val < 0; stackIntialized = true; if (isDirectionDown === undefined) isDirectionDown = currDirectionDown; if (currDirectionDown !== isDirectionDown) return true; isDirectionDown = currDirectionDown; waterfallStackSum += val; } } return false; } _getValueAxis(groupIndex) { let valueAxis = groupIndex === undefined || groupIndex === null ? this.valueAxis : this.seriesGroups[groupIndex].valueAxis || this.valueAxis; if (!valueAxis) valueAxis = this.valueAxis = {}; return valueAxis; } /** @private */ _buildStats(rect) { var stat = { seriesGroups: [] }; this._stats = stat; for (let gidx = 0; gidx < this.seriesGroups.length; gidx++) { var group = this.seriesGroups[gidx]; stat.seriesGroups[gidx] = {}; var xAxis = this._getXAxis(gidx); var valueAxis = this._getValueAxis(gidx); var xAxisStats = this._getXAxisStats(gidx, xAxis, (group.orientation !== 'horizontal') ? rect.width : rect.height); let grst = stat.seriesGroups[gidx]; grst.isValid = true; var valueAxisSize = (group.orientation === 'horizontal') ? rect.width : rect.height; var logAxis = valueAxis.logarithmicScale === true; var logBase = valueAxis.logarithmicScaleBase; if (isNaN(logBase)) logBase = 10; var isStacked = -1 !== group.type.indexOf('stacked'); var isStacked100 = isStacked && -1 !== group.type.indexOf('100'); var isRange = -1 !== group.type.indexOf('range'); var isWaterfall = group.type.indexOf('waterfall') !== -1; if (isWaterfall && !this._moduleWaterfall) self.error(self.localize('missingReference', { files: 'lw.chart.waterfall.js' })); if (isStacked100) { grst.psums = []; grst.nsums = []; } var gmin = NaN, gmax = NaN; var gsumP = NaN, gsumN = NaN; var gbase = valueAxis ? valueAxis.baselineValue : NaN; if (isNaN(gbase)) gbase = logAxis && !isStacked100 ? 1 : 0; var hasStackValueReversal = false; if (gbase !== 0 && isStacked) { hasStackValueReversal = this._hasStackValueReversal(gidx, gbase); if (hasStackValueReversal) gbase = 0; } if (isStacked && isWaterfall) hasStackValueReversal = this._hasStackValueReversal(gidx, gbase); var len = this._getDataLen(gidx); var gMaxRange = 0; var minPercent = NaN; var seriesPrevValue = []; if (isWaterfall) { // init series prev value array for waterfall series for (let sidx = 0; sidx < group.series.length; sidx++) seriesPrevValue.push(NaN); } var prevValueWaterfall = NaN; for (let i = 0; i < len && grst.isValid; i++) { if (xAxis.rangeSelector && xAxis.rangeSelector.visible) { var xAxisValue = xAxis.dataField ? this._getDataValue(i, xAxis.dataField, gidx) : i; if (xAxisValue && xAxisStats.isDateTime) xAxisValue = this._castAsDate(xAxisValue, xAxis.dateFormat); if (xAxisStats.useIndeces) xAxisValue = i; // skip values outside of xAxis min/max if (xAxisValue && (xAxisValue.valueOf() < xAxisStats.min.valueOf() || xAxisValue.valueOf() > xAxisStats.max.valueOf())) continue; } var min = valueAxis.minValue; var max = valueAxis.maxValue; if (/*hasValueAxis && */valueAxis.baselineValue) { if (isNaN(min)) min = gbase; else min = Math.min(gbase, min); if (isNaN(max)) max = gbase; else max = Math.max(gbase, max); } var sumP = 0, sumN = 0; for (let sidx = 0; group.series && sidx < group.series.length; sidx++) { if (!this._isSerieVisible(gidx, sidx)) continue; var val = NaN, valMax = NaN, valMin = NaN; if (group.type.indexOf('candle') !== -1 || group.type.indexOf('ohlc') !== -1) { var fields = ['Open', 'Low', 'Close', 'High']; for (var j in fields) { var valField = this._getDataValueAsNumber(i, group.series[sidx]['dataField' + fields[j]], gidx); if (isNaN(valField)) continue; valMin = isNaN(valMax) ? valField : Math.min(valMin, valField); valMax = isNaN(valMax) ? valField : Math.max(valMax, valField); } } else { if (isRange) { var valFrom = this._getDataValueAsNumber(i, group.series[sidx].dataFieldFrom, gidx); var valTo = this._getDataValueAsNumber(i, group.series[sidx].dataFieldTo, gidx); valMax = Math.max(valFrom, valTo); valMin = Math.min(valFrom, valTo); } else { val = this._getDataValueAsNumber(i, group.series[sidx].dataField, gidx); if (isWaterfall) { if (this._isSummary(gidx, i)) { var summary = this._getDataValue(i, group.series[sidx].summary, gidx); if (summary !== undefined) continue; } if (!isStacked) { if (isNaN(seriesPrevValue[sidx])) seriesPrevValue[sidx] = val; else val += seriesPrevValue[sidx]; seriesPrevValue[sidx] = val; } else { if (!isNaN(prevValueWaterfall)) val += prevValueWaterfall; prevValueWaterfall = val; } } if (isNaN(val) || (logAxis && val <= 0)) continue; valMin = valMax = val; } } if ((isNaN(max) || valMax > max) && ((isNaN(valueAxis.maxValue)) ? true : valMax <= valueAxis.maxValue)) max = valMax; if ((isNaN(min) || valMin < min) && ((isNaN(valueAxis.minValue)) ? true : valMin >= valueAxis.minValue)) min = valMin; if (!isNaN(val) && isStacked && !isWaterfall) { if (val > gbase) sumP += val; else if (val < gbase) sumN += val; } } // for sidx // stacked series fit within min-max settings if (!isStacked100) {// && hasValueAxis) { if (!isNaN(valueAxis.maxValue)) sumP = Math.min(valueAxis.maxValue, sumP); if (!isNaN(valueAxis.minValue)) sumN = Math.max(valueAxis.minValue, sumN); } if (logAxis && isStacked100) { for (let sidx = 0; sidx < group.series.length; sidx++) { if (!this._isSerieVisible(gidx, sidx)) { minPercent = 0.01; continue; } var val = this._getDataValueAsNumber(i, group.series[sidx].dataField, gidx); if (isNaN(val) || val <= 0) { minPercent = 0.01; continue; } var p = sumP === 0 ? 0 : val / sumP; if (isNaN(minPercent) || p < minPercent) minPercent = p; } } var range = sumP - sumN; if (gMaxRange < range) gMaxRange = range; if (isStacked100) { grst.psums[i] = sumP; grst.nsums[i] = sumN; } if (max > gmax || isNaN(gmax)) gmax = max; if (min < gmin || isNaN(gmin)) gmin = min; if (sumP > gsumP || isNaN(gsumP)) gsumP = sumP; if (sumN < gsumN || isNaN(gsumN)) gsumN = sumN; } // for i if (isStacked100) { gsumP = gsumP === 0 ? 0 : Math.max(gsumP, -gsumN); gsumN = gsumN === 0 ? 0 : Math.min(gsumN, -gsumP); } if (gmin === gmax) { if (!isNaN(valueAxis.minValue) && isNaN(valueAxis.maxValue)) { gmin = valueAxis.minValue; gmax = logAxis ? gmin * logBase : gmin + 1; } else if (isNaN(valueAxis.minValue) && !isNaN(valueAxis.maxValue)) { gmax = valueAxis.maxValue; gmin = logAxis ? gmax / logBase : gmax - 1; } } if (gmin === gmax) { if (gmin === 0) { gmin = -1; gmax = 1; } else if (gmin < 0) gmax = 0; else { if (!logAxis) gmin = 0; else if (gmin === 1) { gmin = gmin / logBase; gmax = gmax * logBase; } } } var groupContext = { gmin: gmin, gmax: gmax, gsumP: gsumP, gsumN: gsumN, gbase: gbase, isLogAxis: logAxis, logBase: logBase, minPercent: minPercent, gMaxRange: gMaxRange, isStacked: isStacked, isStacked100: isStacked100, isWaterfall: isWaterfall, hasStackValueReversal: hasStackValueReversal, valueAxis: valueAxis, valueAxisSize: valueAxisSize }; if (groupContext.isStacked) { if (groupContext.gsumN < 0) groupContext.gmin = Math.min(groupContext.gmin, groupContext.gbase + groupContext.gsumN); if (groupContext.gsumP > 0) groupContext.gmax = Math.max(groupContext.gmax, groupContext.gbase + groupContext.gsumP); } grst.context = groupContext; } // for gidx this._mergeCommonValueAxisStats(); for (let i = 0; i < stat.seriesGroups.length; i++) { let grst = stat.seriesGroups[i]; if (!grst.isValid) continue; var out = this._calcOutputGroupStats(grst.context); for (let j in out) grst[j] = out[j]; delete grst.context; } } _mergeCommonValueAxisStats() { let common = {}; for (let i = 0; i < this.seriesGroups.length; i++) { if (!this._isGroupVisible(i)) continue if (this.seriesGroups[i].valueAxis) continue; let stats = this._stats.seriesGroups[i].context; common.gbase = stats.gbase; if (isNaN(common.gmin) || stats.gmin < common.gmin) common.gmin = stats.gmin; if (isNaN(common.gmax) || stats.gmax > common.gmax) common.gmax = stats.gmax; if (isNaN(common.gsumP) || stats.gsumP > common.gsumP) common.gsumP = stats.gsumP; if (isNaN(common.gsumN) || stats.gsumN < common.gsumN) common.gsumN = stats.gsumN; if (isNaN(common.logBase) || stats.logBase < common.logBase) common.logBase = stats.logBase; if (isNaN(common.minPercent) || stats.minPercent < common.minPercent) common.minPercent = stats.minPercent; if (common.gsumN > 0) common.gmin = Math.min(common.gmin, common.gbase + common.gsumN); if (common.gsumP > 0) common.gmax = Math.max(common.gmax, common.gbase + common.gsumP); } for (let i = 0; i < this.seriesGroups.length; i++) { if (this.seriesGroups[i].valueAxis) continue; let ctx = this._stats.seriesGroups[i].context; for (let j in common) ctx[j] = common[j]; } } _calcOutputGroupStats(context) { let gmin = context.gmin, gmax = context.gmax, gsumP = context.gsumP, gsumN = context.gsumN, gbase = context.gbase, logAxis = context.isLogAxis, logBase = context.logBase, minPercent = context.minPercent, gMaxRange = context.gMaxRange, isStacked = context.isStacked, isStacked100 = context.isStacked100, isWaterfall = context.isWaterfall, hasStackValueReversal = context.hasStackValueReversal, valueAxis = context.valueAxis, valueAxisSize = context.valueAxisSize; /// interval calculation let mu = context.valueAxis.unitInterval; if (!mu) { mu = this._calcInterval( gmin, gmax, Math.max(valueAxisSize / 80, 2)); } if (gmin === gmax) { gmin = gbase; gmax = 2 * gmax; } let intervals = NaN; // log axis scale let minPow = 0; let maxPow = 0; if (logAxis) { if (isStacked100) { intervals = 0; let p = 1; minPow = maxPow = this._draw.log(100, logBase); while (p > minPercent) { p /= logBase; minPow--; intervals++; } gmin = Math.pow(logBase, minPow); } else { if (isStacked && !isWaterfall) gmax = Math.max(gmax, gsumP); maxPow = this.renderer._rnd(this._draw.log(gmax, logBase), 1, true); gmax = Math.pow(logBase, maxPow); minPow = this.renderer._rnd(this._draw.log(gmin, logBase), 1, false); gmin = Math.pow(logBase, minPow); } mu = logBase; } // if logAxis if (gmin < gsumN) gsumN = gmin; if (gmax > gsumP) gsumP = gmax; let mn = gmin; let mx = gmax; if (!logAxis) { if (0 !== Math.abs(mx - mn) % mu) { mn = this.renderer._rnd(gmin, mu, false); mx = this.renderer._rnd(gmax, mu, true); } } if (isStacked100 && mx > 100) mx = 100; if (isStacked100 && !logAxis) { mx = (mx > 0) ? 100 : 0; mn = (mn < 0) ? -100 : 0; mu = valueAxis.unitInterval; if (isNaN(mu) || mu <= 0 || mu >= 100) mu = 10; if ((100 % mu) !== 0) { // ensure devision without reminder for (; mu >= 1; mu--) if ((100 % mu) === 0) break; } } if (isNaN(mx) || isNaN(mn) || isNaN(mu)) return {}; if (isNaN(intervals)) { intervals = parseInt(((mx - mn) / (mu === 0 ? 1 : mu)).toFixed()); } if (logAxis && !isStacked100) { intervals = maxPow - minPow; gMaxRange = Math.pow(logBase, intervals); } if (intervals < 1) return {}; let result = { min: mn, max: mx, logarithmic: logAxis, logBase: logBase, base: logAxis ? mn : gbase, minPow: minPow, maxPow: maxPow, sumP: gsumP, sumN: gsumN, mu: mu, maxRange: gMaxRange, intervals: intervals, hasStackValueReversal: hasStackValueReversal }; return result; } /** @private */ _getDataLen(groupIndex) { let ds = this.dataSource; if (groupIndex !== undefined && groupIndex !== null && groupIndex !== -1 && this.seriesGroups[groupIndex].dataSource) ds = this.seriesGroups[groupIndex].dataSource; if (ds) return ds.length; return 0; } /** @private */ _getDataValue(index, dataField, groupIndex) { let ds = this.dataSource; if (groupIndex !== undefined && groupIndex !== null && groupIndex !== -1) ds = this.seriesGroups[groupIndex].dataSource || ds; if (!ds || index < 0 || index > ds.length - 1) return undefined; if (typeof dataField === 'function') return dataField(index, ds); return (dataField && dataField !== '') ? ds[index][dataField] : ds[index]; } /** @private */ _getDataValueAsNumber(index, dataField, groupIndex) { let val = this._getDataValue(index, dataField, groupIndex); if (this._isDate(val)) return val.valueOf(); if (typeof (val) !== 'number') val = parseFloat(val); if (typeof (val) !== 'number') val = undefined; return val; } _isPieGroup(groupIndex) { let group = this.seriesGroups[groupIndex]; if (!group || !group.type) return false; return group.type.indexOf('pie') !== -1 || group.type.indexOf('donut') !== -1; } /** @private */ _renderPieSeries(groupIndex, rect) { let dataLength = this._getDataLen(groupIndex); let group = this.seriesGroups[groupIndex]; let renderData = this._calcGroupOffsets(groupIndex, rect).offsets; for (let sidx = 0; sidx < group.series.length; sidx++) { let s = group.series[sidx]; if (s.customDraw) continue; let settings = this._getSerieSettings(groupIndex, sidx); let anim = this._getAnimProps(groupIndex, sidx); let duration = anim.enabled && dataLength < 5000 && !this._isToggleRefresh && anim.duration; if (this._isTouchDevice && (this.renderer instanceof LW.Utilities.HTML5Renderer)) duration = 0; let minAngle = this._get([s.minAngle, s.startAngle]); if (isNaN(minAngle) || minAngle < 0 || minAngle > 360) minAngle = 0; let maxAngle = this._get([s.maxAngle, s.endAngle]); if (isNaN(maxAngle) || maxAngle < 0 || maxAngle > 360) maxAngle = 360; let ctx = { rect: rect, minAngle: minAngle, maxAngle: maxAngle, groupIndex: groupIndex, serieIndex: sidx, settings: settings, items: [] }; // render for (let i = 0; i < dataLength; i++) { let itemRenderData = renderData[sidx][i]; if (!itemRenderData.visible) continue; let from = itemRenderData.fromAngle; let to = itemRenderData.toAngle; let pieSliceElement = this.renderer.pieslice( itemRenderData.x, itemRenderData.y, itemRenderData.innerRadius, itemRenderData.outerRadius, from, duration === 0 ? to : from, itemRenderData.centerOffset); this._setRenderInfo(groupIndex, sidx, i, { element: pieSliceElement }); let ctxItem = { displayValue: itemRenderData.displayValue, itemIndex: i, visible: itemRenderData.visible, x: itemRenderData.x, y: itemRenderData.y, innerRadius: itemRenderData.innerRadius, outerRadius: itemRenderData.outerRadius, fromAngle: from, toAngle: to, centerOffset: itemRenderData.centerOffset }; ctx.items.push(ctxItem); } // for i this._animatePieSlices(ctx, 0); let self = this; this._enqueueAnimation( 'series', undefined, undefined, duration, function (element, ctx, percent) { self._animatePieSlices(ctx, percent); }, ctx); } } /** @private */ _sliceSortFunction(a, b) { return a.fromAngle - b.fromAngle; } /** @private */ _animatePieSlices(ctx, percent) { var renderInfo; if (this._elementRenderInfo && this._elementRenderInfo.length > ctx.groupIndex && this._elementRenderInfo[ctx.groupIndex].series && this._elementRenderInfo[ctx.groupIndex].series.length > ctx.serieIndex) { renderInfo = this._elementRenderInfo[ctx.groupIndex].series[ctx.serieIndex]; } //var animMaxAngle = 360 * percent; var labelsSettings = this._getLabelsSettings(ctx.groupIndex, ctx.serieIndex, NaN); var showLabels = labelsSettings.visible; var arr = []; for (let i = 0; i < ctx.items.length; i++) { const item = ctx.items[i]; // render the slice if (!item.visible) continue; let fromAngle = item.fromAngle; var toAngle = item.fromAngle + percent * (item.toAngle - item.fromAngle); if (renderInfo && renderInfo[item.displayValue]) { var oldFromAngle = renderInfo[item.displayValue].fromAngle; var oldToAngle = renderInfo[item.displayValue].toAngle; fromAngle = oldFromAngle + (fromAngle - oldFromAngle) * percent; toAngle = oldToAngle + (toAngle - oldToAngle) * percent; } arr.push({ index: i, from: fromAngle, to: toAngle }); } if (renderInfo) arr.sort(this._sliceSortFunction); var prevToAngle = NaN; for (let i = 0; i < arr.length; i++) { const item = ctx.items[arr[i].index]; var elementRenderInfo = this._getRenderInfo(ctx.groupIndex, ctx.serieIndex, item.itemIndex); let fromAngle = arr[i].from; var toAngle = arr[i].to; if (renderInfo) { if (!isNaN(prevToAngle) && fromAngle > prevToAngle) fromAngle = prevToAngle; prevToAngle = toAngle; if (i === arr.length - 1 && toAngle !== arr[0].from) toAngle = ctx.maxAngle + arr[0].from; } var cmd = this.renderer.pieSlicePath(item.x, item.y, item.innerRadius, item.outerRadius, fromAngle, toAngle, item.centerOffset); this.renderer.attr(elementRenderInfo.element, { 'd': cmd }); var colors = this._getColors(ctx.groupIndex, ctx.serieIndex, item.itemIndex, 'radialGradient', item.outerRadius); var settings = ctx.settings; elementRenderInfo.colors = colors; elementRenderInfo.settings = settings; this.renderer.attr( elementRenderInfo.element, { fill: colors.fillColor, stroke: colors.lineColor, 'stroke-width': settings.stroke, 'fill-opacity': settings.opacity, 'stroke-opacity': settings.opacity, 'stroke-dasharray': 'none' || settings.dashStyle }); // Label rendering if (showLabels) { this._showPieLabel(ctx.groupIndex, ctx.serieIndex, item.itemIndex, labelsSettings, undefined, elementRenderInfo.colors.lineColor); } // Install mouse event handlers if (percent === 1.0) { this._installHandlers(elementRenderInfo.element, 'pieslice', ctx.groupIndex, ctx.serieIndex, item.itemIndex); } } } _showPieLabel(groupIndex, serieIndex, itemIndex, labelsSettings, radiusAdjustment) { let renderInfo = this._renderData[groupIndex].offsets[serieIndex][itemIndex]; // remove lablel element if exists if (renderInfo.elementInfo.labelElement) this.renderer.removeElement(renderInfo.elementInfo.labelElement); if (!labelsSettings) labelsSettings = this._getLabelsSettings(groupIndex, serieIndex, NaN); if (!labelsSettings.visible) return; let angleFrom = renderInfo.fromAngle, angleTo = renderInfo.toAngle; let diff = Math.abs(angleFrom - angleTo); if (diff > 360) { angleFrom = 0; angleTo = 360; } let midAngle = diff / 2 + angleFrom; midAngle = midAngle % 360; let radMid = midAngle * Math.PI * 2 / 360; let labelAngleOverride; if (labelsSettings.autoRotate === true) labelAngleOverride = midAngle < 90 || midAngle > 270 ? 360 - midAngle : 180 - midAngle; let labelLinesEnabled = labelsSettings.linesEnabled; // measure let sz = this._showLabel(groupIndex, serieIndex, itemIndex, { x: 0, y: 0, width: 0, height: 0 }, 'center', 'center', true, false, false, labelAngleOverride); let labelRadius = labelsSettings.radius || renderInfo.outerRadius + Math.max(sz.width, sz.height); if (this._isPercent(labelRadius)) labelRadius = parseFloat(labelRadius) / 100 * Math.min(this._plotRect.width, this._plotRect.height) / 2; labelRadius += renderInfo.centerOffset; if (isNaN(radiusAdjustment)) radiusAdjustment = 0; labelRadius += radiusAdjustment; let g = this.seriesGroups[groupIndex]; let s = g.series[serieIndex]; let offsetX = this._draw.getNum([s.offsetX, g.offsetX, this._plotRect.width / 2]); let offsetY = this._draw.getNum([s.offsetY, g.offsetY, this._plotRect.height / 2]); let cx = this._plotRect.x + offsetX; let cy = this._plotRect.y + offsetY; let labelOffset = this._adjustTextBoxPosition( cx, cy, sz, labelRadius, midAngle, renderInfo.outerRadius > labelRadius, labelsSettings.linesAngles !== false, labelsSettings.autoRotate === true); const renderedRect = {}, widthAdjustment = labelOffset.x < cx ? 0 : sz.width / 2, sliceColor = Math.sqrt(Math.pow(labelOffset.x - cx, 2) + Math.pow(labelOffset.y - cy, 2)) + widthAdjustment < renderInfo.outerRadius ? arguments[5] : undefined; renderInfo.elementInfo.labelElement = this._showLabel( groupIndex, serieIndex, itemIndex, { x: labelOffset.x, y: labelOffset.y, width: sz.width, height: sz.height }, 'left', 'top', false, false, false, labelAngleOverride, renderedRect, sliceColor); if (labelRadius > renderInfo.outerRadius + radiusAdjustment + 5 && labelLinesEnabled !== false) { let lineSettings = { lineColor: renderInfo.elementInfo.colors.lineColor, stroke: renderInfo.elementInfo.settings.stroke, opacity: renderInfo.elementInfo.settings.opacity, dashStyle: renderInfo.elementInfo.settings.dashStyle }; renderInfo.elementInfo.labelArrowPath = this._updateLebelArrowPath( renderInfo.elementInfo.labelArrowPath, cx, cy, labelRadius, renderInfo.outerRadius + radiusAdjustment, radMid, labelsSettings.linesAngles !== false, lineSettings, renderedRect); } } _updateLebelArrowPath(pathElement, cx, cy, labelRadius, outerRadius, angle, useLineAngles, lineSettings, renderedRect) { const renderer = this.renderer; let x1 = renderer._ptrnd(cx + (labelRadius - 0) * Math.cos(angle)); let y1 = renderer._ptrnd(cy - (labelRadius - 0) * Math.sin(angle)); let x2 = renderer._ptrnd(cx + (outerRadius + 2) * Math.cos(angle)); let y2 = renderer._ptrnd(cy - (outerRadius + 2) * Math.sin(angle)); // sort the points of possible connections to the label rect by distance to center let points = []; points.push({ x: renderedRect.x + renderedRect.width / 2, y: renderedRect.y }); points.push({ x: renderedRect.x + renderedRect.width / 2, y: renderedRect.y + renderedRect.height }); points.push({ x: renderedRect.x, y: renderedRect.y + renderedRect.height / 2 }); points.push({ x: renderedRect.x + renderedRect.width, y: renderedRect.y + renderedRect.height / 2 }); if (!useLineAngles) { // include corner points points.push({ x: renderedRect.x, y: renderedRect.y }); points.push({ x: renderedRect.x + renderedRect.width, y: renderedRect.y }); points.push({ x: renderedRect.x + renderedRect.width, y: renderedRect.y + renderedRect.height }); points.push({ x: renderedRect.x, y: renderedRect.y + renderedRect.height }); } points = points.sort(function (a, b) { return renderer._ptdist(a.x, a.y, cx, cy) - renderer._ptdist(b.x, b.y, cx, cy); }); points = points.sort(function (a, b) { return (Math.abs(a.x - cx) + Math.abs(a.y - cy)) - (Math.abs(b.x - cx) + Math.abs(b.y - cy)); }); for (let i = 0; i < points.length; i++) { points[i].x = renderer._ptrnd(points[i].x); points[i].y = renderer._ptrnd(points[i].y); } // get the best point of the closest corners x1 = points[0].x; y1 = points[0].y; let path = 'M ' + x1 + ',' + y1 + ' L' + x2 + ',' + y2; if (useLineAngles) { path = 'M ' + x1 + ',' + y1 + ' L' + x2 + ',' + y1 + ' L' + x2 + ',' + y2; } if (pathElement) renderer.attr(pathElement, { 'd': path }); else pathElement = renderer.path(path, {}); renderer.attr( pathElement, { fill: 'none', stroke: lineSettings.lineColor, 'stroke-width': lineSettings.stroke, 'stroke-opacity': lineSettings.opacity, 'stroke-dasharray': 'none' || lineSettings.dashStyle }); return pathElement; } _adjustTextBoxPosition(cx, cy, sz, labelRadius, angle, adjustToCenter, labelLinesAngles, labelsAutoRotate) { let angleInRad = angle * Math.PI * 2 / 360; let x = this.renderer._ptrnd(cx + labelRadius * Math.cos(angleInRad)); let y = this.renderer._ptrnd(cy - labelRadius * Math.sin(angleInRad)); if (labelsAutoRotate) { let w = sz.width; let h = sz.height; let b = Math.atan(h / w) % (Math.PI * 2); let a = angleInRad % (Math.PI * 2); let radiusCorrection = 0; if (a <= b) { radiusCorrection = w / 2 * Math.cos(angleInRad); } else if (a >= b && a < Math.PI - b) { radiusCorrection = (h / 2) * Math.sin(angleInRad); } else if (a >= Math.PI - b && a < Math.PI + b) { radiusCorrection = w / 2 * Math.cos(angleInRad); } else if (a >= Math.PI + b && a < 2 * Math.PI - b) { radiusCorrection = h / 2 * Math.sin(angleInRad); } else if (a >= 2 * Math.PI - b && a < 2 * Math.PI) { radiusCorrection = w / 2 * Math.cos(angleInRad); } labelRadius += Math.abs(radiusCorrection) + 3; let x = this.renderer._ptrnd(cx + labelRadius * Math.cos(angleInRad)); let y = this.renderer._ptrnd(cy - labelRadius * Math.sin(angleInRad)); x -= sz.width / 2; y -= sz.height / 2; return { x: x, y: y }; } if (!adjustToCenter) { if (!labelLinesAngles) { //0 - 45 && 315-360: left, middle //45 - 135: center, bottom //135 - 225: right, middle //225 - 315: center, top if (angle >= 0 && angle < 45 || angle >= 315 && angle < 360) y -= sz.height / 2; else if (angle >= 45 && angle < 135) { y -= sz.height; x -= sz.width / 2; } else if (angle >= 135 && angle < 225) { y -= sz.height / 2; x -= sz.width; } else if (angle >= 225 && angle < 315) { x -= sz.width / 2; } } else { //90 - 270: right, middle //0 - 90, 270 - 360: left, middle if (angle >= 90 && angle < 270) { y -= sz.height / 2; x -= sz.width; } else { y -= sz.height / 2; } } } else { x -= sz.width / 2; y -= sz.height / 2; } return { x: x, y: y }; } _isColumnType(type) { return (type.indexOf('column') !== -1 || type.indexOf('waterfall') !== -1); } /** @private */ _getColumnGroupsCount(orientation) { let cnt = 0; orientation = orientation || 'vertical'; let sg = this.seriesGroups; for (let i = 0; i < sg.length; i++) { let groupOrientation = sg[i].orientation || 'vertical'; if (this._isColumnType(sg[i].type) && groupOrientation === orientation) cnt++; } if (this.columnSeriesOverlap) cnt = 1; return cnt; } /** @private */ _getColumnGroupIndex(groupIndex) { let idx = 0; let orientation = this.seriesGroups[groupIndex].orientation || 'vertical'; for (let i = 0; i < groupIndex; i++) { let sg = this.seriesGroups[i]; let sgOrientation = sg.orientation || 'vertical'; if (this._isColumnType(sg.type) && sgOrientation === orientation) idx++; } return idx; } _renderAxisBands(groupIndex, rect, isXAxis) { var axis = isXAxis ? this._getXAxis(groupIndex) : this._getValueAxis(groupIndex); var group = this.seriesGroups[groupIndex]; var bands = isXAxis ? undefined : group.bands; if (!bands) { for (let i = 0; i < groupIndex; i++) { var compareAxis = isXAxis ? this._getXAxis(i) : this._getValueAxis(i) if (compareAxis === axis) return; // axis already rendered in earlier group } bands = axis.bands; } if (!Array.isArray(bands)) return; var gRect = rect; var swapXY = group.orientation === 'horizontal'; if (swapXY) gRect = { x: rect.y, y: rect.x, width: rect.height, height: rect.width }; this._calcGroupOffsets(groupIndex, gRect); for (let i = 0; i < bands.length; i++) { var band = bands[i]; var valFrom = band.minValue; var valTo = band.maxValue; var from = isXAxis ? this.getXAxisDataPointOffset(valFrom, groupIndex) : this.getValueAxisDataPointOffset(valFrom, groupIndex); var to = isXAxis ? this.getXAxisDataPointOffset(valTo, groupIndex) : this.getValueAxisDataPointOffset(valTo, groupIndex); if (isNaN(from) || isNaN(to)) continue; var diff = Math.abs(from - to); var bandElement; if (group.polar || group.spider) { var renderData = this._renderData[groupIndex]; var polarAxisCoords = renderData.polarCoords; if (!isXAxis) { var pt0 = this._toPolarCoord(polarAxisCoords, rect, rect.x, renderData.baseOffset); var pt1 = this._toPolarCoord(polarAxisCoords, rect, rect.x, from); var pt2 = this._toPolarCoord(polarAxisCoords, rect, rect.x, to); var r0 = this.renderer._ptdist(pt0.x, pt0.y, pt1.x, pt1.y); var r1 = this.renderer._ptdist(pt0.x, pt0.y, pt2.x, pt2.y); var startAngle = Math.round(-polarAxisCoords.startAngle * 360 / (2 * Math.PI)); var endAngle = Math.round(-polarAxisCoords.endAngle * 360 / (2 * Math.PI)); if (startAngle > endAngle) { const tmp = startAngle; startAngle = endAngle; endAngle = tmp; } if (group.spider) { var offsetAngles = renderData.xAxis.offsetAngles; let path = ''; var rArr = [r1, r0]; var angles = offsetAngles; if (polarAxisCoords.isClosedCircle) { //angles = $.extend([], offsetAngles); angles = offsetAngles.slice(0); angles.push(angles[0]); } for (var k in rArr) { for (let j = 0; j < angles.length; j++) { var idx = k === 0 ? j : offsetAngles.length - j - 1; var px = polarAxisCoords.x + rArr[k] * Math.cos(angles[idx]); var py = polarAxisCoords.y + rArr[k] * Math.sin(angles[idx]); if (path === '') path += 'M '; else path += ' L'; path += this.renderer._ptrnd(px) + ',' + this.renderer._ptrnd(py); } if (k === 0) { var px = polarAxisCoords.x + rArr[1] * Math.cos(angles[idx]); var py = polarAxisCoords.y + rArr[1] * Math.sin(angles[idx]); path += ' L' + this.renderer._ptrnd(px) + ',' + this.renderer._ptrnd(py); } } path += ' Z'; bandElement = this.renderer.path(path); } else { bandElement = this.renderer.pieslice( polarAxisCoords.x, polarAxisCoords.y, r0, // innerRadius r1, // outerRadius startAngle, endAngle); } } else { if (group.spider) { const p1 = this.getPolarDataPointOffset(valFrom, this._stats.seriesGroups[groupIndex].max, groupIndex), p2 = this.getPolarDataPointOffset(valTo, this._stats.seriesGroups[groupIndex].max, groupIndex); let path = 'M ' + polarAxisCoords.x + ',' + polarAxisCoords.y; path += ' L ' + p1.x + ',' + p1.y; path += ' L ' + p2.x + ',' + p2.y; bandElement = this.renderer.path(path); } else { var elementInfo = {}; var columnRect = { x: Math.min(from, to), y: rect.y, width: diff, height: rect.height }; this._columnAsPieSlice(elementInfo, rect, polarAxisCoords, columnRect); bandElement = elementInfo.element; } } } else { var elRect = { x: Math.min(from, to), y: gRect.y, width: diff, height: gRect.height }; if (!isXAxis) elRect = { x: gRect.x, y: Math.min(from, to), width: gRect.width, height: diff }; if (swapXY) { let tmp = elRect.x; elRect.x = elRect.y; elRect.y = tmp; tmp = elRect.width; elRect.width = elRect.height; elRect.height = tmp; } if (diff === 0 || diff === 1) { bandElement = this.renderer.line( this.renderer._ptrnd(elRect.x), this.renderer._ptrnd(elRect.y), this.renderer._ptrnd(elRect.x + (swapXY ? 0 : elRect.width)), this.renderer._ptrnd(elRect.y + (swapXY ? elRect.height : 0)) ); } else bandElement = this.renderer.rect(elRect.x, elRect.y, elRect.width, elRect.height); } var fillColor = band.color || this._getThemeColor('band'); var lineColor = band.lineColor || fillColor; var lineWidth = band.lineWidth; if (isNaN(lineWidth)) lineWidth = 1; var opacity = band.opacity; if (isNaN(opacity) || opacity < 0 || opacity > 1) opacity = 1; this.renderer.attr(bandElement, { fill: fillColor, 'fill-opacity': opacity, stroke: lineColor, 'stroke-opacity': opacity, 'stroke-width': lineWidth, 'stroke-dasharray': band.dashStyle }); } // for } _getColumnGroupWidth(groupIndex, xoffsets, size) { let g = this.seriesGroups[groupIndex]; let isStacked = g.type.indexOf('stacked') !== -1; let columnGroupsCount = this._getColumnGroupsCount(g.orientation); if (isNaN(columnGroupsCount) || 0 === columnGroupsCount) columnGroupsCount = 1; let availableWidth = xoffsets.rangeLength >= 1 ? xoffsets.itemWidth : size * 0.9; let minWidth = g.columnsMinWidth; if (isNaN(minWidth)) minWidth = 1; if (!isNaN(g.columnsMaxWidth)) minWidth = Math.min(g.columnsMaxWidth, minWidth); // not all items will fit so try to maximize available width if (minWidth > availableWidth && xoffsets.length > 0) availableWidth = Math.max(availableWidth, size * 0.9 / xoffsets.length); // calculate required width for the group // for stacked seires it will be at least the minWidth let requiredWidth = minWidth; // calculate requiredWidth for non-stacked series if (!isStacked) { let seriesGap = g.seriesGapPercent; if (isNaN(seriesGap) || seriesGap < 0) seriesGap = 10; seriesGap /= 100; let serieMinWidth = minWidth; serieMinWidth *= (1 + seriesGap); requiredWidth += g.series.length * serieMinWidth; } let targetWidth = Math.max(availableWidth / columnGroupsCount, requiredWidth); return { requiredWidth: requiredWidth, availableWidth: availableWidth, targetWidth: targetWidth }; } _getColumnSerieWidthAndOffset(groupIndex, serieIndex) { let group = this.seriesGroups[groupIndex]; let inverse = group.orientation === 'horizontal'; let rect = this._plotRect; if (inverse) rect = { x: rect.y, y: rect.x, width: rect.height, height: rect.width }; let renderData = this._calcGroupOffsets(groupIndex, rect); if (!renderData || renderData.xoffsets.length === 0) return; let valuesOnTicks = true; let columnGroupsCount = this._getColumnGroupsCount(group.orientation); if (group.type === 'candlestick' || group.type === 'ohlc') columnGroupsCount = 1; let relativeGroupIndex = this._getColumnGroupIndex(groupIndex); let groupWidth = this._getColumnGroupWidth(groupIndex, renderData.xoffsets, inverse ? rect.height : rect.width); let intialOffset = 0; let itemWidth = groupWidth.targetWidth; if (this.columnSeriesOverlap === true || (Math.round(itemWidth) > Math.round(groupWidth.availableWidth / columnGroupsCount))) { columnGroupsCount = 1; relativeGroupIndex = 0; } if (valuesOnTicks) intialOffset -= (itemWidth * columnGroupsCount) / 2; intialOffset += itemWidth * relativeGroupIndex; // get columns gap let columnGap = group.columnsGapPercent; if (columnGap <= 0) columnGap = 0; if (isNaN(columnGap) || columnGap >= 100) columnGap = 25; columnGap /= 100; // get item gap size let itemGapWidth = itemWidth * columnGap; if (itemGapWidth + groupWidth.requiredWidth > groupWidth.targetWidth) itemGapWidth = Math.max(0, groupWidth.targetWidth - groupWidth.requiredWidth); if (Math.round(itemWidth) > Math.round(groupWidth.availableWidth)) itemGapWidth = 0; itemWidth -= itemGapWidth; intialOffset += itemGapWidth / 2; // get serie gap let seriesGap = group.seriesGapPercent; if (isNaN(seriesGap) || seriesGap < 0) seriesGap = 10; let isStacked = group.type.indexOf('stacked') !== -1; // get width per serie let serieWidth = itemWidth; if (!isStacked) serieWidth /= group.series.length; // calculate serie gap let serieSpace = this._get([group.seriesGap, (itemWidth * seriesGap / 100) / (group.series.length - 1)]); if (group.polar === true || group.spider === true || isStacked || group.series.length <= 1) serieSpace = 0; let spacesSum = serieSpace * (group.series.length - 1); if (group.series.length > 1 && spacesSum > itemWidth - group.series.length * 1) { spacesSum = itemWidth - group.series.length * 1; serieSpace = spacesSum / Math.max(1, (group.series.length - 1)); } // get columnWidth let columnWidth = serieWidth - (spacesSum / group.series.length); // adjust for max width let columnMaxAdj = 0; let columnsMaxWidth = group.columnsMaxWidth; if (!isNaN(columnsMaxWidth)) { if (columnWidth > columnsMaxWidth) { columnMaxAdj = columnWidth - columnsMaxWidth; columnWidth = columnsMaxWidth; } } // get relative serie position let seriePos = 0; if (!isStacked) { let firstPos = (itemWidth - (columnWidth * group.series.length) - spacesSum) / 2; let spacesBeforeSerie = Math.max(0, serieIndex); seriePos = firstPos + columnWidth * serieIndex + spacesBeforeSerie * serieSpace; } else { seriePos = columnMaxAdj / 2; } return { width: columnWidth, offset: intialOffset + seriePos }; } /** @private */ _renderColumnSeries(groupIndex, rect) { let group = this.seriesGroups[groupIndex]; if (!group.series || group.series.length === 0) return; let inverse = group.orientation === 'horizontal'; let gRect = rect; if (inverse) gRect = { x: rect.y, y: rect.x, width: rect.height, height: rect.width }; let renderData = this._calcGroupOffsets(groupIndex, gRect); if (!renderData || renderData.xoffsets.length === 0) return; let polarAxisCoords; if (group.polar === true || group.spider === true) { polarAxisCoords = this._getPolarAxisCoords(groupIndex, gRect); } let ctx = { groupIndex: groupIndex, rect: rect, vertical: !inverse, seriesCtx: [], renderData: renderData, polarAxisCoords: polarAxisCoords }; ctx.columnGroupWidth = this._getColumnGroupWidth(groupIndex, renderData.xoffsets, inverse ? gRect.height : gRect.width); let gradientType = this._getGroupGradientType(groupIndex), duration; for (let sidx = 0; sidx < group.series.length; sidx++) { let s = group.series[sidx]; if (s.customDraw) continue; let anim = this._getAnimProps(groupIndex, sidx); duration = anim.enabled && !this._isToggleRefresh && renderData.xoffsets.length < 100 ? anim.duration : 0; // Calculate horizontal adjustment let columnWidthAndOffset = this._getColumnSerieWidthAndOffset(groupIndex, sidx); let isVisible = this._isSerieVisible(groupIndex, sidx); let serieSettings = this._getSerieSettings(groupIndex, sidx); let serieColors = this._getColors(groupIndex, sidx, NaN, this._getGroupGradientType(groupIndex), 4); let itemsColors = []; if (typeof s.colorFunction === 'function' && !polarAxisCoords) { for (let i = renderData.xoffsets.first; i <= renderData.xoffsets.last; i++) itemsColors.push(this._getColors(groupIndex, sidx, i, gradientType, 4)); } let serieCtx = { seriesIndex: sidx, serieColors: serieColors, itemsColors: itemsColors, settings: serieSettings, columnWidth: columnWidthAndOffset.width, xAdjust: columnWidthAndOffset.offset, isVisible: isVisible }; ctx.seriesCtx.push(serieCtx); } this._animColumns(ctx, duration === 0 ? 1 : 0); let self = this; this._enqueueAnimation( 'series', undefined, undefined, duration, function (element, ctx, percent) { self._animColumns(ctx, percent); }, ctx); } _getPercent(value, defValue, minValue, maxValue) { if (isNaN(value)) value = defValue; if (!isNaN(minValue) && !isNaN(value) && value < minValue) value = minValue; if (!isNaN(maxValue) && !isNaN(value) && value > maxValue) value = maxValue; if (isNaN(value)) return NaN; return value; } /** @private */ _getColumnVOffsets(renderData, groupIndex, seriesCtx, itemIndex, isStacked, percent) { var group = this.seriesGroups[groupIndex]; var columnsTopWidthPercent = this._getPercent(group.columnsTopWidthPercent, 100, 0, 100); var columnsBottomWidthPercent = this._getPercent(group.columnsBottomWidthPercent, 100, 0, 100); if (columnsTopWidthPercent === 0 && columnsBottomWidthPercent === 0) columnsBottomWidthPercent = 100; var neckHeightPercent = this._getPercent(group.columnsNeckHeightPercent, NaN, 0, 100) / 100; var neckWidthPercent = this._getPercent(group.columnsNeckWidthPercent, 100, 0, 100) / 100; var offsets = []; var prevTo = NaN; for (let iSerie = 0; iSerie < seriesCtx.length; iSerie++) { var serieCtx = seriesCtx[iSerie]; var sidx = serieCtx.seriesIndex; var from = renderData.offsets[sidx][itemIndex].from; var to = renderData.offsets[sidx][itemIndex].to; var xOffset = renderData.xoffsets.data[itemIndex]; var itemStartState; var isVisible = serieCtx.isVisible; if (!isVisible) to = from; var elementRenderInfo = this._elementRenderInfo; if (isVisible && elementRenderInfo && elementRenderInfo.length > groupIndex && elementRenderInfo[groupIndex].series.length > sidx ) { var xvalue = renderData.xoffsets.xvalues[itemIndex]; itemStartState = elementRenderInfo[groupIndex].series[sidx][xvalue]; if (itemStartState && !isNaN(itemStartState.from) && !isNaN(itemStartState.to)) { from = itemStartState.from + (from - itemStartState.from) * percent; to = itemStartState.to + (to - itemStartState.to) * percent; xOffset = itemStartState.xoffset + (xOffset - itemStartState.xoffset) * percent; } } if (!itemStartState) to = from + (to - from) * (isStacked ? 1 : percent); if (isNaN(from)) from = isNaN(prevTo) ? renderData.baseOffset : prevTo; if (!isNaN(to) && isStacked) prevTo = to; else prevTo = from; if (isNaN(to)) to = from; var item = { from: from, to: to, xOffset: xOffset }; if (columnsTopWidthPercent !== 100 || columnsBottomWidthPercent !== 100) { item.funnel = true; item.toWidthPercent = columnsTopWidthPercent; item.fromWidthPercent = columnsBottomWidthPercent; } offsets.push(item); } if (isStacked && offsets.length > 1 && !(this._elementRenderInfo && this._elementRenderInfo.length > groupIndex)) { var sumP = 0, sumN = 0, minP = -Infinity, maxP = Infinity, minN = Infinity, maxN = -Infinity; for (let i = 0; i < offsets.length; i++) { var serieCtx = seriesCtx[i]; if (serieCtx.isVisible) { if (offsets[i].to >= offsets[i].from) { sumN += offsets[i].to - offsets[i].from; minN = Math.min(minN, offsets[i].from); maxN = Math.max(maxN, offsets[i].to); } else { sumP += offsets[i].from - offsets[i].to; minP = Math.max(minP, offsets[i].from); maxP = Math.min(maxP, offsets[i].to); } } } var sumPSave = sumP; var sumNSave = sumN; sumP *= percent; sumN *= percent; var curP = 0, curN = 0; for (let i = 0; i < offsets.length; i++) { if (offsets[i].to >= offsets[i].from) { let diff = offsets[i].to - offsets[i].from; if (diff + curN > sumN) { diff = Math.max(0, sumN - curN); offsets[i].to = offsets[i].from + diff; } if (columnsTopWidthPercent !== 100 || columnsBottomWidthPercent !== 100) { offsets[i].funnel = true; if (!isNaN(neckHeightPercent) && sumNSave * neckHeightPercent >= curN) offsets[i].fromWidthPercent = neckWidthPercent * 100; else offsets[i].fromWidthPercent = (Math.abs(offsets[i].from - minN) / sumNSave) * (columnsTopWidthPercent - columnsBottomWidthPercent) + columnsBottomWidthPercent; if (!isNaN(neckHeightPercent) && sumNSave * neckHeightPercent >= (0 + (curN + diff))) offsets[i].toWidthPercent = neckWidthPercent * 100; else offsets[i].toWidthPercent = (Math.abs(offsets[i].to - minN) / sumNSave) * (columnsTopWidthPercent - columnsBottomWidthPercent) + columnsBottomWidthPercent; } curN += diff; } else { let diff = offsets[i].from - offsets[i].to; if (diff + curP > sumP) { diff = Math.max(0, sumP - curP); offsets[i].to = offsets[i].from - diff; } if (columnsTopWidthPercent !== 100 || columnsBottomWidthPercent !== 100) { offsets[i].funnel = true; if (!isNaN(neckHeightPercent) && sumPSave * neckHeightPercent >= curP) offsets[i].fromWidthPercent = neckWidthPercent * 100; else offsets[i].fromWidthPercent = (Math.abs(offsets[i].from - minP) / sumPSave) * (columnsTopWidthPercent - columnsBottomWidthPercent) + columnsBottomWidthPercent; if (!isNaN(neckHeightPercent) && sumPSave * neckHeightPercent >= (0 + (curP + diff))) offsets[i].toWidthPercent = neckWidthPercent * 100; else offsets[i].toWidthPercent = (Math.abs(offsets[i].to - minP) / sumPSave) * (columnsTopWidthPercent - columnsBottomWidthPercent) + columnsBottomWidthPercent; } curP += diff; } } } return offsets; } /** @private */ _columnAsPieSlice(elementInfo, plotRect, polarAxisCoords, columnRect) { let pointOuter = this._toPolarCoord(polarAxisCoords, plotRect, columnRect.x, columnRect.y); let pointInner = this._toPolarCoord(polarAxisCoords, plotRect, columnRect.x, columnRect.y + columnRect.height); let innerRadius = this.renderer._ptdist(polarAxisCoords.x, polarAxisCoords.y, pointInner.x, pointInner.y); let outerRadius = this.renderer._ptdist(polarAxisCoords.x, polarAxisCoords.y, pointOuter.x, pointOuter.y); let width = plotRect.width; let angleRange = Math.abs(polarAxisCoords.startAngle - polarAxisCoords.endAngle) * 180 / Math.PI; let toAngle = -((columnRect.x - plotRect.x) * angleRange) / width; let fromAngle = -((columnRect.x + columnRect.width - plotRect.x) * angleRange) / width; let startAngle = polarAxisCoords.startAngle; startAngle = 360 * startAngle / (Math.PI * 2); toAngle -= startAngle; fromAngle -= startAngle; if (elementInfo) { if (elementInfo.element !== undefined && elementInfo.element !== null) { let cmd = this.renderer.pieSlicePath(polarAxisCoords.x, polarAxisCoords.y, innerRadius, outerRadius, fromAngle, toAngle, 0); cmd += ' Z'; this.renderer.attr(elementInfo.element, { 'd': cmd }); } else { elementInfo.element = this.renderer.pieslice( polarAxisCoords.x, polarAxisCoords.y, innerRadius, outerRadius, fromAngle, toAngle, 0); } } return { fromAngle: fromAngle, toAngle: toAngle, innerRadius: innerRadius, outerRadius: outerRadius }; } _setRenderInfo(groupIndex, serieIndex, itemIndex, elementInfo) { this._renderData[groupIndex].offsets[serieIndex][itemIndex].elementInfo = elementInfo; } _getRenderInfo(groupIndex, serieIndex, itemIndex) { return this._renderData[groupIndex].offsets[serieIndex][itemIndex].elementInfo || {}; } /** @private */ _animColumns(context, percent) { var self = this; var gidx = context.groupIndex; var group = this.seriesGroups[gidx]; var renderData = context.renderData; var isWaterfall = group.type.indexOf('waterfall') !== -1; var xAxis = this._getXAxis(gidx); var isStacked = group.type.indexOf('stacked') !== -1; var polarAxisCoords = context.polarAxisCoords; //var gradientType = this._getGroupGradientType(gidx); //var columnWidth = context.columnGroupWidth.targetWidth; var firstVisibleSerie = -1; for (let j = 0; j < group.series.length; j++) { if (this._isSerieVisible(gidx, j)) { firstVisibleSerie = j; break; } } var minPos = NaN, maxPos = NaN; for (let j = 0; j < context.seriesCtx.length; j++) { var serieCtx = context.seriesCtx[j]; if (isNaN(minPos) || minPos > serieCtx.xAdjust) minPos = serieCtx.xAdjust; if (isNaN(maxPos) || maxPos < serieCtx.xAdjust + serieCtx.columnWidth) maxPos = serieCtx.xAdjust + serieCtx.columnWidth; } var realGroupWidth = Math.abs(maxPos - minPos); var gapPercent = this._get([group.columnsGapPercent, 25]) / 100; if (isNaN(gapPercent) < 0 || gapPercent >= 1) gapPercent = 0.25; var realGroupGapWidth = gapPercent * realGroupWidth; var xoffsets = context.renderData.xoffsets; var xPrev = -1; var yWaterfallPrev = {}; // skipOverlappingPoints is off by default in column series var skipOverlappingPoints = group.skipOverlappingPoints === true; for (let i = xoffsets.first; i <= xoffsets.last; i++) { var x = xoffsets.data[i]; if (isNaN(x)) continue; if (xPrev !== -1 && Math.abs(x - xPrev) < (realGroupWidth - 1 + realGroupGapWidth) && skipOverlappingPoints) continue; else xPrev = x; var offsets = this._getColumnVOffsets(renderData, gidx, context.seriesCtx, i, isStacked, percent); var isSummary = false; if (isWaterfall) { for (let iSerie = 0; iSerie < group.series.length; iSerie++) { if (group.series[iSerie].summary && xoffsets.xvalues[i][group.series[iSerie].summary]) isSummary = true; } } for (let iSerie = 0; iSerie < context.seriesCtx.length; iSerie++) { var serieCtx = context.seriesCtx[iSerie]; var sidx = serieCtx.seriesIndex; var serie = group.series[sidx]; var from = offsets[iSerie].from; var to = offsets[iSerie].to; var xOffset = offsets[iSerie].xOffset; var startOffset = (context.vertical ? context.rect.x : context.rect.y) + serieCtx.xAdjust; var settings = serieCtx.settings; let colors = serieCtx.itemsColors.length !== 0 ? serieCtx.itemsColors[i - renderData.xoffsets.first] : serieCtx.serieColors; var isVisible = this._isSerieVisible(gidx, sidx); if (!isVisible /*&& !isStacked*/) continue; var x = this.renderer._ptrnd(startOffset + xOffset); var rect = { x: x, width: serieCtx.columnWidth }; if (offsets[iSerie].funnel) { rect.fromWidthPercent = offsets[iSerie].fromWidthPercent; rect.toWidthPercent = offsets[iSerie].toWidthPercent; } var isInverseDirection = true; if (context.vertical) { rect.y = from; rect.height = to - from; if (rect.height < 0) { rect.y += rect.height; rect.height = -rect.height; isInverseDirection = false; } } else { rect.x = from < to ? from : to; rect.width = Math.abs(from - to); isInverseDirection = from - to < 0; rect.y = x; rect.height = serieCtx.columnWidth; } var size = from - to; if (isNaN(size)) continue; size = Math.abs(size); var pieSliceInfo = undefined; var elementRenderInfo = self._getRenderInfo(gidx, sidx, i); var element = elementRenderInfo.element; var labelElement = elementRenderInfo.labelElement; var isNewElement = element === undefined || element === null; if (labelElement) { self.renderer.removeElement(labelElement); labelElement = undefined; } if (!polarAxisCoords) { if (offsets[iSerie].funnel) { // funnel or pyramid var path = this._getTrapezoidPath(Object.assign({}, rect), context.vertical, isInverseDirection); if (isNewElement) element = this.renderer.path(path, {}); else this.renderer.attr(element, { d: path }); } else { // regular column if (isNewElement) { element = this.renderer.rect(rect.x, rect.y, context.vertical ? rect.width : 0, context.vertical ? 0 : rect.height); } else { if (context.vertical === true) this.renderer.attr(element, { x: rect.x, y: rect.y, height: size }); else this.renderer.attr(element, { x: rect.x, y: rect.y, width: size }); } } } else { // column on polar axis var elementInfo = { element: element }; pieSliceInfo = this._columnAsPieSlice(elementInfo, context.rect, polarAxisCoords, rect); element = elementInfo.element; colors = this._getColors(gidx, sidx, undefined, 'radialGradient', pieSliceInfo.outerRadius); } if (size < 1 && (percent !== 1 || polarAxisCoords)) this.renderer.attr(element, { display: 'none' }); else this.renderer.attr(element, { display: 'block' }); if (isNewElement) this.renderer.attr(element, { fill: colors.fillColor, 'fill-opacity': settings.opacity, 'stroke-opacity': settings.opacity, stroke: colors.lineColor, 'stroke-width': settings.stroke, 'stroke-dasharray': settings.dashStyle }); if (labelElement) this.renderer.removeElement(labelElement); if (!isVisible || (size === 0 && percent < 1)) { elementRenderInfo = { element: element, labelElement: labelElement }; self._setRenderInfo(gidx, sidx, i, elementRenderInfo); continue; } /// Waterfall start if (isWaterfall && this._get([serie.showWaterfallLines, group.showWaterfallLines]) !== false) { if (!isStacked || (isStacked && iSerie === firstVisibleSerie)) { var serieKey = isStacked ? -1 : iSerie; if (percent === 1 && !isNaN(renderData.offsets[iSerie][i].from) && !isNaN(renderData.offsets[iSerie][i].to)) { var prevWFInfo = yWaterfallPrev[serieKey]; if (prevWFInfo !== undefined && prevWFInfo !== null) { var p1 = { x: prevWFInfo.x, y: this.renderer._ptrnd(prevWFInfo.y) }; var p2 = { x: x, y: p1.y }; var topWP = group.columnsTopWidthPercent / 100; if (isNaN(topWP)) topWP = 1; else if (topWP > 1 || topWP < 0) topWP = 1; var bottomWP = group.columnsBottomWidthPercent / 100; if (isNaN(bottomWP)) bottomWP = 1; else if (bottomWP > 1 || bottomWP < 0) bottomWP = 1; var sz = context.vertical ? rect.width : rect.height; p1.x = p1.x - sz / 2 + sz / 2 * topWP; if (isSummary) { let adj = sz * topWP / 2; p2.x = p2.x + sz / 2 - (xAxis.flip ? -adj : adj); } else { let adj = sz * bottomWP / 2; p2.x = p2.x + sz / 2 - (xAxis.flip ? -adj : adj); } if (!context.vertical) { this._swapXY([p1]); this._swapXY([p2]); } this.renderer.line( p1.x, p1.y, p2.x, p2.y, { stroke: prevWFInfo.color, 'stroke-width': settings.stroke, 'stroke-opacity': settings.opacity, 'fill-opacity': settings.opacity, 'stroke-dasharray': settings.dashStyle } ); } } } if (percent === 1 && size !== 0) { yWaterfallPrev[isStacked ? -1 : iSerie] = { y: to, x: (context.vertical ? rect.x + rect.width : rect.y + rect.height), color: colors.lineColor }; } } // Waterfall end if (polarAxisCoords) { var sz = this._showLabel(gidx, sidx, i, rect, undefined, undefined, true); var labelRadius = pieSliceInfo.outerRadius + 10; const labelOffset = this._adjustTextBoxPosition( polarAxisCoords.x, polarAxisCoords.y, sz, labelRadius, (pieSliceInfo.fromAngle + pieSliceInfo.toAngle) / 2, true, false, false); labelElement = this._showLabel(gidx, sidx, i, { x: labelOffset.x, y: labelOffset.y }, undefined, undefined, false, false, false); } else { labelElement = this._showLabel(gidx, sidx, i, rect, undefined, undefined, false, false, isInverseDirection); } elementRenderInfo = { element: element, labelElement: labelElement }; self._setRenderInfo(gidx, sidx, i, elementRenderInfo); if (percent === 1.0) { this._installHandlers(element, 'column', gidx, sidx, i); } } } } _getTrapezoidPath(rect, isVertical, isInverseDirection) { let path = ''; let fromP = rect.fromWidthPercent / 100; let toP = rect.toWidthPercent / 100; if (!isVertical) { let tmp = rect.width; rect.width = rect.height; rect.height = tmp; tmp = rect.x; rect.x = rect.y; rect.y = tmp; } let x = rect.x + rect.width / 2; let points = [ { x: x - rect.width * (!isInverseDirection ? fromP : toP) / 2, y: rect.y + rect.height }, { x: x - rect.width * (!isInverseDirection ? toP : fromP) / 2, y: rect.y }, { x: x + rect.width * (!isInverseDirection ? toP : fromP) / 2, y: rect.y }, { x: x + rect.width * (!isInverseDirection ? fromP : toP) / 2, y: rect.y + rect.height } ]; if (!isVertical) this._swapXY(points); path += 'M ' + this.renderer._ptrnd(points[0].x) + ',' + this.renderer._ptrnd(points[0].y); for (let i = 1; i < points.length; i++) path += ' L ' + this.renderer._ptrnd(points[i].x) + ',' + this.renderer._ptrnd(points[i].y); path += ' Z'; return path; } _swapXY(points) { for (let i = 0; i < points.length; i++) { let tmp = points[i].x; points[i].x = points[i].y; points[i].y = tmp; } } /** @private */ _renderCandleStickSeries(groupIndex, rect, isOHLC) { let self = this; let group = self.seriesGroups[groupIndex]; if (!group.series || group.series.length === 0) return; let inverse = group.orientation === 'horizontal'; let gRect = rect; if (inverse) gRect = { x: rect.y, y: rect.x, width: rect.height, height: rect.width }; let renderData = self._calcGroupOffsets(groupIndex, gRect); if (!renderData || renderData.xoffsets.length === 0) return; let polarAxisCoords; if (group.polar || group.spider) { polarAxisCoords = self._getPolarAxisCoords(groupIndex, gRect); } let gradientType = self._getGroupGradientType(groupIndex); let columnsInfo = []; for (let sidx = 0; sidx < group.series.length; sidx++) columnsInfo[sidx] = self._getColumnSerieWidthAndOffset(groupIndex, sidx); for (let sidx = 0; sidx < group.series.length; sidx++) { if (!this._isSerieVisible(groupIndex, sidx)) continue; let settings = self._getSerieSettings(groupIndex, sidx); let s = group.series[sidx]; if (s.customDraw) continue; let colors = typeof s.colorFunction === 'function' ? undefined : self._getColors(groupIndex, sidx, NaN, gradientType); let ctx = { rect: rect, inverse: inverse, groupIndex: groupIndex, seriesIndex: sidx, symbolType: s.symbolType, symbolSize: s.symbolSize, 'fill-opacity': settings.opacity, 'stroke-opacity': settings.opacity, 'stroke-width': settings.stroke, 'stroke-dasharray': settings.dashStyle, gradientType: gradientType, colors: colors, renderData: renderData, polarAxisCoords: polarAxisCoords, columnsInfo: columnsInfo, isOHLC: isOHLC, items: [], self: self }; let anim = self._getAnimProps(groupIndex, sidx); let duration = anim.enabled && !self._isToggleRefresh && renderData.xoffsets.length < 5000 ? anim.duration : 0; self._animCandleStick(ctx, 0); self._enqueueAnimation('series', undefined, undefined, duration, function (undefined, context, percent) { self._animCandleStick(context, percent); }, ctx); } } /** @private */ _animCandleStick(ctx, percent) { var fields = ['Open', 'Low', 'Close', 'High']; var columnWidth = ctx.columnsInfo[ctx.seriesIndex].width; var group = ctx.self.seriesGroups[ctx.groupIndex]; var xoffsets = ctx.renderData.xoffsets; var xPrev = -1; var xRange = Math.abs(xoffsets.data[xoffsets.last] - xoffsets.data[xoffsets.first]); xRange *= percent; var minPos = NaN, maxPos = NaN; for (let j = 0; j < ctx.columnsInfo.length; j++) { var serieCtx = ctx.columnsInfo[j]; if (isNaN(minPos) || minPos > serieCtx.offset) minPos = serieCtx.offset; if (isNaN(maxPos) || maxPos < serieCtx.offset + serieCtx.width) maxPos = serieCtx.offset + serieCtx.width; } var realGroupWidth = Math.abs(maxPos - minPos); // skipOverlappingPoints is on by default in candlestick & OHLC series var skipOverlappingPoints = group.skipOverlappingPoints !== false; for (let i = xoffsets.first; i <= xoffsets.last; i++) { var x = xoffsets.data[i]; if (isNaN(x)) continue; if (xPrev !== -1 && Math.abs(x - xPrev) < realGroupWidth && skipOverlappingPoints) continue; // skip drawing elements outside the anim % range var xDiff = Math.abs(xoffsets.data[i] - xoffsets.data[xoffsets.first]); if (xDiff > xRange) break; xPrev = x; var item = ctx.items[i] = ctx.items[i] || {}; for (let j in fields) { var val = ctx.self._getDataValueAsNumber(i, group.series[ctx.seriesIndex]['dataField' + fields[j]], ctx.groupIndex); if (isNaN(val)) break; var y = ctx.renderData.offsets[ctx.seriesIndex][i][fields[j]]; if (isNaN(y)) break; item[fields[j]] = y; } x += ctx.inverse ? ctx.rect.y : ctx.rect.x; if (ctx.polarAxisCoords) { var point = this._toPolarCoord(ctx.polarAxisCoords, this._plotRect, x, y); x = point.x; y = point.y; } x = this.renderer._ptrnd(x); for (var it in fields) item[it] = this.renderer._ptrnd(item[it]); var colors = ctx.colors; if (!colors) colors = ctx.self._getColors(ctx.groupIndex, ctx.seriesIndex, i, ctx.gradientType); if (!ctx.isOHLC) { var lineElement = item.lineElement; if (!lineElement) { lineElement = ctx.inverse ? this.renderer.line(item.Low, x, item.High, x) : this.renderer.line(x, item.Low, x, item.High); this.renderer.attr(lineElement, { fill: colors.fillColor, 'fill-opacity': ctx['fill-opacity'], 'stroke-opacity': ctx['fill-opacity'], stroke: colors.lineColor, 'stroke-width': ctx['stroke-width'], 'stroke-dasharray': ctx['stroke-dasharray'] }); item.lineElement = lineElement; } var stickElement = item.stickElement; x -= columnWidth / 2; if (!stickElement) { var fillColor = colors.fillColor; if (item.Close <= item.Open && colors.fillColorAlt) fillColor = colors.fillColorAlt; stickElement = ctx.inverse ? this.renderer.rect(Math.min(item.Open, item.Close), x, Math.abs(item.Close - item.Open), columnWidth) : this.renderer.rect(x, Math.min(item.Open, item.Close), columnWidth, Math.abs(item.Close - item.Open)); this.renderer.attr(stickElement, { fill: fillColor, 'fill-opacity': ctx['fill-opacity'], 'stroke-opacity': ctx['fill-opacity'], stroke: colors.lineColor, 'stroke-width': ctx['stroke-width'], 'stroke-dasharray': ctx['stroke-dasharray'] }); item.stickElement = stickElement; } if (percent === 1.0) this._installHandlers(stickElement, 'column', ctx.groupIndex, ctx.seriesIndex, i); } else { var path = 'M' + x + ',' + item.Low + ' L' + x + ',' + item.High + ' ' + 'M' + (x - columnWidth / 2) + ',' + item.Open + ' L' + x + ',' + item.Open + ' ' + 'M' + (x + columnWidth / 2) + ',' + item.Close + ' L' + x + ',' + item.Close; if (ctx.inverse) { path = 'M' + item.Low + ',' + x + ' L' + item.High + ',' + x + ' ' + 'M' + item.Open + ',' + (x - columnWidth / 2) + ' L' + item.Open + ',' + x + ' ' + 'M' + item.Close + ',' + x + ' L' + item.Close + ',' + (x + columnWidth / 2); } var lineElement = item.lineElement; if (!lineElement) { lineElement = this.renderer.path(path, {}); this.renderer.attr(lineElement, { fill: colors.fillColor, 'fill-opacity': ctx['fill-opacity'], 'stroke-opacity': ctx['fill-opacity'], stroke: colors.lineColor, 'stroke-width': ctx['stroke-width'], 'stroke-dasharray': ctx['stroke-dasharray'] }); item.lineElement = lineElement; } /* else { this.renderer.attr(lineElement, { 'd': path }); }*/ if (percent === 1.0) this._installHandlers(lineElement, 'column', ctx.groupIndex, ctx.seriesIndex, i); } } // for } /** @private */ _renderScatterSeries(groupIndex, rect, valueField) { var group = this.seriesGroups[groupIndex]; if (!group.series || group.series.length === 0) return; var isBubble = group.type.indexOf('bubble') !== -1; var inverse = group.orientation === 'horizontal'; var gRect = rect; if (inverse) gRect = { x: rect.y, y: rect.x, width: rect.height, height: rect.width }; var renderData = this._calcGroupOffsets(groupIndex, gRect); if (!renderData || renderData.xoffsets.length === 0) return; var scaleWidth = gRect.width; var polarAxisCoords; if (group.polar || group.spider) { polarAxisCoords = this._getPolarAxisCoords(groupIndex, gRect); scaleWidth = 2 * polarAxisCoords.r; } var gradientType = this._getGroupGradientType(groupIndex); if (!valueField) valueField = 'to'; for (let sidx = 0; sidx < group.series.length; sidx++) { var settings = this._getSerieSettings(groupIndex, sidx); var s = group.series[sidx]; if (s.customDraw) continue; var dataField = s.dataField; var hasColorFunction = typeof s.colorFunction === 'function'; var colors = this._getColors(groupIndex, sidx, NaN, gradientType); var min = NaN, max = NaN; if (isBubble) { for (let i = renderData.xoffsets.first; i <= renderData.xoffsets.last; i++) { var val = this._getDataValueAsNumber(i, (s.radiusDataField || s.sizeDataField), groupIndex); if (typeof val !== 'number') this.error(this.localize('invalidRadiusDataField', { index: i })); if (!isNaN(val)) { if (isNaN(min) || val < min) min = val; if (isNaN(max) || val > max) max = val; } } } var minRadius = s.minRadius || s.minSymbolSize; if (isNaN(minRadius)) minRadius = scaleWidth / 50; var maxRadius = s.maxRadius || s.maxSymbolSize; if (isNaN(maxRadius)) maxRadius = scaleWidth / 25; if (minRadius > maxRadius) maxRadius = minRadius; var radius = s.radius; if (isNaN(radius) && !isNaN(s.symbolSize)) { radius = (s.symbolType === 'circle') ? s.symbolSize / 2 : s.symbolSize; } else radius = 5; var anim = this._getAnimProps(groupIndex, sidx); var duration = anim.enabled && !this._isToggleRefresh && renderData.xoffsets.length < 5000 ? anim.duration : 0; var ctx = { groupIndex: groupIndex, seriesIndex: sidx, symbolType: s.symbolType, symbolSize: s.symbolSize, 'fill-opacity': settings.opacity, 'stroke-opacity': settings.opacity, 'stroke-width': settings.stroke, 'stroke-width-symbol': settings.strokeSymbol, 'stroke-dasharray': settings.dashStyle, items: [], polarAxisCoords: polarAxisCoords }; var ptSave = undefined; for (let i = renderData.xoffsets.first; i <= renderData.xoffsets.last; i++) { var val = this._getDataValueAsNumber(i, dataField, groupIndex); if (typeof (val) !== 'number') continue; var x = renderData.xoffsets.data[i]; var xvalue = renderData.xoffsets.xvalues[i]; var y = renderData.offsets[sidx][i][valueField]; if (y < gRect.y || y > gRect.y + gRect.height) continue; if (isNaN(x) || isNaN(y)) continue; if (inverse) { var tmp = x; x = y; y = tmp + rect.y; } else { x += rect.x; } if (!hasColorFunction && ptSave && this.enableSampling && this.renderer._ptdist(ptSave.x, ptSave.y, x, y) < 1) continue; ptSave = { x: x, y: y }; var r = radius; if (isBubble) { var rval = this._getDataValueAsNumber(i, (s.radiusDataField || s.sizeDataField), groupIndex); if (typeof (rval) !== 'number') continue; r = minRadius + (maxRadius - minRadius) * (rval - min) / Math.max(1, max - min); if (isNaN(r)) r = minRadius; } renderData.offsets[sidx][i].radius = r; var yOld = NaN, xOld = NaN; var rOld = 0; var elementRenderInfo = this._elementRenderInfo; if (xvalue !== undefined && xvalue !== null && elementRenderInfo && elementRenderInfo.length > groupIndex && elementRenderInfo[groupIndex].series.length > sidx ) { var itemStartState = elementRenderInfo[groupIndex].series[sidx][xvalue]; if (itemStartState && !isNaN(itemStartState.to)) { yOld = itemStartState.to; xOld = itemStartState.xoffset; rOld = radius; if (inverse) { var tmp = xOld; xOld = yOld; yOld = tmp + rect.y; } else { xOld += rect.x; } if (isBubble) { rOld = minRadius + (maxRadius - minRadius) * (itemStartState.valueRadius - min) / Math.max(1, max - min); if (isNaN(rOld)) rOld = minRadius; } } } if (hasColorFunction) colors = this._getColors(groupIndex, sidx, i, gradientType); ctx.items.push({ from: rOld, to: r, itemIndex: i, fill: colors.fillColor, stroke: colors.lineColor, x: x, y: y, xFrom: xOld, yFrom: yOld }); } // i this._animR(ctx, 0); var self = this; this._enqueueAnimation('series', undefined, undefined, duration, function (undefined, context, percent) { self._animR(context, percent); }, ctx); } } /** @private */ _animR(ctx, percent) { let items = ctx.items; let symbolType = ctx.symbolType || 'circle'; let symbolSize = ctx.symbolSize; for (let i = 0; i < items.length; i++) { let item = items[i]; let x = item.x; let y = item.y; let r = Math.round((item.to - item.from) * percent + item.from); if (!isNaN(item.yFrom)) y = item.yFrom + (y - item.yFrom) * percent; if (!isNaN(item.xFrom)) x = item.xFrom + (x - item.xFrom) * percent; if (ctx.polarAxisCoords) { let point = this._toPolarCoord(ctx.polarAxisCoords, this._plotRect, x, y); x = point.x; y = point.y; } x = this.renderer._ptrnd(x); y = this.renderer._ptrnd(y); r = this.renderer._ptrnd(r); let elementRenderInfo = this._getRenderInfo(ctx.groupIndex, ctx.seriesIndex, items[i].itemIndex); let element = elementRenderInfo.element; let labelElement = elementRenderInfo.labelElement; if (symbolType === 'circle') { if (!element) { element = this.renderer.circle(x, y, r); this.renderer.attr(element, { fill: item.fill, 'fill-opacity': ctx['fill-opacity'], 'stroke-opacity': ctx['fill-opacity'], stroke: item.stroke, 'stroke-width': ctx['stroke-width'], 'stroke-dasharray': ctx['stroke-dasharray'] }); } this.renderer.attr(element, { r: r, cy: y, cx: x }); } else { if (element) this.renderer.removeElement(element); element = this._drawSymbol( symbolType, x, y, item.fill, ctx['fill-opacity'], item.stroke, ctx['stroke-opacity'] || ctx['fill-opacity'], ctx['stroke-width-symbol'], ctx['stroke-dasharray'], symbolSize || r); } if (labelElement) this.renderer.removeElement(labelElement); labelElement = this._showLabel(ctx.groupIndex, ctx.seriesIndex, item.itemIndex, { x: x - r, y: y - r, width: 2 * r, height: 2 * r }); if (percent >= 1) this._installHandlers(element, 'circle', ctx.groupIndex, ctx.seriesIndex, item.itemIndex); this._setRenderInfo(ctx.groupIndex, ctx.seriesIndex, items[i].itemIndex, { element: element, labelElement: labelElement }); } } _showMultiSeriesToolTip(iidx) { let self = this; let content = '<div style=\'text-align:left\'>'; let prevXAxisText = ''; for (let gidx = 0; gidx < self.seriesGroups.length; gidx++) { if (self._isPieGroup(gidx)) continue; let xAxis = self._getXAxis(gidx); let yAxis = self._getValueAxis(gidx); let group = self.seriesGroups[gidx]; let xAxisSettings = this._getAxisSettings(xAxis); let xAxisFS = this._getFormatSettings(xAxisSettings, 'toolTipFormatSettings'); let xAxisFF = xAxisSettings.toolTipFormatFunction; let xAxisValue = self._getDataValue(iidx, xAxis.dataField, gidx); if (xAxis.dataField === undefined || xAxis.dataField === null || xAxis.dataField === '') xAxisValue = iidx; if (xAxis.type === 'date') xAxisValue = self._castAsDate(xAxisValue, (xAxisFS ? xAxisFS.dateFormat : undefined) || xAxis.dateFormat); if (!xAxisFF && !xAxisFS && xAxis.type === 'date') xAxisFF = this._getDefaultDTFormatFn(xAxis.baseUnit || 'day'); let xAxisDisplayText = (xAxis.displayText || xAxis.dataField || ''); if (xAxisDisplayText !== '') xAxisDisplayText += ': '; let xAxisText = xAxisDisplayText + self._formatValue(xAxisValue, xAxisFS, xAxisFF, gidx, undefined, iidx); if (prevXAxisText !== xAxisText) { if (prevXAxisText !== '') content += '<br />'; content += xAxisText + '<br /><br />'; prevXAxisText = xAxisText; } for (let sidx = 0; sidx < group.series.length; sidx++) { let serie = group.series[sidx]; if (group.showToolTips === false || serie.showToolTips === false) continue; if (!self._isSerieVisible(gidx, sidx)) continue; let valfs = self._get([ self._getFormatSettings(serie, 'toolTipFormatSettings'), self._getFormatSettings(group, 'toolTipFormatSettings'), self._getFormatSettings(yAxis, 'toolTipFormatSettings'), self._getFormatSettings(self, 'toolTipFormatSettings')]); let valff = self._get([serie.toolTipFormatFunction, group.toolTipFormatFunction, yAxis.toolTipFormatFunction, self.toolTipFormatFunction]); let serieValueText = self._getFormattedValue(gidx, sidx, iidx, valfs, valff); let colors = self._getColors(gidx, sidx, iidx); content += '<span style="color:' + colors.lineColor + ';">' + serieValueText + '</span><br />\n'; } } let cssToolTip = this._get([self.toolTipClass, 'lw-chart-tooltip-text']); let toolTipFill = this._get([self.toolTipBackground, self._getThemeColor('background')]); let toolTipStroke = this._get([self.toolTipLineColor, self._getThemeColor('line')]); let toolTipFillOpacity = this._get([self.toolTipOpacity, 1]); content += '</div>'; let coord = this.getItemCoord(self._ttEl.gidx, self._ttEl.sidx, self._ttEl.iidx); coord.x += window.pageXOffset; coord.y += window.pageYOffset; self._createTooltip(coord, self.seriesGroups[self._ttEl.gidx], content, { css: cssToolTip, fill: toolTipFill, stroke: toolTipStroke, fillOpacity: toolTipFillOpacity, symbolSize: 3 }); } /** @private */ _showToolTip(x, y, gidx, sidx, iidx) { let self = this; let xAxis = self._getXAxis(gidx); let yAxis = self._getValueAxis(gidx); if (self._ttEl && gidx === self._ttEl.gidx && sidx === self._ttEl.sidx && iidx === self._ttEl.iidx) return; let group = self.seriesGroups[gidx]; let series = group.series[sidx]; let enableCrosshairs = self.enableCrosshairs; if (self._pointMarker) { // make it relative to the marker instead of cursor x = parseInt(self._pointMarker.x + 5); y = parseInt(self._pointMarker.y - 5); } else { enableCrosshairs = false; } let isCrossHairsOnly = enableCrosshairs && self.showToolTips === false; x = this.renderer._ptrnd(x); y = this.renderer._ptrnd(y); if (group.showToolTips === false || series.showToolTips === false) return; if (!self._ttEl) { self._ttEl = {}; } self._ttEl.sidx = sidx; self._ttEl.gidx = gidx; self._ttEl.iidx = iidx; let seriesCount = 0; for (let i = 0; i < self.seriesGroups.length; i++) for (let j = 0; j < self.seriesGroups[i].series.length; j++) seriesCount++; if (enableCrosshairs) { let _x = this.renderer._ptrnd(self._pointMarker.x); let _y = this.renderer._ptrnd(self._pointMarker.y); let color = self.crosshairsColor || self._getThemeColor('line'); if (group.polar || group.spider) { let polarCoords = this._getPolarAxisCoords(gidx, this._plotRect); let dist = this.renderer._ptdist(_x, _y, polarCoords.x, polarCoords.y); if (dist > polarCoords.r) return; let posAngle = Math.atan2(_y - polarCoords.y, _x - polarCoords.x); let x2 = Math.cos(posAngle) * polarCoords.r + polarCoords.x; let y2 = Math.sin(posAngle) * polarCoords.r + polarCoords.y; if (self._ttEl.vLine) self.renderer.attr(self._ttEl.vLine, { x1: polarCoords.x, y1: polarCoords.y, x2: x2, y2: y2 }); else self._ttEl.vLine = self.renderer.line(polarCoords.x, polarCoords.y, x2, y2, { stroke: color, 'stroke-width': self.crosshairsLineWidth || 1.0, 'stroke-dasharray': self.crosshairsDashStyle || '' }); } else { if (self._ttEl.vLine && self._ttEl.hLine) { self.renderer.attr(self._ttEl.vLine, { x1: _x, x2: _x }); self.renderer.attr(self._ttEl.hLine, { y1: _y, y2: _y }); } else { self._ttEl.vLine = self.renderer.line(_x, self._plotRect.y, _x, self._plotRect.y + self._plotRect.height, { stroke: color, 'stroke-width': self.crosshairsLineWidth || 1.0, 'stroke-dasharray': self.crosshairsDashStyle || '' }); self._ttEl.hLine = self.renderer.line(self._plotRect.x, _y, self._plotRect.x + self._plotRect.width, _y, { stroke: color, 'stroke-width': self.crosshairsLineWidth || 1.0, 'stroke-dasharray': self.crosshairsDashStyle || '' }); } } } if (self.showToolTipsOnAllSeries && !self._isPieGroup(gidx) && seriesCount > 1 ) { self._showMultiSeriesToolTip(iidx); return; } let valfs = self._get([ self._getFormatSettings(series, 'toolTipFormatSettings'), self._getFormatSettings(group, 'toolTipFormatSettings'), self._getFormatSettings(yAxis, 'toolTipFormatSettings'), self._getFormatSettings(self, 'toolTipFormatSettings')]); let valff = self._get([series.toolTipFormatFunction, group.toolTipFormatFunction, yAxis.toolTipFormatFunction, self.toolTipFormatFunction]); let colors = self._getColors(gidx, sidx, iidx); let xAxisValue = self._getDataValue(iidx, xAxis.dataField, gidx); if (xAxis.dataField === undefined || xAxis.dataField === null || xAxis.dataField === '') xAxisValue = iidx; if (xAxis.type === 'date') xAxisValue = self._castAsDate(xAxisValue, (valfs ? valfs.dateFormat : undefined) || xAxis.dateFormat); let text = ''; if (typeof valff === 'function') { let value = {}; let cnt = 0; for (let field in series) if (field.indexOf('dataField') === 0) { value[field.substring(9, field.length).toLowerCase()] = self._getDataValue(iidx, series[field], gidx); cnt++; } if (cnt === 0) value = self._getDataValue(iidx, undefined, gidx); else if (cnt === 1) value = value['']; text = valff(value, iidx, series, group, xAxisValue, xAxis); } else { text = self._getFormattedValue(gidx, sidx, iidx, valfs, valff); let xAxisSettings = this._getAxisSettings(xAxis); let catfs = self._getFormatSettings(xAxisSettings, 'toolTipFormatSettings'); let catff = xAxisSettings.toolTipFormatFunction; if (!catff && !catfs && xAxis.type === 'date') catff = this._getDefaultDTFormatFn(xAxis.baseUnit || 'day'); let categoryText = self._formatValue(xAxisValue, catfs, catff, gidx, sidx, iidx); if (!self._isPieGroup(gidx)) { let t = (xAxis.displayText || xAxis.dataField || ''); if (t.length > 0) text = t + ': ' + categoryText + '<br>' + text; else text = categoryText + '<br>' + text; } else { xAxisValue = self._getDataValue(iidx, series.displayText || series.dataField, gidx); categoryText = self._formatValue(xAxisValue, catfs, catff, gidx, sidx, iidx); text = categoryText + ': ' + text; } } if (!isCrossHairsOnly && self.showToolTips !== false) { let cssToolTip = this._get([series.toolTipClass, group.toolTipClass, self.toolTipClass, 'lw-chart-tooltip-text']); let toolTipFill = this._get([series.toolTipBackground, group.toolTipBackground, self.toolTipBackground, self._getThemeColor('background')]); let toolTipStroke = this._get([series.toolTipLineColor, group.toolTipLineColor, self.toolTipLineColor, colors.lineColor, self._getThemeColor('line')]); let toolTipFillOpacity = this._get([series.toolTipOpacity, group.toolTipOpacity, self.toolTipOpacity, 1]); let coord = this.getItemCoord(gidx, sidx, iidx); coord.y = Math.min(Math.max(coord.y, this._plotRect.y), this._plotRect.y + this._plotRect.y + this._plotRect.height); let symbolSize = 0; if (self._pointMarker && self._pointMarker.element) { symbolSize = series.symbolSizeSelected; if (isNaN(symbolSize)) symbolSize = series.symbolSize; if (isNaN(symbolSize) || symbolSize > 50 || symbolSize < 0) symbolSize = group.symbolSize; if (isNaN(symbolSize) || symbolSize > 50 || symbolSize < 0) symbolSize = 8; } self._createTooltip(coord, group, text, { css: cssToolTip, fill: toolTipFill, stroke: toolTipStroke, fillOpacity: toolTipFillOpacity, symbolSize: symbolSize }); } } _fitTooltip(bounds, elementRect, rect, group, symbolSize) { let fitOptions = {}; let space = 2 + symbolSize / 2; let arrowSize = 7; //try fit left if (elementRect.x - rect.width - arrowSize - space > bounds.x && elementRect.y + elementRect.height / 2 - rect.height / 2 > bounds.y && elementRect.y + elementRect.height / 2 + rect.height / 2 < bounds.y + bounds.height) { fitOptions.left = { arrowLocation: 'right', x: elementRect.x - rect.width - arrowSize - space, y: elementRect.y + elementRect.height / 2 - rect.height / 2, width: rect.width + arrowSize, height: rect.height }; } //try fit right if (elementRect.x + elementRect.width + rect.width + arrowSize + space < bounds.x + bounds.width && elementRect.y + elementRect.height / 2 - rect.height / 2 > bounds.y && elementRect.y + elementRect.height / 2 + rect.height / 2 < bounds.y + bounds.height) { fitOptions.right = { arrowLocation: 'left', x: elementRect.x + elementRect.width + space, y: elementRect.y + elementRect.height / 2 - rect.height / 2, width: rect.width + arrowSize, height: rect.height }; } //try fit top if (elementRect.y - rect.height - space - arrowSize > bounds.y && elementRect.x + elementRect.width / 2 - rect.width / 2 > bounds.x && elementRect.x + elementRect.width / 2 + rect.width / 2 < bounds.x + bounds.width) { fitOptions.top = { arrowLocation: 'bottom', x: elementRect.x + elementRect.width / 2 - rect.width / 2, y: elementRect.y - rect.height - space - arrowSize, width: rect.width, height: rect.height + arrowSize }; } //try fit bottom if (elementRect.y + elementRect.height + rect.height + arrowSize + space < bounds.y + bounds.height && elementRect.x + elementRect.width / 2 - rect.width / 2 > bounds.x && elementRect.x + elementRect.width / 2 + rect.width / 2 < bounds.x + bounds.width) { fitOptions.bottom = { arrowLocation: 'top', x: elementRect.x + elementRect.width / 2 - rect.width / 2, y: elementRect.y + elementRect.height + space, width: rect.width, height: rect.height + arrowSize }; } if (elementRect.width > elementRect.height || ((group.type.indexOf('stackedcolumn') !== -1 || group.type.indexOf('stackedwaterfall') !== -1) && group.orientation !== 'horizontal') ) { if (fitOptions.left) return fitOptions.left; if (fitOptions.right) return fitOptions.right; } else { if (fitOptions.top) return fitOptions.top if (fitOptions.bottom) return fitOptions.bottom } for (let i in fitOptions) { if (fitOptions[i]) return fitOptions[i]; } return { arrowLocation: '' } } /** @private */ _createTooltip(position, group, content, style) { const self = this, groupType = group.type; // create tooltip elements let divToolTip = self._ttEl.box; if (!divToolTip) { divToolTip = self._ttEl.box = document.createElement('div'); divToolTip.id = self.id + 'Tooltip'; divToolTip.className = 'lw-chart-tooltip'; divToolTip.setAttribute('animation', self.animation); divToolTip.setAttribute('theme', self.theme); divToolTip.setAttribute('role', 'tooltip'); const arrowOuterDiv = document.createElement('div'), arrowInnerDiv = document.createElement('div'), contentDiv = document.createElement('div'); arrowOuterDiv.className = 'lw-chart-tooltip-arrow-outer'; arrowOuterDiv.setAttribute('role', 'presentation'); arrowInnerDiv.className = 'lw-chart-tooltip-arrow-inner'; arrowInnerDiv.setAttribute('role', 'presentation'); contentDiv.className = 'lw-chart-tooltip-content'; contentDiv.setAttribute('role', 'presentation'); divToolTip.appendChild(contentDiv); divToolTip.appendChild(arrowOuterDiv); divToolTip.appendChild(arrowInnerDiv); if (self.getRootNode().host) { self.getShadowRootOrBody().appendChild(divToolTip); } else { document.body.appendChild(divToolTip); } if (self.hasAttribute('aria-owns')) { const attributeValue = self.getAttribute('aria-owns'); self.setAttribute('aria-owns', attributeValue + ' ' + divToolTip.id); } else { self.setAttribute('aria-owns', divToolTip.id); } } if (!content || content.length === 0) { divToolTip.classList.add('lw-visibility-hidden'); return; } self.rightToLeft ? divToolTip.setAttribute('right-to-left', '') : divToolTip.removeAttribute('right-to-left'); divToolTip.classList.add('lw-visibility-hidden'); const contentDiv = divToolTip.firstElementChild, arrowOuterDiv = divToolTip.children[1], arrowInnerDiv = divToolTip.children[2]; arrowInnerDiv.style.opacity = arrowOuterDiv.style.opacity = style.fillOpacity; // set styles and content contentDiv.style.backgroundColor = style.fill; contentDiv.style.borderColor = style.stroke; contentDiv.style.opacity = style.fillOpacity; const html = '<span class="' + style.css + '" role="presentation">' + content + '</span>'; contentDiv.innerHTML = html; const size = self._measureHtml(html); // calculate tooltip positioning and arrow location const rect = self._plotRect; if (size.width > rect.width || size.height > rect.height) return; let totalSize = { width: size.width, height: size.height }; let arrowLocation = ''; let arrowSize = 7; let isColumn = self._isColumnType(groupType); let x = Math.max(position.x, rect.x), y = Math.max(position.y, rect.y); if (groupType.indexOf('pie') !== -1 || groupType.indexOf('donut') !== -1) { let midAngle = (position.fromAngle + position.toAngle) / 2; midAngle = midAngle * (Math.PI / 180); let radius = (!isNaN(position.innerRadius) && position.innerRadius > 0) ? (position.innerRadius + position.outerRadius) / 2 : position.outerRadius * 0.75; x = position.x = position.center.x + Math.cos(midAngle) * radius; y = position.y = position.center.y - Math.sin(midAngle) * radius; position.width = position.height = 1; } else if (isColumn && (group.polar || group.spider)) { position.width = position.height = 1; } let ttFit = this._fitTooltip(this._plotRect, position, totalSize, group, style.symbolSize); if (ttFit.arrowLocation !== '') { arrowLocation = ttFit.arrowLocation; x = ttFit.x; y = ttFit.y; totalSize.width = ttFit.width; totalSize.height = ttFit.height; } if (arrowLocation === 'top' || arrowLocation === 'bottom') { totalSize.height += arrowSize; x -= arrowSize / 2; if (arrowLocation === 'bottom') y -= arrowSize; } else if (arrowLocation === 'left' || arrowLocation === 'right') { totalSize.width += arrowSize; y -= arrowSize / 2; if (arrowLocation === 'right') x -= arrowSize; } if (x + totalSize.width > rect.x + rect.width) { arrowLocation = ''; x = rect.x + rect.width - totalSize.width; } if (y + totalSize.height > rect.y + rect.height) { arrowLocation = ''; y = rect.y + rect.height - totalSize.height; } // set arrow and content position let arrowPosition = { x: 0, y: 0 }, contentPosition = { x: 0, y: 0 }; contentDiv.style.width = size.width + 'px'; contentDiv.style.height = size.height + 'px'; arrowOuterDiv.style['margin-top'] = arrowOuterDiv.style['margin-left'] = 0; arrowInnerDiv.style['margin-top'] = arrowInnerDiv.style['margin-left'] = 0; contentDiv.style['margin-top'] = contentDiv.style['margin-left'] = 0; let arrowSizeSolid = arrowSize + 'px solid'; let arrowSizeSolidTransparent = arrowSize + 'px solid transparent'; switch (arrowLocation) { case 'left': arrowPosition = { x: 0, y: (size.height - arrowSize) / 2 }; contentPosition = { x: arrowSize, y: 0 }; contentDiv.style['margin-left'] = arrowSize + 'px'; arrowOuterDiv.style['margin-left'] = 0 + 'px'; arrowOuterDiv.style['margin-top'] = arrowPosition.y + 'px'; arrowOuterDiv.style['border-left'] = ''; arrowOuterDiv.style['border-right'] = arrowSizeSolid + ' ' + style.stroke; arrowOuterDiv.style['border-top'] = arrowSizeSolidTransparent; arrowOuterDiv.style['border-bottom'] = arrowSizeSolidTransparent; arrowInnerDiv.style['margin-left'] = 1 + 'px'; arrowInnerDiv.style['margin-top'] = arrowPosition.y + 'px'; arrowInnerDiv.style['border-left'] = ''; arrowInnerDiv.style['border-right'] = arrowSizeSolid + ' ' + style.fill; arrowInnerDiv.style['border-top'] = arrowSizeSolidTransparent; arrowInnerDiv.style['border-bottom'] = arrowSizeSolidTransparent; break; case 'right': arrowPosition = { x: totalSize.width - arrowSize, y: (size.height - arrowSize) / 2 }; contentPosition = { x: 0, y: 0 }; arrowOuterDiv.style['margin-left'] = arrowPosition.x + 'px'; arrowOuterDiv.style['margin-top'] = arrowPosition.y + 'px'; arrowOuterDiv.style['border-left'] = arrowSizeSolid + ' ' + style.stroke; arrowOuterDiv.style['border-right'] = ''; arrowOuterDiv.style['border-top'] = arrowSizeSolidTransparent; arrowOuterDiv.style['border-bottom'] = arrowSizeSolidTransparent; arrowInnerDiv.style['margin-left'] = arrowPosition.x - 1 + 'px'; arrowInnerDiv.style['margin-top'] = arrowPosition.y + 'px'; arrowInnerDiv.style['border-left'] = arrowSizeSolid + ' ' + style.fill; arrowInnerDiv.style['border-right'] = ''; arrowInnerDiv.style['border-top'] = arrowSizeSolidTransparent; arrowInnerDiv.style['border-bottom'] = arrowSizeSolidTransparent; break; case 'top': arrowPosition = { x: totalSize.width / 2 - arrowSize / 2, y: 0 }; contentPosition = { x: 0, y: arrowSize }; contentDiv.style['margin-top'] = contentPosition.y + 'px'; arrowOuterDiv.style['margin-left'] = arrowPosition.x + 'px'; arrowOuterDiv.style['border-top'] = ''; arrowOuterDiv.style['border-bottom'] = arrowSizeSolid + ' ' + style.stroke; arrowOuterDiv.style['border-left'] = arrowSizeSolidTransparent; arrowOuterDiv.style['border-right'] = arrowSizeSolidTransparent; arrowInnerDiv.style['margin-left'] = arrowPosition.x + 'px'; arrowInnerDiv.style['margin-top'] = 1 + 'px'; arrowInnerDiv.style['border-top'] = ''; arrowInnerDiv.style['border-bottom'] = arrowSizeSolid + ' ' + style.fill; arrowInnerDiv.style['border-left'] = arrowSizeSolidTransparent; arrowInnerDiv.style['border-right'] = arrowSizeSolidTransparent; break; case 'bottom': arrowPosition = { x: totalSize.width / 2 - arrowSize / 2, y: totalSize.height - arrowSize }; contentPosition = { x: 0, y: 0 } arrowOuterDiv.style['margin-left'] = arrowPosition.x + 'px'; arrowOuterDiv.style['margin-top'] = arrowPosition.y + 'px'; arrowOuterDiv.style['border-top'] = arrowSizeSolid + ' ' + style.stroke; arrowOuterDiv.style['border-bottom'] = ''; arrowOuterDiv.style['border-left'] = arrowSizeSolidTransparent; arrowOuterDiv.style['border-right'] = arrowSizeSolidTransparent; arrowInnerDiv.style['margin-left'] = arrowPosition.x + 'px'; arrowInnerDiv.style['margin-top'] = arrowPosition.y - 1 + 'px'; arrowInnerDiv.style['border-top'] = arrowSizeSolid + ' ' + style.fill; arrowInnerDiv.style['border-bottom'] = ''; arrowInnerDiv.style['border-left'] = arrowSizeSolidTransparent; arrowInnerDiv.style['border-right'] = arrowSizeSolidTransparent; break; } if (arrowLocation === '') { arrowOuterDiv.classList.add('lw-hidden'); arrowInnerDiv.classList.add('lw-hidden'); } else { arrowOuterDiv.classList.remove('lw-hidden'); arrowInnerDiv.classList.remove('lw-hidden'); } // update size divToolTip.style.width = totalSize.width + 'px'; divToolTip.style.height = totalSize.height + 'px'; const hostPosition = self.getBoundingClientRect(); divToolTip.style.left = x + hostPosition.left + window.pageXOffset + 'px'; divToolTip.style.top = y + hostPosition.top + window.pageYOffset + 'px'; divToolTip.classList.remove('lw-visibility-hidden'); } /** @private */ _measureHtml(html) { const that = this; let measureDiv = that._measureDiv; if (!measureDiv) { that._measureDiv = measureDiv = document.createElement('div'); measureDiv.className = 'lw-chart-tooltip'; measureDiv.style.position = 'absolute'; measureDiv.style.visibility = 'hidden'; measureDiv.style.left = 0; measureDiv.style.top = 0; (that.shadowRoot || that).appendChild(measureDiv); } measureDiv.innerHTML = html; const sz = { width: measureDiv.offsetWidth + 2, height: measureDiv.offsetHeight + 2 }; if (LW.Utilities.Core.Browser.Firefox) { sz.height += 3; } return sz; } /** @private */ _hideToolTip() { if (!this._ttEl) return; if (this._ttEl.box) { this._ttEl.box.classList.add('lw-visibility-hidden'); } this._hideCrosshairs(); this._ttEl.gidx = undefined; } /** @private */ _hideCrosshairs() { if (!this._ttEl) return; if (this._ttEl.vLine) { this.renderer.removeElement(this._ttEl.vLine); this._ttEl.vLine = undefined; } if (this._ttEl.hLine) { this.renderer.removeElement(this._ttEl.hLine); this._ttEl.hLine = undefined; } } _get(arr) { return this._draw.getByPriority(arr); } _getAxisSettings(axis) { if (!axis) return {}; let self = this; // grid lines settings let gridLinesProperties = axis.gridLines || {}; let gridLinesSettings = { visible: self._get([gridLinesProperties.visible, true]), color: self._get([gridLinesProperties.color, self._getThemeColor('line')]), unitInterval: gridLinesProperties.unitInterval, step: gridLinesProperties.step, dashStyle: gridLinesProperties.dashStyle, width: self._get([gridLinesProperties.lineWidth, 1]), offsets: [], alternatingBackgroundColor: axis.alternatingBackgroundColor, alternatingBackgroundColor2: axis.alternatingBackgroundColor2, alternatingBackgroundOpacity: axis.alternatingBackgroundOpacity }; // tick marks settings let tickMarksProperties = axis.tickMarks || {}; let tickMarksSettings = { visible: self._get([tickMarksProperties.visible, axis.showTickMarks, true]), color: self._get([tickMarksProperties.color, axis.tickMarksColor, self._getThemeColor('line')]), unitInterval: self._get([tickMarksProperties.unitInterval, tickMarksProperties.interval, axis.tickMarksInterval]), step: self._get([tickMarksProperties.step, axis.tickMarksStep]), dashStyle: self._get([tickMarksProperties.dashStyle, axis.tickMarksDashStyle]), width: self._get([tickMarksProperties.lineWidth, 1]), size: self._get([tickMarksProperties.size, 4]), offsets: [] }; // title settings let titleProperties = axis.title || {}; let titleSettings = { visible: self._get([titleProperties.visible, true]), text: self._get([axis.description, titleProperties.text]), style: self._get([axis.descriptionClass, titleProperties['class'], 'lw-chart-axis-description']), halign: self._get([axis.horizontalDescriptionAlignment, titleProperties.horizontalAlignment, 'center']), valign: self._get([axis.verticalDescriptionAlignment, titleProperties.verticalAlignment, 'center']), angle: 0, rotationPoint: self._get([titleProperties.rotationPoint, 'centercenter']), offset: self._get([titleProperties.offset, { x: 0, y: 0 }]) }; let lineProperties = axis.line || {}; let lineSettings = { visible: self._get([lineProperties.visible, true]), color: self._get([lineProperties.color, gridLinesSettings.color, self._getThemeColor('line')]), dashStyle: self._get([lineProperties.dashStyle, gridLinesSettings.dashStyle, '']), width: self._get([lineProperties.lineWidth, 1]), angle: self._get([lineProperties.angle, NaN]) }; let padding = axis.padding || {}; padding = { left: padding.left || 0, right: padding.right || 0, top: padding.top || 0, bottom: padding.bottom || 0 }; let labelsSettings = this._getAxisLabelsSettings(axis); let result = { visible: this._get([axis.visible, true]), customDraw: this._get([axis.customDraw, false]), gridLines: gridLinesSettings, tickMarks: tickMarksSettings, line: lineSettings, title: titleSettings, labels: labelsSettings, padding: padding, toolTipFormatFunction: this._get([axis.toolTipFormatFunction, axis.formatFunction, labelsSettings.formatFunction]), toolTipFormatSettings: this._get([self._getFormatSettings(axis, 'toolTipFormatSettings'), self._getFormatSettings(axis), self._getFormatSettings(labelsSettings)]) }; return result; } _getAxisLabelsSettings(axis) { let self = this; let labels = axis.labels || {}; let settings = { visible: self._get([axis.showLabels, labels.visible, true]), unitInterval: self._get([labels.unitInterval, labels.interval, axis.labelsInterval]), step: self._get([labels.step, axis.labelsStep]), angle: self._get([axis.textRotationAngle, labels.angle, 0]), style: self._get([axis['class'], labels['class'], 'lw-chart-axis-text']), halign: self._get([axis.horizontalTextAlignment, labels.horizontalAlignment, 'center']), valign: self._get([axis.verticalTextAlignment, labels.verticalAlignment, 'center']), textRotationPoint: self._get([axis.textRotationPoint, labels.rotationPoint, 'auto']), textOffset: self._get([axis.textOffset, labels.offset, { x: 0, y: 0 }]), autoRotate: self._get([axis.labelsAutoRotate, labels.autoRotate, false]), formatSettings: self._get([self._getFormatSettings(axis), self._getFormatSettings(labels), undefined]), formatFunction: self._get([axis.formatFunction, labels.formatFunction, undefined]) }; return settings; } _getLabelsSettings(gidx, sidx, iidx, options) { let g = this.seriesGroups[gidx]; let s = g.series[sidx]; let value = isNaN(iidx) ? undefined : this._getDataValue(iidx, s.dataField, gidx); let properties = options || [ 'Visible', 'Offset', 'Angle', 'HorizontalAlignment', 'VerticalAlignment', 'Class', 'BackgroundColor', 'BorderColor', 'BorderOpacity', 'Padding', 'Opacity', 'BackgroundOpacity', 'LinesAngles', 'LinesEnabled', 'AutoRotate', 'Radius' ]; let result = {}; for (let i = 0; i < properties.length; i++) { let key = properties[i]; let name = 'labels' + key; let altName = 'label' + key; let altName2 = key.substring(0, 1).toLowerCase() + key.substring(1); let propValue = undefined; if (g.labels && typeof (g.labels) === 'object') propValue = g.labels[altName2]; if (s.labels && typeof (s.labels) === 'object' && s.labels[altName2] !== undefined && s.labels[altName2] !== null) propValue = s.labels[altName2]; propValue = this._get([s[name], s[altName], propValue, g[name], g[altName]]); if (typeof propValue === 'function') result[altName2] = propValue(value, iidx, s, g); else result[altName2] = propValue; } result['class'] = result['class'] || 'lw-chart-label-text'; result['visible'] = this._get([result['visible'], s.showLabels, g.showLabels, s.labels !== undefined && s.labels !== null ? true : undefined, g.labels !== undefined && g.labels !== null ? true : undefined]); let paddingValue = result['padding'] || 1; result['padding'] = { left: this._get([paddingValue.left, isNaN(paddingValue) ? 1 : paddingValue]), right: this._get([paddingValue.right, isNaN(paddingValue) ? 1 : paddingValue]), top: this._get([paddingValue.top, isNaN(paddingValue) ? 1 : paddingValue]), bottom: this._get([paddingValue.bottom, isNaN(paddingValue) ? 1 : paddingValue]) } return result; } /** @private */ _showLabel(gidx, sidx, iidx, rect, halign, valign, isMeasure, inverseHAlign, inverseVAlign, labelAngleOverride, renderedRect) { let sz = { width: 0, height: 0 }, szSave; if (isNaN(iidx)) return; let settings = this._getLabelsSettings(gidx, sidx, iidx); if (!settings.visible) return isMeasure ? sz : undefined; if (rect.width < 0 || rect.height < 0) return isMeasure ? sz : undefined; let labelsAngle = settings.angle; if (!isNaN(labelAngleOverride)) labelsAngle = labelAngleOverride; let offset = settings.offset || {}; let labelOffset = { x: offset.x, y: offset.y }; if (isNaN(labelOffset.x)) labelOffset.x = 0; if (isNaN(labelOffset.y)) labelOffset.y = 0; halign = halign || settings.horizontalAlignment || 'center'; valign = valign || settings.verticalAlignment || 'center'; let text = this._getFormattedValue(gidx, sidx, iidx, undefined, undefined, true); let w = rect.width; let h = rect.height; if (inverseHAlign === true && halign !== 'center') halign = halign === 'right' ? 'left' : 'right'; if (inverseVAlign === true && valign !== 'center' && valign !== 'middle') { valign = valign === 'top' ? 'bottom' : 'top'; labelOffset.y *= -1; } sz = this.renderer.measureText(text, labelsAngle, { 'class': settings['class'] }); if (isMeasure) return sz; let x = 0, y = 0; if (w > 0) { if (halign === '' || halign === 'center') x += (w - sz.width) / 2; else if (halign === 'right') x += (w - sz.width); } if (h > 0) { if (valign === '' || valign === 'center') y += (h - sz.height) / 2; else if (valign === 'bottom') y += (h - sz.height); } x += rect.x + labelOffset.x; y += rect.y + labelOffset.y; let plotRect = this._plotRect; if (x <= plotRect.x) x = plotRect.x + 2; if (y <= plotRect.y) y = plotRect.y + 2; let labelSize = { width: Math.max(sz.width, 1), height: Math.max(sz.height, 1) }; if (y + labelSize.height >= plotRect.y + plotRect.height) y = plotRect.y + plotRect.height - (szSave ? (labelSize.height + szSave.height) / 2 : labelSize.height) - 2; if (x + labelSize.width >= plotRect.x + plotRect.width) x = plotRect.x + plotRect.width - labelSize.width - 2; let renderGroup; let labelsBackground = settings.backgroundColor; let labelsBorder = settings.borderColor; let padding = settings.padding; if (labelsBackground || labelsBorder) { renderGroup = this.renderer.beginGroup(); this.renderer.rect( x - padding.left, y - padding.top, sz.width + padding.left + padding.right, sz.height + padding.bottom + padding.bottom, { fill: labelsBackground || 'transparent', 'fill-opacity': settings.backgroundOpacity || 1, stroke: labelsBorder || 'transparent', 'stroke-opacity': settings.borderOpacity, 'stroke-width': 1 } ); } let elemLabel = this.renderer.text(text, x, y, sz.width, sz.height, labelsAngle, { 'class': settings['class'], opacity: settings.opacity || 1 }, false, 'center', 'center', undefined, arguments[11]); if (renderedRect) { // return the renderedRect renderedRect.x = x - padding.left; renderedRect.y = y - padding.top; renderedRect.width = sz.width + padding.left + padding.right; renderedRect.height = sz.height + padding.bottom + padding.bottom; } if (renderGroup) this.renderer.endGroup(); return renderGroup || elemLabel; } /** @private */ _getAnimProps(gidx, sidx) { let g = this.seriesGroups[gidx]; let s = !isNaN(sidx) ? g.series[sidx] : undefined; let enabled = this.hasAnimation; if (g.animation) enabled = g.animation !== 'none'; if (s && s.animation) enabled = s.animation !== 'none'; let duration = this.animationDuration; if (isNaN(duration)) duration = 1000; let gd = g.animationDuration; if (!isNaN(gd)) duration = gd; if (s) { let sd = s.animationDuration; if (!isNaN(sd)) duration = sd; } if (duration > 5000) duration = 1000; return { enabled: enabled, duration: duration }; } _isColorTransition(groupIndex, s, renderData, current) { if (current - 1 < renderData.xoffsets.first) return false; let currentColor = this._getColors(groupIndex, s, current, this._getGroupGradientType(groupIndex)); let prevColor = this._getColors(groupIndex, s, current - 1, this._getGroupGradientType(groupIndex)); return (currentColor.fillColor !== prevColor.fillColor); } /** @private */ _renderLineSeries(groupIndex, rect) { var group = this.seriesGroups[groupIndex]; if (!group.series || group.series.length === 0) return; var isArea = group.type.indexOf('area') !== -1; var isStacked = group.type.indexOf('stacked') !== -1; var isStacked100 = isStacked && group.type.indexOf('100') !== -1; var isSpline = group.type.indexOf('spline') !== -1; var isStep = group.type.indexOf('step') !== -1; var isRange = group.type.indexOf('range') !== -1; var isPolar = group.polar === true || group.spider === true; if (isPolar) isStep = false; if (isStep && isSpline) return; var swapXY = group.orientation === 'horizontal'; var flipCategory = this._getXAxis(groupIndex).flip === true; var gRect = rect; if (swapXY) gRect = { x: rect.y, y: rect.x, width: rect.height, height: rect.width }; var renderData = this._calcGroupOffsets(groupIndex, gRect); if (!renderData || renderData.xoffsets.length === 0) return; if (!this._linesRenderInfo) this._linesRenderInfo = {}; this._linesRenderInfo[groupIndex] = {}; for (let sidx = group.series.length - 1; sidx >= 0; sidx--) { var serieSettings = this._getSerieSettings(groupIndex, sidx); var serieCtx = { groupIndex: groupIndex, rect: gRect, serieIndex: sidx, swapXY: swapXY, isArea: isArea, isSpline: isSpline, isRange: isRange, isPolar: isPolar, settings: serieSettings, segments: [], pointsLength: 0 }; var isVisible = this._isSerieVisible(groupIndex, sidx); if (!isVisible) { this._linesRenderInfo[groupIndex][sidx] = serieCtx; continue; } var serie = group.series[sidx]; if (serie.customDraw) continue; var hasColorFunction = typeof serie.colorFunction === 'function'; var curr = renderData.xoffsets.first; var last = curr; var color = this._getColors(groupIndex, sidx, NaN, this._getGroupGradientType(groupIndex)); var continueOnCurr; do { var points = []; var rangeBasePoints = []; var pointsStart = []; var px = 0, py = 0; var xPrev = NaN; var yPrev = NaN; var pyStart = NaN; if (renderData.xoffsets.length < 1) continue; var anim = this._getAnimProps(groupIndex, sidx); var duration = anim.enabled && !this._isToggleRefresh && renderData.xoffsets.length < 10000 && anim.duration; var first = curr; continueOnCurr = false; var ptSave = undefined; for (let i = curr; i <= renderData.xoffsets.last; i++) { curr = i; var x = renderData.xoffsets.data[i]; var xvalue = renderData.xoffsets.xvalues[i]; if (isNaN(x)) continue; x = Math.max(x, 1); px = x; py = renderData.offsets[sidx][i].to; if (!hasColorFunction && ptSave && this.enableSampling && this.renderer._ptdist(ptSave.x, ptSave.y, px, py) < 1) continue; ptSave = { x: px, y: py }; var pyFrom = renderData.offsets[sidx][i].from; if (isNaN(py) || isNaN(pyFrom)) { if (serie.emptyPointsDisplay === 'connect') { continue; } else if (serie.emptyPointsDisplay === 'zero') { if (isNaN(py)) py = renderData.baseOffset; if (isNaN(pyFrom)) pyFrom = renderData.baseOffset; } else { continueOnCurr = true; break; } } if (hasColorFunction && this._isColorTransition(groupIndex, sidx, renderData, curr)) { if (points.length > 1) { curr--; break; } } var elementRenderInfo = this._elementRenderInfo; if (elementRenderInfo && elementRenderInfo.length > groupIndex && elementRenderInfo[groupIndex].series.length > sidx ) { var itemStartState = elementRenderInfo[groupIndex].series[sidx][xvalue]; var pyStart = this.renderer._ptrnd(itemStartState ? itemStartState.to : undefined); var pxStart = this.renderer._ptrnd(gRect.x + (itemStartState ? itemStartState.xoffset : undefined)); pointsStart.push(swapXY ? { y: pxStart, x: pyStart, index: i } : { x: pxStart, y: pyStart, index: i }); } last = i; if (serieSettings.stroke < 2) { if (py - gRect.y <= 1) py = gRect.y + 1; if (pyFrom - gRect.y <= 1) pyFrom = gRect.y + 1; if (gRect.y + gRect.height - py <= 1) py = gRect.y + gRect.height - 1; if (gRect.y + gRect.height - pyFrom <= 1) pyFrom = gRect.y + gRect.height - 1; } if (!isArea && isStacked100) { if (py <= gRect.y) py = gRect.y + 1; if (py >= gRect.y + gRect.height) py = gRect.y + gRect.height - 1; if (pyFrom <= gRect.y) pyFrom = gRect.y + 1; if (pyFrom >= gRect.y + gRect.height) pyFrom = gRect.y + gRect.height - 1; } // TODO: validate condition x = Math.max(x, 1); px = x + gRect.x; if (group.skipOverlappingPoints === true && !isNaN(xPrev) && Math.abs(xPrev - px) <= 1) continue; if (isStep && !isNaN(xPrev) && !isNaN(yPrev)) { if (yPrev !== py) points.push(swapXY ? { y: px, x: this.renderer._ptrnd(yPrev) } : { x: px, y: this.renderer._ptrnd(yPrev) }); } points.push(swapXY ? { y: px, x: this.renderer._ptrnd(py), index: i } : { x: px, y: this.renderer._ptrnd(py), index: i }); rangeBasePoints.push(swapXY ? { y: px, x: this.renderer._ptrnd(pyFrom), index: i } : { x: px, y: this.renderer._ptrnd(pyFrom), index: i }); xPrev = px; yPrev = py; if (isNaN(pyStart)) pyStart = py; } if (points.length === 0) { curr++; continue; } var lastItemIndex = points[points.length - 1].index; if (hasColorFunction) color = this._getColors(groupIndex, sidx, lastItemIndex, this._getGroupGradientType(groupIndex)); var left = gRect.x + renderData.xoffsets.data[first]; var right = gRect.x + renderData.xoffsets.data[last]; if (isArea && group.alignEndPointsWithIntervals === true) { if (left > gRect.x) { left = gRect.x; } if (right < gRect.x + gRect.width) right = gRect.x + gRect.width; if (flipCategory) { var tmp = left; left = right; right = tmp; } } right = this.renderer._ptrnd(right); left = this.renderer._ptrnd(left); var yBase = renderData.baseOffset; pyStart = this.renderer._ptrnd(pyStart); var pyEnd = this.renderer._ptrnd(py) || yBase; if (isRange) { points = points.concat(rangeBasePoints.reverse()); } serieCtx.pointsLength += points.length; var segmentCtx = { lastItemIndex: lastItemIndex, colorSettings: color, pointsArray: points, pointsStart: pointsStart, left: left, right: right, pyStart: pyStart, pyEnd: pyEnd, yBase: yBase, labelElements: [], symbolElements: [] }; serieCtx.segments.push(segmentCtx); } while (curr < renderData.xoffsets.first + renderData.xoffsets.length - 1 || continueOnCurr); this._linesRenderInfo[groupIndex][sidx] = serieCtx; } // for s var contexts = this._linesRenderInfo[groupIndex]; var contextsArr = []; for (let i in contexts) contextsArr.push(contexts[i]); contextsArr = contextsArr.sort(function (a, b) { return a.serieIndex - b.serieIndex; }); if (isArea && isStacked) contextsArr.reverse(); for (let i = 0; i < contextsArr.length; i++) { var serieCtx = contextsArr[i]; this._animateLine(serieCtx, duration === 0 ? 1 : 0); var self = this; this._enqueueAnimation( 'series', undefined, undefined, duration, function (element, context, percent) { self._animateLine(context, percent); }, serieCtx); } } /** @private */ _animateLine(serieCtx, percent) { let settings = serieCtx.settings; let groupIndex = serieCtx.groupIndex; let serieIndex = serieCtx.serieIndex; let group = this.seriesGroups[groupIndex]; let serie = group.series[serieIndex]; let symbol = this._getSymbol(groupIndex, serieIndex); let showLabels = this._getLabelsSettings(groupIndex, serieIndex, NaN, ['Visible']).visible; let isClosedPolar = true; if (serieCtx.isPolar) { if (!isNaN(group.endAngle) && Math.round(Math.abs((isNaN(group.startAngle) ? 0 : group.startAngle) - group.endAngle)) !== 360) isClosedPolar = false; } if (serie.endPointsConnect === false) isClosedPolar = false; let startPoint = 0; for (let iSegment = 0; iSegment < serieCtx.segments.length; iSegment++) { let ctx = serieCtx.segments[iSegment]; let cmd = this._calculateLine(groupIndex, serieCtx.pointsLength, startPoint, ctx.pointsArray, ctx.pointsStart, ctx.yBase, percent, serieCtx.isArea, serieCtx.swapXY); startPoint += ctx.pointsArray.length; if (cmd === '') continue; let split = cmd.split(' '); //let cnt = split.length; let lineCmd = cmd; if (lineCmd !== '') lineCmd = this._buildLineCmd( cmd, serieCtx.isRange, ctx.left, ctx.right, ctx.pyStart, ctx.pyEnd, ctx.yBase, serieCtx.isArea, serieCtx.isPolar, isClosedPolar, serieCtx.isSpline, serieCtx.swapXY ); else lineCmd = 'M 0 0'; let colorSettings = ctx.colorSettings; if (!ctx.pathElement) { ctx.pathElement = this.renderer.path( lineCmd, { 'stroke-width': settings.stroke, 'stroke': colorSettings.lineColor, 'stroke-opacity': settings.opacity, 'fill-opacity': settings.opacity, 'stroke-dasharray': settings.dashStyle, fill: serieCtx.isArea ? colorSettings.fillColor : 'none' }); this._installHandlers(ctx.pathElement, 'path', groupIndex, serieIndex, ctx.lastItemIndex); } else { this.renderer.attr(ctx.pathElement, { 'd': lineCmd }); } if (ctx.labelElements) { for (let i = 0; i < ctx.labelElements.length; i++) this.renderer.removeElement(ctx.labelElements[i]); ctx.labelElements = []; } if (ctx.symbolElements) { for (let i = 0; i < ctx.symbolElements.length; i++) this.renderer.removeElement(ctx.symbolElements[i]); ctx.symbolElements = []; } if (ctx.pointsArray.length === split.length) { if (symbol !== 'none' || showLabels) { let symbolSize = serie.symbolSize; let gRect = this._plotRect; for (let i = 0; i < split.length; i++) { let point = split[i].split(','); point = { x: parseFloat(point[0]), y: parseFloat(point[1]) }; if (point.x < gRect.x || point.x > gRect.x + gRect.width || point.y < gRect.y || point.y > gRect.y + gRect.height) continue; if (symbol !== 'none') { let itemColors = this._getColors(groupIndex, serieIndex, ctx.pointsArray[i].index, this._getGroupGradientType(groupIndex)); let symbolElement = this._drawSymbol( symbol, point.x, point.y, itemColors.fillColorSymbol, settings.opacity, itemColors.lineColorSymbol, settings.opacity, settings.strokeSymbol, undefined, symbolSize); ctx.symbolElements.push(symbolElement); } if (showLabels) { point = this._adjustLineLabelPosition(groupIndex, serieIndex, ctx.pointsArray[i].index, point); if (point) { let labelElement = this._showLabel(groupIndex, serieIndex, ctx.pointsArray[i].index, { x: point.x, y: point.y, width: 0, height: 0 }); ctx.labelElements.push(labelElement); } } } } } if (percent === 1 && symbol !== 'none') { for (let i = 0; i < ctx.symbolElements.length; i++) { if (isNaN(ctx.pointsArray[i].index)) continue; this._installHandlers(ctx.symbolElements[i], 'symbol', groupIndex, serieIndex, ctx.pointsArray[i].index); } } } // iSegment } /** @private */ _adjustLineLabelPosition(gidx, sidx, iidx, pt) { let labelSize = this._showLabel(gidx, sidx, iidx, { width: 0, height: 0 }, '', '', true); if (!labelSize) return; let ptAdj = { x: pt.x - labelSize.width / 2, y: 0 }; ptAdj.y = pt.y - 1.5 * labelSize.height; return ptAdj; } /** @private */ _calculateLine(groupIndex, seriePointsLength, startPoint, pointsArray, pointsStartArray, yBase, percent, isArea, swapXY) { let g = this.seriesGroups[groupIndex]; let polarAxisCoords; if (g.polar === true || g.spider === true) polarAxisCoords = this._getPolarAxisCoords(groupIndex, this._plotRect); let cmd = ''; let cnt = pointsArray.length; if (!isArea && pointsStartArray.length === 0) { let stop = seriePointsLength * percent; cnt = stop - startPoint; } for (let i = 0; i < cnt + 1 && i < pointsArray.length; i++) { if (i > 0) cmd += ' '; let y = pointsArray[i].y; let x = pointsArray[i].x; let baseY = !isArea ? y : yBase; let baseX = x; if (pointsStartArray && pointsStartArray.length > i) { baseY = pointsStartArray[i].y; baseX = pointsStartArray[i].x; if (isNaN(baseY) || isNaN(baseX)) { baseY = y; baseX = x; } } if (cnt <= pointsArray.length && i > 0 && i === cnt) { baseX = pointsArray[i - 1].x; baseY = pointsArray[i - 1].y; } if (swapXY) { x = this.renderer._ptrnd((x - baseY) * (isArea ? percent : 1) + baseY); y = this.renderer._ptrnd(y); } else { x = this.renderer._ptrnd((x - baseX) * percent + baseX); y = this.renderer._ptrnd((y - baseY) * percent + baseY); } if (polarAxisCoords) { let point = this._toPolarCoord(polarAxisCoords, this._plotRect, x, y); x = point.x; y = point.y; } cmd += x + ',' + y; //if (pointsArray.length === 1 && !isArea) // cmd += ' ' + (x + 2) + ',' + (y + 2); } return cmd; } /** @private */ _buildLineCmd(pointsArray, isRange, left, right, pyStart, pyEnd, yBase, isArea, isPolar, isClosedPolar, isSpline, swapXY) { let cmd = pointsArray; let ptBottomLeft = swapXY ? yBase + ',' + left : left + ',' + yBase; let ptBottomRight = swapXY ? yBase + ',' + right : right + ',' + yBase; if (isArea && !isPolar && !isRange) { cmd = ptBottomLeft + ' ' + pointsArray + ' ' + ptBottomRight; } if (isSpline) cmd = this._getBezierPoints(cmd); let split = cmd.split(' '); if (split.length === 0) return ''; // handle single point case if (split.length === 1) { let points = split[0].split(','); return 'M ' + split[0] + ' L' + (parseFloat(points[0]) + 1) + ',' + (parseFloat(points[1]) + 1); } let firstPoint = split[0].replace('M', ''); if (isArea && !isPolar) { if (!isRange) { cmd = 'M ' + ptBottomLeft + ' L ' + firstPoint + ' ' + cmd; } else { cmd = 'M ' + firstPoint + ' L ' + firstPoint + (isSpline ? '' : (' L ' + firstPoint + ' ')) + cmd; } } else { if (!isSpline) cmd = 'M ' + firstPoint + ' ' + 'L ' + firstPoint + ' ' + cmd; } if ((isPolar && isClosedPolar) || isRange) cmd += ' Z'; return cmd; } /** @private */ _getSerieSettings(groupIndex, seriesIndex) { let group = this.seriesGroups[groupIndex]; let isArea = group.type.indexOf('area') !== -1; let isLine = group.type.indexOf('line') !== -1; let serie = group.series[seriesIndex]; let dashStyle = serie.dashStyle || group.dashStyle || ''; let opacity = serie.opacity || group.opacity; if (isNaN(opacity) || opacity < 0 || opacity > 1) opacity = 1; let stroke = serie.lineWidth; if (isNaN(stroke) && stroke !== 'auto') stroke = group.lineWidth; if (stroke === 'auto' || isNaN(stroke) || stroke < 0 || stroke > 15) { if (isArea) stroke = 2; else if (isLine) stroke = 3; else stroke = 1; } let strokeSymbol = serie.lineWidthSymbol; if (isNaN(strokeSymbol)) strokeSymbol = 1; return { stroke: stroke, strokeSymbol: strokeSymbol, opacity: opacity, dashStyle: dashStyle }; } /** @private */ _getColors(gidx, sidx, iidx, gradientType, gradientStops) { let group = this.seriesGroups[gidx]; let serie = group.series[sidx]; let useGradient = this._get([serie.useGradientColors, group.useGradientColors, false]); let colors = this._getSeriesColors(gidx, sidx, iidx); //if (!colors.fillColor) { // colors.fillColor = color; // colors.fillColorSelected = this.renderer.adjustColor(color, 1.1); // colors.fillColorAlt = this.renderer.adjustColor(color, 4.0); // colors.fillColorAltSelected = this.renderer.adjustColor(color, 3.0); // colors.lineColor = colors.symbolColor = this.renderer.adjustColor(color, 0.9); // colors.lineColorSelected = colors.symbolColorSelected = this.renderer.adjustColor(color, 0.9); //} let stops2 = [[0, 1.4], [100, 1]]; let stops4 = [[0, 1], [25, 1.1], [50, 1.4], [100, 1]]; let stopsR = [[0, 1.3], [90, 1.2], [100, 1.0]]; let stops = NaN; if (!isNaN(gradientStops)) { stops = gradientStops === 2 ? stops2 : stops4; } if (useGradient) { let copy = {}; for (let i in colors) copy[i] = colors[i]; colors = copy; if (gradientType === 'verticalLinearGradient' || gradientType === 'horizontalLinearGradient') { let stopsParam = gradientType === 'verticalLinearGradient' ? stops || stops2 : stops || stops4; let keys = ['fillColor', 'fillColorSelected', 'fillColorAlt', 'fillColorAltSelected']; for (let key in keys) { let color = colors[keys[key]]; if (color) colors[keys[key]] = this.renderer._toLinearGradient(color, gradientType === 'verticalLinearGradient', stopsParam); } } else if (gradientType === 'radialGradient') { let params; let stops = stops2; if ((group.type === 'pie' || group.type === 'donut' || group.polar) && iidx !== undefined && iidx !== null && this._renderData[gidx] && this._renderData[gidx].offsets[sidx]) { params = this._renderData[gidx].offsets[sidx][iidx]; stops = stopsR; } colors.fillColor = this.renderer._toRadialGradient(colors.fillColor, stops, params); colors.fillColorSelected = this.renderer._toRadialGradient(colors.fillColorSelected, stops, params); } } return colors; } /** @private */ _installHandlers(element, elementType, gidx, sidx, iidx) { if (!this.enableEvents) return false; var self = this; var g = this.seriesGroups[gidx]; var s = this.seriesGroups[gidx].series[sidx]; var isLineType = g.type.indexOf('line') !== -1 || g.type.indexOf('area') !== -1; if (!isLineType && !(g.enableSelection === false || s.enableSelection === false)) { this.renderer.addHandler(element, 'mousemove', function (e) { var selected = self._selected; if (selected && selected.isLineType && selected.linesUnselectMode === 'click' && !(selected.group === gidx && selected.series === sidx)) return; //e.preventDefault(); //var x = e.pageX || e.clientX || e.screenX; //var y = e.pageY || e.clientY || e.screenY; //const pos = self.getBoundingClientRect(); //x -= pos.left; //y -= pos.top; //if (self._mouseX === x && self._mouseY === y) // return; if (self._ttEl) { if (self._ttEl.gidx === gidx && self._ttEl.sidx === sidx && self._ttEl.iidx === iidx) return; } self._startTooltipTimer(gidx, sidx, iidx); }); } if (!(g.enableSelection === false || s.enableSelection === false)) { this.renderer.addHandler(element, 'mouseover', function () { //e.preventDefault(); var selected = self._selected; if (selected && selected.isLineType && selected.linesUnselectMode === 'click' && !(selected.group === gidx && selected.series === sidx)) return; self._select(element, elementType, gidx, sidx, iidx, iidx); }); } this.renderer.addHandler(element, 'click', function (e) { clearTimeout(self._hostClickTimer); self._lastClickTs = (new Date()).valueOf(); if (isLineType && (elementType !== 'symbol' && elementType !== 'pointMarker')) return; if (self._isColumnType(g.type)) self._unselect(); if (isNaN(iidx)) return; e.stopImmediatePropagation(); self._raiseItemEvent('click', g, s, iidx); }); } /** @private */ _getHorizontalOffset(gidx, sidx, x, y) { let rect = this._plotRect; let dataLength = this._getDataLen(gidx); if (dataLength === 0) return { index: undefined, value: x }; let renderData = this._calcGroupOffsets(gidx, this._plotRect); if (renderData.xoffsets.length === 0) return { index: undefined, value: undefined }; let px = x; let py = y; let g = this.seriesGroups[gidx]; let polarAxisCoords; if (g.polar || g.spider) polarAxisCoords = this._getPolarAxisCoords(gidx, rect); let minDist, idx, x1Selected, y1Selected; for (let i = renderData.xoffsets.first; i <= renderData.xoffsets.last; i++) { let x1 = renderData.xoffsets.data[i]; let y1 = renderData.offsets[sidx][i].to; let dist = 0; if (polarAxisCoords) { let point = this._toPolarCoord(polarAxisCoords, rect, x1 + rect.x, y1); x1 = point.x; y1 = point.y; dist = this.renderer._ptdist(px, py, x1, y1); } else { if (g.orientation === 'horizontal') { x1 += rect.y; let tmp = y1; y1 = x1; x1 = tmp; dist = this.renderer._ptdist(px, py, x1, y1); } else { x1 += rect.x; dist = Math.abs(px - x1); } } if (isNaN(minDist) || minDist > dist) { minDist = dist; idx = i; x1Selected = x1; y1Selected = y1; } } return { index: idx, value: renderData.xoffsets.data[idx], polarAxisCoords: polarAxisCoords, x: x1Selected, y: y1Selected }; } /** @private */ onmousemove(x, y) { if (this._mouseX === x && this._mouseY === y) return; this._mouseX = x; this._mouseY = y; if (!this._selected) return; let gidx = this._selected.group; let sidx = this._selected.series; let g = this.seriesGroups[gidx]; let s = g.series[sidx]; let rect = this._plotRect; if (this.renderer) { rect = this.renderer.getRect(); rect.x += 5; rect.y += 5; rect.width -= 10; rect.height -= 10; } if (x < rect.x + window.scrollX || x > rect.x + rect.width + window.scrollX || y < rect.y + window.scrollY || y > rect.y + rect.height + window.scrollY) { this._hideToolTip(); this._unselect(); return; } let inverse = g.orientation === 'horizontal'; rect = this._plotRect; if (g.type.indexOf('line') !== -1 || g.type.indexOf('area') !== -1) { let offset = this._getHorizontalOffset(gidx, this._selected.series, x, y); let i = offset.index; if (i === undefined || i === null) return; if (this._selected.item !== i) { let segs = this._linesRenderInfo[gidx][sidx].segments; let segId = 0; while (i > segs[segId].lastItemIndex) { segId++; if (segId >= segs.length) return; } let element = segs[segId].pathElement; let iidxBase = segs[segId].lastItemIndex; this._unselect(false); this._select(element, 'path', gidx, sidx, i, iidxBase); } // else // return; let symbolType = this._getSymbol(this._selected.group, this._selected.series); if (symbolType === 'none') symbolType = 'circle'; let renderData = this._calcGroupOffsets(gidx, rect); let to = renderData.offsets[this._selected.series][i].to; let from = to; if (g.type.indexOf('range') !== -1) { from = renderData.offsets[this._selected.series][i].from; } let cmp = inverse ? x : y; if (!isNaN(from) && Math.abs(cmp - from) < Math.abs(cmp - to)) y = from; else y = to; if (isNaN(y)) return; x = offset.value; if (inverse) { let tmp = x; x = y; y = tmp + rect.y; } else { x += rect.x; } if (offset.polarAxisCoords) { x = offset.x; y = offset.y; } y = this.renderer._ptrnd(y); x = this.renderer._ptrnd(x); if (this._pointMarker && this._pointMarker.element) { this.renderer.removeElement(this._pointMarker.element); this._pointMarker.element = undefined; } if (isNaN(x) || isNaN(y)) { return; } let colors = this._getSeriesColors(gidx, sidx, i); let settings = this._getSerieSettings(gidx, sidx); let symbolSize = s.symbolSizeSelected; if (isNaN(symbolSize)) symbolSize = s.symbolSize; if (isNaN(symbolSize) || symbolSize > 50 || symbolSize < 0) symbolSize = g.symbolSize; if (isNaN(symbolSize) || symbolSize > 50 || symbolSize < 0) symbolSize = 8; if (this.showToolTips || this.enableCrosshairs) { this._pointMarker = { type: symbolType, x: x, y: y, gidx: gidx, sidx: sidx, iidx: i }; this._pointMarker.element = this._drawSymbol( symbolType, x, y, colors.fillColorSymbolSelected, settings.opacity, colors.lineColorSymbolSelected, settings.opacity, settings.strokeSymbol, settings.dashStyle, symbolSize); this._installHandlers(this._pointMarker.element, 'pointMarker', gidx, sidx, i); } this._startTooltipTimer(gidx, this._selected.series, i); } } /** @private */ _drawSymbol(type, x, y, fillColor, fillOpacity, lineColor, lineOpacity, lineWidth, lineDashArray, size) { let element, sz = size || 6, sz2 = sz / 2, path; switch (type) { case 'none': return undefined; case 'circle': element = this.renderer.circle(x, y, sz / 2); break; case 'square': sz = sz - 1; sz2 = sz / 2; element = this.renderer.rect(x - sz2, y - sz2, sz, sz); break; case 'diamond': { path = 'M ' + (x - sz2) + ',' + (y) + ' L' + (x) + ',' + (y - sz2) + ' L' + (x + sz2) + ',' + (y) + ' L' + (x) + ',' + (y + sz2) + ' Z'; element = this.renderer.path(path); } break; case 'triangle_up': case 'triangle': { path = 'M ' + (x - sz2) + ',' + (y + sz2) + ' L ' + (x + sz2) + ',' + (y + sz2) + ' L ' + (x) + ',' + (y - sz2) + ' Z'; element = this.renderer.path(path); } break; case 'triangle_down': { path = 'M ' + (x - sz2) + ',' + (y - sz2) + ' L ' + (x) + ',' + (y + sz2) + ' L ' + (x + sz2) + ',' + (y - sz2) + ' Z'; element = this.renderer.path(path); } break; case 'triangle_left': { path = 'M ' + (x - sz2) + ',' + (y) + ' L ' + (x + sz2) + ',' + (y + sz2) + ' L ' + (x + sz2) + ',' + (y - sz2) + ' Z'; element = this.renderer.path(path); } break; case 'triangle_right': { path = 'M ' + (x - sz2) + ',' + (y - sz2) + ' L ' + (x - sz2) + ',' + (y + sz2) + ' L ' + (x + sz2) + ',' + (y) + ' Z'; element = this.renderer.path(path); } break; default: element = this.renderer.circle(x, y, sz); } this.renderer.attr(element, { fill: fillColor, 'fill-opacity': fillOpacity, stroke: lineColor, 'stroke-width': lineWidth, 'stroke-opacity': lineOpacity, 'stroke-dasharray': lineDashArray || '' }); // pass extra parameters required for HTML5 rendering if (type !== 'circle') { this.renderer.attr(element, { r: sz / 2 }); if (type !== 'square') this.renderer.attr(element, { x: x, y: y }); } return element; } /** @private */ _getSymbol(groupIndex, seriesIndex) { let symbols = ['circle', 'square', 'diamond', 'triangle_up', 'triangle_down', 'triangle_left', 'triangle_right']; let g = this.seriesGroups[groupIndex]; let s = g.series[seriesIndex]; let symbolType; if (s.symbolType !== undefined && s.symbolType !== null) symbolType = s.symbolType; if (symbolType === undefined || symbolType === null) symbolType = g.symbolType; if (symbolType === 'default') return symbols[seriesIndex % symbols.length]; else if (symbolType !== undefined && symbolType !== null) return symbolType; return 'none'; } /** @private */ _startTooltipTimer(gidx, sidx, iidx, x, y, showDelay, hideDelay) { this._cancelTooltipTimer(); let self = this; let delay = this.toolTipShowDelay; if (isNaN(delay) || delay > 10000 || delay < 0) delay = 500; if (this._ttEl || (true === this.enableCrosshairs && false === this.showToolTips)) delay = 0; if (!isNaN(showDelay)) delay = showDelay; clearTimeout(this._tttimerHide); if (isNaN(x)) x = self._mouseX; if (isNaN(y)) y = self._mouseY - 3; if (delay === 0) self._showToolTip(x, y, gidx, sidx, iidx); this._tttimer = setTimeout(function () { if (delay !== 0) self._showToolTip(x, y, gidx, sidx, iidx); let toolTipHideDelay = self.toolTipHideDelay; if (!isNaN(hideDelay)) toolTipHideDelay = hideDelay; if (isNaN(toolTipHideDelay)) toolTipHideDelay = 4000; self._tttimerHide = setTimeout(function () { self._hideToolTip(); self._unselect(); }, toolTipHideDelay); }, delay); } /** @private */ _cancelTooltipTimer() { clearTimeout(this._tttimer); } /** @private */ _getGroupGradientType(gidx) { let g = this.seriesGroups[gidx]; if (g.type.indexOf('area') !== -1) return g.orientation === 'horizontal' ? 'horizontalLinearGradient' : 'verticalLinearGradient'; else if (this._isColumnType(g.type) || g.type.indexOf('candle') !== -1) { if (g.polar) return 'radialGradient'; return g.orientation === 'horizontal' ? 'verticalLinearGradient' : 'horizontalLinearGradient'; } else if (g.type.indexOf('scatter') !== -1 || g.type.indexOf('bubble') !== -1 || this._isPieGroup(gidx)) return 'radialGradient'; return undefined; } /** @private */ _select(element, type, gidx, sidx, iidx, iidxBase) { if (this._selected) { if ((this._selected.item !== iidx || this._selected.series !== sidx || this._selected.group !== gidx) ) { this._unselect(); } else { return; } } let g = this.seriesGroups[gidx]; let s = g.series[sidx]; if (g.enableSelection === false || s.enableSelection === false) return; let isLineType = g.type.indexOf('line') !== -1 && g.type.indexOf('area') === -1; this._selected = { element: element, type: type, group: gidx, series: sidx, item: iidx, iidxBase: iidxBase, isLineType: isLineType, linesUnselectMode: s.linesUnselectMode || g.linesUnselectMode }; let colors = this._getColors(gidx, sidx, iidxBase || iidx, this._getGroupGradientType(gidx)); let fillColor = colors.fillColorSelected; if (isLineType) fillColor = 'none'; let settings = this._getSerieSettings(gidx, sidx); let lineColorSelected = (type === 'symbol') ? colors.lineColorSymbolSelected : colors.lineColorSelected; fillColor = (type === 'symbol') ? colors.fillColorSymbolSelected : fillColor; let lineWidth = (type === 'symbol') ? 1 : settings.stroke; if (type !== 'symbol' && this.renderer.getAttr(element, 'fill') === colors.fillColorAlt) fillColor = colors.fillColorAltSelected; this.renderer.attr(element, { 'stroke': lineColorSelected, fill: fillColor, 'stroke-width': lineWidth }); if (g.type.indexOf('pie') !== -1 || g.type.indexOf('donut') !== -1) { this._applyPieSelect(); } // raise mouseover event this._raiseItemEvent('mouseover', g, s, iidx); if (this._isTouchDevice) { this._startTooltipTimer(gidx, sidx, iidx); } } _applyPieSelect() { var self = this; self._createAnimationGroup('animPieSlice'); var selected = this._selected; if (!selected) return; var coord = this.getItemCoord(selected.group, selected.series, selected.item); if (!coord) return; var element = this._getRenderInfo(selected.group, selected.series, selected.item); var ctx = { element: element, coord: coord }; this._enqueueAnimation( 'animPieSlice', undefined, undefined, 300, function (element, ctx, percent) { var coord = ctx.coord; var radiusAdj = coord.selectedRadiusChange * percent; var cmd = self.renderer.pieSlicePath(coord.center.x, coord.center.y, coord.innerRadius === 0 ? 0 : (coord.innerRadius + radiusAdj), coord.outerRadius + radiusAdj, coord.fromAngle, coord.toAngle, coord.centerOffset); self.renderer.attr(ctx.element.element, { 'd': cmd }); self._showPieLabel(selected.group, selected.series, selected.item, undefined, radiusAdj, ctx.element.colors.lineColor); }, ctx); self._startAnimation('animPieSlice'); } _applyPieUnselect() { this._stopAnimations(); let selected = this._selected; if (!selected) return; let coord = this.getItemCoord(selected.group, selected.series, selected.item); if (!coord || !coord.center) return; let cmd = this.renderer.pieSlicePath(coord.center.x, coord.center.y, coord.innerRadius, coord.outerRadius, coord.fromAngle, coord.toAngle, coord.centerOffset); this.renderer.attr(selected.element, { 'd': cmd }); this._showPieLabel(selected.group, selected.series, selected.item, undefined, 0, this._getRenderInfo(selected.group, selected.series, selected.item).colors.lineColor); } /** @private */ _unselect() { let self = this; if (self._selected) { let gidx = self._selected.group; let sidx = self._selected.series; let iidx = self._selected.item; let iidxBase = self._selected.iidxBase; let type = self._selected.type; let g = self.seriesGroups[gidx]; let s = g.series[sidx]; let isLineType = g.type.indexOf('line') !== -1 && g.type.indexOf('area') === -1; let colors = self._getColors(gidx, sidx, iidxBase || iidx, self._getGroupGradientType(gidx)); let fillColor = colors.fillColor; if (isLineType) fillColor = 'none'; let settings = self._getSerieSettings(gidx, sidx); let lineColor = (type === 'symbol') ? colors.lineColorSymbol : colors.lineColor; fillColor = (type === 'symbol') ? colors.fillColorSymbol : fillColor; if (type !== 'symbol' && this.renderer.getAttr(self._selected.element, 'fill') === colors.fillColorAltSelected) fillColor = colors.fillColorAlt; let lineWidth = (type === 'symbol') ? 1 : settings.stroke; self.renderer.attr(self._selected.element, { 'stroke': lineColor, fill: fillColor, 'stroke-width': lineWidth }); if (g.type.indexOf('pie') !== -1 || g.type.indexOf('donut') !== -1) { this._applyPieUnselect(); } self._selected = undefined; if (!isNaN(iidx)) self._raiseItemEvent('mouseout', g, s, iidx); } if (self._pointMarker) { if (self._pointMarker.element) { self.renderer.removeElement(self._pointMarker.element); self._pointMarker.element = undefined; } self._pointMarker = undefined; self._hideCrosshairs(); } } /** @private */ _raiseItemEvent(event, group, serie, index) { let fn = serie[event] || group[event]; let gidx = 0; for (; gidx < this.seriesGroups.length; gidx++) if (this.seriesGroups[gidx] === group) break; if (gidx === this.seriesGroups.length) return; let args = { event: event, seriesGroup: group, serie: serie, elementIndex: index, elementValue: this._getDataValue(index, serie.dataField, gidx) }; if (fn && typeof fn === 'function') fn(args); this.$.fireEvent(event, args); } /** @private */ _calcInterval(min, max, countHint) { let diff = Math.abs(max - min); let approx = diff / countHint; let up = [1, 2, 3, 4, 5, 10, 15, 20, 25, 50, 100]; let dw = [0.5, 0.25, 0.125, 0.1]; let scale = 0.1; let arr = up; if (approx < 1) { arr = dw; scale = 10; } let idx = 0; do { idx = 0; if (approx >= 1) scale *= 10; else scale /= 10; for (let i = 1; i < arr.length; i++) { if (Math.abs(arr[idx] * scale - approx) > Math.abs(arr[i] * scale - approx)) idx = i; else break; } } while (idx === arr.length - 1); return arr[idx] * scale; } //** @private */ _renderDataClone() { if (!this._renderData || this._isToggleRefresh) return; let info = this._elementRenderInfo = []; if (this._isSelectorRefresh) return; for (let groupIndex = 0; groupIndex < this._renderData.length; groupIndex++) { //let catField = this._getXAxis(groupIndex).dataField; while (info.length <= groupIndex) info.push({}); let groupInfo = info[groupIndex]; let data = this._renderData[groupIndex]; if (!data.offsets) continue; if (data.valueAxis) { groupInfo.valueAxis = { itemOffsets: {} }; for (let key in data.valueAxis.itemOffsets) { groupInfo.valueAxis.itemOffsets[key] = data.valueAxis.itemOffsets[key]; } } if (data.xAxis) { groupInfo.xAxis = { itemOffsets: {} }; for (let key in data.xAxis.itemOffsets) { groupInfo.xAxis.itemOffsets[key] = data.xAxis.itemOffsets[key]; } } groupInfo.series = []; let series = groupInfo.series; let isPieSeries = this._isPieGroup(groupIndex); for (let s = 0; s < data.offsets.length; s++) { series.push({}); for (let i = 0; i < data.offsets[s].length; i++) if (!isPieSeries) { series[s][data.xoffsets.xvalues[i]] = { value: data.offsets[s][i].value, /*valueFrom: data.offsets[s][i].valueFrom,*/valueRadius: data.offsets[s][i].valueRadius, xoffset: data.xoffsets.data[i], from: data.offsets[s][i].from, to: data.offsets[s][i].to }; } else { let item = data.offsets[s][i]; series[s][item.displayValue] = { value: item.value, x: item.x, y: item.y, fromAngle: item.fromAngle, toAngle: item.toAngle }; } } } } getPolarDataPointOffset(xValue, yValue, groupIndex) { let renderData = this._renderData[groupIndex]; if (!renderData) return { x: NaN, y: NaN }; let y = this.getValueAxisDataPointOffset(yValue, groupIndex); let x = this.getXAxisDataPointOffset(xValue, groupIndex); let pt = this._toPolarCoord(renderData.polarCoords, renderData.xAxis.rect, x, y); return { x: pt.x, y: pt.y }; } /** @private */ _getDataPointOffsetDiff(value1, value2, baseValue, logBase, scale, yzero, inverse) { let offset1 = this._getDataPointOffset(value1, baseValue, logBase, scale, yzero, inverse); let offset2 = this._getDataPointOffset(value2, baseValue, logBase, scale, yzero, inverse); return Math.abs(offset1 - offset2); } _getXAxisRenderData(groupIndex) { if (groupIndex >= this._renderData.length) return; let group = this.seriesGroups[groupIndex]; let renderData = this._renderData[groupIndex].xAxis; if (!renderData) return; if (group.xAxis === undefined || group.xAxis === null) { // get common xAxis render data (it will be attached to the 1st group) for (let i = 0; i <= groupIndex; i++) { if (this.seriesGroups[i].xAxis === undefined || this.seriesGroups[i].xAxis === null) { renderData = this._renderData[i].xAxis; break; } } } return renderData; } getXAxisDataPointOffset(value, groupIndex) { let group = this.seriesGroups[groupIndex] if (isNaN(value)) return NaN; const renderData = this._getXAxisRenderData(groupIndex); if (!renderData) return NaN; let stats = renderData.data.axisStats; let axisMin = stats.min.valueOf(); let axisMax = stats.max.valueOf(); let denom = axisMax - axisMin; if (denom === 0) denom = 1; if (value.valueOf() > axisMax || value.valueOf() < axisMin) return NaN; let axis = this._getXAxis(groupIndex); let sizeProp = group.orientation === 'horizontal' ? 'height' : 'width'; let xProp = group.orientation === 'horizontal' ? 'y' : 'x'; let percent = (value.valueOf() - axisMin) / denom; let size = renderData.rect[sizeProp] - renderData.data.padding.left - renderData.data.padding.right; if (group.polar || group.spider) { let polarCoords = this._renderData[groupIndex].polarCoords; if (polarCoords.isClosedCircle) size = renderData.data.axisSize; } return this._plotRect[xProp] + renderData.data.padding.left + size * (axis.flip ? (1 - percent) : percent); } getValueAxisDataPointOffset(value, groupIndex) { let valueAxis = this._getValueAxis(groupIndex); if (!valueAxis) return NaN; let renderData = this._renderData[groupIndex]; if (!renderData) return NaN; let flip = valueAxis.flip === true; let logBase = renderData.logBase; let scale = renderData.scale; let baseValue = renderData.gbase; let yzero = renderData.baseOffset; return this._getDataPointOffset(value, baseValue, logBase, scale, yzero, flip); } /** @private */ _getDataPointOffset(value, baseValue, logBase, scale, yzero, inverse) { let offset; if (isNaN(value)) value = baseValue; if (!isNaN(logBase)) { offset = (this._draw.log(value, logBase) - this._draw.log(baseValue, logBase)) * scale; } else { offset = (value - baseValue) * scale; } if (inverse) offset = yzero + offset; else offset = yzero - offset; return offset; } /** @private */ _calcGroupOffsets(groupIndex, rect) { let group = this.seriesGroups[groupIndex]; while (this._renderData.length < groupIndex + 1) this._renderData.push({}); if (this._renderData[groupIndex] !== null && this._renderData[groupIndex].offsets !== undefined) return this._renderData[groupIndex]; if (this._isPieGroup(groupIndex)) { return this._calcPieSeriesGroupOffsets(groupIndex, rect); } let valueAxis = this._getValueAxis(groupIndex); if (!valueAxis || !group.series || group.series.length === 0) return this._renderData[groupIndex]; let inverse = valueAxis.flip === true; let logAxis = valueAxis.logarithmicScale === true; let logBase = valueAxis.logarithmicScaleBase || 10; let out = []; let isStacked = group.type.indexOf('stacked') !== -1; let isStacked100 = isStacked && group.type.indexOf('100') !== -1; let isRange = group.type.indexOf('range') !== -1; let isColumn = this._isColumnType(group.type); let isWaterfall = group.type.indexOf('waterfall') !== -1; let dataLength = this._getDataLen(groupIndex); let gbase = group.baselineValue || valueAxis.baselineValue || 0; if (isStacked100) gbase = 0; let stat = this._stats.seriesGroups[groupIndex]; if (!stat || !stat.isValid) return; let hasValuesOnBothSidesOfBase = stat.hasStackValueReversal; if (hasValuesOnBothSidesOfBase) gbase = 0; if (isWaterfall && isStacked) if (hasValuesOnBothSidesOfBase) // not supported return; else gbase = stat.base; if (gbase > stat.max) gbase = stat.max; if (gbase < stat.min) gbase = stat.min; let range = (isStacked100 || logAxis) ? stat.maxRange : stat.max - stat.min; let min = stat.min; let max = stat.max; let scale = rect.height / (logAxis ? stat.intervals : range); let yzero = 0; if (isStacked100) { if (min * max < 0) { range /= 2; yzero = -(range + gbase) * scale; } else { yzero = -gbase * scale; } } else yzero = -(gbase - min) * scale; if (inverse) yzero = rect.y - yzero; else yzero += rect.y + rect.height; let yPOffset = []; let yNOffset = []; let yOffsetError = []; let pIntervals; if (logAxis) { pIntervals = this._draw.log(max, logBase) - this._draw.log(gbase, logBase); if (isStacked) { // force base value @ min for stacked log series pIntervals = stat.intervals; gbase = isStacked100 ? 0 : min; } if (!inverse) yzero = rect.y + pIntervals / stat.intervals * rect.height; } yzero = this.renderer._ptrnd(yzero); let th = (min * max < 0) ? rect.height / 2 : rect.height; let logSums = []; let stackSums = []; let useOffsetBasedStackCalculation = isStacked && (isColumn || logAxis); let firstItemRendered = []; out = new Array(group.series.length); for (let j = 0; j < group.series.length; j++) out[j] = new Array(dataLength); for (let i = 0; i < dataLength; i++) { if (!isWaterfall && isStacked) stackSums = []; for (let j = 0; j < group.series.length; j++) { if (!isStacked && logAxis) logSums = []; let serie = group.series[j]; let dataField = serie.dataField; let dataFieldFrom = serie.dataFieldFrom; let dataFieldTo = serie.dataFieldTo; let dataFieldRadius = serie.radiusDataField || serie.sizeDataField; out[j][i] = {}; let isVisible = this._isSerieVisible(groupIndex, j); if (group.type.indexOf('candle') !== -1 || group.type.indexOf('ohlc') !== -1) { // handle financial series let fields = ['Open', 'Close', 'High', 'Low']; for (let f in fields) { let field = 'dataField' + fields[f]; if (serie[field]) { out[j][i][fields[f]] = this._getDataPointOffset( this._getDataValueAsNumber(i, serie[field], groupIndex), gbase, logAxis ? logBase : NaN, scale, yzero, inverse); } } continue; } if (isStacked) { while (stackSums.length <= i) stackSums.push(0); } let valFrom = NaN; if (isRange) { valFrom = this._getDataValueAsNumber(i, dataFieldFrom, groupIndex); if (isNaN(valFrom)) valFrom = gbase; } let val = NaN; if (isRange) val = this._getDataValueAsNumber(i, dataFieldTo, groupIndex); else val = this._getDataValueAsNumber(i, dataField, groupIndex); let valR = this._getDataValueAsNumber(i, dataFieldRadius, groupIndex); if (isStacked) stackSums[i] += isVisible ? val : 0; if (!isVisible) val = NaN; if (isNaN(val) || (logAxis && val <= 0)) { out[j][i] = { from: undefined, to: undefined }; continue; } let yOffset; if (isStacked) { if (useOffsetBasedStackCalculation) { yOffset = (val >= gbase) ? yPOffset : yNOffset; } else val = stackSums[i]; } let h = scale * (val - gbase); if (isRange) h = scale * (val - valFrom); if (isStacked && useOffsetBasedStackCalculation) { if (!firstItemRendered[i]) { firstItemRendered[i] = true; h = scale * (val - gbase); } else { h = scale * val; } } if (logAxis) { while (logSums.length <= i) logSums.push({ p: { value: 0, height: 0 }, n: { value: 0, height: 0 } }); let base = (isRange || isRange) ? valFrom : gbase; let sums = val > base ? logSums[i].p : logSums[i].n; sums.value += val; if (isStacked100) { val = sums.value / (stat.psums[i] + stat.nsums[i]) * 100; h = (this._draw.log(val, logBase) - stat.minPow) * scale; } else { h = this._draw.log(sums.value, logBase) - this._draw.log(base, logBase); h *= scale; } h -= sums.height; sums.height += h; } let y = yzero; if (isRange) { let yDiff = 0; if (logAxis) yDiff = (this._draw.log(valFrom, logBase) - this._draw.log(gbase, logBase)) * scale; else yDiff = (valFrom - gbase) * scale; y += inverse ? yDiff : -yDiff; } if (isStacked) { if (isStacked100 && !logAxis) { let irange = (stat.psums[i] - stat.nsums[i]); if (val > gbase) { h = (stat.psums[i] / irange) * th; if (stat.psums[i] !== 0) h *= val / stat.psums[i]; } else { h = (stat.nsums[i] / irange) * th; if (stat.nsums[i] !== 0) h *= val / stat.nsums[i]; } } if (useOffsetBasedStackCalculation) { if (isNaN(yOffset[i])) yOffset[i] = y; y = yOffset[i]; } } if (isNaN(yOffsetError[i])) yOffsetError[i] = 0; let err = yOffsetError[i]; h = Math.abs(h); let hSave = h; if (h >= 1) { const h_new = this.renderer._ptrnd(h) - 1; if (Math.abs(h - h_new) > 0.5) h = Math.round(h); else h = h_new; } err += h - hSave; if (!isStacked) err = 0; if (Math.abs(err) > 0.5) { if (err > 0) { h -= 1; err -= 1; } else { h += 1; err += 1; } } yOffsetError[i] = err; // adjust the height to make sure it span the entire height // otherwise there will be a few pixels inaccuracy if (j === group.series.length - 1 && isStacked100) { let sumH = 0; for (let k = 0; k < j; k++) sumH += Math.abs(out[k][i].to - out[k][i].from); sumH += h; if (sumH < th) { if (h > 0.5) h = this.renderer._ptrnd(h + th - sumH); else { let k = j - 1; while (k >= 0) { let diff = Math.abs(out[k][i].to - out[k][i].from); if (diff > 1) { if (out[k][i].from > out[k][i].to) { out[k][i].from += th - sumH; } break; } k--; } } } } if (inverse) h *= -1; let drawOpositeDirection = val < gbase; if (isRange) drawOpositeDirection = valFrom > val; let outVal = isNaN(valFrom) ? val : { from: valFrom, to: val }; if (drawOpositeDirection) { if (useOffsetBasedStackCalculation) yOffset[i] += h; out[j][i] = { from: y, to: y + h, value: outVal, valueRadius: valR }; } else { if (useOffsetBasedStackCalculation) yOffset[i] -= h; out[j][i] = { from: y, to: y - h, value: outVal, valueRadius: valR }; } } // for j } // for i let renderData = this._renderData[groupIndex]; renderData.baseOffset = yzero; renderData.gbase = gbase; renderData.logBase = logAxis ? logBase : NaN; renderData.scale = scale; renderData.offsets = !isWaterfall ? out : this._applyWaterfall(out, dataLength, groupIndex, yzero, gbase, logAxis ? logBase : NaN, scale, inverse, isStacked); renderData.xoffsets = this._calculateXOffsets(groupIndex, rect.width); return this._renderData[groupIndex]; } _isPercent(value) { return (typeof (value) === 'string' && value.length > 0 && value.indexOf('%') === value.length - 1); } /** @private */ _calcPieSeriesGroupOffsets(groupIndex, rect) { var self = this; var dataLength = this._getDataLen(groupIndex); var group = this.seriesGroups[groupIndex]; var renderData = this._renderData[groupIndex] = {}; var out = renderData.offsets = []; for (let sidx = 0; sidx < group.series.length; sidx++) { var s = group.series[sidx]; var minAngle = this._get([s.minAngle, s.startAngle]); if (isNaN(minAngle) || minAngle < 0 || minAngle > 360) minAngle = 0; var maxAngle = this._get([s.maxAngle, s.endAngle]); if (isNaN(maxAngle) || maxAngle < 0 || maxAngle > 360) maxAngle = 360; var angleRange = maxAngle - minAngle; var initialAngle = s.initialAngle || 0; if (initialAngle < minAngle) initialAngle = minAngle; if (initialAngle > maxAngle) initialAngle = maxAngle; var centerOffset = s.centerOffset || 0; var offsetX = this._draw.getNum([s.offsetX, group.offsetX, rect.width / 2]); var offsetY = this._draw.getNum([s.offsetY, group.offsetY, rect.height / 2]); var availableSize = Math.min(rect.width, rect.height) / 2; var currentAngle = initialAngle; // outer radius var radius = s.radius; if (self._isPercent(radius)) radius = parseFloat(radius) / 100 * availableSize; if (isNaN(radius)) radius = availableSize * 0.4; // inner radius var innerRadius = s.innerRadius; if (self._isPercent(innerRadius)) innerRadius = parseFloat(innerRadius) / 100 * availableSize; if (isNaN(innerRadius) || innerRadius >= radius) innerRadius = 0; // selected radius var selectedRadiusChange = s.selectedRadiusChange; if (self._isPercent(selectedRadiusChange)) selectedRadiusChange = parseFloat(selectedRadiusChange) / 100 * (radius - innerRadius); if (isNaN(selectedRadiusChange)) selectedRadiusChange = 0.1 * (radius - innerRadius); out.push([]); // compute the sum var sumP = 0; var sumN = 0; for (let i = 0; i < dataLength; i++) { var val = this._getDataValueAsNumber(i, s.dataField, groupIndex); if (isNaN(val)) continue; if (!this._isSerieVisible(groupIndex, sidx, i) && s.hiddenPointsDisplay !== true) continue; if (val > 0) sumP += val; else sumN += val; } var range = sumP - sumN; if (range === 0) range = 1; // render for (let i = 0; i < dataLength; i++) { var val = this._getDataValueAsNumber(i, s.dataField, groupIndex); if (isNaN(val)) { out[sidx].push({}); continue; } var displayField = s.displayText || s.displayField; var displayValue = this._getDataValue(i, displayField, groupIndex); if (displayValue === undefined || displayValue === null) displayValue = i; var angle = 0; var isVisible = this._isSerieVisible(groupIndex, sidx, i); if (isVisible || s.hiddenPointsDisplay === true) { angle = Math.abs(val) / range * angleRange; } var x = rect.x + offsetX; var y = rect.y + offsetY; var centerOffsetValue = centerOffset; if (typeof centerOffset === 'function') { centerOffsetValue = centerOffset({ seriesIndex: sidx, seriesGroupIndex: groupIndex, itemIndex: i }); } if (isNaN(centerOffsetValue)) centerOffsetValue = 0; var sliceRenderData = { key: groupIndex + '_' + sidx + '_' + i, value: val, displayValue: displayValue, x: x, y: y, fromAngle: currentAngle, toAngle: currentAngle + angle, centerOffset: centerOffsetValue, innerRadius: innerRadius, outerRadius: radius, selectedRadiusChange: selectedRadiusChange, visible: isVisible }; out[sidx].push(sliceRenderData); currentAngle += angle; } } return renderData; } /** @private */ _isPointSeriesOnly() { for (let i = 0; i < this.seriesGroups.length; i++) { let g = this.seriesGroups[i]; if (g.type.indexOf('line') === -1 && g.type.indexOf('area') === -1 && g.type.indexOf('scatter') === -1 && g.type.indexOf('bubble') === -1) return false; } return true; } /** @private */ _hasColumnSeries() { let types = ['column', 'ohlc', 'candlestick', 'waterfall']; for (let i = 0; i < this.seriesGroups.length; i++) { let g = this.seriesGroups[i]; for (let j in types) if (g.type.indexOf(types[j]) !== -1) return true; } return false; } /** @private */ _alignValuesWithTicks(groupIndex) { let psonly = this._isPointSeriesOnly(); let g = this.seriesGroups[groupIndex]; // if xAxis let xAxis = this._getXAxis(groupIndex); let xAxisValuesOnTicks = xAxis.valuesOnTicks === undefined || xAxis.valuesOnTicks === null ? psonly : xAxis.valuesOnTicks !== false; if (xAxis.logarithmicScale) xAxisValuesOnTicks = true; if (groupIndex === undefined || groupIndex === null) return xAxisValuesOnTicks; if (g.valuesOnTicks === undefined || g.valuesOnTicks === null) return xAxisValuesOnTicks; return g.valuesOnTicks; } _getYearsDiff(from, to) { return to.getFullYear() - from.getFullYear(); } _getMonthsDiff(from, to) { return 12 * (to.getFullYear() - from.getFullYear()) + to.getMonth() - from.getMonth(); } _getDateDiff(from, to, baseUnit, round) { let diff = 0; if (baseUnit !== 'year' && baseUnit !== 'month') diff = to.valueOf() - from.valueOf(); switch (baseUnit) { case 'year': diff = this._getYearsDiff(from, to); break; case 'month': diff = this._getMonthsDiff(from, to); break; case 'day': diff /= (24 * 3600 * 1000); break; case 'hour': diff /= (3600 * 1000); break; case 'minute': diff /= (60 * 1000); break; case 'second': diff /= (1000); break; case 'millisecond': break; } if (baseUnit !== 'year' && baseUnit !== 'month' && round !== false) diff = this.renderer._rnd(diff, 1, true); return diff; } _getBestDTUnit(min, max, groupIndex, axisSize, targetItemWidth) { let dateTimeUnit = 'day'; let range = max.valueOf() - min.valueOf(); if (range < 1000) dateTimeUnit = 'second'; else if (range < 3600000) dateTimeUnit = 'minute'; else if (range < 86400000) dateTimeUnit = 'hour'; else if (range < 2592000000) dateTimeUnit = 'day'; else if (range < 31104000000) dateTimeUnit = 'month'; else dateTimeUnit = 'year'; let units = [ { key: 'year', cnt: range / (1000 * 60 * 60 * 24 * 365) }, { key: 'month', cnt: range / (1000 * 60 * 60 * 24 * 30) }, { key: 'day', cnt: range / (1000 * 60 * 60 * 24) }, { key: 'hour', cnt: range / (1000 * 60 * 60) }, { key: 'minute', cnt: range / (1000 * 60) }, { key: 'second', cnt: range / 1000 }, { key: 'millisecond', cnt: range } ]; let i = -1; for (let j = 0; j < units.length; j++) if (units[j].key === dateTimeUnit) { i = j; break; } let bestCnt = -1, bestIndex = -1; for (; i < units.length; i++) { if (units[i].cnt / 100 > axisSize) break; let interval = this._estAxisInterval(min, max, groupIndex, axisSize, units[i].key, targetItemWidth); let cnt = this._getDTIntCnt(min, max, interval, units[i].key); if (bestCnt === -1 || bestCnt < cnt) { bestCnt = cnt; bestIndex = i; } } dateTimeUnit = units[bestIndex].key; return dateTimeUnit; } /** @private */ _getXAxisStats(groupIndex, xAxis, axisSize) { let dataLength = this._getDataLen(groupIndex); let isDateTime = xAxis.type === 'date' || xAxis.type === 'time'; if (isDateTime && !this._autoDateFormats) { if (!this._autoDateFormats) this._autoDateFormats = []; let detectedFormat = this._testXAxisDateFormat(); if (detectedFormat) this._autoDateFormats.push(detectedFormat); } let axisMin = isDateTime ? this._castAsDate(xAxis.minValue, xAxis.dateFormat) : this._castAsNumber(xAxis.minValue); let axisMax = isDateTime ? this._castAsDate(xAxis.maxValue, xAxis.dateFormat) : this._castAsNumber(xAxis.maxValue); if (this._selectorRange && this._selectorRange[groupIndex]) { let rangeMin = this._selectorRange[groupIndex].min; if (!isNaN(rangeMin)) axisMin = isDateTime ? this._castAsDate(rangeMin, xAxis.dateFormat) : this._castAsNumber(rangeMin); let rangeMax = this._selectorRange[groupIndex].max; if (!isNaN(rangeMax)) axisMax = isDateTime ? this._castAsDate(rangeMax, xAxis.dateFormat) : this._castAsNumber(rangeMax); } let min = axisMin, max = axisMax; let minDS, maxDS; let autoDetect = xAxis.type === undefined || xAxis.type === null || xAxis.type === 'auto'; let useIndeces = (autoDetect || xAxis.type === 'basic'); let cntDateTime = 0, cntNumber = 0; for (let i = 0; i < dataLength && xAxis.dataField; i++) { let value = this._getDataValue(i, xAxis.dataField, groupIndex); value = isDateTime ? this._castAsDate(value, xAxis.dateFormat) : this._castAsNumber(value); if (isNaN(value)) continue; if (isDateTime) cntDateTime++; else cntNumber++; if (isNaN(minDS) || value < minDS) minDS = value; if (isNaN(maxDS) || value >= maxDS) maxDS = value; } if (autoDetect && ((!isDateTime && cntNumber === dataLength) || (isDateTime && cntDateTime === dataLength)) ) { useIndeces = false; } if (useIndeces) { minDS = 0; maxDS = Math.max(0, dataLength - 1); } // use the data source min/max if not set if (isNaN(min)) min = minDS; if (isNaN(max)) max = maxDS; // convert to date if (isDateTime) { if (!this._isDate(min)) min = this._isDate(max) ? max : new Date(); if (!this._isDate(max)) max = this._isDate(min) ? min : new Date(); } else { if (isNaN(min)) min = 0; if (isNaN(max)) max = useIndeces ? Math.max(0, dataLength - 1) : min; } if (minDS === undefined || minDS === null) minDS = min; if (maxDS === undefined || maxDS === null) maxDS = max; // ensure min/max ranges are within the selector ranges let rangeSelector = xAxis.rangeSelector && xAxis.rangeSelector.visible; if (rangeSelector) { let selectorMin = rangeSelector.minValue || min; if (selectorMin && isDateTime) selectorMin = this._castAsDate(selectorMin, rangeSelector.dateFormat || xAxis.dateFormat); let selectorMax = rangeSelector.maxValue || max; if (selectorMax && isDateTime) selectorMax = this._castAsDate(selectorMax, rangeSelector.dateFormat || xAxis.rangeSelector); if (min < selectorMin) min = selectorMin; if (max < selectorMin) max = selectorMax; if (min > selectorMax) min = selectorMin; if (max > selectorMax) max = selectorMax; } let dateTimeUnit, isTimeUnit; if (isDateTime) { dateTimeUnit = xAxis.baseUnit; if (!dateTimeUnit) { dateTimeUnit = this._getBestDTUnit(min, max, groupIndex, axisSize); } isTimeUnit = dateTimeUnit === 'hour' || dateTimeUnit === 'minute' || dateTimeUnit === 'second' || dateTimeUnit === 'millisecond'; } let isLogAxis = xAxis.logarithmicScale === true; let logBase = xAxis.logarithmicScaleBase; if (isNaN(logBase) || logBase <= 1) logBase = 10; let interval = xAxis.unitInterval; if (isLogAxis) interval = 1; else if (isNaN(interval) || interval <= 0) interval = this._estAxisInterval(min, max, groupIndex, axisSize, dateTimeUnit); let filterRange = { min: min, max: max }; let group = this.seriesGroups[groupIndex], minPow, maxPow; if (isLogAxis) { if (!min) { min = 1; if (max && min > max) min = max; } if (!max) { max = min; } filterRange = { min: min, max: max }; minPow = this.renderer._rnd(this._draw.log(min, logBase), 1, false); maxPow = this.renderer._rnd(this._draw.log(max, logBase), 1, true); max = Math.pow(logBase, maxPow); min = Math.pow(logBase, minPow); } else if (!isDateTime && (group.polar || group.spider)) { // TODO: evaluate applying to all series min = this.renderer._rnd(min, interval, false); max = this.renderer._rnd(max, interval, true); } return { min: min, max: max, logAxis: { enabled: isLogAxis, base: logBase, minPow: minPow, maxPow: maxPow }, dsRange: { min: minDS, max: maxDS }, filterRange: filterRange, useIndeces: useIndeces, isDateTime: isDateTime, isTimeUnit: isTimeUnit, dateTimeUnit: dateTimeUnit, interval: interval }; } /** @private */ _getDefaultDTFormatFn(dateTimeUnit) { let months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; let fn; if (dateTimeUnit === 'year' || dateTimeUnit === 'month' || dateTimeUnit === 'day') { fn = function (value) { return value.getDate() + '-' + months[value.getMonth()] + '-' + value.getFullYear(); }; } else { fn = function (value) { return value.getDate() + '-' + months[value.getMonth()] + '-' + value.getFullYear() + '<br>' + value.getHours() + ':' + value.getMinutes() + ':' + value.getSeconds(); }; } return fn; } /** @private */ _getDTIntCnt(min, max, interval, dateTimeUnit) { let cnt = 0; let curr = new Date(min); let maxDate = new Date(max); maxDate = maxDate.valueOf(); if (interval <= 0) return 1; while (curr.valueOf() < maxDate) { if (dateTimeUnit === 'millisecond') curr = new Date(curr.valueOf() + interval); else if (dateTimeUnit === 'second') curr = new Date(curr.valueOf() + interval * 1000); else if (dateTimeUnit === 'minute') curr = new Date(curr.valueOf() + interval * 60000); else if (dateTimeUnit === 'hour') { curr = new Date(curr.valueOf() + interval * 60000 * 24); } else if (dateTimeUnit === 'day') curr.setDate(curr.getDate() + interval); else if (dateTimeUnit === 'month') curr.setMonth(curr.getMonth() + interval); else if (dateTimeUnit === 'year') curr.setFullYear(curr.getFullYear() + interval); cnt++; } return cnt; } /** @private */ _estAxisInterval(min, max, groupIndex, axisSize, baseUnit, avgItemWidth) { if (isNaN(min) || isNaN(max)) return NaN; let scale = [1, 2, 5, 10, 15, 20, 50, 100, 200, 500]; let i = 0; let prefCount = axisSize / ((!isNaN(avgItemWidth) && avgItemWidth > 0) ? avgItemWidth : 50); if (this._renderData && this._renderData.length > groupIndex && this._renderData[groupIndex].xAxis && !isNaN(this._renderData[groupIndex].xAxis.avgWidth)) { let avgWidth = Math.max(1, this._renderData[groupIndex].xAxis.avgWidth); if (avgWidth !== 0 && isNaN(avgItemWidth)) { // use average text size and 90% axis size to account // for padding between text items prefCount = 0.9 * axisSize / avgWidth; } } if (prefCount <= 1) return Math.abs(max - min); let itemsCount = 0, intSize; while (true) { intSize = i >= scale.length ? Math.pow(10, 3 + i - scale.length) : scale[i]; if (this._isDate(min) && this._isDate(max)) itemsCount = this._getDTIntCnt(min, max, intSize, baseUnit); else itemsCount = (max - min) / intSize; if (itemsCount <= prefCount) break; i++; } let group = this.seriesGroups[groupIndex]; if (group.spider || group.polar) { if (2 * intSize > max - min) intSize = max - min; } return intSize; } /** @private */ _getPaddingSize(axisStats, axis, valuesOnTicks, axisSize, isPolar, isClosedCircle, hasColumnSeries) { var min = axisStats.min; var max = axisStats.max; if (axisStats.logAxis.enabled) { min = axisStats.logAxis.minPow; max = axisStats.logAxis.maxPow; } var unitInterval = axisStats.interval; var dateTimeUnit = axisStats.dateTimeUnit; if (isPolar) { var padding = (axisSize / Math.max(1, max - min + unitInterval)) * unitInterval; if (isClosedCircle) { return { left: 0, right: padding }; } else { if (valuesOnTicks) return { left: 0, right: 0 }; return { left: padding / 2, right: padding / 2 }; } } if (valuesOnTicks && !hasColumnSeries) return { left: 0, right: 0 }; if (this._isDate(min) && this._isDate(max)) { var itemsCount = this._getDTIntCnt(min, max, Math.min(unitInterval, max - min), dateTimeUnit); var itemWidth = axisSize / Math.max(2, itemsCount); return { left: itemWidth / 2, right: itemWidth / 2 }; } var itemsCount = Math.max(1, max - min); if (itemsCount === 1) { const sz = axisSize / 4; return { left: sz, right: sz }; } var itemWidth = axisSize / (itemsCount + 1); return { left: itemWidth / 2, right: itemWidth / 2 }; } /** @private */ _calculateXOffsets(groupIndex, axisSize) { var g = this.seriesGroups[groupIndex]; var xAxis = this._getXAxis(groupIndex); var xoffsets = []; var xvalues = []; var dataLength = this._getDataLen(groupIndex); var axisStats = this._getXAxisStats(groupIndex, xAxis, axisSize); var min = axisStats.min; var max = axisStats.max; var isDateTime = axisStats.isDateTime; var isTimeUnit = axisStats.isTimeUnit; var hasColumnSeries = this._hasColumnSeries(); var isPolar = g.polar || g.spider; var startAngle = this._get([g.startAngle, g.minAngle, 0]); var endAngle = this._get([g.endAngle, g.maxAngle, 360]); var isClosedCircle = isPolar && !(Math.abs(Math.abs(endAngle - startAngle) - 360) > 0.0001); var valuesOnTicks = this._alignValuesWithTicks(groupIndex); var padding = this._getPaddingSize(axisStats, xAxis, valuesOnTicks, axisSize, isPolar, isClosedCircle, hasColumnSeries); var rangeLength = max - min; var filterRange = axisStats.filterRange; if (rangeLength === 0) rangeLength = 1; var plotSize = axisSize - padding.left - padding.right; if (isPolar && valuesOnTicks && !isClosedCircle) padding.left = padding.right = 0; var first = -1, last = -1; for (let i = 0; i < dataLength; i++) { var value = (xAxis.dataField === undefined) ? i : this._getDataValue(i, xAxis.dataField, groupIndex); if (axisStats.useIndeces) { if (i < filterRange.min || i > filterRange.max) { xoffsets.push(NaN); xvalues.push(undefined); continue; } x = padding.left + (i - min) / rangeLength * plotSize; if (axisStats.logAxis.enabled === true) { var logBase = axisStats.logAxis.base; x = this._lwPlot.scale( value, { min: min.valueOf(), max: max.valueOf(), type: 'logarithmic', base: logBase }, { min: 0, max: plotSize, flip: false } ); } xoffsets.push(this.renderer._ptrnd(x)); xvalues.push(value); if (first === -1) first = i; if (last === -1 || last < i) last = i; continue; } value = isDateTime ? this._castAsDate(value, xAxis.dateFormat) : this._castAsNumber(value); if (isNaN(value) || value < filterRange.min || value > filterRange.max) { xoffsets.push(NaN); xvalues.push(undefined); continue; } var x = 0; if (axisStats.logAxis.enabled === true) { var logBase = axisStats.logAxis.base; x = this._lwPlot.scale( value, { min: min.valueOf(), max: max.valueOf(), type: 'logarithmic', base: logBase }, { min: 0, max: plotSize, flip: false } ); } else if (!isDateTime || (isDateTime && isTimeUnit)) { //diffFromMin = value - min; x = (value - min) * plotSize / rangeLength; } else { x = (value.valueOf() - min.valueOf()) / (max.valueOf() - min.valueOf()) * plotSize; } x = this.renderer._ptrnd(padding.left + x); xoffsets.push(x); xvalues.push(value); if (first === -1) first = i; if (last === -1 || last < i) last = i; } if (xAxis.flip === true) { for (let i = 0; i < xoffsets.length; i++) if (!isNaN(xoffsets[i])) xoffsets[i] = axisSize - xoffsets[i]; } if (isTimeUnit || isDateTime) { rangeLength = this._getDateDiff(min, max, xAxis.baseUnit); rangeLength = this.renderer._rnd(rangeLength, 1, false); } var itemsCount = Math.max(1, rangeLength); var itemWidth = plotSize / itemsCount; if (first === last && itemsCount === 1) xoffsets[first] = padding.left + plotSize / 2; return { axisStats: axisStats, data: xoffsets, xvalues: xvalues, first: first, last: last, length: last === -1 ? 0 : last - first + 1, itemWidth: itemWidth, intervalWidth: itemWidth * axisStats.interval, rangeLength: rangeLength, useIndeces: axisStats.useIndeces, padding: padding, axisSize: plotSize }; } /** @private */ _getXAxis(gidx) { if (gidx === undefined || gidx === null || this.seriesGroups.length <= gidx) return this.xAxis; return this.seriesGroups[gidx].xAxis || this.xAxis; } /** @private */ _isGreyScale(groupIndex, seriesIndex) { let g = this.seriesGroups[groupIndex]; let s = g.series[seriesIndex]; if (s.greyScale === true) return true; else if (s.greyScale === false) return false; if (g.greyScale === true) return true; else if (g.greyScale === false) return false; return this.greyScale === true; } /** @private */ _getSeriesColors(groupIndex, seriesIndex, itemIndex) { let colors = this._getSeriesColorsInternal(groupIndex, seriesIndex, itemIndex); if (this._isGreyScale(groupIndex, seriesIndex)) { for (let i in colors) colors[i] = this._draw.toGreyScale(colors[i]); } return colors; } _getColorFromScheme(groupIndex, serieIndex, itemIndex) { let color = '#000000'; let group = this.seriesGroups[groupIndex]; let serie = group.series[serieIndex]; if (this._isPieGroup(groupIndex)) { let dataLength = this._getDataLen(groupIndex); color = this._getItemColorFromScheme(serie.colorScheme || group.colorScheme || this.colorScheme, serieIndex * dataLength + itemIndex, groupIndex, serieIndex); } else { let sidx = 0; for (let i = 0; i <= groupIndex; i++) { for (let j = 0; j < this.seriesGroups[i].series.length; j++) { if (i === groupIndex && parseInt(j) === serieIndex) break; else sidx++; } } let colorScheme = this.colorScheme; if (group.colorScheme) { colorScheme = group.colorScheme; } if (colorScheme === undefined || colorScheme === null || colorScheme === '') colorScheme = this.colorSchemes[0].name; if (!colorScheme) return color; for (let i = 0; i < this.colorSchemes.length; i++) { let cs = this.colorSchemes[i]; if (cs.name === colorScheme) { while (sidx > cs.colors.length) { sidx -= cs.colors.length; if (++i >= this.colorSchemes.length) i = 0; cs = this.colorSchemes[i]; } color = cs.colors[sidx % cs.colors.length]; } } } // else return color; } /** @private */ _createColorsCache() { this._colorsCache = { get: function (cacheKey) { if (this._store[cacheKey]) return this._store[cacheKey]; }, set: function (cacheKey, color) { if (this._size < 10000) { this._store[cacheKey] = color; this._size++; } }, clear: function () { this._store = {}; this._size = 0; }, _size: 0, _store: {} }; } /** @private */ _getSeriesColorsInternal(groupIndex, seriesIndex, itemIndex) { let g = this.seriesGroups[groupIndex]; let s = g.series[seriesIndex]; if (!typeof s.colorFunction === 'function' && g.type !== 'pie' && g.type !== 'donut') itemIndex = NaN; let cacheKey = groupIndex + '_' + seriesIndex + '_' + (isNaN(itemIndex) ? 'NaN' : itemIndex); if (this._colorsCache.get(cacheKey)) return this._colorsCache.get(cacheKey); let colors = { lineColor: '#222222', lineColorSelected: '#151515', lineColorSymbol: '#222222', lineColorSymbolSelected: '#151515', fillColor: '#222222', fillColorSelected: '#333333', fillColorSymbol: '#222222', fillColorSymbolSelected: '#333333', fillColorAlt: '#222222', fillColorAltSelected: '#333333' }; let customColors; if (typeof s.colorFunction === 'function') { let value = !isNaN(itemIndex) ? this._getDataValue(itemIndex, s.dataField, groupIndex) : NaN; if (g.type.indexOf('range') !== -1 && !isNaN(itemIndex)) { let valueFrom = this._getDataValue(itemIndex, s.dataFieldFrom, groupIndex); let valueTo = this._getDataValue(itemIndex, s.dataFieldTo, groupIndex); value = { from: valueFrom, to: valueTo }; } customColors = s.colorFunction(value, itemIndex, s, g); if (typeof (customColors) === 'object') { for (let key in customColors) colors[key] = customColors[key]; } else { colors.fillColor = customColors; } } else { for (let key in colors) { if (s[key]) colors[key] = s[key]; } if (!s.fillColor && !s.color) { colors.fillColor = this._getColorFromScheme(groupIndex, seriesIndex, itemIndex); } else { s.fillColor = s.fillColor || s.color; } } let colorDeriveMap = { fillColor: { baseColor: 'fillColor', adjust: 1.0 }, fillColorSelected: { baseColor: 'fillColor', adjust: 1.1 }, fillColorSymbol: { baseColor: 'fillColor', adjust: 1.0 }, fillColorSymbolSelected: { baseColor: 'fillColorSymbol', adjust: 2.0 }, fillColorAlt: { baseColor: 'fillColor', adjust: 4.0 }, fillColorAltSelected: { baseColor: 'fillColor', adjust: 3.0 }, lineColor: { baseColor: 'fillColor', adjust: 0.95 }, lineColorSelected: { baseColor: 'lineColor', adjust: 0.95 }, lineColorSymbol: { baseColor: 'lineColor', adjust: 1.0 }, lineColorSymbolSelected: { baseColor: 'lineColorSelected', adjust: 1.0 } }; // assign colors for (let key in colors) { if (typeof (customColors) !== 'object' || !customColors[key]) { if (s[key]) colors[key] = s[key]; } } // derive colors for (let key in colors) { if (typeof (customColors) !== 'object' || !customColors[key]) { if (!s[key]) colors[key] = this.renderer.adjustColor(colors[colorDeriveMap[key].baseColor], colorDeriveMap[key].adjust); } } this._colorsCache.set(cacheKey, colors); return colors; } /** @private */ _getItemColorFromScheme(scheme, index, gidx, sidx) { let i; if (scheme === undefined || scheme === '') scheme = this.colorSchemes[0].name; for (i = 0; i < this.colorSchemes.length; i++) if (scheme === this.colorSchemes[i].name) break; let j = 0; while (j <= index) { if (i === this.colorSchemes.length) i = 0; let schLen = this.colorSchemes[i].colors.length; if (j + schLen <= index) { j += schLen; i++; } else { let color = this.colorSchemes[i].colors[index - j]; if (this._isGreyScale(gidx, sidx) && color.indexOf('#') === 0) color = this._draw.toGreyScale(color); return color; } } } getColorScheme(scheme) { for (let i = 0; i < this.colorSchemes.length; i++) { if (this.colorSchemes[i].name === scheme) return this.colorSchemes[i].colors; } return undefined; } addColorScheme(scheme, colors) { for (let i = 0; i < this.colorSchemes.length; i++) { if (this.colorSchemes[i].name === scheme) { this.colorSchemes[i].colors = colors; return; } } this.colorSchemes.push({ name: scheme, colors: colors }); } removeColorScheme(scheme) { for (let i = 0; i < this.colorSchemes.length; i++) { if (this.colorSchemes[i].name === scheme) { this.colorSchemes.splice(i, 1); break; } } } /** @private */ _formatValue(value, formatSettings, formatFunction, groupIndex, serieIndex, itemIndex) { if (value === undefined || value === null) return ''; if (this._isObject(value) && !this._isDate(value) && !formatFunction) return ''; if (formatFunction) { if (typeof formatFunction !== 'function') return value.toString(); try { return formatFunction(value, itemIndex, serieIndex, groupIndex); } catch (e) { return e.message; } } if (this._isNumber(value)) return this._formatNumber(value, formatSettings); if (this._isDate(value)) return this._formatDate(value, formatSettings); if (formatSettings) { return (formatSettings.prefix || '') + value.toString() + (formatSettings.sufix || ''); } return value.toString(); } /** @private */ _getFormattedValue(groupIndex, serieIndex, itemIndex, formatSettings, formatFunction, valuesOnly) { let g = this.seriesGroups[groupIndex]; let s = g.series[serieIndex]; let text = ''; let fs = formatSettings, fn = formatFunction; if (s.labels) { fs = fs || this._getFormatSettings(s.labels); fn = fn || s.labels.formatFunction; } if (!fs && !fn) { fs = this._getFormatSettings(s); fn = s.formatFunction; if (!fs && !fn) { fs = this._getFormatSettings(g); fn = g.formatFunction; } } let value = {}, cnt = 0; for (let field in s) if (field.indexOf('dataField') === 0) { value[field.substring(9).toLowerCase()] = this._getDataValue(itemIndex, s[field], groupIndex); cnt++; } if (cnt === 0) value = this._getDataValue(itemIndex, undefined, groupIndex); if (g.type.indexOf('waterfall') !== -1 && this._isSummary(groupIndex, itemIndex)) { value = this._renderData[groupIndex].offsets[serieIndex][itemIndex].value; cnt = 0; } if (fn && typeof fn === 'function') { try { return fn(cnt === 1 ? value[''] : value, itemIndex, s, g); } catch (e) { return e.message; } } if (cnt === 1 && this._isPieGroup(groupIndex)) { return this._formatValue(value[''], fs, fn, groupIndex, serieIndex, itemIndex); } if (cnt > 0) { let i = 0; for (let field in value) { if (i > 0 && text !== '') text += '<br>'; let dataField = 'dataField' + (field.length > 0 ? field.substring(0, 1).toUpperCase() + field.substring(1) : ''); let displayField = 'displayText' + (field.length > 0 ? field.substring(0, 1).toUpperCase() + field.substring(1) : ''); let displayText = s[displayField] || s[dataField]; let currValue = value[field]; if (undefined !== currValue) { currValue = this._formatValue(currValue, fs, fn, groupIndex, serieIndex, itemIndex); } else continue; if (valuesOnly === true) text += currValue; else text += displayText + ': ' + currValue; i++; } } else { if (value !== undefined && value !== null) text = this._formatValue(value, fs, fn, groupIndex, serieIndex, itemIndex); } return text || ''; } /** @private */ _isNumberAsString(text) { if (typeof (text) !== 'string') return false; text = text.trim(); for (let i = 0; i < text.length; i++) { let ch = text.charAt(i); if ((ch >= '0' && ch <= '9') || ch === ',' || ch === '.') continue; if (ch === '-' && i === 0) continue; if ((ch === '(' && i === 0) || (ch === ')' && i === text.length - 1)) continue; return false; } return true; } /** @private */ _castAsDate(value, dateFormat) { if (value instanceof Date && !isNaN(value)) return value; if (typeof value === 'string') { let result = new Date(value); if (this._isDate(result)) { if (value.indexOf(':') === -1) result.setHours(0, 0, 0, 0); return result; } try { if (dateFormat) { result = LW.Utilities.DateTime.parseDateString(value, undefined, dateFormat).toDate(); if (this._isDate(result)) return result; } // try formats detected earlier if (this._autoDateFormats) { for (let i = 0; i < this._autoDateFormats.length; i++) { result = LW.Utilities.DateTime.parseDateString(value, undefined, this._autoDateFormats[i]).toDate(); if (this._isDate(result)) return result; } } // try all formats let detectedFormat = this._detectDateFormat(value); if (detectedFormat) { result = LW.Utilities.DateTime.parseDateString(value, undefined, detectedFormat).toDate(); if (this._isDate(result)) { this._autoDateFormats.push(detectedFormat); return result; } } } catch (error) { // } } return undefined; } /** @private */ _castAsNumber(value) { if (value instanceof Date && !isNaN(value)) return value.valueOf(); if (typeof (value) === 'string') { if (this._isNumber(value)) { value = parseFloat(value); } else { if (!/[a-zA-Z]/.test(value)) { let date = new Date(value); if (date !== undefined && date !== null) value = date.valueOf(); } } } if (isNaN(value)) { return undefined; } return value; } /** @private */ _isNumber(value) { if (typeof (value) === 'string') { if (this._isNumberAsString(value)) value = parseFloat(value); } return typeof value === 'number' && isFinite(value); } /** @private */ _isDate(value) { return value instanceof Date && !isNaN(value.getDate()); } /** @private */ _isBoolean(value) { return typeof value === 'boolean'; } /** @private */ _isObject(value) { return (value && (typeof value === 'object' || typeof value === 'function')) || false; } /** @private */ _formatDate(value, settings) { let result = value.toString(); if (settings) { if (settings.dateFormat) result = new LW.Utilities.DateTime(value).toString(settings.dateFormat); result = (settings.prefix || '') + result + (settings.sufix || ''); } return result; } /** @private */ _formatNumber(value, settings) { if (!this._isNumber(value)) return value; settings = settings || {}; const self = this; let decimalSeparator = self.localization.decimalSeparator, thousandsSeparator = self.localization.thousandsSeparator; if (settings.decimalSeparator) decimalSeparator = settings.decimalSeparator; if (settings.thousandsSeparator) thousandsSeparator = settings.thousandsSeparator; let prefix = settings.prefix || ''; let sufix = settings.sufix || ''; let decimalPlaces = settings.decimalPlaces; if (isNaN(decimalPlaces)) decimalPlaces = this._getDecimalPlaces([value], undefined, 3); let negativeWithBrackets = settings.negativeWithBrackets || false; let negative = (value < 0); if (negative && negativeWithBrackets) value *= -1; let output = value.toString(); let decimalindex; let decimal = Math.pow(10, decimalPlaces); output = (Math.round(value * decimal) / decimal).toString(); if (isNaN(output)) { output = ''; } decimalindex = output.lastIndexOf('.'); if (decimalPlaces > 0) { if (decimalindex < 0) { output += decimalSeparator; decimalindex = output.length - 1; } else if (decimalSeparator !== '.') { output = output.replace('.', decimalSeparator); } while ((output.length - 1 - decimalindex) < decimalPlaces) { output += '0'; } } decimalindex = output.lastIndexOf(decimalSeparator); decimalindex = (decimalindex > -1) ? decimalindex : output.length; let newoutput = output.substring(decimalindex); let cnt = 0; for (let i = decimalindex; i > 0; i-- , cnt++) { if ((cnt % 3 === 0) && (i !== decimalindex) && (!negative || (i > 1) || (negative && negativeWithBrackets))) { newoutput = thousandsSeparator + newoutput; } newoutput = output.charAt(i - 1) + newoutput; } output = newoutput; if (negative && negativeWithBrackets) output = '(' + output + ')'; return prefix + output + sufix; } /** @private */ _calculateControlPoints(arr, offset) { let x0 = arr[offset], y0 = arr[offset + 1], x1 = arr[offset + 2], y1 = arr[offset + 3], x2 = arr[offset + 4], y2 = arr[offset + 5]; let tension = 0.4; let distP0P1 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)); let distP1P2 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)); let denom = (distP0P1 + distP1P2); if (denom === 0) denom = 1; let factorA = tension * distP0P1 / denom; let factorB = tension - factorA; return [ x1 + factorA * (x0 - x2) /* x1 */, y1 + factorA * (y0 - y2) /* y1 */, x1 - factorB * (x0 - x2) /* x2 */, y1 - factorB * (y0 - y2) /* y2 */ ]; } /** @private */ _getBezierPoints(arr) { let result = ''; let points = [], controlPoints = []; let split = arr.split(' '); for (let i = 0; i < split.length; i++) { let pt = split[i].split(','); points.push(parseFloat(pt[0])); points.push(parseFloat(pt[1])); if (isNaN(points[points.length - 1]) || isNaN(points[points.length - 2])) continue; } let len = points.length; if (len <= 1) return ''; else if (len === 2) { result = 'M' + this.renderer._ptrnd(points[0]) + ',' + this.renderer._ptrnd(points[1]) + ' L' + this.renderer._ptrnd(points[0] + 1) + ',' + this.renderer._ptrnd(points[1] + 1) + ' ' return result; } for (let i = 0; i < len - 4; i += 2) controlPoints = controlPoints.concat(this._calculateControlPoints(points, i)); for (let i = 2; i < len - 5; i += 2) { result += ' C' + this.renderer._ptrnd(controlPoints[2 * i - 2]) + ',' + this.renderer._ptrnd(controlPoints[2 * i - 1]) + ' ' + this.renderer._ptrnd(controlPoints[2 * i]) + ',' + this.renderer._ptrnd(controlPoints[2 * i + 1]) + ' ' + this.renderer._ptrnd(points[i + 2]) + ',' + this.renderer._ptrnd(points[i + 3]) + ' '; } // check the x & y diff between the 1st and 2nd point and connect with either a line or quadratic curve if (len <= 4 || (Math.abs(points[0] - points[2]) < 3 || Math.abs(points[1] - points[3]) < 3)) { result = 'M' + this.renderer._ptrnd(points[0]) + ',' + this.renderer._ptrnd(points[1]) + ' L' + this.renderer._ptrnd(points[2]) + ',' + this.renderer._ptrnd(points[3]) + ' ' + result; } else { result = 'M' + this.renderer._ptrnd(points[0]) + ',' + this.renderer._ptrnd(points[1]) + ' Q' + this.renderer._ptrnd(controlPoints[0]) + ',' + this.renderer._ptrnd(controlPoints[1]) + ' ' + this.renderer._ptrnd(points[2]) + ',' + this.renderer._ptrnd(points[3]) + ' ' + result; } // check the x & y diff between the last 2 points and connect with either a line or quadratic curve if (len >= 4 && (Math.abs(points[len - 2] - points[len - 4]) < 3 || Math.abs(points[len - 1] - points[len - 3]) < 3)) { result += ' L' + this.renderer._ptrnd(points[len - 2]) + ',' + this.renderer._ptrnd(points[len - 1]) + ' '; } else if (len >= 5) { result += ' Q' + this.renderer._ptrnd(controlPoints[len * 2 - 10]) + ',' + this.renderer._ptrnd(controlPoints[len * 2 - 9]) + ' ' + this.renderer._ptrnd(points[len - 2]) + ',' + this.renderer._ptrnd(points[len - 1]) + ' '; } return result; } /** @private */ _createAnimationGroup(groupId) { if (!this._animGroups) { this._animGroups = {}; } this._animGroups[groupId] = { animations: [], startTick: NaN }; } /** @private */ _startAnimation(groupId) { let d = new Date(); let currentTick = d.getTime(); this._animGroups[groupId].startTick = currentTick; this._runAnimation(); this._enableAnimTimer(); } /** @private */ _enqueueAnimation(groupId, element, properties, duration, fn, context, easing) { if (duration < 0) duration = 0; if (easing === undefined) easing = 'easeInOutSine'; this._animGroups[groupId].animations.push({ key: element, properties: properties, duration: duration, fn: fn, context: context, easing: easing }); } /** @private */ _stopAnimations() { clearTimeout(this._animtimer); this._animtimer = undefined; this._animGroups = undefined; } /** @private */ _enableAnimTimer() { if (!this._animtimer) { let self = this; this._animtimer = setTimeout(function () { self._runAnimation(); }, this._animTickInt); } } /** @private */ _runAnimation() { if (this._animGroups) { let d = new Date(); let currentTick = d.getTime(); let animGroupsNewList = {}; for (let j in this._animGroups) { let list = this._animGroups[j].animations; let startTick = this._animGroups[j].startTick; let maxDuration = 0; for (let i = 0; i < list.length; i++) { let item = list[i]; let tSince = (currentTick - startTick); if (item.duration > maxDuration) maxDuration = item.duration; let percent = item.duration > 0 ? tSince / item.duration : 1; let easePercent = percent; if (item.easing && item.duration !== 0 && item.duration !== false) easePercent = LW.Utilities.Animation.Easings[item.easing](tSince, 0, 1, item.duration); if (percent > 1) { percent = 1; easePercent = 1; } if (item.fn) { // custom function item.fn(item.key, item.context, easePercent); continue; } let params = {}; for (let j = 0; j < item.properties.length; j++) { let p = item.properties[j]; let val = 0; if (percent === 1) { val = p.to; } else { val = easePercent * (p.to - p.from) + p.from; } params[p.key] = val; } this.renderer.attr(item.key, params); } // for i if (startTick + maxDuration > currentTick) animGroupsNewList[j] = ({ startTick: startTick, animations: list }); } // for j this._animGroups = animGroupsNewList; if (this.renderer instanceof LW.Utilities.HTML5Renderer) this.renderer.refresh(); } this._animtimer = null; if (Object.values(this._animGroups).length > 0) { this._enableAnimTimer(); } } _fixCoords(rect, groupIndex) { var swapXY = this.seriesGroups[groupIndex].orientation === 'horizontal'; if (!swapXY) return rect; var tmp = rect.x; rect.x = rect.y; rect.y = tmp + this._plotRect.y - this._plotRect.x; var tmp = rect.width; rect.width = rect.height; rect.height = tmp; return rect; } getItemCoord(groupIndex, serieIndex, itemIndex) { var self = this; if (self._isPieGroup(groupIndex) && ( !self._isSerieVisible(groupIndex, serieIndex, itemIndex) || !self._renderData || self._renderData.length <= groupIndex ) ) { return { x: NaN, y: NaN }; } if (!self._isSerieVisible(groupIndex, serieIndex) || !self._renderData || self._renderData.length <= groupIndex ) { return { x: NaN, y: NaN }; } var g = self.seriesGroups[groupIndex] var s = g.series[serieIndex]; var coord = self._getItemCoord(groupIndex, serieIndex, itemIndex); if (self._isPieGroup(groupIndex)) { if (isNaN(coord.x) || isNaN(coord.y) || isNaN(coord.fromAngle) || isNaN(coord.toAngle)) return { x: NaN, y: NaN }; var plotRect = this._plotRect; var fromAngle = coord.fromAngle * (Math.PI / 180); var toAngle = coord.toAngle * (Math.PI / 180); const x1 = plotRect.x + coord.center.x + Math.cos(fromAngle) * coord.outerRadius, x2 = plotRect.x + coord.center.x + Math.cos(toAngle) * coord.outerRadius, y1 = plotRect.y + coord.center.y - Math.sin(fromAngle) * coord.outerRadius, y2 = plotRect.y + coord.center.y - Math.sin(toAngle) * coord.outerRadius; var x = Math.min(x1, x2); var width = Math.abs(x2 - x1); let y = Math.min(y1, y2); var height = Math.abs(y2 - y1); coord = { x: x, y: y, width: width, height: height, center: coord.center, centerOffset: coord.centerOffset, innerRadius: coord.innerRadius, outerRadius: coord.outerRadius, selectedRadiusChange: coord.selectedRadiusChange, fromAngle: coord.fromAngle, toAngle: coord.toAngle }; return coord; } if (g.type.indexOf('column') !== -1 || g.type.indexOf('waterfall') !== -1) { var offsetAndWidth = this._getColumnSerieWidthAndOffset(groupIndex, serieIndex); coord.height = Math.abs(coord.y.to - coord.y.from); coord.y = Math.min(coord.y.to, coord.y.from); coord.x += offsetAndWidth.offset; coord.width = offsetAndWidth.width; } else if (g.type.indexOf('ohlc') !== -1 || g.type.indexOf('candlestick') !== -1) { var offsetAndWidth = this._getColumnSerieWidthAndOffset(groupIndex, serieIndex); let y = coord.y; var minY = Math.min(y.Open, y.Close, y.Low, y.High); var maxY = Math.max(y.Open, y.Close, y.Low, y.High); coord.height = Math.abs(maxY - minY); coord.y = minY coord.x += offsetAndWidth.offset; coord.width = offsetAndWidth.width; } else if (g.type.indexOf('line') !== -1 || g.type.indexOf('area') !== -1) { coord.width = coord.height = 0; coord.y = coord.y.to; } else if (g.type.indexOf('bubble') !== -1 || g.type.indexOf('scatter') !== -1) { coord.center = { x: coord.x, y: coord.y.to }; var radius = coord.y.radius; if (s.symbolType !== 'circle' && s.symbolType !== undefined && s.symbolType !== null) radius /= 2; coord.y = coord.y.to; coord.radius = radius; coord.width = 2 * radius; coord.height = 2 * radius; } coord = this._fixCoords(coord, groupIndex); if (g.polar || g.spider) { var point = this._toPolarCoord(this._renderData[groupIndex].polarCoords, this._plotRect, coord.x, coord.y); coord.x = point.x; coord.y = point.y; if (coord.center) { coord.center = this._toPolarCoord(this._renderData[groupIndex].polarCoords, this._plotRect, coord.center.x, coord.center.y); } } if (g.type.indexOf('bubble') !== -1 || g.type.indexOf('scatter') !== -1) { coord.x -= radius; coord.y -= radius; } return coord; } _getItemCoord(groupIndex, serieIndex, itemIndex) { let g = this.seriesGroups[groupIndex], x, y; if (!g || !this._renderData) return { x: NaN, y: NaN }; let serie = g.series[serieIndex]; if (!serie) return { x: NaN, y: NaN }; let plotRect = this._plotRect; if (this._isPieGroup(groupIndex)) { let slice = this._renderData[groupIndex].offsets[serieIndex][itemIndex]; if (!slice) return { x: NaN, y: NaN }; let angle = (slice.fromAngle + slice.toAngle) / 2 * (Math.PI / 180); x = plotRect.x + slice.x + Math.cos(angle) * slice.outerRadius; y = plotRect.y + slice.y - Math.sin(angle) * slice.outerRadius; return { x: x, y: y, center: { x: slice.x, y: slice.y }, centerOffset: slice.centerOffset, innerRadius: slice.innerRadius, outerRadius: slice.outerRadius, selectedRadiusChange: slice.selectedRadiusChange, fromAngle: slice.fromAngle, toAngle: slice.toAngle }; } else { x = plotRect.x + this._renderData[groupIndex].xoffsets.data[itemIndex]; y = this._renderData[groupIndex].offsets[serieIndex][itemIndex]; if (isNaN(x) || !y) return { x: NaN, y: NaN }; } let yOut = {}; for (let i in y) { yOut[i] = y[i]; } return { x: x, y: yOut }; } getXAxisValue(offset, groupIndex) { var group = this.seriesGroups[groupIndex]; if (!group) return undefined; var xAxis = this._getXAxis(groupIndex); var rect = this._plotRect; var axisSize = 0; var pos = NaN; var xAxisStats = this._renderData[0].xoffsets.axisStats; var min = 0, max = 0; if (group.polar || group.spider) { if (isNaN(offset.x) || isNaN(offset.y)) return NaN; var polarCoords = this._getPolarAxisCoords(groupIndex, rect); var dist = this.renderer._ptdist(offset.x, offset.y, polarCoords.x, polarCoords.y); if (dist > polarCoords.r) return NaN; var posAngle = Math.atan2(polarCoords.y - offset.y, offset.x - polarCoords.x); posAngle = Math.PI / 2 - posAngle; if (posAngle < 0) posAngle = 2 * Math.PI + posAngle; pos = posAngle * polarCoords.r; var startAngle = polarCoords.startAngle + Math.PI / 2; var endAngle = polarCoords.endAngle + Math.PI / 2; min = startAngle * polarCoords.r; max = endAngle * polarCoords.r; axisSize = (endAngle - startAngle) * polarCoords.r; var padding = this._getPaddingSize(xAxisStats, xAxis, xAxis.valuesOnTicks, axisSize, true, polarCoords.isClosedCircle, this._hasColumnSeries()); if (polarCoords.isClosedCircle) { axisSize -= (padding.left + padding.right); max -= (padding.left + padding.right); } else { if (!xAxis.valuesOnTicks) { min += padding.left; max -= padding.right; } } } else { if (group.orientation !== 'horizontal') { if (offset < rect.x || offset > rect.x + rect.width) return NaN; pos = offset - rect.x; axisSize = rect.width; } else { if (offset < rect.y || offset > rect.y + rect.height) return NaN; pos = offset - rect.y; axisSize = rect.height; } if (this._renderData[groupIndex] && this._renderData[groupIndex].xoffsets) { var padding = this._renderData[groupIndex].xoffsets.padding; axisSize -= (padding.left + padding.right); pos -= padding.left; } max = axisSize; } var value = this._lwPlot.scale( pos, { min: min, max: max }, { min: xAxisStats.min.valueOf(), max: xAxisStats.max.valueOf(), type: xAxisStats.logAxis.enabled ? 'logarithmic' : 'linear', base: xAxisStats.logAxis.base, flip: xAxis.flip } ); return value; } getValueAxisValue(offset, groupIndex) { let group = this.seriesGroups[groupIndex]; if (!group) return undefined; let valueAxis = this._getValueAxis(groupIndex); let rect = this._plotRect; let axisSize = 0; let pos = NaN; if (group.polar || group.spider) { if (isNaN(offset.x) || isNaN(offset.y)) return NaN; let polarCoords = this._getPolarAxisCoords(groupIndex, rect); pos = this.renderer._ptdist(offset.x, offset.y, polarCoords.x, polarCoords.y); axisSize = polarCoords.r; pos = axisSize - pos; } else { if (group.orientation === 'horizontal') { if (offset < rect.x || offset > rect.x + rect.width) return NaN; pos = offset - rect.x; axisSize = rect.width; } else { if (offset < rect.y || offset > rect.y + rect.height) return NaN; pos = offset - rect.y; axisSize = rect.height; } } let gstat = this._stats.seriesGroups[groupIndex]; let value = this._lwPlot.scale( pos, { min: 0, max: axisSize }, { min: gstat.min.valueOf(), max: gstat.max.valueOf(), type: gstat.logarithmic ? 'logarithmic' : 'linear', base: gstat.logBase, flip: !valueAxis.flip } ); return value; } _detectDateFormat(samples, additionalFormats) { let formats = { // en-US // short date pattern en_US_d: 'M/d/yyyy', // long date pattern en_US_D: 'dddd, MMMM dd, yyyy', // short time pattern en_US_t: 'h:mm tt', // long time pattern en_US_T: 'h:mm:ss tt', // long date, short time pattern en_US_f: 'dddd, MMMM dd, yyyy h:mm tt', // long date, long time pattern en_US_F: 'dddd, MMMM dd, yyyy h:mm:ss tt', // month/day pattern en_US_M: 'MMMM dd', // month/year pattern en_US_Y: 'yyyy MMMM', // S is a sortable format that does not vary by culture en_US_S: 'yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss', // en-CA en_CA_d: 'dd/MM/yyyy', en_CA_D: 'MMMM-dd-yy', en_CA_f: 'MMMM-dd-yy h:mm tt', en_CA_F: 'MMMM-dd-yy h:mm:ss tt', // formatting of dates in MySQL Databases ISO: 'yyyy-MM-dd hh:mm:ss', ISO2: 'yyyy-MM-dd HH:mm:ss', d1: 'dd.MM.yyyy', d2: 'dd-MM-yyyy', zone1: 'yyyy-MM-ddTHH:mm:ss-HH:mm', zone2: 'yyyy-MM-ddTHH:mm:ss+HH:mm', custom: 'yyyy-MM-ddTHH:mm:ss.fff', custom2: 'yyyy-MM-dd HH:mm:ss.fff', // de-DE de_DE_d: 'dd.MM.yyyy', de_DE_D: 'dddd, d. MMMM yyyy', de_DE_t: 'HH:mm', de_DE_T: 'HH:mm:ss', de_DE_f: 'dddd, d. MMMM yyyy HH:mm', de_DE_F: 'dddd, d. MMMM yyyy HH:mm:ss', de_DE_M: 'dd MMMM', de_DE_Y: 'MMMM yyyy', // fr-FR fr_FR_d: 'dd/MM/yyyy', fr_FR_D: 'dddd d MMMM yyyy', fr_FR_t: 'HH:mm', fr_FR_T: 'HH:mm:ss', fr_FR_f: 'dddd d MMMM yyyy HH:mm', fr_FR_F: 'dddd d MMMM yyyy HH:mm:ss', fr_FR_M: 'd MMMM', fr_FR_Y: 'MMMM yyyy', // it-IT it_IT_d: 'dd/MM/yyyy', it_IT_D: 'dddd d MMMM yyyy', it_IT_t: 'HH:mm', it_IT_T: 'HH:mm:ss', it_IT_f: 'dddd d MMMM yyyy HH:mm', it_IT_F: 'dddd d MMMM yyyy HH:mm:ss', it_IT_M: 'dd MMMM', it_IT_Y: 'MMMM yyyy', // Ru ru_RU_d: 'dd.MM.yyyy', ru_RU_D: 'd MMMM yyyy \'?.\'', ru_RU_t: 'H:mm', ru_RU_T: 'H:mm:ss', ru_RU_f: 'd MMMM yyyy \'?.\' H:mm', ru_RU_F: 'd MMMM yyyy \'?.\' H:mm:ss', ru_RU_Y: 'MMMM yyyy', // cs-CZ cs_CZ_d: 'd.M.yyyy', cs_CZ_D: 'd. MMMM yyyy', cs_CZ_t: 'H:mm', cs_CZ_T: 'H:mm:ss', cs_CZ_f: 'd. MMMM yyyy H:mm', cs_CZ_F: 'd. MMMM yyyy H:mm:ss', cs_CZ_M: 'dd MMMM', cs_CZ_Y: 'MMMM yyyy', // he-IL he_IL_d: 'dd MMMM yyyy', he_IL_D: 'dddd dd MMMM yyyy', he_IL_t: 'HH:mm', he_IL_T: 'HH:mm:ss', he_IL_f: 'dddd dd MMMM yyyy HH:mm', he_IL_F: 'dddd dd MMMM yyyy HH:mm:ss', he_IL_M: 'dd MMMM', he_IL_Y: 'MMMM yyyy', // hr-HR hr_HR_d: 'd.M.yyyy.', hr_HR_D: 'd. MMMM yyyy.', hr_HR_t: 'H:mm', hr_HR_T: 'H:mm:ss', hr_HR_f: 'd. MMMM yyyy. H:mm', hr_HR_F: 'd. MMMM yyyy. H:mm:ss', hr_HR_M: 'd. MMMM', // hu-HU hu_HU_d: 'yyyy.MM.dd.', hu_HU_D: 'yyyy. MMMM d.', hu_HU_t: 'H:mm', hu_HU_T: 'H:mm:ss', hu_HU_f: 'yyyy. MMMM d. H:mm', hu_HU_F: 'yyyy. MMMM d. H:mm:ss', hu_HU_M: 'MMMM d.', hu_HU_Y: 'yyyy. MMMM', // jp-JP jp_JP_d: 'gg y/M/d', jp_JP_D: 'gg y\'?\'M\'?\'d\'?\'', jp_JP_t: 'H:mm', jp_JP_T: 'H:mm:ss', jp_JP_f: 'gg y\'?\'M\'?\'d\'?\' H:mm', jp_JP_F: 'gg y\'?\'M\'?\'d\'?\' H:mm:ss', jp_JP_M: 'M\'?\'d\'?\'', jp_JP_Y: 'gg y\'?\'M\'?\'', // LT lt_LT_d: 'yyyy.MM.dd', lt_LT_D: 'yyyy \'m.\' MMMM d \'d.\'', lt_LT_t: 'HH:mm', lt_LT_T: 'HH:mm:ss', lt_LT_f: 'yyyy \'m.\' MMMM d \'d.\' HH:mm', lt_LT_F: 'yyyy \'m.\' MMMM d \'d.\' HH:mm:ss', lt_LT_M: 'MMMM d \'d.\'', lt_LT_Y: 'yyyy \'m.\' MMMM', // sa-IN sa_IN_d: 'dd-MM-yyyy', sa_IN_D: 'dd MMMM yyyy dddd', sa_IN_t: 'HH:mm', sa_IN_T: 'HH:mm:ss', sa_IN_f: 'dd MMMM yyyy dddd HH:mm', sa_IN_F: 'dd MMMM yyyy dddd HH:mm:ss', sa_IN_M: 'dd MMMM', // basic basic_y: 'yyyy', basic_ym: 'yyyy-MM', basic_d: 'yyyy-MM-dd', basic_dhm: 'yyyy-MM-dd hh:mm', basic_bhms: 'yyyy-MM-dd hh:mm:ss', basic2_ym: 'MM-yyyy', basic2_d: 'MM-dd-yyyy', basic2_dhm: 'MM-dd-yyyy hh:mm', basic2_dhms: 'MM-dd-yyyy hh:mm:ss', basic3_ym: 'yyyy/MM', basic3_d: 'yyyy/MM/dd', basic3_dhm: 'yyyy/MM/dd hh:mm', basic3_bhms: 'yyyy/MM/dd hh:mm:ss', basic4_ym: 'MM/yyyy', basic4_d: 'MM/dd/yyyy', basic4_dhm: 'MM/dd/yyyy hh:mm', basic4_dhms: 'MM/dd/yyyy hh:mm:ss' }; if (additionalFormats) formats = Object.assign({}, formats, additionalFormats); let arr = []; if (!Array.isArray(samples)) arr.push(samples); else arr = samples; for (let j in formats) formats[j] = { format: formats[j], count: 0 }; for (let i = 0; i < arr.length; i++) { const value = arr[i]; if (value === null || value === undefined) continue; for (let j in formats) { try { const result = value instanceof Date || LW.Utilities.DateTime.parseDateString(value, undefined, formats[j].format); if (result) { formats[j].count++; } } catch (error) { // } } } let best = { key: undefined, count: 0 }; for (let j in formats) { if (formats[j].count > best.count) { best.key = j; best.count = formats[j].count; } } return best.key ? formats[best.key].format : ''; } _testXAxisDateFormat(groupIndex) { let self = this; let xAxis = self._getXAxis(groupIndex); let dataLength = self._getDataLen(groupIndex); let localizationFormats = {}; if (self.localization.patterns) { for (let key in self.localization.patterns) localizationFormats['local_' + key] = self.localization.patterns[key]; } let samples = []; for (let i = 0; i < dataLength && i < 10; i++) { const value = self._getDataValue(i, xAxis.dataField, groupIndex); if (value === null || value === undefined) continue; samples.push(value); } let dateFormat = self._detectDateFormat(samples, localizationFormats); return dateFormat; } _getThemeColor(which) { if (this.theme === 'light') { switch (which) { case 'background': return '#FFFFFF'; case 'line': return '#BCBCBC'; case 'band': return '#AAAAAA'; } } switch (which) { case 'background': return '#2E2E2E'; case 'line': return '#707070'; case 'band': return '#565656'; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // (function () { 'use strict'; if (!LW.Chart) { return; } LW.Chart.prototype._moduleAnnotations = true; LW.Chart.prototype._renderAnnotation = function (groupIndex, annotation) { const group = this.seriesGroups[groupIndex]; const renderer = this.renderer; if (isNaN(groupIndex)) return; let x = this._get([this.getXAxisDataPointOffset(annotation.xValue, groupIndex), annotation.x]); let y = this._get([this.getValueAxisDataPointOffset(annotation.yValue, groupIndex), annotation.y]); let x2 = this._get([this.getXAxisDataPointOffset(annotation.xValue2, groupIndex), annotation.x2]); let y2 = this._get([this.getValueAxisDataPointOffset(annotation.yValue2, groupIndex), annotation.y2]); if (group.polar || group.spider) { const point = this.getPolarDataPointOffset(annotation.xValue, annotation.yValue, groupIndex); if (point && !isNaN(point.x) && !isNaN(point.y)) { x = point.x; y = point.y; } else { x = annotation.x; y = annotation.y; } } if (isNaN(y) || isNaN(x)) return false; if (group.orientation === 'horizontal') { let tmp = x; x = y; y = tmp; tmp = x2; x2 = y2; y2 = tmp; } if (annotation.offset) { if (!isNaN(annotation.offset.x)) { x += annotation.offset.x; x2 += annotation.offset.x; } if (!isNaN(annotation.offset.y)) { y += annotation.offset.y; y2 += annotation.offset.y; } } const width = this._get([annotation.width, x2 - x]); const height = this._get([annotation.height, y2 - y]); let shape; switch (annotation.type) { case 'rect': shape = renderer.rect(x, y, width, height); break; case 'circle': shape = renderer.rect(x, y, annotation.radius); break; case 'line': shape = renderer.rect(x, y, x2, y2); break; case 'path': shape = renderer.path(annotation.path); break; } if (shape) { renderer.attr(shape, { fill: annotation.fillColor, stroke: annotation.lineColor, opacity: this._get([annotation.fillOpacity, annotation.opacity]), 'stroke-opacity': this._get([annotation.lineOpacity, annotation.opacity]), 'stroke-width': annotation.lineWidth, 'stroke-dasharray': annotation.dashStyle || 'none' }); } let txtElement; if (annotation.text) { const txt = annotation.text; let xOffset = 0, yOffset = 0; if (txt.offset) { if (!isNaN(txt.offset.x)) xOffset += txt.offset.x; if (!isNaN(txt.offset.y)) yOffset += txt.offset.y; } txtElement = renderer.text( txt.value, x + xOffset, y + yOffset, NaN, NaN, txt.angle, {}, txt.clip === true, txt.horizontalAlignment || 'center', txt.verticalAlignment || 'center', txt.rotationPoint || 'centermiddle'); renderer.attr(txtElement, { fill: txt.fillColor, stroke: txt.lineColor, 'class': 'lw-chart-annotation-text ' + (txt['class'] || '') }); } const events = [ 'click', 'mouseenter', 'mouseleave' ]; const self = this; for (let i = 0; i < events.length; i++) { const event = /*this._getEvent(events[i]) ||*/ events[i]; if (shape) this.renderer.addHandler(shape, event, function () { self._raiseAnnotationEvent(annotation, event); }); if (txtElement) this.renderer.addHandler(txtElement, event, function () { self._raiseAnnotationEvent(annotation, event); }); } }; LW.Chart.prototype._raiseAnnotationEvent = function (annotation, event) { this.$.fireEvent('annotation' + event.charAt(0).toUpperCase() + event.slice(1), { annotation: annotation }); }; })(); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // (function () { 'use strict'; if (!LW.Chart) { return; } LW.Chart.prototype._moduleApi = true; LW.Chart.prototype.getItemsCount = function (groupIndex, serieIndex) { const g = this.seriesGroups[groupIndex]; if (!this._isSerieVisible(groupIndex, serieIndex)) return 0; const renderData = this._renderData; if (!g || !renderData || renderData.length <= groupIndex) return 0; const serie = g.series[serieIndex]; if (!serie) return 0; return renderData[groupIndex].offsets[serieIndex].length; }; LW.Chart.prototype.getXAxisRect = function (groupIndex) { const renderData = this._renderData; if (!renderData || renderData.length <= groupIndex) return undefined; if (!renderData[groupIndex].xAxis) return undefined; return renderData[groupIndex].xAxis.rect; }; LW.Chart.prototype.getXAxisLabels = function (groupIndex) { const output = []; let renderData = this._renderData; if (!renderData || renderData.length <= groupIndex) return output; renderData = renderData[groupIndex].xAxis; if (!renderData) return output; const group = this.seriesGroups[groupIndex]; if (group.polar || group.spider) { for (let i = 0; i < renderData.polarLabels.length; i++) { const label = renderData.polarLabels[i]; output.push({ offset: { x: label.x, y: label.y }, value: label.value }); } return output; } const xAxis = this._getXAxis(groupIndex); const rect = this.getXAxisRect(groupIndex); const swapPosition = xAxis.position === 'top' || xAxis.position === 'right'; const swapXY = group.orientation === 'horizontal'; for (let i = 0; i < renderData.data.length; i++) { if (swapXY) output.push({ offset: { x: rect.x + (swapPosition ? 0 : rect.width), y: rect.y + renderData.data.data[i] }, value: renderData.data.xvalues[i] }); else output.push({ offset: { x: rect.x + renderData.data.data[i], y: rect.y + (swapPosition ? rect.height : 0) }, value: renderData.data.xvalues[i] }); } return output; }; LW.Chart.prototype.getValueAxisRect = function (groupIndex) { const renderData = this._renderData; if (!renderData || renderData.length <= groupIndex) return undefined; if (!renderData[groupIndex].valueAxis) return undefined; return renderData[groupIndex].valueAxis.rect; }; LW.Chart.prototype.getValueAxisLabels = function (groupIndex) { const output = []; let renderData = this._renderData; if (!renderData || renderData.length <= groupIndex) return output; renderData = renderData[groupIndex].valueAxis; if (!renderData) return output; const valueAxis = this._getValueAxis(groupIndex); const swapPosition = valueAxis.position === 'top' || valueAxis.position === 'right'; const group = this.seriesGroups[groupIndex]; const swapXY = group.orientation === 'horizontal'; if (group.polar || group.spider) { for (let i = 0; i < renderData.polarLabels.length; i++) { const label = renderData.polarLabels[i]; output.push({ offset: { x: label.x, y: label.y }, value: label.value }); } return output; } for (let i = 0; i < renderData.items.length; i++) { if (swapXY) { output.push( { offset: { x: renderData.itemOffsets[renderData.items[i]].x + renderData.itemWidth / 2, y: renderData.rect.y + (swapPosition ? renderData.rect.height : 0) }, value: renderData.items[i] } ); } else { output.push( { offset: { x: renderData.rect.x + renderData.rect.width, y: renderData.itemOffsets[renderData.items[i]].y + renderData.itemWidth / 2 }, value: renderData.items[i] } ); } } return output; }; LW.Chart.prototype.getPlotAreaRect = function () { return this._plotRect; }; LW.Chart.prototype.getRect = function () { return this._rect; }; LW.Chart.prototype.showToolTip = function (groupIndex, serieIndex, itemIndex, showDelay, hideDelay) { const coord = this.getItemCoord(groupIndex, serieIndex, itemIndex); if (isNaN(coord.x) || isNaN(coord.y)) return; this._startTooltipTimer(groupIndex, serieIndex, itemIndex, coord.x, coord.y, showDelay, hideDelay); }; LW.Chart.prototype.hideToolTip = function (hideDelay) { if (isNaN(hideDelay)) hideDelay = 0; const self = this; self._cancelTooltipTimer(); setTimeout(function () { self._hideToolTip(0); }, hideDelay); }; })(); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // (function () { 'use strict'; if (!LW.Chart) { return; } LW.Chart.prototype._moduleRangeSelector = true; /** * Renders the xAxis range selector * @private * @param {number} group index * @param {object} bounding rectangle of the xAxis in relative coords */ LW.Chart.prototype._renderXAxisRangeSelector = function (groupIndex, rect) { const self = this; const g = self.seriesGroups[groupIndex]; const axis = self._getXAxis(groupIndex); const rangeSelector = axis ? axis.rangeSelector : undefined; if (!self._isSelectorRefresh) { const elHost = (rangeSelector && rangeSelector.renderTo) ? rangeSelector.renderTo : self, oldRangeSelector = elHost.getElementsByClassName('lw-chart-range-selector')[0]; if (oldRangeSelector) { oldRangeSelector.parentElement.removeChild(oldRangeSelector); } } if (!axis || axis.visible === false || g.type === 'spider') return false; if (!self._isGroupVisible(groupIndex)) return false; if (!rangeSelector) return false; let swapXY = g.orientation === 'horizontal'; if (rangeSelector.renderTo) swapXY = false; if (self.rightToLeft) axis.flip = true; let axisSize = swapXY ? self.offsetHeight : self.offsetWidth; axisSize -= 4; const axisStats = this._getXAxisStats(groupIndex, axis, axisSize); let axisPosition = axis.position; if (rangeSelector.renderTo && rangeSelector.position) axisPosition = rangeSelector.position; if (!this._isSelectorRefresh) { const renderTo = rangeSelector.renderTo; const div = document.createElement('div'); div.className = 'lw-chart-range-selector lw-unselectable'; div.style.position = 'absolute'; div.style.backgroundColor = 'transparent'; div.style.onselectstart = function () { return false; }; if (!renderTo) { this.renderer.getContainer().appendChild(div); const selectorSize = this._selectorGetSize(axis); if (!swapXY) { div.style.left = '1px'; div.style.top = (rect.y + (axisPosition !== 'top' ? rect.height : -selectorSize)) + 'px'; div.style.height = selectorSize + 'px'; div.style.width = axisSize + 'px'; } else { div.style.left = (1 + rect.x + (axisPosition !== 'right' ? -selectorSize : rect.width)) + 'px'; div.style.top = '0'; div.style.height = axisSize + 'px'; div.style.width = selectorSize + 'px'; rect.height = selectorSize; } } else { renderTo.appendChild(div); div.style.width = renderTo.offsetWidth + 'px'; div.style.height = renderTo.offsetHeight + 'px'; rect.width = renderTo.offsetWidth; rect.height = renderTo.offsetHeight; } div.parentDiv = div.parentElement; this._refreshSelector(groupIndex, axis, axisStats, div, rect, swapXY); } this._isSelectorRefresh = false; return true; }; LW.Chart.prototype._refreshSelector = function (groupIndex, axis, axisStats, renderTo, rect, swapXY) { const self = this; const xAxisSettings = {}; const selector = axis.rangeSelector; for (let i in selector) xAxisSettings[i] = selector[i]; delete xAxisSettings.padding; let min = xAxisSettings.minValue; let max = xAxisSettings.maxValue; if (isNaN(min)) min = Math.min(axisStats.min.valueOf(), axisStats.dsRange.min.valueOf()); if (isNaN(max)) max = Math.max(axisStats.max.valueOf(), axisStats.dsRange.max.valueOf()); if (this._isDate(axisStats.min)) min = new Date(min); if (this._isDate(axisStats.max)) max = new Date(max); let axisPosition = axis.position; if (selector.renderTo && selector.position) axisPosition = selector.position; xAxisSettings.dataField = axis.dataField; delete xAxisSettings.rangeSelector; xAxisSettings.type = axis.type; xAxisSettings.baseUnit = selector.baseUnit !== null ? selector.baseUnit : axis.baseUnit; xAxisSettings.minValue = min; xAxisSettings.maxValue = max; xAxisSettings.flip = axis.flip; xAxisSettings.position = axisPosition; const defaultPadding = 5; let leftPadding = 2, rightPadding = 2, topPadding = 2, bottomPadding = 2; if (!selector.renderTo) { leftPadding = swapXY ? 0 : rect.x; rightPadding = swapXY ? 0 : this._rect.width - rect.x - rect.width; topPadding = swapXY ? rect.y : defaultPadding; bottomPadding = swapXY ? this._paddedRect.height - this._plotRect.height : defaultPadding; } let padding = selector.padding; if ((padding === undefined || padding === null) && !selector.renderTo) padding = { left: leftPadding, top: topPadding, right: rightPadding, bottom: bottomPadding }; else { padding = { left: ((padding && padding.left) ? padding.left : leftPadding), top: ((padding && padding.top) ? padding.top : topPadding), right: ((padding && padding.right) ? padding.right : rightPadding), bottom: ((padding && padding.bottom) ? padding.bottom : bottomPadding) }; } let dataField = selector.dataField; for (let i = 0; (dataField === undefined || dataField === null) && i < this.seriesGroups.length; i++) { for (let j = 0; (dataField === undefined || dataField === null) && j < this.seriesGroups[i].series.length; j++) dataField = this.seriesGroups[i].series[j].dataField; } const rangeSelectorSettings = { parentChart: this, padding: padding, _isRangeSelectorInstance: true, theme: this.theme, caption: selector.caption, description: selector.description, titlePadding: selector.titlePadding, colorScheme: selector.colorScheme || this.colorScheme, backgroundColor: selector.backgroundColor || this.backgroundColor || self._getThemeColor('background'), backgroundImage: selector.backgroundImage, showBorderLine: selector.showBorderLine !== null ? selector.showBorderLine : (selector.renderTo ? true : false), borderLineWidth: selector.borderLineWidth || this.borderLineWidth, borderLineColor: selector.borderLineColor || this.borderLineColor || self._getThemeColor('line'), rightToLeft: selector.rightToLeft !== null ? selector.rightToLeft : this.rightToLeft, greyScale: selector.greyScale !== null ? selector.greyScale : this.greyScale, renderEngine: this.renderEngine, showLegend: false, animation: 'none', enableEvents: false, showToolTips: false, dataSource: this.dataSource, xAxis: xAxisSettings, seriesGroups: [ { orientation: swapXY ? 'horizontal' : 'vertical', valueAxis: { visible: false //unitInterval: 10 }, type: selector.serieType, skipOverlappingPoints: selector.skipOverlappingPoints, columnSeriesOverlap: selector.columnSeriesOverlap, columnsGapPercent: selector.columnsGapPercent, seriesGapPercent: selector.seriesGapPercent, series: [ { dataField: dataField, opacity: 0.8, lineWidth: 1 } ] } ] } if (selector.seriesGroups) { rangeSelectorSettings.seriesGroups = selector.seriesGroups; } if (selector.valueAxis.visible) { rangeSelectorSettings.valueAxis = selector.valueAxis; } if (!rangeSelectorSettings.showBorderLine) { rangeSelectorSettings.borderLineWidth = 1; rangeSelectorSettings.borderLineColor = self._get([this.backgroundColor, this.background, self._getThemeColor('background')]); rangeSelectorSettings.showBorderLine = true; } self._supressBindingRefresh = true; renderTo.innerHTML = ''; const rangeSelectorChart = document.createElement('lw-chart'); rangeSelectorChart.rightToLeft = self.rightToLeft; rangeSelectorChart.parentDiv = renderTo; for (let property in rangeSelectorSettings) { rangeSelectorChart[property] = rangeSelectorSettings[property]; } renderTo.appendChild(rangeSelectorChart); self._rangeSelectorInstances[groupIndex] = rangeSelectorChart; self._supressBindingRefresh = false; const createSlidersWhenRendered = function () { if (!rangeSelectorChart._plotRect) return; const sliderRect = rangeSelectorChart._paddedRect; sliderRect.height = rangeSelectorChart._plotRect.height; if (!swapXY && axisPosition === 'top') sliderRect.y += rangeSelectorChart._renderData[0].xAxis.rect.height; else if (swapXY) { const sliderXAxisWidth = rangeSelectorChart._renderData[0].xAxis.rect.width; sliderRect.width -= sliderXAxisWidth; if (axisPosition !== 'right') sliderRect.x += sliderXAxisWidth; } self._createSliderElements(groupIndex, renderTo, sliderRect, selector, { min: xAxisSettings.minValue, max: xAxisSettings.maxValue }); self._rangeSelectorEventData = { groupIndex: groupIndex, renderTo: renderTo, swapXY: swapXY }; if (self.hasAttribute('aria-owns')) { const attributeValue = self.getAttribute('aria-owns'); self.setAttribute('aria-owns', attributeValue + ' ' + rangeSelectorChart.id); } else { self.setAttribute('aria-owns', rangeSelectorChart.id); } }; if (!rangeSelectorChart.isRendered) { rangeSelectorChart.whenRendered(() => { createSlidersWhenRendered(); }); } else { createSlidersWhenRendered(); } }; LW.Chart.prototype._createSliderElements = function (groupIndex, renderTo, rect, selectorSettings, xAxisSettings) { const that = this, oldSlider = renderTo.getElementsByClassName('slider')[0]; if (oldSlider) { oldSlider.parentElement.removeChild(oldSlider); } const colorSelectedRange = selectorSettings.selectedRangeColor || 'blue'; const selectedRangeOpacity = that._get([selectorSettings.selectedRangeOpacity, 0.1]); const unselectedRangeOpacity = that._get([selectorSettings.unselectedRangeOpacity, 0.5]); const colorUnselectedRange = selectorSettings.unselectedRangeColor || 'white'; const colorRangeLineColor = selectorSettings.rangeLineColor || 'grey'; const div = document.createElement('div'); div.className = 'slider'; div.style.position = 'absolute'; div.style.background = colorSelectedRange; div.style.opacity = selectedRangeOpacity; div.style.left = rect.x + 'px'; div.style.top = rect.y + 'px'; div.style.width = rect.width + 'px'; div.style.height = rect.height + 'px'; renderTo.appendChild(div); while (this._sliders.length < groupIndex + 1) this._sliders.push({}); function createDiv(background, opacity) { const div = document.createElement('div'); div.className = 'slider'; div.style.position = 'absolute'; div.style.background = background; div.style.opacity = opacity; return div; } function createDivBarDef() { const div = document.createElement('div'); div.className = 'slider'; div.style.position = 'absolute'; div.style.background = '#FFFFFF'; div.style.borderStyle = 'solid'; div.style.borderWidth = '1px'; div.style.borderRadius = '3px'; div.style.borderColor = colorRangeLineColor; div.setAttribute('role', 'slider'); div.setAttribute('aria-controls', that.id); return div; } const divRect = div.getBoundingClientRect(), renderToRect = renderTo.getBoundingClientRect(); this._sliders[groupIndex] = { element: div, host: renderTo.firstElementChild, _sliderInitialAbsoluteRect: { x: divRect.left, y: divRect.top, width: rect.width, height: rect.height }, _hostInitialAbsolutePos: { x: renderToRect.left, y: renderToRect.top }, getRect: function () { const hostRect = renderTo.getBoundingClientRect(); return { x: hostRect.left - this._hostInitialAbsolutePos.x + this._sliderInitialAbsoluteRect.x, y: hostRect.top - this._hostInitialAbsolutePos.y + this._sliderInitialAbsoluteRect.y, width: this._sliderInitialAbsoluteRect.width, height: this._sliderInitialAbsoluteRect.height }; }, rect: rect, left: createDiv(colorUnselectedRange, unselectedRangeOpacity), right: createDiv(colorUnselectedRange, unselectedRangeOpacity), leftTop: createDiv(colorRangeLineColor, unselectedRangeOpacity), rightTop: createDiv(colorRangeLineColor, unselectedRangeOpacity), leftBorder: createDiv(colorRangeLineColor, unselectedRangeOpacity), leftBar: createDivBarDef(), rightBorder: createDiv(colorRangeLineColor, unselectedRangeOpacity), rightBar: createDivBarDef() }; const slider = this._sliders[groupIndex]; renderTo.appendChild(slider.left); renderTo.appendChild(slider.right); renderTo.appendChild(slider.leftTop); renderTo.appendChild(slider.rightTop); renderTo.appendChild(slider.leftBorder); renderTo.appendChild(slider.rightBorder); renderTo.appendChild(slider.leftBar); renderTo.appendChild(slider.rightBar); const renderData = this._renderData[groupIndex].xAxis; const stats = renderData.data.axisStats; const minValue = stats.min.valueOf(); const maxValue = stats.max.valueOf(); if (typeof stats.min === 'number') { slider.leftBar.setAttribute('aria-valuemin', xAxisSettings.min); slider.leftBar.setAttribute('aria-valuemax', xAxisSettings.max); slider.leftBar.setAttribute('aria-valuenow', minValue); slider.rightBar.setAttribute('aria-valuemin', xAxisSettings.min); slider.rightBar.setAttribute('aria-valuemax', xAxisSettings.max); slider.rightBar.setAttribute('aria-valuenow', maxValue); } else { slider.leftBar.setAttribute('aria-valuemin', xAxisSettings.min.getTime()); slider.leftBar.setAttribute('aria-valuemax', xAxisSettings.max.getTime()); slider.leftBar.setAttribute('aria-valuenow', stats.min.getTime()); slider.leftBar.setAttribute('aria-valuetext', stats.min.toLocaleString()); slider.rightBar.setAttribute('aria-valuemin', xAxisSettings.min.getTime()); slider.rightBar.setAttribute('aria-valuemax', xAxisSettings.max.getTime()); slider.rightBar.setAttribute('aria-valuenow', stats.max.getTime()); slider.rightBar.setAttribute('aria-valuetext', stats.max.toLocaleString()); } let startOffset = this._valueToOffset(groupIndex, minValue); let endOffset = this._valueToOffset(groupIndex, maxValue); if (startOffset > endOffset) { const tmp = endOffset; endOffset = startOffset; startOffset = tmp; } if (this.seriesGroups[groupIndex].orientation !== 'horizontal') { div.style.left = Math.round(rect.x + startOffset) + 'px'; div.style.top = rect.y + 'px'; div.style.width = Math.round(endOffset - startOffset) + 'px'; div.style.height = rect.height + 'px'; } else { div.style.left = rect.x + 'px'; div.style.top = Math.round(rect.y + startOffset) + 'px'; div.style.width = rect.width + 'px'; div.style.height = Math.round(endOffset - startOffset) + 'px'; } this._setSliderPositions(groupIndex, startOffset, endOffset); }; LW.Chart.prototype._setSliderPositions = function (groupIndex, startOffset, endOffset) { const g = this.seriesGroups[groupIndex]; const axis = this._getXAxis(groupIndex); const selector = axis.rangeSelector; let swapXY = g.orientation === 'horizontal'; if (axis.rangeSelector.renderTo) swapXY = false; let axisPosition = axis.position; if (selector.renderTo && selector.position) axisPosition = selector.position; const slider = this._sliders[groupIndex]; const posProp = swapXY ? 'top' : 'left'; const oPosProp = swapXY ? 'left' : 'top'; const sizeProp = swapXY ? 'height' : 'width'; const oSizeProp = swapXY ? 'width' : 'height'; const rectPosProp = swapXY ? 'y' : 'x'; const rectOPosProp = swapXY ? 'x' : 'y'; const rect = slider.rect; slider.startOffset = startOffset; slider.endOffset = endOffset; slider.left.style[posProp] = (rect[rectPosProp]) + 'px'; slider.left.style[oPosProp] = (rect[rectOPosProp]) + 'px'; slider.left.style[sizeProp] = (startOffset) + 'px'; slider.left.style[oSizeProp] = (rect[oSizeProp]) + 'px'; slider.right.style[posProp] = (rect[rectPosProp] + endOffset) + 'px'; slider.right.style[oPosProp] = (rect[rectOPosProp]) + 'px'; slider.right.style[sizeProp] = (rect[sizeProp] - endOffset + 1) + 'px'; slider.right.style[oSizeProp] = (rect[oSizeProp]) + 'px'; slider.leftTop.style[posProp] = (rect[rectPosProp]) + 'px'; slider.leftTop.style[oPosProp] = (rect[rectOPosProp] + (((swapXY && axisPosition === 'right') || (!swapXY && axisPosition !== 'top')) ? 0 : rect[oSizeProp])) + 'px'; slider.leftTop.style[sizeProp] = (startOffset) + 'px'; slider.leftTop.style[oSizeProp] = (1) + 'px'; slider.rightTop.style[posProp] = (rect[rectPosProp] + endOffset) + 'px'; slider.rightTop.style[oPosProp] = (rect[rectOPosProp] + (((swapXY && axisPosition === 'right') || (!swapXY && axisPosition !== 'top')) ? 0 : rect[oSizeProp])) + 'px'; slider.rightTop.style[sizeProp] = (rect[sizeProp] - endOffset + 1) + 'px'; slider.rightTop.style[oSizeProp] = (1) + 'px'; slider.leftBorder.style[posProp] = (rect[rectPosProp] + startOffset) + 'px'; slider.leftBorder.style[oPosProp] = (rect[rectOPosProp]) + 'px'; slider.leftBorder.style[sizeProp] = (1) + 'px'; slider.leftBorder.style[oSizeProp] = (rect[oSizeProp]) + 'px'; let handleBarSize = rect[oSizeProp] / 4; if (handleBarSize > 20) handleBarSize = 20; if (handleBarSize < 3) handleBarSize = 3; slider.leftBar.style[posProp] = (rect[rectPosProp] + startOffset - 3) + 'px'; slider.leftBar.style[oPosProp] = (rect[rectOPosProp] + rect[oSizeProp] / 2 - handleBarSize / 2) + 'px'; slider.leftBar.style[sizeProp] = (5) + 'px'; slider.leftBar.style[oSizeProp] = (handleBarSize) + 'px'; slider.rightBorder.style[posProp] = (rect[rectPosProp] + endOffset) + 'px'; slider.rightBorder.style[oPosProp] = (rect[rectOPosProp]) + 'px'; slider.rightBorder.style[sizeProp] = (1) + 'px'; slider.rightBorder.style[oSizeProp] = (rect[oSizeProp]) + 'px'; slider.rightBar.style[posProp] = (rect[rectPosProp] + endOffset - 3) + 'px'; slider.rightBar.style[oPosProp] = (rect[rectOPosProp] + rect[oSizeProp] / 2 - handleBarSize / 2) + 'px'; slider.rightBar.style[sizeProp] = (5) + 'px'; slider.rightBar.style[oSizeProp] = (handleBarSize) + 'px'; }; LW.Chart.prototype._resizeState = {}; LW.Chart.prototype._onSliderMouseDown = function (event) { event.stopImmediatePropagation(); event.stopPropagation(); const self = this; const slider = self._sliders[self._rangeSelectorEventData.groupIndex]; if (!slider) return; if (self._resizeState.state === undefined || self._resizeState.state === null) self._testAndSetReadyResize(event); if (self._resizeState.state !== 'ready') return; self._draggingRangeSelector = true; self._resizeState.state = 'resizing'; }; LW.Chart.prototype._valueToOffset = function (groupIndex, value) { const group = this.seriesGroups[groupIndex]; const slider = this._sliders[groupIndex]; const selectorChart = slider.host; const renderData = selectorChart._renderData[0].xAxis; const stats = renderData.data.axisStats; const axisMin = stats.min.valueOf(); const axisMax = stats.max.valueOf(); let denom = axisMax - axisMin; if (denom === 0) denom = 1; const axis = this._getXAxis(groupIndex); const sizeProp = group.orientation === 'horizontal' ? 'height' : 'width'; const percent = (value.valueOf() - axisMin) / denom; return slider.getRect()[sizeProp] * (axis.flip ? (1 - percent) : percent); }; LW.Chart.prototype._offsetToValue = function (groupIndex, offset) { const slider = this._sliders[groupIndex]; const group = this.seriesGroups[groupIndex]; const axis = this._getXAxis(groupIndex); const sizeProp = group.orientation === 'horizontal' ? 'height' : 'width'; let denom = slider.getRect()[sizeProp]; if (denom === 0) denom = 1; const selectorChart = slider.host; const renderData = selectorChart._renderData[0].xAxis; const stats = renderData.data.axisStats; const axisMin = stats.min.valueOf(); const axisMax = stats.max.valueOf(); let value = offset / denom * (axisMax - axisMin) + axisMin; if (axis.flip === true) { value = axisMax - offset / denom * (axisMax - axisMin); } if (this._isDate(stats.min) || this._isDate(stats.max)) { value = new Date(value); } else { if (axis.dataField === undefined || axis.dataField === null || stats.useIndeces) value = Math.round(value); if (value < stats.min) value = stats.min; if (value > stats.max) value = stats.max; } return value; }; LW.Chart.prototype._onSliderMouseUp = function (event) { const self = this; const groupIndex = self._rangeSelectorEventData.groupIndex; const swapXY = self._rangeSelectorEventData.swapXY; const slider = self._sliders[groupIndex]; delete self._draggingRangeSelector; if (!slider) return; if (self._resizeState.state !== 'resizing') return; event.stopImmediatePropagation(); event.stopPropagation(); self._resizeState = {}; // update self.style.cursor = 'default'; const leftProp = !swapXY ? 'left' : 'top'; const posProp = !swapXY ? 'x' : 'y'; const from = slider.element.getBoundingClientRect()[leftProp]; const to = from + (!swapXY ? slider.element.offsetWidth : slider.element.offsetHeight); const fullRect = slider.getRect(); let minValue = self._offsetToValue(groupIndex, from - fullRect[posProp]); let maxValue = self._offsetToValue(groupIndex, to - fullRect[posProp]); const selectorChart = slider.host; const renderData = selectorChart._renderData[0].xAxis; const stats = renderData.data.axisStats; if (!stats.isTimeUnit && (maxValue.valueOf() - minValue.valueOf()) > 86400000) { minValue.setHours(0, 0, 0, 0); maxValue.setDate(maxValue.getDate() + 1); maxValue.setHours(0, 0, 0, 0); } const axis = self._getXAxis(groupIndex); if (axis.flip) { const tmp = minValue; minValue = maxValue; maxValue = tmp; } // apply to all groups that share this range selector for (let i = 0; i < self.seriesGroups.length; i++) { const groupXAxis = self._getXAxis(i); if (groupXAxis === axis) self._selectorRange[i] = { min: minValue, max: maxValue }; } self._isSelectorRefresh = true; const animSave = self.animation; self.$.fireEvent('rangeSelectionChanging', { instance: self, minValue: minValue, maxValue: maxValue }); self.animation = 'none'; self.update(); self.animation = animSave; self.$.fireEvent('rangeSelectionChanged', { instance: self, minValue: minValue, maxValue: maxValue }); if (typeof minValue === 'number') { slider.leftBar.setAttribute('aria-valuenow', minValue); slider.rightBar.setAttribute('aria-valuenow', maxValue); } else { slider.leftBar.setAttribute('aria-valuenow', minValue.getTime()); slider.leftBar.setAttribute('aria-valuetext', minValue.toLocaleString()); slider.rightBar.setAttribute('aria-valuenow', maxValue.getTime()); slider.rightBar.setAttribute('aria-valuetext', maxValue.toLocaleString()); } }; LW.Chart.prototype._onSliderMouseMove = function (event) { const self = this; const groupIndex = self._rangeSelectorEventData.groupIndex; const slider = self._sliders[groupIndex]; const swapXY = self._rangeSelectorEventData.swapXY; if (!slider) return; const rect = slider.getRect(); const element = slider.element; const position = { left: event.clientX, top: event.clientY }; const coord = element.getBoundingClientRect(); const leftProp = !swapXY ? 'left' : 'top', elementLeftProp = parseFloat(getComputedStyle(element)[leftProp]); const widthProp = !swapXY ? 'width' : 'height'; const posProp = !swapXY ? 'x' : 'y'; if (self._resizeState.state === 'resizing') { event.stopImmediatePropagation(); event.stopPropagation(); if (self._resizeState.side === 'left') { let diff = Math.round(position[leftProp] - coord[leftProp]); let pos = rect[posProp]; if (coord[leftProp] + diff >= pos && coord[leftProp] + diff <= pos + rect[widthProp]) { let left = parseInt(elementLeftProp); let newSize = Math.max(2, (swapXY ? element.offsetHeight : element.offsetWidth) - diff); element.style[widthProp] = (newSize) + 'px'; element.style[leftProp] = (left + diff) + 'px'; } } else if (self._resizeState.side === 'right') { let elementSize = swapXY ? element.offsetHeight : element.offsetWidth; let diff = Math.round(position[leftProp] - coord[leftProp] - elementSize); let pos = rect[posProp]; if (coord[leftProp] + elementSize + diff >= pos && coord[leftProp] + diff + elementSize <= pos + rect[widthProp]) { let newSize = Math.max(2, elementSize + diff); element.style[widthProp] = (newSize) + 'px'; } } else if (self._resizeState.side === 'move') { let elementSize = swapXY ? element.offsetHeight : element.offsetWidth; let left = parseInt(elementLeftProp); let diff = Math.round(position[leftProp] - self._resizeState.startPos); if (coord[leftProp] + diff >= rect[posProp] && coord[leftProp] + diff + elementSize <= rect[posProp] + rect[widthProp] ) { self._resizeState.startPos = position[leftProp]; element.style[leftProp] = (left + diff) + 'px'; } } const startOffset = parseInt(elementLeftProp) - slider.rect[posProp]; const endOffset = startOffset + (swapXY ? element.offsetHeight : element.offsetWidth); self._setSliderPositions(groupIndex, startOffset, endOffset); } else { self._testAndSetReadyResize(event); } }; LW.Chart.prototype._testAndSetReadyResize = function (event) { const self = this, eventData = self._rangeSelectorEventData; const renderTo = eventData.renderTo; const groupIndex = eventData.groupIndex; const slider = self._sliders[groupIndex]; const swapXY = eventData.swapXY; const rect = slider.getRect(); const element = slider.element; const position = { left: event.clientX, top: event.clientY }; const coord = element.getBoundingClientRect(); const topProp = swapXY ? 'left' : 'top'; const leftProp = !swapXY ? 'left' : 'top'; const heightProp = swapXY ? 'width' : 'height'; const diff = self._isTouchDevice ? 30 : 5; if (position[topProp] >= coord[topProp] && position[topProp] <= coord[topProp] + rect[heightProp]) { if (Math.abs(position[leftProp] - coord[leftProp]) <= diff) { renderTo.style.cursor = swapXY ? 'row-resize' : 'col-resize'; self._resizeState = { state: 'ready', side: 'left' }; } else if (Math.abs(position[leftProp] - coord[leftProp] - (!swapXY ? element.offsetWidth : element.offsetHeight)) <= diff) { renderTo.style.cursor = swapXY ? 'row-resize' : 'col-resize'; self._resizeState = { state: 'ready', side: 'right' }; } else if (position[leftProp] + diff > coord[leftProp] && position[leftProp] - diff < coord[leftProp] + (!swapXY ? element.offsetWidth : element.offsetHeight)) { renderTo.style.cursor = 'pointer'; self._resizeState = { state: 'ready', side: 'move', startPos: position[leftProp] }; } else { renderTo.style.cursor = 'default'; self._resizeState = {}; } } else { renderTo.style.cursor = 'default'; self._resizeState = {}; } }; LW.Chart.prototype._selectorGetSize = function (axis) { if (axis.rangeSelector.renderTo) return 0; return axis.rangeSelector.size || this._paddedRect.height / 3; }; })(); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // (function () { 'use strict'; if (!LW.Chart) { return; } LW.Chart.prototype._moduleWaterfall = true; LW.Chart.prototype._isSummary = function (groupIndex, itemIndex) { const group = this.seriesGroups[groupIndex]; for (let sidx = 0; sidx < group.series.length; sidx++) { if (undefined === group.series[sidx].summary) continue; const summaryValue = this._getDataValue(itemIndex, group.series[sidx].summary, groupIndex); if (undefined !== summaryValue) return true; } return false; }; LW.Chart.prototype._applyWaterfall = function (out, len, groupIndex, yzero, gbase, logBase, scale, inverse, isStacked) { const group = this.seriesGroups[groupIndex]; if (out.length === 0) return out; let lastTo = yzero; // waterfall sums by serie / stack const wfSum = {}; const seriesPrevVisibleIndex = []; let isDirectionDown; const seriesVisibility = []; for (let j = 0; j < group.series.length; j++) seriesVisibility.push(this._isSerieVisible(groupIndex, j)); // The direction of the first column is relative to the baseline. For all columns after // that the direction is based on whether the value is positive or negative // For stacked series the key is -1. For non-stacked the serie index const firstItemRendered = {}; for (let i = 0; i < len; i++) { let summaryLastTo = yzero; let summarySum = 0; const isSummaryItem = this._isSummary(groupIndex, i); for (let j = 0; j < out.length; j++) { if (!seriesVisibility[j]) continue; let refBase = 0; // handle summary items if (isSummaryItem) { refBase = summaryLastTo === yzero ? gbase : 0; out[j][i].value = wfSum[j]; out[j][i].summary = true; isDirectionDown = out[j][i].value < refBase; if (inverse) isDirectionDown = !isDirectionDown; let size = 0; if (!isNaN(logBase)) size = this._getDataPointOffsetDiff(out[j][i].value + summarySum, summarySum === 0 ? gbase : summarySum, refBase || gbase, logBase, scale, yzero, inverse); else size = this._getDataPointOffsetDiff(out[j][i].value, refBase, refBase, NaN, scale, yzero, inverse); out[j][i].to = summaryLastTo + (isDirectionDown ? size : -size); out[j][i].from = summaryLastTo; if (isStacked) { summarySum += out[j][i].value; summaryLastTo = out[j][i].to; } continue; } // end of summary items const k = isStacked ? -1 : j; if (isNaN(out[j][i].value)) continue; if (undefined === firstItemRendered[k]) { refBase = gbase; firstItemRendered[k] = true; } isDirectionDown = out[j][i].value < refBase; if (inverse) isDirectionDown = !isDirectionDown; let y = NaN; if (!isStacked) { y = i === 0 ? yzero : out[j][seriesPrevVisibleIndex[j]].to; } else { y = lastTo; } let size = 0; if (!isNaN(logBase)) size = this._getDataPointOffsetDiff(out[j][i].value + (isNaN(wfSum[k]) ? 0 : wfSum[k]), isNaN(wfSum[k]) ? gbase : wfSum[k], refBase || gbase, logBase, scale, y, inverse); else size = this._getDataPointOffsetDiff(out[j][i].value, refBase, refBase, NaN, scale, yzero, inverse); out[j][i].to = lastTo = y + (isDirectionDown ? size : -size); out[j][i].from = y; if (isNaN(wfSum[k])) wfSum[k] = out[j][i].value; else wfSum[k] += out[j][i].value; if (k === -1) { if (isNaN(wfSum[j])) wfSum[j] = out[j][i].value; else wfSum[j] += out[j][i].value; } if (!isStacked) seriesPrevVisibleIndex[j] = i; } } return out; }; })(); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * DropDownLst custom element. */ LW('lw-drop-down-list', class DropDownList extends LW.ContentElement { /** * DropDownList's properties */ static get properties() { return { 'autoCloseDelay': { value: 100, type: 'number' }, 'dataSource': { value: null, type: 'any', reflectToAttribute: false }, 'displayLoadingIndicator': { value: false, type: 'boolean' }, 'displayMember': { value: '', type: 'string' }, 'displayMode': { allowedValues: ['outlined', 'filled', 'underlined'], value: 'outlined', type: 'string' }, 'dropDownAppendTo': { value: null, type: 'any' }, 'dropDownButtonPosition': { allowedValues: ['none', 'left', 'right', 'top', 'bottom'], value: 'right', defaultReflectToAttribute: true, type: 'string' }, 'dropDownMinHeight': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownHeight': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownMaxHeight': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownOpenMode': { allowedValues: ['none', 'default', 'dropDownButton', 'auto'], value: 'default', type: 'string' }, 'dropDownOverlay': { value: false, type: 'boolean' }, 'dropDownPlaceholder': { value: 'No Items', type: 'string' }, 'dropDownPosition': { allowedValues: ['auto', 'top', 'bottom', 'overlay-top', 'overlay-center', 'overlay-bottom', 'center-bottom', 'center-top'], value: 'auto', type: 'string' }, 'dropDownMinWidth': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownWidth': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownMaxWidth': { value: '', type: 'any', validator: '_propertyValidator' }, 'filterable': { value: false, type: 'boolean' }, 'filterInputPlaceholder': { value: '', type: 'string' }, 'filterCallback': { value: null, type: 'function?' }, 'filterMode': { value: 'startsWithIgnoreCase', allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase', 'custom'], type: 'string' }, 'grouped': { value: false, type: 'boolean' }, 'groupMember': { value: '', type: 'string' }, 'hint': { value: '', type: 'string' }, 'horizontalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] }, 'incrementalSearchDelay': { value: 700, type: 'number?' }, 'incrementalSearchMode': { value: 'startsWithIgnoreCase', allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'], type: 'string' }, 'itemMeasureMode': { value: 'auto', allowedValues: ['auto', 'precise'], type: 'string' }, 'inputMember': { value: 'label', type: 'string' }, 'itemTemplate': { value: null, type: 'any' }, 'itemHeight': { value: null, type: 'number?' }, 'label': { value: '', type: 'string' }, 'loadingIndicatorPlaceholder': { value: 'Loading...', type: 'string' }, 'loadingIndicatorPosition': { value: 'center', allowedValues: ['bottom', 'center', 'top'], type: 'string' }, 'messages': { extend: true, value: { 'en': { 'invalidNode': '{{elementType}}: Invalid parameter "{{node}}" when calling {{method}}.' } }, type: 'object' }, 'name': { value: '', type: 'string' }, 'opened': { value: false, type: 'boolean' }, 'placeholder': { value: '', type: 'string' }, 'resizeMode': { value: 'none', allowedValues: ['none', 'horizontal', 'vertical', 'both'], type: 'string' }, 'resizeIndicator': { value: false, type: 'boolean' }, 'selectionDisplayMode': { value: 'plain', allowedValues: ['plain', 'placeholder', 'tokens'], type: 'string' }, 'selectionMode': { value: 'one', allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'], type: 'string' }, 'selectedIndexes': { value: [], type: 'array' }, 'selectedValues': { value: [], type: 'array' }, 'sorted': { value: false, type: 'boolean' }, 'sortDirection': { value: 'asc', type: 'string' }, 'tokenTemplate': { value: null, type: 'any' }, 'type': { value: 'list', type: 'string', defaultReflectToAttribute: true, readonly: true }, 'valueMember': { value: '', type: 'string' }, 'virtualized': { value: false, type: 'boolean' }, 'verticalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] } } } /** * DropDownList's event listeners. */ static get listeners() { return { 'actionButton.down': '_buttonsDownHandler', 'actionButton.mouseenter': '_buttonsMouseEventsHandler', 'actionButton.mouseleave': '_buttonsMouseEventsHandler', 'actionButton.focus': '_buttonsFocusHandler', 'actionButton.blur': '_buttonsFocusHandler', 'document.selectstart': '_selectStartHandler', 'document.dragstart': '_dragStartHandler', 'document.down': '_documentDownHandler', 'document.up': '_documentUpHandler', 'document.move': '_documentMoveHandler', 'dropDownButton.down': '_buttonsDownHandler', 'dropDownButton.mouseenter': '_buttonsMouseEventsHandler', 'dropDownButton.mouseleave': '_buttonsMouseEventsHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler', 'focus': '_focusEventHandler', 'blur': '_blurEventHandler', 'dropDownButton.focus': '_buttonsFocusHandler', 'dropDownButton.blur': '_buttonsFocusHandler', 'dropDownContainer.transitionend': '_dropDownTransitionendHandler', 'listBox.change': '_listBoxChangeHandler', 'listBox.itemClick': '_listBoxItemClickHandler', 'listBox.keydown': '_listBoxKeyDownHandler', 'listBox.bindingComplete': '_bindingCompleteHandler', 'mouseenter': '_mouseEnterHandler', 'mouseleave': '_mouseLeaveHandler', 'resize': '_resizeHandler', 'resizeBar.move': '_resizeBarMoveHandler', 'styleChanged': '_styleChangedHandler', 'wheel': '_mouseWheelHandler' }; } /** * DropDownList's HTML template. */ template() { return `<div id="container" role="presentation"> <span class="lw-label" id="label">[[label]]</span> <div id="content" class="lw-content" role="presentation"> <div class="lw-buttons-container" id="buttonsContainer" role="presentation"> <span id="actionButton" class ="lw-action-button" role="presentation">[[placeholder]]</span> <span id="dropDownButton" class="lw-drop-down-button"> <span class ="lw-drop-down-button-icon" id="arrow" aria-hidden="true"></span> </span> </div> <div id="dropDownContainer" class="lw-drop-down lw-drop-down-container lw-visibility-hidden" role="presentation"> <lw-list-box id="listBox" unfocusable animation="[[animation]]" data-source="[[dataSource]]" disabled="[[disabled]]" display-loading-indicator="[[displayLoadingIndicator]]" display-member="[[displayMember]]" filterable="[[filterable]]" filter-callback="[[filterCallback]]" filter-mode="[[filterMode]]" filter-input-placeholder="[[filterInputPlaceholder]]" grouped="[[grouped]]" group-member="[[groupMember]]" item-height="[[itemHeight]]" item-measure-mode="[[itemMeasureMode]]" item-template="[[itemTemplate]]" incremental-search-delay="[[incrementalSearchDelay]]" incremental-search-mode="[[incrementalSearchMode]]" loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]" loading-indicator-position="[[loadingIndicatorPosition]]" name="[[name]]" placeholder="[[dropDownPlaceholder]]" right-to-left="[[rightToLeft]]" readonly="[[readonly]]" selected-indexes="{{selectedIndexes}}" selection-mode="[[selectionMode]]" selected-values="{{selectedValues}}" sorted="[[sorted]]" sort-direction="[[sortDirection]]" theme="[[theme]]" value-member="[[valueMember]]" horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]" vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]" virtualized="[[virtualized]]"> <content></content> </lw-list-box> <div id="resizeBar" class="lw-drop-down-resize-bar" aria-label="Resize"> <div></div> </div> </div> </div> <span class="lw-hint lw-hidden" id="hint">[[hint]]</span> </div>`; } /* * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.dropdownlist.css', 'lw.dropdown.css' ] } /** * Updates the DropDownList when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'animation': that.$.dropDownContainer.setAttribute('animation', that.animation); break; case 'disabled': that._setFocusable(); that.close(); that._positionDetection.handleAutoPositioning(); break; case 'dataSource': case 'displayMember': case 'inputMember': //when selectedValues is 0 and displayMember is changed set actionButton text to default. if (that.$.actionButton) { that.$.actionButton.innerHTML = that.placeholder; } //Check the new listBox size that._setDropDownSize(); that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds('horizontally'); break; case 'dropDownAppendTo': that._positionDetection.dropDownAppendToChangedHandler(); break; case 'dropDownOpenMode': that._setFocusable(); //Close the dropDownList without throwing events. that.$dropDownContainer.addClass('lw-visibility-hidden'); that.$.dropDownButton.removeAttribute('selected'); that.removeAttribute('drop-down-button-focus'); that.removeAttribute('action-button-focus'); that.opened = false; if (that._ariaButton) { that._ariaButton.setAttribute('aria-expanded', false); } that._setAriaRelations(); break; case 'dropDownOverlay': if (!newValue) { that._positionDetection.removeOverlay(); } break; case 'dropDownPosition': that._positionDetection.dropDownPositionChangedHandler(); break; case 'dropDownMinWidth': case 'dropDownWidth': case 'dropDownMaxWidth': case 'dropDownHeight': case 'dropDownMinHeight': case 'dropDownMaxHeight': that._setDropDownSize(); break; case 'filterable': //NOTE: We need this property to be applied in time before _setDropDownSize() is called that.$.listBox.filterable = newValue; if (that._dropDownSize && that._dropDownSize.height === 'auto') { that._setDropDownSize(); } break; case 'label': if (!that._ariaButton) { return; } if (newValue) { that._ariaButton.setAttribute('aria-labelledby', that.$.label.id); } else if (that.elementName === 'DropDownList') { that._ariaButton.setAttribute('aria-labelledby', that.$.actionButton.id); } break; case 'opened': if (that.disabled || that.readonly) { return; } newValue ? that.open() : that.close(); break; case 'placeholder': that._applySelection(); break; case 'readonly': that.close(); break; case 'resizeIndicator': if (newValue) { that.$.dropDownContainer.setAttribute('resize-indicator', ''); } else { that.$.dropDownContainer.removeAttribute('resize-indicator'); } break; case 'resizeMode': that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode); break; case 'selectedValues': case 'selectedIndexes': if (newValue.length === 0) { that.$.actionButton.innerHTML = that.placeholder; } else { that._applySelection(); } break; case 'selectionMode': //NOTE: Manually apply the selectionMode in order to resize the drop down after the mode is changed if (that.$.listBox) { that.$.listBox[propertyName] = newValue; if (newValue === 'checkBox' || newValue === 'radioButton' || oldValue === 'checkBox' || oldValue === 'radioButton') { that._setDropDownSize(); } } break; case 'selectionDisplayMode': that._applySelection(); break; case 'tokenTemplate': that._tokenTemplate = that._validateTemplate(that.tokenTemplate); that._applySelection(); break; case 'unfocusable': that._setFocusable(); break; } } /** * Appends a lw-list-item to the end of the DropDownList. */ appendChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' })); return } that.$.listBox.appendChild(node); if (that._dropDownSize && that._dropDownSize.height === 'auto') { that._setDropDownSize(); } } /** * Called when the element is attached from the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted || !that.$.dropDownContainer) { return; } that._positionDetection.dropDownAttached('_setDropDownSize'); that._positionDetection.checkBrowserBounds(); //Refresh the selection if (that.selectedIndexes) { that._applySelection() } } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); if (!that.$.dropDownContainer) { return; } that.close(); if (that._positionDetection) { that._positionDetection.dropDownDetached(); } } /** * Removes all items from DOM. */ clearItems() { const that = this; if (!that.$.listBox) { return; } that.$.listBox.clearItems(); that.$.actionButton.innerHTML = that.placeholder; } /** * Unselects all items. */ clearSelection() { const that = this; if (!that.$.listBox) { return; } that.$.listBox.clearSelection(); that.$.actionButton.innerHTML = that.placeholder; } /** * Hides the drop down list. */ close() { const that = this; if (that.$dropDownContainer.hasClass('lw-visibility-hidden')) { return; } const isClosingEventPrevented = that.$.fireEvent('closing').defaultPrevented; if (isClosingEventPrevented) { return; } that.$dropDownContainer.addClass('lw-visibility-hidden'); that.$.fireEvent('close'); if (that.$.dropDownButton) { that.$.dropDownButton.removeAttribute('selected'); } that.opened = false; if (that._ariaButton) { that._ariaButton.setAttribute('aria-expanded', false); } that._preventDropDownClose = false; that._positionDetection.removeOverlay(true); that.$.listBox.removeAttribute('focus'); if (that._edgeMacFF && !that.hasAnimation && that.$.dropDownContainer) { that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = ''; that.$dropDownContainer.addClass('not-in-view'); } } /** * Creates a clone of the element. */ cloneNode() { const that = this; if (!that.$.listBox) { return; } let clone = HTMLElement.prototype.cloneNode.apply(that, Array.prototype.slice.call(arguments, 0, 1)); //Set only those properties that have reflectToAttribute set to false. clone.dataSource = that.dataSource; return clone; } /** * Ensures the desired item is visible by scrolling to it. */ ensureVisible(item) { const that = this; if (!that.$.listBox) { return; } that.$.listBox.ensureVisible(item); } /** * Returns a LW.ListItem element if it's value is matched. */ getItem(value) { const that = this; if (!that.$.listBox) { return; } return that.$.listBox.getItem(value); } /** * Returns an array with the items from the list. */ get items() { const that = this; if (!that.$ || !that.$.listBox) { return []; } return that.$.listBox.items; } /** * Returns the focused item; */ get _focusedItem() { const that = this; if (!that.$ || !that.$.listBox) { return; } return that.$.listBox._focusedItem; } /** * Inserts an item at a specified position. * @param {number} index The index at which a new item will be inserted. * @param {string/object/array} item Describes the properties of the item that will be inserted. If string is passed, it will be processed as the label for the new item. If an object is passed, it must contain valid properties for the item, e.g. { label, value, group, disabled }. If an array is passed, multiple items will be inserted in the list with the coressponding settings. */ insert(index, item) { const that = this; if (!that.$.listBox) { return; } that.$.listBox.insert(index, item); //Add the item to the ActionButton if the item is selected. that._applySelection() if (that._dropDownSize && that._dropDownSize.height === 'auto') { that._setDropDownSize(); } } /** * Inserts a lw-list-item to the DropDownList at a certain position. */ insertBefore(newNode, referenceNode) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!newNode || !referenceNode) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' })); return; } if (!that.$.listBox) { return; } that.$.listBox.insertBefore(newNode, referenceNode); if (that._dropDownSize && that._dropDownSize.height === 'auto') { that._setDropDownSize(); } } /** * Shows the drop down List. */ open() { const that = this, getFirstFocusableItem = function () { for (let i = 0; i < that.items.length; i++) { if (!that.items[i].disabled) { return that.items[i]; } } }; if (that.disabled || !that.offsetHeight) { return; } if (!that.$dropDownContainer.hasClass('lw-visibility-hidden')) { return; } if (that.$dropDownContainer.hasClass('not-in-view')) { that.$dropDownContainer.removeClass('not-in-view'); } that.$.dropDownContainer.style.transition = null; if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) { const rect = that.getBoundingClientRect(); // handles the case, when the dropdown is opened, while it is still part of the dropdownlist's tree. if (that.$.container.contains(that.$.dropDownContainer)) { let iterations = 0; const interval = setInterval(function () { const rect = that.getBoundingClientRect(); iterations++; if (rect.top === that._positionTop && iterations < 10) { return; } that.open(); clearInterval(interval); that._positionTop = rect.top; }, 100); return; } else if (rect.top !== that._positionTop) { that._positionTop = rect.top; } } const isOpeningEventPrevented = that.$.fireEvent('opening').defaultPrevented; if (isOpeningEventPrevented) { return; } if (that._shadowDOMStylesDelay) { that._setDropDownSize(); delete that._shadowDOMStylesDelay; } that.opened = true; if (that._ariaButton) { that._ariaButton.setAttribute('aria-expanded', true); } that.$.listBox.setAttribute('focus', ''); that._positionDetection.placeOverlay(); that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds('horizontally'); that.$dropDownContainer.removeClass('lw-visibility-hidden'); that.$.fireEvent('open'); if (that.$.dropDownButton) { if (that.dropDownOpenMode === 'dropDownButton') { that.$.dropDownButton.setAttribute('selected', ''); } else { that.$.dropDownButton.removeAttribute('selected'); } } if (that.$.listBox && !that._focusedItem || (that._focusedItem && !that._focusedItem._focused)) { if (that.selectedIndexes.length > 0) { that._focus(that.items[that.selectedIndexes[0]]); } else { that._focus(getFirstFocusableItem); } } if (that.$.input && !LW.Utilities.Core.isMobile) { that.$.input.focus(); } } /** * DropDownList ready method. */ ready() { super.ready(); } /** * DropDownList render method */ render() { const that = this; if (that.rightToLeft) { that.dropDownButtonPosition = that.dropDownButtonPosition === 'right' ? 'left' : 'right'; } that.classList.add('lw-drop-down-box'); if (that.$.dropDownContainer) { that._positionDetection = new LW.Utilities.PositionDetection(that, that.$.dropDownContainer, that.$.container, 'close'); that._positionDetection.getDropDownParent(true); that._positionDetection.setDropDownPosition(); that._calculateDropDownSize(); that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode); if (that.resizeIndicator) { that.$.dropDownContainer.setAttribute('resize-indicator', ''); } that._positionDetection.handleAutoPositioning(); } if (that.opened) { that.open(); } //Used for the scroll handling that._positionTop = that.getBoundingClientRect().top; that._edgeMacFF = LW.Utilities.Core.Browser.Edge || LW.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1; if (that._edgeMacFF && that.hasAnimation && that.$.dropDownContainer) { that.$dropDownContainer.addClass('not-in-view'); } if (that.$.label && !that.$.label.id) { that.$.label.id = that.id + 'Label'; } if (that.$.actionButton && !that.$.actionButton.id) { that.$.actionButton.id = that.id + 'ActionButton'; } if (that.$.hint && !that.$.hint.id) { that.$.hint.id = that.id + 'Hint'; } if (!that.hint) { that.hint = that.placeholder; } that._createElement(); super.render(); } /** * Removes an item from the list box. * @param {number} index The index at which a new item will be inserted. */ removeAt(index) { const that = this; if (!that.$.listBox) { return; } that.$.listBox.removeAt(index); //Remove the item from the ActionButton if its present. that._applySelection(); if (that._dropDownSize && that._dropDownSize.height === 'auto') { that._setDropDownSize(); } } /** * Removes a lw-list-item frop the DropDownList. */ removeChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node || !(node instanceof LW.ListItem)) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' })); return } that.$.listBox.removeChild(node); if (that._dropDownSize && that._dropDownSize.height === 'auto') { that._setDropDownSize(); } } get value() { const that = this; if (!that.isRendered) { return null; } if (!that.$.listBox) { return null; } return that.$.listBox.value; } set value(newValue) { const that = this; if (!that.isRendered) { return null; } if (!that.$.listBox) { return null; } that.$.listBox.value = newValue; } /** * Selects an item by its HTML Element or Value. */ select(item) { const that = this; if (!that.$.listBox) { return; } that.$.listBox.select(item); } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); that.$.actionButton.removeAttribute('tabindex'); that.$.dropDownButton.removeAttribute('tabindex'); return; } let index = that.tabIndex > 0 ? that.tabIndex : 0; if (that.dropDownOpenMode === 'dropDownButton') { that.removeAttribute('tabindex'); that.$.actionButton.setAttribute('tabindex', index); that.$.dropDownButton.setAttribute('tabindex', index); } else { that.$.actionButton.removeAttribute('tabindex'); that.$.dropDownButton.removeAttribute('tabindex'); that.tabIndex = index; } } /** * Checks for missing modules. */ static get requires() { return { 'LW.ListBox': 'lw.listbox.js' } } /** * Unselects an item by its HTML Element or Value. */ unselect(item) { const that = this; if (!that.$.listBox) { return; } that.$.listBox.unselect(item); } /** * Updates an item from the list. * @param {number} index The index at which a new item will be inserted. * @param {string/object} settings The settings that will be applied to the item that will be updated. If a string is passed, it will be considered as the new label for the item. If an object is passed, it will should describe valid properties for the item, e.g. { label, value, group, disabled}. */ update(index, details) { const that = this; if (!that.$.listBox) { return; } that.$.listBox.update(index, details); that._applySelection(); } /** * Resizebar mousemouve event handler. * @param {any} event */ _resizeBarMoveHandler(event) { //Used to prevent page scrolling on iOS devices if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * Creates a token for the selected items */ _createToken() { const that = this; let icon, buttonLabel = false; const fragment = document.createDocumentFragment(), lastSelectedIndex = that.selectedIndexes[that.selectedIndexes.length - 1]; if (that.selectionDisplayMode === 'plain' && (that.selectionMode === 'one' || that.selectionMode === 'zeroOrOne' || that.selectionMode === 'radioButton')) { icon = ''; } else { if (that.selectionDisplayMode === 'tokens') { if (that.selectedIndexes.length === 1 && (['oneOrManyExtended', 'oneOrMany', 'one', 'radioButton'].indexOf(that.selectionMode) > -1)) { icon = ''; } else { icon = '&#10006'; buttonLabel = true; } } else { icon = that.selectedIndexes.length === 1 ? '' : ','; } } const selectedIndexes = that.selectedIndexes, items = that.$.listBox._items; for (let i = 0; i < selectedIndexes.length; i++) { const selectedIndex = selectedIndexes[i]; if (items[selectedIndex]) { fragment.appendChild(that._applyTokenTemplate(items[selectedIndex][that.inputMember], that.selectionDisplayMode !== 'tokens' && selectedIndex === lastSelectedIndex ? '' : icon, buttonLabel)); } } return fragment; } /** * Sets the selection mode for the DropDownList. */ _applySelection() { const that = this; if (that.selectionDisplayMode === 'placeholder' || that.selectedIndexes.length === 0) { that.$.actionButton.innerHTML = that.placeholder; return; } if (!that.$.listBox._items || that.$.listBox._items.length === 0) { return; } if (that.selectionDisplayMode === 'plain') { const selectedIndexes = that.$.listBox.selectedIndexes, //that.selectedIndexes, items = that.$.listBox._items; let newValue = []; for (let i = 0; i < selectedIndexes.length; i++) { const selectedIndex = selectedIndexes[i]; if (items[selectedIndex]) { newValue.push(items[selectedIndex][that.inputMember]); } } that.$.actionButton.innerHTML = !newValue.length ? '' : `<span class="lw-token">${newValue.join(', ').trim()}</span>`; return; } that.$.actionButton.innerHTML = ''; that.$.actionButton.appendChild(that._createToken()); } /** * Applies a template to the tokens */ _applyTokenTemplate(label, icon, buttonLabel) { const that = this; const element = document.createElement('span'), token = function () { return '<span class=\'lw-drop-down-list-selection-label\' role="presentation">' + label + `</span><span class=\'lw-drop-down-list-unselect-button\' role="button"${buttonLabel ? ' aria-label="Unselect"' : ''}>${icon}</span>`; }; element.classList.add('lw-token'); if (that._tokenTemplate) { let content = document.importNode(that._tokenTemplate.content, true); const childrenCount = content.childNodes.length, regex = /{{\w+}}/g; let bindingString; for (let i = 0; i < childrenCount; i++) { bindingString = regex.exec(content.childNodes[i].innerHTML); if (bindingString) { content.childNodes[i].innerHTML = content.childNodes[i].innerHTML.replace(bindingString[0], token()); } if (content.childNodes[i].outerHTML) { element.innerHTML += content.childNodes[i].outerHTML; } } } else if (typeof that.tokenTemplate === 'function') { that.tokenTemplate(element, { label: label, iconSeparator: icon }); } else { element.innerHTML = token(); } return element; } /** * BindingComplete event Handler. When the dataSource or size of listBox is changed. */ _bindingCompleteHandler() { const that = this; if (!that.$.listBox) { return; } requestAnimationFrame(() => { that._setDropDownSize(); that._positionDetection.checkBrowserBounds(); }); } /** * Action/DropDown button mouse down event handler. */ _buttonsDownHandler(event) { const that = this; if (that.disabled) { return; } if (that.hasRippleAnimation) { if (!that.$.buttonsContainer || that.dropDownOpenMode === 'dropDownButton') { LW.Utilities.Animation.Ripple.animate(event.target, event.pageX, event.pageY); } else { const target = that.$.buttonsContainer; target.firstElementChild.noRipple = true; LW.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY); target.firstElementChild.noRipple = false; } } that._preventsSelectStart = true; if (that.tagName.toLowerCase().indexOf('lw-drop-down-') > -1 && that.dropDownOpenMode === 'dropDownButton' && event.target === that.$.actionButton) { that.$.actionButton.setAttribute('active', ''); } //Used to handle closing after blur event is thrown if (that.opened) { that._preventDropDownClose = true; } } /** * DropDownList container mouse enter/leave events handler. */ _buttonsMouseEventsHandler(event) { const that = this; if (that.disabled) { return; } if (event.type === 'mouseenter') { that.setAttribute('hover', ''); event.target.setAttribute('hover', ''); } else { that.removeAttribute('hover'); event.target.removeAttribute('hover'); } } /** * Calculates the dropDownSize and creates an object with the sizes */ _calculateDropDownSize() { const that = this; that._dropDownSize = {}; const computedStyle = window.getComputedStyle(that.$.dropDownContainer); const topBorder = parseFloat(computedStyle.getPropertyValue('border-top-width').trim()), bottomBorder = parseFloat(computedStyle.getPropertyValue('border-bottom-width').trim()), topMargin = parseFloat(computedStyle.getPropertyValue('margin-top').trim()), bottomMargin = parseFloat(computedStyle.getPropertyValue('margin-bottom').trim()), topPaddinng = parseFloat(computedStyle.getPropertyValue('padding-top').trim()), bottomPaddinng = parseFloat(computedStyle.getPropertyValue('padding-bottom').trim()); if (LW.Utilities.Core.CSSVariablesSupport()) { that._dropDownSize.width = computedStyle.getPropertyValue('--lw-drop-down-list-drop-down-width').trim(); that._dropDownSize.height = computedStyle.getPropertyValue('--lw-drop-down-list-drop-down-height').trim(); } if (!that._dropDownSize.width || that._dropDownSize.width.indexOf('initial') > -1) { that._dropDownSize.width = that.offsetWidth; } if (!that._dropDownSize.height) { that._dropDownSize.height = 'auto'; } that._dropDownSize.minHeight = parseFloat(computedStyle.getPropertyValue('min-height').trim()); that._dropDownSize.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height').trim()); that._dropDownSize.borderWidth = (isNaN(topBorder) ? 0 : topBorder) + (isNaN(bottomBorder) ? 0 : bottomBorder); that._dropDownSize.paddingWidth = (isNaN(topPaddinng) ? 0 : topPaddinng) + (isNaN(bottomPaddinng) ? 0 : bottomPaddinng); that._dropDownSize.marginWidth = (isNaN(topMargin) ? 0 : topMargin) + (isNaN(bottomMargin) ? 0 : bottomMargin); } /** * Initializes the element. */ _createElement() { const that = this; that._tokenTemplate = that._validateTemplate(that.tokenTemplate); //Set properties. that._applySelection(); that._setDropDownSize(); that._setFocusable(); //Flag indicator for the ripple effect. Used to append the ripple to that specific element, not his firstElementChild like it's done usually. //Used in class Ripple, method animate() in lwelement. that.$.arrow.noRipple = true; that._shadowDOMStylesDelay = that.shadowRoot; that._setAriaRelations(true); } /** * Document mouse down event handler. */ _documentDownHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } let target = event.originalEvent.target; if (target === that._overlay) { that._overlayDown = true; } if (that.shadowRoot) { target = event.originalEvent.composedPath()[0]; let rootElement = target.getRootNode().host; while (rootElement) { if (rootElement.closest('.lw-drop-down-container') === that.$.dropDownContainer) { that._isDropDownClicked = true; } rootElement = rootElement.getRootNode().host; } } else { if (that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; } that._isDropDownClicked = target.closest('.lw-drop-down-container') === that.$.dropDownContainer; } that._buttonClicked = target.closest('.lw-action-button') || target.closest('.lw-drop-down-button'); if (that.$.listBox) { let listItem = target.closest('lw-list-item'); if (!that.$.listBox.contains(listItem)) { listItem = undefined; } if (that.hasRippleAnimation && listItem) { LW.Utilities.Animation.Ripple.animate(listItem, event.pageX, event.pageY); } if (listItem || target === that.$.listBox.$.filterInput || target.closest('.lw-token')) { that._preventDropDownClose = true; } } if (that._isDropDownClicked) { that._preventDropDownClose = true; } if (target !== that.$.resizeBar || that.resizeMode === 'none') { return; } if (!that._resizeDetails) { that._resizeDetails = {}; } const computedStyle = that.$.dropDownContainer.getBoundingClientRect(); that._resizeDetails.started = true; that._resizeDetails.x = event.pageX; that._resizeDetails.y = event.pageY; that._resizeDetails.width = that.$.dropDownContainer.offsetWidth; that._resizeDetails.height = that.$.dropDownContainer.offsetHeight; that._resizeDetails.offsetXL = event.clientX - computedStyle.left; that._resizeDetails.offsetXR = computedStyle.left + that.$.dropDownContainer.offsetWidth - event.clientX; that._resizeDetails.offsetY = computedStyle.top + that.$.dropDownContainer.offsetHeight - event.clientY; that._resizeDetails.offsetYtop = event.clientY - computedStyle.top; that._preventDropDownClose = true; } /** * Document Move Event handler * @param {any} event */ _documentMoveHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.dropDownOpenMode === 'auto' && that.dropDownAppendTo !== null) { if (that.contains(target) || that.$.dropDownContainer.contains(target)) { that._isElementHovered = true; } else { that._isElementHovered = false; that._autoClose(); } } if (!that._resizeDetails || (that._resizeDetails && !that._resizeDetails.started)) { return; } that.setAttribute('resizing', ''); if (!that._resizeDetails.resizeEventFired) { that.$.fireEvent('resizeStart', { 'position': { left: event.pageX, top: event.pageY } }); that._resizeDetails.resizeEventFired = true; } const doc = document.documentElement, computedStyle = that.$.dropDownContainer.getBoundingClientRect(), dropDownStyle = that.getBoundingClientRect(), direction = that.$.dropDownContainer.hasAttribute('top') ? 'top' : 'bottom'; let size; function verticalResize() { size = event.pageY - that._resizeDetails.y; if (direction === 'bottom') { //6 is the margin of document.body, we don't want scrollbars to be shown that._resizeDetails.height = Math.min(doc.clientHeight - computedStyle.top - 6, Math.max(0, that._resizeDetails.height + size)); that._resizeDetails.y = Math.max(computedStyle.top + doc.scrollTop - that._resizeDetails.offsetY, Math.min(doc.clientHeight + doc.scrollTop - that._resizeDetails.offsetY * 1.5, event.pageY)); } else { that._resizeDetails.height = Math.min(that._dropDownSize.maxHeight, Math.max(0, Math.min(dropDownStyle.top, that._resizeDetails.height - size))); size = Math.max(0, computedStyle.top + (computedStyle.height - Math.max(that._dropDownSize.minHeight, that._resizeDetails.height))); if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) { const margin = Math.abs(parseFloat(getComputedStyle(that.$.dropDownContainer).getPropertyValue('margin-bottom'))) || 0; that.$.dropDownContainer.style.top = that.dropDownAppendTo && that.dropDownAppendTo.length > 0 ? (margin + size) + 'px' : ''; } const minYCondition = dropDownStyle.top + doc.scrollTop + that._resizeDetails.offsetYtop; that._resizeDetails.y = Math.max(that._resizeDetails.offsetYtop, Math.min(minYCondition, Math.max(minYCondition - that._dropDownSize.maxHeight, event.pageY))); } that.$.dropDownContainer.style.height = that._resizeDetails.height + 'px'; } function horizontalResize() { //Resize only from corner //if (that._resizeDetails.offsetXR > 20) { // return; //} size = event.pageX - that._resizeDetails.x; //6 is the margin of document.body, we don't want scrollbars to be shown that._resizeDetails.width = Math.min(doc.clientWidth - computedStyle.left - 6, Math.max(0, that._resizeDetails.width + size)); that.$.dropDownContainer.style.width = that._resizeDetails.width + 'px'; that._resizeDetails.x = Math.max(computedStyle.left + doc.scrollLeft - that._resizeDetails.offsetXR, Math.min(doc.clientWidth + doc.scrollLeft - that._resizeDetails.offsetXR * 1.5, event.pageX)); } switch (that.resizeMode) { case 'vertical': verticalResize(); break; case 'horizontal': horizontalResize(); break; case 'both': horizontalResize(); verticalResize(); break; } } /** * Document Up handler. */ _documentUpHandler(event) { const that = this; that.$.actionButton.removeAttribute('active'); if (that._resizeDetails && that._resizeDetails.started) { that._resizeDetails.started = that._resizeDetails.resizeEventFired = false; that.removeAttribute('resizing'); that._preventDropDownClose = false; that.focus(); that.$.fireEvent('resizeEnd', { 'position': { left: event.pageX, top: event.pageY } }); return; } if (that.disabled || that._isDropDownClicked || that.readonly) { delete that._isDropDownClicked; return; } if (that._overlayDown) { that.close(); delete that._overlayDown; return; } let target = event.originalEvent.target, rootElement = target.closest ? target.closest('lw-drop-down-list') : undefined; if (that.enableShadowDOM || that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; rootElement = target.getRootNode().host; } that._preventsSelectStart = false; if (typeof (target) === 'undefined' || target === that.$.resizeBar) { return; } if (that.selectionDisplayMode === 'tokens' && target.classList.contains('lw-drop-down-list-selection-label') && rootElement === that) { if (that.dropDownOpenMode !== 'none') { that.open(); } let item = that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.textContent)[0]; //Scroll to that item and focus it. that.$.listBox._scrollView.scrollTop = item.offsetTop; that._focus(item); return; } if (that.selectionDisplayMode === 'tokens' && target.classList.contains('lw-drop-down-list-unselect-button') && rootElement === that) { if (that.selectedIndexes.length === 1 && ['zeroOrMany', 'zeroOrOne', 'checkBox'].indexOf(that.selectionMode) < 0) { return; } that.unselect(that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.previousElementSibling.textContent)[0]); return; } const isActionButtonPressed = target.closest('.lw-action-button'); let openDropDown; if (that._buttonClicked) { if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed && that._buttonClicked === that.$.actionButton) { that.$.fireEvent('actionButtonClick'); } else if (target.closest('.lw-drop-down-button') === that._buttonClicked || isActionButtonPressed === that._buttonClicked) { openDropDown = true; that.$.fireEvent('dropDownButtonClick'); } } that._buttonClicked = undefined; if (isActionButtonPressed === that.$.actionButton || target.closest('.lw-drop-down-button') === that.$.dropDownButton) { if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed === that.$.actionButton) { that.close(); return; } //Open/Close the dropDownList that.$dropDownContainer.hasClass('lw-visibility-hidden') && that.dropDownOpenMode !== 'none' && openDropDown && event.originalEvent.type !== 'pointercancel' ? that.open() : that.close(); return; } target = that._getUpEventTarget(target); if (target === undefined) { return; } if (target !== 'dropDownContainer' && target !== 'item' || target === 'item' && that.selectionMode !== 'checkBox' && that.selectionMode.indexOf('Many') < 0) { that.close(); } } /** * DragStarted Event Handler * @param {any} event */ _dragStartHandler(event) { const that = this; if (that._resizeDetails && that._resizeDetails.started) { event.preventDefault(); } } /** * Dropdown transitionend handler. */ _dropDownTransitionendHandler() { const that = this; if (that._edgeMacFF && !that.opened && that.hasAnimation) { that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = ''; that.$dropDownContainer.addClass('not-in-view'); } } /** * Focuses an item. Accepts a LW.ListItem element or a string, representing the value of an item. */ _focus(item) { this.$.listBox._focus(item); } /** * Element/DropDownButton blur event handler * @param {any} event */ _blurEventHandler() { const that = this; if (that.$.dropDownButton) { that.removeAttribute('focus'); that.$.dropDownButton.removeAttribute('focus'); } if (that.$.actionButton) { that.removeAttribute('focus'); that.$.actionButton.removeAttribute('focus'); } //NOT Applicable to lwDropDownButton, because the contento of the popup is focusable ! if (that.nodeName && that.nodeName.toLowerCase() === 'lw-drop-down-list' && !that._preventDropDownClose) { that.close(); } } /** * Element focus event handler */ _focusEventHandler() { const that = this; if (that.$.dropDownButton) { that.setAttribute('focus', ''); that.$.dropDownButton.setAttribute('focus', ''); } if (that.$.actionButton) { that.setAttribute('focus', ''); that.$.actionButton.setAttribute('focus', ''); } that.removeAttribute('drop-down-button-focus'); that.removeAttribute('action-button-focus'); } /** * DropDownList drop-down-button and action-button focus/blur handlers * @param {any} event */ _buttonsFocusHandler(event) { const that = this; if (event.target === that.$.dropDownButton) { if (event.type === 'focus') { that.setAttribute('drop-down-button-focus', ''); } else { that.removeAttribute('drop-down-button-focus'); //NOT Applicable to lwDropDownButton, because the contento of the popup is focusable ! if (that.nodeName && that.nodeName.toLowerCase() === 'lw-drop-down-list' && !that._preventDropDownClose) { that.close(); } } } else { event.type === 'focus' ? that.setAttribute('action-button-focus', '') : that.removeAttribute('action-button-focus'); } } /** * Gets the target of a document up event. */ _getUpEventTarget(originalTarget) { const that = this; let target = originalTarget; target = target.parentElement === undefined ? target.getRootNode().host : target.parentElement; while (target) { if (target === that.$.dropDownContainer) { target = 'dropDownContainer'; break; } target = target.parentElement === undefined ? target.getRootNode().host : target.parentElement; } return target; } /** * DropDown keydown event handler. */ _keyDownHandler(event) { const that = this, activeElement = that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement, target = that.enableShadowDOM ? event.composedPath()[0] : event.target; if (that.$.listBox && target === that.$.listBox.$.filterInput || (activeElement !== that && activeElement !== that.$.dropDownButton && activeElement !== that.$.actionButton)) { return; } switch (event.key) { case 'Enter': case ' ': event.preventDefault(); if (target !== that.$.actionButton) { that._keyPressed = true; if (that.opened) { if (that._focusedItem) { that.select(that._focusedItem); } if ((event.key === 'Enter' && ['none'].indexOf(that.selectionMode) < 0) || (event.key === ' ' && ['none', 'one', 'radioButton'].indexOf(that.selectionMode) > -1)) { that.close(); } } else if (!that.opened && !that.readonly && that.dropDownOpenMode !== 'none') { that.open(); } } if (that.dropDownOpenMode === 'dropDownButton') { target.setAttribute('active', ''); } break; case 'End': case 'Home': case 'PageUp': case 'PageDown': case 'ArrowUp': case 'ArrowDown': if (that.readonly) { return; } if (event.altKey) { that._keyPressed = false; that.$dropDownContainer.hasClass('lw-visibility-hidden') ? that.open() : that.close(); return; } event.preventDefault(); that.$.listBox._handleKeyStrokes(event.key); break; case 'Escape': event.preventDefault(); that.close(); break; default: if (that.readonly) { return; } if (that.selectionMode === 'oneOrManyExtended') { that.$.listBox._keysPressed[event.key] = true; } that.$.listBox._applyIncrementalSearch(event.key); break; } } /** * DropDown key up event handler. */ _keyUpHandler(event) { const that = this, target = that.enableShadowDOM ? event.composedPath()[0] : event.target; if (that.$.listBox && target === that.$.listBox.$.filterInput) { return; } if (event.key === 'Enter' || event.key === ' ') { target.removeAttribute('active'); if (!that.$dropDownContainer.hasClass('lw-visibility-hidden')) { that._keyPressed = false; //that.$.listBox.focus(); } } if (that.$.listBox && that.selectionMode === 'oneOrManyExtended') { that.$.listBox._keysPressed[event.key] = false; } } /** * DropDownList Change event handler. */ _listBoxChangeHandler(event) { const that = this; if (event.target !== that.$.listBox) { event.stopPropagation(); return; } if ((that.dropDownAppendTo && that.dropDownAppendTo.length > 0) || that.enableShadowDOM) { that.$.fireEvent('change', event.detail); } if (that.autoComplete === 'list' && event.detail) { const lastSelectedItem = that.$.listBox._items[event.detail.index]; that._lastSelectedItem = lastSelectedItem && lastSelectedItem.selected ? lastSelectedItem : undefined; } that._applySelection(that.selectionMode, event.detail); } /** * ListBox itemClick event handler * @param {any} event */ _listBoxItemClickHandler(event) { const that = this; if ((that.dropDownAppendTo && that.dropDownAppendTo.length > 0) || that.enableShadowDOM) { that.$.fireEvent(event.type, event.detail); } if (that.selectionMode !== 'checkBox' && that.selectionMode.indexOf('Many') < 0) { that.close(); } if (!LW.Utilities.Core.isMobile) { that.focus(); } delete that._isDropDownClicked; } /** * DropDownList key down handler. */ _listBoxKeyDownHandler(event) { const that = this; if (event.key === 'Enter') { that.close(); that.dropDownOpenMode === 'dropDownButton' ? that.$.dropDownButton.focus() : that.focus(); event.stopPropagation(); return; } if (event.key === 'Escape') { that.close(); return; } } /** * Element container mouse enter event handler. */ _mouseEnterHandler() { const that = this; that._isElementHovered = true; if (that.tagName.toLowerCase().indexOf('lw-drop-down-') > -1 && that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) { that.open(); } } /** * Element container mouse leave event handler. */ _mouseLeaveHandler() { const that = this; that.removeAttribute('hover'); that._isElementHovered = false; if (that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) { that._autoClose() } } /** * Mouse wheel event handler. */ _mouseWheelHandler(event) { const that = this; if (that.disabled || that.readonly || (that.items && that.items.length === 0)) { return; } if (that.$dropDownContainer && !that.$dropDownContainer.hasClass('lw-visibility-hidden')) { return; } if (that.$.listBox) { event.preventDefault(); that.$.listBox._handleKeyStrokes(event.deltaY > 0 ? 'ArrowDown' : 'ArrowUp'); } } /** * Automatically closes the dropdown. */ _autoClose() { const that = this; that._autoCloseTimeout = setTimeout(function () { if (!that._isElementHovered) { that.close(); } clearTimeout(that._autoCloseTimeout); }.bind(that), that.autoCloseDelay); } /** * Validates the value of the property * @param {any} oldValue - the old value * @param {any} value - the new value */ _propertyValidator(oldValue, newValue) { if (typeof newValue !== 'number' && typeof newValue !== 'string') { return oldValue; } return newValue; } /** * Resize handler - recalculate the size of the popup if the element is initialized with a different size. */ _resizeHandler() { const that = this; if (that.resizeMode === 'none') { that._calculateDropDownSize(); that._setDropDownSize(); } } /** * Document select start event handler. */ _selectStartHandler(event) { if (this._preventsSelectStart) { event.preventDefault(); } } /** * Sets WAI-ARIA relations. */ _setAriaRelations(initialization) { const that = this; let oldButton, newButton; if (that.dropDownOpenMode !== 'dropDownButton') { oldButton = that.$.dropDownButton; oldButton.setAttribute('aria-hidden', true); newButton = that; that.$.actionButton.removeAttribute('role'); } else { oldButton = that; newButton = that.$.dropDownButton; newButton.removeAttribute('aria-hidden'); that.$.actionButton.setAttribute('role', 'button'); } that._ariaButton = newButton; newButton.setAttribute('role', 'button'); newButton.setAttribute('aria-haspopup', 'listbox'); newButton.setAttribute('aria-owns', that.$.listBox.id); newButton.setAttribute('aria-describedby', that.$.hint.id); if (that.label) { newButton.setAttribute('aria-labelledby', that.$.label.id); } else if (that.elementName === 'DropDownList') { newButton.setAttribute('aria-labelledby', that.$.actionButton.id); } oldButton.setAttribute('role', 'presentation'); oldButton.removeAttribute('aria-owns'); if (initialization) { newButton.setAttribute('aria-expanded', that.opened); } else { oldButton.removeAttribute('aria-describedby'); oldButton.removeAttribute('aria-expanded'); oldButton.removeAttribute('aria-haspopup'); oldButton.removeAttribute('aria-labelledby'); } } /** * Set DropDown Size. */ _setDropDownSize() { const that = this; let dropDownHeight; if (!that._dropDownSize) { that._calculateDropDownSize(); } ['dropDownMinWidth', 'dropDownMaxWidth'].forEach((name) => { that.$.dropDownContainer.style[name.replace('dropDown', '').replace(/^./, 'm')] = that[name] === 'initial' ? that.offsetWidth + 'px' : (that[name] ? parseFloat(that[name]) + (that[name].toString().endsWith('%') ? '%' : 'px') : null); }); ['dropDownMinHeight', 'dropDownMaxHeight'].forEach((name) => { that.$.dropDownContainer.style[name.replace('dropDown', '').replace(/^./, 'm')] = that[name] ? parseFloat(that[name]) + (that[name].toString().endsWith('%') ? '%' : 'px') : null; }); if (that.dropDownWidth) { if (that.dropDownWidth !== 'auto') { that.$.dropDownContainer.style.width = (that.dropDownWidth === 'initial' ? that.offsetWidth : parseFloat(that.dropDownWidth)) + 'px'; } else { that.$.dropDownContainer.style.width = 'auto'; } } else { that.$.dropDownContainer.style.width = that._dropDownSize.width === 'auto' ? 'auto' : (parseFloat(that._dropDownSize.width) || 0) + 'px'; } if (that.dropDownHeight && that.dropDownHeight !== 'auto') { that.$.dropDownContainer.style.height = parseFloat(that.dropDownHeight) + ((that.dropDownHeight + '').indexOf('%') > -1 ? '%' : 'px'); } else { if (that.$.listBox && (that._dropDownSize.height === 'auto' || that.dropDownHeight === 'auto')) { that.$.dropDownContainer.style.height = ''; let verticalOffset = 2 * parseInt(window.getComputedStyle(that.$.listBox.$.itemsContainer).getPropertyValue('--lw-list-item-vertical-offset')); if (isNaN(verticalOffset)) { verticalOffset = 6; } dropDownHeight = verticalOffset; if (that.$.listBox.items.length > 0) { that.$.listBox.items.map(item => dropDownHeight += item.height || item.offsetHeight); } else { dropDownHeight = that.$.listBox.$.placeholder.offsetHeight; } if (that.filterable) { const filterInputContainer = that.$.listBox.$.filterInputContainer; dropDownHeight += filterInputContainer.offsetHeight + filterInputContainer.offsetTop; } dropDownHeight = dropDownHeight + that._dropDownSize.paddingWidth + that._dropDownSize.borderWidth; that.$.dropDownContainer.style.height = dropDownHeight + 'px'; } else { that.$.dropDownContainer.style.height = that._dropDownSize.height; } } if (that.$.listBox) { that.$.listBox._refreshLayout(); if (dropDownHeight === undefined || !that.$.listBox.$) { return; } const vScrollOverlapHeight = Math.max(0, that._dropDownSize.minHeight - (dropDownHeight - that.$.listBox.$.horizontalScrollBar.offsetHeight)); if (vScrollOverlapHeight) { that.$.dropDownContainer.style.height = (dropDownHeight + vScrollOverlapHeight) + 'px'; } } } /** * Style changed event handler * @param {any} event */ _styleChangedHandler(event) { const that = this; if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) { const styleProperties = event.detail.styleProperties, fontProperties = ['font-size', 'font-family', 'font-style', 'font-weight']; for (let s = 0; s < fontProperties.length; s++) { if (styleProperties[fontProperties[s]]) { that.$.dropDownContainer.style[fontProperties[s]] = styleProperties[fontProperties[s]].value; } } } if (that._dropDownSize.height === 'auto') { that._setDropDownSize(); } } /** * Checks for HTMLTemplate support and returns it's content. */ _validateTemplate(template) { const that = this; if (!template) { return; } if (typeof template === 'function') { return; } if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } if (!(template instanceof HTMLTemplateElement)) { template = document.getElementById(template); } if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'tokenTemplate' })); return; } return template; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * ComboBox custom element. */ LW('lw-combo-box', class ComboBox extends LW.DropDownList { /** * ComboBox's properties */ static get properties() { return { 'autoComplete': { allowedValues: ['none', 'manual', 'auto', 'inline', 'list'], type: 'string', value: 'none' }, 'autoCompleteDelay': { value: 100, type: 'number' }, 'autoOpenShortcutKey': { value: [], type: 'array' }, 'dropDownOpenMode': { allowedValues: ['none', 'default', 'dropDownButton', 'auto'], value: 'dropDownButton', defaultReflectToAttribute: true, type: 'string' }, 'escKeyMode': { allowedValues: ['clearValue', 'firstPossibleValue', 'none', 'previousValue'], type: 'string', value: 'none' }, 'inputPurpose': { type: 'string', value: 'off' }, 'minLength': { type: 'number', value: 2 }, 'value': { value: '', type: 'string' } } } /** * ComboBox's event listeners. */ static get listeners() { return { 'input.focus': '_inputFocusHandler', 'input.blur': '_inputFocusHandler', 'dropDownButton.focus': '_dropDownButtonFocusHandler', 'dropDownButton.blur': '_dropDownButtonFocusHandler', 'input.change': '_inputChangeEventHandler', 'input.mouseenter': '_buttonsMouseEventsHandler', 'input.mouseleave': '_buttonsMouseEventsHandler', 'document.down': '_documentDownHandler', 'document.up': '_documentUpHandler', 'document.selectstart': '_selectStartHandler', 'dropDownButton.down': '_buttonsDownHandler', 'dropDownButton.mouseenter': '_buttonsMouseEventsHandler', 'dropDownButton.mouseleave': '_buttonsMouseEventsHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler', 'listBox.change': '_listBoxChangeHandler', 'listBox.itemClick': '_listBoxItemClickHandler', 'listBox.keydown': '_listBoxKeyDownHandler', 'wheel': '_mouseWheelHandler' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.combobox.css' ] } /** * ComboBox's HTML template. */ template() { return `<div id="container" role="presentation"> <span class="lw-label" id="label">[[label]]</span> <div id="content" class="lw-content" role="presentation"> <div class="lw-buttons-container" id="buttonsContainer" role="presentation"> <span id="actionButton" class="lw-action-button" role="presentation"> <input class="lw-input" id="input" placeholder="[[placeholder]]" autocomplete="[[inputPurpose]]" role="textbox" aria-label="[[placeholder]]" /> <div class="lw-combo-box-auto-complete-string" id="autoCompleteString"></div> </span> <span id="dropDownButton" class="lw-drop-down-button" role="button" aria-label="Toggle popup"> <span class="lw-drop-down-button-icon" id="arrow" aria-hidden="true"></span> </span> </div> <div id="dropDownContainer" class="lw-drop-down lw-drop-down-container lw-visibility-hidden" role="presentation"> <lw-list-box id="listBox" unfocusable animation="[[animation]]" data-source="[[dataSource]]" disabled="[[disabled]]" display-loading-indicator="[[displayLoadingIndicator]]" display-member="[[displayMember]]" filterable="[[filterable]]" filter-callback="[[filterCallback]]" filter-mode="[[filterMode]]" filter-input-placeholder="[[filterInputPlaceholder]]" grouped="[[grouped]]" group-member="[[groupMember]]" item-height="[[itemHeight]]" item-measure-mode="[[itemMeasureMode]]" item-template="[[itemTemplate]]" incremental-search-delay="[[incrementalSearchDelay]]" incremental-search-mode="[[incrementalSearchMode]]" loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]" loading-indicator-position="[[loadingIndicatorPosition]]" name="[[name]]" placeholder="[[dropDownPlaceholder]]" readonly="[[readonly]]" right-to-left="[[rightToLeft]]" selected-indexes="{{selectedIndexes}}" selection-mode="[[selectionMode]]" selected-values="{{selectedValues}}" sorted="[[sorted]]" theme="[[theme]]" value-member="[[valueMember]]" horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]" vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]" virtualized="[[virtualized]]"> <content></content> </lw-list-box> <div id="resizeBar" class="lw-drop-down-resize-bar" aria-label="Resize"> <div></div> </div> </div> </div> <span class="lw-hint" id="hint">[[hint]]</span> </div>`; } /** * Updates the ComboBox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'autoComplete': if (newValue === 'list') { that.$.listBox.$.filterInput.value = ''; //Context Fix let listBoxContext = that.$.listBox.context; that.$.listBox.context = that.$.listBox; that.$.listBox._filterItems(true); that.$.listBox.context = listBoxContext; that._setDropDownSize(); } that._autoComplete(true); that._setAriaAutocomplete(); //If autoComplete is disabled //if (newValue === 'none' && (['one', 'oneOrManyExtended', 'oneOrMany'].indexOf(that.selectionMode) > -1 && !that.selectedIndexes.length && that.items.length)) { // that.select(that._focusedItem || that.items[0]); //} break; case 'dataSource': case 'displayMember': //when selectedValues is 0 and displayMember is changed set actionButton text to default. that._clearSelection(true); //Check the new listBox size that._setDropDownSize(); that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds('horizontally'); //Issue: When changing dataSource from property, the items are not added right away so size isnt calculated properly. Needs a new event or sth... //that._setDropDownSize(); break; case 'disabled': //Needed, because spans are inserted before the input in advanced selectionDisplayMode and atr syncronization doesn't affect the input. that.$.input.disabled = newValue; that._setFocusable(); that.close(); if (that._positionDetection) { that._positionDetection.handleAutoPositioning(); } that._ariaPropertyChangedHandler('disabled', newValue); break; case 'readonly': //Needed, because spans are inserted before the input in advanced selectionDisplayMode and atr syncronization doesn't affect the input. that.$.input.readOnly = newValue; that.close(); that._ariaPropertyChangedHandler('readonly', newValue); break; case 'selectedValues': case 'selectedIndexes': that._clearSelection(true); break; case 'selectionMode': case 'selectionDisplayMode': that._clearSelection(); that._applySelectionDisplayMode(); if (that.selectionDisplayMode === 'tokens') { that._currentSelection = undefined; } that._applySelection(that.selectionMode); if (propertyName === 'selectionMode') { super.propertyChangedHandler(propertyName, oldValue, newValue); } break; case 'tokenTemplate': if (that.$.selectionField) { while (that.$.selectionField.firstElementChild.nodeName === 'SPAN') { that.$.selectionField.removeChild(that.$.selectionField.firstElementChild); } } that._tokenTemplate = that._validateTemplate(that.tokenTemplate); that._applySelection(); break; case 'value': that.clearSelection(); that.value = that.$.input.value = that._oldValue = newValue; that._queryItems(true); if(that._currentSelection && !that._currentSelection.length) { that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.$.input.value, 'addedItems': [], 'removedItems': [], 'selected': [], 'disabled': [], 'index': [], 'label': [], }); } break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Removes all items from the ComboBox. */ clearItems() { const that = this; that.$.listBox.clearItems(); that._clearSelection(true); } /** * Unselects all items. */ clearSelection() { const that = this; that.$.listBox.clearSelection(); that._clearSelection(arguments[0] ? false : true); } /* ** Blur Method */ blur() { this.$.input.blur(); } /** * Close method. */ close() { const that = this; super.close(); that.$.input.removeAttribute('aria-controls'); } /** * Focus method */ focus() { this.$.input.focus(); } /** * Open method */ open() { const that = this; super.open(); that.$.input.setAttribute('aria-controls', that.$.listBox.id); } /** * Sets tab index */ _setFocusable() { const that = this; if (!that.disabled && !that.unfocusable) { let index = that.tabIndex > 0 ? that.tabIndex : 0; that.$.input.tabIndex = index; that.dropDownOpenMode === 'dropDownButton' ? that.$.dropDownButton.setAttribute('tabindex', index) : that.$.dropDownButton.removeAttribute('tabindex'); //that.$.dropDownButton.setAttribute('tabindex', index); return; } that.$.input.tabIndex = -1; that.$.dropDownButton.removeAttribute('tabindex'); } /** * Handles the autoComplete functionaltiy */ _autoComplete(noSelectionRefresh) { const that = this; if (that.autoComplete === 'list') { return; } if (that.$.listBox._items.length === 0 && typeof that.dataSource !== 'function') { that.close(); return; } const value = that.$.input.value.length < that.minLength ? '' : (that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value), //displayMode is a lwTextBox property isItemFocused = function (items) { for (let i = 0; i < items.length; i++) { if (items[i]._focused && items[i].hasAttribute('focus')) { return true; } } }; let selectedItem; if (that.$.listBox.selectedValues.length === 1) { selectedItem = that.$.listBox.getItem(that.$.listBox.selectedValues[0]); } that.$.autoCompleteString.textContent = ''; that.$.listBox.$.filterInput.value = that.autoComplete === 'none' || that.$.input.value.length < that.minLength ? '' : value; const queryCallback = function () { if (!that.$.listBox.isAttached || !that.$.input) { return; } const activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement; that._setDropDownSize(); if (that.opened) { that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds(); } if (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length > 0) { that.$.listBox._scrollView.scrollTop = that.$.listBox._filteredItems[0].offsetTop; if (that.autoComplete !== 'none' && that.$.input.value.length >= that.minLength && !isItemFocused(that.$.listBox._filteredItems)) { that._focus(that.$.listBox._filteredItems[0]); } if (activeElement === that.$.input && that.autoComplete === 'inline' && that.$.input.value.length >= that.minLength) { that._updateAutoCompleteHelper(); } if (selectedItem && selectedItem[that.inputMember] === that.$.listBox._filteredItems[0][that.inputMember] && selectedItem.value === that.$.listBox._filteredItems[0].value) { that.$.listBox.context = that.$.listBox; that.$.listBox._select(that.$.listBox._filteredItems[0], true); that.$.listBox.context = listBoxContext; } if (value !== that.$.listBox._filteredItems[0][that.inputMember] || (LW.TextBox && that instanceof LW.TextBox && that.dropDownOpenMode === 'auto')) { if (that._closedFromKeyCombination) { that._closedFromKeyCombination = false; return; } if (value.length < that.minLength && !(LW.TextBox && that instanceof LW.TextBox && that.dropDownOpenMode === 'auto')) { that.close(); return; } if (that.isCompleted && that.dropDownOpenMode !== 'none' && activeElement === that.$.input) { that.open(); } } return; } that[typeof that.dataSource === 'function' ? 'open' : 'close'](); } //Context Fix let listBoxContext = that.$.listBox.context; that.$.listBox.context = that.$.listBox; that.$.listBox._filterItems(noSelectionRefresh ? true : false, queryCallback, LW.TextBox && that instanceof LW.TextBox && that.dropDownOpenMode === 'auto'); that.$.listBox.context = listBoxContext; } /** * Updates the autoComplete string highlighter */ _updateAutoCompleteHelper() { const that = this, autoCompleteString = that.$.autoCompleteString; autoCompleteString.style.width = that.$.input.offsetWidth + 'px'; autoCompleteString.style.height = that.$.input.offsetHeight + 'px'; autoCompleteString.style.left = that.$.input.offsetLeft + 'px'; autoCompleteString.style.top = that.$.input.offsetTop + 'px'; autoCompleteString.style.paddingLeft = that.selectedIndexes.length > 0 ? 0 : null; if (!that._focusedItem) { autoCompleteString.textContent = ''; return; } const inputValue = that.$.input.value, focusedItemlabel = that._focusedItem[that.inputMember]; if (focusedItemlabel.length !== inputValue.length && focusedItemlabel.toLowerCase().indexOf(inputValue.toLowerCase()) === 0) { autoCompleteString.textContent = that.$.input.value + focusedItemlabel.slice(inputValue.length); } } /** * Fills the selection field with the labels selected items. */ _applySelection(mode, details) { const that = this; if (!that.$.selectionField) { that.$.selectionField = that.$.actionButton; } that.$.autoCompleteString.textContent = ''; if (that.selectedIndexes.length === 0) { that._clearSelection(details && details.index > -1 && that.$.input.value === that.$.listBox._items[details.index][that.inputMember]); return; } if (!that.$.listBox._items || that.$.listBox._items.length === 0) { return; } if (that.selectionMode === 'one' || that.selectionMode === 'zeroOrOne' || that.selectionMode === 'radioButton') { if (that._currentSelection && that._currentSelection.length > that.selectedIndexes.length) { that._currentSelection = that.selectedIndexes.map(i => that.$.listBox._items[i][that.inputMember]); that.$.input.value = that._currentSelection.toString(); that._oldValue = that.value = that._currentSelection.toString(); return; } that._clearSelection(); that._currentSelection = that.selectedIndexes.map(i => that.$.listBox._items[i][that.inputMember]); that.$.input.value = that._currentSelection.toString(); that._oldValue = that.value = that._currentSelection.toString(); that.$.container.setAttribute('has-value', ''); if (that.autoComplete !== 'none' && typeof that.dataSource !== 'function') { that._autoComplete(true); if (!that._keyboardNavigation) { that.close(); } } } else { that.$.input.value = ''; that.$.input.placeholder = ''; that.$.container.setAttribute('has-value', ''); while (that.$.selectionField.firstElementChild.nodeName === 'SPAN') { that.$.selectionField.removeChild(that.$.selectionField.firstElementChild) } let fragment = document.createDocumentFragment(), element, icon; if (that.selectedIndexes.length === 1 && (that.selectionMode === 'oneOrManyExtended' || that.selectionMode === 'oneOrMany')) { icon = ''; } else { icon = that.selectionDisplayMode === 'tokens' ? '&#10006' : ','; } that.selectedIndexes.map(index => { element = that._applyTokenTemplate(that.$.listBox._items[index][that.inputMember], icon); element._value = that.$.listBox._items[index].value; fragment.appendChild(element); }); that.$.selectionField.insertBefore(fragment, that.$.input); that._currentSelection = that.selectedIndexes.map(i => that.$.listBox._items[i][that.inputMember]); that._oldValue = that.value = that._currentSelection.toString(); that._positionDetection.positionDropDown(); } } /** * Sets the selection mode for the ComboBox. */ _applySelectionDisplayMode() { const that = this; if (that.selectionMode === 'one' || that.selectionMode === 'zeroOrOne' || that.selectionMode === 'radioButton') { that.$.removeClass('auto-height'); } else { that.$.addClass('auto-height'); } } /** * BindingComplete event Handler. When the dataSource or size of listBox is changed. */ _bindingCompleteHandler() { const that = this; that._queryItems(); that._setDropDownSize(); } /** * ComboBox container mouse enter/leave events handler. */ _buttonsMouseEventsHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } if (event.type === 'mouseenter') { event.target.setAttribute('hover', ''); that.setAttribute('hover', ''); if (that.dropDownOpenMode === 'auto' && !(LW.TextBox && that instanceof LW.TextBox)) { if (event.target === that.$.dropDownButton) { that.open(); that.$.input.focus(); } else { that.close(); } } } else { event.target.removeAttribute('hover'); that.removeAttribute('hover'); } } /** * Initializes the element. */ _createElement() { const that = this; that.classList.add('lw-drop-down-box'); that._tokenTemplate = that._validateTemplate(that.tokenTemplate); //Set properties. that._applySelectionDisplayMode(); that._applySelection(that.selectionMode); if (that.autoComplete !== 'none') { that._autoComplete(true); } that._setDropDownSize(); that.$.input.disabled = that.disabled; that.$.input.readOnly = that.readonly; that._setFocusable(); if (that.$.input.value.length > 0 && that.selectedIndexes.length === 0) { that.$.container.setAttribute('has-value', ''); that._oldValue = that.value = that.$.input.value; } //Flag indicator for the ripple effect. Used to append the ripple to that specific element, not his firstElementChild like it's done usually. //Used in class Ripple, method animate() in lwelement. that.$.arrow.noRipple = true; that.checkLicense(); that._setAriaRelations(true); } /** * Reset the input and clears the selection field. */ _clearSelection(resetInput) { const that = this; if (resetInput) { that.$.input.value = ''; that.value = ''; } that.$.input.placeholder = that.placeholder; that.$.autoCompleteString.textContent = ''; that._currentSelection = []; if (that.$.selectionField) { while (that.$.selectionField.firstElementChild.nodeName === 'SPAN') { that.$.selectionField.removeChild(that.$.selectionField.firstElementChild) } } if (that.autoComplete !== 'none' && that.autoComplete !== 'list' && that.$.input.value.length > 0) { if (that._autoCompleteTimer) { clearTimeout(that._autoCompleteTimer); } if (typeof that.dataSource !== 'function') { that._autoCompleteTimer = setTimeout(function () { that._autoComplete(true); }, that.autoCompleteDelay); } } if (!that.$.input.value.length) { that.$.container.removeAttribute('has-value'); } } _documentDownHandler(event) { const that = this; super._documentDownHandler(event); let target = event.originalEvent.target; if (that.shadowRoot || that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; } if (target === that.$.dropDownButton && that.dropDownOpenMode !== 'none' && !LW.Utilities.Core.isMobile) { requestAnimationFrame(() => that.$.input.focus()); } } /** * Document Up handler. */ _documentUpHandler(event) { const that = this; let target = event.originalEvent.target, rootElement = target.closest ? target.closest('lw-combo-box') : undefined; if (that.shadowRoot || that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; rootElement = target.getRootNode().host; } const originalTarget = target; if (that._resizeDetails && that._resizeDetails.started) { that._resizeDetails.started = that._resizeDetails.resizeEventFired = false; that.removeAttribute('resizing'); that._dropDownResized = true; that.$.fireEvent('resizeEnd', { 'position': { left: event.pageX, top: event.pageY } }); return; } if (that.disabled || that._isDropDownClicked || that.readonly) { delete that._isDropDownClicked; return; } if (that._overlayDown) { that.close(); delete that._overlayDown; return; } if (target === that.$.input || typeof (target) === 'undefined' || target === that.$.resizeBar) { return; } if (target === that.$.selectionField) { that.$.input.focus(); return; } if (target === that.$.dropDownButton && that.dropDownOpenMode !== 'none') { that._preventDropDownClose = true; target === that._buttonClicked && that.$dropDownContainer.hasClass('lw-visibility-hidden') && event.originalEvent.type !== 'pointercancel' ? that.open() : that.close(); if (!LW.Utilities.Core.isMobile) { requestAnimationFrame(() => that.$.input.focus()); } that._buttonClicked = undefined; return; } if (target.classList.contains('lw-drop-down-list-selection-label') && rootElement === that && that.dropDownOpenMode !== 'none') { const item = that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.textContent)[0]; //NOTE: Fires a new custom event for token click if (!item || that.$.fireEvent('tokenClick', { index: that.$.listBox._items.indexOf(item), label: item.label, value: item.value }).defaultPrevented) { return; } that.open(); that.$.input.focus(); //Scroll to that item and focus it. that.$.listBox.ensureVisible(item); that._focus(item); return; } if (that.selectionDisplayMode === 'tokens' && target.classList.contains('lw-drop-down-list-unselect-button') && rootElement === that) { if (that.selectedIndexes.length === 1 && ['zeroOrMany', 'zeroOrOne', 'checkBox'].indexOf(that.selectionMode) < 0) { return; } that.unselect(that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.previousElementSibling.textContent)[0]); that.$.input.focus(); return; } target = that._getUpEventTarget(target); if (target === undefined) { that.$.input.focus(); return; } if ((!that.$dropDownContainer.hasClass('lw-visibility-hidden') && target !== 'dropDownContainer' && target !== 'item') || (target === 'item' && that.selectionMode.indexOf('Many') < 0) && that.selectionMode !== 'checkBox') { that.close(); } if (target === 'item' || (target === 'dropDownContainer' && originalTarget !== that.$.listBox.$.filterInput)) { that.$.input.focus(); } } /** * DropDownButton Focus Handler * @param {any} event */ _dropDownButtonFocusHandler(event) { const that = this; if (event.type === 'focus') { if (that.dropDownOpenMode !== 'dropDownButton') { that.$.input.focus(); } that.setAttribute('focus', '') } else { that.removeAttribute('focus'); } } /** * ComboBox input's focus/blur event handler. */ _inputFocusHandler(event) { const that = this; if (that.disabled) { return; } if (event.type === 'focus') { that.setAttribute('focus', ''); if (!that._buttonClicked) { that._oldValue = that.$.input.value; } that.$.fireEvent('focus'); } else { that.removeAttribute('focus'); that.$.fireEvent('blur'); event.target.value !== '' || (that.selectedIndexes.length !== 0 && event.target.value === '') ? that.$.container.setAttribute('has-value', '') : that.$.container.removeAttribute('has-value'); if (!that._preventDropDownClose) { if (that.opened && (that.autoComplete === 'auto' || that.autoComplete === 'inline') && that.$.input.value.length > 0 && that._focusedItem && !that._focusedItem.selected) { that.select(that._focusedItem); } that.close(); } //Handles autoComplete mode 'list' if (!that._handleAutoCompleteModeList()) { return; } if (that.escKeyMode === 'previousValue') { that.value = that.$.input.value; } } } /** * Returns the previous value or clears the value if no item is matched */ _handleAutoCompleteModeList() { const that = this; if (that.autoComplete === 'list' && !that._buttonClicked) { if (that.opened && that._isDropDownClicked) { return false; } that.$.autoCompleteString.textContent = ''; if (that._lastSelectedItem) { if (!that._lastSelectedItem.selected) { that.select(that._lastSelectedItem); } } else { if (that.$.input.value.length && that._oldValue) { const foundItems = that.$.listBox._queryItems(that._oldValue, that.incrementalSearchMode); for (let i = 0; i < foundItems.length; i++) { if (!foundItems[i].hidden) { if (!foundItems[i].selected) { that.select(foundItems[i]); } that._focus(foundItems[i]); break; } } that.value = that.$.input.value = that._oldValue; } else { that.value = that.$.input.value = ''; } } } } /** * Input change event handler * @param {any} event */ _inputChangeEventHandler(event) { const that = this; event.stopPropagation(); if (that._preventInputChangeEvent) { delete that._preventInputChangeEvent; return; } if (that._isDropDownClicked || that._oldValue === that.$.input.value) { return; } that.$.fireEvent('change', { 'oldValue': that._oldValue, 'value': that.$.input.value, 'addedItems': [], 'removedItems': [], 'selected': [], 'disabled': [], 'index': [], 'label': [], }); } /** * ComboBox keydown event handler. */ _keyDownHandler(event) { const that = this, target = that.enableShadowDOM ? event.composedPath()[0] : event.target; if (that.disabled || that.readonly || target === that.$.listBox.$.filterInput) { return; } const focusedItem = typeof that._focusedItem === 'function' ? that._focusedItem() : that._focusedItem; switch (event.key) { case 'Enter': delete that._preventInputChangeEvent; if (target === that.$.input && focusedItem && that.opened) { if (focusedItem.selected && that.autoComplete === 'list') { that.close(); that._unfocus(); that._handleAutoCompleteModeList(); return; } if (!focusedItem.disabled) { that.select(focusedItem); that._preventInputChangeEvent = true; } if (!that.$dropDownContainer.hasClass('lw-visibility-hidden') && that.selectionMode.indexOf('one') > -1) { that.close(); that._unfocus(); } } else if (target === that.$.dropDownButton) { that.$.dropDownButton.setAttribute('active', ''); that.$dropDownContainer.hasClass('lw-visibility-hidden') && that.dropDownOpenMode !== 'none' ? that.open() : that.close(); that.$.input.focus(); } else { that.close(); } //Same behavior as on blur that._handleAutoCompleteModeList(); return; case 'Escape': switch (that.escKeyMode) { case 'none': //Closes the drop down poppup if (!that.$dropDownContainer.hasClass('lw-visibility-hidden')) { that.close(); that._unfocus(); } break; case 'clearValue': that.value = that.$.input.value = ''; that.close(); break; case 'previousValue': that.$.input.value = that._oldValue; break; case 'firstPossibleValue': { const firstPossibleItem = that.$.listBox._items.find(item => !item.disabled && !item.hidden && !item.readonly); if (firstPossibleItem) { const newValue = firstPossibleItem[that.inputMember]; if (that.$.input.value === newValue) { that.close(); } that.$.input.value = newValue; } that.close(); break; } } break; case 'End': case 'Home': case 'PageUp': case 'PageDown': case 'ArrowUp': case 'ArrowDown': if (that._autoOpenOnKeyDown(event) === true) { return; } if (event.altKey) { that._closedFromKeyCombination = true; if (that.$dropDownContainer.hasClass('lw-visibility-hidden') && that.dropDownOpenMode !== 'none') { if (event.key === 'ArrowDown') { that.open(); } if (!that.opened) { return; } if (that.items.length === 0) { return; } if (that.selectedIndexes.length === 0) { that._focus(that.items[0]) } else if (that.selectedIndexes.length > 0 && !that.$.listBox._items[that.selectedIndexes[that.selectedIndexes.length - 1]].hidden) { that._focus(that.items[that.selectedIndexes[that.selectedIndexes.length - 1]]); } } else { that.close(); } return; } if (target === that.$.input && that.$dropDownContainer.hasClass('lw-visibility-hidden')) { if (event.ctrlKey) { event.preventDefault(); that._handleKeyStroke(event.key); } return; } if (((event.key === 'PageUp' || event.key === 'PageDown') && !focusedItem) || target === that.$.listBox.$.filterInput) { return; } event.preventDefault(); if (!focusedItem || (focusedItem && !focusedItem._focused)) { that._focus(that.items[0]); return; } that._handleKeyStroke(event.key); //Update the autoComplete if it's manual if (that.autoComplete === 'inline' || that.autoComplete === 'list') { that._updateAutoCompleteHelper(); } break; case 'Backspace': if (that.$.input.previousElementSibling) { if (that.$.input.value.length === 0) { if (that.selectedIndexes.length === 1 && ['zeroOrMany', 'zeroOrOne', 'checkBox'].indexOf(that.selectionMode) < 0) { return; } const itemToBeRemoved = that.$.listBox.getItem(that.$.input.previousElementSibling._value); if (itemToBeRemoved) { that.unselect(itemToBeRemoved); } else if (that.$.selectionField.firstElementChild && that.$.selectionField.firstElementChild.nodeName === 'SPAN') { that.$.selectionField.removeChild(that.$.selectionField.firstElementChild) } } return; } if (that.selectedIndexes.length > 1) { that.clearSelection(true); } break; default: if (target === that.$.input && that.selectionMode === 'oneOrManyExtended') { that.$.listBox._keysPressed[event.key] = true; } if (that._autoOpenOnKeyDown(event) === true) { return; } } } /** * Handles keyboard keys * @param {any} key */ _handleKeyStroke(key) { const that = this, listBox = that.$.listBox; if (that.autoComplete === 'none') { listBox._handleKeyStrokes(key); return; } const items = that.items; switch (key) { case 'ArrowLeft': case 'ArrowUp': that._handleArrowKeys(true); break; case 'ArrowRight': case 'ArrowDown': that._handleArrowKeys(false); break; case 'Home': case 'End': { if (items.length === 0) { return; } const isHomeKeyPressed = key === 'Home'; that._focus(isHomeKeyPressed ? items[0] : items[items.length - 1]); listBox.scrollTop = isHomeKeyPressed ? 0 : listBox.scrollHeight; break; } case 'PageUp': { that._pageUpKeyHandler(items); break; } case 'PageDown': { that._pageDownKeyHandler(items); break; } } listBox._recycle(); } /** * Handles the Arrow keys only for autoComplete modes * @param {any} isArrowUp */ _handleArrowKeys(isArrowUp) { const that = this, listBox = that.$.listBox; let focusedItemIndex; if (that._focusedItem) { focusedItemIndex = that.$.listBox._indexOf(that._focusedItem); that._focusedItem._focused = false; } else if (that.selectedIndexes.length !== 0) { focusedItemIndex = that.selectedIndexes[that.selectedIndexes.length - 1] } else { return; } const focusedItem = isArrowUp ? listBox._getPreviousItem(focusedItemIndex) : listBox._getNextItem(focusedItemIndex); that._focus(focusedItem); if (that.autoComplete === 'list' && listBox._items[focusedItemIndex] !== focusedItem) { that._keyboardNavigation = true; listBox.clearSelection(); listBox.select(focusedItem); delete that._keyboardNavigation; } that.ensureVisible(focusedItem); } /** * Page Down key handler. */ _pageDownKeyHandler(items) { const that = this, listBox = that.$.listBox; let selectedItem = listBox._items[that.selectedIndexes[that.selectedIndexes.length - 1]]; if (listBox._focusedItem) { selectedItem = listBox._focusedItem; } let item; const selectedItemIndex = listBox._indexOf(selectedItem); let viewTop = selectedItem.top + listBox.$.itemsContainer.offsetHeight - selectedItem.height; for (let i = selectedItemIndex; i < items.length; i++) { if (items[i].top >= viewTop) { item = items[i]; break; } } if (!item) { item = items[items.length - 1]; } that._focus(item); if (item.height + item.top > listBox.$.itemsContainer.scrollTop + listBox.$.itemsContainer.offsetHeight || item.top < listBox.$.itemsContainer.scrollTop) { listBox.scrollTop = item.top - listBox.$.itemsContainer.offsetHeight + item.height; } } /** * Page Up key handler. */ _pageUpKeyHandler(items) { const that = this, listBox = that.$.listBox; let selectedItem = listBox._items[that.selectedIndexes[that.selectedIndexes.length - 1]]; if (listBox._focusedItem) { selectedItem = listBox._focusedItem; } const viewTop = selectedItem.top - listBox.$.itemsContainer.offsetHeight; const selectedItemIndex = listBox._indexOf(selectedItem); let item; for (let i = selectedItemIndex; i > 0; i--) { if (items[i].top <= viewTop) { item = items[i]; break; } } if (!item) { item = items[0]; } listBox._focus(item); listBox.scrollTop = item.top; if (listBox._indexOf(item) === 0) { listBox.scrollTop = 0; } } /** * Handles auto opening on specific key down * @param {any} event */ _autoOpenOnKeyDown(event) { const that = this; if (that.opened || (!that.opened && that.autoOpenShortcutKey.indexOf(event.key) < 0)) { return; } if (that.selectedIndexes.length) { that._focus(that.items[that.selectedIndexes[that.selectedIndexes.length - 1]]); } const focusedItem = typeof that._focusedItem === 'function' ? that._focusedItem() : that._focusedItem; that.open(); if (!focusedItem || (focusedItem && !focusedItem._focused)) { if (event.key === 'ArrowDown') { that._focus(that.items[0]); } else if (event.key === 'ArrowUp') { that._focus(that.items[that.items.length - 1]); } that.ensureVisible(that._focusedItem); } return true; } /** * ComboBox key up event handler. */ _keyUpHandler(event) { const that = this, target = that.enableShadowDOM ? event.composedPath()[0] : event.target; if (that.disabled || (that.escKeyMode === 'none' && event.key === 'Escape') || target === that.$.listBox.$.filterInput) { return; } delete that._preventInputChangeEvent; if (target === that.$.input && that.selectionMode === 'oneOrManyExtended') { that.$.listBox._keysPressed[event.key] = false; } if (['one', 'radioButton', 'zeroOrOne'].indexOf(that.selectionMode) > -1 && that.selectedIndexes.length === 1 && that.$.input.value !== (that._currentSelection ? that._currentSelection[0] : undefined)) { that._preventInputChangeEvent = true; that.unselect(that.$.listBox._items[that.selectedIndexes[0]]); } if (event.key === 'Enter') { that.$.dropDownButton.removeAttribute('active'); return; } if (target === that.$.input && event.key.indexOf('Arrow') < 0 && ['Control', 'Shift'].indexOf(event.key) < 0) { if (that.value === that.$.input.value) { return; } if (that._currentSelection) { that.value = that._currentSelection.toString() + (that._currentSelection.length > 0 ? ',' : '') + that.$.input.value; } else { that.value = that.$.input.value; } that.$.autoCompleteString.textContent = ''; if (that._closedFromKeyCombination) { that._closedFromKeyCombination = false; return; } //that._unfocus(); if (that.autoComplete !== 'none' && that.autoComplete !== 'list') { if (that.$.input.value !== (that._currentSelection ? that._currentSelection.toString() : undefined) || (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length !== that.$.listBox._items.length)) { if (that._autoCompleteTimer) { clearTimeout(that._autoCompleteTimer); } that._autoCompleteTimer = setTimeout(function () { that._autoComplete(true); }, that.autoCompleteDelay); } } else { if (that.$.input.value.length > 0) { that._queryItems(); } if (that._focusedItem && !(event.key === 'Escape' && that.escKeyMode === 'firstPossibleValue')) { that.open(); if (event.key !== ' ') { that.$.listBox._scrollView.scrollTop = that._focusedItem.offsetTop; } } } if ((that.autoComplete !== 'none' && that.autoComplete !== 'list') && that.$.listBox._filteredItems && that.$.listBox._filteredItems.length === that.$.listBox._items.length) { that.close(); return; } } } /** * Checks if input's value matches an item from the listBox */ _queryItems(selectItem) { const that = this; if (!that.value || !that.$.input) { that.close(); return; } let foundItems = that.$.listBox._queryItems(that.$.input.previousElementSibling ? that.$.input.value : that.value, that.incrementalSearchMode); if (foundItems.length === 0) { that._unfocus(); } for (let i = 0; i < foundItems.length; i++) { if (!foundItems[i].hidden) { if (selectItem && !foundItems[i].selected) { that.select(foundItems[i]); } that._focus(foundItems[i]); break; } } if (that.autoComplete === 'list' && (that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement) === that.$.input && that.$.input.value.length >= that.minLength) { that._lastSelectedItem = that._focusedItem; that._updateAutoCompleteHelper(); } else { that._lastSelectedItem = undefined; } } /** * Document select start event handler. */ _selectStartHandler(event) { const that = this; if (that._resizeDetails && that._resizeDetails.started) { event.preventDefault(); } } /** * Unfocuses the focused list item from the ComboBox. */ _unfocus() { const that = this; if (!that._focusedItem) { return; } that._focusedItem._focused = false; that.$.listBox._focusedItem = undefined; } /** * Sets WAI-ARIA relations. */ _setAriaRelations() { const that = this; that.setAttribute('role', 'combobox'); that.setAttribute('aria-describedby', that.$.hint.id); that.setAttribute('aria-expanded', that.opened); that.setAttribute('aria-haspopup', 'listbox'); that.setAttribute('aria-labelledby', that.$.label.id); that._ariaButton = that; that._setAriaAutocomplete(); } /** * Sets the WAI-ARIA property aria-autocomplete. */ _setAriaAutocomplete() { const that = this, autoComplete = that.autoComplete, input = that.$.input; if (autoComplete === 'none') { input.setAttribute('aria-autocomplete', 'none'); } else if (autoComplete === 'auto' || autoComplete === 'manual') { input.setAttribute('aria-autocomplete', 'list'); } else { input.setAttribute('aria-autocomplete', 'both'); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * DropDownButton custom element. */ LW('lw-drop-down-button', class DropDownButton extends LW.ContentElement { /** * DropDownButton's properties */ static get properties() { return { 'autoCloseDelay': { value: 100, type: 'number' }, 'dropDownAppendTo': { value: null, type: 'any' }, 'dropDownButtonPosition': { allowedValues: ['none', 'left', 'right', 'top', 'bottom'], value: 'right', type: 'string' }, 'dropDownHeight': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownMaxHeight': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownMaxWidth': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownMinHeight': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownMinWidth': { value: '', type: 'any', validator: '_propertyValidator' }, 'dropDownOpenMode': { allowedValues: ['none', 'default', 'dropDownButton', 'auto'], value: 'default', type: 'string' }, 'dropDownOverlay': { value: false, type: 'boolean' }, 'dropDownPlaceholder': { value: 'No Items', type: 'string' }, 'dropDownPosition': { allowedValues: ['auto', 'top', 'bottom', 'overlay-top', 'overlay-center', 'overlay-bottom', 'center-bottom', 'center-top'], value: 'auto', type: 'string' }, 'dropDownWidth': { value: '', type: 'any', validator: '_propertyValidator' }, 'hint': { value: '', type: 'string' }, 'horizontalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] }, 'label': { value: '', type: 'string' }, 'messages': { extend: true, value: { 'en': { 'invalidNode': 'lw-drop-down-button: Invalid parameter "{{node}}" when calling {{method}}.' } }, type: 'object' }, 'name': { value: '', type: 'string' }, 'opened': { value: false, type: 'boolean' }, 'placeholder': { value: '', type: 'string' }, 'resizeIndicator': { value: false, type: 'boolean' }, 'resizeMode': { value: 'none', allowedValues: ['none', 'horizontal', 'vertical', 'both'], type: 'string' }, 'verticalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] } } } /** * DropDownButton's event listeners. */ static get listeners() { return { 'actionButton.down': '_buttonsDownHandler', 'actionButton.mouseenter': '_buttonsMouseEventsHandler', 'actionButton.mouseleave': '_buttonsMouseEventsHandler', 'document.selectstart': '_selectStartHandler', 'document.dragstart': '_dragStartHandler', 'document.down': '_documentDownHandler', 'document.up': '_documentUpHandler', 'document.move': '_documentMoveHandler', 'dropDownButton.down': '_buttonsDownHandler', 'dropDownButton.mouseenter': '_buttonsMouseEventsHandler', 'dropDownButton.mouseleave': '_buttonsMouseEventsHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler', 'focus': '_focusEventHandler', 'blur': '_blurEventHandler', 'dropDownContainer.transitionend': '_dropDownTransitionendHandler', 'mouseenter': '_mouseEnterHandler', 'mouseleave': '_mouseLeaveHandler', 'resize': '_resizeHandler', 'resizeBar.move': '_resizeBarMoveHandler', 'styleChanged': '_styleChangedHandler' }; } /** * DropDownButton's HTML template. */ template() { return `<div id="container" role="presentation"> <span class="lw-label" id="label">[[label]]</span> <div id="content" class="lw-content" role="presentation"> <div id="buttonsContainer" class="lw-buttons-container" role="presentation"> <span id="actionButton" class="lw-action-button">[[placeholder]]</span> <span id="dropDownButton" class="lw-drop-down-button"> <span class="lw-drop-down-button-icon" id="arrow" aria-hidden="true"></span> </span> </div> <div id="dropDownContainer" class="lw-drop-down lw-drop-down-container lw-visibility-hidden" role="dialog"> <lw-scroll-viewer id="scrollViewer" right-to-left="[[rightToLeft]]" horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]" vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]"> <content></content> </lw-scroll-viewer> <div id="resizeBar" class="lw-drop-down-resize-bar" aria-label="Resize"> <div></div> </div> </div> </div> <span class="lw-hidden lw-hint" id="hint">[[hint]]</span> </div>`; } /* * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.scrollviewer.css', 'lw.dropdown.css', 'lw.dropdownbutton.css' ] } /** * Called when the element is attached from the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted || !that.$.dropDownContainer) { return; } that._positionDetection.dropDownAttached('_setDropDownSize'); that._positionDetection.checkBrowserBounds(); } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); if (!that.$.dropDownContainer) { return; } that.close(); that._positionDetection.dropDownDetached(); } /** * Updates the DropDownButton when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'dropDownAppendTo': that._positionDetection.dropDownAppendToChangedHandler(); break; case 'dropDownHeight': case 'dropDownMaxHeight': case 'dropDownMaxWidth': case 'dropDownMinHeight': case 'dropDownMinWidth': case 'dropDownWidth': that._setDropDownSize(); break; case 'dropDownOpenMode': that._setFocusable(); that.close(); that._setAriaRelations(); break; case 'dropDownOverlay': if (!newValue) { that._positionDetection.removeOverlay(); } break; case 'dropDownPlaceholder': if (that.$.dropDownContainer.hasAttribute('empty')) { that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = newValue; if (that.opened) { that.$.scrollViewer.refresh(); } } break; case 'dropDownPosition': that._positionDetection.dropDownPositionChangedHandler(); break; case 'innerHTML': // It is necessary to apply the new HTML directly to scrollViewerContentContainer due to a conflict in innerHTML binding of scrollViewer (removed) if (newValue.trim() === '') { that.$.dropDownContainer.setAttribute('empty', ''); requestAnimationFrame(() => that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = that.dropDownPlaceholder); } else { that.$.dropDownContainer.removeAttribute('empty'); that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = newValue; } if (that.opened) { that.$.scrollViewer.refresh(); } break; case 'opened': if (newValue) { that.open(); } else { that.close(); } break; case 'placeholder': if (oldValue === '' || newValue === '') { that._setFocusable(); } break; case 'resizeIndicator': if (newValue) { that.$.dropDownContainer.setAttribute('resize-indicator', ''); } else { that.$.dropDownContainer.removeAttribute('resize-indicator'); } break; case 'resizeMode': that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode); if (that.opened) { that.$.scrollViewer.refresh(); } break; case 'label': if (newValue) { that._ariaButton.setAttribute('aria-labelledby', that.$.label.id); } else if (that.elementName === 'DropDownButton') { that._ariaButton.setAttribute('aria-labelledby', that.$.actionButton.id); } break; } } /** * Appends html nodes fo the element * @param {any} node - HTML element to be appended */ appendChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { method: 'removeChild', node: 'node' })); return; } that.$.scrollViewer.appendChild(node); if (that.opened) { that.$.scrollViewer.refresh(); } } /** * Removes content from the element * @param {any} node - node to be removed */ removeChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { method: 'removeChild', node: 'node' })); return } if (!that.$.dropDownContainer.contains(node)) { return; } that.$.scrollViewer.removeChild(node); if (that.opened) { that.$.scrollViewer.refresh(); } } /** * Removes the content completely */ removeAll() { const that = this; if (that.isCompleted) { that.$.scrollViewer.removeAll(); } } _open() { const that = this; if (that.disabled || !that.offsetHeight) { return; } if (!that.$dropDownContainer.hasClass('lw-visibility-hidden')) { return; } if (that.$dropDownContainer.hasClass('not-in-view')) { that.$dropDownContainer.removeClass('not-in-view'); } that.$.dropDownContainer.style.transition = null; if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) { const rect = that.getBoundingClientRect(); // handles the case, when the dropdown is opened, while it is still part of the DropDownButton's tree. if (that.$.container.contains(that.$.dropDownContainer)) { let iterations = 0; const interval = setInterval(function () { const rect = that.getBoundingClientRect(); iterations++; if (rect.top === that._positionTop && iterations < 10) { return; } that.open(); clearInterval(interval); that._positionTop = rect.top; }, 100); return; } else if (rect.top !== that._positionTop) { that._positionTop = rect.top; } } const isOpeningEventPrevented = that.$.fireEvent('opening').defaultPrevented; if (isOpeningEventPrevented) { return; } that.opened = true; that._ariaButton.setAttribute('aria-expanded', true); that._positionDetection.placeOverlay(); that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds('horizontally'); that.$dropDownContainer.removeClass('lw-visibility-hidden'); that.$.fireEvent('open'); if (that.$.dropDownButton) { if (that.dropDownOpenMode === 'dropDownButton') { that.$.dropDownButton.setAttribute('selected', ''); } else { that.$.dropDownButton.removeAttribute('selected'); } } if (that.$.input) { that.$.input.focus(); } } /** * Opens the drop down container */ open() { const that = this, //NOTE: Will not close other DropDown's on page ! For example, DropDownList, DateTimePickers, etc ... dropDownsInDOM = document.querySelectorAll('lw-drop-down-button, lw-color-picker'); //Make sure all dropDownButton popups are closed before openning this one for (let i = 0; i < dropDownsInDOM.length; i++) { if (dropDownsInDOM[i] !== that && dropDownsInDOM[i].opened) { dropDownsInDOM[i].close(); } } that._open(); that.$.scrollViewer.refresh(); } /** * Scrolls to a position * @param {any} top - Y coordinate * @param {any} left - X coordinate */ scrollTo(top, left) { const that = this; if (!that.isCompleted) { return; } that.$.scrollViewer.scrollTo(top, left); } ready() { super.ready(); } render() { const that = this; if (that.rightToLeft) { that.dropDownButtonPosition = that.dropDownButtonPosition === 'right' ? 'left' : 'right'; } that.classList.add('lw-drop-down-box'); that._edgeMacFF = LW.Utilities.Core.Browser.Edge || LW.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1; that._positionDetection = new LW.Utilities.PositionDetection(that, that.$.dropDownContainer, that.$.container, 'close'); that._positionDetection.getDropDownParent(true); that._positionDetection.setDropDownPosition(); that._calculateDropDownSize(); that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode); if (that.resizeIndicator) { that.$.dropDownContainer.setAttribute('resize-indicator', ''); } that._positionDetection.handleAutoPositioning(); if (that.$.label && !that.$.label.id) { that.$.label.id = that.id + 'Label'; } if (that.$.actionButton && !that.$.actionButton.id) { that.$.actionButton.id = that.id + 'ActionButton'; } if (that.$.hint && !that.$.hint.id) { that.$.hint.id = that.id + 'Hint'; } if (!that.hint) { that.hint = that.placeholder; } that._createElement(); if (that.opened) { that.open(); } else if (that.hasAnimation && that._edgeMacFF) { that.$dropDownContainer.addClass('not-in-view'); } //Used for the scroll handling that._positionTop = that.getBoundingClientRect().top; super.render(); } /** * Sets WAI-ARIA relations. */ _setAriaRelations(initialization) { const that = this; let oldButton, newButton; if (that.dropDownOpenMode !== 'dropDownButton') { oldButton = that.$.dropDownButton; oldButton.setAttribute('aria-hidden', true); newButton = that; that.$.actionButton.removeAttribute('role'); } else { oldButton = that; newButton = that.$.dropDownButton; newButton.removeAttribute('aria-hidden'); that.$.actionButton.setAttribute('role', 'button'); } that._ariaButton = newButton; newButton.setAttribute('role', 'button'); newButton.setAttribute('aria-haspopup', 'dialog'); newButton.setAttribute('aria-owns', that.$.dropDownContainer.id); newButton.setAttribute('aria-describedby', that.$.hint.id); if (that.label) { newButton.setAttribute('aria-labelledby', that.$.label.id); } else if (that.elementName === 'DropDownButton') { newButton.setAttribute('aria-labelledby', that.$.actionButton.id); } oldButton.setAttribute('role', 'presentation'); oldButton.removeAttribute('aria-owns'); if (initialization) { newButton.setAttribute('aria-expanded', that.opened); } else { oldButton.removeAttribute('aria-describedby'); oldButton.removeAttribute('aria-expanded'); oldButton.removeAttribute('aria-haspopup'); oldButton.removeAttribute('aria-labelledby'); } } _setDropDownSize() { const that = this; if (!that._dropDownSize) { that._calculateDropDownSize(); } ['dropDownMinWidth', 'dropDownMinHeight', 'dropDownMaxWidth', 'dropDownMaxHeight'].forEach((name) => { that.$.dropDownContainer.style[name.replace('dropDown', '').replace(/^./, 'm')] = that[name] ? that[name] + (that[name].toString().endsWith('%') ? '%' : 'px') : null; }); if (that.dropDownWidth) { if (that.dropDownWidth !== 'auto') { that.$.dropDownContainer.style.width = (that.dropDownWidth === 'initial' ? that.offsetWidth : parseFloat(that.dropDownWidth)) + 'px'; } else { that.$.dropDownContainer.style.width = 'auto'; } } else { that.$.dropDownContainer.style.width = that._dropDownSize.width === 'auto' ? 'auto' : (parseFloat(that._dropDownSize.width) || 0) + 'px'; } if (that.dropDownHeight && that.dropDownHeight !== 'auto') { that.$.dropDownContainer.style.height = parseFloat(that.dropDownHeight) + ((that.dropDownHeight + '').indexOf('%') > -1 ? '%' : 'px'); } else { that.$.dropDownContainer.style.height = that._dropDownSize.height; } } // /** //* Sets tab index //*/ // _setFocusable() { // const that = this; // if (that.disabled || that.unfocusable) { // that.removeAttribute('tabindex'); // that.$.actionButton.removeAttribute('tabindex'); // that.$.dropDownButton.removeAttribute('tabindex'); // return; // } // let index = that.tabIndex > 0 ? that.tabIndex : 0; // that.$.actionButton.removeAttribute('tabindex'); // that.$.dropDownButton.removeAttribute('tabindex'); // that.tabIndex = index; // } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); that.$.actionButton.removeAttribute('tabindex'); that.$.dropDownButton.removeAttribute('tabindex'); return; } let index = that.tabIndex > 0 ? that.tabIndex : 0; if (that.dropDownOpenMode === 'dropDownButton') { that.removeAttribute('tabindex'); that.$.actionButton.setAttribute('tabindex', index); that.$.dropDownButton.setAttribute('tabindex', index); } else { that.$.actionButton.removeAttribute('tabindex'); that.$.dropDownButton.removeAttribute('tabindex'); that.tabIndex = index; } } _calculateDropDownSize() { const that = this; that._dropDownSize = {}; const computedStyle = window.getComputedStyle(that.$.dropDownContainer); const topBorder = parseFloat(computedStyle.getPropertyValue('border-top-width').trim()), bottomBorder = parseFloat(computedStyle.getPropertyValue('border-bottom-width').trim()), topMargin = parseFloat(computedStyle.getPropertyValue('margin-top').trim()), bottomMargin = parseFloat(computedStyle.getPropertyValue('margin-bottom').trim()), topPaddinng = parseFloat(computedStyle.getPropertyValue('padding-top').trim()), bottomPaddinng = parseFloat(computedStyle.getPropertyValue('padding-bottom').trim()); if (LW.Utilities.Core.CSSVariablesSupport()) { that._dropDownSize.width = computedStyle.getPropertyValue('--lw-drop-down-list-drop-down-width').trim(); that._dropDownSize.height = computedStyle.getPropertyValue('--lw-drop-down-list-drop-down-height').trim(); } if (!that._dropDownSize.width || that._dropDownSize.width.indexOf('initial') > -1) { that._dropDownSize.width = that.offsetWidth; } if (!that._dropDownSize.height) { that._dropDownSize.height = 'auto'; } that._dropDownSize.minHeight = parseFloat(computedStyle.getPropertyValue('min-height').trim()); that._dropDownSize.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height').trim()); that._dropDownSize.borderWidth = (isNaN(topBorder) ? 0 : topBorder) + (isNaN(bottomBorder) ? 0 : bottomBorder); that._dropDownSize.paddingWidth = (isNaN(topPaddinng) ? 0 : topPaddinng) + (isNaN(bottomPaddinng) ? 0 : bottomPaddinng); that._dropDownSize.marginWidth = (isNaN(topMargin) ? 0 : topMargin) + (isNaN(bottomMargin) ? 0 : bottomMargin); } /** * Initialization method. Called inside ready method */ _createElement() { const that = this; if (that.innerHTML.trim() === '') { that.$.dropDownContainer.setAttribute('empty', ''); that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = that.dropDownPlaceholder; } that._setDropDownSize(); that._setFocusable(); that._setAriaRelations(true); //Flag indicator for the ripple effect. Used to append the ripple to that specific element, not his firstElementChild like it's done usually. //Used in class Ripple, method animate() in lwelement. that.$.arrow.noRipple = true; } /** * DragStarted Event Handler * @param {any} event */ _dragStartHandler(event) { const that = this; if (that._resizeDetails && that._resizeDetails.started) { event.preventDefault(); } } /** * Dropdown transitionend handler. */ _dropDownTransitionendHandler() { const that = this; if (that._edgeMacFF && !that.opened && that.hasAnimation) { that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = ''; that.$dropDownContainer.addClass('not-in-view'); } } /** * Element/DropDownButton blur event handler * @param {any} event */ _blurEventHandler() { const that = this; if (that.hasAttribute('focus')) { if (that.$.dropDownButton) { that.removeAttribute('focus'); that.$.dropDownButton.removeAttribute('focus'); } if (that.$.actionButton) { that.removeAttribute('focus'); that.$.actionButton.removeAttribute('focus'); } that.$.fireEvent('blur'); } } /** * Element focus event handler */ _focusEventHandler() { const that = this; if (!that.hasAttribute('focus')) { if (that.$.dropDownButton) { that.setAttribute('focus', ''); that.$.dropDownButton.setAttribute('focus', ''); } if (that.$.actionButton) { that.setAttribute('focus', ''); that.$.actionButton.setAttribute('focus', ''); } that.$.fireEvent('focus'); } } /** * Gets the target of a document up event. */ _getUpEventTarget(originalTarget) { const that = this; let target = originalTarget; if (target === that.$.dropDownContainer) { return 'dropDownContainer'; } target = target.parentElement === undefined ? target.getRootNode().host : target.parentElement; while (target) { if (target === that.$.dropDownContainer) { target = 'dropDownContainer'; break; } target = target.parentElement === undefined ? target.getRootNode().host : target.parentElement; } return target; } /** * Hides the drop down list. */ close() { const that = this; if (that.$dropDownContainer.hasClass('lw-visibility-hidden')) { return; } const isClosingEventPrevented = that.$.fireEvent('closing').defaultPrevented; if (isClosingEventPrevented) { return; } that.$dropDownContainer.addClass('lw-visibility-hidden'); that.$.fireEvent('close'); if (that.$.dropDownButton) { that.$.dropDownButton.removeAttribute('selected'); } that.opened = false; that._ariaButton.setAttribute('aria-expanded', false); that._preventDropDownClose = false; that._positionDetection.removeOverlay(true); if (that._edgeMacFF && !that.hasAnimation) { that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = ''; that.$dropDownContainer.addClass('not-in-view'); } } /** * DocumentUp event handler * @param {any} event */ _documentUpHandler(event) { const that = this, isResizing = that.hasAttribute('resizing'); that.$.actionButton.removeAttribute('active'); if (that._resizeDetails && that._resizeDetails.started) { that._resizeDetails.started = that._resizeDetails.resizeEventFired = false; that.removeAttribute('resizing'); that._preventDropDownClose = false; that.focus(); that.$.fireEvent('resizeEnd', { 'position': { left: event.pageX, top: event.pageY } }); return; } if (that.disabled || that._isDropDownClicked || that.readonly) { delete that._isDropDownClicked; return; } if (that._overlayDown) { that.close(); delete that._overlayDown; return; } let target = event.originalEvent.target; if (that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; } that._preventsSelectStart = false; if (typeof (target) === 'undefined' || target === that.$.resizeBar) { return; } const isActionButtonPressed = target.closest('.lw-action-button'); let openDropDown; if (that._buttonClicked) { if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed && that._buttonClicked === that.$.actionButton) { that.$.fireEvent('actionButtonClick'); } else if (target.closest('.lw-drop-down-button') === that._buttonClicked || isActionButtonPressed === that._buttonClicked) { openDropDown = true; that.$.fireEvent('dropDownButtonClick'); } } that._buttonClicked = undefined; if ((!that.editable && isActionButtonPressed === that.$.actionButton) || target.closest('.lw-drop-down-button') === that.$.dropDownButton) { if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed === that.$.actionButton) { that.close(); return; } //Open/Close the DropDownButton that.$dropDownContainer.hasClass('lw-visibility-hidden') && that.dropDownOpenMode !== 'none' && openDropDown && event.originalEvent.type !== 'pointercancel' ? that.open() : that.close(); return; } target = that._getUpEventTarget(target); if (target === undefined) { return; } if (target !== 'dropDownContainer' && target !== 'item' || target === 'item' && that.selectionMode !== 'checkBox' && that.selectionMode.indexOf('Many') < 0) { that.close(); } if (isResizing && that.$.scrollViewer) { that.$.scrollViewer.refresh(); } } /** * Key down handler * @param {any} event */ _keyDownHandler(event) { const that = this, activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement; if (that.disabled || that.readonly || (activeElement !== that && activeElement !== that.$.dropDownButton && activeElement !== that.$.actionButton)) { return; } switch (event.key) { case 'Enter': case ' ': event.preventDefault(); if (event.target !== that.$.actionButton) { if (that.opened && event.key === 'Enter') { that.close(); } else if (!that.opened && !that.readonly && that.dropDownOpenMode !== 'none') { that.open(); } } if (that.dropDOwnOpenMode === 'dropDownButton') { event.target.setAttribute('active', ''); } break; case 'End': that.$.scrollViewer.scrollTop = that.$.scrollViewer.scrollHeight; break; case 'Home': that.$.scrollViewer.scrollTop = 0; break; case 'PageUp': case 'PageDown': that.$.scrollViewer.scrollTop += (event.key.indexOf('Down') > -1 ? 1 : -1) * that.$.dropDownContainer.offsetHeight; break; case 'ArrowUp': case 'ArrowDown': if (event.altKey) { if (!that.disabled && !that.readonly && that.dropDownOpenMode !== 'none') { that.$dropDownContainer.hasClass('lw-visibility-hidden') ? that.open() : that.close(); } return; } event.preventDefault(); that.$.scrollViewer.scrollTop += (event.key.indexOf('Down') > -1 ? 1 : -1) * 10; break; case 'Escape': event.preventDefault(); that.close(); break; } } /** * DropDown key up event handler. */ _keyUpHandler(event) { const that = this, target = that.isInShadowDOM ? event.composedPath()[0] : event.target; if (event.key === 'Enter' || event.key === ' ') { target.removeAttribute('active'); } } /** * Validates the value of the property * @param {any} oldValue - the old value * @param {any} value - the new value */ _propertyValidator(oldValue, newValue) { if (typeof newValue !== 'number' && typeof newValue !== 'string') { return oldValue; } return newValue; } /** * Element container mouse enter event handler. */ _mouseEnterHandler() { const that = this; that._isElementHovered = true; if (that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) { that.open(); } } /** * Element container mouse leave event handler. */ _mouseLeaveHandler() { const that = this; that.removeAttribute('hover'); that._isElementHovered = false; if (that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) { that._autoClose() } } /** * Automatically closes the dropdown. */ _autoClose() { const that = this; that._autoCloseTimeout = setTimeout(function () { if (!that._isElementHovered) { that.close(); } clearTimeout(that._autoCloseTimeout); }.bind(that), that.autoCloseDelay); } /** * Document Move Event handler * @param {any} event */ _documentMoveHandler(event) { const that = this, target = that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.dropDownOpenMode === 'auto' && that.dropDownAppendTo !== null) { if (that.contains(target) || that.$.dropDownContainer.contains(target)) { that._isElementHovered = true; } else { that._isElementHovered = false; that._autoClose(); } } if (!that._resizeDetails || (that._resizeDetails && !that._resizeDetails.started)) { return; } that.setAttribute('resizing', ''); if (!that._resizeDetails.resizeEventFired) { that.$.fireEvent('resizeStart', { 'position': { left: event.pageX, top: event.pageY } }); that._resizeDetails.resizeEventFired = true; } const doc = document.documentElement, computedStyle = that.$.dropDownContainer.getBoundingClientRect(), dropDownStyle = that.getBoundingClientRect(), direction = that.$.dropDownContainer.hasAttribute('top') ? 'top' : 'bottom'; let size; function verticalResize() { size = event.pageY - that._resizeDetails.y; if (direction === 'bottom') { //6 is the margin of document.body, we don't want scrollbars to be shown that._resizeDetails.height = Math.min(doc.clientHeight - computedStyle.top - 6, Math.max(0, that._resizeDetails.height + size)); that._resizeDetails.y = Math.max(computedStyle.top + doc.scrollTop - that._resizeDetails.offsetY, Math.min(doc.clientHeight + doc.scrollTop - that._resizeDetails.offsetY * 1.5, event.pageY)); } else { that._resizeDetails.height = Math.min(that._dropDownSize.maxHeight, Math.max(0, Math.min(dropDownStyle.top, that._resizeDetails.height - size))); size = Math.max(0, computedStyle.top + (computedStyle.height - Math.max(that._dropDownSize.minHeight, that._resizeDetails.height))); if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) { const margin = Math.abs(parseFloat(getComputedStyle(that.$.dropDownContainer).getPropertyValue('margin-bottom'))) || 0; that.$.dropDownContainer.style.top = that.dropDownAppendTo && that.dropDownAppendTo.length > 0 ? (margin + size) + 'px' : ''; } const minYCondition = dropDownStyle.top + doc.scrollTop + that._resizeDetails.offsetYtop; that._resizeDetails.y = Math.max(that._resizeDetails.offsetYtop, Math.min(minYCondition, Math.max(minYCondition - that._dropDownSize.maxHeight, event.pageY))); } that.$.dropDownContainer.style.height = that._resizeDetails.height + 'px'; } function horizontalResize() { //Resize only from corner //if (that._resizeDetails.offsetXR > 20) { // return; //} size = event.pageX - that._resizeDetails.x; //6 is the margin of document.body, we don't want scrollbars to be shown that._resizeDetails.width = Math.min(doc.clientWidth - computedStyle.left - 6, Math.max(0, that._resizeDetails.width + size)); that.$.dropDownContainer.style.width = that._resizeDetails.width + 'px'; that._resizeDetails.x = Math.max(computedStyle.left + doc.scrollLeft - that._resizeDetails.offsetXR, Math.min(doc.clientWidth + doc.scrollLeft - that._resizeDetails.offsetXR * 1.5, event.pageX)); } switch (that.resizeMode) { case 'vertical': verticalResize(); break; case 'horizontal': horizontalResize(); break; case 'both': horizontalResize(); verticalResize(); break; } } /** * Document mouse down event handler. */ _documentDownHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } let target = event.originalEvent.target; if (target === that._overlay) { that._overlayDown = true; } if (that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; let rootElement = target; while (rootElement) { if (rootElement.closest('.lw-drop-down-container') === that.$.dropDownContainer) { that._isDropDownClicked = true; break; } rootElement = rootElement.getRootNode().host; } } else { that._isDropDownClicked = target.closest('.lw-drop-down-container') === that.$.dropDownContainer; } that._buttonClicked = target.closest('.lw-action-button') || target.closest('.lw-drop-down-button'); if (that._isDropDownClicked) { that._preventDropDownClose = true; } if (target !== that.$.resizeBar || that.resizeMode === 'none') { return; } if (!that._resizeDetails) { that._resizeDetails = {}; } const computedStyle = that.$.dropDownContainer.getBoundingClientRect(); that._resizeDetails.started = true; that._resizeDetails.x = event.pageX; that._resizeDetails.y = event.pageY; that._resizeDetails.width = that.$.dropDownContainer.offsetWidth; that._resizeDetails.height = that.$.dropDownContainer.offsetHeight; that._resizeDetails.offsetXL = event.clientX - computedStyle.left; that._resizeDetails.offsetXR = computedStyle.left + that.$.dropDownContainer.offsetWidth - event.clientX; that._resizeDetails.offsetY = computedStyle.top + that.$.dropDownContainer.offsetHeight - event.clientY; that._resizeDetails.offsetYtop = event.clientY - computedStyle.top; that._preventDropDownClose = true; } /** * Resize handler - recalculate the size of the popup if the element is initialized with a different size. */ _resizeHandler() { const that = this; if (that.resizeMode === 'none') { that._calculateDropDownSize(); that._setDropDownSize(); } } /** * Resizebar mousemouve event handler. * @param {any} event */ _resizeBarMoveHandler(event) { //Used to prevent page scrolling on iOS devices if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * Style changed event handler * @param {any} event */ _styleChangedHandler(event) { const that = this; if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) { const styleProperties = event.detail.styleProperties, fontProperties = ['font-size', 'font-family', 'font-style', 'font-weight']; for (let s = 0; s < fontProperties.length; s++) { if (styleProperties[fontProperties[s]]) { that.$.dropDownContainer.style[fontProperties[s]] = styleProperties[fontProperties[s]].value; } } } if (that._dropDownSize && that._dropDownSize.height === 'auto') { that._setDropDownSize(); } } /** * Action/DropDown button mouse down event handler. */ _buttonsDownHandler(event) { const that = this; if (that.disabled) { return; } if (that.hasRippleAnimation) { if (that.dropDownOpenMode === 'dropDownButton') { LW.Utilities.Animation.Ripple.animate(event.target, event.pageX, event.pageY); } else if (event.target === that.$.dropDownButton || !that.editable) { const target = that.$.buttonsContainer; target.firstElementChild.noRipple = true; LW.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY); target.firstElementChild.noRipple = false; } } that._preventsSelectStart = true; if (that.dropDownOpenMode === 'dropDownButton' && event.target === that.$.actionButton && that.tagName.toLowerCase() === 'lw-drop-down-button') { that.$.actionButton.setAttribute('active', ''); } //Used to handle closing after blur event is thrown if (that.opened) { that._preventDropDownClose = true; } } /** * DropDownList container mouse enter/leave events handler. */ _buttonsMouseEventsHandler(event) { const that = this; if (that.disabled) { return; } if (event.type === 'mouseenter') { that.setAttribute('hover', ''); event.target.setAttribute('hover', ''); } else { that.removeAttribute('hover'); event.target.removeAttribute('hover'); } } /** * Document select start event handler. */ _selectStartHandler(event) { if (this._preventsSelectStart) { event.preventDefault(); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Multi Split Button custom element. */ LW('lw-multi-split-button', class MultiSplitButton extends LW.DropDownList { //Multi Split Button's properties. static get properties() { return { 'buttonsDataSource': { value: [], type: 'array' }, 'dropDownOpenMode': { allowedValues: ['none', 'dropDownButton', 'auto'], value: 'dropDownButton', type: 'string' } }; } template() { return `<div id="container" role="presentation"> <span class="lw-label" id="label">[[label]]</span> <div id="content" class="lw-content" role="presentation"> <div id="actionButton" class ="lw-input lw-action-button" role="presentation"> <template> <div class="lw-multi-split-button-buttons" *items={{buttonsDataSource}} role="presentation"><span class="lw-action-split-button" inner-H-T-M-L={{item}} role="button"></span></div> </template> </div> <span id="dropDownButton" class="lw-drop-down-button" role="button" aria-label="Toggle popup"> <span class ="lw-drop-down-button-icon" id="arrow" aria-hidden="true"></span> </span> <div id="dropDownContainer" class="lw-drop-down lw-drop-down-container lw-visibility-hidden" role="presentation"> <lw-list-box id="listBox" unfocusable animation="[[animation]]" data-source="[[dataSource]]" disabled="[[disabled]]" display-loading-indicator="[[displayLoadingIndicator]]" display-member="[[displayMember]]" filterable="[[filterable]]" filter-mode="[[filterMode]]" filter-input-placeholder="[[filterInputPlaceholder]]" grouped="[[grouped]]" group-member="[[groupMember]]" item-height="[[itemHeight]]" item-template="[[itemTemplate]]" incremental-search-delay="[[incrementalSearchDelay]]" incremental-search-mode="[[incrementalSearchMode]]" loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]" loading-indicator-position="[[loadingIndicatorPosition]]" name="[[name]]" placeholder="[[dropDownPlaceholder]]" readonly="[[readonly]]" right-to-left="[[rightToLeft]]" selected-indexes="{{selectedIndexes}}" selection-mode="[[selectionMode]]" selected-values="{{selectedValues}}" sorted="[[sorted]]" theme="[[theme]]" value-member="[[valueMember]]" horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]" vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]" virtualized="[[virtualized]]"> <content></content> </lw-list-box> <div id="resizeBar" class="lw-drop-down-resize-bar" aria-label="Resize"> <div></div> </div> </div> </div> <span class="lw-hint" id="hint">[[hint]]</span> </div>`; } static get listeners() { return { 'actionButton.down': '_buttonsDownHandler', 'actionButton.mouseenter': '_buttonsMouseEventsHandler', 'actionButton.move': '_buttonsMouseEventsHandler', 'actionButton.mouseleave': '_buttonsMouseEventsHandler', 'dropDownButton.mouseenter': '_dropDownButtonMouseEventsHandler', 'dropDownButton.mouseleave': '_dropDownButtonMouseEventsHandler', 'actionButton.focus': '_focusEventHandler', 'actionButton.blur': '_blurEventHandler', 'dropDownButton.focus': '_focusEventHandler', 'dropDownButton.blur': '_blurEventHandler' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.dropdown.css', 'lw.multisplitbutton.css' ] } /** * ActionButton / DropDownButton Blur event handler */ _blurEventHandler() { const that = this; that.removeAttribute('focus'); if (!that._preventDropDownClose) { that.close(); } } /** * ActionButton / DropDownButton Focus event handler */ _focusEventHandler() { this.setAttribute('focus', ''); } _documentUpHandler(event) { const that = this; super._documentUpHandler(event); const splitButtons = (that.shadowRoot || that).querySelectorAll('.lw-action-split-button'); for (let i = 0; i < splitButtons.length; i++) { const splitButton = splitButtons[i]; splitButton.removeAttribute('active'); } that.removeAttribute('active'); } _dropDownButtonMouseEventsHandler(event) { const that = this; if (event.type === 'mouseleave') { that.$.dropDownButton.removeAttribute('hover'); that.removeAttribute('hover'); } else { that.$.dropDownButton.setAttribute('hover', ''); that.setAttribute('hover', ''); } } _buttonsDownHandler(event) { const that = this; const splitButtons = (that.shadowRoot || that).querySelectorAll('.lw-action-split-button'); for (let i = 0; i < splitButtons.length; i++) { const splitButton = splitButtons[i]; const rect = splitButton.getBoundingClientRect(); if (event.type !== 'mouseleave') { that.setAttribute('active', ''); splitButtons[i].removeAttribute('active'); if (rect.left <= event.pageX && event.pageX <= rect.width + rect.left) { splitButtons[i].setAttribute('active', ''); that.$.fireEvent('buttonClick', { 'index': i, 'label': that.buttonsDataSource[i] }); } } else { splitButtons[i].removeAttribute('active'); that.removeAttribute('active', ''); } } } _buttonsMouseEventsHandler(event) { const that = this; const splitButtons = (that.shadowRoot || that).querySelectorAll('.lw-action-split-button'); for (let i = 0; i < splitButtons.length; i++) { const splitButton = splitButtons[i]; const rect = splitButton.getBoundingClientRect(); if (event.type !== 'mouseleave') { that.setAttribute('hover', ''); splitButtons[i].removeAttribute('hover'); if (rect.left <= event.pageX && event.pageX <= rect.width + rect.left) { splitButtons[i].setAttribute('hover', ''); } } else { splitButtons[i].removeAttribute('hover'); that.removeAttribute('hover', ''); } } } _applySelection() { const that = this; if (that.buttonsDataSource.length === 0) { if (that.selectionDisplayMode === 'placeholder' || that.selectedIndexes.length === 0) { (that.shadowRoot || that).querySelector('.lw-template-container').innerHTML = that.placeholder; return; } if (!that.$.listBox._items || that.$.listBox._items.length === 0) { return; } (that.shadowRoot || that).querySelector('.lw-template-container').innerHTML = '<div class="lw-multi-split-button-buttons"><span class="lw-action-split-button"></span></div>'; that.$.actionButton.querySelector('.lw-action-split-button').appendChild(that._createToken()); } } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (propertyName === 'dataSource' || propertyName === 'displayMember') { //Check the new listBox size that._setDropDownSize(); that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds('horizontally'); } else { super.propertyChangedHandler(propertyName, oldValue, newValue); } } /** * Sets WAI-ARIA relations. */ _setAriaRelations() { const that = this; that.setAttribute('role', 'group'); that.setAttribute('aria-describedby', that.$.hint.id); that.setAttribute('aria-labelledby', that.$.label.id); that.getElementsByClassName('lw-template-container')[0].setAttribute('role', 'presentation'); const dropDownButton = that._ariaButton = that.$.dropDownButton; dropDownButton.setAttribute('aria-haspopup', 'listbox'); dropDownButton.setAttribute('aria-expanded', that.opened); dropDownButton.setAttribute('aria-owns', that.$.listBox.id); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * TextBox custom element. */ LW('lw-text-box', class TextBox extends LW.ComboBox { /** * TextBox's properties */ static get properties() { return { 'autoFocus': { value: false, type: 'boolean' }, 'autoComplete': { allowedValues: ['none', 'manual', 'auto', 'inline'], type: 'string', value: 'manual' }, 'displayMode': { value: 'default', allowedValues: ['default', 'escaped'], type: 'string' }, 'dropDownOpenMode': { allowedValues: ['none', 'default', 'auto'], value: 'default', type: 'string' }, 'enterKeyBehavior': { value: 'submit', allowedValues: ['submit', 'clearOnSubmit'], type: 'string' }, 'form': { value: '', type: 'string' }, 'hint': { value: null, type: 'any' }, 'maxLength': { value: null, type: 'number?' }, 'minLength': { value: 2, type: 'number' }, 'messages': { extend: true, value: { 'en': { 'missingReference': '{{elementType}}: Missing reference to {{files}}.' } }, type: 'object' }, 'required': { value: false, type: 'boolean' }, 'requiredMessage': { value: '', type: 'string' }, 'selectAllOnFocus': { value: false, type: 'boolean' }, 'selectionMode': { value: 'zeroOrOne', allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'], type: 'string' }, 'type': { value: 'input', type: 'string', defaultReflectToAttribute: true, readonly: true }, 'value': { value: '', type: 'string' } } } /** * TextBox's event listeners. */ static get listeners() { return { 'document.up': '_documentUpHandler', 'focus': '_focusHandler', 'keydown': '_keyDownHandler', 'mouseenter': '_mouseEventsHandler', 'mouseleave': '_mouseEventsHandler', 'input.blur': '_focusHandler', 'input.change': '_textBoxChangeHandler', 'input.focus': '_focusHandler', 'input.keyup': '_textBoxKeyUpHandler', 'input.paste': '_textBoxChangeHandler', 'input.select': '_textBoxSelectHandler', 'listBox.bindingComplete': '_bindingCompleteHandler' } } /** * TextBox's HTML template. */ template() { return `<div id="container" role="presentation"> <span id="label" inner-h-t-m-l="[[label]]" class="lw-label"></span> <div id="content" class="lw-content" role="presentation"> <input class="lw-input" type="text" id="input" disabled="[[disabled]]" maxlength="[[maxLength]]" name="[[name]]" placeholder="[[placeholder]]" readonly="[[readonly]]" role="textbox" aria-label="[[placeholder]]" autocomplete="[[inputPurpose]]"> <div id="autoCompleteString"></div> <div id="dropDownContainer" class="lw-drop-down lw-drop-down-container lw-visibility-hidden" role="presentation"> <lw-list-box id="listBox" data-source="[[dataSource]]" unfocusable="true" disabled="[[disabled]]" display-loading-indicator="[[displayLoadingIndicator]]" display-member="[[displayMember]]" item-height="[[itemHeight]]" item-template="[[itemTemplate]]" item-measure-mode="[[itemMeasureMode]]" filter-callback="[[filterCallback]]" filter-mode="[[filterMode]]" loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]" loading-indicator-position="[[loadingIndicatorPosition]]" placeholder="[[dropDownPlaceholder]]" readonly="[[readonly]]" right-to-left="[[rightToLeft]]" selection-mode="[[selectionMode]]" value-member="[[valueMember]]"> <content></content> </lw-list-box> </div> </div> <span id="hint" class ="lw-hidden lw-hint"></span> </div>`; } /** * Updates the TextBox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'autoComplete': if (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length !== that.$.listBox._items.length) { super._autoComplete(true); } that._setAriaAutocomplete(); break; case 'dataSource': case 'valueMember': //when selectedValues is 0 and displayMember is changed set actionButton text to default. that._clearSelection(); //Check the new listBox size that._setDropDownSize(); that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds('horizontally'); //Issue: When changing dataSource from property, the items are not added right away so size isnt calculated properly. Needs a new event or sth... //that._setDropDownSize(); break; case 'displayMember': case 'inputMember': { const listBox = that.$.listBox; if (listBox.selectedIndexes.length) { const label = listBox._items[listBox.selectedIndexes[0]][that.inputMember]; that.$.listBox.$.filterInput.value = label; that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(label) : that._toDefaultDisplayMode(label); that.set('value', that._toDefaultDisplayMode(that.$.input.value)); } break; } case 'displayMode': that.$.input.value = newValue === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value = that._toDefaultDisplayMode(that.$.input.value); break; case 'dropDownOpenMode': that._setFocusable(); that.$dropDownContainer.addClass('lw-visibility-hidden'); that.opened = false; break; case 'value': if (that.$.input !== document.activeElement || (that.$.input === document.activeElement && that.$.input.value === that._oldValue)) { that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value; that._oldValue = oldValue; } if (!that.value) { that.clearSelection(); } newValue.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); break; case 'hint': if (newValue === null) { that.$.hint.innerHTML = ''; that.$.removeClass('invalid'); return; } that._handleHintContainer(); break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Checks for missing modules. */ static get requires() { return { 'LW.ComboBox': 'lw.combobox.js' } } /* * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.textbox.css' ] } /** * Opens the popup */ open() { const that = this; if ((that.$.listBox.items.length === 0 && typeof that.dataSource !== 'function') || that.autoComplete === 'none') { return; } if (that.$.input.value.length === 0 && (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length !== that.$.listBox._items.length)) { super._autoComplete(true); return; } super.open(); } /** * Closes the popup */ close() { const that = this; super.close(); that.$.autoCompleteString.textContent = ''; if (that.$.listBox._focusedItem) { that.$.listBox._focusedItem._focused = false; } if (that.autoComplete === 'none') { return; } if (that.$.input._filteredItems && that.$.input._filteredItems[0] && that.$.input._filteredItems[0] !== that.$.input.value) { super._autoComplete(true); } } /** * Creates a clone of the element. */ cloneNode() { const that = this; let clone = HTMLElement.prototype.cloneNode.apply(that, Array.prototype.slice.call(arguments, 0, 1)); if (that.$.listBox) { //Set only those properties that have reflectToAttribute set to false. clone.dataSource = that.dataSource; } return clone; } /** * Focus method */ focus() { this.$.input.focus(); } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.$.input.tabIndex = -1; return; } that.$.input.removeAttribute('tabindex'); } /** * Reset Method. Reset to the initialization value */ reset() { const that = this; if (that.displayMode === 'escaped') { that.value = that._initializationValue; that.$.input.value = that._toEscapedDisplayMode(that._initializationValue); } else { that.$.input.value = that.value = that._initializationValue; } if (!that.value && that.$.listBox) { that.clearSelection(); } } /** * BindingComplete event Handler. When the dataSource or size of listBox is changed. */ _bindingCompleteHandler() { const that = this; if (!that.$.listBox) { return; } if (that.isRendered) { that._setDropDownSize(); that._positionDetection.checkBrowserBounds(); } } /** * TextBox create method. */ _createElement() { const that = this; that._browserIsIEorEdge = LW.Utilities.Core.Browser.IE || LW.Utilities.Core.Browser.Edge; if (that.autoFocus) { that.$.input.focus(); } if (that.value) { that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value; } that._setDropDownSize(); that._handleSelectedText(); that._setFocusable(); that._initializationValue = that._oldValue = that.value; that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); that._handleHintContainer(); that._setAriaRelations(); } /** * Focus handler. Selects whole text in element's text area on selectAllOnFocus: true */ _focusHandler(event) { const that = this; if (event.type === 'blur') { if (that._isDropDownClicked) { return; } that.removeAttribute('focus'); that.$.autoCompleteString.textContent = ''; that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); if ((that.autoComplete === 'auto' || that.autoComplete === 'inline') && that.$.input.value.length > 0 && that.$.listBox._focusedItem && that.$.listBox._focusedItem._focused) { const newValue = that.$.listBox._focusedItem[that.inputMember]; that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(newValue) : that._toDefaultDisplayMode(newValue); that.set('value', that._toDefaultDisplayMode(newValue)); } if (!that._preventDropDownClose) { that.close(); } if (that._oldValue !== that.value) { that.$.fireEvent('change', { 'oldValue': that._oldValue, 'value': that.value }); } that.$.fireEvent('blur'); return; } if (that.disabled) { return; } that.setAttribute('focus', ''); that._oldValue = that.value; if (that.selectAllOnFocus) { that.$.input.select(); } if (false === that._canFireFocus) { return; } that._canFireFocus = false; that.$.fireEvent('focus'); that._canFireFocus = true; } /** * TextBox container mouse enter/leave events handler. */ _handlePointerInEscapedSymbol(direction) { const that = this; if (that.displayMode !== 'escaped') { return; } let selectionStart = that.$.input.selectionStart, selectionEnd = that.$.input.selectionEnd, value = that.$.input.value; if (value[selectionStart - 1] !== '\\') { return; } if (!value[selectionStart].match(/n|r|s|t|f/g)) { return; } if (selectionStart === selectionEnd) { let pointerPositionModifier = direction === 'next' ? 1 : -1; that.$.input.selectionStart = selectionStart + pointerPositionModifier; that.$.input.selectionEnd = selectionStart + pointerPositionModifier; return; } else { that.$.input.selectionStart = selectionStart - 1; } if (value[selectionEnd - 1] !== '\\') { return; } if (!value[selectionEnd].match(/n|r|s|t|f/g)) { return; } that.$.input.selectionEnd = selectionEnd + 1; } /** * Handles Text selection */ _handleSelectedText() { const that = this; if (that.selectionStart === null || that.selectionEnd === null || that.selectionStart === that.selectionEnd || that.selectAllOnFocus) { return; } that.selectionStart = that.selectionStart < 0 ? 0 : that.selectionStart; that.selectionEnd = that.selectionEnd > that.value.length ? that.value.length : that.selectionEnd; that.$.input.setSelectionRange(that.selectionStart, that.selectionEnd); } /** * Handles the Hint */ _handleHintContainer() { const that = this; if (!that.hint) { return; } const container = that.$.hint; if (typeof that.hint === 'function') { const value = that.value, invalid = that.hint(value, container); invalid ? that.$.addClass('invalid') : that.$.removeClass('invalid'); } else if (typeof that.hint === 'string') { container.innerHTML = that.hint; that.$.removeClass('invalid'); } } /** * keyDown event handler. */ _keyDownHandler(event) { const that = this; function replaceEscapedKeyWith(newValue) { let selectionStart = that.$.input.selectionStart, selectionEnd = that.$.input.selectionEnd, value = that.$.input.value; event.preventDefault(); value = value.substring(0, selectionStart) + newValue + value.substring(selectionEnd, value.length); that.value = that._toDefaultDisplayMode(value); that.$.input.value = value; that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart + 2; } that._showAutoCompleteHighlighter = false; switch (event.key) { case 'ArrowUp': case 'ArrowDown': if (event.altKey) { event.preventDefault(); if (event.key === 'ArrowDown') { that.open(); } else { that.close(); } return; } if (that.opened) { event.preventDefault(); that.$.listBox._handleKeyStrokes(event.key); if (that.autoComplete !== 'inline') { break; } that._showAutoCompleteHighlighter = true; super._updateAutoCompleteHelper(); } break; case 'PageUp': case 'PageDown': event.preventDefault(); that.$.input.selectionStart = that.$.input.selectionEnd = event.key === 'PageUp' ? 0 : that.$.input.value.length; break; case 'Enter': { const focusedItem = typeof that.$.listBox._focusedItem === 'function' ? that.$.listBox._focusedItem() : that.$.listBox._focusedItem; if (that.opened && focusedItem && focusedItem._focused) { that.$.listBox.$.filterInput.value = focusedItem[that.inputMember]; that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(focusedItem[that.inputMember]) : that._toDefaultDisplayMode(focusedItem[that.inputMember]); that.select(focusedItem); that.close(); } if (that.enterKeyBehavior !== 'default') { const value = that.$.input.value; if (that._oldValue !== value) { that.close(); that.$.fireEvent('change', { 'oldValue': that._oldValue, 'value': value, 'type': 'submit' }); if (that.enterKeyBehavior === 'clearOnSubmit') { if (LW.MaskedTextBox && (that instanceof LW.MaskedTextBox)) { that._cleanMask(); that._setMaskToInput(); that.$.input.selectionStart = that.$.input.selectionEnd = 0; } else { that.$.input.value = ''; } } that._oldValue = that.value = that._toDefaultDisplayMode(that.$.input.value); } that._submitted = true; } break; } case 'Escape': if (that.$.dropDownContainer) { that.close(); } that._closedFromKeyCombination = true; if (that.escKeyMode === 'none') { return; } switch (that.escKeyMode) { case 'none': break; case 'clearValue': that.value = that.$.input.value = ''; break; case 'previousValue': that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that._oldValue) : that._oldValue; break; } break; case ' ': if (that.displayMode === 'escaped') { replaceEscapedKeyWith('\\s'); } break; case 'Backspace': if (that.displayMode === 'escaped' && that.$.input.selectionStart === that.$.input.selectionEnd) { let carretPosition = that.$.input.selectionStart; if (that.$.input.value[carretPosition - 2] === '\\' && (that.$.input.value[carretPosition - 1] === 's' || that.$.input.value[carretPosition - 1] === 'n')) { that.$.input.value = that.$.input.value.substring(0, carretPosition - 2) + that.$.input.value.substring(carretPosition - 2, that.$.input.value.length); that.$.input.selectionStart = carretPosition - 2; } } break; } } /** * Pre-defined ComboBox keyUpHandler */ _keyUpHandler(event) { const that = this; if (that.disabled || event.key === 'Escape' || event.target === that.$.listBox.$.filterInput) { return; } if (event.target === that.$.input && that.selectionMode === 'oneOrManyExtended') { that.$.listBox._keysPressed[event.key] = false; } } /** * ListItem click event handler * @param {any} event */ _listBoxItemClickHandler(event) { const that = this, eventDetails = event.detail; super._listBoxItemClickHandler(event); if (eventDetails.selected) { if (that.displayMode === 'escaped') { const originalValue = that.$.input.value; that.value = that._toDefaultDisplayMode(originalValue); that.$.input.value = originalValue; } else { that.value = that.$.input.value; } if (that._oldValue !== that.value) { that.$.fireEvent('change', { 'oldValue': that._oldValue, 'value': that.value }); that.$.input.focus(); } } } _submitKeyUpHandler() { const that = this; if (that._submitted) { if (that.enterKeyBehavior === 'clearOnSubmit') { that.$.input.selectionStart = that.$.input.selectionEnd = 0; } that._submitted = false; } } /** * TextBox keyUp event handler. */ _textBoxKeyUpHandler(event) { const that = this; if (that.disabled || event.altKey || event.ctrlKey) { return; } if (that.displayMode === 'escaped') { const originalValue = that.$.input.value; that.value = that._toDefaultDisplayMode(that.$.input.value); that.$.input.value = originalValue; } else { that.value = that.$.input.value; } let selectedItem; if (that.$.listBox.selectedIndexes.length === 1) { selectedItem = that.$.listBox.getItem(that.$.listBox.selectedValues[0]); if (that.value !== selectedItem[that.inputMember]) { that.unselect(selectedItem); } } if (!that._showAutoCompleteHighlighter) { that.$.autoCompleteString.textContent = ''; } if (event.key === 'Alt' || event.key === 'Control' || (!that.opened && event.key === 'Escape') || event.key === 'Enter') { that._closedFromKeyCombination = false; return; } if (event.key && event.key.indexOf('Arrow') > -1) { that._handlePointerInEscapedSymbol(event.key === 'ArrowRight' ? 'next' : undefined); return; } if (that.autoComplete !== 'none' && (that.$.input.value.length > 0 || that.dropDownOpenMode === 'auto')) { const autoComplete = super._autoComplete.bind(that); if (that._autoCompleteTimer) { clearTimeout(that._autoCompleteTimer); } if (that.$.listBox._items.length === 0 && typeof that.dataSource !== 'function') { that.close(); return; } that._autoCompleteTimer = setTimeout(function () { autoComplete(true); }, that.autoCompleteDelay); } else { that.close(); } if (event.key === 'Enter' && that.value !== that.value && that._browserIsIEorEdge) { that.value = that.$.input.value; that.$.fireEvent('change', { 'oldValue': that._oldValue, 'value': that.value }); } } /** * ListBox drop down change event handler. */ _listBoxChangeHandler(event) { const that = this; //Stop listBox's change event. TextBox will throw it's own 'change' event event.stopPropagation(); if (event.detail.selected) { const selectedItem = that.$.listBox._items[event.detail.index]; let label = ''; if (selectedItem) { label = selectedItem[that.inputMember]; } that.$.listBox.$.filterInput.value = label; that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(label) : that._toDefaultDisplayMode(label); that.set('value', that._toDefaultDisplayMode(that.$.input.value)); } if (that.autoComplete !== 'none' && typeof that.dataSource !== 'function') { that._autoComplete(true); } } /** * TextBox container mouse enter/leave events handler. */ _mouseEventsHandler(event) { const that = this; event.type === 'mouseenter' ? that.setAttribute('hover', '') : that.removeAttribute('hover'); } /** * TextBox change handler. */ _textBoxChangeHandler(event) { const that = this; event.stopPropagation(); if (that.displayMode === 'escaped') { const originalValue = that.$.input.value, selectionStart = that.$.input.selectionStart, selectionEnd = that.$.input.selectionEnd, clipboardData = event.clipboardData || (event.originalEvent && event.originalEvent.clipboardData) || window.clipboardData; if (clipboardData) { let clipboardValue = clipboardData.getData('text'), value = that.$.input.value; event.preventDefault(); clipboardValue = that._toEscapedDisplayMode(clipboardValue); that.$.input.value = value.substring(0, selectionStart) + clipboardValue + value.substring(selectionEnd, value.length); } that.value = that._toDefaultDisplayMode(that.$.input.value); that.$.input.value = originalValue; } else { that.value = that.$.input.value; } that._handleHintContainer(); } /** * TextBox test select handler. */ _textBoxSelectHandler() { const that = this; if (that.disabled) { return; } that.selectionStart = that.$.input.selectionStart; that.selectionEnd = that.$.input.selectionEnd; } /** * Escapes special characters in the string. */ _toEscapedDisplayMode(str) { const keyValuePairs = [ { key: /\r\n|\n\r|\n|\r/g, value: '\\n' }, { key: /\s/g, value: '\\s' }, { key: /\n/g, value: '\\n' }, { key: /\t/g, value: '\\t' }, { key: /\f/g, value: '\\f' }, { key: /\r/g, value: '\\r' } /*{ key: /\\/g, value: '\\\\' }*/ ]; for (let i = 0; i < keyValuePairs.length; i++) { str = str.replace(keyValuePairs[i].key, keyValuePairs[i].value) } return str; } /** * Reverts escaped characters. */ _toDefaultDisplayMode(str) { if (!str) { str = ''; } const keyValuePairs = [ { key: /\\s/g, value: ' ' }, { key: /\\n/g, value: '\n' }, { key: /\\t/g, value: '\t' }, { key: /\\f/g, value: '\f' }, { key: /\\r/g, value: '\r' } /*{ key: /\\\\[^n{1}|^s{1}|^t{1}|^f{1}|^r{1}]/g, value: '\\' }*/ ]; for (let i = 0; i < keyValuePairs.length; i++) { str = str.replace(keyValuePairs[i].key, keyValuePairs[i].value) } return str; } /** * Document mouse down event handler. */ _documentDownHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } let target = event.originalEvent.target; if (that.enableShadowDOM) { target = event.originalEvent.composedPath()[0]; if (that._dropDownParent === null) { that._isDropDownClicked = target.closest('.lw-drop-down-container') === that.$.dropDownContainer; } else { let rootElement = target.getRootNode().host; if (rootElement && rootElement.closest('.lw-drop-down-container') === that.$.dropDownContainer) { that._isDropDownClicked = true; } } } else { that._isDropDownClicked = target.closest('.lw-drop-down-container') === that.$.dropDownContainer; } const listItem = event.originalEvent.target.closest('lw-list-item'); if (listItem || that._isDropDownClicked) { that._preventDropDownClose = true; } } /** * Predefines the method form the DropDownList Base Class **/ _documentMoveHandler() { } /** * Document Up event handler. */ _documentUpHandler(event) { const that = this; if (that.disabled) { return; } let target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (!target) { return; } if (that.displayMode === 'escaped' && target === that.$.input) { that._handlePointerInEscapedSymbol(); } if (that._isDropDownClicked || that.readonly) { delete that._isDropDownClicked; return; } if (target === that.$.input && that.dropDownOpenMode === 'auto') { super._autoComplete(true); return; } while (target) { if (target instanceof LW.ListItem && target.ownerListBox === that.$.listBox) { if (target.unselectable || target.disabled) { return; } if (that.displayMode === 'escaped') { that.$.input.value = that._toEscapedDisplayMode(target[that.inputMember]); } else { that.$.input.value = that._toDefaultDisplayMode(target[that.inputMember]); } that.value = that.$.input.value; that.$.fireEvent('change', { 'oldValue': that._oldValue, 'value': that.value, 'type': 'submit' }); that._oldValue = that.value; (that.enterKeyBehavior === 'clearOnSubmit') && (that.$.input.value = that.value = ''); super._autoComplete(true); that.close(); target = 'item'; that.$.input.focus(); return; } else if (target === that.$.listBox) { target = 'listBox'; return; } target = target.parentElement; } if (target !== 'listBox' && target !== 'item') { that.close(); return; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * MaskedTextBox custom element. */ LW('lw-masked-text-box', class MaskedTextBox extends LW.BaseElement { /** * MaskedTextBox's properties */ static get properties() { return { 'allowPromptAsInput': { value: false, type: 'boolean' }, 'asciiOnly': { value: false, type: 'boolean' }, 'autoFocus': { value: false, type: 'boolean' }, 'autoShowMask': { value: false, type: 'boolean' }, 'cutCopyMaskFormat': { value: 'excludePromptAndLiterals', allowedValues: ['excludePromptAndLiterals', 'includePrompt', 'includeLiterals', 'includePromptAndLiterals'], type: 'string' }, 'hidePromptOnLeave': { value: false, type: 'boolean' }, 'hint': { value: '', reflectToAttribute: true, type: 'string' }, 'isOverwriteMode': { value: false, type: 'boolean' }, 'label': { value: '', reflectToAttribute: true, type: 'string' }, 'mask': { value: '#####', type: 'string' }, 'maskCompleted': { value: false, type: 'boolean' }, 'maskFull': { value: false, type: 'boolean' }, 'maxLength': { value: null, type: 'number?' }, 'minLength': { value: 2, type: 'number' }, 'name': { value: '', type: 'string' }, 'placeholder': { value: '', type: 'string' }, 'promptChar': { value: '_', type: 'string' }, 'rejectInputOnFirstFailure': { value: false, type: 'boolean' }, 'resetOnPrompt': { value: false, type: 'boolean' }, 'resetOnSpace': { value: false, type: 'boolean' }, 'selectAllOnFocus': { value: false, type: 'boolean' }, 'textMaskFormat': { value: 'excludePromptAndLiterals', allowedValues: ['excludePromptAndLiterals', 'includePrompt', 'includeLiterals', 'includePromptAndLiterals'], type: 'string' }, 'validation': { value: null, type: 'function?', reflectToAttribute: false }, 'value': { value: null, reflectToAttribute: true, type: 'string?' } } } /** * MaskedTextBox's event listeners. */ static get listeners() { return { 'mouseenter': '_mouseEventsHandler', 'mouseleave': '_mouseEventsHandler', 'input.copy': '_cutCopyHandler', 'input.change': '_textBoxChangeHandler', 'input.cut': '_cutCopyHandler', 'input.paste': '_textBoxPasteHandler', 'input.keydown': '_textBoxKeyDownHandler', 'input.keyup': '_textBoxKeyUpHandler', 'input.blur': '_blurHandler', 'input.focus': '_focusHandler' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.textbox.css', 'lw.maskedtextbox.css' ] } /** * MaskedTextBox's HTML template. */ template() { return '<div id="container" role="presentation">' + '<span id="label" inner-h-t-m-l="[[label]]" class="lw-hidden lw-label"></span>' + `<input class="lw-input" type="text" id="input" autocomplete="off" autocorrect="off" autocapitalize="off" disabled="[[disabled]]" maxlength="[[maxLength]]" minlength="[[minLength]]" name="[[name]]" placeholder="[[placeholder]]" readonly="[[readonly]]" />` + '<span id="hint" inner-h-t-m-l="[[hint]]" class="lw-hidden lw-hint"></span>' + '</div>'; } /** * Updates the MaskedTextBox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { // super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; let maskValue; switch (propertyName) { case 'hidePromptOnLeave': if (newValue && !that._focused) { that._hidePrompt(); } else if (that._promptHidden) { that._showPrompt(); } break; case 'maxLength': if (that.mask.length > 0) { that.maxLength = oldValue; } break; case 'maskCompleted': case 'maskFull': that[propertyName] = oldValue; break; case 'promptChar': that._updatePromptChar(); break; case 'placeholder': if (that._isPlaceholderRequired()) { that.$.input.value = '' that.$.removeClass('has-value'); } else { that._updatePromptChar(); } that._updatePromptChar(); break; case 'mask': maskValue = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, 'excludePromptAndLiterals'); if (that._isPlaceholderRequired()) { that.$.input.value = '' that.$.removeClass('has-value'); } else { that._initializeMask(); that._setValueToMask(maskValue); that._setMaskToInput(); that.maxLength = that._mask.length; if (that._promptHidden) { that._hidePrompt(); } } break; case 'value': that._overwrite = true; that._setValueToMask(newValue); that._overwrite = false; that._setMaskToInput(); if (that._promptHidden) { that._hidePrompt(); } that._updateMaskFullAndCompleted(); break; case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'readonly': break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat); } render() { const that = this; that._createElement(); super.render(); } /** * Focus method */ focus() { this.$.input.focus(); } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.$.input.tabIndex = -1; return; } that.$.input.removeAttribute('tabindex'); } /** * MaskedTextBox create element method. */ _createElement() { const that = this; if (that.autoFocus) { that.$.input.focus(); } that.$.addClass('lw-input'); that._setFocusable(); that._initializeMask(); that._updateMaxLength(); if (that._isPlaceholderRequired()) { that.$.input.value = '' that.$.removeClass('has-value'); } else { that._setValueToMask(that.value) that._setMaskToInput(); that._updateMaskFullAndCompleted(); that.$.addClass('has-value'); } that.$.input.selectionStart = that.$.input.selectionEnd = 0; that._initializationValue = that._value = that.value; that._rejectInput = false; if (!that.$.label.id) { that.$.label.id = that.id + 'Label'; } if (!that.$.hint.id) { that.$.hint.id = that.id + 'Hint'; } if (!that.hint) { that.hint = that.placeholder; } that.setAttribute('role', 'presentation'); that.$.input.setAttribute('aria-describedby', that.$.hint.id); that.$.input.setAttribute('aria-labelledby', that.$.label.id); } /** * MaskedTextBox blur handler. */ _blurHandler() { const that = this, requiresPlaceholder = that._isPlaceholderRequired(); if (that.disabled) { return; } if (that._valueBeforeChange !== that.value) { that.$.fireEvent('change', { 'newValue': that.value, 'oldValue': that._valueBeforeChange }); that._valueBeforeChange = ''; } that._hidePrompt(); that._focused = false; that._validateMaskValue(); that.removeAttribute('focus'); that.$.input.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); if (requiresPlaceholder) { that.$.input.value = '' that.$.removeClass('has-value'); } that.$.fireEvent('blur'); } /* * Controlls maskFull and maskCompleted readonly properties */ _updateMaskFullAndCompleted() { const that = this; let maskFull = true, maskCompleted = true, hasRequiredChar = false; for (let i = 0; i < that._mask.length; i++) { const maskElement = that._mask[i]; if (maskElement.type === 'mask') { if (maskElement.required) { hasRequiredChar = true; } if (maskElement.character === '') { if (maskElement.required) { maskCompleted = false; } maskFull = false; } } } if (!maskFull && maskCompleted && !hasRequiredChar) { maskCompleted = false; } that.maskFull = maskFull; that.maskCompleted = maskCompleted; } _isPlaceholderRequired() { const that = this, hasValue = (that.value && that.value.length > 0), hasPlaceholder = (that.placeholder.length > 0), isRequired = !hasValue && (hasPlaceholder || that.autoShowMask); return isRequired; } /* * Updates mask items with new value, based on the mask settings */ _cleanMask(startsAt, endsAt) { const that = this; startsAt = startsAt ? startsAt : 0; endsAt = endsAt ? endsAt : that._mask.length; for (let i = startsAt; i < endsAt; i++) { let maskElement = that._mask[i]; if (maskElement.type === 'mask') { that._mask[i].character = ''; } } } /** * Updates the clipboard data on cut/copy. The format of the value depends on cutCopyMaskFormat - ['excludePromptAndLiterals', 'includePrompt', 'includeLiterals', 'includePromptAndLiterals'] */ _cutCopyHandler(event, type) { const that = this, selectionStart = parseInt(that.$.input.selectionStart, 10), selectionEnd = parseInt(that.$.input.selectionEnd, 10), selection = that._getValueWithTextMaskFormat({ start: selectionStart, end: selectionEnd }); if (window.clipboardData) { window.clipboardData.setData('text/plain', selection); window.clipboardData.setData('text/html', selection); } if (event) { that._preventDefault(event); } if (type === 'Copy') { return selection; } that._cleanMask(selectionStart, selectionEnd); that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat); that._setMaskToInput(); that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart; that.maskFull = that.maskCompleted = false; return selection; } _documentUpHandler() { } /** * Delete handler. Removes single character if selectionStart=selectionEnd or all selected chars aind replaces them with a mask fragment */ _deleteHandler(event) { const that = this, selectionStart = that.$.input.selectionStart, selectionEnd = that.$.input.selectionEnd, key = event.key; let newSelectionStart = selectionStart; that._preventDefault(event); if (selectionStart === selectionEnd) { if (key === 'Backspace') { for (let i = selectionStart; i > 0; i--) { const maskItem = that._mask[i - 1]; if (maskItem.type === 'mask') { newSelectionStart = i - 1; maskItem.character = ''; break; } else { newSelectionStart = selectionStart - 1; break; } } } else { for (let i = selectionStart; i < that._mask.length; i++) { const maskItem = that._mask[i]; if (maskItem.type === 'mask') { newSelectionStart = i + 1; maskItem.character = ''; break; } else { newSelectionStart = selectionStart + 1; break; } } } } else { that._cleanMask(selectionStart, selectionEnd); if (key === 'Delete') { newSelectionStart = selectionEnd; } } that._setMaskToInput(); that._updateMaskFullAndCompleted(); that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat); that.$.input.selectionStart = that.$.input.selectionEnd = newSelectionStart; } _findNextOccupiedPosition(start) { const that = this, maskLength = that._mask.length; let nextOccupiedPosition = start; for (let i = start; i < maskLength; i++) { let maskElement = that._mask[i]; if ((maskElement.type === 'mask') && (maskElement.character === '')) { nextOccupiedPosition++; } else { break; } } return nextOccupiedPosition; } /** * MaskedTextBox focus handler */ _focusHandler(event) { const that = this; if (event.context.nodeName.toUpperCase() !== 'INPUT') { that.$.input.focus(); return; } if (that.disabled) { return; } that.setAttribute('focus', ''); if (that.selectAllOnFocus) { that.$.input.select(); } that._showPrompt(); that._focused = true; if (that._isPlaceholderRequired()) { that._initializeMask(); that._setValueToMask(that.value); that._setMaskToInput(); const selectionStart = that._getEditableSelectionStart(0); that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart; } that.$.fireEvent('focus'); } /* * Combines mask elements into string and updates input's value */ _setMaskToInput() { const that = this; let mask = ''; for (let i = 0; i < that._mask.length; i++) { const maskElement = that._mask[i]; let newCharacter; if (maskElement.type === 'literal' || maskElement.type === 'separator' || maskElement.type === 'placeholder' || maskElement.type === 'currency') { newCharacter = maskElement.character; } else if (maskElement.type === 'mask' && maskElement.character !== '') { switch (maskElement.escapeSymbol) { case '>': newCharacter = maskElement.character.toUpperCase(); break; case '<': newCharacter = maskElement.character.toLowerCase(); break; case '|': newCharacter = maskElement.character; break; case '\\': newCharacter = maskElement.character; break; default: newCharacter = maskElement.character; break; } } else { newCharacter = maskElement.defaultCharacter; } mask = mask + newCharacter; } that.$.input.value = mask; } /** * Check if the entered character is format symbol */ _getEditableSelectionStart(selectionStart, key) { const that = this; for (let i = selectionStart; i < that._mask.length; i++) { const maskItem = that._mask[i]; if (maskItem.type !== 'mask') { continue; } if (maskItem.character !== '' && !that.isOverwriteMode && !(key === ' ' && that.resetOnSpace) && !(key === that.promptChar && that.resetOnPrompt)) { continue; } return i; } return -1; } _getNonEditableSelectionStart(selectionStart, key) { const that = this; for (let i = selectionStart; i < that._mask.length; i++) { const maskItem = that._mask[i]; if (maskItem.type === 'mask') { continue; } if (maskItem.character === key) { return i; } } return -1; } /** * Updates value in relation to the textMaskFormat */ _getValueWithTextMaskFormat(range, maskFormat) { const that = this, rangeStart = range ? range.start : 0, rangeEnd = range ? range.end : (that._mask.length || that.$.input.value.length); let value = ''; maskFormat = maskFormat ? maskFormat : that.cutCopyMaskFormat; if (maskFormat === 'includePromptAndLiterals') { return that.$.input.value.substring(rangeStart, rangeEnd); } for (let i = rangeStart; i < rangeEnd; i++) { const maskElement = that._mask[i]; switch (maskFormat) { case 'excludePromptAndLiterals': if (maskElement.type !== 'mask') { continue; } value = maskElement.character === '' ? (value + ' ') : (value + maskElement.character); break; case 'includePrompt': if (maskElement.type !== 'mask') { continue; } value = maskElement.character === '' ? (value + maskElement.defaultCharacter) : (value + maskElement.character); break; case 'includeLiterals': if (maskElement.type === 'mask' && maskElement.character === '') { continue; } value = value + maskElement.character; break; } } return value.trim(); } /** * Hides prompt characters on blur when promt is hidden on hidePromptOnLeave=true */ _hidePrompt() { const that = this, regex = new RegExp(that.promptChar, 'g'); if (that.disabled || !that.hidePromptOnLeave || that.mask.length === 0) { return; } that.$.input.value = that.$.input.value.replace(regex, ' '); that._promptHidden = true; } /** * Mask string is transformed to array of mask items */ _initializeMask() { const that = this; let maskLength = that.mask.length, escapeSymbol; that._mask = []; if (that.mask === undefined || that.mask === null || that.mask.length === 0) { return; } for (let i = 0; i < maskLength; i++) { const maskChar = that.mask.charAt(i); let maskElement = {}; maskElement.defaultCharacter = that.promptChar; switch (maskChar) { case '0': maskElement.editable = true; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; // types : mask, literal, placeholder, separator, currency maskElement.maskCharacter = '0'; maskElement.regex = '\\d'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '9': maskElement.editable = true; maskElement.required = false; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = '9'; maskElement.regex = '(\\d|\\s)'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '#': maskElement.editable = true; maskElement.required = false; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = '#'; maskElement.regex = '(\\d|\\s|[+]|[-])'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'L': maskElement.editable = true; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'L'; maskElement.regex = '([a-zA-Z--])'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '?': maskElement.editable = true; maskElement.required = false; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = '?'; maskElement.regex = '[a-zA-Z--]?'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '&': maskElement.editable = true; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = '&'; maskElement.regex = '[^\\s]'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'C': maskElement.editable = true; maskElement.required = false; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'C'; maskElement.regex = '.'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'A': maskElement.editable = true; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'A'; maskElement.regex = '[a-zA-Z--0-9]'; //'[a-zA-Z--0-9]' maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'a': maskElement.editable = true; maskElement.required = false; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'a'; maskElement.regex = '[a-zA-Z--0-9]?'; //'[a-zA-Z--0-9]' maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'Z': maskElement.editable = true; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'Z'; maskElement.regex = '[a-zA-Z0-9]'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'z': maskElement.editable = true; maskElement.required = false; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'z'; maskElement.regex = '[a-zA-Z0-9]?'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'Y': maskElement.editable = true; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'Y'; maskElement.regex = '[a-zA-Z]'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case 'y': maskElement.editable = true; maskElement.required = false; maskElement.escapeSymbol = escapeSymbol; maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; maskElement.maskCharacter = 'y'; maskElement.regex = '[a-zA-Z]?'; maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : ''; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '.': maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'placeholder'; maskElement.maskCharacter = '.'; maskElement.regex = null; maskElement.character = '.'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case ',': maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'placeholder'; maskElement.maskCharacter = ','; maskElement.regex = null; maskElement.character = ','; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case ':': maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'separator'; maskElement.maskCharacter = ':'; maskElement.regex = null; maskElement.character = ':'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '/': maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'separator'; maskElement.maskCharacter = '/'; maskElement.regex = null; maskElement.character = '/'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '$': maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'currency'; maskElement.maskCharacter = '$'; maskElement.regex = null; maskElement.character = '$'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; break; case '<': // escapeSymbol = escapeSymbol === '|' ? null : '<'; if (escapeSymbol) { if (escapeSymbol === '|') { escapeSymbol = null; } else if (escapeSymbol === '\\') { maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'literal'; maskElement.maskCharacter = '<'; maskElement.regex = '<'; maskElement.character = '<'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; } else { escapeSymbol = '<'; } } else { escapeSymbol = '<'; } break; case '>': //escapeSymbol = escapeSymbol === '|' ? null : '>'; if (escapeSymbol) { if (escapeSymbol === '|') { escapeSymbol = null; } else if (escapeSymbol === '\\') { maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'literal'; maskElement.maskCharacter = '>'; maskElement.regex = '>'; maskElement.character = '>'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; } else { escapeSymbol = '>'; } } else { escapeSymbol = '>'; } break; case '|': //escapeSymbol = '|'; if (escapeSymbol) { if (escapeSymbol === '\\') { maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'literal'; maskElement.maskCharacter = '|'; maskElement.regex = '|'; maskElement.character = '|'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; } else { escapeSymbol = '|'; } } else { escapeSymbol = '|'; } break; case '\\': //escapeSymbol = '\\'; if (escapeSymbol) { if (escapeSymbol === '\\') { maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'literal'; maskElement.maskCharacter = '\\'; maskElement.regex = '\\'; // Invalid regular expression: /\/: \ at end of pattern maskElement.character = '\\'; maskElement.defaultCharacter = that.promptChar; escapeSymbol = null; } else { escapeSymbol = '\\'; } } else { escapeSymbol = '\\'; } break; default: // literals maskElement.editable = false; maskElement.required = true; maskElement.escapeSymbol = escapeSymbol; maskElement.type = 'literal'; maskElement.maskCharacter = maskChar; maskElement.regex = null; maskElement.character = maskChar; maskElement.defaultCharacter = maskChar; escapeSymbol = null; break; } if (escapeSymbol) { continue; } if (maskElement.type) { that._mask.push(maskElement); } } } /** * Base keyDownHandler */ _keyDownHandler() { } /** * Check if the entered character is allowed symbol */ _validateInput(character, position) { const that = this, maskElement = that._mask[position], regEx = new RegExp(maskElement.regex); return regEx.test(character); } /* * Updates mask items with new value, based on the mask settings */ _setValueToMask(value, selection) { const that = this, newValue = value || '', valueLength = newValue.length; const selectionStart = selection && selection.start ? selection.start : 0; const selectionEnd = selection && selection.end ? selection.end : that._mask.length; let latestUpdatedPosition = selectionStart, latestValueChar = 0; while (latestUpdatedPosition < selectionEnd && latestValueChar < valueLength) { if (that._mask[latestUpdatedPosition].type === 'mask') { latestValueChar++; } if (that._setCharAtPosition(newValue.charAt(latestValueChar - 1), latestUpdatedPosition) || that._mask[latestUpdatedPosition].type !== 'mask') { latestUpdatedPosition++; } } if (latestUpdatedPosition < selectionEnd) { for (let i = latestUpdatedPosition; i < selectionEnd; i++) { if (that._mask[i].type === 'mask') { that._mask[i].character = ''; } } } if (selection) { selection.start = latestUpdatedPosition; } } /** * Combination of preventDefault and stopPropagation. Used in several places */ _preventDefault(event) { if (event.preventDefault) { event.preventDefault(); } if (event.stopPropagation) { event.stopPropagation(); } } /** * Shows prompt characters on focus when promt is hidden on hidePromptOnLeave=true */ _showPrompt() { const that = this; if (that.disabled || !that._promptHidden) { return; } that._setMaskToInput(); } /** * MaskedTextBox change handler */ _textBoxChangeHandler() { const that = this; if (that.disabled || that.readonly) { return; } that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat); if (that._valueBeforeChange !== that.value) { that.$.fireEvent('change', { 'newValue': that.value, 'oldValue': that._valueBeforeChange }); that._valueBeforeChange = ''; that._validateMaskValue(); } } /** * MaskedTextBox key down handler */ _textBoxKeyDownHandler(event) { const that = this, key = event.key, ctrlPressed = event.ctrlKey, //shiftPressed = event.shiftKey, ctrlHandledCodes = ['KeyA', 'KeyC', 'KeyV', 'KeyX'], selectionEnd = that.$.input.selectionEnd, asciiRegExpString = 'xxx[\x00-\x7F]+xxx', asciiRegExp = new RegExp(asciiRegExpString), allSupportedKeyboardCharacters = /^[a-zA-Z---0-9.!@?#"$%&:';()*\+,\/;\-=[\\\]\^_{|}<>~` ]+$/; let selectionStart = that.$.input.selectionStart; if (ctrlPressed && (ctrlHandledCodes.indexOf(event.code) > -1)) { const performClipboard = function (command, callback) { const textArea = document.createElement('textarea'); textArea.style.position = 'absolute'; textArea.style.left = '-1000px'; textArea.style.top = '-1000px'; document.body.appendChild(textArea); textArea.focus(); if (command === 'Paste') { setTimeout(function () { let value = textArea.value; if (value.length === 0 && window.clipboardData) { // pasteFrom.value = window.clipboardData.getData('Text'); textArea.value = window.clipboardData.getData('Text'); value = textArea.value; } textArea.parentNode.removeChild(textArea); that.$.input.focus(); callback(value); }, 25); } else { textArea.value = that._cutCopyHandler(null, command); textArea.focus(); textArea.setSelectionRange(0, textArea.value.length); setTimeout(function () { document.designMode = 'off'; textArea.focus(); textArea.parentNode.removeChild(textArea); that.$.input.focus(); }, 25); if (window.clipboardData) { window.clipboardData.setData('Text', textArea.value); } } }; switch (event.code) { case 'KeyA': that.$.input.setSelectionRange(0, that.$.input.value.length); break; case 'KeyC': performClipboard('Copy'); break; case 'KeyV': performClipboard('Paste', function (text) { const context = that.context; that.context = that; that._textBoxPasteHandler(null, text) that.context = context; }); break; case 'KeyX': performClipboard('Cut'); break; } return; } if (key === 'Backspace') { that._deleteHandler(event); that._updateMaskFullAndCompleted(); return; } if (key === 'Delete') { that._deleteHandler(event); that._updateMaskFullAndCompleted(); return; } if (!that.allowPromptAsInput && (key === that.promptChar)) { that._preventDefault(event); return; } if (that.disabled || that.readonly || (that.asciiOnly && !asciiRegExp.test(key)) || (!allSupportedKeyboardCharacters.test(key) || key.length > 1)) { return; } that._preventDefault(event); if (selectionStart === selectionEnd && selectionStart === that.$.input.value.length) { return; } if (key === ' ' && !that.resetOnSpace) { return; } selectionStart = that._getEditableSelectionStart(selectionStart, key); const nonEditableKeyHandler = function () { selectionStart = that._getNonEditableSelectionStart(that.$.input.selectionStart, key); if (selectionStart !== -1) { that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart + 1; } } if (selectionStart === -1) { nonEditableKeyHandler(); return; } const isChanged = that._setCharAtPosition(key, selectionStart); if (isChanged) { that._setMaskToInput(); that._updateMaskFullAndCompleted(); that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart + 1; } else { nonEditableKeyHandler(); } } /** * MaskedTextBox key up handler */ _textBoxKeyUpHandler() { const that = this; const value = that.value; that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat); if (value !== that.value) { that.$.fireEvent('change', { 'newValue': that.value, 'oldValue': value }); } } /** * MaskedTextBox paste handler */ _textBoxPasteHandler(event, value) { const that = this, textBoxValue = that.$.input.value, selectionStart = that.$.input.selectionStart; let newValue, selectionEnd = that.$.input.selectionEnd; if (event) { that._preventDefault(event); } if (window.clipboardData && window.clipboardData.getData) { newValue = window.clipboardData.getData('Text'); } else if (event && event.clipboardData && event.clipboardData.getData) { newValue = event.clipboardData.getData('text/plain'); } else if (value) { newValue = value; } if ((selectionEnd - selectionStart) !== textBoxValue.length) { if (selectionStart === selectionEnd) { that.$.input.selectionEnd = selectionEnd = that._mask.length; } if (that.rejectInputOnFirstFailure) { let latestTestedValueChar = 0; for (let i = selectionStart; i < selectionEnd; i++) { if (that._mask[i].type === 'mask') { if (!that._validateInput(newValue.charAt(latestTestedValueChar), i)) { that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart; return; } else { latestTestedValueChar++; } if (latestTestedValueChar > newValue.length) { break; } } } } const selection = { start: selectionStart, end: selectionEnd }; that._overwrite = true; that._setValueToMask(newValue, selection); that._setMaskToInput(); that._updateMaskFullAndCompleted(); that.$.input.selectionStart = that.$.input.selectionEnd = selection.start; that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat); } } /* * Updates custom mask item */ _setCharAtPosition(newChar, position) { const that = this, maskItem = that._mask[position]; if (newChar === ' ' && that.resetOnSpace) { newChar = ''; } if (maskItem.type !== 'mask' || that.readonly || that.disabled || !maskItem.editable) { return false; } if (newChar === '' && !that.resetOnSpace) { return false; } if (newChar === that.promptChar && !that.resetOnPrompt && that.allowPromptAsInput) { return false; } if (!that.isOverwriteMode && newChar !== '' && newChar !== that.promptChar && maskItem.character !== '' && !that._overwrite) { return false; } const regex = maskItem.regex; if (regex) { let regExpr = new RegExp(regex, 'i'); if (regExpr.test(newChar)) { switch (maskItem.escapeSymbol) { case '>': newChar = newChar.toUpperCase(); break; case '<': newChar = newChar.toLowerCase(); break; } that._mask[position].character = newChar; return true; } else if (that.resetOnSpace && newChar === '') { that._mask[position].character = newChar; return true; } else if (that.resetOnPrompt && newChar === that.promptChar && that.allowPromptAsInput) { that._mask[position].character = ''; return true; } return false; } return false; } /** * Updates maxLength property and input's max length */ _updateMaxLength() { const that = this; if (that._mask.length > 0) { that.maxLength = that._mask.length; } } /* * Updates prompt char */ _updatePromptChar() { const that = this; for (let i = 0; i < that._mask.length; i++) { let maskElement = that._mask[i]; maskElement.defaultCharacter = that.promptChar; } that._setMaskToInput(); } /* * Validates the value according to the 'validation' property */ _validateMaskValue() { const that = this; if (that.readonly || that.disabled || !that.validation || typeof that.validation !== 'function') { return; } const value = that.value; const success = that.validation(value); if (!success) { that.setAttribute('error', ''); } else { that.removeAttribute('error'); } that.$.fireEvent('validation', { 'success': success }); } _keyUpHandler() { return; } _resizeHandler() { } _selectStartHandler() { } _mouseWheelHandler() { } _applySelection() { } _setDropDownSize() { } _styleChangedHandler() { } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * MultilineTextBox custom element. */ LW('lw-multiline-text-box', class MultilineTextBox extends LW.TextBox { /** * MultilineTextBox's properties */ static get properties() { return { 'autoCapitalize': { value: 'none', allowedValues: ['none', 'words', 'characters'], type: 'string' }, 'autoComplete': { value: 'off', allowedValues: ['on', 'off'], type: 'string' }, 'autoExpand': { value: false, type: 'boolean' }, 'cols': { value: 20, type: 'number?' }, 'enterKeyBehavior': { value: 'newLine', allowedValues: ['submit', 'clearOnSubmit', 'newLine'], type: 'string' }, 'horizontalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] }, 'minLength': { value: 0, type: 'number' }, 'resizable': { value: false, type: 'boolean' }, 'rows': { value: 5, type: 'number?' }, 'selectionDirection': { value: 'none', allowedValues: ['forward', 'backward', 'none'], type: 'string' }, 'selectionEnd': { value: 0, reflectToAttribute: false, type: 'number' }, 'selectionStart': { value: 0, reflectToAttribute: false, type: 'number' }, 'spellCheck': { value: false, type: 'boolean' }, 'type': { value: 'textarea', type: 'string', defaultReflectToAttribute: true, readonly: true }, 'verticalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] }, 'wrap': { value: 'soft', allowedValues: ['hard', 'soft', 'off'], type: 'string' } } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.textbox.css', 'lw.multilinetextbox.css' ] } /** * MultilineTextBox's event listeners. */ static get listeners() { return { 'document.mousemove': '_documentSelectionOutsideHandler', 'container.resize': '_handleScrollbarsDisplay', 'document.move': '_resizeMoveHandler', 'document.up': '_upHandler', 'focus': '_focusHandler', 'horizontalScrollBar.change': '_horizontalScrollbarHandler', 'keydown': '_keyDownHandler', 'mouseenter': '_mouseEventsHandler', 'mouseleave': '_mouseEventsHandler', 'resize': '_handleScrollbarsDisplay', 'resizeElement.down': '_resizeDownHandler', 'styleChanged': '_handleScrollbarsDisplay', 'input.change': '_textBoxChangeHandler', 'input.focus': '_focusHandler', 'input.blur': '_blurHandler', 'input.keydown': '_textBoxKeyDownHandler', 'input.keyup': '_keyUpHandler', 'input.paste': '_textBoxChangeHandler', 'input.select': '_textBoxSelectHandler', 'input.touchmove': '_inputTouchmoveHandler', 'input.touchstart': '_inputTouchstartHandler', 'wheel': '_mouseWheelHandler', 'verticalScrollBar.change': '_verticalScrollbarHandler' } } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (!that._scrollView) { that._scrollView = new LW.Utilities.Scroll(that.$.input, that.$.horizontalScrollBar, that.$.verticalScrollBar); } } detached() { const that = this; super.detached(); if (that._scrollView) { that._scrollView.unlisten(); delete that._scrollView; } } static get requires() { return { 'LW.ScrollBar': 'lw.scrollbar.js' } } /** * MultilineTextBox's HTML template. */ template() { return `<div id="container" role="presentation"> <span id="label" inner-h-t-m-l="[[label]]" class="lw-label"></span> <div id="innerContainer" class="lw-inner-container" role="presentation"> <textarea class="lw-input" id="input" autocapitalize="[[autoCapitalize]]" autocomplete="off" cols="[[cols]]" disabled="[[disabled]]" maxlength="[[maxLength]]" minlength="[[minLength]]" name="[[name]]" placeholder="[[placeholder]]" readonly="[[readonly]]" required="[[required]]" rows="[[rows]]" spellcheck="[[spellCheck]]" wrap="[[wrap]]" aria-label="[[placeholder]]" autocomplete="[[inputPurpose]]"></textarea> <lw-scroll-bar id="verticalScrollBar" right-to-left="[[rightToLeft]]" animation="[[animation]]" disabled="[[disabled]]" orientation="vertical"></lw-scroll-bar> <lw-scroll-bar id="horizontalScrollBar" right-to-left="[[rightToLeft]]" animation="[[animation]]" disabled="[[disabled]]"></lw-scroll-bar> <div id="resizeElement" class="lw-resize-element" aria-label="Resize"></div> <textarea id="textBoxHidden" class="lw-text-box-hidden" autocapitalize="[[autoCapitalize]]" autocomplete="off" cols="[[cols]]" disabled="[[disabled]]" inner-h-t-m-l="[[value]]" maxlength="[[maxLength]]" minlength="[[minLength]]" name="[[name]]" placeholder="[[placeholder]]" readonly="[[readonly]]" required="[[required]]" rows="[[rows]]" spellcheck="[[spellCheck]]" wrap="[[wrap]]"></textarea> </div> <span id="hint" class="lw-hidden lw-hint"></span> </div>`; } /** * Updates the TextBox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'autoExpand': that._autoExpandUpdate(); break; case 'displayMode': switch (newValue) { case 'escaped': that.$.input.value = that._toEscapedDisplayMode(that.value); break; default: that.$.input.value = that.value = that._toDefaultDisplayMode(that.$.input.value); break; } that._autoExpandUpdate(); that._handleScrollbarsDisplay(); break; case 'value': if (that._preventProgramaticValueChange) { that._userValue = that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value; that._programmaticValue = newValue; } else { that._userValue = that._programmaticValue = newValue; } switch (that.displayMode) { case 'escaped': that.$.input.value = that._toEscapedDisplayMode(that._userValue); break; default: that.$.input.value = that._userValue; break; } that._oldValue = oldValue; that._autoExpandUpdate(); that._handleScrollbarsDisplay(); break; case 'horizontalScrollBarVisibility': case 'verticalScrollBarVisibility': case 'singleLine': case 'wrap': case 'resizable': case 'placeholder': that._autoExpandUpdate(); that._handleScrollbarsDisplay(); break; case 'selectionEnd': case 'selectionStart': that._handleSelectedText(); break; case 'rows': case 'cols': that._updateSizeRowsCols(); break; case 'disabled': that._setFocusable(); that._ariaPropertyChangedHandler('disabled', newValue); break; case 'animation': break; case 'readonly': that._ariaPropertyChangedHandler('readonly', newValue); break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Gets selected text in relation to a display mode */ selection(displayMode) { const that = this; let start = that.$.input.selectionStart, end = that.$.input.selectionEnd, value = that.value; if (that.displayMode === 'escaped') { value = that.$.input.value.substring(start, end); if (displayMode === 'escaped') { return value; } else { return that._toDefaultDisplayMode(value); } } if (displayMode === 'escaped') { value = value.substring(start, end); return that._toEscapedDisplayMode(value); } value = value.substring(start, end); return value; } /** * Select Method */ select(start, end) { const that = this, args = Array.from(arguments).slice(0, 2); let selectionStart, selectionEnd; for (let i in args) { args[i] = parseInt(args[i]) || 0; } if (args.length === 2) { selectionStart = Math.min([start, end]); selectionEnd = Math.max([start, end]); } else { selectionStart = args[0]; } if (args.length === 2) { selectionStart = parseInt(selectionStart) if (selectionStart > 0) { selectionStart = selectionStart < that.$.input.length ? that.$.input.length : selectionStart; } else { selectionStart = 0; } if (selectionEnd < selectionStart) { selectionEnd = selectionStart; } else if (selectionEnd > that.$.input.length) { selectionStart = 0; } that.$.input.focus(); that.$.input.setSelectionRange(selectionStart, selectionEnd); return; } else if (args.length === 1) { that.$.input.focus(); that.$.input.setSelectionRange(selectionStart, selectionStart + 1); return; } that.$.input.select(); } /** * Updates the height of the multiline text box according to the number of text rows */ _autoExpandUpdate() { const that = this, input = that.$.input, textBoxHidden = that.$.textBoxHidden, vScroll = that.$.verticalScrollBar; if (!that.autoExpand) { input.style.height = vScroll.style.height = textBoxHidden.style.height = null; return; } const maxHeight = parseFloat(window.getComputedStyle(that).getPropertyValue('max-height')); textBoxHidden.style.height = 0; textBoxHidden.value = input.value; let resizeTriggerHeight = 0; //Note: Checks if the element has height 'auto' if (that.resizeTrigger) { resizeTriggerHeight = that.resizeTrigger.clientHeight; const multilineTextBox = that.clientHeight if (resizeTriggerHeight === multilineTextBox) { resizeTriggerHeight = 0; } } input.style.height = vScroll.style.height = (isNaN(maxHeight) ? textBoxHidden.scrollHeight : Math.min((maxHeight || 0) - resizeTriggerHeight, textBoxHidden.scrollHeight)) + 'px'; } _blurHandler() { const that = this; if (that._outsideAutoScroll) { clearInterval(that._outsideAutoScroll); // new } that.removeAttribute('focus'); that._preventProgramaticValueChange = false; that._oldValue = that.value; that.value = that._userValue || that.value; that.$.fireEvent('blur'); } /** * MultilineTextBox create element method. */ _createElement() { const that = this; if (!that.$.input.id) { that.$.input.id = that.id + 'Input'; } if (that.autoFocus) { //that.$.input.focus(); if (navigator.userAgent.match(/Edge/)) { setTimeout(function () { that.$.input.focus(); that.setAttribute('focus', ''); }, 10); } else { that.$.input.focus(); that.setAttribute('focus', ''); } } // that.autoExpand = (that.theme.indexOf('material') > -1 || that.autoExpand) ? true : false;// const wrappedText = that.$.input.innerHTML; if (that.value) { that.$.input.innerHTML = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value; } else if ((wrappedText.length > 0) && that.displayMode === 'escaped') { that.value = wrappedText; that.$.input.innerHTML = that._toEscapedDisplayMode(wrappedText) } else if (wrappedText.length > 0) { that.value = wrappedText; } that._setFocusable(); that._syncTextBoxContentOnInitialization(); that._scrollView = new LW.Utilities.Scroll(that.$.input, that.$.horizontalScrollBar, that.$.verticalScrollBar); that._autoExpandUpdate(); that._handleScrollbarsDisplay(); that._initializationValue = that._oldValue = that.value; that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); that._handleHintContainer(); that.setAttribute('role', 'textbox'); that.setAttribute('aria-multiline', true); that.setAttribute('aria-describedby', that.$.hint.id); that.setAttribute('aria-labelledby', that.$.label.id); that.$.verticalScrollBar.setAttribute('aria-controls', that.$.input.id); that.$.horizontalScrollBar.setAttribute('aria-controls', that.$.input.id); } /** * Handles the display of the scrollbars, based on set properties and text length. */ _handleScrollbarsDisplay(event) { const that = this, textBox = that.$.input; requestAnimationFrame(() => { that._autoExpandUpdate(); switch (that.horizontalScrollBarVisibility) { case 'disabled': that.$container.addClass('hscroll'); that.$.horizontalScrollBar.disabled = true; break; case 'hidden': that.$container.removeClass('hscroll'); break; case 'visible': that.$container.addClass('hscroll'); that._scrollView.scrollWidth = textBox.scrollWidth - textBox.clientWidth; that._scrollView.scrollTo(that.$.input.scrollLeft, true); that.$.horizontalScrollBar.disabled = false; break; default: if (textBox.scrollWidth > textBox.clientWidth) { that.$container.addClass('hscroll'); that._scrollView.scrollWidth = textBox.scrollWidth - textBox.clientWidth; if (event && event.type === 'resize') { that.$.input.scrollLeft = that._scrollView.scrollLeft; } else { that._scrollView.scrollTo(that.$.input.scrollLeft, true); } } else { that.$container.removeClass('hscroll'); } that.$.horizontalScrollBar.disabled = false; } switch (that.verticalScrollBarVisibility) { case 'disabled': that.$container.addClass('vscroll'); that.$.verticalScrollBar.disabled = true; break; case 'hidden': that.$container.removeClass('vscroll'); break; case 'visible': that.$container.addClass('vscroll'); that._scrollView.scrollHeight = textBox.scrollHeight - textBox.clientHeight; that._scrollView.scrollTo(that.$.input.scrollTop); that.$.verticalScrollBar.disabled = false; break; default: if (textBox.scrollHeight > textBox.clientHeight) { that.$container.addClass('vscroll'); that._scrollView.scrollHeight = textBox.scrollHeight - textBox.clientHeight; if (event && event.type === 'resize') { that.$.input.scrollTop = that._scrollView.scrollTop; } else { that._scrollView.scrollTo(that.$.input.scrollTop); } } else { that.$container.removeClass('vscroll'); } that.$.verticalScrollBar.disabled = false; } }) } /** * Focus handler. Selects whole text in element's text area on selectAllOnFocus: true */ _focusHandler(event) { const that = this; if (that.disabled) { return; } if (event.target === that) { that.$.input.focus(); that._edgeSelect = false; return; } that.setAttribute('focus', ''); if (that.selectAllOnFocus) { if (navigator.userAgent.match(/Edge/)) { const scrollTop = that.$.input.scrollTop; if (that._edgeSelect) { that._edgeSelect = false; return; } setTimeout(function () { that._edgeSelect = true; that.$.input.select(); that.$.input.scrollTop = scrollTop; }, 5); } else { that.$.input.select(); } } that.$.fireEvent('focus'); } /** * Returns the scrollLeft of the input */ _getScrollLeft(scrollLeft, scrollWidth) { const that = this; if (!that.rightToLeft) { return scrollLeft; } //Note: Chrome has a bug with direction: rtl. Doesn't inverse the scrollLeft //see: https://bugs.chromium.org/p/chromium/issues/detail?id=721759 if (LW.Utilities.Core.Browser.Chrome) { if (!scrollWidth) { scrollWidth = that.$.input.scrollWidth - that.$.input.offsetWidth; } scrollLeft = scrollWidth - scrollLeft; } else { scrollLeft *= -1; } return scrollLeft; } /** * Horizontal scrollbar handler. */ _horizontalScrollbarHandler(event) { const that = this; if (that.disabled || that.horizontalScrollBarVisibility === 'hidden' || that.horizontalScrollBarVisibility === 'disabled') { return; } event.stopPropagation(); that.$.input.scrollLeft = that._getScrollLeft(event.detail.value); } /** * keyDown event handler. */ _keyDownHandler(event) { const that = this, key = event.key, shiftKey = event.shiftKey, ctrlKey = event.ctrlKey, value = that.$.input.value; function replaceEscapedKeyWith(newValue) { let selectionStart = that.$.input.selectionStart, selectionEnd = that.$.input.selectionEnd, value = that.$.input.value; event.preventDefault(); that.$.input.value = value.substring(0, selectionStart) + newValue + value.substring(selectionEnd, value.length); that.value = that._toDefaultDisplayMode(that.$.input.value); that.$.input.selectionStart = selectionStart + 2; that.$.input.selectionEnd = selectionStart + 2; } if (that.allowVerticalScrollbar && that.$.input.selectionEnd > (that.$.input.value.length - 5)) { that._scrollView.scrollTo(that._scrollView.scrollTop + (event.deltaY < 0 ? -that.offsetHeight : that.offsetHeight)); } if (key.indexOf('Arrow') > -1) { event.stopPropagation(); return; } switch (key) { case 'Enter': { if ((that.enterKeyBehavior === 'newLine' && !ctrlKey && !shiftKey) || (that.enterKeyBehavior !== 'newLine' && (ctrlKey || shiftKey))) { if (that.displayMode === 'escaped') { replaceEscapedKeyWith('\\n'); } break; } event.preventDefault(); that._userValue = that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value; that.value = that._userValue; if ((that.enterKeyBehavior === 'submit' || that.enterKeyBehavior === 'clearOnSubmit') || (value !== '' && that._userValue !== that._oldValue)) { that.$.fireEvent('change', { 'oldValue': that._oldValue, 'value': value, 'type': 'submit' }); } if (that.enterKeyBehavior === 'clearOnSubmit') { that.$.input.value = ''; } that._oldValue = that.value = that._toDefaultDisplayMode(that.$.input.value); that._submitted = true; if (that.displayMode === 'escaped' && that.enterKeyBehavior.toLowerCase().indexOf('submit') < 0 && !ctrlKey && !shiftKey) { replaceEscapedKeyWith('\\n'); } if ((that.enterKeyBehavior === 'submit') || (that.enterKeyBehavior === 'newLine' && ctrlKey)) { that.$.input.blur(); } break; } case 'Escape': if (that.escKeyMode === 'none') { return; } switch (that.escKeyMode) { case 'none': break; case 'clearValue': that.value = that.$.input.value = ''; break; case 'previousValue': that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that._oldValue) : that._oldValue; break; } break; case ' ': if (that.displayMode === 'escaped') { replaceEscapedKeyWith('\\s'); } break; case 'Backspace': if ((that.displayMode === 'escaped') && (that.$.input.selectionStart === that.$.input.selectionEnd)) { let carretPosition = that.$.input.selectionStart; if ((value[carretPosition - 2] === '\\') && ((value[carretPosition - 1] === 's') || (value[carretPosition - 1] === 'n'))) { that.$.input.value = that.$.input.value.substring(0, carretPosition - 2) + that.$.input.value.substring(carretPosition - 2, that.$.input.value.length); that.$.input.selectionStart = carretPosition - 2; } } if (that._scrollView) { that._handleScrollbarsDisplay(); } break; } } /** * TextBox keyUp event handler. */ _keyUpHandler(event) { const that = this, key = event.key; switch (key) { case 'ArrowLeft': case 'ArrowUp': case 'ArrowDown': that._handlePointerInEscapedSymbol(); break; case 'ArrowRight': that._handlePointerInEscapedSymbol('next'); break; } that._userValue = that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value; that._submitKeyUpHandler(); } /** * MultilineTextBox keyDown event handler. */ _textBoxKeyDownHandler(event) { const that = this, key = event.key; if (that._scrollView) { that._handleScrollbarsDisplay(); } that.value && that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); if (['Enter', 'Escape'].indexOf(key) === -1) { that._preventProgramaticValueChange = true; } if (['ArrowLeft', 'ArrowUp', 'ArrowDown', 'ArrowRight'].indexOf(key) > -1) { that._scrollView.scrollTo(that.$.input.scrollTop); } if (['PageUp', 'PageDown'].indexOf(key) > -1 && LW.Utilities.Core.Browser.Chrome) { if (event.key === 'PageUp') { that.$.input.setSelectionRange(0, 0); that.$.input.scrollTop = 0; } if (event.key === 'PageDown') { that.$.input.setSelectionRange(that.$.input.value.length, that.$.input.value.length); that.$.input.scrollTop = that._scrollView.verticalScrollBar.max; } event.preventDefault(); } } /** * Mouse wheel handler. */ _mouseWheelHandler(event) { const that = this; if (that.disabled || that.$.verticalScrollBar.disabled) { return; } that._scrollView.scrollTo(that._scrollView.scrollTop + (event.deltaY < 0 ? -that.offsetHeight : that.offsetHeight)); that.$.input.scrollTop += event.deltaY < 0 ? -that.offsetHeight : that.offsetHeight; if (that.$.input.scrollTop > 0) { event.preventDefault(); } } /** * Gets the text in the TextBox before widget's initialization */ _syncTextBoxContentOnInitialization() { const that = this; let value; if (that.value === '') { value = that.innerHTML; } else { value = that.value; } if (that.displayMode === 'escaped') { if (value.match(/\r\n|\n\r|\n|\r|\s|\t|\f|\r/g)) { that.value = that._initializationValue = value; that.$.input.value = that._toEscapedDisplayMode(value); } else { that.value = that._initializationValue = that._toDefaultDisplayMode(value); that.$.input.value = value; } return; } that.$.input.value = that.value = that._initializationValue = value; } /** * TextBox change handler. */ _textBoxChangeHandler(event) { const that = this, clipboardData = event.clipboardData || (event.originalEvent && event.originalEvent.clipboardData) || window.clipboardData, oldValue = that.value; if (that.displayMode === 'escaped') { const selectionStart = that.$.input.selectionStart, selectionEnd = that.$.input.selectionEnd; if (clipboardData) { let clipboardValue = clipboardData.getData('text'), value = that.$.input.value; event.preventDefault(); clipboardValue = that._toEscapedDisplayMode(clipboardValue); that.$.input.value = value.substring(0, selectionStart) + clipboardValue + value.substring(selectionEnd, value.length); } that.value = that._toDefaultDisplayMode(that.$.input.value); } else { that.value = that.$.input.value; } that._handleScrollbarsDisplay(); that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); if (!clipboardData) { that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue, 'type': 'blur' }); } that._handleHintContainer(); } /** * input touchmove handler. */ _inputTouchmoveHandler(event) { const that = this; if ((that._resizeStarted || that._touchmoveInside) && event.cancelable) { event.preventDefault(); event.stopPropagation(); return; } const computedVerticalScrollBarVisibility = that.$.container.classList.contains('vscroll'), coords = that._touchCoords; if (!that.$.container.classList.contains('hscroll') && !computedVerticalScrollBarVisibility || !coords) { return; } const scrollView = that._scrollView, touches = event.touches[0]; let scrolled, scrollSize, coord, previousCoord; that._touchCoords = [touches.pageX, touches.pageY]; if (computedVerticalScrollBarVisibility) { scrolled = scrollView.scrollTop; scrollSize = scrollView.scrollHeight; coord = touches.pageY; previousCoord = coords[1]; } else { scrolled = scrollView.scrollLeft; scrollSize = scrollView.scrollWidth; coord = touches.pageX; previousCoord = coords[0]; } const normalizedCoord = parseFloat(coord.toFixed(5)), normalizedPreviousCoord = parseFloat(previousCoord.toFixed(5)); if (scrolled === 0 && normalizedCoord >= normalizedPreviousCoord || // pan up scrolled === scrollSize && normalizedCoord <= normalizedPreviousCoord) { // pan down return; } if (coord !== previousCoord) { that._touchmoveInside = true; } if (event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * input touchstart handler. */ _inputTouchstartHandler(event) { const touches = event.touches[0]; this._touchCoords = [touches.pageX, touches.pageY]; } /** * Resize Element down handler. */ _resizeDownHandler() { const that = this; if (that.disabled || !that.resizable) { return; } that._resizeStarted = true; that.$container.addClass('lw-resize'); if (!that.readonly) { that.$.input.setAttribute('readonly', ''); } } /** * Resize Element move handler. */ _resizeMoveHandler(event) { const that = this; if (that.disabled || !that.resizable || !that._resizeStarted) { return; } const rectObject = that.getBoundingClientRect(), min = { width: 50, height: 50 }, newWidth = that.rightToLeft ? (rectObject.width + rectObject.left - event.clientX) : (event.clientX - rectObject.left), newHeight = event.clientY - rectObject.top; if (newWidth > min.width) { that.style.width = newWidth + 'px'; } if (newHeight > min.height) { that.style.height = newHeight + 'px'; } } /** * Update size on cols and rows change. */ _updateSizeRowsCols() { const that = this; that.$.container.removeAttribute('style'); setTimeout(function () { if ((that.horizontalScrollBarVisibility === 'disabled' || that.horizontalScrollBarVisibility === 'hidden') && (that.verticalScrollBarVisibility === 'disabled' || that.verticalScrollBarVisibility === 'hidden')) { return; } const rectObject = that.getBoundingClientRect(); that.$.container.style.width = rectObject.width + 'px'; that.$.container.style.height = rectObject.height + 'px'; }, 0); } /** * Up handler. */ _upHandler(event) { const that = this; delete that._touchCoords; delete that._touchmoveInside; that._selectionStarted = false; if (that.disabled) { return; } if (event.originalEvent.target === that.$.input) { that._handlePointerInEscapedSymbol(); return; } that.$container.removeClass('lw-resize'); if (!that.readonly) { that.$.input.removeAttribute('readonly'); } if (that._resizeStarted) { that.$.input.focus(); } that._resizeStarted = false; } /** * Vertical scrollbar handler. */ _verticalScrollbarHandler(event) { const that = this; if (that.disabled || that.verticalScrollBarVisibility === 'disabled' || that.verticalScrollBarVisibility === 'hidden') { return; } event.stopPropagation(); that.$.input.scrollTop = event.detail.value; } /** * Used in drag outside support. */ _documentDownHandler(event) { const that = this; that._selectionStarted = false; if (!event.originalEvent || !that.$.input.contains(event.originalEvent.target)) { return; } that._selectionStarted = true; that._selectionStartTime = new Date(); that._pointerDown = { pageX: event.pageX, pageY: event.pageY }; that._edgeSelect = false; } _documentSelectionOutsideHandler(event) { const that = this, coordOffset = 10; clearInterval(that._outsideAutoScroll); if (!that._selectionStarted) { return; } const inputCoord = that.$.input.getBoundingClientRect(), topBound = inputCoord.y + coordOffset, bottomBound = inputCoord.y + inputCoord.height - coordOffset; if (event.pageY > topBound && event.pageY < bottomBound) { return; } const standardClickDelay = 300; const isClick = new Date() - that._selectionStartTime < standardClickDelay; const isDrag = !isClick && (Math.abs(that._pointerDown.pageX - event.pageX) >= 3 || Math.abs(that._pointerDown.pageY - event.pageY) >= 3); if (!isDrag) { return; } that._outsideAutoScroll = setInterval(function () { scrollElement(); scrollElement(true); }, 10); function scrollElement(horizontally) { const elementCoordinates = that.getBoundingClientRect(), documentElement = document.documentElement, pointerOffset = horizontally ? elementCoordinates.left + documentElement.scrollLeft - event.pageX : elementCoordinates.top + documentElement.scrollTop - event.pageY, suffix = horizontally ? 'Left' : 'Top'; if (pointerOffset > 0) { that.$.input['scroll' + suffix] -= 10; that._scrollView['scroll' + suffix] -= 10; } else { that.$.input['scroll' + suffix] += 10; that._scrollView['scroll' + suffix] += 10; } } } _selectStartHandler() { } _styleChangedHandler() { } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * PasswordTextBox custom element. */ LW('lw-password-text-box', class PasswordTextBox extends LW.BaseElement { /** * PasswordTextBox's properties */ static get properties() { return { 'autoFocus': { value: false, type: 'boolean' }, 'hint': { value: '', reflectToAttribute: true, type: 'string' }, 'label': { value: '', reflectToAttribute: true, type: 'string' }, 'maxLength': { value: null, type: 'number?' }, 'minLength': { value: 2, type: 'number' }, 'messages': { value: { 'en': { 'passwordStrength': 'Password strength', 'short': 'Short', 'weak': 'Weak', 'far': 'Far', 'good': 'Good', 'strong': 'Strong', 'showPassword': 'Show password' } }, type: 'object', extend: true }, 'name': { value: '', type: 'string' }, 'passwordStrength': { value: null, type: 'function?', reflectToAttribute: false }, 'placeholder': { value: '', type: 'string' }, 'selectAllOnFocus': { value: false, type: 'boolean' }, 'showPasswordIcon': { value: false, type: 'boolean' }, 'showPasswordStrength': { value: false, type: 'boolean' }, 'tooltipArrow': { value: false, type: 'boolean' }, 'tooltipDelay': { value: 0, type: 'number' }, 'tooltipPosition': { allowedValues: ['bottom', 'top', 'left', 'right', 'absolute'], value: 'top', type: 'string' }, 'tooltipTemplate': { value: null, type: 'string?' }, 'type': { value: 'password', type: 'string', defaultReflectToAttribute: true, readonly: true }, 'value': { value: '', reflectToAttribute: false, type: 'string' } } } /** * PasswordTextBox's event listeners. */ static get listeners() { return { 'document.up': '_documentUpHandler', 'mouseenter': '_mouseEventsHandler', 'mouseleave': '_mouseEventsHandler', 'passwordIcon.down': '_showPassword', 'input.change': '_textBoxChangeHandler', 'input.paste': '_textBoxChangeHandler', 'input.keyup': '_textBoxChangeHandler', 'input.blur': '_blurHandler', 'input.focus': '_focusHandler' } } static get requires() { return { 'LW.Tooltip': 'lw.tooltip.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.textbox.css', 'lw.passwordtextbox.css' ] } /** * PasswordTextBox's HTML template. */ template() { return '<div id="container" role="presentation">' + '<span id="label" inner-h-t-m-l="[[label]]" class="lw-hidden lw-label"></span>' + '<div id="innerContainer" class="lw-content" role="presentation">' + `<input class="lw-input" type="password" id="input" disabled="[[disabled]]" maxlength="[[maxLength]]" minlength="[[minLength]]" name="[[name]]" placeholder="[[placeholder]]" readonly="[[readonly]]" value="[[value]]">` + '<span id="passwordIcon" title="Show Password" class="lw-password-icon lw-hidden" role="button" aria-label="Show Password"></span>' + '</div>' + '<span id="hint" inner-h-t-m-l="[[hint]]" class="lw-hint lw-hidden"></span>' + `<lw-tooltip id="tooltip" open-mode="manual" arrow="[[tooltipArrow]]" right-to-left="[[rightToLeft]]" tooltip-template="[[tooltipTemplate]]" position="[[tooltipPosition]]" delay="[[tooltipDelay]]">` + '</lw-tooltip>' + '</div>'; } /** * Updates the PasswordTextBox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; let strength; switch (propertyName) { case 'locale': case 'messages': case 'passwordStrength': strength = that._evaluatePasswordStrength(); that._updateTooltipString(strength); that.$.passwordIcon.setAttribute('title', that.localize('showPassword')); that._updatePasswordStrengthStyles(strength); break; case 'tooltipPosition': that.$.tooltip.position = that.tooltipPosition; break; case 'tooltipTemplate': that.$.tooltip.tooltipTemplate = that.tooltipTemplate; break; case 'value': strength = that._evaluatePasswordStrength(); that._updateTooltipString(strength); that._updatePasswordStrengthStyles(strength); break; case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'readonly': break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.$.input.tabIndex = -1; return; } that.$.input.removeAttribute('tabindex'); } render() { const that = this; that._createElement(); super.render(); } /** * Focus method */ focus() { this.$.input.focus(); } blur() { that.$.input.blur(); } /** * Reset Method. Reset to the initialization value */ reset() { const that = this; that.$.input.value = that.value = that._initializationValue; } /** * Element's create method */ _createElement() { const that = this; if (that.autoFocus) { that.$.input.focus(); } that.$.addClass('lw-input'); that._setFocusable(); that.$.tooltip.selector = that.$.innerContainer; that.$.passwordIcon.setAttribute('title', that.localize('showPassword')); that._updateTooltipString('short'); that._updatePasswordStrengthStyles(); that._initializationValue = that.value; that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); that._handleHintContainer(); if (!that.hint) { that.hint = that.placeholder; } //NOTE: Tooltip styles are loaded with a delay if (that.shadowRoot) { that.$.tooltip.style.display = 'none'; requestAnimationFrame(() => that.$.tooltip.style.display = ''); } if (!that.$.label.id) { that.$.label.id = that.id + 'Label'; } if (!that.$.hint.id) { that.$.hint.id = that.id + 'Hint'; } if (!that.hint) { that.hint = that.placeholder; } that.setAttribute('role', 'presentation'); that.$.innerContainer.removeAttribute('aria-describedby'); that.$.input.setAttribute('aria-describedby', that.$.tooltip.id + ' ' + that.$.hint.id); that.$.input.setAttribute('aria-labelledby', that.$.label.id); } /** * Handles the Hint */ _handleHintContainer() { const that = this; if (!that.hint) { return; } const container = that.$.hint; if (typeof that.hint === 'function') { const value = that.value, invalid = that.hint(value, container); invalid ? that.$.addClass('invalid') : that.$.removeClass('invalid'); } else if (typeof that.hint === 'string') { container.innerHTML = that.hint; that.$.removeClass('invalid'); } } /** * PasswordTextBox focus handler. */ _focusHandler() { const that = this; if (that.disabled) { return; } if (that.selectAllOnFocus) { that.$.input.select(); } if (that.showPasswordIcon) { that.$passwordIcon.removeClass('lw-hidden'); } that.setAttribute('focus', ''); that._valueBeforeChange = that.value; if (!that.showPasswordStrength) { return; } if (!that._tooltipOpened) { that.$.tooltip.open(); that._tooltipOpened = true; } that.$.fireEvent('focus'); } /** * PasswordTextBox blur handler. */ _blurHandler() { const that = this; if (that.disabled || that._passwordIconPressed) { return; } if (that._valueBeforeChange !== that.value) { that.$.fireEvent('change', { 'newValue': that.value, 'oldValue': that._valueBeforeChange }); that._valueBeforeChange = ''; } if (that.showPasswordIcon) { that.$passwordIcon.addClass('lw-hidden'); } that.removeAttribute('focus'); that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value'); that.$.fireEvent('blur'); if (!that._tooltipOpened) { return; } that.$.tooltip.close(); that._tooltipOpened = false; } /** * Shows password if show passwor icon is pressed. */ _showPassword() { const that = this; if (that.disabled || !that.showPasswordIcon) { return; } that.$.input.type = 'text'; that._passwordIconPressed = true; } /** * Hides password. */ _documentUpHandler() { const that = this; if (that.disabled || !that.showPasswordIcon || !that._passwordIconPressed) { return; } that.$.input.type = 'password'; that._passwordIconPressed = false; that.$.input.focus(); } /** * PasswordTextBox change handler. */ _textBoxChangeHandler() { const that = this; if (that.disabled || that.readonly) { return; } that.value = that.$.input.value; let strength = that._evaluatePasswordStrength(); that._updateTooltipString(strength); that._updatePasswordStrengthStyles(strength); } /** * Updates container's styles related to the password strength. */ _updatePasswordStrengthStyles(strength) { const that = this, passwordStrengthOptions = ['short', 'weak', 'far', 'good', 'strong']; strength = strength || 'short'; for (let i = 0; i < passwordStrengthOptions.length; i++) { that.$container.removeClass('lw-password-' + passwordStrengthOptions[i]); } if (that.disabled) { return; } that.$container.addClass('lw-password-' + strength); } /** * Evaluates the strength of the password string. */ _evaluatePasswordStrength() { const that = this, password = that.$.input.value, passwordLength = password.length, allowedSymbols = '<>@!#$%^&*()_+[]{}?:;|\'"\\,./~`-='; if (that.disabled) { return; } if (that.passwordStrength) { return that.passwordStrength(password, allowedSymbols); } let letters = 0, numbers = 0, specials = 0, passwordStrength = 0; for (var i = 0; i < passwordLength; i++) { const charAt = password.charAt(i), charCodeAt = password.charCodeAt(i); if ((charCodeAt > 64 && charCodeAt < 91) || (charCodeAt > 96 && charCodeAt < 123) || (charCodeAt > 127 && charCodeAt < 155) || (charCodeAt > 159 && charCodeAt < 166)) { letters += 1; continue } if (isNaN(charAt) === false) { numbers += 1; continue } if (allowedSymbols.indexOf(charAt) !== -1) { specials += 1; continue } } passwordStrength = letters + numbers + 2 * specials + letters * numbers / 2 + passwordLength; if (passwordLength < 8) { return 'short'; } else { if (passwordStrength < 20) { return 'weak'; } else if (passwordStrength < 30) { return 'far'; } else if (passwordStrength < 40) { return 'good'; } else { return 'strong'; } } } _keyUpHandler() { } _mouseWheelHandler() { } _resizeHandler() { } _selectStartHandler() { } _setDropDownSize() { } _styleChangedHandler() { } /** * PasswordTextBox container mouse enter/leave events handler. */ _mouseEventsHandler(event) { const that = this; event.type === 'mouseenter' ? that.setAttribute('hover', '') : that.removeAttribute('hover'); } _updateTooltipString(strength) { const that = this; that.$.tooltip.value = '<span class="password-strength-label">' + that.localize('passwordStrength') + ': </span><span class="password-strength-value">' + that.localize(strength) + '</span>'; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Column', class Column { constructor ( column ) { const that = this; if ( typeof column !== 'string' ) { Object.assign( that, column ); } else { that.label = column; that.dataField = column; } if ( !that.dataType ) { that.dataType = 'string'; } if ( !that.columnGroup ) { that.columnGroup = ''; } that.canNotify = true; that.data = column; let align = 'left'; switch ( that.dataType ) { case 'string': case 'date': align = 'left'; break; case 'number': align = 'right'; break; case 'boolean': align = 'center'; break; } if ( that.index === undefined ) { that.index = -1; } if ( that.visibleIndex === undefined ) { that.visibleIndex = -1; } if ( that.selected === undefined ) { that.selected = false; } if ( !that.label ) { that.label = ''; } if ( !that.menuItems ) { that.menuItems = null; } if ( !that.icon ) { that.icon = 'lw-icon-user'; } if ( !that.displayField ) { that.displayField = that.dataField; } if ( !that.template ) { that.template = ''; } if ( !that.editor ) { that.editor = 'input'; } if ( typeof that.editor === 'string' ) { that.editor = { template: that.editor, autoFocus: true } } else { if ( undefined === that.editor.autoFocus ) { that.editor.autoFocus = true; } } that.menu = null; if ( that.allowActionButtonAnimation === undefined ) { if ( that.grid ) { that.allowActionButtonAnimation = that.grid.appearance.allowColumnActionButtonAnimation; } else { that.allowActionButtonAnimation = false; } } if ( that.allowSortButtonAnimation === undefined ) { if ( that.grid ) { that.allowSortButtonAnimation = that.grid.appearance.allowColumnSortButtonAnimation; } else { that.allowSortButtonAnimation = false; } } if ( that.autoShowActionButton === undefined ) { if ( that.grid ) { that.autoShowActionButton = that.grid.appearance.autoShowColumnActionButton; } else { that.autoShowActionButton = false; } } if ( that.autoShowSortButton === undefined ) { if ( that.grid ) { that.autoShowSortButton = that.grid.appearance.autoShowColumnSortButton; } else { that.autoShowSortButton = true; } } if ( that.showSortButton === undefined ) { if ( that.grid ) { that.showSortButton = that.grid.appearance.showColumnSortButton; } else { that.showSortButton = false; } } if ( that.showIcon === undefined ) { if ( that.grid ) { that.showIcon = that.grid.appearance.showColumnIcon; } else { that.showIcon = false; } } if ( that.showDescriptionButton === undefined ) { if ( that.grid ) { that.showDescriptionButton = that.grid.appearance.showColumnDescriptionButton; } else { that.showDescriptionButton = false; } } if ( that.showCustomButton === undefined ) { if ( that.grid ) { that.showCustomButton = that.grid.appearance.showColumnCustomButton; } else { that.showCustomButton = false; } } if ( that.showActionButton === undefined ) { if ( that.grid ) { that.showActionButton = that.grid.appearance.showColumnActionButton; } else { that.showActionButton = false; } } if ( that.allowLabelAnimation === undefined ) { if ( that.grid ) { that.allowLabelAnimation = that.grid.appearance.allowColumnLabelAnimation; } else { that.allowLabelAnimation = false; } } if ( that.autoShowFilterButton === undefined ) { if ( that.grid ) { that.autoShowFilterButton = that.grid.appearance.autoShowColumnFilterButton; } else { that.autoShowFilterButton = false; } } if ( that.showFilterButton === undefined ) { if ( that.grid ) { that.showFilterButton = that.grid.appearance.showColumnFilterButton; } else { that.showFilterButton = false; } } if ( that.autoCloseMenu === undefined ) { if ( that.grid ) { that.autoCloseMenu = that.grid.columnMenu.autoClose; } else { that.autoCloseMenu = true; } } if ( !that.formatFunction ) { that.formatFunction = null; } if ( !that.sortOrder ) { that.sortOrder = null; } if ( !that.sortIndex ) { that.sortIndex = null; } if ( !that.filter ) { that.filter = null; } if ( !that.filterMenuMode ) { that.filterMenuMode = 'default'; if ( that.grid && that.grid.filtering.filterMenu.mode === 'excel' ) { that.filterMenuMode = 'excel'; } } if ( !that.align ) { that.align = align; } if ( !that.cellsAlign ) { that.cellsAlign = align; } if ( !that.cellsWrap ) { that.cellsWrap = false; if ( that.grid && that.grid.layout.allowCellsWrap ) { that.cellsWrap = that.grid.layout.allowCellsWrap; } } if ( !that.minWidth ) { that.minWidth = 30; } if ( !that.width ) { that.width = null; } if ( that.grid && that.grid.columnWidth ) { that.width = that.grid.columnWidth; } if ( that.visible === undefined ) { that.visible = true; } if ( that.allowResize === undefined ) { that.allowResize = true; } if ( that.allowReorder === undefined ) { that.allowReorder = true; } if ( that.allowHide === undefined ) { that.allowHide = true; } if ( that.allowSort === undefined ) { that.allowSort = true; } if ( that.allowSelect === undefined ) { that.allowSelect = true; } if ( that.allowSortToggleOnClick === undefined ) { that.allowSortToggleOnClick = true; } if ( that.allowGroup === undefined ) { that.allowGroup = true; } if ( that.allowFilter === undefined ) { that.allowFilter = true; } if ( that.allowEdit === undefined ) { that.allowEdit = true; } if ( that.allowHeaderEdit === undefined ) { that.allowHeaderEdit = true; } if ( that.allowExport === undefined ) { that.allowExport = true; } if ( that.description === undefined ) { that.description = ''; } if ( undefined === that.group ) { that.group = false; } if ( !that.summary ) { that.summary = []; } if ( !that.formatSettings ) { that.formatSettings = { decimalPlaces: null, decimalSeparator: null, negativeWithBrackets: null, prefix: null, sufix: null, thousandsSeparator: null, dateFormat: 'd' } } that.selected = false; that.sorted = false; that.filtered = false; that.parent = null; that.children = []; } refresh() { const that = this; if ( that.element ) { that.element._refresh(); } } render() { const that = this; that.element.column = that; if ( that.element ) { that.element._render(); } } setProperty( propertyName, value ) { const that = this; const oldValue = that.getProperty( propertyName ); if ( oldValue !== value ) { that.canNotify = false; that[ propertyName ] = value; that.propertyChanged( propertyName, oldValue, value ); that.canNotify = true; } } getProperty( propertyName ) { const that = this; if ( propertyName === 'selected' ) { let selected = false; if ( that.grid._selection.cells[ 'column' + that.dataField ] ) { selected = null; } if ( that.grid && that.grid._selection.columns[ that.dataField ] ) { selected = true; } that.grid.columns.canNotify = false; that[ propertyName ] = selected; that.grid.columns.canNotify = true; return selected; } if ( propertyName === 'group' ) { if ( that.dataSource && that.dataSource.groupBy ) { return that.dataSource.groupBy.indexOf( that.dataField ) >= 0; } return false; } return that[ propertyName ]; } get properties() { return [ 'allowExport', 'allowGroup', 'allowSelect', 'verticalAlign', 'columnGroup', 'cellsVerticalAlign', 'autoCloseMenu', 'autoShowActionButton', 'autoShowSortButton', 'autoShowFilterButton', 'allowLabelAnimation', 'allowActionButtonAnimation', 'allowSortButtonAnimation', 'allowHide', 'allowEdit', 'allowHeaderEdit', 'allowFilter', 'allowSort', 'allowSortToggleOnClick', 'allowResize', 'allowReorder', 'canNotify', 'data', 'description', 'grid', 'icon', 'menuItems', 'menu', 'summary', 'cellsFormat', 'formatSettings', 'formatFunction', 'index', 'sortIndex', 'sortOrder', 'sorted', 'groups', 'element', 'level', 'group', 'filtered', 'filterEditor', 'filter', 'filterMenuMode', 'dataField', 'displayField', 'label', 'dataType', 'align', 'cellsWrap', 'cellsAlign', 'minWidth', 'width', 'visible', 'freeze', 'showActionButton', 'selected', 'showIcon', 'showDescriptionButton', 'treeColumn', 'computedWidth', 'computedHeight', 'overflowWidth', 'parent', 'children', 'onAction', 'left', 'top', 'showCustomButton', 'showFilterButton', 'showSortButton', 'editor', 'template', 'visibleIndex' ] } propertyChanged( propertyName, oldValue, newValue ) { const that = this; if (that.data && that.data[propertyName] !== undefined) { that.data[propertyName] = newValue; } if ( propertyName === 'allowSort' || propertyName === 'allowFilter' ) { that.refresh(); return; } if ( propertyName === 'showIcon' ) { that.refresh(); return; } if ( propertyName === 'visible' ) { that.grid.refresh( that.grid.grouping.enabled ); return; } if ( propertyName === 'showCustomButton' ) { if ( newValue ) { that.element._showCustomButton(); } else { that.element._hideCustomButton(); } } if ( propertyName === 'showDescriptionButton' ) { if ( newValue ) { that.element._showDescriptionButton(); } else { that.element._hideDescriptionButton(); } } if ( propertyName === 'filter' ) { if ( that.filter ) { that.grid.addFilter( that.dataField, that.filter ); that.filtered = true; } else { that.grid.removeFilter( that.dataField ); that.filtered = false; } if ( that.autoShowFilterButton || that.showFilterButton ) { if ( newValue ) { that.element._showFilterButton(); } else { that.element._hideFilterButton(); } } } if ( propertyName === 'sortIndex' ) { if ( that.grid.sorting.mode === 'many' ) { if ( that.grid.context === document ) { that.grid.sortBy( that.dataField, that.sortOrder ); } } return; } if ( propertyName === 'selected' ) { if (false === that.allowSelect) { return; } if ( that.selectionColumn ) { that.refresh(); } if ( newValue ) { if ( !that.grid._selection.columns[ that.dataField ] ) { that.grid._selection.columns[ that.dataField ] = true; } } else if ( newValue === false ) { if ( that.grid._selection.columns[ that.dataField ] ) { delete that.grid._selection.columns[ that.dataField ]; } } that.grid._recycle( false ); } if ( propertyName === 'formatSettings' ) { that.grid._recycle( false ); } if ( propertyName === 'sortOrder' ) { that.sorted = false; if ( newValue === null ) { that.element._hideSortButton(); } else { that.element._showSortButton(); that.sorted = true; } if ( that.grid.context === document ) { that.grid.sortBy( that.dataField, that.sortOrder ); } if ( that.sorted ) { that.element.setAttribute( 'aria-sort', that.sortOrder === 'asc' ? 'ascending' : 'descenting' ); } else { that.element.removeAttribute( 'aria-sort' ); } return; } if ( propertyName === 'group' ) { if ( that.grid.context === document ) { if ( newValue ) { that.grid.addGroup( that.dataField ); } else { that.grid.removeGroup( that.dataField ); } } return; } if ( propertyName === 'showActionButton' ) { that.element.allowAnimations = false; if ( newValue ) { that.element._showActionButton(); } else { that.element._hideActionButton(); } that.element.allowAnimations = true; } if ( propertyName === 'autoShowActionButton' ) { that.element.allowAnimations = false; if ( !newValue ) { that.element._showActionButton(); } else { that.element._hideActionButton(); } that.element.allowAnimations = true; } if ( propertyName === 'showFilterButton' ) { that.element.allowAnimations = false; if ( undefined === that._autoShowFilterButton ) { that._autoShowFilterButton = that.autoShowFilterButton; } if ( newValue ) { that.autoShowFilterButton = false; that.element._showFilterButton(); } else { that.element._hideFilterButton(); that.autoShowFilterButton = that._autoShowFilterButton; } that.element.allowAnimations = true; } if ( propertyName === 'showSortButton' ) { that.element.allowAnimations = false; if ( undefined === that._autoShowSortButton ) { that._autoShowSortButton = that.autoShowSortButton; } if ( newValue ) { that.autoShowSortButton = false; that.element._showSortButton(); } else { that.element._hideSortButton(); that.autoShowSortButton = that._autoShowSortButton; } that.element.allowAnimations = true; } if ( propertyName === 'autoShowSortButton' ) { that.element.allowAnimations = false; that._autoShowSortButton = that.autoShowSortButton; if ( !newValue ) { that.element._showSortButton(); } else { that.element._hideSortButton(); } that.element.allowAnimations = true; } if ( propertyName === 'menu' ) { if ( newValue ) { that.element.setAttribute( 'aria-controls', that.menu.id ); } else { that.element.removeAttribute( 'aria-controls' ); if ( that.autoShowActionButton ) { that.element._hideActionButton(); } } } if ( propertyName === 'label' || propertyName === 'width' || propertyName === 'minWidth' ) { that.grid.refresh(); } if ( propertyName === 'freeze' ) { if ( !newValue ) { if ( that.freeze === true || that.freeze === 'near' ) { that.element.removeAttribute( 'freeze' ); const index = that.grid._frozenNearColumns.indexOf( that ); if ( index >= 0 ) { that.grid._frozenNearColumns.splice( index, 0, 0 ); } } else if ( that.freeze === 'far' ) { const index = that.grid._frozenFarColumns.indexOf( that ); if ( index >= 0 ) { that.grid._frozenFarColumns.splice( index, 0, 0 ); } } } else { that.element.setAttribute( 'freeze', '' ); if ( that.freeze ) { if ( that.freeze === true || that.freeze === 'near' ) { that.grid._frozenNearColumns.push( that ); } else { that.grid._frozenFarColumns.push( that ); } } } that.grid._createColumnHeaderCellElements(); that.grid.refresh(); } } _measureSize( label ) { const that = this; const grid = that.grid; const widths = ( function () { const widths = []; const header = document.createElement( 'div' ); const columnHeaderCellContentElement = document.createElement( 'div' ); const labels = Array.isArray( label ) ? label : [ label ]; columnHeaderCellContentElement.classList.add( 'lw-label' ); header.appendChild( columnHeaderCellContentElement ); header.style.width = 'auto'; header.style.position = 'static'; grid.$.columnHeader.appendChild( header ); for ( let i = 0; i < labels.length; i++ ) { columnHeaderCellContentElement.innerHTML = '<span>' + labels[ i ] + '</span>'; const width = 20 + columnHeaderCellContentElement.firstChild.offsetWidth; const maxWidth = Math.max( 30, width ); widths.push( maxWidth ); } grid.$.columnHeader.removeChild( header ); return widths; } )(); if ( widths.length === 1 ) { return widths[ 0 ]; } return widths; } _autoSize( autoSizeHeadersOnly ) { const that = this; const grid = that.grid; let label = that.label.toString(); if ( !autoSizeHeadersOnly ) { const rows = grid.isInitialized ? grid._recyclingRows : []; for ( let i = 0; i < rows.length; i++ ) { const row = rows[ i ]; const value = '' + row.data[ that.dataField ]; if ( value && value.length > label.length ) { label = value; } } } const columnWidth = that._measureSize( label ); return columnWidth; } autoSize( autoSizeHeadersOnly ) { const that = this; const columnWidth = that._autoSize( autoSizeHeadersOnly ); that.width = columnWidth; } createElement() { const that = this; const element = document.createElement( 'lw-grid-column' ); element._initialize( that ); element.setAttribute( 'role', 'columnheader' ); element.setAttribute( 'aria-haspopup', '' ); that.element = element; that.grid.notify( function ( propertyName, oldValue, newValue ) { switch ( propertyName ) { case 'appearance_allowColumnLabelAnimation': that.setProperty( 'allowLabelAnimation', newValue ); break; case 'appearance_allowColumnSortAnimation': that.setProperty( 'allowSortAnimation', newValue ); break; case 'appearance_allowColumnSortButtonAnimation': that.setProperty( 'allowSortButtonAnimation', newValue ); break; case 'appearance_allowColumnActionButtonAnimation': that.setProperty( 'allowActionButtonAnimation', newValue ); break; case 'appearance_allowColumnFilterButtonAnimation': that.setProperty( 'allowFilterButtonAnimation', newValue ); break; case 'appearance_autoShowColumnActionButton': that.setProperty( 'autoShowActionButton', newValue ); break; case 'appearance_autoShowColumnSortButton': that.setProperty( 'autoShowSortButton', newValue ); break; case 'appearance_autoShowColumnFilterButton': that.setProperty( 'autoShowFilterButton', newValue ); break; case 'appearance_showColumnActionButton': that.setProperty( 'showActionButton', newValue ); break; case 'appearance_showColumnFilterButton': that.setProperty( 'showFilterButton', newValue ); break; case 'appearance_showColumnCustomButton': that.setProperty( 'showCustomButton', newValue ); break; case 'appearance_showColumnDescriptionButton': that.setProperty( 'showDescriptionButton', newValue ); break; case 'appearance_showColumnSortButton': that.setProperty( 'showSortButton', newValue ); break; case 'appearance_showFrozenColumnBackground': case 'appearance_showSortColumnBackground': case 'appearance_showFilterColumnBackground': that.grid._recycle( false ); break; } } ); return element; } } ); LW( 'lw-grid-column', class Column extends LW.BaseElement { _showSortButton( refresh ) { const that = this; if ( !that.column ) { return; } if ( that.column.autoGenerated ) { return; } that.sortButton.classList.remove( 'asc' ); that.sortButton.classList.remove( 'desc' ); if ( !that.column.autoShowSortButton ) { if ( that.column.allowSort ) { that.sortButton.classList.add( 'lw-icon-sort', 'lw-grid-icon' ); } } if ( that.column.sortOrder === 'asc' ) { that.sortButton.classList.add( 'asc' ); } else if ( that.column.sortOrder === 'desc' ) { that.sortButton.classList.add( 'desc' ); } if ( that.column.showSortButton ) { that.sortButton.classList.add( 'show' ); if ( refresh !== false ) { that._refresh(); } } } _hideSortButton( refresh ) { const that = this; if ( !that.column ) { return; } that.sortButton.classList.remove( 'asc' ); that.sortButton.classList.remove( 'desc' ); if ( !that.column.showSortButton || that.column.autoShowSortButton ) { that.sortButton.classList.remove( 'show' ); that.sortButton.classList.remove( 'lw-icon-sort' ); if ( refresh !== false ) { that._refresh(); } } } _showFilterButton() { const that = this; if ( !that.column || that.column.autoGenerated ) { return; } that.filterButton.classList.add( 'show' ); that._refresh(); } _hideFilterButton() { const that = this; if ( !that.column ) { return; } that.filterButton.classList.remove( 'show' ); that._refresh(); } _showDescriptionButton() { const that = this; if ( !that.column || that.column.autoGenerated ) { return; } that.descriptionButton.setAttribute( 'title', that.column.description ); that.descriptionButton.classList.add( 'show' ); that._refresh(); } _hideDescriptionButton() { const that = this; if ( !that.column ) { return; } that.descriptionButton.classList.remove( 'show' ); that._refresh(); } _showIcon() { const that = this; if ( !that.column || that.column.autoGenerated ) { return; } that.icon.classList.add( 'show' ); that._refresh(); } _hideIcon() { const that = this; that.icon.classList.remove( 'show' ); that._refresh(); } _showCustomButton() { const that = this; if ( !that.column || that.column.autoGenerated ) { return; } that.customButton.classList.add( 'show' ); that._refresh(); } _hideCustomButton() { const that = this; if ( !that.column ) { return; } that.customButton.classList.remove( 'show' ); that._refresh(); } _showActionButton() { const that = this; if ( !that.column ) { return; } if ( that.column.showActionButton && that.column.grid.hasColumnMenu( that.column ) && !that.column.autoGenerated ) { if ( that.actionButton ) { that.actionButton.classList.add( 'show' ); that._refresh(); } } } _hideActionButton() { const that = this; if ( !that.column ) { return; } if ( that.column.showActionButton ) { if ( that.actionButton && !that.hasAttribute( 'aria-controls' ) ) { that.actionButton.classList.remove( 'show' ); that._refresh(); } } } _rotate() { const that = this; const span = document.createElement( 'span' ); that.label.innerHTML = ''; span.innerHTML = that.column.label; that.label.appendChild( span ); span.className = 'rotate' span.style.transform = 'rotate(' + that.column.rotationAngle + 'deg)'; return that.column.grid._recycleRotate( that.label, span, that.column.align, that.column.verticalAlign, that.column.label ); } _align() { const that = this; let align = that.column.align; if ( that.column.grid.rightToLeft ) { if ( align === 'left' ) { align = 'right'; } else if ( align === 'right' ) { align = 'left'; } } switch ( align ) { case 'left': that.label.classList.add( 'align-left' ); break; case 'center': that.label.classList.add( 'align-center' ); break; case 'right': that.label.classList.add( 'align-right' ); break; } switch ( that.column.verticalAlign ) { case 'top': that.label.classList.add( 'align-top' ); break; case 'middle': that.label.classList.add( 'align-middle' ); break; case 'bottom': that.label.classList.add( 'align-bottom' ); break; } } _refresh() { const that = this; const grid = that.column.grid; that.sortButton.classList.remove( 'filter' ); that.sortButton.classList.remove( 'action' ); that.label.className = 'lw-label'; if ( that.column.visible && that.column.dataField === '_checkBoxColumn' ) { const grid = that.column.grid; let visibleRows = grid.getVisibleRows(); if ( grid.paging.enabled && grid.selection.checkBoxes.selectAllMode === 'page' ) { visibleRows = visibleRows.slice( grid.paging.pageIndex * grid.paging.pageSize, ( grid.paging.pageIndex + 1 ) * grid.paging.pageSize ); } const selectedRows = grid.paging.enabled && grid.selection.checkBoxes.selectAllMode === 'page' ? grid._getSelectedRows( true, true ) : grid._getSelectedRows( true, false ); if ( grid.selection.checkBoxes.autoShow ) { that.setAttribute( 'auto-show', '' ); } else { that.removeAttribute( 'auto-show' ); } if ( selectedRows.length === visibleRows.length ) { that.setAttribute( 'selected', '' ); } else if ( selectedRows.length > 0 && selectedRows.length < visibleRows.length ) { that.setAttribute( 'selected', 'indeterminate' ); } else if ( selectedRows.length === 0 || visibleRows.length === 0 ) { that.removeAttribute( 'selected' ); } that.removeAttribute( 'checkbox' ); that.label.classList.remove( 'lw-input' ); if ( grid.selection.checkBoxes.selectAllMode !== 'none' ) { that.setAttribute( 'checkbox', '' ); that.label.classList.add( 'lw-input' ); } return; } if ( that.column.dataField === '_commandColumn' ) { const grid = that.column.grid; const showLabel = grid.editing.commandColumn.displayMode !== 'icon'; const showIcon = grid.editing.commandColumn.displayMode !== 'label'; const properties = grid.editing.commandColumn.dataSource.commandColumnMenu; let commandColumnItem = '<div class="lw-grid-command-item">'; const label = properties.label === '{{messages}}' ? grid.localize( 'commandColumnMenu' ) : properties.label; const icon = properties.icon; if ( showIcon && showLabel ) { commandColumnItem += '<span class="lw-grid-icon ' + icon + '"></span>'; commandColumnItem += '<span class="lw-grid-label">' + label + '</span>'; } else if ( showIcon && !showLabel ) { commandColumnItem += '<span class="lw-grid-icon ' + icon + '"></span>'; } else if ( showLabel && !showIcon ) { commandColumnItem += '<span class="lw-grid-label">' + label + '</span>'; } commandColumnItem += '</div>'; if ( properties.visible ) { that.label.innerHTML = commandColumnItem; } } const selected = that.column.getProperty( 'selected' ); if ( selected === false && that.hasAttribute( 'selected' ) ) { that.removeAttribute( 'selected' ); } else if ( selected === true ) { that.setAttribute( 'selected', '' ); } else if ( selected === null ) { that.setAttribute( 'selected', 'indeterminate' ); } if ( that.column.allowSortButtonAnimation ) { that.sortButton.classList.add( 'lw-animate' ); } else { that.sortButton.classList.remove( 'lw-animate' ); } if ( grid.dragDrop && grid.dragDrop.column === that.column ) { that.classList.add( 'dragged' ); } else { that.classList.remove( 'dragged' ); } if ( !that.column.sorted ) { that._hideSortButton( false ); } else { that._showSortButton( false ); } if ( that.column.allowFilterButtonAnimation ) { that.filterButton.classList.add( 'lw-animate' ); } else { that.filterButton.classList.remove( 'lw-animate' ); } if ( that.column.allowActionButtonAnimation && that.allowAnimations !== false ) { that.buttonsGroup.classList.add( 'lw-animate' ); } else { that.buttonsGroup.classList.remove( 'lw-animate' ); } if ( that.column.allowLabelAnimation && that.allowAnimations !== false ) { that.label.classList.add( 'lw-animate' ); } else { that.label.classList.remove( 'lw-animate' ); } that.buttonsGroup.classList.remove( 'action' ); if ( that.actionButton.classList.contains( 'show' ) ) { that.buttonsGroup.classList.add( 'action' ); } if ( that.column.showIcon ) { that.icon.classList.add( 'show' ); } else { that.icon.classList.remove( 'show' ); } if ( that.icon.classList.contains( 'show' ) ) { that.icon.classList.add( that.column.icon ); } let buttonsCount = that.column.showIcon ? 1 : 0; for ( let i = 0; i < that.buttonsGroup.children.length; i++ ) { if ( that.buttonsGroup.children[ i ].classList.contains( 'show' ) ) { buttonsCount++; } } switch ( buttonsCount ) { case 1: that.label.classList.add( 'one' ); break; case 2: that.label.classList.add( 'two' ); break; case 3: that.label.classList.add( 'three' ); break; case 4: that.label.classList.add( 'four' ); break; case 5: that.label.classList.add( 'five' ); break; case 6: that.label.classList.add( 'six' ); break; } that.classList.remove( 'lw-visibility-hidden' ); if ( that.column.grid._columnGap > 0 ) { that.classList.add( 'lw-grid-column-border' ); } else { that.classList.remove( 'lw-grid-column-border' ); } if ( !that.column.grid.appearance.showColumnHeaderLines ) { that.classList.add( 'lw-grid-vertical-border-collapse' ); } else { that.classList.remove( 'lw-grid-vertical-border-collapse' ); } if ( that.column.rotationAngle ) { const rotateResult = that._rotate(); if ( !rotateResult ) { return; } } that._align(); } _render() { const that = this; const columnDataField = that.column.dataField ? that.column.dataField : ''; const isLastColumn = that.column === that.column.grid._lastVisibleColumn; if ( that.label.firstChild ) { if ( that.label.firstChild.textContent !== that.column.label ) { that.label.firstChild.textContent = that.column.label; } } else { that.label.innerHTML = '<span>' + that.column.label + '</span>'; } that._refresh(); if ( that.column.autoGenerated || isLastColumn ) { that.style.width = that.column.computedWidth + 'px'; } else { that.style.width = that.column.computedWidth - that.column.grid._columnGap + 'px'; } if ( that.style.height !== that.column.computedHeight + 'px' ) { that.style.height = that.column.computedHeight + 'px'; } if ( that.style.lineHeight !== that.column.computedHeight + 'px' ) { that.style.lineHeight = that.column.computedHeight + 'px'; } if ( !that.column.grid.rightToLeft ) { if ( that.style.left !== that.column.left + 'px' ) { that.style.left = that.column.left + 'px'; } } else { if ( that.style.right !== that.column.left + 'px' ) { that.style.right = that.column.left + 'px'; } } if ( that.style.top !== that.column.top + 'px' ) { that.style.top = that.column.top + 'px'; } if ( that.getAttribute( 'data-field' ) !== columnDataField ) { that.setAttribute( 'data-field', columnDataField ); } that.setAttribute( 'header', '' ); if ( that.column.freeze ) { that.setAttribute( 'freeze', '' ); } if ( that.column.level > 0 ) { that.style.top = that.column.top + 'px'; } } get hasStyleObserver() { return false; } get enableShadowDOM() { return false; } addThemeClass() { } addDefaultClass() { } get isUtilityElement() { return true; } _initialize( column ) { const that = this; const label = document.createElement( 'div' ); const sortButton = document.createElement( 'div' ); const filterButton = document.createElement( 'div' ); const actionButton = document.createElement( 'div' ); const descriptionButton = document.createElement( 'div' ); const customButton = document.createElement( 'div' ); const icon = document.createElement( 'div' ); const buttonsGroup = document.createElement( 'div' ); that.column = column; that.classList.add( 'lw-visibility-hidden' ); icon.classList.add( 'lw-icon', 'lw-grid-icon' ); label.classList.add( 'lw-label' ); sortButton.classList.add( 'lw-sort-button', 'lw-grid-icon' ); filterButton.classList.add( 'lw-filter-button', 'lw-icon-filter', 'lw-grid-icon' ); actionButton.classList.add( 'lw-action-button', 'lw-grid-icon' ); actionButton.setAttribute( 'aria-haspopup', '' ); descriptionButton.classList.add( 'lw-description-button', 'lw-icon-info-circled', 'lw-grid-icon' ); customButton.classList.add( 'lw-custom-button', column.customButtonIcon ? column.customButtonIcon : 'lw-icon-tools', 'lw-grid-icon' ); buttonsGroup.classList.add( 'lw-buttons-group' ); actionButton.innerHTML = '<div></div>'; that.style.width = that.column.computedWidth + 'px'; that.appendChild( icon ); that.appendChild( label ); that.appendChild( buttonsGroup ); buttonsGroup.appendChild( sortButton ); buttonsGroup.appendChild( filterButton ); buttonsGroup.appendChild( descriptionButton ); buttonsGroup.appendChild( customButton ); buttonsGroup.appendChild( actionButton ); that.icon = icon; that.label = label; that.sortButton = sortButton; that.filterButton = filterButton; that.actionButton = actionButton; that.descriptionButton = descriptionButton; that.customButton = customButton; that.buttonsGroup = buttonsGroup; const downEvent = window.PointerEvent ? 'pointerdown' : 'mousedown'; const upEvent = window.PointerEvent ? 'pointerup' : 'mouseup'; that._filterDownEvent = function ( event ) { event.preventDefault(); event.stopPropagation(); if ( that.column.onAction ) { that.column.onAction( event ); } }.bind( that ); that._filterUpEvent = function ( event ) { event.preventDefault(); event.stopPropagation(); }; that._actionUpEvent = function ( event ) { event.preventDefault(); event.stopPropagation(); }; that._actionDownEvent = function ( event ) { event.preventDefault(); event.stopPropagation(); if ( that.column.onAction ) { that.column.onAction( event ); } }.bind( that ); that.filterButton.addEventListener( downEvent, that._filterDownEvent ); that.filterButton.addEventListener( upEvent, that._filterUpEvent ); that.actionButton.addEventListener( upEvent, that._actionUpEvent ); that.actionButton.addEventListener( downEvent, that._actionDownEvent ); if ( !that.column.autoShowActionButton && that.column.showActionButton ) { that._showActionButton(); } if ( !that.column.autoShowSortButton && that.column.showSortButton ) { that._showSortButton(); } if ( !that.column.autoShowFilterButton && that.column.showFilterButton ) { that._showFilterButton(); } if ( that.column.showDescriptionButton ) { that._showDescriptionButton(); } if ( that.column.showCustomButton ) { that._showCustomButton(); } if ( that.column.showIcon ) { that._showIcon(); } if ( that.column.dataField === '_rowHeaderColumn' ) { that.classList.add( 'top-near-corner' ); } that.customButton.onclick = function ( event ) { if ( that.column.onCustomButtonClick ) { that.column.onCustomButtonClick( event ); } }.bind( that ); } template() { return ''; } _detach() { const that = this; const downEvent = window.PointerEvent ? 'pointerdown' : 'mousedown'; const upEvent = window.PointerEvent ? 'pointerup' : 'mouseup'; that.filterButton.removeEventListener( downEvent, that._filterDownEven ); that.filterButton.removeEventListener( upEvent, that._filterUpEvent ); that.actionButton.removeEventListener( upEvent, that._actionUpEvent ); that.actionButton.removeEventListener( downEvent, that._actionDownEvent ); that.element = null; if ( that.column ) { that.column.grid = null; that.column.element = null; } that.icon = null; that.label = null; that.sortButton = null; that.filterButton = null; that.actionButton = null; that.descriptionButton = null; that.customButton = null; that.buttonsGroup = null; that.column = null; delete that.grid; delete that.column; delete that.icon; delete that.label; delete that.sortButton; delete that.filterButton; delete that.actionButton; delete that.descriptionButton; delete that.customButton; delete that.buttonsGroup; } onDetached() { const that = this; that._detach(); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Row', class Row { constructor ( row ) { const that = this; if ( !row ) { row = {}; } Object.assign( that, row ); if ( !row ) { return; } if ( that.data === undefined ) { const itemObject = { $: {} }; if ( row.grid && row.grid.dataSource ) { const dataSource = row.grid.dataSource; for ( let j = 0; j < dataSource.dataFields.length; j++ ) { const dataField = dataSource.dataFields ? dataSource.dataFields[ j ] : {}; itemObject[ dataField.name ] = ''; } } else { Object.assign( itemObject, row ); } if ( row.id ) { itemObject.$.id = row.id; } that.data = itemObject; } if ( undefined === row.$ || ( row.$ && undefined === row.$.id ) ) { if ( row.data ) { if ( row.data.$ && row.data.$.id ) { that.id = row.data.$.id; } if ( !that.id ) { that.id = row.index; } } else if ( that.id === undefined ) { that.id = row.index; } if ( that.id === undefined ) { that.id = LW.Utilities.Core.createGUID(); } } if ( undefined === that.detailHeight ) { if ( that.grid ) { that.detailHeight = that.grid.rowDetail.height; } else { that.detailHeight = 200; } } if ( undefined === that.height && that.grid ) { that.height = that.grid.layout.rowMinHeight; if ( that.grid.__autoRowHeight ) { that.height = that.grid.__autoRowHeight; } if ( that.grid.layout.rowHeight ) { that.height = that.grid.layout.rowHeight; } } if ( undefined === that.cellHeight ) { that.cellHeight = that.height; } if ( undefined === that.showDetail ) { that.showDetail = false; } if ( undefined === that.index ) { that.index = -1; } if ( undefined === that.visibleIndex ) { that.visibleIndex = -1; } if ( undefined === that.freeze ) { that.freeze = false; } if ( undefined === that.height ) { that.height = null; } if ( undefined === that.minHeight ) { that.minHeight = 25; if ( that.grid ) { that.minHeight = that.grid.layout.rowMinHeight; } } if ( undefined === that.checked ) { that.checked = false; } if ( undefined === that.selected ) { that.selected = false; if ( that.grid && that.grid._selection.rows[ that.id ] ) { that.selected = true; } } else if ( that.selected && that.grid ) { that.grid._selection.rows[ that.id ] = true; } if ( undefined === that.enabled ) { that.enabled = true; } if ( undefined === that.visible ) { that.visible = true; } if ( undefined === that.allowCheck ) { that.allowCheck = true; } if ( undefined === that.filtered ) { that.filtered = true; } if ( undefined === that.allowResize ) { that.allowResize = true; } if ( undefined === that.allowReorder ) { that.allowReorder = true; } if ( undefined === that.allowToggle ) { that.allowToggle = true; } if ( undefined === that.allowSelect ) { that.allowSelect = true; } if ( undefined === that.expanded ) { if ( row.data && row.data.expanded !== undefined ) { that.expanded = row.data.expanded; } else { that.expanded = false; } } that.headerCell = null; that._cells = []; } get properties() { return [ 'allowToggle', 'allowResize', 'allowSelect', 'allowReorder', 'allowCheck', 'canNotify', 'children', 'checked', 'cells', 'detailHeight', 'detailTemplate', 'cellHeight', 'expandHeight', 'data', 'enabled', 'expanded', 'filtered', 'freeze', 'grid', 'headerCell', 'height', 'index', 'id', 'minHeight', 'unbound', 'selected', 'showDetail', 'visible', 'parent', 'leaf', 'visibleIndex' ] } createElement() { const that = this; const element = document.createElement( 'lw-grid-row' ); that.element = element; element.setAttribute( 'role', 'row' ); element._initialize( that ); return element; } _autoSize( row ) { const that = this; const grid = that.grid; let height = grid.layout.rowMinHeight; const element = that.element; if ( !row ) { row = that; } if ( row ) { that.data = row.data; } if ( !element ) { return that.height; } if ( !grid.__autoHeightRows ) { grid.__autoHeightRows = []; } const updateHeight = ( row, column, cellElement ) => { if ( !cellElement || !column || column.autoGenerated ) { return 0; } const measureHeight = () => { cellElement.style.height = 'auto'; if ( column.cellsWrap ) { cellElement.content.classList.add( 'wrap' ); } else { cellElement.content.classList.add( 'nowrap' ); } if ( row && column ) { cellElement.content.textContent = row.data[ column.dataField ]; } const height = cellElement.offsetHeight; cellElement.style.height = ''; cellElement.content.classList.remove( 'wrap' ); cellElement.content.classList.remove( 'nowrap' ); return height; } if ( !grid.__autoHeightRows[ column.dataField ] ) { grid.__autoHeightRows[ column.dataField ] = []; } const length = row.data[ column.dataField ].length; const cachedValue = grid.__autoHeightRows[ column.dataField ][ length ]; const cellHeight = cachedValue ? cachedValue : measureHeight(); height = Math.max( height, cellHeight ); if ( !cachedValue ) { grid.__autoHeightRows[ column.dataField ][ length ] = cellHeight; } } for ( let j = 0; j < grid._frozenNearColumns.length; j++ ) { const column = grid._frozenNearColumns[ j ]; const cellElement = element.children[ 0 ].children[ j ]; updateHeight( row, column, cellElement ); } for ( let j = 0; j < grid._frozenFarColumns.length; j++ ) { const column = grid._frozenFarColumns[ j ]; const cellElement = element.children[ 2 ].children[ j ]; updateHeight( row, column, cellElement ); } for ( let j = 0; j < element.children[ 1 ].children.length; j++ ) { const columnElement = grid._columnElements[ j ]; const column = columnElement.column; const cellElement = element.children[ 1 ].children[ j ]; updateHeight( row, column, cellElement ); } return height; } autoSize() { const that = this; const height = that._autoSize(); that.height = height; } getCell( column ) { const that = this; const grid = that.grid; if ( typeof column === 'string' || typeof column === 'number' ) { column = grid.columnByDataField[ column ]; } if ( !column ) { return null; } if ( !that[ 'column_' + column.dataField ] ) { const cell = new LW.Grid.Cell( that, column, grid ); that[ 'column_' + column.dataField ] = cell; return cell; } else { const cell = that[ 'column_' + column.dataField ]; cell.column = column; return cell; } } get cells() { const that = this; if ( that._cells && that.grid && that._cells.length === that.grid.columns.length ) { return that._cells; } that.createCells(); return that._cells; } get viewCells() { const that = this; const cells = []; for ( let i = 0; i < that.grid.viewColumns.length; i++ ) { const column = that.grid.viewColumns[ i ]; if ( !that[ 'column_' + column.dataField ] ) { const cell = new LW.Grid.Cell( that, column, that.grid ); that[ 'column_' + column.dataField ] = cell; cells.push( cell ); } else { const cell = that[ 'column_' + column.dataField ]; cells.push( cell ); } } that._viewCells = cells; return cells; } createCells() { const that = this; const grid = that.grid; that._cells = []; for ( let i = 0; i < grid.viewColumns.length; i++ ) { const column = grid.viewColumns[ i ]; if ( column.autoGenerated ) { continue; } if ( !that[ 'column_' + column.dataField ] ) { const cell = new LW.Grid.Cell( that, column, grid ); that[ 'column_' + column.dataField ] = cell; that._cells.push( cell ); } else { const cell = that[ 'column_' + column.dataField ]; that._cells.push( cell ); } } } toggle( event ) { const that = this; that.element._handleExpandCollapse( !that.expanded, event ); } select() { const that = this; that.setProperty( 'selected', true ); } unselect() { const that = this; that.setProperty( 'selected', false ); } expand() { const that = this; that.element._handleExpandCollapse( true ); } collapse() { const that = this; that.element._handleExpandCollapse( false ); } render() { const that = this; that.element.row = that; that.element._render(); } setProperty( propertyName, value ) { const that = this; const oldValue = that.getProperty( propertyName ); that[ propertyName ] = value; if ( oldValue !== value ) { that.canNotify = false; that.propertyChanged( propertyName, oldValue, value ); that.canNotify = true; } } getProperty( propertyName ) { const that = this; if ( propertyName === 'selected' && that.grid ) { let selected = false; if ( that.grid._selection.cells[ 'row' + that.id ] ) { selected = null; } if ( that.grid && that.grid._selection.rows[ that.id ] ) { selected = true; } that.grid.rows.canNotify = false; that[ propertyName ] = selected; that.grid.rows.canNotify = true; return selected; } return that[ propertyName ]; } propertyChanged( propertyName, oldValue, newValue ) { const that = this; if ( propertyName === 'showDetail' ) { that.height = 0; const detail = that.element.rowDetail; if ( that.grid.appearance.allowRowDetailToggleAnimation && !that.grid.rowDetail.dialog.enabled ) { const toggleAnimation = function ( event ) { const row = that.grid._toggledRow; if ( row && ( event.propertyName === 'transform' || event.propertyName === 'height' ) ) { endAnimation( row ); } }; const endAnimation = function ( row ) { row.grid.$.content.style.transition = ''; row.element.rowDetail.removeEventListener( 'transitionend', toggleAnimation ); row.element.rowDetail.removeEventListener( 'transitioncancel', toggleAnimation ); row.grid._toggledRow = null; row.element.removeAttribute( 'has-detail' ); that.grid._refresh(); } that.grid._toggledRow = that; detail.addEventListener( 'transitionend', toggleAnimation ); detail.addEventListener( 'transitioncancel', toggleAnimation ); if ( newValue ) { that.element.setAttribute( 'has-detail', '' ); that.element.toggleDetailButton.removeAttribute( 'toggled' ); that.element.toggleDetailButton.classList.remove( 'lw-animate' ); setTimeout( () => { that.element.toggleDetailButton.classList.add( 'lw-animate' ); that.element.toggleDetailButton.setAttribute( 'toggled', '' ); that.element.setAttribute( 'show-detail', '' ); } ); that.element.style.height = that.cellHeight + that.detailHeight + 'px'; if ( that.grid._autoHeight ) { that.grid.$.content.style.transition = '0.25s height ease-in-out'; that.grid.$.content.style.height = parseInt( that.grid.$.content.style.height ) + that.detailHeight + 'px'; that.grid.$.scrollView.style.height = 'auto'; } detail.classList.remove( 'lw-hidden' ); if ( detail.style.height !== that.detailHeight + 'px' ) { detail.style.height = that.detailHeight + 'px'; } if ( detail.style.lineHeight !== that.detailHeight + 'px' ) { detail.style.lineHeight = that.detailHeight + 'px'; } if ( detail.style.top !== that.cellHeight + 'px' ) { detail.style.top = that.cellHeight + 'px'; } } else { that.element.setAttribute( 'has-detail', '' ); that.element.toggleDetailButton.removeAttribute( 'toggled' ); if ( that.grid._autoHeight ) { that.grid.$.content.style.transition = '0.25s height ease-in-out'; that.grid.$.content.style.height = parseInt( that.grid.$.content.style.height ) - that.detailHeight + 'px'; that.grid.$.scrollView.style.height = 'auto'; } setTimeout( () => { that.element.style.height = that.cellHeight + 'px'; that.element.removeAttribute( 'show-detail' ); } ); } } else { that.grid._refresh(); } } if ( propertyName === 'allowCheck' || propertyName === 'allowSelect' ) { that.grid._recycle(); } if ( propertyName === 'checked' ) { if ( that.grid.checkBoxes.hasThreeStates ) { that.grid._hasThreeStates( that, that ); } that.grid._recycle(); } if ( propertyName === 'selected' ) { if (false === that.allowSelect) { return; } if ( newValue ) { that.grid._selection.rows[ that.id ] = true; } else if ( newValue === false ) { if ( that.grid._selection.rows[ that.id ] ) { delete that.grid._selection.rows[ that.id ]; } } if ( !that.element ) { return; } if ( newValue ) { that.element.setAttribute( 'aria-selected', true ); } else { that.element.removeAttribute( 'aria-selected' ); } that.grid._recycle(); } if ( propertyName === 'visible' ) { that.grid.refresh(); } if ( propertyName === 'expanded' ) { if ( !that.expandHeight ) { that.grid.refresh(); } } if ( propertyName === 'height' ) { if ( !that.expandHeight ) { if ( that.cellHeight !== newValue ) { that.cellHeight = newValue; that.grid.refresh(); } } } if ( propertyName === 'freeze' ) { if ( newValue === true || newValue === 'near' ) { that.grid._frozenNearRows.push( that ); } else if ( newValue === 'far' ) { that.grid._frozenFarRows.push( that ); } else { that.grid._frozenNearRows.splice( that.grid._frozenNearRows.indexOf( that ), 1 ); that.grid._frozenFarRows.splice( that.grid._frozenFarRows.indexOf( that ), 1 ); } that.grid._recycle(); } } } ); LW( 'lw-grid-row', class Row extends LW.BaseElement { static get properties() { return { } } get isUtilityElement() { return true; } get hasStyleObserver() { return false; } addThemeClass() { } addDefaultClass() { } _initialize( row ) { const that = this; const grid = row.grid; const columnElements = grid._columnElements; const frozenNearColumns = grid._frozenNearColumns; const frozenFarColumns = grid._frozenFarColumns; const cellsContainerElement = document.createElement( 'div' ); const cellsNearContainerElement = document.createElement( 'div' ); const cellsFarContainerElement = document.createElement( 'div' ); const fragment = document.createDocumentFragment(); const nearFragment = document.createDocumentFragment(); const farFragment = document.createDocumentFragment(); if ( grid.rightToLeft ) { cellsNearContainerElement.classList.add( 'far', 'lw-grid-cell-container' ); cellsContainerElement.classList.add( 'center', 'lw-grid-cell-container' ); cellsFarContainerElement.classList.add( 'near', 'lw-grid-cell-container' ); } else { cellsNearContainerElement.classList.add( 'near', 'lw-grid-cell-container' ); cellsContainerElement.classList.add( 'center', 'lw-grid-cell-container' ); cellsFarContainerElement.classList.add( 'far', 'lw-grid-cell-container' ); } that.row = row; row.createCells(); that._mouseEnter = function () { if ( grid.isScrolling || grid.editing.isEditing ) { return; } if ( that.commandBar ) { that.commandBar.parentNode.removeChild( that.commandBar ); that.commandBar = null; } if ( grid.editing.enabled && grid.editing.commandColumn.visible && grid.editing.commandColumn.inline && !that.commandBar ) { const commandBar = document.createElement( 'div' ); const template = grid._getCommandColumnCommandsTemplate(); commandBar.classList.add( 'lw-grid-command-bar' ); commandBar.innerHTML = template; cellsContainerElement.appendChild( commandBar ); requestAnimationFrame( () => { commandBar.classList.add( 'show' ); } ) grid._updateCommandColumnCommandsVisibility( commandBar, that.row ); commandBar.onmousedown = function ( event ) { const elements = event.path; let commandItem = null; for ( let i = 0; i < elements.length; i++ ) { if ( elements[ i ].classList.contains( 'lw-grid-command-item' ) ) { commandItem = elements[ i ]; break; } } if ( !commandItem ) { // commandItem = that.querySelector('.lw-grid-command-item'); } if ( commandItem ) { const command = commandItem.getAttribute( 'command' ); grid._applyCommand( command, [ that.row ] ); if ( that.commandBar ) { that.commandBar.parentNode.removeChild( that.commandBar ); that.commandBar = null; } that.removeAttribute( 'hover' ); event.stopPropagation(); event.preventDefault(); } } that.commandBar = commandBar; } }; that._mouseLeave = function () { if ( grid.isScrolling || grid.editing.isEditing ) { return; } if ( that.commandBar ) { that.commandBar.classList.remove( 'show' ); that.commandBar.addEventListener( 'transitionend', function () { if ( that.commandBar ) { that.commandBar.parentNode.removeChild( that.commandBar ); that.commandBar = null; } } ); that.commandBar.addEventListener( 'transitioncancel', function () { if ( that.commandBar ) { that.commandBar.parentNode.removeChild( that.commandBar ); that.commandBar = null; } } ); } }; that.addEventListener( 'mouseenter', that._mouseEnter ); that.addEventListener( 'mouseleave', that._mouseLeave ); for ( let i = 0; i < frozenNearColumns.length; i++ ) { const column = frozenNearColumns[ i ]; const cell = row.getCell( column ); const cellElement = cell.createElement(); nearFragment.appendChild( cellElement ); } for ( let i = 0; i < frozenFarColumns.length; i++ ) { const column = frozenFarColumns[ i ]; const cell = row.getCell( column ); const cellElement = cell.createElement(); farFragment.appendChild( cellElement ); } for ( let i = 0; i < columnElements.length; i++ ) { const columnElement = columnElements[ i ]; const column = columnElement.column; if ( !columnElement.parentNode || !column ) { break; } const cell = row.getCell( column ); const cellElement = cell.createElement(); if ( column && column._treeColumn ) { that.toggleButton = cellElement.toggleButton; } fragment.appendChild( cellElement ); } cellsNearContainerElement.appendChild( nearFragment ); cellsContainerElement.appendChild( fragment ); cellsFarContainerElement.appendChild( farFragment ); const rowDetailElement = document.createElement( 'div' ); rowDetailElement.classList.add( 'lw-grid-row-detail', 'lw-hidden', 'lw-animate' ); const rowContainerElement = document.createElement( 'div' ); rowContainerElement.classList.add( 'lw-grid-row-sub-container', 'lw-hidden' ); that._rowFragment = document.createDocumentFragment(); that._rowFragment.appendChild( cellsNearContainerElement ); that._rowFragment.appendChild( cellsContainerElement ); that._rowFragment.appendChild( cellsFarContainerElement ); that._rowFragment.appendChild( rowDetailElement ); that._rowFragment.appendChild( rowContainerElement ); that.appendChild( that._rowFragment ); that.cellsNearContainerElement = that.children[ 0 ]; that.cellsContainerElement = that.children[ 1 ]; that.cellsFarContainerElement = that.children[ 2 ]; that.rowDetail = that.children[ 3 ]; that.rowContainer = that.children[ 4 ]; if ( grid.layout.rowHeight && grid.layout.rowHeight !== 'auto' ) { that.style.height = grid.layout.rowHeight + 'px'; } delete that._rowFragment; } get enableShadowDOM() { return false; } _handleExpandCollapse( expanded, event ) { const that = this; const row = that.row; const grid = row.grid; if ( !row.allowToggle ) { return null; } grid._toggledRow = row; let eventDetails = { 'row': row } if ( event ) { eventDetails.originalEvent = event.originalEvent; } grid.$.fireEvent( expanded ? 'rowExpand' : 'rowCollapse', eventDetails ); const setRowHeight = function () { const row = grid._toggledRow; grid._refresh(); grid._refreshRowHierarchy(); let expandHeight = 0; for ( let i = 0; i < grid.rowHierarchy.length; i++ ) { const row = grid.rowHierarchy[ i ]; let parent = row.parent; while ( parent ) { if ( parent.id === grid._toggledRow.id ) { expandHeight += row.height; } parent = parent.parent; } } const value = grid._scrollView.scrollTop; const remainingHeight = grid._contentHeight - ( row.cellHeight + row.top - value ); row.expandHeight = Math.min( remainingHeight, expandHeight ); row.height = row.cellHeight + row.expandHeight; } const requestNewData = grid.dataSource.virtualDataSourceOnExpand && expanded && row.data._loaded !== true; if ( !grid.appearance.allowRowToggleAnimation || requestNewData ) { grid.rows.canNotify = false; row.expanded = expanded; grid.rows.canNotify = true; if ( requestNewData ) { row.data._loaded = true; row.data.expanded = expanded; grid._virtualDataRequest( 'expand' ); } grid._toggledRow = null; grid._refresh(); if ( requestNewData && grid.appearance.allowRowToggleAnimation ) { that.toggleButton.removeAttribute( 'toggled' ); that.toggleButton.classList.remove( 'lw-animate' ); setTimeout( () => { that.toggleButton.classList.add( 'lw-animate' ); that.toggleButton.setAttribute( 'toggled', '' ); }, 50 ); } } else { const endAnimation = function ( row ) { row.height = row.cellHeight; grid.$.content.style.transition = ''; row.element.rowContainer.innerHTML = ''; row.element.rowContainer.classList.add( 'lw-hidden' ); row.element.rowContainer.removeEventListener( 'transitionend', toggleAnimation ); row.element.rowContainer.removeEventListener( 'transitioncancel', toggleAnimation ); row.element.rowContainer.style.height = ''; row.element.rowContainer.style.transform = ''; row.element.rowContainer.style.transition = ''; row.element.rowContainer.classList.remove( 'lw-animate' ) if ( row.element.toggleButton ) { row.element.toggleButton.classList.remove( 'lw-animate' ); } grid._refresh(); } const toggleAnimation = function ( event ) { const row = grid._toggledRow; that._toggleTimer = null; grid._toggledRow = null; if ( row && ( event.propertyName === 'transform' || event.propertyName === 'height' ) ) { setTimeout( () => { endAnimation( row ); }, 50 ); } }; if ( that._toggleTimer ) { clearTimeout( that._toggleTimer ); const row = grid._toggledRow; grid._toggledRow = null; endAnimation( row ); } that._toggleTimer = setTimeout( () => { const updateHeightAndRefresh = function () { setRowHeight(); grid._recycle( false ); that.style.overflow = 'hidden'; that.style.height = 'auto'; that.style.lineHeight = row.cellHeight + 'px'; } if ( expanded ) { row.expanded = true; updateHeightAndRefresh(); that.rowContainer.style.transform = 'scaleY(0)'; that.rowContainer.style.height = '0px'; if ( that.toggleButton ) { that.toggleButton.removeAttribute( 'toggled' ); } if ( grid._autoHeight ) { grid.$.content.style.height = parseInt( grid.$.content.style.height ) - row.expandHeight + 'px'; } setTimeout( function () { if ( that.toggleButton ) { that.toggleButton.classList.add( 'lw-animate' ); that.toggleButton.setAttribute( 'toggled', '' ); } that.rowContainer.addEventListener( 'transitionend', toggleAnimation ); that.rowContainer.addEventListener( 'transitioncancel', toggleAnimation ); if ( grid._autoHeight ) { grid.$.content.style.transition = '0.25s height ease-in-out'; grid.$.content.style.height = parseInt( grid.$.content.style.height ) + row.expandHeight + 'px'; } that.rowContainer.classList.add( 'lw-animate' ) that.rowContainer.style.height = row.expandHeight + 'px'; that.rowContainer.style.transform = 'scaleY(1)'; } ); } else { updateHeightAndRefresh(); row.expanded = false; that.rowContainer.style.transform = 'scaleY(0)'; that.rowContainer.style.height = '0px'; if ( grid._autoHeight ) { grid.$.content.style.height = parseInt( grid.$.content.style.height ) - row.expandHeight + 'px'; grid.$.content.style.transition = ''; grid.$.content.style.height = parseInt( grid.$.content.style.height ) + row.expandHeight + 'px'; } that.rowContainer.style.height = row.expandHeight + 'px'; that.rowContainer.style.transform = 'scaleY(1)'; if ( that.toggleButton ) { that.toggleButton.setAttribute( 'toggled', '' ); that.toggleButton.classList.add( 'lw-animate' ); } setTimeout( function () { if ( that.toggleButton ) { that.toggleButton.removeAttribute( 'toggled', '' ); } if ( grid._autoHeight ) { grid.$.content.style.transition = '0.25s height ease-in-out'; grid.$.content.style.height = parseInt( grid.$.content.style.height ) - row.expandHeight + 'px'; } that.rowContainer.addEventListener( 'transitionend', toggleAnimation ); that.rowContainer.addEventListener( 'transitioncancel', toggleAnimation ); that.rowContainer.classList.add( 'lw-animate' ) // that.rowContainer.style.transition = 'transform .25s ease-in-out, height .25s ease-in-out'; that.rowContainer.style.transform = 'scaleY(0)'; that.rowContainer.style.height = '0px'; }, 0 ); } }, 50 ); } } _renderAddNewRow() { const that = this; const row = that.row; const grid = row.grid; const element = row.element; const cell = new LW.Grid.Cell( row, grid.columns[ 0 ], grid ); if ( row.visible ) { element.classList.remove( 'lw-hidden' ); } else { element.classList.add( 'lw-hidden' ); } element.innerHTML = '<lw-grid-cell><div>' + grid.localize( 'addNewRow' ) + '</div></lw-grid-cell>'; element.firstChild.firstChild.classList.add( 'align-center' ); element.firstChild.classList.add( 'lw-grid-column-border-collapse' ); element.firstChild.setAttribute( 'freeze', '' ); element.firstChild.setAttribute( 'addNewRow', '' ); element.firstChild.style.width = '100%'; if ( grid._scrollView.vScrollBar.offsetWidth > 0 ) { element.firstChild.style.width = 'calc(100% - ' + ( -1 + grid._scrollView.vScrollBar.offsetWidth ) + 'px)'; } element.firstChild.cell = cell; if ( grid._rowGap > 0 && row !== grid.rows[ grid.rows.length - 1 ] ) { that.style.marginBottom = grid._rowGap + 'px'; if ( parseInt( that.style.height ) - grid._rowGap !== row.height ) { that.style.height = row.height - grid._rowGap + 'px'; } if ( parseInt( that.style.lineHeight ) - grid._rowGap !== row.height ) { that.style.lineHeight = row.height - grid._rowGap + 'px'; } } else { that.style.marginBottom = ''; if ( parseInt( that.style.height ) !== row.height ) { that.style.height = row.height + 'px'; } if ( parseInt( that.style.lineHeight ) !== row.height ) { that.style.lineHeight = row.height + 'px'; } } } _renderFilterRow() { const that = this; const row = that.row; const grid = row.grid; const element = row.element; //const cell = new LW.Grid.Cell( row, grid.columns[ 0 ], grid ); if ( row.visible ) { element.classList.remove( 'lw-hidden' ); } else { element.classList.add( 'lw-hidden' ); } element.innerHTML = '<lw-grid-cell><div>' + grid.localize( 'addNewRow' ) + '</div></lw-grid-cell>'; element.firstChild.firstChild.classList.add( 'align-center' ); element.firstChild.classList.add( 'lw-grid-column-border-collapse' ); element.firstChild.setAttribute( 'freeze', '' ); element.firstChild.setAttribute( 'addNewRow', '' ); element.firstChild.style.width = '100%'; if ( grid._scrollView.vScrollBar.offsetWidth > 0 ) { element.firstChild.style.width = 'calc(100% - ' + ( -1 + grid._scrollView.vScrollBar.offsetWidth ) + 'px)'; } that.style.marginBottom = ''; if ( parseInt( that.style.height ) !== row.height ) { that.style.height = row.height + 'px'; } if ( parseInt( that.style.lineHeight ) !== row.height ) { that.style.lineHeight = row.height + 'px'; } } _renderEmpty() { const that = this; that.classList.add( 'lw-hidden' ); } _renderCell( row, column, element ) { if ( !column ) { element.classList.add( 'lw-hidden' ); return; } let cell = row.getCell( column ); if ( cell.element !== element ) { cell._styleChanged = true; } if ( element.cell !== cell ) { if ( element.cell.background !== cell.background || element.cell.borderColor !== cell.borderColor || element.cell.color !== cell.color || element.cell.fontSize !== cell.fontSize || element.cell.fontFamily !== cell.fontFamily || element.cell.fontWeight !== cell.fontWeight || element.cell.fontStyle !== cell.fontStyle ) { cell._styleChanged = true; } } cell.element = element; element.cell = cell; if ( column._treeColumn && cell.element.isRendered && !LW.Utilities.Core.isMobile ) { cell.element._refresh(); } cell.render(); if ( column && column.rowHeaderColumn ) { row.header = element; element.setAttribute( 'data-id', row.id ); } } _alternate() { const that = this; const row = that.row; const grid = row.grid; const start = grid.appearance.alternationStart; const end = grid.appearance.alternationEnd > 0 ? grid.appearance.alternationEnd : Infinity; if ( grid.appearance.alternationCount <= 0 ) { return; } that.removeAttribute( 'alternation-index' ); if ( row.visibleIndex >= start && row.visibleIndex <= end ) { const alternationIndex = ( row.visibleIndex - start ) % grid.appearance.alternationCount; that.setAttribute( 'alternation-index', alternationIndex ); } } _openRowDetailDialog( detail ) { const that = this; const grid = that.row.grid; const row = that.row; if ( !grid.rowDetail.dialog.enabled || !row.showDetail ) { return false; } const dialog = grid._dialogRowDetail || grid._createDialog( grid.rowDetail.dialog ); if ( grid.rowDetail.dialog.visible && dialog.row !== row ) { row.showDetail = false; return; } const header = grid.rowDetail.dialog.header === '{{message}}' ? grid.localize( 'dialogRowDetailHeader', { value: row.visibleIndex + 1 } ) : grid.rowDetail.dialog.header; if ( grid.rowDetail.dialog.visible && grid.rowDetail.dialog.row === row && !row.showDetail ) { dialog.close(); return; } dialog.header.innerHTML = header; dialog.content.innerHTML = ''; dialog.content.style.width = '100%'; dialog.content.style.height = '100%'; dialog.row = row; dialog.querySelector( '.lw-footer' ).classList.add( 'lw-hidden' ); if ( !grid._dialogRowDetail ) { dialog.setAttribute( 'tabindex', 0 ); dialog.modal = true; dialog.btnConfirm.innerHTML = grid.localize( 'dialogRowDetailButtonConfirm' ); dialog.btnCancel.innerHTML = grid.localize( 'dialogRowDetailButtonCancel' ); dialog.btnCancel.classList.add( 'lw-hidden' ); dialog.onOpen = function () { grid.rowDetail.dialog.visible = true; } dialog.onClose = function () { grid.rowDetail.dialog.visible = false; dialog.row.showDetail = false; } dialog.btnCancel.onclick = function () { dialog.close(); } dialog.btnClose.onclick = function () { dialog.close(); } dialog.btnConfirm.onclick = function () { dialog.close(); } dialog.onkeydown = function ( event ) { if ( event.key === 'Escape' ) { dialog.close(); } } grid._dialogRowDetail = dialog; } dialog.open(); setTimeout( function () { dialog.focus(); }, 100 ); dialog.content.appendChild( detail ); } _renderDetail( detail ) { const that = this; const grid = that.row.grid; const row = that.row; let value = row.id; let template = row.detailTemplate || grid.rowDetail.template; if ( template.startsWith( '#' ) ) { template = document.querySelector( template ); } if ( row._detail ) { if ( detail.firstChild === row._detail ) { if ( grid.onRowDetailUpdated ) { grid.onRowDetailUpdated( row.index, row, detail.firstChild ); } return; } if ( detail.firstChild ) { detail.removeChild( detail.firstChild ); } detail.appendChild( row._detail ); if ( grid.onRowDetailUpdated ) { grid.onRowDetailUpdated( row.index, row, detail.firstChild ); } return; } if ( template instanceof HTMLTemplateElement ) { const templateContent = template.content.cloneNode( true ).firstElementChild; value = value.toString(); value = value.replace( /'/ig, '\\\'' ); value = value.replace( /"/ig, '\\"' ); let html = templateContent.outerHTML.replace( /{{value}}/ig, value ).replace( /{{id}}/ig, row.id ); if ( html.indexOf( '{{value=' ) >= 0 ) { if ( !value ) { html = html.replace( /{{value=/ig, '' ); html = html.replace( /}}/ig, '' ); } else { html = html.substring( 0, html.indexOf( '{{value=' ) ) + value + html.substring( html.indexOf( '}' ) ); html = html.replace( /}/ig, '' ); html = html.replace( /{/ig, '' ); } } html = '<div>' + html + '</div>'; for ( let name in row.data ) { html = html.replace( '{{' + name + '}}', row.data[ name ] ) } if ( detail.innerHTML !== html ) { detail.innerHTML = html; } } else { let html = '<div>' + template.replace( /{{value}}/ig, value ).replace( /{{id}}/ig, row.id ) + '</div>'; for ( let name in row.data ) { html = html.replace( '{{' + name + '}}', row.data[ name ] ) } if ( detail.innerHTML !== html ) { detail.innerHTML = html; } } if ( grid.onRowDetailInit ) { grid.onRowDetailInit( row.index, row, detail.firstChild ); } if ( grid.rowDetail.dialog.enabled ) { that._openRowDetailDialog( detail.firstChild.firstElementChild ); } else { row._detail = detail.firstChild; } } _render() { let that = this; const row = that.row; const grid = row.grid; const selected = row.getProperty( 'selected' ); if ( selected === false && that.hasAttribute( 'selected' ) ) { that.removeAttribute( 'selected' ); } else if ( selected === true ) { that.setAttribute( 'selected', '' ); } else if ( selected === null ) { that.setAttribute( 'selected', 'indeterminate' ); } if ( !row.allowSelect ) { that.setAttribute( 'selected', 'none' ); } if ( that.hasAttribute( 'unbound' ) ) { that.removeAttribute( 'unbound' ); } if ( row.unbound ) { that.setAttribute( 'unbound', '' ); } that.removeAttribute( 'focus' ); if ( !grid._toggledRow && that.classList.contains( 'lw-animate' ) ) { that.classList.remove( 'lw-animate' ); that.rowContainer.innerHTML = ''; that.rowContainer.classList.add( 'lw-hidden' ); grid._refreshLayout(); grid._recycle(); return; } if ( grid.columns.length === 0 ) { that._renderEmpty(); return; } if ( row.addNewRow ) { that._renderAddNewRow(); return; } if ( grid._toggledRow ) { if ( row.id === grid._toggledRow.id ) { that.setAttribute( 'toggle', '' ); } else if ( that.hasAttribute( 'toggle' ) ) { that.removeAttribute( 'toggle' ); } } if ( grid._toggledRow && grid.appearance.allowRowToggleAnimation ) { let parentRow = row.parent; if ( !grid._toggledRow.expanded && grid._toggledRow.id === row.id ) { const rowContainer = that.rowContainer; for ( let i = 0; i < rowContainer.children.length; i++ ) { const animatingRowElement = rowContainer.children[ i ]; const uid = animatingRowElement.getAttribute( 'data-id' ); const animatingRow = grid.rowById[ uid ]; if ( animatingRowElement.getAttribute( 'data-rendered' ) ) { continue; } animatingRowElement.setAttribute( 'data-rendered', true ); animatingRow.element = animatingRowElement; animatingRow.render(); } } while ( parentRow ) { if ( parentRow.id === grid._toggledRow.id ) { const rowContainer = parentRow.element.rowContainer; if ( grid._toggledRow.expanded ) { that.classList.add( 'lw-hidden' ); let rowElement = row.createElement( grid ); for ( let i = 0; i < rowContainer.children.length; i++ ) { const animatingRowElement = rowContainer.children[ i ]; if ( animatingRowElement.getAttribute( 'data-id' ) === row.id.toString() ) { rowElement = animatingRowElement; return; } } row.element = rowElement; rowContainer.appendChild( rowElement ); rowContainer.classList.remove( 'lw-hidden' ); rowElement.row = row; that = rowElement; } break; } parentRow = parentRow.parent; } } that._alternate(); const nearWidth = parseFloat( grid.$.columnNearContainer.style.width ); const centerWidth = parseFloat( grid.$.columnContainer.style.width ); const farWidth = parseFloat( grid.$.columnFarContainer.style.width ); const cellsCenterContainerElement = that.children[ 1 ]; const cellsNearContainerElement = that.children[ 0 ]; const cellsFarContainerElement = that.children[ 2 ]; if ( !grid.rightToLeft ) { cellsFarContainerElement.classList.remove( 'vscroll' ); if ( grid.computedVerticalScrollBarVisibility ) { cellsFarContainerElement.classList.add( 'vscroll' ); } } else { cellsNearContainerElement.classList.remove( 'vscroll' ); if ( grid.computedVerticalScrollBarVisibility ) { cellsNearContainerElement.classList.add( 'vscroll' ); } } if ( that.hasAttribute( 'group' ) ) { that.removeAttribute( 'group' ); } if ( that.hasAttribute( 'tree' ) ) { that.removeAttribute( 'tree' ); } if ( that.hasAttribute( 'level' ) ) { that.removeAttribute( 'level' ); that.removeAttribute( 'aria-level' ); } if ( that.hasAttribute( 'leaf' ) ) { that.removeAttribute( 'leaf' ); } if ( that.hasAttribute( 'expanded' ) ) { that.removeAttribute( 'expanded' ); } if ( that.hasAttribute( 'summary' ) ) { that.removeAttribute( 'summary' ); } if ( that.hasAttribute( 'filter' ) ) { that.removeAttribute( 'filter' ); } if ( row.filtered === null ) { that.setAttribute( 'filter', 'indeterminate' ) } if ( grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0 && grid.grouping.renderMode === 'advanced' ) { that.setAttribute( 'level', row.level ); that.setAttribute( 'aria-level', row.level ); if ( row.expanded ) { that.setAttribute( 'expanded', '' ); } if ( row.label !== undefined && row.level === grid.dataSource.groupBy.length - 1 ) { that.setAttribute( 'leaf', '' ); } if ( row.label !== undefined ) { that.setAttribute( 'group', '' ); } else { that.setAttribute( 'leaf', '' ); } if ( row.summaryRow ) { that.setAttribute( 'summary', '' ); } if ( that.toggleButton ) { that.toggleButton.classList.remove( 'lw-hidden' ); } } else if ( grid.dataSource.boundHierarchy ) { that.setAttribute( 'level', row.level ); that.setAttribute( 'aria-level', row.level ); if ( row.expanded ) { that.setAttribute( 'expanded', '' ); } if ( row.leaf ) { that.setAttribute( 'leaf', '' ); } if ( row.summaryRow ) { that.setAttribute( 'summary', '' ); } if ( that.toggleButton ) { that.toggleButton.classList.remove( 'lw-hidden' ); } } else { row.canNotify = false; row.leaf = true; row.expanded = false; row.summaryRow = false; if ( row.data.summaryRow ) { row.summaryRow = true; } row.level = 0; if ( that.toggleButton ) { that.toggleButton.classList.add( 'lw-hidden' ); } row.canNotify = true; } that.setAttribute( 'data-id', row.id ); that.visible = row.visible; that.cellsNearContainerElement.classList.remove( 'lw-visibility-hidden' ); that.cellsContainerElement.classList.remove( 'lw-visibility-hidden' ); that.cellsFarContainerElement.classList.remove( 'lw-visibility-hidden' ); that.removeAttribute( 'rowspan' ); if ( grid._rowGap > 0 && row !== grid.rows[ grid.rows.length - 1 ] ) { that.style.marginBottom = grid._rowGap + 'px'; if ( parseInt( that.style.height ) - grid._rowGap !== row.height ) { that.style.height = row.height - grid._rowGap + 'px'; } if ( parseInt( that.style.lineHeight ) - grid._rowGap !== row.height ) { that.style.lineHeight = row.height - grid._rowGap + 'px'; } } else { that.style.marginBottom = ''; if ( parseInt( that.style.height ) !== row.height ) { that.style.height = row.height + 'px'; } if ( parseInt( that.style.lineHeight ) !== row.height ) { that.style.lineHeight = row.height + 'px'; } } if ( !grid.rightToLeft ) { if ( cellsCenterContainerElement.style.left !== -grid._scrollView.scrollLeft + 'px' ) { cellsCenterContainerElement.style.left = -grid._scrollView.scrollLeft + 'px'; } } else { if ( cellsCenterContainerElement.style.right !== grid._scrollView.scrollWidth - grid._scrollView.scrollLeft - grid._scrollView.vScrollBar.offsetWidth + 'px' ) { cellsCenterContainerElement.style.right = grid._scrollView.scrollWidth - grid._scrollView.scrollLeft - grid._scrollView.vScrollBar.offsetWidth + 'px'; } } if ( grid.rowDetail.enabled ) { const detail = that.rowDetail; that.removeAttribute( 'show-detail' ); if ( row.showDetail ) { detail.classList.remove( 'lw-hidden' ); that.setAttribute( 'show-detail', '' ); if ( !grid.rowDetail.dialog.enabled ) { if ( detail.style.height !== row.detailHeight + 'px' ) { detail.style.height = row.detailHeight + 'px'; } if ( detail.style.lineHeight !== row.detailHeight + 'px' ) { detail.style.lineHeight = row.detailHeight + 'px'; } if ( detail.style.top !== row.cellHeight + 'px' ) { detail.style.top = row.cellHeight + 'px'; } } else { detail.classList.add( 'lw-hidden' ); } that._renderDetail( detail ); } else { detail.classList.add( 'lw-hidden' ); } } else if ( that.rowDetail ) { const detail = that.rowDetail; detail.classList.add( 'lw-hidden' ); } cellsNearContainerElement.classList.remove( 'lw-hidden' ); cellsFarContainerElement.classList.remove( 'lw-hidden' ); if ( cellsNearContainerElement.style.width !== nearWidth + 'px' ) { cellsNearContainerElement.style.width = nearWidth + 'px'; } if ( cellsCenterContainerElement.style.width !== centerWidth + 'px' ) { cellsCenterContainerElement.style.width = centerWidth + 'px'; } if ( cellsFarContainerElement.style.width !== farWidth + 'px' ) { cellsFarContainerElement.style.width = farWidth + 'px'; } cellsNearContainerElement.style.height = row.cellHeight + 'px'; cellsCenterContainerElement.style.height = row.cellHeight + 'px'; cellsFarContainerElement.style.height = row.cellHeight + 'px'; if ( farWidth === 0 ) { cellsFarContainerElement.classList.add( 'lw-hidden' ); } if ( nearWidth === 0 ) { cellsNearContainerElement.classList.add( 'lw-hidden' ); } if ( nearWidth > 0 && parseInt( nearWidth ) === parseInt( grid._autoGeneratedColumnsNearWidth ) ) { // cellsNearContainerElement.classList.add('border-collapse'); } if ( farWidth > 0 && parseInt( farWidth ) === parseInt( grid._autoGeneratedColumnsFarWidth ) ) { cellsFarContainerElement.classList.add( 'border-collapse' ); } for ( let j = 0; j < grid._frozenNearColumns.length; j++ ) { const column = grid._frozenNearColumns[ j ]; let cellElement = that.children[ 0 ].children[ j ]; if ( !cellElement ) { const cell = row.getCell( column ); cellElement = cell.createElement(); that.children[ 0 ].appendChild( cellElement ); } that._renderCell( row, column, cellElement ); } for ( let j = 0; j < grid._frozenFarColumns.length; j++ ) { const column = grid._frozenFarColumns[ j ]; let cellElement = that.children[ 2 ].children[ j ]; if ( !cellElement ) { const cell = row.getCell( column ); cellElement = cell.createElement(); that.children[ 2 ].appendChild( cellElement ); } that._renderCell( row, column, cellElement ); } for ( let j = 0; j < cellsCenterContainerElement.children.length; j++ ) { const columnElement = grid._columnElements[ j + grid._frozenNearColumns.length ]; if ( !columnElement ) { let cellElement = that.children[ 1 ].children[ j ]; that._renderCell( row, null, cellElement ); } } for ( let j = 0; j < grid._columnElements.length; j++ ) { const columnElement = grid._columnElements[ j ]; const column = columnElement.column; if ( !columnElement.parentNode || !column ) { if ( columnElement && !column ) { let cellElement = that.children[ 1 ].children[ j ]; if ( cellElement ) { cellElement.classList.add( 'lw-visibility-hidden' ); } } continue; } let cellElement = that.children[ 1 ].children[ j ]; if ( !cellElement ) { if ( !columnElement.column ) { columnElement.column = column; } const cell = row.getCell( column ); cellElement = cell.createElement(); that.children[ 1 ].appendChild( cellElement ); } if ( columnElement.classList.contains( 'lw-visibility-hidden' ) ) { cellElement.classList.add( 'lw-visibility-hidden' ); continue; } else { cellElement.classList.remove( 'lw-visibility-hidden' ); } that._renderCell( row, column, cellElement ); } if ( !that.visible ) { that.classList.add( 'lw-hidden' ); } else { that.classList.remove( 'lw-hidden' ); } } template() { return ''; } _detach() { const that = this; that.row.headerCell = null; that.row._cells = []; that.row = null; delete that.row; that.element = null; that.removeEventListener( 'mouseenter', that._mouseEnter ); that.removeEventListener( 'mouseleave', that._mouseLeave ); delete that.element; delete that.grid; delete that._mouseEnter; delete that._mouseLeave; delete that.cellsNearContainerElement; delete that.cellsContainerElement; delete that.cellsFarContainerElement; delete that.rowDetail; delete that.rowContainer; } onDetached() { const that = this; that._detach(); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Cell', class Cell { constructor ( row, column ) { const that = this; that.row = row; that.column = column; that.grid = row.grid; that.rowSpan = 1; that.colSpan = 1; that.value = undefined; that.fontSize = null; that.fontWeight = null; that.fontFamily = null; that.fontStyle = null; that.color = null; that.background = null; that.borderColor = null; that.tooltip = null; that.align = null; that.verticalAlign = null; that.readonly = false; that.oldValue = undefined; that._updating = false; that.styleChanged = true; that.editor = null; that.template = null; that.isEditing = false; that.canNotify = true; that.selected = false; that.focused = false; const proxy = new Proxy( that, { deleteProperty: function ( target, property ) { delete target[ property ]; return true; }, get: function ( target, property ) { if ( property === 'value' ) { const cellValue = !that.column.displayField ? that.row.data[ that.column.dataField ] : that.row.data[ that.column.displayField ]; return cellValue; } else if ( property === 'editor' || property === 'template' ) { return target[ property ] || that.column[ property ]; } else if ( property === 'focused' ) { if ( that.grid.selection.allowCellSelection && that.grid._selection.focusedCell && that.grid._selection.focusedCell.row.id === that.row.id && that.grid._selection.focusedCell.column.dataField === that.column.dataField ) { return true; } if ( that.grid.selection.allowRowSelection && that.grid._selection.focusedCell && that.grid._selection.focusedCell.row.id === that.row.id && that.grid._selection.focusedCell.column.dataField === that.column.dataField ) { return true; } const parent = that.parent(); if ( parent && that.grid.selection.allowCellSelection && that.grid._selection.focusedCell && that.grid._selection.focusedCell.row.id === parent.row.id && that.grid._selection.focusedCell.column.dataField === parent.column.dataField ) { return true; } return false; } if ( property === 'selected' ) { if ( that.row.getProperty( 'selected' ) === true ) { return true; } if ( that.column.getProperty( 'selected' ) === true ) { return true; } return that.grid._selection.cells[ 'row' + that.row.id ] ? that.grid._selection.cells[ 'row' + that.row.id ][ that.column.dataField ] : false; } else if ( property === 'modifiedValue' ) { const tempValue = that.grid._cellsUpdatedValues[ that.row.id + '_' + that.column.dataField ]; if ( tempValue !== undefined ) { return tempValue; } return target[ 'value' ]; } return target[ property ]; }, set: function ( target, propertyName, value ) { const oldValue = this.get( target, propertyName ); if ( oldValue === value ) { return true; } target[ propertyName ] = value; if ( propertyName === 'element' || propertyName === 'isEditing' || propertyName === 'oldValue' || propertyName === '_updating' || propertyName === 'notifyFn' || propertyName.startsWith( '_' ) || propertyName === 'canNotify' ) { return true; } if ( propertyName === 'focused' ) { that.grid._selection.focusedCell = that; } if ( propertyName === 'colSpan' || propertyName === 'rowSpan' ) { if ( value >= 0 && that.grid._cellsMerge.indexOf( that ) === -1 ) { that.grid._cellsMerge.push( that ); } } if ( propertyName === 'row' || propertyName === 'column' || propertyName === 'grid' || propertyName === 'styleChanged' ) { return true; } if ( propertyName === 'background' || propertyName === 'fontSize' || propertyName === 'fontWeight' || propertyName === 'fontFamily' || propertyName === 'color' || propertyName === 'borderColor' || propertyName === 'fontStyle' ) { that._styleChanged = true; } if ( propertyName === 'value' ) { if ( that.oldValue === undefined ) { that.oldValue = oldValue; } const updateCellValue = () => { that.grid.dataSource.boundSource.canNotify = false; if ( value !== null && value.label && value.value ) { that.row.data[ that.column.displayField ] = value.label; that.row.data[ that.column.dataField ] = value.value; } else { if ( that.column.valueField ) { that.row.data[ that.column.valueField ] = value; } that.row.data[ that.column.dataField ] = value; } const dataItem = that.grid.dataSource.dataItemById[ that.row.id ]; if ( dataItem ) { const index = dataItem.$.index; if ( value !== that.grid.dataSource[ index ][ that.column.dataField ] ) { that.grid.dataSource[ index ][ that.column.dataField ] = value; } } that.grid.dataSource.boundSource.canNotify = true; } updateCellValue(); } if ( propertyName === 'selected' ) { if ( that.grid._selection.cells[ 'row' + that.row.id ] ) { delete that.grid._selection.cells[ 'row' + that.row.id ][ that.column.dataField ]; if ( Object.getOwnPropertyNames( that.grid._selection.cells[ 'row' + that.row.id ] ).length === 1 ) { delete that.grid._selection.cells[ 'row' + that.row.id ]; } } if ( that.grid._selection.cells[ 'column' + that.column.dataField ] ) { delete that.grid._selection.cells[ 'column' + that.column.dataField ][ that.row.id ]; if ( Object.getOwnPropertyNames( that.grid._selection.cells[ 'column' + that.column.dataField ] ).length === 1 ) { delete that.grid._selection.cells[ 'column' + that.column.dataField ]; } } if ( value ) { if ( !that.grid._selection.cells[ 'row' + that.row.id ] ) { that.grid._selection.cells[ 'row' + that.row.id ] = []; } if ( !that.grid._selection.cells[ 'column' + that.column.dataField ] ) { that.grid._selection.cells[ 'column' + that.column.dataField ] = []; } that.grid._selection.cells[ 'row' + that.row.id ][ that.column.dataField ] = true; that.grid._selection.cells[ 'column' + that.column.dataField ][ that.row.id ] = true; } } if ( that._updating || !that.canNotify ) { return true; } if ( !that.row.canNotify ) { return true; } that.grid._recycle(); if ( that.propertyChanged ) { that.propertyChanged( name.substring( 1 ), oldValue/*, newValue*/ ); } return true; } } ); return proxy; } setStyle( element ) { const that = this; if ( that._styleChanged ) { element.style.background = that.background; element.style.borderColor = that.borderColor; element.style.color = that.color; element.style.fontSize = that.fontSize; element.style.fontFamily = that.fontFamily; element.style.fontWeight = that.fontWeight; element.style.fontStyle = that.fontStyle; element.style.paddingBottom = ''; that._styleChanged = false; } } getFormattedValue( value, format ) { const that = this; if ( value === undefined || value === null || value === '' ) { return value; } if (!format) { return '' + value; } if ( that.column.dataType === 'date' || that.column.dataType === 'datetime' || that.column.dataType === 'time' ) { return that.formatDate( value, format ); } if ( that.column.dataType === 'int' || that.column.dataType === 'int64' || that.column.dataType === 'float' || that.column.dataType === 'number' ) { return that.formatNumber( value, format ); } return value; } /** * Formats a date. */ formatDate( value, format ) { if ( !LW.Utilities.DateTime ) { return value; } const that = this; const grid = that.grid; if ( that.column.formatSettings.Intl && that.column.formatSettings.Intl.DateTimeFormat ) { const formattedValue = new Intl.DateTimeFormat( this.grid.locale, that.column.formatSettings.Intl.DateTimeFormat ).format( value ); return formattedValue; } if ( !format && that.column.formatSettings.dateFormat ) { format = that.column.formatSettings.dateFormat; } try { const date = new LW.Utilities.DateTime( value ); date.calendar.locale = grid.locale; if ( grid.messages[ grid.locale ] && grid.messages[ grid.locale ].calendar ) { if ( grid.messages[ grid.locale ].calendar.months ) { date.calendar.months = grid.messages[ grid.locale ].calendar.months; } if ( grid.messages[ grid.locale ].calendar.days ) { date.calendar.days = grid.messages[ grid.locale ].calendar.days; } if ( grid.messages[ grid.locale ].calendar.firstDay !== undefined ) { date.calendar.firstDay = grid.messages[ grid.locale ].calendar.firstDay; } if ( grid.messages[ grid.locale ].calendar.eras !== undefined ) { date.calendar.eras = grid.messages[ grid.locale ].calendar.eras; } if ( grid.messages[ grid.locale ].calendar.AM !== undefined ) { date.calendar.AM = grid.messages[ grid.locale ].calendar.AM; } if ( grid.messages[ grid.locale ].calendar.PM !== undefined ) { date.calendar.PM = grid.messages[ grid.locale ].calendar.PM; } if ( grid.messages[ grid.locale ].calendar[ '/' ] !== undefined ) { date.calendar[ '/' ] = grid.messages[ grid.locale ].calendar[ '/' ]; } if ( grid.messages[ grid.locale ].calendar[ ':' ] !== undefined ) { date.calendar[ ':' ] = grid.messages[ grid.locale ].calendar[ ':' ]; } } return date.toString( format ); } catch ( e ) { return value; } } /** * Formats a number. */ formatNumber( value, format ) { if ( !LW.Utilities.NumberRenderer ) { return value; } const that = this; const grid = that.grid; if ( that.column.formatSettings.Intl && that.column.formatSettings.Intl.NumberFormat ) { const formattedValue = new Intl.NumberFormat( this.grid.locale, that.column.formatSettings.Intl.NumberFormat ).format( value ); return formattedValue; } const renderer = new LW.Utilities.NumberRenderer(); if ( renderer.localizationObject ) { const formatSettings = that.column.formatSettings; const calendar = grid.messages[ grid.locale ] ? grid.messages[ grid.locale ].calendar : {}; if ( formatSettings.decimalPlaces ) { renderer.localizationObject.decimalPlaces = formatSettings.decimalPlaces; } if ( formatSettings.decimalSeparator || calendar.decimalSeparator ) { renderer.localizationObject.decimalSeparator = formatSettings.decimalSeparator || calendar.decimalSeparator; } if ( formatSettings.thousandsSeparator || calendar.thousandsSeparator ) { renderer.localizationObject.thousandsSeparator = formatSettings.thousandsSeparator || calendar.thousandsSeparator; } renderer.localizationObject.currencysymbol = calendar.currencySymbol; renderer.localizationObject.currencysymbolposition = calendar.currencySymbolPosition; if ( formatSettings.prefix ) { renderer.localizationObject.currencysymbol = formatSettings.prefix; } if ( formatSettings.sufix ) { renderer.localizationObject.currencysymbol = formatSettings.sufix; renderer.localizationObject.currencysymbolposition = 'after'; } } const output = renderer.formatNumber( value, format ); if ( output === undefined ) { return value; } if ( value < 0 && that.column.formatSettings.negativeWithBrackets ) { return '(' + output + ')'; } return output; } refresh() { const that = this; if ( that.element ) { const htmlCellContent = that.element.firstChild; that.setStyle( htmlCellContent ); } } setProperties( properties ) { const that = this; that._updating = true; for ( let propertyName in properties ) { that[ propertyName ] = properties[ propertyName ]; } that._updating = false; that.grid._recycle(); } createElement() { const that = this; const element = document.createElement( 'lw-grid-cell' ); element.setAttribute( 'role', 'gridcell' ); that.element = element; element._initialize( that ); return element; } render() { const that = this; if ( !that.element ) { return; } that.element._render(); } parent( getSiblingsData ) { const that = this; const row = that.row; const dataField = that.column.dataField; const grid = that.grid; if ( !grid._cellsMerge.length ) { return null; } if ( that.__parentCells ) { if ( that.__parentCells[ 'row' + row.id + '_column_' + dataField ] !== undefined ) { return that.__parentCells[ 'row' + row.id + '_column_' + dataField ]; } } let visibleRows = grid.getVisibleRows(); if ( grid.paging.enabled && grid.selection.selectAllMode === 'page' ) { visibleRows = visibleRows.slice( grid.paging.pageIndex * grid.paging.pageSize, ( grid.paging.pageIndex + 1 ) * grid.paging.pageSize ); } if ( !that.__parentCells ) { that.__parentCells = []; } for ( let i = 0; i < grid._cellsMerge.length; i++ ) { const cell = grid._cellsMerge[ i ]; let rows = []; let columns = []; rows.push( cell.row ); if ( cell.rowSpan > 1 ) { const startRowIndex = visibleRows.indexOf( cell.row ); if ( startRowIndex >= 0 ) { for ( let r = startRowIndex; r < startRowIndex + cell.rowSpan; r++ ) { if ( visibleRows[ r ] && rows.indexOf( visibleRows[ r ] ) === -1 ) { rows.push( visibleRows[ r ] ); } } } } columns.push( cell.column.dataField ); if ( cell.colSpan > 1 ) { const startColumnIndex = grid.columns.indexOf( grid.columnByDataField[ cell.column.dataField ] ); for ( let r = startColumnIndex; r < startColumnIndex + cell.colSpan; r++ ) { if ( grid.columns[ r ] && columns.indexOf( grid.columns[ r ].dataField ) === -1 ) { columns.push( grid.columns[ r ].dataField ); } } } if ( rows.indexOf( row ) >= 0 && columns.indexOf( dataField ) >= 0 ) { if ( getSiblingsData ) { const parentCell = { cell: cell.row.getCell( cell.column.dataField ), rows: rows, columns: columns, row: cell.row, column: cell.column, endRow: rows[ rows.length - 1 ], endColumn: grid.columnByDataField[ columns[ columns.length - 1 ] ] }; that.__parentCells[ 'row' + row.id + '_column_' + dataField ] = parentCell; return parentCell; } const parentCell = cell.row.getCell( cell.column.dataField ); that.__parentCells[ 'row' + row.id + '_column_' + dataField ] = parentCell; return parentCell; } } that.__parentCells[ 'row' + row.id + '_column_' + dataField ] = null; return null; } } ); LW( 'lw-grid-cell', class Cell extends LW.BaseElement { static get properties() { return { } } get hasStyleObserver() { return false; } get enableShadowDOM() { return false; } addThemeClass() { } addDefaultClass() { } get isUtilityElement() { return true; } _refresh() { const that = this; that.innerHTML = ''; that._initialize( that.cell ); } _initialize( cell ) { const that = this; const content = document.createElement( 'div' ); const column = cell.column; const row = cell.row; const grid = cell.grid; that.cell = cell; that.appendChild( content ); let shouldAddToggleButton = false; if ( column && column._treeColumn && grid.dataSource.boundHierarchy ) { shouldAddToggleButton = true; if ( !grid.grouping.enabled && grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0 ) { shouldAddToggleButton = false; } } if ( shouldAddToggleButton ) { const indent = document.createElement( 'div' ); const button = document.createElement( 'button' ); const label = document.createElement( 'div' ); const container = document.createElement( 'div' ); const checkbox = document.createElement( 'div' ); const checkboxInput = document.createElement( 'span' ); if ( row.expanded ) { button.setAttribute( 'toggled', '' ); } else { button.removeAttribute( 'toggled', '' ); } that.toggleButton = button; that.checkbox = checkbox; content.appendChild( indent ); content.appendChild( container ); container.setAttribute( 'content', '' ); indent.setAttribute( 'indent', '' ); label.setAttribute( 'label', '' ); button.setAttribute( 'toggle-button', '' ); checkbox.setAttribute( 'checkbox', '' ); checkbox.setAttribute( 'role', 'checkbox' ); that.setAttribute( 'has-toggle-button', '' ); container.appendChild( button ); container.appendChild( checkbox ); checkboxInput.classList.add( 'lw-input' ); checkbox.appendChild( checkboxInput ); if ( grid.checkBoxes.visible ) { checkboxInput.classList.remove( 'lw-hidden' ); } else { checkboxInput.classList.add( 'lw-hidden' ); } container.appendChild( label ); that.content = label; that.isRendered = true; return; } else { const label = document.createElement( 'div' ); content.appendChild( label ); } that.content = content; that.isRendered = true; } _renderCommands() { const that = this; const grid = that.cell.grid; if ( grid.__cellsCommandTemplate ) { that.firstChild.innerHTML = grid.__cellsCommandTemplate; grid._updateCommandColumnCommandsVisibility( that.firstChild, that.cell.row ); return; } const commandHTML = grid._getCommandColumnCommandsTemplate(); that.firstChild.innerHTML = commandHTML; grid._updateCommandColumnCommandsVisibility( that.firstChild, that.cell.row ); grid.__cellsCommandTemplate = commandHTML; } _renderGroupCell() { const that = this; const grid = that.cell.grid; const column = that.cell.column; const row = that.cell.row; //const data = row.data; [ ...that.attributes ].forEach( attr => that.removeAttribute( attr.name ) ); that.setAttribute( 'group', '' ); if ( that.style.width !== column.computedWidth + 'px' ) { that.style.width = column.computedWidth + 'px'; } if ( !grid.rightToLeft ) { if ( that.style.left !== column.left + 'px' ) { that.style.left = column.left + 'px'; } } else { if ( that.style.right !== column.left + 'px' ) { that.style.right = column.left + 'px'; } } if ( that.classList.contains( 'lw-hidden' ) ) { that.classList.remove( 'lw-hidden' ); } if ( column.autoGenerated ) { that.style.width = '0px'; } let cellValue = row.label; const getAllSubRows = function ( dataField, rows, subRows ) { for ( let i = 0; i < rows.length; i++ ) { const row = rows[ i ]; if ( row[ dataField ] !== undefined ) { subRows.push( row ); } if ( row.summaryRow ) { continue; } if ( row[ 'children' ] ) { getAllSubRows( dataField, row[ 'children' ], subRows ); } else if ( row.data && row.data[ 'children' ] ) { getAllSubRows( dataField, row[ 'children' ], subRows ); } } return subRows; } if ( row.label !== undefined ) { let summary = ''; let summaryValue = []; if ( grid.grouping.summaryRow.visible ) { const subRows = getAllSubRows( column.dataField, row.summaryRow ? row.parent.data[ 'children' ] : row.data[ 'children' ], [] ); const summaryObject = { }; const summaryFunctions = column._treeColumn ? ( column.summary.length > 0 ? column.summary : [ 'count' ] ) : column.summary; summaryObject[ column.dataField ] = summaryFunctions; const summaryResult = summaryFunctions.length > 0 ? grid.dataSource.summarize( [ summaryObject ], subRows ) : null; if ( summaryResult ) { for ( let i = 0; i < summaryFunctions.length; i++ ) { const summaryFunction = summaryFunctions[ i ]; if ( grid.grouping.renderMode === 'advanced' ) { summary += '<span summary>' + grid.localize( summaryFunction, {value: summaryResult[ column.dataField ][ summaryFunction ]} ); + '</span>'; } else { if ( i > 0 ) { summary += ', '; } let formattedValue = summaryResult[ column.dataField ][ summaryFunction ]; const cellsFormat = column.cellsFormat; if ( cellsFormat ) { formattedValue = that.cell.getFormattedValue( formattedValue, cellsFormat ); } summary += grid.localize( summaryFunction, {value: formattedValue} ); } summaryValue.push( summaryResult[ column.dataField ][ summaryFunction ] ); } } } if ( column._treeColumn ) { const column = grid.columnByDataField[ row.groupDataField ]; const groupLabel = column ? column.label : ''; if ( grid.grouping.renderMode === 'advanced' ) { if ( !row.summaryRow ) { cellValue = '<div header><span group>' + groupLabel + '</span><span value>' + row.label + '</span></div>'; } else { cellValue = '<div header><span group></span><span value></span></div>'; } if ( summary ) { cellValue += '<div summary>'; cellValue += summary; cellValue += '</div>'; } } else if ( grid.grouping.renderMode === 'compact' ) { if ( !row.summaryRow ) { cellValue = '<div header><span group>' + groupLabel + ': </span><span value>' + row.label + '</span>'; if ( summary && grid.grouping.summaryRow.inline ) { cellValue += '<span summary>'; cellValue += ' (' + summaryValue + ')'; cellValue += '</span>'; } } else { cellValue = '<div header><span group></span><span value></span>'; if ( summary ) { cellValue += '<div summary>'; cellValue += summary; cellValue += '</div>'; } } cellValue += '</div>'; that.classList.add( 'lw-grid-column-border-collapse' ); } else if ( grid.grouping.renderMode === 'basic' ) { cellValue = row.label; if ( !row.summaryRow ) { if ( summary && grid.grouping.summaryRow.inline ) { cellValue += '<span summary>'; cellValue += ' (' + summaryValue + ')'; cellValue += '</span>'; } } else { if ( summary ) { cellValue += '<div summary>'; cellValue += summary; cellValue += '</div>'; } } that.classList.add( 'lw-grid-column-border-collapse' ); } that.setAttribute( 'has-toggle-button', '' ); } else { that.removeAttribute( 'has-toggle-button', '' ); if ( grid.grouping.renderMode === 'advanced' ) { cellValue = '<div content><div label><div header><span group></span><span value></span></div>'; if ( summary ) { cellValue += '<div summary>'; cellValue += summary; cellValue += '</div>'; } cellValue += '</div></div>'; } else { cellValue = summary; } } } const htmlCellContent = that.firstChild; if ( grid.dataSource.boundHierarchy && column._treeColumn ) { const indent = htmlCellContent.children[ 0 ]; const toggleButton = htmlCellContent.children[ 1 ].children[ 0 ]; const checkbox = htmlCellContent.children[ 1 ].children[ 1 ].firstChild; const content = htmlCellContent.children[ 1 ].children[ 2 ]; indent.setAttribute( 'indent', '' ); if ( row.checked ) { checkbox.setAttribute( 'checked', '' ); } else if ( row.checked === false ) { checkbox.removeAttribute( 'checked' ); } else if ( row.checked === null ) { checkbox.setAttribute( 'checked', 'indeterminate' ); } if ( !row.leaf ) { toggleButton.classList.remove( 'lw-visibility-hidden' ); if ( row.expanded ) { toggleButton.setAttribute( 'toggled', '' ); } else { toggleButton.removeAttribute( 'toggled', '' ); } } else { toggleButton.classList.add( 'lw-visibility-hidden' ); } let indentDiv = ''; if ( !column._treeColumn ) { that.toggleButton.classList.add( 'lw-hidden' ); } else { that.toggleButton.classList.remove( 'lw-hidden' ); } if ( column._treeColumn ) { if ( grid.grouping.enabled && grid.dataSource.groupBy.length > 0 && grid.grouping.renderMode === 'advanced' ) { let level = row.level; if ( undefined === row.label ) { level--; } indentDiv += '<div style="width: ' + ( 1 + level ) * grid.grouping.groupIndent + 'px;"></div>'; } else { for ( let i = 0; i < row.level; i++ ) { indentDiv += '<div class=\'lw-indent\'></div>'; } } } if ( undefined === row.label ) { toggleButton.classList.add( 'lw-hidden' ); } else { toggleButton.classList.remove( 'lw-hidden' ); toggleButton.style.marginLeft = ''; if ( column._treeColumn && grid.grouping.enabled && grid.grouping.toggleButtonIndent > 0 && grid.grouping.renderMode === 'advanced' ) { toggleButton.style.marginLeft = row.level * ( grid.grouping.toggleButtonIndent - grid.grouping.groupIndent ) + 'px'; } } indent.innerHTML = indentDiv; content.innerHTML = cellValue; if ( grid.appearance.showTooltips ) { content.setAttribute( 'title', row.label ? row.label : cellValue ); } else if ( content.hasAttribute( 'title' ) ) { content.removeAttribute( 'title' ); } } else if ( row.label !== undefined && grid.grouping.enabled && !column._treeColumn ) { htmlCellContent.innerHTML = cellValue; } if ( grid.grouping.enabled && grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0 && grid.grouping.renderMode === 'advanced' ) { const indent = grid.grouping.groupIndent * ( 1 + row.level ); if ( column.dataField === grid.columns[ grid.columns.length - 1 ].dataField ) { that.style.width = column.computedWidth - indent + 'px'; if ( grid.appearance.showColumnLines ) { htmlCellContent.firstChild.classList.add( 'lw-grid-column-border' ); } } } let cellContentClassName = 'lw-label'; that.style.zIndex = ''; if ( grid.grouping.renderMode !== 'advanced' && column._treeColumn ) { const groupColumn = grid.columnByDataField[ row.groupDataField ]; if ( groupColumn.cellsAlign ) { cellContentClassName += ' align-' + groupColumn.cellsAlign; } if ( groupColumn.cellsVerticalAlign ) { cellContentClassName += ' align-' + groupColumn.cellsVerticalAlign; } that.setAttribute( 'header', '' ); if ( !row.summaryRow ) { that.style.width = '100%'; } that.style.zIndex = 100; } if ( row.summaryRow ) { that.setAttribute( 'header', '' ); that.classList.add( 'lw-grid-column-border-collapse' ); if ( column.cellsAlign ) { cellContentClassName += ' align-' + column.cellsAlign; } if ( column.cellsVerticalAlign ) { cellContentClassName += ' align-' + column.cellsVerticalAlign; } } if ( htmlCellContent.className !== cellContentClassName ) { htmlCellContent.className = cellContentClassName; } if ( column.formatFunction ) { const formatObject = { row: row, column: column, cell: that.cell, value: null, template: null, group: { value: cellValue, template: null } }; column.formatFunction( formatObject ); if ( formatObject.group.value !== cellValue ) { htmlCellContent.innerHTML = formatObject.group.value; } if ( formatObject.group.template !== null ) { htmlCellContent.innerHTML = formatObject.group.template; } } } _renderFilterCell( element ) { const that = this; const grid = that.cell.grid; const column = that.cell.column; let dataSource; const clickCommand = ( column, properties ) => { grid._handleFilterMenuClick(column, properties); } if ( !grid._filterInfo ) { grid._filterInfo = {}; grid._filterInfo.stringConditions = [ {icon: 'lw-icon-contains', command: clickCommand, value: 'CONTAINS', label: grid.localize( 'CONTAINS' )}, {icon: 'lw-icon-does-not-contain', command: clickCommand, value: 'DOES_NOT_CONTAIN', label: grid.localize( 'DOES_NOT_CONTAIN' )}, {icon: 'lw-icon-starts-with', command: clickCommand, value: 'STARTS_WITH', label: grid.localize( 'STARTS_WITH' )}, {icon: 'lw-icon-ends-with', command: clickCommand, value: 'ENDS_WITH', label: grid.localize( 'ENDS_WITH' )}, {icon: 'lw-icon-equals', command: clickCommand, value: 'EQUAL', label: grid.localize( 'EQUAL' )}, {icon: 'lw-icon-delete', command: clickCommand, value: 'CLEAR_FILTER', label: grid.localize( 'CLEAR_FILTER' )} ]; grid._filterInfo.numberAndDateConditions = [ {icon: 'lw-icon-equals', command: clickCommand, value: 'EQUAL', label: grid.localize( 'EQUAL' )}, {icon: 'lw-icon-not-equal', command: clickCommand, value: 'NOT_EQUAL', label: grid.localize( 'NOT_EQUAL' )}, {icon: 'lw-icon-less-than', command: clickCommand, value: 'LESS_THAN', label: grid.localize( 'LESS_THAN' )}, {icon: 'lw-icon-less-than-equal', command: clickCommand, value: 'LESS_THAN_OR_EQUAL', label: grid.localize( 'LESS_THAN_OR_EQUAL' )}, {icon: 'lw-icon-greater-than', command: clickCommand, value: 'GREATER_THAN', label: grid.localize( 'GREATER_THAN' )}, {icon: 'lw-icon-greater-than-equal', command: clickCommand, value: 'GREATER_THAN_OR_EQUAL', label: grid.localize( 'GREATER_THAN_OR_EQUAL' )}, {icon: 'lw-icon-between', command: clickCommand, value: 'RANGE', label: grid.localize( 'RANGE' )}, {icon: 'lw-icon-delete', command: clickCommand, value: 'CLEAR_FILTER', label: grid.localize( 'CLEAR_FILTER' )} ]; } if ( column.dataType === 'string' ) { dataSource = grid._filterInfo.stringConditions; } else { dataSource = grid._filterInfo.numberAndDateConditions; } let columnIcon = 'lw-icon-search'; if ( !column._filterInfo ) { column._filterInfo = { condition: '' }; } if (column.filterEditor && column.filterEditor.condition) { column._filterInfo.condition = column.filterEditor.condition; } if (column.filterEditor && column.filterEditor.value) { column._filterInfo.value = column.filterEditor.value; } column._filterInfo.dataSource = dataSource; switch ( column._filterInfo.condition.toLowerCase() ) { case 'equal': { columnIcon = 'lw-icon-equals'; break; } case 'starts_with': { columnIcon = 'lw-icon-starts-with'; break; } case 'ends_with': { columnIcon = 'lw-icon-ends-with'; break; } case 'not_equal': { columnIcon = 'lw-icon-not-equal'; break; } case 'less_than': { columnIcon = 'lw-icon-less-than'; break; } case 'less_than_or_equal': { columnIcon = 'lw-icon-less-than-or-equal'; break; } case 'greater_than': { columnIcon = 'lw-icon-greater-than'; break; } case 'greater_than_or_equal': { columnIcon = 'lw-icon-greater-than-or-equal'; break; } case 'contains': { columnIcon = 'lw-icon-contains'; break; } case 'does_not_contain': { columnIcon = 'lw-icon-does-not-contain'; break; } case 'range': { columnIcon = 'lw-icon-between'; break; } default: { columnIcon = 'lw-icon-search'; } } let template = `<div class="lw-filter-input-type"><i class="lw-grid-icon ${columnIcon} show"></i></div>`; if ( column.dataType === 'string' ) { template += `<input class="lw-filter-input-value" data-type="${column.dataType}"/>`; element.innerHTML = template; } else if ( column.dataType === 'date' ) { const date = new LW.Utilities.DateTime(); const format = date.expandFormat( date.calendar, column.cellsFormat || 'd' ); template += `<input placeholder="${format}" class="lw-filter-input-value" data-type="${column.dataType}"/><div class="lw-filter-input-type"><i class="lw-grid-icon lw-icon-calendar show"></i></div>`; element.innerHTML = template; element.lastElementChild.onpointerdown = function () { grid._handleFilterCalendarCellClick(that.cell); } } else if ( column.dataType === 'number' ) { template += '<div class="lw-grid-cell-editor lw-filter-input-value lw-grid-number-input-cell-editor"><input class="lw-input" type="number"><div tabindex="-1" class="nav"><div tabindex="-1" class="up"></div><div tabindex="-1" class="down"></div></div></div>'; element.innerHTML = template; grid._handleFilterNumberCellEditor(this.cell, element); } else if (column.dataType === 'boolean') { const checkbox = document.createElement( 'div' ); checkbox.classList.add( 'lw-input' ); checkbox.classList.add( 'lw-grid-check-box-cell-editor' ); checkbox.classList.add( 'lw-filter-input-value' ); element.tabIndex = 0; element.style.outline = 'none'; that.setAttribute('template', 'checkBox'); checkbox.setAttribute('checked', 'indeterminate') template = checkbox.outerHTML; element.innerHTML = template; element.classList.add('align-center'); element.classList.add('lw-label'); element.onfocus = () => { element.setAttribute('focus', ''); } element.onblur = () => { element.removeAttribute('focus', ''); } element.onclick = (event) => { if (event.target.classList.contains('lw-input')) { grid._handleFilterCellCheckBoxClick(this.cell); } } } const input = element.querySelector( 'input' ); if (input) { element.firstElementChild.onpointerdown = function ( ) { grid._handleFilterCellIconClick(this.cell); }.bind(this); input.onfocus = function ( ) { grid._handleFilterCellFocus(this.cell); }.bind(this); input.onblur = function ( ) { grid._handleFilterCellBlur(this.cell); }.bind(this); input.onkeyup = function (event) { grid._handleFilterCellKeyUp(this.cell, event); }.bind(this); input.onkeydown = function (event) { grid._handleFilterCellKeyDown(this.cell, event); }.bind(this); } element.classList.add( 'lw-filter-input-container' ); column._filterInfo.input = input; column._filterInfo.cell = that.cell; column._filterInfo.editor = element; if (!column.allowFilter) { input.disabled = true; } if (column.filterEditor) { if (column.filterEditor.template) { const template = column.filterEditor.template; const cellContent = document.createElement( 'div' ); if ( column.filterTemplate instanceof HTMLTemplateElement ) { cellContent.appendChild( template.content.cloneNode( true ) ); } else if (template instanceof HTMLElement) { cellContent.appendChild( template ); } else { cellContent.innerHTML = template; } element.innerHTML = ''; element.appendChild(cellContent); cellContent.style.height = '100%'; cellContent.style.width = '100%'; const input = element.querySelector('input'); if (input) { input.onfocus = () => { element.setAttribute('focus', ''); } input.onblur = () => { element.removeAttribute('focus', ''); } } if (column.filterEditor.onInit) { column.filterEditor.onInit( column, cellContent ); } } else { if (column.filterEditor.min !== undefined) { input.min = column.filterEditor.min; } if (column.filterEditor.max !== undefined) { input.max = column.filterEditor.max; } if (column.filterEditor.minlength !== undefined) { input.minlength = column.filterEditor.minlength; } if (column.filterEditor.maxlength !== undefined) { input.maxlength = column.filterEditor.maxlength; } if (column.filterEditor.placeholder !== undefined) { input.placeholder = column.filterEditor.placeholder; } if (column.filterEditor.value !== undefined) { input.value = column.filterEditor.value; } if (column.filterEditor.step !== undefined) { input.step = column.filterEditor.step; } if (column.filterEditor.disabled !== undefined) { input.disabled = column.filterEditor.disabled; } if (column.filterEditor.condition !== undefined) { column._filterInfo.condition = column.filterEditor.condition; } if (column.filterEditor.onInit) { column.filterEditor.onInit( column, element ); } } } } _render() { const that = this; const grid = that.cell.grid; const column = that.cell.column; const row = that.cell.row; const data = row.data; const cellsFormat = !row._isMeasureRow ? column.cellsFormat : null; if ( grid.grouping.enabled && grid.dataSource.groupBy.length > 0 && row.label !== undefined ) { that._renderGroupCell(); return; } if ( grid.grouping.enabled && grid.dataSource.groupBy.length > 0 && that.toggleButton ) { that.toggleButton.classList.remove( 'lw-hidden' ); that.toggleButton.classList.remove( 'lw-visibility-hidden' ); that.toggleButton.style.marginLeft = ''; if ( column._treeColumn && grid.grouping.enabled && grid.grouping.toggleButtonIndent > 0 ) { that.toggleButton.style.marginLeft = row.level * ( grid.grouping.toggleButtonIndent - grid.grouping.groupIndent ) + 'px'; } } if ( grid.grouping.enabled && grid.dataSource.groupBy.length > 0 ) { that.removeAttribute( 'header' ); that.removeAttribute( 'group' ); } if ( !column.visible ) { that.style.width = '0px'; return; } if ( grid.appearance.showSortColumnBackground ) { column.sorted ? that.setAttribute( 'sort', '' ) : that.removeAttribute( 'sort' ); } else if ( column.sorted && that.hasAttribute( 'sort' ) ) { that.removeAttribute( 'sort' ); } if ( grid.appearance.showFilterColumnBackground ) { column.filtered ? that.setAttribute( 'filter', '' ) : that.removeAttribute( 'filter' ); } else if ( column.filtered && that.hasAttribute( 'filter' ) ) { that.removeAttribute( 'filter' ); } if ( grid.dataSource.boundHierarchy && that.hasAttribute( 'has-toggle-button' ) && !column._treeColumn ) { that.removeAttribute( 'has-toggle-button' ); } let cellValue = !column.displayField ? data[ column.dataField ] : data[ column.displayField ]; that.removeAttribute( 'highlight' ); if (grid.highlighted === row.id) { that.setAttribute('highlight', ''); } if ( grid.editing.batch ) { if ( grid._cellsUpdatedValues ) { that.removeAttribute( 'update' ); const tempValue = grid._cellsUpdatedValues[ row.id + '_' + column.dataField ]; if ( tempValue !== undefined ) { that.setAttribute( 'update', '' ); cellValue = tempValue; } } if ( grid._rowsDeleted ) { if ( grid._rowsDeleted.indexOf( row ) >= 0 ) { that.setAttribute( 'delete', '' ); } else { that.removeAttribute( 'delete' ); } } if ( grid._rowsAdded ) { if ( grid._rowsAdded.indexOf( row.id ) >= 0 ) { that.setAttribute( 'add', '' ); } else { that.removeAttribute( 'add' ); } } } if ( grid.onCellValue && !( column.rowHeaderColumn || column.selectionColumn ) ) { that.cell._updating = true; grid.onCellValue( that.cell ); that.cell._updating = false; cellValue = that.cell.value; } if ( cellValue === undefined ) { cellValue = ''; } let formattedValue = cellValue; if ( cellsFormat ) { formattedValue = that.cell.getFormattedValue( cellValue, cellsFormat ); } const htmlCellContent = that.firstChild; if ( grid.onCellRender || column.onCellRender ) { requestAnimationFrame( function () { if ( !column._cellsCachedValues ) { column._cellsCachedValues = []; } if ( column._cellsCachedValues[ row.index ] ) { const cellContent = column._cellsCachedValues[ row.index ]; if ( htmlCellContent.firstChild ) { htmlCellContent.removeChild( htmlCellContent.firstChild ); } htmlCellContent.appendChild( cellContent ); } else { grid.onCellRender ? grid.onCellRender( that.cell ) : column.onCellRender( that.cell ); if ( that.cell.template !== column.template ) { const cellContent = document.createElement( 'div' ); if ( htmlCellContent.firstChild ) { htmlCellContent.removeChild( htmlCellContent.firstChild ); } if ( that.cell.template instanceof HTMLTemplateElement ) { cellContent.appendChild( that.cell.template.cloneNode( true ) ); } else { cellContent.appendChild( that.cell.template ); } htmlCellContent.appendChild( cellContent ); column._cellsCachedValues[ row.index ] = cellContent; return; } } } ); } if ( !column.autoGenerated ) { that.setAttribute( 'data-field', column.dataField ); } if ( that.cell.focused ) { if ( grid.selection.allowCellSelection ) { that.setAttribute( 'focus', '' ); } row.element.setAttribute( 'focus', '' ); if ( !that.cell.id ) { that.id = 'gridcell' + '_' + Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 ); } grid.setAttribute( 'aria-activedescendant', that.id ); } else { that.removeAttribute( 'focus' ); } if ( that.cell.selected ) { that.setAttribute( 'selected', '' ); that.setAttribute( 'aria-selected', true ); } else { that.removeAttribute( 'selected' ); that.removeAttribute( 'aria-selected' ); } if ( grid.dragDrop && grid.dragDrop.row === row ) { that.classList.add( 'dragged' ); } else { that.classList.remove( 'dragged' ); } if ( grid.rowDetail.enabled && row.showDetail ) { that.style.height = row.cellHeight + 'px'; that.style.lineHeight = row.cellHeight + 'px'; } if ( row.expanded && row.expandHeight > 0 ) { that.style.height = row.cellHeight + 'px'; that.style.lineHeight = row.cellHeight + 'px'; } const alignment = that._getCellAlignment( row, column ); const hasTemplate = that.cell.template !== '' && grid.isInitialized && !row._isMeasureRow; let cellContentClassName = ''; if ( alignment.align ) { cellContentClassName += alignment.align + ' '; } if ( alignment.verticalAlign ) { cellContentClassName += alignment.verticalAlign + ' '; } if ( column.cellsWrap ) { cellContentClassName += 'wrap' + ' '; } cellContentClassName += 'lw-label'; if ( that.style.width !== column.computedWidth + 'px' ) { const isLastColumn = grid._isLastVisibleColumn( column ); if ( column.autoGenerated || isLastColumn ) { that.style.width = column.computedWidth + 'px'; } else { that.style.width = column.computedWidth - grid._columnGap + 'px'; } } if ( grid.grouping.enabled && grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0 && grid.grouping.renderMode === 'advanced' ) { const indent = grid.grouping.groupIndent * ( 1 + row.level ); if ( column.dataField === grid.columns[ grid.columns.length - 1 ].dataField ) { that.style.width = column.computedWidth - indent + grid.grouping.groupIndent + 'px'; if ( grid.appearance.showColumnLines ) { that.classList.add( 'lw-grid-column-border' ); } } } if ( column === grid._firstVisibleColumn ) { that.classList.add( 'lw-grid-column-border-collapse' ); } else { that.classList.remove( 'lw-grid-column-border-collapse' ); } if ( grid._columnGap > 0 && grid.appearance.showColumnLines ) { that.classList.add( 'lw-grid-column-border' ); } if ( grid._rowGap > 0 ) { that.classList.add( 'lw-grid-row-border' ); } if ( !grid.appearance.showColumnLines ) { that.classList.add( 'lw-grid-vertical-border-collapse' ); } else { that.classList.remove( 'lw-grid-vertical-border-collapse' ); } if ( !grid.appearance.showRowLines ) { that.classList.add( 'lw-grid-horizontal-border-collapse' ); } else { that.classList.remove( 'lw-grid-horizontal-border-collapse' ); } let left = column.left; if ( !grid.rightToLeft ) { if ( that.style.left !== left + 'px' ) { that.style.left = left + 'px'; } } else { if ( that.style.right !== left + 'px' ) { that.style.right = left + 'px'; } } if ( that.classList.contains( 'lw-hidden' ) ) { that.classList.remove( 'lw-hidden' ); } if ( that.hasAttribute( 'template' ) ) { that.removeAttribute( 'template' ); } if ( that.hasAttribute( 'freeze' ) ) { that.removeAttribute( 'freeze' ); } if ( that.hasAttribute( 'detail' ) ) { that.removeAttribute( 'detail' ); } if ( row.filterRow ) { that.classList.add( 'lw-grid-filter-row-cell' ); } else if ( row.summaryRow ) { that.classList.add( 'lw-grid-summary-row-cell' ); } else if ( column.freeze || row.freeze ) { if ( column.selectionColumn ) { that.setAttribute( 'checkbox', '' ); cellContentClassName += ' lw-input'; if ( column.grid.selection.checkBoxes.enabled && column.grid.selection.checkBoxes.autoShow ) { that.setAttribute( 'auto-show', '' ); } else { that.removeAttribute( 'auto-show' ); } } if ( column.rowHeaderColumn || column.selectionColumn ) { that.setAttribute( 'header', '' ); that.setAttribute( 'role', 'rowheader' ); } if ( column.rowDetailColumn ) { that.setAttribute( 'header', '' ); that.setAttribute( 'detail', '' ); that.setAttribute( 'has-toggle-button', '' ); } if ( column.commandColumn ) { that.setAttribute( 'command', '' ); } if ( grid.appearance.showFrozenColumnBackground && column.freeze ) { that.setAttribute( 'freeze', '' ); } if ( grid.appearance.showFrozenRowBackground && row.freeze ) { that.setAttribute( 'freeze', '' ); } } if ( column.cellsRotationAngle ) { const rotateResult = that._rotateCellContent( htmlCellContent, column, cellValue ); if ( !rotateResult ) { return; } } else { if ( row.filterRow ) { if ( column.toggleColumn || column.rowHeaderColumn ) { htmlCellContent.innerHTML = ''; } else { if ( !column._filterEditorInitialized ) { column._filterEditorInitialized = true; that._renderFilterCell( htmlCellContent ); return; } else { if (column.dataType === 'boolean') { that.setAttribute('template', 'checkBox'); } return; } } } else if ( row.summaryRow ) { if ( column.toggleColumn || column.rowHeaderColumn ) { htmlCellContent.innerHTML = ''; } else { if ( column.summary.length > 0 && grid._summaryItems ) { const summaryItem = grid._summaryItems[ column.dataField ]; let index = 0; for ( let summaryItemFunction in summaryItem ) { if ( index === row.summaryRowIndex ) { const cellsFormat = column.cellsFormat; let formattedValue = summaryItem[ summaryItemFunction ]; if ( cellsFormat ) { formattedValue = that.cell.getFormattedValue( formattedValue, cellsFormat ); } htmlCellContent.innerHTML = grid.localize( summaryItemFunction, {value: formattedValue} ); } index++; } } } } else { if ( grid.rowDetail.enabled && column.rowDetailColumn ) { if ( htmlCellContent.innerHTML !== '' ) { if ( row.showDetail ) { htmlCellContent.innerHTML = '<button class="lw-animate" toggled toggle-button></button>'; } else { htmlCellContent.innerHTML = '<button class="lw-animate" toggle-button></button>'; } row.element.toggleDetailButton = that.querySelector( 'button' ); } } else if ( column.commandColumn ) { that._renderCommands(); } else if ( grid.appearance.showRowHeaderNumber && column.rowHeaderColumn ) { if ( row.addNewRow ) { htmlCellContent.textContent = ''; } else { const getLabel = ( row ) => { if ( that.cell.value ) { return that.cell.value; } if ( grid.appearance.autoGenerateRowLabelMode === 'number' ) { return row.visibleIndex + 1; } else { const index = row.visibleIndex % 26; const prefixes = Math.floor( row.visibleIndex / 26 ); const charCode = 'A'.charCodeAt( 0 ); const letter = String.fromCharCode( charCode + index ); let prefix = ''; for ( let p = 0; p < prefixes; p++ ) { prefix += 'A'; } const label = prefix + letter; return label; } } if ( grid._rowsAdded ) { if ( grid._rowsAdded.indexOf( row.id ) >= 0 ) { htmlCellContent.textContent = ''; } else { htmlCellContent.textContent = getLabel( row ); } } else { htmlCellContent.textContent = getLabel( row ); } } } else if ( hasTemplate ) { that.removeAttribute( 'readonly' ); switch ( that.cell.template ) { case 'checkBox': case 'switchButton': case 'radioButton': if ( htmlCellContent.textContent !== '' ) { htmlCellContent.textContent = ''; } if ( !grid.editing.enabled || !column.allowEdit || that.cell.readonly || ( grid.editing.enabled && grid.editing.commandColumn.visible && grid.editing.editRow !== that.cell.row ) ) { that.setAttribute( 'readonly', '' ); } if ( htmlCellContent.innerHTML !== '<span class="lw-input"></span>' ) { htmlCellContent.innerHTML = '<span class="lw-input"></span>'; } if ( cellValue ) { htmlCellContent.firstChild.setAttribute( 'checked', '' ); } else if ( cellValue === null ) { htmlCellContent.firstChild.setAttribute( 'checked', 'indeterminate' ); } else { htmlCellContent.firstChild.removeAttribute( 'checked' ); } that.setAttribute( 'template', that.cell.template ); break; default: { let template = null; that.setAttribute( 'template', '' ); if ( typeof that.cell.template === 'function' ) { const formatObject = { row: row, column: column, cell: that.cell, oldValue: that.cell.oldValue, value: cellValue, template: null }; let cellTemplate = htmlCellContent.querySelector( '.lw-grid-cell-template' ); if ( cellTemplate && cellTemplate.getAttribute( 'column' ) === column.dataField ) { formatObject.template = cellTemplate.firstElementChild; } else { cellTemplate = null; } if ( that.formattedValue !== formattedValue ) { cellTemplate = null; } if ( !cellTemplate ) { that.cell.template( formatObject ); } if ( !cellTemplate && formatObject.template ) { if ( formatObject.template instanceof HTMLElement ) { const templateContainer = document.createElement( 'div' ); templateContainer.classList.add( 'lw-grid-cell-template' ); templateContainer.setAttribute( 'column', column.dataField ); htmlCellContent.innerHTML = ''; htmlCellContent.appendChild( templateContainer ); templateContainer.appendChild( formatObject.template ); } else { htmlCellContent.innerHTML = '<div column="' + column.dataField + '" class="lw-grid-cell-template">' + formatObject.template + '</div>'; } } else if ( !cellTemplate && formatObject.template === null ) { htmlCellContent.innerHTML = cellValue; } if ( that.cell._styleChanged ) { that.cell.setStyle( htmlCellContent ); } if ( that.cell.oldValue === undefined ) { that.cell.oldValue = cellValue; } that.formattedValue = formattedValue; } else { if ( htmlCellContent.textContent !== '' ) { htmlCellContent.textContent = ''; } if ( that.cell.template.startsWith( '#' ) ) { template = document.querySelector( that.cell.template ); } if ( template ) { const templateContent = template.content.cloneNode( true ).firstElementChild; cellValue = cellValue.toString(); cellValue = cellValue.replace( /'/ig, '\\\'' ); cellValue = cellValue.replace( /"/ig, '\\"' ); let html = templateContent.outerHTML.replace( /{{value}}/ig, cellValue ).replace( /{{id}}/ig, row.id ); if ( html.indexOf( '{{value=' ) >= 0 ) { if ( !cellValue ) { html = html.replace( /{{value=/ig, '' ); html = html.replace( /}}/ig, '' ); } else { html = html.substring( 0, html.indexOf( '{{value=' ) ) + cellValue + html.substring( html.indexOf( '}' ) ); html = html.replace( /}/ig, '' ); html = html.replace( /{/ig, '' ); } } if ( htmlCellContent.innerHTML !== html ) { htmlCellContent.innerHTML = html; } } else { if ( cellValue === '' ) { cellValue = '&nbsp;'; } const html = that.cell.template.replace( /{{value}}/ig, cellValue ).replace( /{{id}}/ig, row.id ); if ( htmlCellContent.innerHTML !== html ) { htmlCellContent.innerHTML = html; } } } } } } else if ( column.selectionColumn ) { if ( grid.selectionMode === 'checkBox' ) { if ( row.getProperty( 'selected' ) ) { that.setAttribute( 'selected', '' ); that.element.setAttribute( 'aria-selected', true ); } else { if ( that.getAttribute( 'selected' ) ) { that.removeAttribute( 'selected' ); that.element.removeAttribute( 'aria-selected' ); } } } } else { const firstChild = htmlCellContent.firstChild; if ( firstChild && firstChild.classList && that.toggleButton && column._treeColumn ) { const indent = htmlCellContent.children[ 0 ]; const toggleButton = htmlCellContent.children[ 1 ].children[ 0 ]; const checkbox = htmlCellContent.children[ 1 ].children[ 1 ].firstChild; const content = htmlCellContent.children[ 1 ].children[ 2 ]; let indentDiv = ''; if ( column._treeColumn ) { if ( grid.grouping.enabled ) { let level = row.level - 1; indentDiv += '<div style="width: ' + ( 1 + level ) * grid.grouping.groupIndent + 'px;"></div>'; } else { for ( let i = 0; i < row.level; i++ ) { indentDiv += '<div class=\'lw-indent\'></div>'; } } if ( row.checked ) { checkbox.setAttribute( 'checked', '' ); } else if ( row.checked === false ) { checkbox.removeAttribute( 'checked' ); } else if ( row.checked === null ) { checkbox.setAttribute( 'checked', 'indeterminate' ); } if ( row.leaf ) { if ( row.allowCheck ) { checkbox.classList.remove( 'lw-visibility-hidden' ); } else { checkbox.classList.add( 'lw-visibility-hidden' ); } } else { if ( row.allowCheck ) { checkbox.classList.remove( 'lw-hidden' ); } else { checkbox.classList.add( 'lw-hidden' ); } } } if ( row.allowCheck ) { if ( grid.checkBoxes.visible ) { checkbox.classList.remove( 'lw-hidden' ); } else { checkbox.classList.add( 'lw-hidden' ); } } else if ( !grid.checkBoxes.visible ) { checkbox.classList.add( 'lw-hidden' ); } indent.innerHTML = indentDiv; toggleButton.classList.add( 'lw-visibility-hidden' ); if ( !row.leaf ) { toggleButton.classList.remove( 'lw-visibility-hidden' ); if ( row.expanded ) { toggleButton.setAttribute( 'toggled', '' ); } else { toggleButton.removeAttribute( 'toggled', '' ); } } else { toggleButton.classList.add( 'lw-visibility-hidden' ); } if ( row.data.isEmpty ) { toggleButton.classList.add( 'lw-visibility-hidden' ); } content.innerHTML = formattedValue; if ( grid.appearance.showRowHeaderNumber && grid.grouping.enabled && grid.dataSource.groupBy.length > 0 && grid.grouping.renderMode === 'advanced' ) { formattedValue = '<span visible-index>' + ( 1 + row.visibleIndex ) + '</span> ' + formattedValue; } if ( grid.rowDetail.enabled && grid.grouping.enabled && grid.dataSource.groupBy.length > 0 && grid.grouping.renderMode === 'advanced' ) { content.innerHTML = '<button class="inline lw-animate" toggled toggle-button></button>' + formattedValue; row.element.toggleDetailButton = that.querySelector( 'button.inline' ); row.element.toggleDetailButton.setAttribute( 'title', grid.localize( !row.showDetail ? 'expandRow' : 'collapseRow', {elementType: 'Grid'} ) ); row.element.toggleDetailButton.onpointerdown = function () { row.showDetail = !row.showDetail; } } if ( grid.appearance.showTooltips ) { content.setAttribute( 'title', formattedValue ); } else if ( content.hasAttribute( 'title' ) ) { content.removeAttribute( 'title' ); } } else { const cell = row[ 'column_' + column.dataField ]; if ( that.getAttribute( 'rowspan' ) ) { that.removeAttribute( 'rowspan' ); that.removeAttribute( 'aria-rowspan' ); that.style.height = ''; } if ( that.getAttribute( 'colspan' ) ) { that.removeAttribute( 'colspan' ); that.removeAttribute( 'aria-colspan' ); } if ( cell ) { if ( cell.colSpan > 1 ) { const startColumnIndex = grid.columns.indexOf( column ); let width = 0; for ( let m = startColumnIndex; m < startColumnIndex + cell.colSpan; m++ ) { const viewColumn = grid.columns[ m ]; if ( viewColumn && viewColumn.visible ) { width += viewColumn.computedWidth; } } that.style.width = width + 'px'; that.setAttribute( 'colspan', '' ); that.setAttribute( 'aria-colspan', cell.colSpan ); cell._styleChanged = true; } if ( cell.rowSpan > 1 ) { const startRowIndex = grid.rows.indexOf( row ); let height = 0; row.element.setAttribute( 'rowspan', '' ); for ( let m = startRowIndex; m <= startRowIndex + cell.rowSpan - 1; m++ ) { const viewRow = grid.rows[ m ]; if ( viewRow && viewRow.visible && viewRow.filtered ) { height += viewRow.cellHeight; } } that.style.height = height + 'px'; that.setAttribute( 'rowspan', '' ); that.setAttribute( 'aria-rowspan', cell.rowSpan ); cell._styleChanged = true; } if ( ( cell.colSpan === 1 && that.hasAttribute( 'colspan' ) ) || ( that.hasAttribute( 'rowspan' ) && cell.rowSpan === 1 ) ) { that.style.height = ''; that.style.width = ''; that.removeAttribute( 'colspan' ); that.removeAttribute( 'rowspan' ); that.removeAttribute( 'aria-rowspan' ); that.removeAttribute( 'aria-colspan' ); cell._styleChanged = true; } if ( htmlCellContent.textContent !== formattedValue && !column.formatFunction ) { htmlCellContent.textContent = formattedValue; } cell.setStyle( htmlCellContent ); if ( grid.appearance.showTooltips ) { htmlCellContent.setAttribute( 'title', cell.tooltip || formattedValue ); } else if ( htmlCellContent.hasAttribute( 'title' ) ) { htmlCellContent.removeAttribute( 'title' ); } } else { htmlCellContent.textContent = formattedValue; } } } } } if ( htmlCellContent.className !== cellContentClassName ) { htmlCellContent.className = cellContentClassName; } if ( column.formatFunction && !row.data.isEmpty && grid.isInitialized ) { const formatObject = { row: row, column: column, cell: that.cell, oldValue: that.cell.oldValue, value: cellValue, formattedValue: formattedValue, template: null }; that.cell.canNotify = false; row.canNotify = false; const cellStyle = Object.assign( { }, { background: that.cell.background, borderColor: that.cell.borderColor, color: that.cell.color, fontSize: that.cell.fontSize, fontFamily: that.cell.fontFamily, fontWeight: that.cell.fontWeight, fontStyle: that.cell.fontStyle } ); column.formatFunction( formatObject ); if ( htmlCellContent.style.background !== cellStyle.background || htmlCellContent.style.borderColor !== cellStyle.borderColor || htmlCellContent.style.color !== cellStyle.color || htmlCellContent.style.fontSize !== cellStyle.fontSize || htmlCellContent.style.fontWeight !== cellStyle.fontWeight || htmlCellContent.style.fontStyle !== cellStyle.fontStyle ) { that.cell._styleChanged = true; that.cell.setStyle( htmlCellContent ); } if ( that.cell.background !== cellStyle.background || that.cell.borderColor !== cellStyle.borderColor || that.cell.color !== cellStyle.color || that.cell.fontSize !== cellStyle.fontSize || that.cell.fontWeight !== cellStyle.fontWeight || that.cell.fontStyle !== cellStyle.fontStyle ) { that.cell._styleChanged = true; that.cell.setStyle( htmlCellContent ); } let requiresUpdate = true; if ( formatObject.value !== cellValue ) { if ( that.toggleButton ) { const content = htmlCellContent.children[ 1 ].children[ 2 ]; content.innerHTML = formatObject.value; } else { htmlCellContent.innerHTML = formatObject.value; } requiresUpdate = false; } if ( formatObject.template !== null ) { if ( that.toggleButton ) { const content = htmlCellContent.children[ 1 ].children[ 2 ]; if ( content.innerHTML !== formatObject.template ) { content.innerHTML = formatObject.template; } } else if ( htmlCellContent.innerHTML !== formatObject.template ) { const checkTemplateElement = document.createElement( 'div' ); checkTemplateElement.innerHTML = formatObject.template; if ( checkTemplateElement.innerHTML !== htmlCellContent.innerHTML ) { htmlCellContent.innerHTML = formatObject.template; } } requiresUpdate = false; } if ( requiresUpdate ) { htmlCellContent.textContent = cellValue; } that.cell.canNotify = true; row.canNotify = true; } } _rotateCellContent( columnHeaderCellContentElement, column, cellValue ) { const that = this; const textElement = document.createElement( 'span' ); columnHeaderCellContentElement.innerHTML = ''; textElement.innerHTML = cellValue; columnHeaderCellContentElement.appendChild( textElement ); textElement.className = 'rotate' textElement.style.transform = 'rotate(' + column.cellsRotationAngle + 'deg)'; return that.grid._recycleRotate( columnHeaderCellContentElement, textElement, column.cellsAlign, column.cellsVerticalAlign, cellValue ); } _getCellAlignment( row, column ) { const cell = row[ 'column_' + column.dataField ]; const verticalAlign = cell ? cell.verticalAlign || column.cellsVerticalAlign : column.cellsVerticalAlign; let align = cell ? cell.align || column.cellsAlign : column.cellsAlign; const alignment = { align: '', verticalAlign: '' }; if ( cell.grid.rightToLeft ) { if ( align === 'left' ) { align = 'right'; } else if ( align === 'right' ) { align = 'left'; } } switch ( align ) { case 'left': alignment.align = 'align-left'; break; case 'center': case 'middle': alignment.align = 'align-center'; break; case 'right': alignment.align = 'align-right'; break; } switch ( verticalAlign ) { case 'top': alignment.verticalAlign = 'align-top'; break; case 'center': case 'middle': alignment.verticalAlign = 'align-middle'; break; case 'bottom': alignment.verticalAlign = 'align-bottom'; break; } return alignment; } template() { return ''; } _detach() { const that = this; that.element = null; that.cell = null; } onDetached() { const that = this; that._detach(); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('Grid.Resize', class Resize { autoSizeRows(rows) { const that = this; const rowsToAutoSize = !rows ? that._recyclingRows : rows; that.rows.canNotify = false; for (let i = 0; i < rowsToAutoSize.length; i++) { const row = rowsToAutoSize[i]; row.element = that._rowElements[1]; row.grid = that; const height = row._autoSize(row); if (row.cellHeight !== height) { row.cellHeight = height; } row.height = height; } that.rows.canNotify = true; that.refresh(); } autoSizeColumns(autoSizeHeadersOnly, columns) { const that = this; const columnsToAutoSize = !columns ? that.columns : columns; let labels = []; if (!autoSizeHeadersOnly) { const rows = that._recyclingRows; for (let i = 0; i < rows.length; i++) { const row = rows[i]; for (let j = 0; j < columnsToAutoSize.length; j++) { const column = columnsToAutoSize[j]; const cell = row.getCell(column.dataField); if (!labels[column.dataField]) { labels[column.dataField] = column.label; } if (cell.value && cell.value.toString().length > labels[column.dataField].length) { labels[column.dataField] = cell.value; } } } } const measureLabels = []; for (let j = 0; j < columnsToAutoSize.length; j++) { const column = columnsToAutoSize[j]; const label = labels[column.dataField] ? labels[column.dataField] : column.label; measureLabels.push(label); } const columnWidths = columnsToAutoSize[0]._measureSize(measureLabels); that.columns.canNotify = false; for (let j = 0; j < columnsToAutoSize.length; j++) { const column = columnsToAutoSize[j]; column.width = columnWidths[j]; } that.columns.canNotify = true; that.refresh(); } _doubleClickHandler(event) { const that = this; if (that.behavior.rowResizeMode === 'none' && that.behavior.columnResizeMode === 'none') { return; } const isDoubleClick = that._downTime ? new Date() - that._downTime < 300 : false; if (isDoubleClick) { const elements = (that.enableShadowDOM ? that.shadowRoot : that.getRootNode()).elementsFromPoint(event.clientX, event.clientY); let columnDataField = null; let columnElement = null; let rowId = null; let rowElement = null; for (let i = 0; i < elements.length; i++) { const element = elements[i]; if (element.getAttribute('data-field')) { columnDataField = element.getAttribute('data-field'); columnElement = element; break; } if (element.getAttribute('data-id')) { rowId = element.getAttribute('data-id'); rowElement = element; break; } } const column = that.columnByDataField[columnDataField]; const row = that.rowById[rowId]; if (that.appearance.allowColumnAutoSizeOnDoubleClick && column && column.allowResize && that.behavior.columnResizeMode !== 'none') { const columnRight = columnElement.getBoundingClientRect().right; const columnResizeBreakpoint = 10; if (columnRight - columnResizeBreakpoint <= event.clientX && event.clientX <= columnRight + columnResizeBreakpoint) { column.autoSize(); } } if (that.appearance.allowRowAutoSizeOnDoubleClick && row && row.allowResize && that.behavior.rowResizeMode !== 'none') { const rowBottom = rowElement.getBoundingClientRect().bottom; const rowResizeBreakpoint = 10; if (rowBottom - rowResizeBreakpoint <= event.clientY && event.clientY <= rowBottom + rowResizeBreakpoint) { row.computedHeight = null; row.autoSize(); } } } that._downTime = new Date(); } _endResize(/*event*/) { const that = this; if (that._overlay) { that._overlay.parentNode.removeChild(that._overlay); that._overlay = null; } const boundingRect = that.getBoundingRect(that); that.classList.remove('lw-grid-resize-mode'); that.$.root.classList.remove('lw-grid-resize-mode'); that.classList.remove('lw-grid-row-resize-mode'); that.classList.remove('lw-grid-column-resize-mode'); if (that._rowToResize && that._rowResizeStartLine && that._rowResizeLine) { const row = that.rowById[that._rowToResizeId]; const newRowHeight = row.cellHeight + parseFloat(that._rowResizeLine.style.top) - parseFloat(that._rowResizeStartLine.style.top) const oldHeight = row.cellHeight; that.rows.canNotify = false; row.height = null; if (that.behavior.rowResizeMode === 'split') { const nextRow = that._nextRow(row); const offset = parseInt(row.height - newRowHeight + row.cellHeight); row.computedHeight = newRowHeight; nextRow.computedHeight = parseInt(nextRow.height) + offset; nextRow.height = null; } else { row.computedHeight = newRowHeight; } that.rows.canNotify = true; that._rowResizeStartLine.parentNode.removeChild(that._rowResizeStartLine); that._rowResizeLine.parentNode.removeChild(that._rowResizeLine); if (that.appearance.showResizeTooltips) { that._rowResizeTooltip.parentNode.removeChild(that._rowResizeTooltip); } if (that._rowToResize.header) { that._rowToResize.header.style.cursor = ''; } that._rowResizeLine = null; that._rowToResize = null; that._rowToResizeId = null; that.refresh(); that.$.fireEvent('rowResize', { 'row': row, 'oldHeight': oldHeight, 'height': newRowHeight }); return; } if (!that._columnToResizeElement || !that._columnResizeLine) { return; } const column = that.columnByDataField[that._columnToResizeDataField]; const columnRect = that._columnToResizeRect; let newColumnWidth = boundingRect.left + parseInt(that._columnResizeLine.style.left) - columnRect.left + that.scrollLeft; const oldWidth = column.width; if (that.rightToLeft) { newColumnWidth = boundingRect.left - parseFloat(that._columnResizeLine.style.left) + columnRect.right - that.scrollLeft - that._scrollView.vScrollBar.offsetWidth; } if (newColumnWidth < column.minWidth) { newColumnWidth = column.minWidth; } that.columns.canNotify = false; if (that.behavior.columnResizeMode === 'split') { const nextColumn = that._nextColumn(column); const offset = parseInt(column.computedWidth - newColumnWidth); column.width = newColumnWidth; nextColumn.width = parseInt(nextColumn.computedWidth) + offset; } else { column.width = newColumnWidth; } that.columns.canNotify = true; that._columnResizeLine.parentNode.removeChild(that._columnResizeLine); that._columnResizeLine = null; that._columnResizeStartLine.parentNode.removeChild(that._columnResizeStartLine); if (that._columnResizeTooltip.parentNode) { that._columnResizeTooltip.parentNode.removeChild(that._columnResizeTooltip); } that._columnResizeStartLine = null; that._columnToResizeElement.style.cursor = ''; that._columnToResizeElement.sortButton.style.cursor = ''; that._columnToResizeElement.filterButton.style.cursor = ''; that._columnToResizeElement = null; that._columnToResizeRect = null; that._columnToResizeDataField = null; that._columnResizeTooltip = null; that.refresh(); that.$.fireEvent('columnResize', { 'column': column, 'oldWidth': oldWidth, 'width': newColumnWidth }); } _columnDownResizeHandler() { const that = this; const columnRect = that._columnToResizeRect; const columnHeaderRect = that.getBoundingRect(that.$.columnHeader); if (that._dragDetails) { return; } const createLine = function () { const resizeLine = document.createElement('div'); resizeLine.classList.add('lw-grid-resize-line'); if (that.rightToLeft) { resizeLine.style.left = -columnHeaderRect.left + columnRect.left + 'px'; } else { resizeLine.style.left = -columnHeaderRect.left + columnRect.right + 'px'; } resizeLine.style.top = -columnHeaderRect.top + columnRect.top + 'px'; resizeLine.style.height = 'calc(100% - ' + resizeLine.style.top + ')'; resizeLine.style.cursor = 'col-resize'; return resizeLine; } const resizeTooltip = document.createElement('div'); resizeTooltip.classList.add('lw-grid-resize-tooltip'); that._columnResizeTooltip = resizeTooltip; that._columnResizeTooltip.style.left = -columnHeaderRect.left + columnRect.right + 'px'; if (that.rightToLeft) { that._columnResizeTooltip.style.left = -columnHeaderRect.left + columnRect.left + 'px'; } that._columnResizeTooltip.innerHTML = that.localize('columnResizeTooltip', { value: columnRect.width }); that._columnResizeLine = createLine(); that._columnResizeStartLine = createLine(); if (that.behavior.columnResizeMode === 'growAndShrink') { that.classList.add('lw-grid-resize-mode'); that.classList.add('lw-grid-column-resize-mode'); that.$.root.classList.add('lw-grid-resize-mode'); } if (that.appearance.showResizeTooltips) { that.$.root.appendChild(that._columnResizeTooltip); } that.$.root.appendChild(that._columnResizeLine); that.$.root.appendChild(that._columnResizeStartLine); that._overlay = document.createElement('div'); that._overlay.classList.add('lw-grid-overlay'); that._overlay.style.cursor = 'col-resize'; that.$.root.appendChild(that._overlay); } _columnMoveResizeHandler(event) { const that = this; const columnResizeBreakpoint = 5; if (that._dragDetails) { return; } const updateTooltip = function (boundingRect) { const columnRect = that._columnToResizeRect; let newColumnWidth = boundingRect.left + parseFloat(that._columnResizeLine.style.left) - columnRect.left + that.scrollLeft; if (that.rightToLeft) { newColumnWidth = boundingRect.left - parseFloat(that._columnResizeLine.style.left) + columnRect.right - that.scrollLeft - that._scrollView.vScrollBar.offsetWidth; } const column = that.columnByDataField[that._columnToResizeDataField]; if (newColumnWidth < column.minWidth) { newColumnWidth = column.minWidth; } if (that.appearance.showResizeTooltips) { that._columnResizeTooltip.innerHTML = that.localize('columnResizeTooltip', { value: parseInt(newColumnWidth) }); } } if (that._columnResizeLine) { const column = that.columnByDataField[that._columnToResizeDataField]; const columnRect = that._columnToResizeRect; const minWidth = column.minWidth; const maxWidth = column.maxWidth; const nextColumn = that._nextColumn(column); const boundingRect = that.getBoundingRect(that); if (!that.rightToLeft) { if (event.pageX < boundingRect.left) { return; } if (that.behavior.columnResizeMode === 'split' && nextColumn) { if (event.pageX >= boundingRect.left + nextColumn.left + nextColumn.computedWidth - nextColumn.minWidth - that.scrollLeft) { that._columnResizeLine.style.left = -boundingRect.left + boundingRect.left + nextColumn.computedWidth + nextColumn.left - nextColumn.minWidth - that.scrollLeft + 'px'; updateTooltip(boundingRect); return; } } if (columnRect.left + minWidth - that.scrollLeft >= event.pageX) { that._columnResizeLine.style.left = -boundingRect.left + columnRect.left + minWidth - that.scrollLeft + 'px'; updateTooltip(boundingRect); return; } if (columnRect.left + maxWidth - that.scrollLeft <= event.pageX) { that._columnResizeLine.style.left = -boundingRect.left + columnRect.left + maxWidth - that.scrollLeft + 'px'; updateTooltip(boundingRect); return; } that._columnResizeLine.style.left = -boundingRect.left + event.pageX + 'px'; updateTooltip(boundingRect); } else { if (event.pageX > boundingRect.right) { return; } if (that.behavior.columnResizeMode === 'split' && nextColumn) { if (event.pageX <= that.offsetWidth - that.scrollLeft - nextColumn.left - nextColumn.computedWidth + nextColumn.minWidth) { that._columnResizeLine.style.left = that.offsetWidth - that.scrollLeft - nextColumn.left - nextColumn.computedWidth + nextColumn.minWidth + 'px'; updateTooltip(boundingRect); return; } } if (columnRect.right - minWidth - that.scrollLeft <= event.pageX) { that._columnResizeLine.style.left = -boundingRect.left + columnRect.right - minWidth - that.scrollLeft + 'px'; updateTooltip(boundingRect); return; } if (columnRect.left + maxWidth - that.scrollLeft >= event.pageX) { that._columnResizeLine.style.left = -boundingRect.left + columnRect.right - maxWidth - that.scrollLeft + 'px'; updateTooltip(boundingRect); return; } that._columnResizeLine.style.left = -boundingRect.left + event.pageX + 'px'; updateTooltip(boundingRect); } } else { const that = this; if (event.composedPath && event.composedPath().indexOf(this) === -1) { return; } const elements = (that.enableShadowDOM ? that.shadowRoot : that.getRootNode()).elementsFromPoint(event.clientX, event.clientY); let columnDataField = null; let columnElement = null; if (that._columnResizeLine) { return; } for (let i = 0; i < elements.length; i++) { const element = elements[i]; if (element.hasAttribute('data-field') && element.hasAttribute('header')) { columnDataField = element.getAttribute('data-field'); columnElement = element; break; } } if (that._columnToResizeElement) { that._columnToResizeElement.style.cursor = ''; that._columnToResizeElement.sortButton.style.cursor = ''; that._columnToResizeElement.filterButton.style.cursor = ''; that._columnToResizeElement = null; } if (columnDataField) { const columnRight = !that.rightToLeft ? columnElement.getBoundingClientRect().right : columnElement.getBoundingClientRect().left; columnElement.style.cursor = '' columnElement.sortButton.style.cursor = ''; columnElement.filterButton.style.cursor = ''; if (columnRight - columnResizeBreakpoint <= event.clientX && event.clientX <= columnRight + columnResizeBreakpoint) { const column = that.columnByDataField[columnDataField]; if (!column || (column && !column.allowResize)) { return; } const isLastColumn = that._isLastVisibleColumn(column); if (that.behavior.columnResizeMode === 'split' && isLastColumn) { return; } columnElement.style.cursor = 'col-resize'; columnElement.sortButton.style.cursor = 'col-resize'; columnElement.filterButton.style.cursor = 'col-resize'; that._columnToResizeRect = that.getBoundingRect(columnElement); that._columnToResizeElement = columnElement; that._columnToResizeDataField = columnDataField; } } } } _rowMoveResizeHandler(event) { const that = this; const elements = (that.enableShadowDOM ? that.shadowRoot : that.getRootNode()).elementsFromPoint(event.clientX, event.clientY); const rowResizeBreakpoint = 5; const resizeLineHeight = 1; let rowId = null; let rowElement = null; if (that._rowResizeLine) { const scrollViewTop = that._offsetTop(that.$.scrollView); const scrollViewBounds = { top: scrollViewTop, bottom: that.$.scrollView.offsetHeight + scrollViewTop }; if (event.pageY <= scrollViewBounds.top) { return; } if (event.pageY >= scrollViewBounds.bottom) { return; } const updateTooltip = function () { const newRowHeight = row.cellHeight + parseFloat(that._rowResizeLine.style.top) - parseFloat(that._rowResizeStartLine.style.top); if (that.appearance.showResizeTooltips) { that._rowResizeTooltip.innerHTML = that.localize('rowResizeTooltip', { value: parseInt(newRowHeight) }); } } const row = that.rowById[that._rowToResizeId]; const nextRow = that._nextRow(row); const rowBounds = that._rowToResizeBounds; const minHeight = row.minHeight; const maxHeight = row.maxHeight; if (that.behavior.rowResizeMode === 'split' && nextRow) { if (rowBounds.bottom + nextRow.height - nextRow.minHeight <= event.pageY) { that._rowResizeLine.style.top = rowBounds.bottom + nextRow.height - nextRow.minHeight - scrollViewTop + 'px'; updateTooltip(); return; } } if (rowBounds.top + minHeight + rowResizeBreakpoint >= event.pageY) { that._rowResizeLine.style.top = rowBounds.top + minHeight + rowResizeBreakpoint - scrollViewTop + 'px'; updateTooltip(); return; } if (rowBounds.top + maxHeight >= event.pageY - scrollViewTop) { that._rowResizeLine.style.top = rowBounds.top + maxHeight + rowResizeBreakpoint - scrollViewTop + 'px'; updateTooltip(); return; } that._rowResizeLine.style.top = -scrollViewTop + event.pageY - resizeLineHeight + 'px'; updateTooltip(); return; } else { for (let i = 0; i < elements.length; i++) { const element = elements[i]; if (element.hasAttribute('data-id') && element.hasAttribute('header')) { rowElement = element; rowId = element.getAttribute('data-id'); break; } } if (that._rowToResize) { that._rowToResize.style.cursor = ''; that._rowToResize = null; } if (rowId !== null) { const rowBottom = that._offsetTop(rowElement) + rowElement.offsetHeight; rowElement.style.cursor = ''; if (rowBottom - rowResizeBreakpoint <= event.clientY && event.clientY <= rowBottom + rowResizeBreakpoint) { const row = that.rowById[rowId]; if (!row || (row && !row.allowResize)) { return; } if (row.header) { row.header.style.cursor = 'row-resize'; } const top = that._offsetTop(rowElement); that._rowToResizeBounds = { top: top, bottom: rowElement.offsetHeight + top, height: rowElement.offsetHeight }; that._rowToResize = rowElement; that._rowToResizeId = rowId; } } } } _rowDownResizeHandler() { const that = this; const rowBounds = that._rowToResizeBounds; const createLine = function () { const resizeLine = document.createElement('div'); resizeLine.classList.add('lw-grid-resize-line', 'row'); resizeLine.style.width = that.$.scrollView.offsetWidth - that._rowToResize.offsetLeft + 'px'; resizeLine.style.left = '0px'; resizeLine.style.top = -that._offsetTop(that.$.scrollView) + rowBounds.bottom + 'px'; resizeLine.style.cursor = 'row-resize'; return resizeLine; } const resizeTooltip = document.createElement('div'); resizeTooltip.classList.add('lw-grid-resize-tooltip'); that._rowResizeTooltip = resizeTooltip; that._rowResizeTooltip.style.top = -that._offsetTop(that.$.scrollView) + rowBounds.bottom + 'px'; that._rowResizeTooltip.innerHTML = that.localize('rowResizeTooltip', { value: rowBounds.height }); that._rowResizeTooltip.style.right = '20px'; that._rowResizeTooltip.style.bottom = 'initial'; if (that.behavior.rowResizeMode === 'growAndShrink') { that.classList.add('lw-grid-resize-mode'); that.classList.add('lw-grid-row-resize-mode'); that.$.root.classList.add('lw-grid-resize-mode'); } that._rowResizeLine = createLine(); that._rowResizeStartLine = createLine(); that._overlay = document.createElement('div'); that._overlay.classList.add('lw-grid-overlay'); that._overlay.style.cursor = 'row-resize'; that.$.root.appendChild(that._overlay); that.$.scrollView.appendChild(that._rowResizeLine); that.$.scrollView.appendChild(that._rowResizeStartLine); if (that.appearance.showResizeTooltips) { that.$.scrollView.appendChild(that._rowResizeTooltip); } } _rowResizeHandler(event) { const that = this; let clientX = event.clientX; let clientY = event.clientY; if (clientX === undefined || clientY === undefined) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } const elements = (that.enableShadowDOM ? that.shadowRoot : that.getRootNode()).elementsFromPoint(clientX, clientY); let rowId = null; for (let i = 0; i < elements.length; i++) { const element = elements[i]; if (element.getAttribute('data-id')) { rowId = element.getAttribute('data-id'); } } if (rowId !== null) { if (that._rowToResize && !that._rowResizeLine) { that._rowDownResizeHandler(event); return; } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Reorder', class Reorder { _createLine( item ) { const that = this; const createColumnLine = function () { const dragLine = document.createElement( 'div' ); const columnRect = that.getBoundingRect( item ); const columnHeaderRect = that.getBoundingRect( that.$.columnHeader ); const rect = that.getBoundingRect( that ); const height = that.$.content.offsetHeight - 7 - that._scrollView.hScrollBar.offsetHeight - columnRect.top + rect.top; dragLine.classList.add( 'lw-grid-drag-line' ); if ( that.rightToLeft ) { dragLine.style.left = -columnHeaderRect.left + columnRect.left + 'px'; } else { dragLine.style.left = -columnHeaderRect.left + columnRect.right + 'px'; } dragLine.style.top = columnRect.top - rect.top + 'px'; dragLine.style.height = height + 'px'; dragLine.style.opacity = 0; return dragLine; } const createRowLine = function () { const dragLine = document.createElement( 'div' ); const rowRect = that.getBoundingRect( item ); dragLine.classList.add( 'lw-grid-drag-line', 'row' ); dragLine.style.width = that.$.scrollView.offsetWidth - item.offsetLeft - item.row.header.offsetWidth - that._scrollView.vScrollBar.offsetWidth + 'px'; dragLine.style.left = item.row.header.offsetWidth + 'px'; dragLine.style.top = rowRect.bottom - that.offsetTop + 'px'; dragLine.style.opacity = 0; return dragLine; } if ( item.classList.contains( 'lw-breadcrumb-item' ) || item.column ) { return createColumnLine(); } else { return createRowLine(); } } _drag( event ) { const that = this; const moveEvent = event.originalEvent; if ( !that._dragDrop ) { return; } const dragDetails = that._dragDrop.dragDetails; let feedback = dragDetails.feedback; if ( !feedback && that._dragDrop.showFeedback ) { feedback = that._dragDrop.createFeedback( moveEvent ); if ( !feedback ) { return; } else { that._overlay = document.createElement( 'div' ); that._overlay.classList.add( 'lw-grid-overlay' ); that._overlay.style.cursor = ''; that.$.root.appendChild( that._overlay ); if ( that._dragDrop.column ) { that._dragLine = that._createLine( that._dragDrop.column.element ); that.$.root.appendChild( that._dragLine ); requestAnimationFrame( () => { that._dragLine.style.opacity = 1; } ); that._dragDrop.feedbackLine = that._dragLine; } else { const row = that._dragDrop.row; let rowFeedback = '<div>'; for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; rowFeedback += '<div>' + column.label + ': ' + row[ 'column_' + column.dataField ].value + '</div>'; } that._dragDrop.items = that._rowElements; that._dragDrop.getItemCoordinates( that._rowElements ); rowFeedback += '</div>'; feedback.innerHTML = rowFeedback; that._dragLine = that._createLine( that._dragDrop.row.element ); that.$.root.appendChild( that._dragLine ); requestAnimationFrame( () => { that._dragLine.style.opacity = 1; } ); feedback.classList.add( 'lw-grid-row-drag-feedback' ); that._dragDrop.feedbackLine = that._dragLine; } } } that._dragDrop.drag( event ); that._dragDrop.column ? that._dragColumn( event ) : that._dragRow( event ); moveEvent.preventDefault(); } _dragRow( event ) { const that = this; const dragDetails = that._dragDrop.dragDetails; //const feedback = dragDetails.feedback; const dragLine = that._dragLine; const moveEvent = event.originalEvent; const rect = that.getBoundingRect( that ); if ( event.pageY < rect.top || event.pageY > rect.bottom || event.pageX < rect.left || event.pageX > rect.right || ( dragDetails.target && !dragDetails.target.row ) || !dragDetails.target ) { that._dragDrop.error(); dragLine.style.opacity = 0; } else { that._dragDrop.getItemCoordinates( that._dragDrop.items ); dragLine.style.opacity = 1; that._dragDrop.success(); if ( !dragDetails.target ) { return; } let rowRect = that.getBoundingRect( dragDetails.target ); dragLine.style.width = that.$.scrollView.offsetWidth - that._dragDrop.row.offsetLeft - that._dragDrop.row.header.offsetWidth - that._scrollView.vScrollBar.offsetWidth + 'px'; dragLine.style.left = that._dragDrop.row.header.offsetWidth + 'px'; let top = rowRect.top - that.offsetTop - that.scrollTop; if ( that._recyclingRows[ that._recyclingRows.length - 1 ].element === dragDetails.target && event.pageY > rect.bottom - 10 ) { dragDetails.before = false; } if ( event.pageY > top + that.offsetTop + rowRect.height - 7 ) { dragDetails.before = false; } dragLine.style.top = dragDetails.before ? top + 'px' : top + rowRect.height - 7 + 'px'; } that.$.fireEvent( 'rowDragging', { 'row': that._dragDrop.row, 'index': that._dragDrop.visibleIndex, 'data': that._dragDrop, 'originalEvent': moveEvent } ); } _dragColumn( event ) { const that = this; const dragDetails = that._dragDrop.dragDetails; //const feedback = dragDetails.feedback; const rect = that.getBoundingRect( that ); const moveEvent = event.originalEvent; if ( event.pageY < rect.top || event.pageY > rect.bottom || event.pageX < rect.left || event.pageX > rect.right ) { that._dragDrop.error(); that._dragLine.style.opacity = 0; } else { that._dragLine.style.opacity = 1; } if ( dragDetails.target && that._dragDrop.feedback && !that._dragDrop.feedback.classList.contains( 'error' ) ) { that._dragDrop.getItemCoordinates( that._dragDrop.items ); const columnRect = that.getBoundingRect( dragDetails.target ); const contentRect = that.getBoundingRect( that.$.content ); if ( that._dragDrop.column ) { that._dragLine.style.opacity = 1; if ( dragDetails.before === false ) { that._dragLine.style.left = -that.offsetLeft + columnRect.right - that.scrollLeft + 'px'; } else { that._dragLine.style.left = -that.offsetLeft + columnRect.left - that.scrollLeft + 'px'; } if ( dragDetails.target.classList.contains( 'lw-breadcrumb-item' ) ) { that._dragLine.style.top = columnRect.top - rect.top - that.scrollTop + 'px'; that._dragLine.style.height = columnRect.height + 'px'; that.$.breadcrumb.dataSource.forEach( item => { if ( item.value === dragDetails.item.column.dataField ) { that._dragLine.style.opacity = 0; that._dragDrop.error(); } } ); } else { that._dragLine.style.top = columnRect.top - rect.top - that.scrollTop + 'px'; const height = that.$.content.offsetHeight - 7 - that._scrollView.hScrollBar.offsetHeight - columnRect.top + contentRect.top; that._dragLine.style.height = height + 'px'; } if ( parseInt( that._dragLine.style.left ) < 3 ) { that._dragLine.style.left = '3px'; } else if ( parseInt( that._dragLine.style.left ) >= that.offsetWidth - 3 ) { that._dragLine.style.left = that.offsetWidth - 7 + 'px'; } } } else { that._dragLine.style.opacity = 0; } that.$.fireEvent( 'columnDragging', { 'column': that._dragDrop.column, 'index': that.columns.indexOf( that._dragDrop.column ), 'data': that._dragDrop, 'originalEvent': moveEvent } ); } _beginRowDrag( event, row ) { const that = this; let allowReorder = false; if ( that.behavior.allowRowReorder && row.allowReorder ) { allowReorder = true; } if ( !allowReorder ) { return; } const rowDragStartEvent = that.$.fireEvent( 'rowDragStart', { 'row': row, 'index': row.visibleIndex, 'data': null, 'originalEvent': event.originalEvent } ); if ( rowDragStartEvent.defaultPrevented ) { return; } that._dragDrop = new LW.Utilities.DragDrop( that ); that._dragDrop.capture( row.element, event ); that._dragDrop.row = row; that._recycle( false ); if ( that._dragInterval ) { clearInterval( that._dragInterval ); } that._dragInterval = setInterval( function () { const dragDetails = that._dragDrop.dragDetails; if ( !dragDetails.feedback ) { return; } const left = parseInt( dragDetails.feedback.style.left ); const top = parseInt( dragDetails.feedback.style.top ); const rect = that.getBoundingClientRect(); if ( that._dragLine ) { if ( rect.left <= left && rect.left + rect.width >= left ) { if ( top >= rect.top && top <= rect.top + 20 ) { that.scrollTop -= 5; } else if ( top >= rect.top + rect.height + 5 && top <= rect.top + rect.height + 20 ) { that.scrollTop += 5; } } } }, 10 ); } _beginDrag( event, item ) { const that = this; if ( !item.dataField ) { that._beginRowDrag( event, item ); return; } const column = item; if ( that.behavior.allowColumnReorder && column.allowReorder ) { const columnDragStartEvent = that.$.fireEvent( 'columnDragStart', { 'column': column, 'index': that.columns.indexOf( column ), 'data': null, 'originalEvent': event.originalEvent } ); if ( !columnDragStartEvent.defaultPrevented ) { that._dragDrop = new LW.Utilities.DragDrop( that ); that._dragDrop.capture( column.element, event ); that._dragDrop.column = column; const elements = that.columns.map( ( column ) => { return column.element; } ); if ( that.$.breadcrumb ) { that._dragDrop.items = elements.concat( that.$.breadcrumb._items ); } else { that._dragDrop.items = elements; } if ( that._dragInterval ) { clearInterval( that._dragInterval ); } that._dragInterval = setInterval( function () { const dragDetails = that._dragDrop.dragDetails; if ( !dragDetails.feedback ) { return; } const left = parseInt( dragDetails.feedback.style.left ); //const top = parseInt( dragDetails.feedback.style.top ); const rect = that.getBoundingClientRect(); if ( that._dragLine ) { if ( rect.left <= left && rect.left + rect.width >= left ) { if ( left >= rect.left && left <= rect.left + 20 ) { that.scrollLeft -= 5; } else if ( left >= rect.left + rect.width - 20 && left <= rect.left + rect.width ) { that.scrollLeft += 5; } } } }, 3 ); } } } _cancelDrag() { const that = this; if ( that._dragLine ) { if ( that._dragLine.parentNode ) { that._dragLine.parentNode.removeChild( that._dragLine ); } that._dragLine = null; } if ( that._dragDrop ) { that._dragDrop.removeFeedback(); that._dragDrop = null; } if ( that._dragInterval ) { clearInterval( that._dragInterval ); } that._recycle(); } _endDrag( event ) { const that = this; if ( that._dragDrop ) { const dragDetails = that._dragDrop.dragDetails; if ( !dragDetails.feedback || ( dragDetails.feedback && dragDetails.feedback.classList.contains( 'error' ) && !dragDetails.feedback.classList.contains( 'data' ) ) ) { that._cancelDrag(); return; } if ( event.key && event.key === 'Escape' ) { if ( that._dragDrop.column ) { that.$.fireEvent( 'columnDragCancel', { 'column': dragDetails.item.column, 'index': that.columns.indexOf( that._dragDrop.column ), 'data': that._dragDrop } ); } else if ( that._dragDrop.row ) { that.$.fireEvent( 'rowDragCancel', { 'row': that._dragDrop.row, 'index': that._dragDrop.row.visibleIndex, 'data': that._dragDrop } ); } that._cancelDrag(); return; } that.beginUpdate(); let target = dragDetails.target; const before = dragDetails.before; if ( that._dragDrop.column ) { if ( target && target.column && !( event.key === 'Escape' ) && !dragDetails.feedback.classList.contains( 'data' ) ) { const columnDragEndEvent = that.$.fireEvent( 'columnDragEnd', { 'column': that._dragDrop.column, 'index': that.columns.indexOf( that._dragDrop.column ), 'newIndex': that.columns.indexOf( target.column ), 'data': that._dragDrop, 'originalEvent': event.originalEvent } ); if ( !columnDragEndEvent.defaultPrevented ) { const columnIndex = that.columns.indexOf( that._dragDrop.column ); const newColumnIndex = that.columns.indexOf( target.column ); that._dragDrop.column.columnGroup = target.column.columnGroup; that.columns.move( columnIndex, newColumnIndex ); } } else { that.$.fireEvent( 'columnDragEnd', { 'column': that._dragDrop.column, 'index': that.columns.indexOf( that._dragDrop.column ), 'newIndex': -1, 'data': that._dragDrop, 'originalEvent': event.originalEvent } ); } if ( !( event.key === 'Escape' ) && that.$.breadcrumb ) { const breadcrumbRect = that.getBoundingRect( that.$.breadcrumb ); if ( event.originalEvent.pageY >= breadcrumbRect.top - that.scrollTop && event.originalEvent.pageY <= breadcrumbRect.bottom - that.scrollTop ) { const targetIndex = that.$.breadcrumb._items.indexOf( target ); const column = that._dragDrop.dragDetails.item.column; const newSource = that.$.breadcrumb.dataSource.slice( 0 ); newSource.splice( Math.max( 0, targetIndex + ( before ? 0 : 1 ) ), 0, { label: column.label, value: column.dataField } ); that.$.breadcrumb.dataSource = newSource; const dataSource = that.$.breadcrumb.dataSource.map( item => { return item.value; } ); that.dataSource.groupBy = dataSource; that.refresh( true ); that.refreshFilters(); } } } else if ( that._dragDrop.row ) { if ( target && target.row && !( event.key === 'Escape' ) && !dragDetails.feedback.classList.contains( 'data' ) ) { const rowDragEndEvent = that.$.fireEvent( 'rowDragEnd', { 'row': that._dragDrop.row, 'index': that._dragDrop.row.visibleIndex, 'newIndex': target.row.visibleIndex, 'data': that._dragDrop, 'originalEvent': event.originalEvent } ); if ( !rowDragEndEvent.defaultPrevented ) { const rowIndex = that._dragDrop.row.visibleIndex; let newRowIndex = target.row.visibleIndex; if ( !dragDetails.before ) { newRowIndex++; } if ( rowIndex < newRowIndex ) { newRowIndex--; } that.rows.move( rowIndex, newRowIndex ); } } else { that.$.fireEvent( 'rowDragEnd', { 'row': that._dragDrop.row, 'index': that._dragDrop.row.visibleIndex, 'newIndex': -1, 'data': that._dragDrop, 'originalEvent': event.originalEvent } ); } } that._cancelDrag(); that.endUpdate(); if ( that.columnGroups ) { that._renderColumns( true ); } } } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Menu', class Menu { _openColumnChooserMenu( column ) { const that = this; if ( !column ) { column = that._commandColumn; } if ( !column || ( that.menu && that.menu.column === column && column.element.hasAttribute( 'aria-controls' ) ) ) { that.closeMenu(); return; } if ( !that.menu ) { that.menu = document.createElement( 'div' ); that.menu.classList.add( 'lw-grid-column-menu' ); that.menu.setAttribute( 'theme', that.getAttribute( 'theme' ) ); that.menu.id = that.id + '_' + that.tagName.toLowerCase() + '_menu_' + Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 ); } if ( that.appearance.allowColumnMenuAnimation ) { that.menu.classList.add( 'lw-animate' ); } else { that.menu.classList.remove( 'lw-animate' ); } that._createColumnChooserMenuItems( column ); that.menu.style.height = that.columnMenu.height ? that.columnMenu.height + 'px' : 'auto'; if ( that.menu.column && that.menu.column !== column ) { that.menu.column.setProperty( 'menu', null ); that.menu.column = null; } document.body.appendChild( that.menu ); column.setProperty( 'menu', that.menu ); const columnRect = column.element.getBoundingClientRect(); that.menu.column = column; let left = columnRect.right - column.element.actionButton.getBoundingClientRect().width + window.pageXOffset; let top = columnRect.bottom + window.pageYOffset; if ( left + that.menu.offsetWidth > window.innerWidth ) { left = columnRect.right + window.pageXOffset - that.menu.offsetWidth; if ( left + that.menu.offsetWidth > window.innerWidth ) { left = window.innerWidth - that.menu.offsetWidth; } } that.menu.style.left = left + 'px'; that.menu.style.top = top + 'px'; that.menu.classList.remove( 'lw-hidden' ); that.menu.classList.add( 'open' ); } _openColumnFilterMenu( column ) { const that = this; if ( !column || ( that.filterRowMenu && that.filterRowMenu.column === column && column.element.hasAttribute( 'aria-controls' ) ) ) { that.closeMenu(); return; } if ( !that.filterRowMenu ) { that.filterRowMenu = document.createElement( 'div' ); that.filterRowMenu.classList.add( 'lw-grid-column-menu' ); that.filterRowMenu.setAttribute( 'theme', that.getAttribute( 'theme' ) ); that.filterRowMenu.id = that.id + '_' + that.tagName.toLowerCase() + '_menu_' + Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 ); } if ( that.appearance.allowColumnMenuAnimation ) { that.filterRowMenu.classList.add( 'lw-animate' ); } else { that.filterRowMenu.classList.remove( 'lw-animate' ); } that._createColumnFilterMenuItems( column ); that.filterRowMenu.style.height = that.columnMenu.height ? that.columnMenu.height + 'px' : 'auto'; if ( that.filterRowMenu.column && that.filterRowMenu.column !== column ) { that.filterRowMenu.column.setProperty( 'menu', null ); that.filterRowMenu.column = null; } document.body.appendChild( that.filterRowMenu ); column.setProperty( 'filterRowMenu', that.filterRowMenu ); const columnRect = column.element.getBoundingClientRect(); that.filterRowMenu.column = column; let left = columnRect.left + window.pageXOffset; let top = columnRect.bottom + that.layout.rowMinHeight + window.pageYOffset; if ( left + that.filterRowMenu.offsetWidth > window.innerWidth ) { left = columnRect.right + window.pageXOffset - that.filterRowMenu.offsetWidth; if ( left + that.filterRowMenu.offsetWidth > window.innerWidth ) { left = window.innerWidth - that.filterRowMenu.offsetWidth; } } that.filterRowMenu.style.left = left + 'px'; that.filterRowMenu.style.top = top + 'px'; that.filterRowMenu.classList.remove( 'lw-hidden' ); that.filterRowMenu.classList.add( 'open' ); setTimeout( () => { that.filterRowMenu.querySelector( 'lw-menu' ).focus(); }, 50 ) return that.filterRowMenu; } _openMenu( column ) { const that = this; if ( !column || ( that.menu && that.menu.column === column && column.element.hasAttribute( 'aria-controls' ) ) || that.columnMenu.enabled === false ) { that.closeMenu(); return; } that._closeMenu( that.filterRowMenu ); if ( !that.menu ) { that.menu = document.createElement( 'div' ); that.menu.classList.add( 'lw-grid-column-menu' ); that.menu.setAttribute( 'theme', that.getAttribute( 'theme' ) ); that.menu.id = that.id + '_' + that.tagName.toLowerCase() + '_menu_' + Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 ); } if ( that.appearance.allowColumnMenuAnimation ) { that.menu.classList.add( 'lw-animate' ); } else { that.menu.classList.remove( 'lw-animate' ); } if ( that.rightToLeft ) { that.menu.setAttribute( 'right-to-left', '' ); } else { that.menu.removeAttribute( 'right-to-left' ); } that._createMenuItems( column ); that._createFilterPanel( column ); that._filterMenuItemsVisibility( column ); that.menu.style.height = that.columnMenu.height ? that.columnMenu.height + 'px' : 'auto'; if ( that.menu.column && that.menu.column !== column ) { that.menu.column.setProperty( 'menu', null ); that.menu.column = null; } document.body.appendChild( that.menu ); column.setProperty( 'menu', that.menu ); const columnRect = column.element.getBoundingClientRect(); that.menu.column = column; let left = columnRect.right - column.element.actionButton.getBoundingClientRect().width + window.pageXOffset; let top = columnRect.bottom + window.pageYOffset; if ( that.rightToLeft ) { left = columnRect.left + window.pageXOffset - that.menu.offsetWidth + column.element.actionButton.getBoundingClientRect().width; if ( left < 0 ) { left = columnRect.left + window.pageXOffset; } } if ( left + that.menu.offsetWidth > window.innerWidth ) { left = columnRect.right + window.pageXOffset - that.menu.offsetWidth; if ( left + that.menu.offsetWidth > window.innerWidth ) { left = window.innerWidth - that.menu.offsetWidth; } } that.menu.style.left = left + 'px'; that.menu.style.top = top + 'px'; if ( !that.hasColumnMenu( column ) ) { that.closeMenu(); } else { that.menu.classList.remove( 'lw-hidden' ); } that.menu.classList.add( 'open' ); } _menuItemClick( event ) { const that = this; const details = event.detail; const menuItem = details.value; if ( menuItem && menuItem.properties ) { const command = menuItem.properties.command; if ( typeof command === 'function' ) { command.apply( that, [ menuItem.column, menuItem.properties ] ); } else if ( that[ command ] ) { that[ command ].apply( that, [ menuItem.column, menuItem.properties ] ); } if ( menuItem.column.autoCloseMenu ) { that.closeMenu(); } } } removeGroupByCommand( column ) { const that = this; that.removeGroup( column.dataField ); } groupByCommand( column ) { const that = this; if ( !that.dataSource ) { return; } that.addGroup( column.dataField ); } sortAscCommand( column ) { const that = this; that.sortBy( column.dataField, 'asc' ); } sortDescCommand( column ) { const that = this; that.sortBy( column.dataField, 'desc' ); } removeSortCommand( column ) { const that = this; that.sortBy( column.dataField, null ); } addFilterCommand(column) { const that = this; if (that.$.headerBar) { that.$.headerBar.openFilterPanel(column); } } removeFilterCommand(column) { const that = this; that.removeFilter(column.dataField); } /* { 'columnMenuCustomizeType': {command: 'customizeTypeCommand', enabled: true, visible: false, icon: 'lw-icon-customize', label: '{{messages}}'}}, { 'columnMenuItemRename': { command: 'renameCommand', enabled: true, visible: false, icon: 'lw-icon-rename', label: '{{messages}}' } }, { 'columnMenuItemEditDescription': { command: 'editDescriptionCommand', enabled: true, visible: false, icon: 'lw-icon-description', label: '{{messages}}' } }, { 'columnMenuItemDuplicate': { command: 'duplicateCommand', visible: false, enabled: true, icon: 'lw-icon-duplicate', label: '{{messages}}' } }, { 'columnMenuItemInsertLeft': { command: 'insertLeftCommand', visible: false, enabled: true, icon: 'lw-icon-insert-left', label: '{{messages}}' } }, { 'columnMenuItemInsertRight': { command: 'insertRightCommand', visible: false, enabled: true, icon: 'lw-icon-insert-right', label: '{{messages}}' } }, { 'columnMenuItemSortAsc': { command: 'sortAscCommand', visible: 'auto', enabled: true, icon: 'lw-icon-sort-a-z', label: '{{messages}}' } }, { 'columnMenuItemSortDesc': { command: 'sortDescCommand', visible: 'auto', enabled: true, icon: 'lw-icon-sort-z-a', label: '{{messages}}' } }, { 'columnMenuItemRemoveSort': { command: 'removeSortCommand', visible: 'auto', enabled: true, icon: 'lw-icon-cancel-circled', label: '{{messages}}' } }, { 'columnMenuItemFilter': { command: 'addFilterCommand', visible: 'auto', enabled: true, icon: 'lw-icon-add-filter', label: '{{messages}}' } }, { 'columnMenuItemRemoveFilter': { command: 'removeFilterCommand', enabled: true, visible: 'auto', icon: 'lw-icon-cancel-circled-outline', label: '{{messages}}' } }, { 'columnMenuItemGroupBy': { command: 'groupByCommand', enabled: true, visible: 'auto', icon: 'lw-icon-group-by', label: '{{messages}}' } }, { 'columnMenuItemHide': { command: 'hideColumnCommand', enabled: true, visible: false, icon: 'lw-icon-hide', label: '{{messages}}' } }, { 'columnMenuItemDelete': { command: 'deleteColumnCommand', enabled: true, visible: false, icon: 'lw-icon-delete', label: '{{messages}}' } } */ _removeMenu() { const that = this; if ( that.menu ) { const verticalMenu = that.menu.querySelector( 'lw-menu' ); if ( verticalMenu ) { that.menu.removeChild( verticalMenu ); } } if ( that.filterRowMenu ) { const verticalMenu = that.filterRowMenu.querySelector( 'lw-menu' ); if ( verticalMenu ) { that.filterRowMenu.removeChild( verticalMenu ); } } } _createColumnChooserMenuItems(/*column*/ ) { const that = this; that._removeMenu(); const verticalMenu = document.createElement( 'lw-menu' ); const menuContent = document.createDocumentFragment(); verticalMenu.mode = 'vertical'; verticalMenu.dropDownAppendTo = 'body'; verticalMenu.checkboxes = true; verticalMenu.checkable = true; verticalMenu.classList.add( 'lw-grid-column-chooser-menu' ); verticalMenu.rightToLeft = that.rightToLeft; for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; const menuItem = document.createElement( 'lw-menu-item' ); const icon = column.showIcon ? column.icon : ( column.visible ? 'lw-icon-eye' : 'lw-icon-eye-off' ); menuItem.checked = column.visible; if ( !column.allowHide ) { continue; } column.command = function ( column ) { column.visible = !column.visible; } menuItem.label = that.localize( column.label ) || column.label || column.dataField; menuItem.value = { column: column, properties: column }; if ( icon ) { menuItem.label = '<span class="lw-grid-icon ' + icon + '"></span>' + menuItem.label; } menuContent.appendChild( menuItem ); } verticalMenu.appendChild( menuContent ); that.menu.appendChild( verticalMenu ); that.menu.itemCheckChange = that._menuItemClick.bind( that ); that.menu.addEventListener( 'itemCheckChange', that.menu.itemCheckChange ); that.menu.addEventListener( 'keydown', that._keyDownHandler.bind( that ) ); } _createColumnFilterMenuItems( column ) { const that = this; that._removeMenu(); const verticalMenu = document.createElement( 'lw-menu' ); const menuContent = document.createDocumentFragment(); verticalMenu.mode = 'vertical'; verticalMenu.dropDownAppendTo = 'body'; verticalMenu.classList.add( 'lw-grid-column-filter-menu' ); verticalMenu.rightToLeft = that.rightToLeft; const dataSource = column._filterInfo.dataSource; for ( let i = 0; i < dataSource.length; i++ ) { const item = dataSource[ i ]; const menuItem = document.createElement( 'lw-menu-item' ); const icon = item.icon; menuItem.label = item.label; menuItem.value = { column: column, properties: item }; if ( icon ) { menuItem.label = '<span class="lw-grid-icon ' + icon + '"></span>' + menuItem.label; } if (column._filterInfo.condition === item.value) { menuItem.setAttribute('focus', ''); } menuContent.appendChild( menuItem ); } verticalMenu.appendChild( menuContent ); that.filterRowMenu.appendChild( verticalMenu ); that.filterRowMenu.itemClick = that._menuItemClick.bind( that ); that.filterRowMenu.addEventListener( 'itemClick', that.filterRowMenu.itemClick ); that.filterRowMenu.addEventListener( 'keydown', ( event ) => { if ( event.key === 'Escape' ) { that._closeMenu( that.filterRowMenu ); } } ); } _createMenuItems( column ) { const that = this; that._removeMenu(); const verticalMenu = document.createElement( 'lw-menu' ); const menuContent = document.createDocumentFragment(); const dataSource = column.menuItems || that.columnMenu.dataSource; verticalMenu.mode = 'vertical'; verticalMenu.dropDownAppendTo = 'body'; verticalMenu.rightToLeft = that.rightToLeft; for ( let item in dataSource ) { const properties = dataSource[ item ]; const menuItem = document.createElement( 'lw-menu-item' ); let icon = properties.icon; menuItem.label = that.localize( item ); menuItem.value = { column: column, properties: properties }; const sortString = ( asc ) => { if ( asc ) { if ( column.dataType === 'string' ) { return 'A  Z'; } else if ( column.dataType === 'number' || column.dataType === 'date' || column.dataType === 'time' ) { return '1  9'; } else if ( column.dataType === 'bool' || column.dataType === 'boolean' ) { return '0  1'; } } else { if ( column.dataType === 'string' ) { return 'Z  A'; } else if ( column.dataType === 'number' || column.dataType === 'date' || column.dataType === 'time' ) { return '9  1'; } else if ( column.dataType === 'bool' || column.dataType === 'boolean' ) { return '1  0'; } } } if ( item === 'columnMenuItemSortAsc' ) { menuItem.label = that.localize( item, { mode: sortString( true ) } ); if ( column.dataType !== 'string' ) { if ( properties.iconAlt ) { icon = properties.iconAlt; } } } else if ( item === 'columnMenuItemSortDesc' ) { menuItem.label = that.localize( item, { mode: sortString( false ) } ); if ( column.dataType !== 'string' ) { if ( properties.iconAlt ) { icon = properties.iconAlt; } } } if ( icon ) { menuItem.label = '<span class="lw-grid-icon ' + icon + '"></span>' + menuItem.label; } menuContent.appendChild( menuItem ); } verticalMenu.appendChild( menuContent ); if ( that._filterContainer ) { that.menu.insertBefore( verticalMenu, that._filterContainer ); } else { that.menu.appendChild( verticalMenu ); } that.menu.itemClick = that._menuItemClick.bind( that ); that.menu.addEventListener( 'itemClick', that.menu.itemClick ); that.menu.addEventListener( 'keydown', that._keyDownHandler.bind( that ) ); } _getFilterType( column ) { const dataType = column.dataType.endsWith( '?' ) ? column.dataType.substring( 0, column.dataType.length - 1 ) : column.dataType; let filterType = 'string'; switch ( dataType ) { case 'number': case 'int': case 'float': case 'int64': filterType = 'numeric'; break; case 'bool': case 'boolean': filterType = 'bool'; break; case 'date': case 'time': case 'datetime': filterType = 'date'; break; case 'any': filterType = 'any'; break; } return filterType; } _createFilterPanel( column ) { const that = this; if ( !LW.FilterPanel ) { return; } if ( that.filtering.enabled && that.filtering.filterMenu.visible && column.allowFilter && !that.filtering.filterRow.visible && (!that.header.visible || (that.header.visible && that.header.buttons.indexOf('filter') === -1))) { const filterType = that._getFilterType( column ); if ( that._filterPanel && that._filterPanel.parentNode ) { that._filterPanel.parentNode.removeChild( that._filterPanel ); } that._filterPanel = that._filterPanels[ filterType ]; that._filterPanel.dataField = column.dataField; that._filterPanel.rightToLeft = that.rightToLeft; if ( that.filtering.filterMenu.messages ) { that._filterPanel.messages = that.filtering.filterMenu.messages; } if ( column.filterMenuMode === 'excel' ) { that._filterPanel.dataField = column.dataField; if ( that.dataSource && that.dataSource.boundSource ) { that._filterPanel.data = that.dataSource.boundSource.toArray ? that.dataSource.boundSource.toArray() : that.dataSource.boundSource; } } that._filterPanel.mode = column.filterMenuMode; if ( !that._filterContainer ) { const filterContainer = document.createElement( 'div' ); filterContainer.classList.add( 'lw-filter-container' ); that._filterContainer = filterContainer; requestAnimationFrame( function () { that.menu.appendChild( filterContainer ); } ); that._applyFilterHandler = function () { that.addFilter( that._filterPanel.dataField, that._filterPanel.getFilter() ); const column = that.columnByDataField[ that._filterPanel.dataField ]; column._filterState = that._filterPanel.getState(); }; that._clearFilterHandler = function () { requestAnimationFrame( () => { that.removeFilter( that._filterPanel.dataField ); const column = that.columnByDataField[ that._filterPanel.dataField ]; column._filterState = null; } ); }; } that._filterContainer.appendChild( that._filterPanel ); that._filterPanel.classList.remove( 'lw-hidden' ); that._filterPanel.removeEventListener( 'filter', that._applyFilterHandler ); that._filterPanel.removeEventListener( 'clear', that._clearFilterHandler ); that._filterPanel.addEventListener( 'filter', that._applyFilterHandler ); that._filterPanel.addEventListener( 'clear', that._clearFilterHandler ); if ( column.filterMenuMode === 'none' || !that.filtering.filterMenu.visible || !LW.FilterPanel ) { that._filterContainer.classList.add( 'lw-hidden' ); } else { that._filterContainer.classList.remove( 'lw-hidden' ); } that._filterPanel.reset(); if ( column._filterState ) { that._filterPanel.loadState( column._filterState ); } else if ( column.filter ) { const columnFilterGroup = column.filter; const filterType = that._getFilterType( column ); let filters = columnFilterGroup.getFilters(); while ( filters.length > 0 && filters[ 0 ].type === 'FilterGroup' ) { filters = filters[ 0 ].value; } const conditions = columnFilterGroup.getConditions( filterType ); const firstFilterComparison = filters.length > 0 ? conditions.indexOf( filters[ 0 ].condition ) : -1; const secondFilterComparison = filters.length > 1 ? conditions.indexOf( filters[ 1 ].condition ) : -1; const firstFilterValue = filters.length > 0 ? filters[ 0 ].value : ''; const secondFilterValue = filters.length > 1 ? filters[ 1 ].value : ''; const logicalOperator = filters.length > 1 ? [ 'and', 'or' ].indexOf( filters[ 1 ].logicalOperator ) : 0; column._filterState = { firstFilterComparison: firstFilterComparison, firstFilterValue: firstFilterValue, logicalOperator: logicalOperator, secondFilterComparison: secondFilterComparison, secondFilterValue: secondFilterValue }; that._filterPanel.loadState( column._filterState ); } } else if ( that._filterPanel ) { that._filterPanel.parentNode.removeChild( that._filterPanel ); column._filterState = null; } } hasColumnMenu( column ) { const that = this; if ( that.columnMenu.enabled === false ) { return false; } const dataSource = column.menuItems || that.columnMenu.dataSource; let hiddenMenuItemsCount = 0; let length = 0; for ( let item in dataSource ) { const properties = dataSource[ item ]; length++; if ( properties.visible === false ) { hiddenMenuItemsCount++; } else if ( properties.visible === 'auto' ) { if ( item === 'columnMenuItemFilter' || item === 'columnMenuItemRemoveFilter' ) { if ( that.filtering.filterMenu.visible || that.filtering.filterRow.visible ) { if (!that.header.visible || (that.header.visible && that.header.buttons.indexOf('filter') === -1)) { hiddenMenuItemsCount++; } } } if ( item === 'columnMenuItemGroupBy' || item === 'columnMenuItemRemoveGroupBy' ) { if ( !column.allowGroup || !that.grouping.enabled ) { hiddenMenuItemsCount++; } } if ( item === 'columnMenuItemFilter' && !column.allowFilter ) { hiddenMenuItemsCount++; } if ( item === 'columnMenuItemRemoveFilter' && !column.allowFilter ) { hiddenMenuItemsCount++; } if ( item === 'columnMenuItemGroupBy' && !column.allowGroup ) { hiddenMenuItemsCount++; } if ( item === 'columnMenuItemSortAsc' || item === 'columnMenuItemSortDesc' || item === 'columnMenuItemRemoveSort' ) { if ( !column.allowSort || !that.sorting.enabled ) { hiddenMenuItemsCount++; } } } } const hasFilter = that.filtering.enabled && that.filtering.filterMenu.visible && column.filterMenuMode !== 'none'; if ( ( !hasFilter || !LW.FilterPanel ) && ( !LW.Menu || hiddenMenuItemsCount >= length ) ) { return false; } return true; } _filterMenuItemsVisibility( column ) { const that = this; const menuItems = ( that.menu.parentElement && ( that.enableShadowDOM || that.isInShadowDOM ) ? that.menu.firstElementChild.shadowRoot : that.menu ) .querySelectorAll( 'lw-menu-item' ); const dataSource = column.menuItems || that.columnMenu.dataSource; let index = 0; for ( let item in dataSource ) { const menuItem = menuItems[ index++ ]; const properties = dataSource[ item ]; menuItem.disabled = !properties.enabled; menuItem.classList.remove( 'lw-hidden' ); if ( item === 'columnMenuItemRemoveSort' ) { if ( column.sortOrder ) { menuItem.disabled = false; } else { menuItem.disabled = true; } } if ( item === 'columnMenuItemSortAsc' && column.sortOrder === 'asc' ) { menuItem.disabled = true; } else if ( item === 'columnMenuItemSortDesc' && column.sortOrder === 'desc' ) { menuItem.disabled = true; } if ( properties.visible === true ) { menuItem.classList.remove( 'lw-hidden' ); } else if ( properties.visible === false ) { menuItem.classList.add( 'lw-hidden' ); } else if ( properties.visible === 'auto' ) { if ( item === 'columnMenuItemFilter' || item === 'columnMenuItemRemoveFilter' ) { if ( that.filtering.enabled === false ) { menuItem.classList.add( 'lw-hidden' ); } else { if ( that.filtering.filterMenu.visible || that.filtering.filterRow.visible ) { menuItem.classList.add( 'lw-hidden' ); } if ( that.header.visible && that.header.buttons.indexOf('filter') >= 0) { menuItem.classList.remove( 'lw-hidden' ); } } } if ( item === 'columnMenuItemGroupBy' ) { if ( that.grouping.enabled && column.allowGroup ) { menuItem.classList.remove( 'lw-hidden' ); } else { menuItem.classList.add( 'lw-hidden' ); } const groupIndex = that.dataSource.groupBy.indexOf( column.dataField ); if ( groupIndex >= 0 ) { menuItem.disabled = true; } else { menuItem.disabled = false; } } if ( item === 'columnMenuItemRemoveGroupBy' ) { if ( that.grouping.enabled && column.allowGroup ) { menuItem.classList.remove( 'lw-hidden' ); } else { menuItem.classList.add( 'lw-hidden' ); } const groupIndex = that.dataSource.groupBy.indexOf( column.dataField ); if ( groupIndex < 0 ) { menuItem.disabled = true; } else { menuItem.disabled = false; } } if ( item === 'columnMenuItemFilter' && !column.allowFilter ) { menuItem.classList.add( 'lw-hidden' ); } if ( item === 'columnMenuItemRemoveFilter' && !column.allowFilter ) { menuItem.classList.add( 'lw-hidden' ); } if ( item === 'columnMenuItemSortAsc' || item === 'columnMenuItemSortDesc' || item === 'columnMenuItemRemoveSort' ) { if ( column.allowSort && that.sorting.enabled ) { menuItem.classList.remove( 'lw-hidden' ); } else { menuItem.classList.add( 'lw-hidden' ); } } } } } /* Public API */ openMenu( dataField ) { const that = this; const column = that.columnByDataField[ dataField ]; if ( !column ) { return; } that._openMenu( column ); } hasMenu() { const that = this; if ( that.menu && that.menu.column ) { if ( that.menu.parentNode ) { return true; } } return false; } _closeMenu( menu ) { const that = this; const close = ( menu ) => { if ( menu && menu.column ) { if ( menu.column ) { menu.column.setProperty( 'menu', null ); menu.column = null; } if ( menu.parentNode ) { menu.classList.remove( 'open' ); if ( !that.appearance.allowColumnMenuAnimation ) { menu.parentNode.removeChild( menu ); } } menu.removeEventListener( 'keydown', that._keyDownHandler.bind( that ) ); menu.removeEventListener( 'itemClick', menu.itemClick ); menu.removeEventListener( 'itemCheckChange', menu.itemCheckChange ); that.focus(); } } close( menu ); } closeMenu() { const that = this; const menu = that.menu; that._closeMenu( menu ); that._closeMenu( that.filterRowMenu ); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('Grid.Pager', class Pager { _refreshPaging(pageIndexChanged) { const that = this; requestAnimationFrame(() => { that._refreshLayout(); that._refreshSelection(); if (!pageIndexChanged) { that._initializeRowElements(); that._refreshLayout(); } if (that.dataSource && that.dataSource.virtualDataSource) { that._virtualDataRequest(!pageIndexChanged ? 'pageSizeChange' : 'pageIndexChange'); } else { that._recycle(false); } const first = that.paging.pageIndex * that.paging.pageSize; const last = first + that.paging.pageSize; that.$.fireEvent('page', { 'data': { first: first, last: last, size: last - first } }); }); } _refreshPagesCount() { const that = this; const getPagesCount = function () { const visibleRows = that.getVisibleRows(); let rowsCount = visibleRows.length; if (that.rowHierarchy) { rowsCount = 0; for (let i = 0; i < visibleRows.length; i++) { const row = visibleRows[i]; if (row.level === 0 && !row.parent) { rowsCount++; } } if (that.dataSource.virtualDataSourceLength !== undefined) { rowsCount = that.dataSource.virtualDataSourceLength; } } return { pagesCount: Math.ceil(rowsCount / that.paging.pageSize), totalRecords: rowsCount }; } const headerPager = that.$.headerPager.querySelector('lw-pager'); const pagesCountInfo = getPagesCount(); if (headerPager) { headerPager.pagesCount = pagesCountInfo.pagesCount; headerPager.totalRecords = pagesCountInfo.totalRecords; } const footerPager = that.$.footerPager.querySelector('lw-pager'); if (headerPager) { footerPager.pagesCount = pagesCountInfo.pagesCount; footerPager.totalRecords = pagesCountInfo.totalRecords; } if (that.paging.pageIndex > pagesCountInfo.pagesCount) { that.paging.pageIndex = pagesCountInfo.pagesCount - 1; that._refreshPaging(that.paging.pageIndex); } } _renderPagers() { const that = this; if (that.pager.visible) { requestAnimationFrame(() => { const headerPager = document.createElement('lw-pager'); const footerPager = document.createElement('lw-pager'); that.$.headerPager.innerHTML = ''; that.$.footerPager.innerHTML = ''; that.$.headerPager.appendChild(headerPager); that.$.footerPager.appendChild(footerPager); const localizePager = function (pager) { const messages = pager.messages[that.locale] if (!messages) { pager.messages[that.locale] = { }; } Object.assign(pager.messages[that.locale], { 'firstButton': that.localize('pagerFirstButton'), 'lastButton': that.localize('pagerLastButton'), 'previousButton': that.localize('pagerPreviousButton'), 'nextButton': that.localize('pagerNextButton'), 'navigateToLabel': that.localize('pagerNavigateToLabel'), 'pageSizeLabel': that.localize('pagerPageSizeLabel'), 'navigateToInputPlaceholder': that.localize('pagerNavigateToInputPlaceholder'), 'ellipsis': that.localize('pagerEllipsis'), 'summaryString': that.localize('pagerSummaryString'), 'summaryPrefix': that.localize('pagerSummaryPrefix'), 'summarySuffix': that.localize('pagerSummarySuffix'), }); } const getPagesCount = function () { const visibleRows = that.getVisibleRows(); let rowsCount = visibleRows.length; if (that.rowHierarchy) { rowsCount = 0; for (let i = 0; i < visibleRows.length; i++) { const row = visibleRows[i]; if (row.level === 0 && !row.parent) { rowsCount++; } } if (that.dataSource.virtualDataSourceLength !== undefined) { rowsCount = that.dataSource.virtualDataSourceLength; } } return { pagesCount: Math.ceil(rowsCount / that.paging.pageSize), totalRecords: rowsCount }; } const addPropertyBindings = function (pager, pagerPosition) { const id = pagerPosition + 'GridPager', pagesCountInfo = getPagesCount(); pager.setAttribute('lw-id', id); that.$[id] = pager; that['$' + id] = LW.Utilities.Extend(pager); pager.beginUpdate(); that.addPropertyBinding('[[pager_navigationButtons_position]]', 'navigationButtonsPosition', pager); that.addPropertyBinding('[[pager_navigationButtons_firstLastButtons_visible]]', 'showFirstLastNavigationButtons', pager); that.addPropertyBinding('[[pager_navigationButtons_prevNextButtons_visible]]', 'showPrevNextNavigationButtons', pager); that.addPropertyBinding('[[pager_navigationButtons_labels_visible]]', 'showNavigationButtonLabels', pager); that.addPropertyBinding('[[pager_pageIndexSelectors_visible]]', 'showPageIndexSelectors', pager); that.addPropertyBinding('[[pager_pageIndexSelectors_dataSource]]', 'pageIndexSelectors', pager); that.addPropertyBinding('[[pager_summary_visible]]', 'showSummary', pager); that.addPropertyBinding('[[pager_summary_position]]', 'summaryPosition', pager); that.addPropertyBinding('[[pager_navigationInput_visible]]', 'showNavigationInput', pager); that.addPropertyBinding('[[pager_navigationInput_position]]', 'navigationInputPosition', pager); that.addPropertyBinding('[[pager_pageSizeSelector_visible]]', 'showPageSizeSelector', pager); that.addPropertyBinding('[[pager_pageSizeSelector_dataSource]]', 'pageSizeSelectorDataSource', pager); that.addPropertyBinding('[[pager_pageSizeSelector_position]]', 'pageSizeSelectorPosition', pager); that.addPropertyBinding('[[pager_autoEllipsis]]', 'autoEllipsis', pager); that.addPropertyBinding('[[!paging_enabled]]', 'disabled', pager); that.addPropertyBinding('{{paging_pageIndex}}', 'pageIndex', pager); that.addPropertyBinding('{{paging_pageSize}}', 'pageSize', pager); that.addPropertyBinding('{{rightToLeft}}', 'rightToLeft', pager); pager.pagesCount = pagesCountInfo.pagesCount; pager.totalRecords = pagesCountInfo.totalRecords; pager.$.pageSizeSelector.dropDownAppendTo = 'body'; pager.$.pageSizeSelector.selectedIndexes = [0]; that['$' + id].listen('change', function (event) { const pagesCountInfo = getPagesCount(); pager.pagesCount = pagesCountInfo.pagesCount; pager.totalRecords = pagesCountInfo.totalRecords; if (that.paging.pageIndex > pager.pagesCount) { that.paging.pageIndex = pager.pagesCount - 1; } headerPager.refresh(); footerPager.refresh(); const pageIndexChanged = (event.detail && event.detail.index !== undefined) || event.target.value !== undefined; that._refreshPaging(pageIndexChanged); }); pager.endUpdate(); } addPropertyBindings(headerPager, 'header'); addPropertyBindings(footerPager, 'footer'); localizePager(headerPager); localizePager(footerPager); }); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Filter', class Filter { addFilter( dataField, filter, refreshFilters ) { const that = this; const column = that.columnByDataField[ dataField ]; if ( typeof filter === 'string' ) { filter = that.dataSource._createFilter( column.dataType, [ filter ] ); } if ( column && column.canNotify ) { column.setProperty( 'filter', filter ); if ( that._isUpdating ) { return; } if ( refreshFilters !== false ) { that.refreshFilters(); } } } removeFilter( dataField, refreshFilters ) { const that = this; const column = that.columnByDataField[ dataField ]; if ( column && column.canNotify ) { column.setProperty( 'filter', null ); if ( that._isUpdating ) { return; } if ( refreshFilters !== false ) { that.refreshFilters(); } } } clearFilter() { const that = this; for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; column.setProperty( 'filter', null ); } that.refreshFilters(); } getFilteredColumns() { const that = this; if ( that._filters ) { const columns = []; for ( let i = 0; i < that._filters.length; i++ ) { const filter = that._filters[ i ]; columns[ filter[ 0 ] ] = filter[ 1 ]; columns.length++; } return columns; } return []; } getVisibleRows() { const that = this; if ( that._visibleRows ) { return that._visibleRows; } const visibleRows = []; const viewRows = that._viewRows; const offset = that.editing.addNewRow.visible && that.editing.addNewRow.position !== 'far' ? 1 : 0; for ( let i = 0; i < viewRows.length; i++ ) { const row = viewRows[ i ]; row.canNotify = false; row.visibleIndex = -1; if ( row.visible && ( row.filtered !== false || row.filtered === undefined ) ) { row.visibleIndex = visibleRows.length - offset; visibleRows.push( row ); } row.canNotify = true; } that._visibleRows = visibleRows; return visibleRows; } refreshFilters() { const that = this; const filters = []; if ( !that._filters ) { that._filters = []; } for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; if ( column.filter ) { filters.push( [ column.dataField, column.filter ] ); } } that.scrollTop = 0; that.closeMenu(); if ( that.dataSource && !that.dataSource.onFilter ) { that.dataSource.onFilter = function () { const viewRows = that._viewRows; for ( let i = 0; i < viewRows.length; i++ ) { const row = viewRows[ i ]; if ( row.data && !row.addNewRow ) { row.filtered = row.data.$.filtered !== undefined ? row.data.$.filtered : true; } } that.refresh(); } } if ( JSON.stringify( that._filters ) === JSON.stringify( filters ) ) { that._visibleRows = null; return; } that._filters = filters; that._visibleRows = null; if ( that.dataSource && that.dataSource.virtualDataSource ) { that.closeMenu(); that._virtualDataRequest( 'filter' ); } else { const operator = that._filterOperator || 'and'; that.dataSource._filter( filters, operator ); } if ( that.paging.enabled && that.dataSource && !that.dataSource.virtualDataSource ) { that._refreshPagesCount(); } let detailColumns = []; for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; if ( column.filter ) { detailColumns.push( column ); } } let data = []; if ( that._filters ) { for ( let i = 0; i < that._filters.length; i++ ) { const filter = that._filters[ i ]; data.push( {dataField: filter[ 0 ], filter: filter[ 1 ]} ); } } that.$.fireEvent( 'filter', { 'columns': detailColumns, 'data': data } ); } _handleFilterCellFocus( cell ) { const that = this; const filterInfo = cell.column._filterInfo; const editor = filterInfo.editor; const input = filterInfo.input; const column = cell.column; const dataType = column.dataType; editor.setAttribute( 'focus', '' ); that.filtering.filterRow.cell = cell; if ( filterInfo.condition === 'RANGE' ) { that._openFilterCellDialog( cell, ( column ) => { const filterInfo = column._filterInfo; const editor = filterInfo.editor; const range = filterInfo.range; const input = filterInfo.input; const cell = filterInfo.cell; if ( range ) { const filterGroup = new LW.FilterGroup(); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, range.min, 'GREATER_THAN_OR_EQUAL' ) ); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, range.max, 'LESS_THAN_OR_EQUAL' ) ); that.addFilter( column.dataField, filterGroup ); } else { that.removeFilter( column.dataField ); } if ( !editor ) { return; } if ( input ) { input.type = ''; if ( !range ) { input.value = ''; } else { const min = cell.getFormattedValue( range.min, column.cellsFormat ); const max = cell.getFormattedValue( range.max, column.cellsFormat ); input.value = min + ' - ' + max; } } } ); } else { if ( dataType === 'number' || dataType === 'int' || dataType === 'float' ) { input.type = 'number'; } else { input.type = ''; } if ( filterInfo.value ) { input.value = filterInfo.value; if (dataType === 'date') { input.value = cell.getFormattedValue( filterInfo.value, column.cellsFormat ); } } } } _handleFilterCellBlur( cell ) { const that = this; const filterInfo = cell.column._filterInfo; const editor = filterInfo.editor; const input = filterInfo.input; const column = cell.column; const condition = filterInfo.condition; that.filtering.filterRow.cell = null; if (column.filterRowMenu && column.filterRowMenu.classList.contains( 'open' )) { editor.removeAttribute( 'focus' ); return; } if ( input.value !== '' && condition !== 'RANGE' ) { if ( column.dataType === 'date' ) { filterInfo.value = new Date( input.value ); input.value = cell.getFormattedValue( filterInfo.value, column.cellsFormat ); } else if ( column.dataType === 'number' || column.dataType === 'int' || column.dataType === 'float' ) { filterInfo.value = parseFloat( input.value ); input.type = ''; input.value = cell.getFormattedValue( filterInfo.value, column.cellsFormat ); } else { filterInfo.value = input.value; } } if (that.filtering.filterRow.applyMode === 'auto') { that._handleFilterCellValue(cell); } editor.removeAttribute( 'focus' ); } _handleFilterCellValue(cell) { const that = this; const filterInfo = cell.column._filterInfo; const column = cell.column; const condition = filterInfo.condition; if (condition === 'RANGE') { const range = filterInfo.range; if (range) { const filterGroup = new LW.FilterGroup(); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, range.min, 'GREATER_THAN_OR_EQUAL' ) ); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, range.max, 'LESS_THAN_OR_EQUAL' ) ); that.addFilter( column.dataField, filterGroup ); } else { that.removeFilter(column.dataField); } } else { const value = filterInfo.value; if (value !== '' && value !== undefined) { const filterGroup = new LW.FilterGroup(); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, value, filterInfo.condition || (column.dataType === 'string' ? 'CONTAINS' : 'EQUAL' )) ); that.addFilter( column.dataField, filterGroup ); } else { that.removeFilter(column.dataField); } } } _handleFilterCellKeyDown( cell, event ) { const that = this; const column = cell.column; const input = column._filterInfo.input; if (event.ctrlKey && event.key === 'a') { input.select(); } else if (event.altKey && event.key === 'ArrowDown') { that._handleFilterCellIconClick(cell); } } _handleFilterCellKeyUp( cell, event ) { const column = cell.column; const input = column._filterInfo.input; const that = this; const filterInfo = column._filterInfo; const key = event.key; filterInfo.value = input.value; if (key === 'Escape') { filterInfo.value = ''; filterInfo.range = null; input.value = ''; } if (key === 'Enter' || key === 'Escape' || input.value === '') { that._handleFilterCellValue(cell); } else if (that.filtering.filterRow.applyMode === 'auto' && key !== 'Ctrl' && key !== 'Shift') { that._filterRowTimer = setTimeout(() => { that._handleFilterCellValue(cell); }, that.filtering.filterRow.autoApplyModeDelay); } if (event.ctrlKey && key === 'a') { input.select(); } } _handleFilterCellCheckBoxClick(cell) { const that = this; const column = cell.column; const filterInfo = column._filterInfo; if (filterInfo.value === undefined) { filterInfo.value = null; } if (filterInfo.value === true) { filterInfo.value = false; } else if (filterInfo.value === false) { filterInfo.value = null; } else if (filterInfo.value === null) { filterInfo.value = true; } const checkbox = cell.element.querySelector('.lw-input'); if (filterInfo.value) { checkbox.setAttribute('checked', filterInfo.value); } else if (filterInfo.value === null) { checkbox.setAttribute('checked', 'indeterminate') } else { checkbox.removeAttribute('checked'); } if (filterInfo.value === null) { that.removeFilter(column.dataField); return; } const filterGroup = new LW.FilterGroup(); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, filterInfo.value === true ? true : false, 'EQUAL' ) ); that.addFilter( column.dataField, filterGroup ); } _handleFilterCellIconClick( cell ) { const that = this; const column = cell.column; if ( column.filterRowMenu && column.filterRowMenu.classList.contains( 'open' ) ) { that._closeMenu( column.filterRowMenu ); return; } that._openColumnFilterMenu( column ); } _handleFilterCalendarCellClick( cell ) { const that = this; that._openFilterCellDialog( cell, ( column ) => { const filterInfo = column._filterInfo; const input = filterInfo.editor.querySelector( 'input' ); const value = filterInfo.value; if ( input ) { if ( !value ) { input.value = ''; that.removeFilter( column.dataField ); } else { input.value = cell.getFormattedValue( value, column.cellsFormat || '' ); const filterGroup = new LW.FilterGroup(); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, value, filterInfo.condition || 'EQUAL' ) ); that.addFilter( column.dataField, filterGroup ); } } } ); } _handleFilterMenuClick( column, properties ) { const that = this; const filterInfo = column._filterInfo; const editor = filterInfo.editor; const input = filterInfo.input; editor.firstElementChild.innerHTML = `<i class="lw-grid-icon ${properties.icon} show"></i>`; if ( properties.value === 'CLEAR_FILTER' ) { input.value = ''; editor.firstElementChild.innerHTML = '<i class="lw-grid-icon lw-icon-search show"></i>'; filterInfo.condition = null; filterInfo.value = ''; filterInfo.range = null; } input.type = ''; if ( filterInfo.condition === 'RANGE' && properties.value !== 'RANGE' ) { let range = filterInfo.range; filterInfo.value = range.min; } else if ( properties.value === 'RANGE' && filterInfo.condition !== 'RANGE' && filterInfo.condition !== null ) { let range = filterInfo.range; if ( filterInfo.value ) { range = {min: filterInfo.value, max: filterInfo.value}; filterInfo.range = range; } } if ( properties.value === 'RANGE' ) { input.readonly = true; const filterGroup = new LW.FilterGroup(); const range = filterInfo.range; if (range) { filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, range.min, 'GREATER_THAN_OR_EQUAL' ) ); filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, range.max, 'LESS_THAN_OR_EQUAL' ) ); that.addFilter( column.dataField, filterGroup ); const min = filterInfo.cell.getFormattedValue( range.min, column.cellsFormat ); const max = filterInfo.cell.getFormattedValue( range.max, column.cellsFormat ); input.value = min + ' - ' + max; } else { input.value = ''; } filterInfo.condition = properties.value; return; } else { input.readonly = false; } if (properties.value !== 'CLEAR_FILTER') { filterInfo.condition = properties.value; } if ( input.value === '' ) { that.removeFilter( column.dataField ); } else { const filterGroup = new LW.FilterGroup(); const value = filterInfo.value; filterGroup.addFilter( 'and', filterGroup.createFilter( column.dataType, value, filterInfo.condition || 'EQUAL' ) ); that.addFilter( column.dataField, filterGroup ); input.value = filterInfo.cell.getFormattedValue( value, column.cellsFormat ); } setTimeout(() => { input.focus(); },25); } _handleFilterNumberCellEditor(cell, element, customSpinFn) { const numberInput = element.querySelector( 'input' ); const spinnerUp = element.querySelector( '.up' ); const spinnerDown = element.querySelector( '.down' ); const column = cell.column; const that = this; let spinValue = (step) => { const filterInfo = column._filterInfo; if (filterInfo.condition === 'RANGE') { numberInput.focus(); return; } let oldValue = parseFloat( filterInfo.value ); if ( isNaN( oldValue ) ) { filterInfo.value = 0; numberInput.value = 0; return; } const condition = step < 0 ? ( oldValue > numberInput.min || numberInput.min === '' ) : oldValue < numberInput.max || numberInput.max === '' ; if ( condition) { numberInput.value = oldValue + step; filterInfo.value = numberInput.value; numberInput.focus(); that._handleFilterCellValue(cell); } } if (customSpinFn) { spinValue = customSpinFn; } const setupSpinButtons = (button, step) => { let spin, spinInterval; button.onpointerdown = function (event) { spinValue(step); if (spin) { clearTimeout(spin); } spin = setTimeout(() => { if (spinInterval) { clearInterval(spinInterval); } spinInterval = setInterval(() => { spinValue(step); }, 50); }, 300); event.preventDefault(); event.stopPropagation(); }; button.onpointerup = () => { if (spinInterval) { clearInterval(spinInterval); } if (spin) { clearTimeout(spin); } spinInterval = null; } button.onpointerenter = () => { if (spinInterval) { clearInterval(spinInterval); spinInterval = setInterval(() => { spinValue(1); }, 50); } } button.onpointerleave = () => { clearInterval(spinInterval); } document.addEventListener('pointerup', ()=> { if (spinInterval) { clearInterval(spinInterval); } spinInterval = null; if (spin) { clearTimeout(spin); } }); } setupSpinButtons(spinnerUp, 1); setupSpinButtons(spinnerDown, -1); } _openFilterCellDialog( cell, confirm ) { const that = this; const dialog = that._dialogFilter || that._createDialog(); const header = that.localize( 'dialogFilterHeader' ) + ' ' + cell.column.label; const content = dialog.content; dialog.header.innerHTML = header; dialog.confirm = confirm; let layoutRow = null; let layoutRowIndex = 0; if ( !that._cellEditors ) { that._cellEditors = []; } if ( !that._dialogFilter ) { dialog.modal = true; dialog.btnConfirm.innerHTML = that.localize( 'dialogFilterButtonConfirm' ); dialog.btnCancel.innerHTML = that.localize( 'dialogFilterButtonCancel' ); dialog.onOpen = function () { dialog.focus(); const cell = that._dialogFilterCell; const range = cell.column._filterInfo.range; const value = cell.column._filterInfo.value; if ( cell.column.dataType === 'date' ) { const calendar = content.querySelector( 'lw-calendar' ); setTimeout( () => { if ( cell.column._filterInfo.condition === 'RANGE' && range ) { calendar.selectedDates = [ new Date( range.min.getTime() ), new Date( range.max.getTime() ) ]; calendar._selectMultipleDates( new Date( range.min.getTime() ), new Date( range.max.getTime() ) ); } else if ( value ) { calendar.selectedDates = [ new Date( value.getTime() ) ]; } calendar.focus(); }, 100 ); calendar.focus(); } else { const inputs = content.querySelectorAll( 'input' ); inputs[ 0 ].focus(); if ( range ) { inputs[ 0 ].value = range.min; inputs[ 1 ].value = range.max; } } } dialog.onClose = function () { } dialog.btnCancel.onclick = function () { dialog.close(); const cell = that._dialogFilterCell; cell.column._filterInfo.range = null; cell.column._filterInfo.value = null; dialog.confirm( cell.column ); } dialog.btnClose.onclick = function () { dialog.close(); } dialog.btnConfirm.onclick = function () { const cell = that._dialogFilterCell; cell.column._filterInfo.range = null; cell.column._filterInfo.value = null; if ( cell.column.dataType === 'date' ) { const calendar = content.querySelector( 'lw-calendar' ); const dates = calendar.selectedDates; if ( calendar.selectionMode === 'range' ) { cell.column._filterInfo.range = {min: new Date( dates[ 0 ].getTime() ), max: new Date( dates[ dates.length - 1 ].getTime() )}; } else { cell.column._filterInfo.value = new Date( dates[ 0 ].getTime() ); } } else { const numberInputs = content.querySelectorAll( 'input' ); let min = numberInputs[ 0 ].value; let max = numberInputs[ 1 ].value; if ( max === '' ) { max = 100; } if ( min === '' ) { min = 0; } cell.column._filterInfo.range = {min: min, max: max}; } dialog.confirm( cell.column ); dialog.close(); } dialog.onkeydown = function ( event ) { const key = event.key; if ( key === 'Enter' ) { dialog.btnConfirm.onclick(); } else if ( key === 'Escape' ) { dialog.close(); } } } content.classList.remove( 'lw-grid-layout' ); content.innerHTML = ''; const validate = () => { const inputs = content.querySelectorAll( 'input' ); dialog.btnConfirm.disabled = true; if ( inputs[ 0 ].value === '' ) { inputs[ 0 ].value = 0; } if ( inputs[ 1 ].value === '' ) { inputs[ 1 ].value = 100; } let min = parseFloat( inputs[ 0 ].value ); let max = parseFloat( inputs[ 1 ].value ); if ( min <= max ) { dialog.btnConfirm.disabled = false; } } if ( cell.column.dataType !== 'date' ) { content.classList.add( 'lw-grid-layout' ); } for ( let i = 0; i < 2; i++ ) { const column = cell.column; if ( column.dataType === 'date' ) { const fieldEditor = document.createElement( 'div' ); if ( column._filterInfo.condition === 'RANGE' ) { fieldEditor.innerHTML = '<lw-calendar selection-mode="range"></lw-calendar>'; } else { fieldEditor.innerHTML = '<lw-calendar></lw-calendar>'; } content.appendChild( fieldEditor ); break; } if ( layoutRowIndex % 2 === 0 ) { layoutRow = document.createElement( 'div' ); layoutRow.classList.add( 'row' ); content.appendChild( layoutRow ); } const col = document.createElement( 'div' ); col.classList.add( 'col-sm-6' ); const stack = document.createElement( 'div' ); stack.classList.add( 'column' ); const label = document.createElement( 'label' ); label.innerHTML = i === 0 ? that.localize( 'dialogFilterMinLabel' ) : that.localize( 'dialogFilterMaxLabel' ); const fieldEditor = document.createElement( 'div' ); fieldEditor.classList.add( 'lw-grid-dialog-editor' ) fieldEditor.setAttribute( 'editor', column.dataField ); fieldEditor.setAttribute( 'template', column.editor.template ); col.appendChild( stack ); layoutRow.appendChild( col ); stack.appendChild( label ); stack.appendChild( fieldEditor ); layoutRowIndex++; fieldEditor.innerHTML = '<div class="lw-grid-cell-editor lw-filter-input-value lw-grid-number-input-cell-editor"><input class="lw-input" type="number"><div class="nav"><div tabindex="-1" class="up"></div><div tabindex="-1" class="down"></div></div></div>'; const numberInput = fieldEditor.querySelector( 'input' ); numberInput.onchange = () => { validate(); } that._handleFilterNumberCellEditor(cell, fieldEditor, (step) => { let oldValue = parseFloat(numberInput.value); if ( isNaN( oldValue ) ) { numberInput.value = 0; return; } const condition = step < 0 ? ( oldValue > numberInput.min || numberInput.min === '' ) : oldValue < numberInput.max || numberInput.max === '' ; if ( condition) { numberInput.value = oldValue + step; } validate(); }) } that._dialogFilter = dialog; that._dialogFilterCell = cell; const columnRect = cell.column.element.getBoundingClientRect(); const offset = that.offset( that ); let left = columnRect.left + window.pageXOffset - offset.left; let top = columnRect.bottom + that.layout.rowMinHeight + window.pageYOffset - offset.top; dialog.open( left, top ); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('Grid.Sort', class Sort { clearSort() { const that = this; if (that._isSorting) { return; } if (!that.dataSource) { return; } that._isSorting = true; that.dataSource.clearSort(); if (!that._sortedColumns) { that._sortedColumns = []; } for (let i = 0; i < that._sortedColumns.length; i++) { const sortColumn = that._sortedColumns[i]; const column = that.columnByDataField[sortColumn.dataField]; if (!column) { continue; } column.setProperty('sortOrder', null); column.setProperty('sortIndex', null); } that._sortedColumns = []; for (let i = 0; i < that.dataSource.length; i++) { const row = that.rows[i]; const data = that.dataSource[i]; if (row) { row.data = data; row.boundIndex = data.boundIndex; } } that._recycle(); that._refreshHeaderBar(); that._isSorting = false; } getSortedColumns() { const that = this; const sortedColumns = []; if (that._sortedColumns) { for (let i = 0; i < that._sortedColumns.length; i++) { const sortColumn = that._sortedColumns[i]; sortedColumns[sortColumn.dataField] = { sortOrder: sortColumn.sortOrder, sortIndex: sortColumn.sortIndex }; sortedColumns.length++; } } return sortedColumns; } addSort(dataField, sortOrder) { const that = this; that.sortBy(dataField, sortOrder); } removeSort(dataField) { const that = this; that.sortBy(dataField, null); } refreshSort() { const that = this; that._refreshSort(that._sortedColumns); } _refreshSort(sortedColumns) { const that = this; if (that._isSorting || !sortedColumns) { return; } const sortDataFields = []; const sortOrders = []; const sortDataTypes = []; that._isSorting = true; for (let i = 0; i < sortedColumns.length; i++) { const sortColumn = sortedColumns[i]; const column = that.columnByDataField[sortColumn.dataField]; if (!column) { continue; } column.setProperty('sortOrder', sortColumn.sortOrder); sortDataFields.push(sortColumn.dataField); sortOrders.push(sortColumn.sortOrder); sortDataTypes.push(sortColumn.dataType); } const sort = function () { if (that.dataSource && that.dataSource.virtualDataSource) { that._virtualDataRequest('sort'); } else { that.dataSource.sortBy(sortDataFields, sortDataTypes, sortOrders); if (that.dataSource.boundHierarchy) { that._refreshRowHierarchy(); if (that.dataSource.groupBy.length > 0) { that.refresh(); } } else { for (let i = 0; i < that.dataSource.length; i++) { const row = that.rows[i]; const data = that.dataSource[i]; row.data = data; row.boundIndex = data.boundIndex; } } that._recycle(); } } sort(); that._refreshHeaderBar(); that._isSorting = false; that._sortedColumns = sortedColumns; } sortBy(columnDataField, sortOrder) { const that = this; const column = that.columnByDataField[columnDataField]; const sortDataFields = []; const sortOrders = []; const sortDataTypes = []; const toggleSort = sortOrder === undefined ? true : false; if (that._isSorting || !column) { return; } that._isSorting = true; if (sortOrder === 'descending') { sortOrder = 'desc'; } if (undefined === sortOrder || sortOrder === 'ascending') { sortOrder = 'asc'; } const clearSortColumn = function (column) { if (column) { column.setProperty('sortOrder', null); } } const clearSortColumns = function () { if (that._sortedColumns.length > 0) { for (let i = 0; i < that._sortedColumns.length; i++) { const sortColumn = that._sortedColumns[i]; const column = that.columnByDataField[sortColumn.dataField]; clearSortColumn(column); } } that._sortedColumns = []; } if (column === null) { clearSortColumns(); that._isSorting = false; return; } if (!that.sorting.enabled || !that.dataSource || !column.allowSort || that._sortAnimation) { that._isSorting = false; return; } clearSortColumn(column); if (!that._sortedColumns) { that._sortedColumns = []; } let dataType = 'string'; for (let i = 0; i < that.dataSource.dataFields.length; i++) { const field = that.dataSource.dataFields[i]; if (field.name === columnDataField) { dataType = field.dataType; break; } } let addNewSortColumn = true; for (let i = 0; i < that._sortedColumns.length; i++) { const sortColumn = that._sortedColumns[i]; if (sortColumn.dataField === columnDataField) { addNewSortColumn = false; sortColumn.sortIndex = column.sortIndex; if (toggleSort) { if (sortColumn.sortOrder === 'asc') { sortColumn.sortOrder = 'desc'; sortOrder = 'desc'; } else if (sortColumn.sortOrder === 'desc') { if (that.sorting.sortToggleThreeStates) { that._sortedColumns.splice(i, 1); clearSortColumn(column); sortOrder = null; } else { sortColumn.sortOrder = 'asc'; sortOrder = 'asc'; } break; } } else { sortColumn.sortOrder = sortOrder; if (sortOrder === null) { that._sortedColumns.splice(i, 1); clearSortColumn(column); } } } } if (addNewSortColumn) { if (that.sorting.mode === 'one') { clearSortColumns(); } if (sortOrder !== null) { that._sortedColumns.push({ dataField: columnDataField, sortOrder: sortOrder, sortIndex: column.sortIndex, dataType: dataType }); } } column.setProperty('sortOrder', sortOrder); that._sortedColumns.sort((a, b) => { if (typeof a.sortIndex === 'string' && typeof b.sortIndex === 'string') { return 0; } if (typeof a.sortIndex === 'number' && typeof b.sortIndex === 'string') { return -1; } if (typeof a.sortIndex === 'string' && typeof b.sortIndex === 'number') { return 1; } if (typeof a.sortIndex === 'number' && typeof b.sortIndex === 'number') { return a.sortIndex - b.sortIndex; } }); for (let i = 0; i < that._sortedColumns.length; i++) { const sortColumn = that._sortedColumns[i]; sortDataFields.push(sortColumn.dataField); sortOrders.push(sortColumn.sortOrder); sortDataTypes.push(sortColumn.dataType); } const sort = function () { if (that.dataSource && that.dataSource.virtualDataSource) { that._virtualDataRequest('sort'); } else { that.dataSource.sortBy(sortDataFields, sortDataTypes, sortOrders); if (that.dataSource.boundHierarchy) { that._refreshRowHierarchy(); if (that.dataSource.groupBy.length > 0) { that.refresh(); } } else { for (let i = 0; i < that.dataSource.length; i++) { const row = that.rows[i]; const data = that.dataSource[i]; row.data = data; row.boundIndex = data.boundIndex; } } that._recycle(); } const detailColumns = []; for (let i = 0; i < that._sortedColumns.length; i++) { const column = that.columnByDataField[that._sortedColumns[i].dataField]; if (column) { detailColumns.push(column); } } that._refreshHeaderBar(); that.$.fireEvent('sort', { 'columns': detailColumns, 'data': that._sortedColumns }); } if (that.appearance.allowSortAnimation) { let positions = []; let takenPositions = []; that.rows.canNotify = false; that._sortAnimation = true; const refreshRows = function () { for (let i = 0; i < that._rowElements.length; i++) { const rowElement = that._rowElements[i]; rowElement.classList.remove('lw-grid-sort-animation'); that.removeTransformMoveStyle(rowElement); if (rowElement.offsetHeight > 0) { positions.push(rowElement.offsetTop); } } } refreshRows(); that._sortTimer = setTimeout(function () { refreshRows(); that._sortAnimation = false; that.rows.canNotify = true; }, that.appearance.sortAnimationDuration); that._sortTimer2 = setTimeout(function () { sort(); }, that.appearance.sortAnimationDuration / 2); for (let i = 0; i < positions.length; i++) { const rowElement = that._rowElements[i]; rowElement.classList.remove('lw-grid-sort-animation'); that.removeTransformMoveStyle(rowElement); let randomIndex = Math.floor((Math.random() * positions.length - 1) + 1); while (takenPositions[randomIndex]) { randomIndex = Math.floor((Math.random() * positions.length - 1) + 1); } takenPositions[randomIndex] = true; that.addTransformMoveStyle(rowElement, '0ms', 0, -rowElement.offsetTop + positions[randomIndex], 0, 0.5); rowElement.classList.add('lw-grid-sort-animation'); setTimeout(function () { that.addTransformMoveStyle(rowElement, that.appearance.sortAnimationDuration + 'ms', 0, 0, 0, 1); }); setTimeout(function () { rowElement.classList.remove('lw-grid-sort-animation'); }, that.appearance.sortAnimationDuration); } } else { sort(); } that._isSorting = false; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Group', class Group { _renderGroupBar() { const that = this; if ( !that.grouping.groupBar.visible ) { return; } const bar = that.$.groupHeader; if ( !bar.firstElementChild ) { const breadcrumb = document.createElement( 'lw-breadcrumb' ); const label = that.localize( 'groupBarLabel' ); bar.appendChild( breadcrumb ); that.$.breadcrumb = breadcrumb; breadcrumb.placeholder = label; breadcrumb.classList.add( 'lw-hidden' ); } const groups = that.dataSource.groupBy; const dataSource = []; for ( let i = 0; i < groups.length; i++ ) { const group = groups[ i ]; const column = that.columns.find( column => { return column.dataField === group; } ); if ( !column ) { continue; } let icons = ''; if ( column.sortOrder ) { icons += '<span class="lw-grid-icon show ' + ( column.sortOrder === 'asc' ? 'lw-icon-sort-up' : 'lw-icon-sort-down' ) + '"></span>'; } if ( column.filter ) { icons += '<span class="lw-grid-icon lw-icon-filter show"></span>'; } dataSource.push( {label: column.label + icons, value: column.dataField} ); } that.$.breadcrumb.closeButtons = that.grouping.groupBar.allowColumnCloseButtons; that.$.breadcrumb.allowDrag = that.$.breadcrumb.allowDrop = that.grouping.groupBar.allowColumnDragDrop; that.$.breadcrumb.dataSource = dataSource; that.$.breadcrumb.minimizeWidth = 350; if ( that.offsetWidth < 350 ) { that.$.breadcrumb.parentElement.style.zIndex = 9999; that.$.breadcrumb.parentElement.style.overflow = 'visible'; } that.$.breadcrumb.onminimize = () => { that.$.breadcrumb.parentElement.style.zIndex = 9999; that.$.breadcrumb.parentElement.style.overflow = 'visible'; } that.$.breadcrumb.onitemclick = ( event ) => { const item = event.detail.item; const column = that.columnByDataField[ item.value ]; if ( column.allowSortToggleOnClick && that.sorting.enabled ) { that.sortBy( column.dataField ); } } that.$.breadcrumb.onmaximize = () => { that.$.breadcrumb.parentElement.style.zIndex = ''; that.$.breadcrumb.parentElement.style.overflow = ''; } that.$.breadcrumb.ondragstart = function ( event ) { const dragDrop = that.$.breadcrumb._dragDrop; const index = that.$.breadcrumb._items.indexOf( event.detail.item ); const column = that.columnByDataField[ that.$.breadcrumb.dataSource[ index ].value ]; const columnDragStartEvent = that.$.fireEvent( 'columnDragStart', { 'column': column, 'index': that.columns.indexOf( column ), 'data': dragDrop, 'originalEvent': event.detail.originalEvent } ); if ( columnDragStartEvent.defaultPrevented ) { return; } const elements = that.columns.map( ( column ) => { if ( column.dataField === dataSource[ index ].value ) { column.element.classList.add( 'dragged' ); } return column.element; } ); dragDrop.items = dragDrop.items.concat( elements ); dragDrop.getItemCoordinates( dragDrop.items ); dragDrop.column = column; that._overlay = document.createElement( 'div' ); that._overlay.classList.add( 'lw-grid-overlay' ); that._overlay.style.cursor = ''; that.$.root.appendChild( that._overlay ); that._dragLine = that._createLine( dragDrop.dragDetails.item ); that.$.root.appendChild( that._dragLine ); that._dragLine.style.height = dragDrop.dragDetails.item.offsetHeight + 'px'; requestAnimationFrame( () => { that._dragLine.style.opacity = 1; } ); } that.$.breadcrumb.ondragging = function ( event ) { const dragDrop = that.$.breadcrumb._dragDrop; const dragDetails = dragDrop.dragDetails; if ( that._dragLine && dragDetails.target ) { const columnRect = that.getBoundingRect( dragDetails.target ); const rect = that.getBoundingRect( that ); const columnHeaderRect = that.getBoundingRect( that.$.columnHeader ); if ( dragDetails.before ) { that._dragLine.style.left = -columnHeaderRect.left + columnRect.left + 'px'; } else { that._dragLine.style.left = -columnHeaderRect.left + columnRect.right + 'px'; } if ( parseInt( that._dragLine.style.left ) < 3 ) { that._dragLine.style.left = '3px'; } that._dragLine.style.top = columnRect.top - rect.top + 'px'; if ( dragDetails.target.classList.contains( 'lw-breadcrumb-item' ) ) { that._dragLine.style.height = columnRect.height + 'px'; } else { that._dragLine.style.height = 'calc(100% - 7px - ' + that._dragLine.style.top + ')'; } that.$.fireEvent( 'columnDragging', { 'column': dragDrop.column, 'index': that.columns.indexOf( dragDrop.column ), 'data': dragDrop, 'originalEvent': event.detail.originalEvent } ); } } that.$.breadcrumb.ondragcancel = function () { if ( that._dragLine ) { that._dragLine.parentNode.removeChild( that._dragLine ); } that.columns.forEach( column => { if ( column.element ) { column.element.classList.remove( 'dragged' ); } } ); const dragDrop = that.$.breadcrumb._dragDrop; that.$.fireEvent( 'columnDragCancel', { 'column': dragDrop.column, 'index': that.columns.indexOf( dragDrop.column ), 'data': dragDrop } ); } that.$.breadcrumb.ondragend = function ( event ) { that.beginUpdate(); const rect = that.getBoundingRect( that.$.breadcrumb ); if ( event.detail.originalEvent.pageY > rect.bottom ) { const dragDrop = that.$.breadcrumb._dragDrop; const dataField = event.detail.item.data.value; const target = dragDrop.dragDetails.target; const column = that.columnByDataField[ dataField ]; const index = that.$.breadcrumb.dataSource.findIndex( ( item ) => { if ( item.value === column.dataField ) { return true; } return false; } ); const newSource = that.$.breadcrumb.dataSource.slice( 0 ); newSource.splice( index, 1 ); that.$.breadcrumb.dataSource = newSource; if ( target && target.column ) { const columnDragEndEvent = that.$.fireEvent( 'columnDragEnd', { 'column': dragDrop.column, 'index': that.columns.indexOf( dragDrop.column ), 'newIndex': that.columns.indexOf( target.column ), 'data': dragDrop, 'originalEvent': event.detail.originalEvent } ); if ( !columnDragEndEvent.defaultPrevented ) { const columnIndex = that.columns.indexOf( column ); const newColumnIndex = that.columns.indexOf( target.column ); that.columns.move( columnIndex, newColumnIndex ); } } } const dataSource = that.$.breadcrumb.dataSource.map( item => { return item.value; } ); if ( that._dragLine ) { that._dragLine.parentNode.removeChild( that._dragLine ); } that.columns.forEach( column => { if ( column.element ) { column.element.classList.remove( 'dragged' ); } } ); that.dataSource.groupBy = dataSource; that.refresh( true ); that.refreshFilters(); that.refreshSort(); that.endUpdate(); } that.$.breadcrumb.onclose = function ( event ) { const item = event.detail.item; that.removeGroup( item.value ); } } addGroup( dataField ) { const that = this; if ( !that.dataSource || !that.grouping.enabled ) { return; } const index = that.dataSource.groupBy.indexOf( dataField ); if ( index === -1 ) { that.dataSource.groupBy.push( dataField ); that.refresh( true ); that.refreshFilters(); that.refreshSort(); } } removeGroup( dataField ) { const that = this; if ( !that.dataSource || !that.grouping.enabled ) { return; } const index = that.dataSource.groupBy.indexOf( dataField ); if ( index >= 0 ) { that.dataSource.groupBy.splice( index, 1 ); that.refresh( true ); that.refreshFilters(); that.refreshSort(); } } clearGroups() { const that = this; if ( !that.dataSource || !that.grouping.enabled ) { return; } that.dataSource.clearGroup(); that.refresh( true ); that.refreshFilters(); that.refreshSort(); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Select', class Select { _refreshSelection() { const that = this; if ( that.selection.enabled ) { const column = that._selectionColumn; column.refresh(); } that._refreshCellSelectionRect(); } _toggleColumnSelection( column ) { const that = this; if ( !that.selection.enabled || that.selection.checkBoxes.selectAllMode === 'none' ) { if ( that._inputOverlay && that._inputOverlay.parentNode ) { that._inputOverlay.parentNode.removeChild( that._inputOverlay ); } return; } let selected = column.element.getAttribute( 'selected' ); if ( selected === 'indeterminate' ) { selected = true; } else if ( selected === '' ) { selected = false; } else { selected = true; } let visibleRows = that._recyclingRows; that._selectionColumn._selecting = true; that.beginUpdate(); for ( let i = 0; i < visibleRows.length; i++ ) { const row = visibleRows[ i ]; row.selected = selected; } that._selectionColumn._selecting = false; that.endUpdate( false ); that._recycle( false ); if ( that.selection.enabled && that.selection.checkBoxes.enabled && that.selection.checkBoxes.selectAllMode !== 'none' ) { const element = column.element; const input = element.querySelector( '.lw-input' ); if ( that._inputOverlay ) { if ( that._inputOverlay.parentNode !== that.$.columnHeader ) { if ( that._inputOverlay.parentNode ) { that._inputOverlay.parentNode.removeChild( that._inputOverlay ); } that._inputOverlay = document.createElement( 'div' ); that.$.columnHeader.appendChild( that._inputOverlay ); } } else { that._inputOverlay = document.createElement( 'div' ); that.$.columnHeader.appendChild( that._inputOverlay ); } that._inputOverlay.column = column; that._inputOverlay.onpointerdown = function () { if ( !that._inputOverlay ) { that._inputOverlay.onpointerdown = null; } const column = that._inputOverlay.column; that._inputOverlay.classList.remove( 'lw-animate' ); that._selectionColumn._selecting = true; that.beginUpdate(); let selected = column.element.hasAttribute( 'selected' ); let visibleRows = that._recyclingRows; for ( let i = 0; i < visibleRows.length; i++ ) { const row = visibleRows[ i ]; row.selected = !selected; } that._selectionColumn._selecting = false; const overlay = that._inputOverlay; that.endUpdate( false ); that._recycle(); that.$.columnHeader.appendChild( overlay ); that._inputOverlay = overlay; that._inputOverlay.classList.add( 'lw-animate' ); return false; } that._inputOverlay.classList.add( 'lw-input-overlay' ); that._inputOverlay.classList.add( 'lw-input-overlay-column' ); if ( that.appearance.allowCheckBoxesSelectionAnimation ) { that._inputOverlay.classList.add( 'lw-animate' ); } that._inputOverlay.style.top = ( element.offsetHeight - input.offsetHeight ) / 4 + 1 + 'px'; const left = that._selectionColumn.element.parentElement.offsetLeft + that._selectionColumn.element.offsetLeft; if ( that.rightToLeft ) { that._inputOverlay.style.right = left + 'px'; } else { that._inputOverlay.style.left = left + 'px'; } that._inputOverlay.style.height = element.offsetWidth + 'px'; that._inputOverlay.style.width = element.offsetWidth + 'px'; that._inputOverlay.onmousedown = null; that._inputOverlay.classList.add( 'lw-input-overlay-on' ); that._selectionColumn.refresh(); } } _refreshCheckBoxColumnSelection() { const that = this; if ( that.selection.enabled && that.selection.checkBoxes.enabled ) { const element = that._selectionColumn.element; if ( that.selection.checkBoxes.selectAllMode === 'none' ) { element.removeAttribute( 'checkbox' ); element.label.classList.remove( 'lw-input' ); } else { element.setAttribute( 'checkbox', '' ); element.label.classList.add( 'lw-input' ); } that._selectionColumn.refresh(); } } _handleExtendedRowSelection( row, event ) { const that = this; if ( !row ) { return; } let visibleRows = that._recyclingRows; if ( that.paging.enabled && that.selection.selectAllMode === 'page' ) { visibleRows = visibleRows.slice( that.paging.pageIndex * that.paging.pageSize, ( that.paging.pageIndex + 1 ) * that.paging.pageSize ); } if ( event && !event.ctrlKey ) { that._selection.rows = []; } if ( event && !event.shiftKey ) { that._rangeSelectionStartRow = row; that._rangeSelectionEndRow = row; } if ( event && event.shiftKey ) { that._rangeSelectionEndRow = row; const startIndex = visibleRows.indexOf( that._rangeSelectionStartRow ); const endIndex = visibleRows.indexOf( that._rangeSelectionEndRow ); const minIndex = Math.min( startIndex, endIndex ); const maxIndex = Math.max( startIndex, endIndex ); if ( startIndex === -1 || endIndex === -1 ) { return; } for ( let i = minIndex; i <= maxIndex; i++ ) { const visibleRow = visibleRows[ i ]; if ( visibleRow.allowSelect ) { visibleRow.setProperty( 'selected', true ); } } } else { if ( row.allowSelect !== false) { if ( event && event.ctrlKey ) { if ( row.selected === null ) { row.setProperty( 'selected', true ); } else { row.setProperty( 'selected', !row.selected ); } } else { row.setProperty( 'selected', true ); } } } } _setSelection( rowId, dataField, event ) { const that = this; if ( !that.selection.enabled ) { return; } that._lastColumnSelectionRange = null; that._lastRowSelectionRange = null; that.closeMenu(); if ( rowId === null && dataField === null ) { that.clearSelection(); return; } const clearSelection = function () { if ( event && !event.ctrlKey && !event.shiftKey || that.selection.mode === 'one' ) { if ( that.selection.mode !== 'many' ) { for ( let rowId in that._selection.rows ) { const row = that.rowById[ rowId ]; row.canNotify = false; row.selected = false; row.canNotify = true; } that._selection.rows = []; that._selection.columns = []; that._selection.cells = []; } that._selection.focusedCell = null; } if ( that._selection.selectionRect ) { const selectionRect = that._selection.selectionRect; selectionRect.parentNode.removeChild( selectionRect ); const eventNames = { down: 'pointerdown', move: 'pointermove', up: 'pointerup' }; if ( LW.Utilities.Core.isMobile ) { eventNames.down = 'touchstart'; eventNames.move = 'touchmove'; eventNames.up = 'touchend'; } document.removeEventListener( eventNames.move, selectionRect.onMove ); document.removeEventListener( eventNames.up, selectionRect.onUp ); document.removeEventListener( eventNames.down, selectionRect.onDown ); that._selection.selectionRect = null; } } that.beginUpdate(); const column = that.columnByDataField[ dataField ]; const selectRow = () => { const row = that.rowById[ rowId ]; if ( row && (row.allowSelect || (row.allowSelect === null && !event))) { clearSelection(); that._selectRow( rowId, event ); } } if ( that.selection.allowCellSelection && rowId !== undefined && rowId !== null && column && !column.autoGenerated ) { const row = that.rowById[ rowId ]; let cell = row.getCell( dataField ); const parentCell = that._getParentCell( row, dataField ); if ( parentCell ) { cell = parentCell.row.getCell( parentCell.column.dataField ); } clearSelection(); if ( event && !event.ctrlKey ) { that._selection.rows = []; that._selection.columns = []; if ( that.selection.mode !== 'many' ) { that._selection.cells = []; } } if ( that.selection.mode === 'extended' ) { if ( event && event.ctrlKey ) { cell.selected = !cell.selected; } else { cell.selected = true; } } else { if ( that.selection.mode === 'one' ) { cell.selected = true; } else { cell.selected = !cell.selected; } } if ( event && !event.shiftKey || !that._selection.focusedCell ) { that._selection.focusedCell = cell; } if ( event && ( event.shiftKey || that._selection.focusedCell === cell ) && that.selection.mode === 'extended' ) { if ( !parentCell ) { that._renderCellSelectionRect( cell.row, cell.column, cell.row, cell.column ); } else { that._renderCellSelectionRect( cell.row, cell.column, parentCell.endRow, parentCell.endColumn ); } } } else if ( that.selection.allowRowHeaderSelection && rowId !== undefined && rowId !== null && that.columnByDataField[ dataField ] === undefined ) { selectRow(); } else if ( that.selection.checkBoxes.enabled && rowId !== undefined && rowId !== null && dataField === '_checkBoxColumn' && that.columnByDataField[ dataField ] === undefined ) { selectRow(); } else if ( rowId !== undefined && rowId !== null && ( dataField === undefined || that.columnByDataField[ dataField ] !== undefined ) && that.selection.allowRowSelection ) { selectRow(); } else if ( that.selection.allowColumnHeaderSelection && column ) { clearSelection(); that._selectColumn( dataField, event || new KeyboardEvent( 'keydown' )); } that.endUpdate( false ); that._recycle(); if ( rowId !== undefined && rowId !== null && !column ) { that._renderInputOverlay( rowId, event ); } that.__selectionStarted = new Date(); } _renderCellSelectionRect( beginRow, beginColumn, endRow, endColumn ) { const that = this; let visibleRows = that._recyclingRows; const startRowIndex = visibleRows.indexOf( beginRow ); const endRowIndex = visibleRows.indexOf( endRow ); //const startColumnIndex = that.columns.indexOf(beginColumn); //const endColumnIndex = that.columns.indexOf(endColumn); if ( startRowIndex >= 0 && endRowIndex >= 0 ) { if ( !that._selection.selectionRect ) { const createSelectionRect = function ( canResize ) { const fillContent = document.createElement( 'div' ); const borderContent = document.createElement( 'div' ); const overlay = document.createElement( 'div' ); overlay.classList.add( 'lw-selection-overlay' ); overlay.appendChild( borderContent ); borderContent.appendChild( fillContent ); fillContent.classList.add( 'lw-selection-overlay-content' ); borderContent.classList.add( 'lw-selection-overlay-border-content' ); if ( that.selection.allowCellDragSelectionHandle && canResize ) { borderContent.classList.add( 'handle' ); } that.$.scrollView.appendChild( overlay ); return overlay; } const selectionRect = that._selection.selectionRect = createSelectionRect( true ); if ( that.selection.allowCellDragSelectionHandle ) { let capturePoint = null; let isHorizontalDrag = null; let isVerticalDrag = null; selectionRect.onMove = function ( event ) { const selectionRect = that._selection.selectionRect; let clientX = event.clientX; let clientY = event.clientY; if ( event.touches ) { clientX = event.touches[ 0 ].clientX; clientY = event.touches[ 0 ].clientY; } const getElements = function ( event ) { const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); let columnDataField = null; for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.getAttribute( 'data-field' ) ) { columnDataField = element.getAttribute( 'data-field' ); break; } } let row = null; for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.getAttribute( 'data-id' ) ) { row = element.row; break; } } return { column: that.columnByDataField[ columnDataField ], row: row }; } if ( selectionRect.capturedDrag ) { const eventData = { clientX: clientX, clientY: clientY }; let beginElements = getElements( eventData ); let row = getElements( { clientX: clientX, clientY: clientY + selectionRect.top } ).row; let column = getElements( { clientX: clientX + selectionRect.left, clientY: clientY } ).column; if ( !row ) { row = visibleRows[ visibleRows.length - 1 ]; } if ( !column ) { column = beginElements.column; } if ( row && column && beginElements.row && beginElements.column ) { selectionRect.row = beginElements.row; selectionRect.column = beginElements.column; selectionRect.endDragRow = selectionRect.endRow = row; selectionRect.endDragColumn = selectionRect.endColumn = column; that._dragSelectionStartDataField = selectionRect.column.dataField; that._dragSelectionStartRow = selectionRect.row; that._selection.focusedCell = selectionRect.row.getCell( selectionRect.column.dataField ); } that._resizeSelectionRect(); event.preventDefault(); } else if ( selectionRect.captured ) { that._dragSelectionStartDataField = that._selection.focusedCell.column.dataField; that._dragSelectionStartRow = that._selection.focusedCell.row; if ( isHorizontalDrag === null && isVerticalDrag === null ) { if ( Math.abs( clientX - capturePoint.left ) >= 30 ) { isHorizontalDrag = true; } else if ( Math.abs( clientY - capturePoint.top ) >= 30 ) { isVerticalDrag = true; } } if ( selectionRect.lastPoint && Math.abs( selectionRect.lastPoint.top - clientY ) >= 40 ) { isHorizontalDrag = null; isVerticalDrag = true; } else if ( selectionRect.lastPoint && Math.abs( selectionRect.lastPoint.left - clientX ) >= 40 ) { isVerticalDrag = null; isHorizontalDrag = true; } if ( isHorizontalDrag ) { const endDataField = selectionRect.endDragColumn.dataField; //const endRow = selectionRect.endDragRow; const eventData = { clientX: clientX, clientY: capturePoint.top - 5 }; const elements = getElements( eventData ); if ( elements.row && elements.column ) { selectionRect.endDragRow = selectionRect.endRow; selectionRect.endDragColumn = elements.column; if ( selectionRect.endDragColumn.dataField !== endDataField ) { selectionRect.lastPoint = { left: clientX, top: clientY }; } that._resizeSelectionRect(); } } else if ( isVerticalDrag ) { //const endColumn = selectionRect.endDragColumn; const endRow = selectionRect.endDragRow; const eventData = { clientX: capturePoint.left - 5, clientY: clientY }; const elements = getElements( eventData ); if ( elements.row && elements.column ) { selectionRect.endDragRow = elements.row; selectionRect.endDragColumn = selectionRect.endColumn; if ( selectionRect.endDragRow.id && selectionRect.endDragRow.id !== endRow.id ) { selectionRect.lastPoint = { left: clientX, top: clientY }; } that._resizeSelectionRect(); } } // event.preventDefault(); } if ( ( selectionRect.captured ) && that.selection.allowDragSelectionAutoScroll ) { if ( that._autoScrollSelectionDragInterval ) { clearInterval( that._autoScrollSelectionDragInterval ); } that.selection.isDragging = true; // event.preventDefault(); that._autoScrollSelectionDragInterval = setInterval( function () { const rect = that.$.scrollView.getBoundingClientRect(); if ( clientX <= rect.left + 20 ) { that.scrollLeft -= 15; that._resizeSelectionRect(); } else if ( clientX >= rect.left + rect.width - 20 ) { that.scrollLeft += 15; that._resizeSelectionRect(); } if ( clientY <= rect.top + 20 ) { that.scrollTop -= 15; that._resizeSelectionRect(); } else if ( clientY >= rect.top + rect.height - 20 ) { that.scrollTop += 15; that._resizeSelectionRect(); } }, 5 ); } } selectionRect.onUp = function (/*event*/ ) { if ( !selectionRect.captured ) { return; } if ( that._autoScrollSelectionDragInterval ) { clearInterval( that._autoScrollSelectionDragInterval ); } if ( !that.editing.editCell && !that.editing.editRow ) { that.focus(); } selectionRect.capturedDrag = false; selectionRect.captured = false; isHorizontalDrag = null; isVerticalDrag = null; capturePoint = null; selectionRect.lastPoint = null; const cellValues = selectionRect.cellValues; if ( selectionRect.minRow && selectionRect.maxRow && selectionRect.maxRow && selectionRect.maxColumn ) { // select cells on mouse up. that._selectCellsRange( selectionRect.minRow, selectionRect.maxRow, selectionRect.minColumn.dataField, selectionRect.maxColumn.dataField ); selectionRect.row = selectionRect.minRow; selectionRect.column = selectionRect.minColumn; selectionRect.endColumn = selectionRect.maxColumn; selectionRect.endRow = selectionRect.maxRow; selectionRect.cellValues = cellValues; that._resizeSelectionRect(); if ( that.selection.allowCellDragSelectionAutoFill ) { that._pasteSelectedCells( { row: selectionRect.row, endRow: selectionRect.endDragRow, column: selectionRect.column, endColumn: selectionRect.endColumn }, cellValues ); } } selectionRect.endDragColumn = null; selectionRect.endDragRow = null; selectionRect.minColumn = null; selectionRect.minRow = null; selectionRect.maxColumn = null; selectionRect.maxRow = null; } selectionRect.onDown = function ( event ) { if ( selectionRect.captured && !capturePoint ) { let clientX = event.clientX; let clientY = event.clientY; if ( event.touches ) { clientX = event.touches[ 0 ].clientX; clientY = event.touches[ 0 ].clientY; } capturePoint = { left: clientX, top: clientY }; } } const eventNames = { down: 'pointerdown', move: 'pointermove', up: 'pointerup' }; if ( LW.Utilities.Core.isMobile ) { eventNames.down = 'touchstart'; eventNames.move = 'touchmove'; eventNames.up = 'touchend'; } selectionRect[ 'on' + eventNames.down ] = function ( event ) { const rect = selectionRect.getBoundingClientRect(); let clientX = event.clientX; let clientY = event.clientY; if ( event.touches ) { clientX = event.touches[ 0 ].clientX; clientY = event.touches[ 0 ].clientY; } if ( clientX >= rect.right - 5 && clientY >= rect.bottom - 5 ) { selectionRect.captured = true; selectionRect.endDragRow = selectionRect.endRow; selectionRect.endDragColumn = selectionRect.endColumn; } else if ( that.selection.allowCellDragDropSelectionHandle && clientY >= rect.bottom - 5 ) { selectionRect.captured = true; selectionRect.capturedDrag = true; selectionRect.endDragRow = selectionRect.endRow; selectionRect.endDragColumn = selectionRect.endColumn; selectionRect.left = selectionRect.endColumn.left - selectionRect.column.left; selectionRect.top = selectionRect.endRow.top - selectionRect.row.top; } else { if ( !selectionRect.captured ) { that._rowDownHandler( event ); } } } document.addEventListener( eventNames.move, selectionRect.onMove, { passive: false } ); document.addEventListener( eventNames.up, selectionRect.onUp, { passive: false } ); document.addEventListener( eventNames.down, selectionRect.onDown, { passive: false } ); } } const selectionRect = that._selection.selectionRect; selectionRect.row = that._selection.focusedCell.row; selectionRect.column = that._selection.focusedCell.column; selectionRect.endRow = endRow; selectionRect.endDragRow = endRow; selectionRect.endColumn = endColumn; selectionRect.endDragColumn = endColumn; that._refreshCellSelectionRect(); } } _resizeSelectionRect() { const that = this; const selectionRect = that._selection.selectionRect; if ( !selectionRect ) { return; } let visibleRows = that._recyclingRows; let row = selectionRect.row; let endRow = selectionRect.endDragRow; let column = selectionRect.column; let endColumn = selectionRect.endDragColumn; const startRowIndex = visibleRows.indexOf( row ); const endRowIndex = visibleRows.indexOf( endRow ); const endSelectedRowIndex = visibleRows.indexOf( selectionRect.endRow ); const startColumnIndex = that.columns.indexOf( column ); const endColumnIndex = that.columns.indexOf( endColumn ); const endSelectedColumnIndex = that.columns.indexOf( selectionRect.endColumn ); const minRowIndex = Math.min( endSelectedRowIndex, Math.min( startRowIndex, endRowIndex ) ); const maxRowIndex = Math.max( endSelectedRowIndex, Math.max( startRowIndex, endRowIndex ) ); const minColumnIndex = Math.min( endSelectedColumnIndex, Math.min( startColumnIndex, endColumnIndex ) ); const maxColumnIndex = Math.max( endSelectedColumnIndex, Math.max( startColumnIndex, endColumnIndex ) ); if ( endSelectedRowIndex <= Math.min( startRowIndex, endRowIndex ) ) { selectionRect.minRow = selectionRect.endRow; } else { if ( startRowIndex <= endRowIndex ) { selectionRect.minRow = row; } else { selectionRect.minRow = endRow; } } if ( endSelectedRowIndex >= Math.max( startRowIndex, endRowIndex ) ) { selectionRect.maxRow = selectionRect.endRow; } else { if ( startRowIndex >= endRowIndex ) { selectionRect.maxRow = row; } else { selectionRect.maxRow = endRow; } } if ( endSelectedColumnIndex <= Math.min( startColumnIndex, endColumnIndex ) ) { selectionRect.minColumn = selectionRect.endColumn; } else { if ( startColumnIndex <= endColumnIndex ) { selectionRect.minColumn = column; } else { selectionRect.minColumn = endColumn; } } if ( endSelectedColumnIndex >= Math.max( startColumnIndex, endColumnIndex ) ) { selectionRect.maxColumn = selectionRect.endColumn; } else { if ( startColumnIndex >= endColumnIndex ) { selectionRect.maxColumn = column; } else { selectionRect.maxColumn = endColumn; } } let top = 0; let height = 0; let left = 0; let width = 0; for ( let i = minRowIndex; i <= maxRowIndex; i++ ) { const visibleRow = visibleRows[ i ]; if ( i === minRowIndex ) { top = visibleRow.top; } if ( i === maxRowIndex ) { height = visibleRow.top + visibleRow.height - top; } for ( let j = minColumnIndex; j <= maxColumnIndex; j++ ) { const dataField = that.columns[ j ].dataField; const cell = visibleRow.getCell( dataField ); if ( j === minColumnIndex ) { left = cell.column.left; } if ( j === maxColumnIndex ) { width = cell.column.left + cell.column.computedWidth - left } } } selectionRect.style.top = top - that.scrollTop - 1 + 'px'; if ( that.rightToLeft ) { selectionRect.style.right = left - that.scrollLeft + 'px'; } else { selectionRect.style.left = left - that.scrollLeft + 'px'; } selectionRect.style.height = height + 1 + 'px'; selectionRect.style.width = width + 1 + 'px'; } _getPatternValue( rowIndex, columnIndex, selectedValues ) { let patternArray = []; let index = 0; let rowPatterns = []; let columnPatterns = []; let names = []; let dayMonths = []; const days = { // full day names names: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ], // abbreviated day names namesAbbr: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], // shortest day names namesShort: [ 'Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa' ] }; const months = { // full month names (13 months for lunar calendards -- 13th month should be '' if not lunar) names: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', '' ], // abbreviated month names namesAbbr: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', '' ] }; const parseValue = function ( value ) { if ( value === undefined ) { return undefined; } if ( value.toString().indexOf( 'GMT+' ) >= 0 || value.toString().indexOf( 'GMT-' ) >= 0 ) { return undefined; } if ( isNaN( parseFloat( value ) ) ) { if ( days.names.indexOf( value ) >= 0 ) { dayMonths = days.names; return days.names.indexOf( value ); } if ( days.namesAbbr.indexOf( value ) >= 0 ) { dayMonths = days.namesAbbr; return days.namesAbbr.indexOf( value ); } if ( days.namesShort.indexOf( value ) >= 0 ) { dayMonths = days.namesShort; return days.namesShort.indexOf( value ); } if ( months.names.indexOf( value ) >= 0 ) { dayMonths = months.names; return months.names.indexOf( value ); } if ( months.namesAbbr.indexOf( value ) >= 0 ) { dayMonths = months.namesAbbr; return months.namesAbbr.indexOf( value ); } if ( undefined !== value ) { if ( value === null ) { value = ''; } const hasNumber = /\d+/.test( value.toString() ); if ( hasNumber ) { names.push( value.toString().replace( /[0-9]/, '#' ) ); names[ names.length - 1 ] = names[ names.length - 1 ].replace( /[0-9]/g, '' ); const result = parseFloat( value.toString().replace( /\D/g, '' ) ); if ( isNaN( result ) ) { return 0; } else { return result; } } } return undefined; } const hasLetters = /[A-Za-z]/.test( value.toString() ); if ( hasLetters ) { return undefined; } return parseFloat( value ); } let columnsCount = 0; for ( let rowId in selectedValues ) { let row = selectedValues[ rowId ]; patternArray[ index ] = []; columnsCount = 0; for ( let columnDataField in row ) { let value = parseValue( row[ columnDataField ] ); if ( value === undefined ) { continue; } patternArray[ index ].push( value ); columnsCount++; } if ( patternArray[ index ].length === 0 ) { continue; } let stepStart = patternArray[ index ][ 0 ]; let step = 0; for ( let i = 0; i < patternArray[ index ].length; i++ ) { let prevValue = parseValue( patternArray[ index ][ i - 1 ] ); let value = parseValue( patternArray[ index ][ i ] ); if ( i === 0 ) { prevValue = value; } stepStart += value; step += value - prevValue; } stepStart /= patternArray[ index ].length; stepStart -= patternArray[ index ][ 0 ]; stepStart += patternArray[ index ][ patternArray[ index ].length - 1 ]; if ( step !== 0 ) { step /= ( patternArray[ index ].length - 1 ); } if ( dayMonths.length > 0 || names.length > 0 ) { step = 1; stepStart = patternArray[ index ][ 0 ]; } if ( patternArray[ index ].length <= 2 ) { stepStart = patternArray[ index ][ patternArray[ index ].length - 1 ] + step; } rowPatterns.push( { step: step, stepStart: stepStart } ); index++; } for ( let i = 0; i < columnsCount; i++ ) { let stepStart = patternArray[ 0 ][ i ]; let step = 0; for ( let j = 1; j < patternArray.length; j++ ) { const prevValue = parseValue( patternArray[ j - 1 ][ i ] ); const value = parseValue( patternArray[ j ][ i ] ); stepStart += value; step += value - prevValue; } stepStart /= patternArray.length; stepStart -= patternArray[ 0 ][ i ]; stepStart += patternArray[ patternArray.length - 1 ][ i ]; if ( step !== 0 ) { step /= ( patternArray.length - 1 ); } if ( dayMonths.length > 0 || names.length > 0 ) { step = 1; stepStart = patternArray[ 0 ][ i ]; } if ( patternArray.length <= 2 ) { stepStart = patternArray[ patternArray.length - 1 ][ i ] + step; } columnPatterns.push( { step: step, stepStart: stepStart } ); } if ( !patternArray[ rowIndex ] ) { let startRowIndex = patternArray.length; for ( let i = startRowIndex; i <= rowIndex; i++ ) { patternArray[ i ] = []; for ( let j = 0; j <= columnIndex; j++ ) { if ( !columnPatterns[ j ] ) { columnPatterns[ j ] = columnPatterns[ j - 1 ]; } if ( !columnPatterns[ j ] ) { continue; } if ( i === startRowIndex ) { patternArray[ i ][ j ] = columnPatterns[ j ].stepStart; } else { patternArray[ i ][ j ] = patternArray[ i - 1 ][ j ] + columnPatterns[ j ].step; if ( dayMonths.length > 1 && patternArray[ i ][ j ] >= dayMonths.length ) { patternArray[ i ][ j ] = 0; } } } } if ( dayMonths.length > 0 ) { return dayMonths[ patternArray[ rowIndex ][ columnIndex ] ]; } else if ( names.length > 0 ) { return names[ rowIndex % names.length ].replace( '#', patternArray[ rowIndex ][ columnIndex ] ); } return patternArray[ rowIndex ][ columnIndex ]; } if ( !patternArray[ rowIndex ][ columnIndex ] ) { let startColumnIndex = columnsCount; for ( let i = startColumnIndex; i <= columnIndex; i++ ) { if ( !rowPatterns[ rowIndex ] ) { continue; } if ( i === startColumnIndex ) { patternArray[ rowIndex ].push( rowPatterns[ rowIndex ].stepStart ); } else { patternArray[ rowIndex ][ i ] = patternArray[ rowIndex ][ i - 1 ] + rowPatterns[ rowIndex ].step; if ( dayMonths.length > 1 && patternArray[ rowIndex ][ i ] >= dayMonths.length ) { patternArray[ rowIndex ][ i ] = 0; } } } if ( dayMonths.length > 0 ) { return dayMonths[ patternArray[ rowIndex ][ columnIndex ] ]; } else if ( names.length > 0 ) { return names[ rowIndex % names.length ].replace( '#', patternArray[ rowIndex ][ columnIndex ] ); } return patternArray[ rowIndex ][ columnIndex ]; } if ( patternArray[ rowIndex ] && patternArray[ rowIndex ][ columnIndex ] ) { if ( names.length > 0 ) { return names[ rowIndex % names.length ].replace( '#', patternArray[ rowIndex ][ columnIndex ] ); } return patternArray[ rowIndex ][ columnIndex ]; } return 0; } _pasteDataType( args ) { const that = this; const unboundMode = that.dataSource && typeof ( that.dataSource.dataSource ) === 'number'; const cell = args.cell; const value = args.value; let dataType = cell.column.dataType; if ( !dataType || unboundMode ) { if ( isNaN( parseFloat( value ) ) ) { dataType = 'string'; } else if ( value instanceof Date ) { dataType = 'date'; } else if ( value === 'true' || value === 'false' ) { dataType = 'boolean'; } else { dataType = 'number'; } } return dataType; } _pasteModeCopy( args ) { const that = this; const unboundMode = that.dataSource && typeof ( that.dataSource.dataSource ) === 'number'; const dataType = that._pasteDataType( args ); const cell = args.cell; //const selectedValues = args.selectedValues; const value = args.value; const dataField = args.dataField; if ( dataType === 'string' ) { cell.value = value; } else if ( dataType === 'bool' || dataType === 'boolean' ) { if ( value === 1 || value === '1' || value === true || value === 'true' || value === 'TRUE' || value === 'True' ) { cell.value = true; } } else if ( dataType === 'date' || dataType === 'time' || dataType === 'dateTime' ) { const column = that.columnByDataField[ dataField ]; if ( unboundMode ) { cell.value = value; } else { if ( column && column.dataType !== dataType ) { cell.value = null; } else { cell.value = value; } } } else if ( dataType === 'number' || dataType === 'float' || dataType === 'int' ) { const column = that.columnByDataField[ dataField ]; if ( unboundMode ) { cell.value = value; } else { if ( column && column.dataType !== dataType ) { cell.value = null; } else { if ( value !== null ) { if ( dataType === 'int' || dataType === 'integer' ) { cell.value = parseInt( value ); } else { cell.value = parseFloat( value ); } } else { cell.value = null; } } } } } _pasteModeFill( args ) { const that = this; const unboundMode = that.dataSource && typeof ( that.dataSource.dataSource ) === 'number'; const dataType = that._pasteDataType( args ); const cell = args.cell; const selectedValues = args.selectedValues; const minRowIndex = args.minRowIndex; const minColumnIndex = args.minColumnIndex; const currentRowIndex = args.currentRowIndex; const currentColumnIndex = args.currentColumnIndex; const columnDataField = args.dataField; let value = args.value; if ( dataType === 'string' ) { const hasNumber = /\d+/.test( value.toString() ); if ( hasNumber ) { value = that._getPatternValue( currentRowIndex - minRowIndex, currentColumnIndex - minColumnIndex, selectedValues ); if ( value === undefined ) { if ( selectedValues[ currentRowIndex - minRowIndex ] && selectedValues[ currentRowIndex - minRowIndex ][ currentColumnIndex - minColumnIndex ] ) { value = selectedValues[ currentRowIndex - minRowIndex ][ currentColumnIndex - minColumnIndex ]; } } } else { value = that._getPatternValue( currentRowIndex - minRowIndex, currentColumnIndex - minColumnIndex, selectedValues ); if ( value === undefined ) { if ( selectedValues[ currentRowIndex - minRowIndex ] ) { value = selectedValues[ currentRowIndex - minRowIndex ][ currentColumnIndex - minColumnIndex ]; } else { value = args.value; } } else { value = args.value; } } if ( value !== undefined ) { cell.value = value; } } else if ( dataType === 'bool' || dataType === 'boolean' ) { if ( value === 1 || value === '1' || value === true || value === 'true' || value === 'TRUE' || value === 'True' ) { cell.value = true; } } else if ( dataType === 'date' || dataType === 'time' || dataType === 'dateTime' ) { const column = that.columnByDataField[ columnDataField ]; if ( unboundMode ) { cell.value = value; } else { if ( column && column.dataType !== dataType ) { cell.value = null; } } if ( selectedValues[ currentRowIndex - minRowIndex ] ) { value = selectedValues[ currentRowIndex - minRowIndex ][ currentColumnIndex - minColumnIndex ]; if ( value !== undefined ) { cell.value = value; } } } else if ( dataType === 'number' || dataType === 'float' || dataType === 'int' ) { value = that._getPatternValue( currentRowIndex - minRowIndex, currentColumnIndex - minColumnIndex, selectedValues ); const column = that.columnByDataField[ columnDataField ]; if ( unboundMode ) { cell.value = value; } else { if ( column && column.dataType !== dataType ) { cell.value = null; } else { if ( value !== null ) { if ( dataType === 'int' || dataType === 'integer' ) { cell.value = parseInt( value ); } else { cell.value = parseFloat( value ); } } else { cell.value = null; } } } } } _pasteSelectedCells( selectionRect, selectedValues ) { const that = this; that.beginUpdate(); let visibleRows = that._recyclingRows; let row = selectionRect.row; let endRow = selectionRect.endRow; let column = selectionRect.column; let endColumn = selectionRect.endColumn; const startRowIndex = visibleRows.indexOf( row ); const endRowIndex = visibleRows.indexOf( endRow ); const endSelectedRowIndex = visibleRows.indexOf( selectionRect.endRow ); const startColumnIndex = that.columns.indexOf( column ); const endColumnIndex = that.columns.indexOf( endColumn ); const endSelectedColumnIndex = that.columns.indexOf( selectionRect.endColumn ); const minRowIndex = Math.min( endSelectedRowIndex, Math.min( startRowIndex, endRowIndex ) ); const maxRowIndex = Math.max( endSelectedRowIndex, Math.max( startRowIndex, endRowIndex ) ); const minColumnIndex = Math.min( endSelectedColumnIndex, Math.min( startColumnIndex, endColumnIndex ) ); const maxColumnIndex = Math.max( endSelectedColumnIndex, Math.max( startColumnIndex, endColumnIndex ) ); let maxCapturedRowIndex = 0; let maxCapturedColumnIndex = 0; let capturedColumnIndex = 0; let capturedRowIndex = 0; for ( let rowId in selectedValues ) { if ( maxCapturedRowIndex === 0 ) { //for (let column in selectedValues[rowId]) { // maxCapturedColumnIndex++; //} maxCapturedColumnIndex += Object.keys( selectedValues[ rowId ] ).length; } maxCapturedRowIndex++; } for ( let i = minRowIndex; i <= maxRowIndex; i++ ) { const visibleRow = visibleRows[ i ]; //let columnIndex = 0; capturedColumnIndex = 0; for ( let j = minColumnIndex; j <= maxColumnIndex; j++ ) { const dataField = that.columns[ j ].dataField; const cell = visibleRow.getCell( dataField ); let currentCapturedRowIndex = 0; for ( let rowId in selectedValues ) { if ( currentCapturedRowIndex === capturedRowIndex ) { let currentCapturedColumnIndex = 0; let row = selectedValues[ rowId ]; for ( let columnDataField in row ) { if ( capturedColumnIndex === currentCapturedColumnIndex ) { let value = row[ columnDataField ]; let canSetValue = true; if ( selectedValues[ visibleRow.id ] ) { if ( selectedValues[ visibleRow.id ][ dataField ] ) { canSetValue = false; } } if ( canSetValue && that.clipboard.autoFillMode !== 'none' ) { const args = { value: value, oldValue: cell.value, dataField: columnDataField, id: rowId }; if ( that.clipboard.onPasteValue ) { that.clipboard.onPasteValue( args ); cell.value = args.value; } else { args.cell = cell; args.selectedValues = selectedValues; args.minRowIndex = minRowIndex; args.maxRowIndex = maxRowIndex; args.minColumnIndex = minColumnIndex; args.maxColumnIndex = maxColumnIndex; args.currentColumnIndex = j; args.currentRowIndex = i; if ( that.clipboard.autoFillMode === 'copy' ) { that._pasteModeCopy( args ); } else if ( that.clipboard.autoFillMode === 'fillSeries' ) { that._pasteModeFill( args ); } } } } currentCapturedColumnIndex++; } } currentCapturedRowIndex++; } capturedColumnIndex++; if ( capturedColumnIndex >= maxCapturedColumnIndex ) { capturedColumnIndex = 0; } } capturedRowIndex++; if ( capturedRowIndex >= maxCapturedRowIndex ) { capturedRowIndex = 0; } } that.endUpdate( false ); that._recycle( false ); } _refreshCellSelectionRect() { const that = this; const selectionRect = that._selection.selectionRect; if ( !selectionRect || ( selectionRect && selectionRect.captured ) ) { return; } let visibleRows = that._recyclingRows; let row = selectionRect.row; let endRow = selectionRect.endRow; let column = selectionRect.column; let endColumn = selectionRect.endColumn; const startRowIndex = visibleRows.indexOf( row ); const endRowIndex = visibleRows.indexOf( endRow ); const startColumnIndex = that.columns.indexOf( column ); const endColumnIndex = that.columns.indexOf( endColumn ); let minRowIndex = Math.min( startRowIndex, endRowIndex ); let maxRowIndex = Math.max( startRowIndex, endRowIndex ); let minColumnIndex = Math.min( startColumnIndex, endColumnIndex ); let maxColumnIndex = Math.max( startColumnIndex, endColumnIndex ); minColumnIndex = Math.max( 0, minColumnIndex ); minRowIndex = Math.max( 0, minRowIndex ); const updateMinMax = function ( parentCell ) { const rowStartIndex = visibleRows.indexOf( parentCell.row ); const rowEndIndex = visibleRows.indexOf( parentCell.endRow ); const rowStartColumnIndex = that.columns.indexOf( parentCell.column ); const rowEndColumnIndex = that.columns.indexOf( parentCell.endColumn ); minRowIndex = Math.min( minRowIndex, rowStartIndex ); minRowIndex = Math.min( minRowIndex, rowEndIndex ); minRowIndex = Math.max( 0, minRowIndex ); maxRowIndex = Math.max( maxRowIndex, rowStartIndex ); maxRowIndex = Math.max( maxRowIndex, rowEndIndex ); minColumnIndex = Math.min( minColumnIndex, rowStartColumnIndex ); minColumnIndex = Math.min( minColumnIndex, rowEndColumnIndex ); minColumnIndex = Math.max( 0, minColumnIndex ); maxColumnIndex = Math.max( maxColumnIndex, rowStartColumnIndex ); maxColumnIndex = Math.max( maxColumnIndex, rowEndColumnIndex ); } const parentCell = that._getParentCell( row, column.dataField ); const parentCell2 = that._getParentCell( row, endColumn.dataField ); const endParentCell = that._getParentCell( endRow, endColumn.dataField ); const endParentCell2 = that._getParentCell( endRow, column.dataField ); if ( parentCell ) { updateMinMax( parentCell ); } if ( parentCell2 ) { updateMinMax( parentCell2 ); } if ( endParentCell ) { updateMinMax( endParentCell ); } if ( endParentCell2 ) { updateMinMax( endParentCell2 ); } let top = 0; let height = 0; let left = 0; let width = 0; selectionRect.cellValues = []; for ( let i = minRowIndex; i <= maxRowIndex; i++ ) { const visibleRow = visibleRows[ i ]; if ( i === minRowIndex ) { top = visibleRow.top; if ( visibleRow.freeze !== true && visibleRow.freeze !== 'near' ) { top += that.__frozenNearHeight; } if ( visibleRow.freeze === 'far' ) { top = visibleRow.top + that.__scrollHeight + that.scrollTop - that._scrollView.hScrollBar.offsetHeight; } } if ( i === maxRowIndex ) { let lastTop = visibleRow.top; if ( visibleRow.freeze === 'far' ) { lastTop = visibleRow.top + that.__scrollHeight + that.scrollTop - that._scrollView.hScrollBar.offsetHeight; } height = lastTop + visibleRow.height - top; if ( visibleRow.freeze !== true && visibleRow.freeze !== 'near' ) { height += that.__frozenNearHeight; } } selectionRect.cellValues[ visibleRow.id ] = []; for ( let j = minColumnIndex; j <= maxColumnIndex; j++ ) { const dataField = that.columns[ j ].dataField; const cell = visibleRow.getCell( dataField ); selectionRect.cellValues[ visibleRow.id ][ dataField ] = cell.value; if ( j === minColumnIndex ) { left = cell.column.left; if ( cell.column.freeze && cell.column.freeze === 'far' ) { left = that.__clientSize.width - that.__frozenFarWidth + left + that.scrollLeft - that._scrollView.vScrollBar.offsetWidth; } } if ( j === maxColumnIndex ) { let maxLeft = cell.column.left; if ( cell.column.freeze && cell.column.freeze === 'far' ) { maxLeft = that.__clientSize.width - that.__frozenFarWidth + maxLeft + that.scrollLeft - that._scrollView.vScrollBar.offsetWidth; } width = maxLeft + cell.column.computedWidth - left; } cell.selected = true; } } selectionRect.style.top = top - that.scrollTop - 1 + 'px'; if ( that.rightToLeft ) { selectionRect.style.right = left - that.scrollLeft + 'px'; } else { selectionRect.style.left = left - that.scrollLeft + 'px'; } selectionRect.style.height = height + 1 + 'px'; selectionRect.style.width = width + 1 + 'px'; } _renderInputOverlay( id, event, isSameRow ) { const that = this; const row = that.rowById[ id ]; if ( !row ) { return; } if ( (false === row.allowSelect) || row.label ) { return; } if ( event && that.selection.checkBoxes.enabled ) { if ( that._inputOverlay && that._inputOverlay.classList.contains( 'lw-input-overlay-column' ) ) { if ( that._inputOverlay.parentNode ) { that._inputOverlay.parentNode.removeChild( that._inputOverlay ); } that._inputOverlay = null; } if ( !that._inputOverlay ) { that._inputOverlay = document.createElement( 'div' ); that.$.scrollView.appendChild( that._inputOverlay ); that._inputOverlay.classList.add( 'lw-input-overlay' ); } let top = !row.freeze ? that.__frozenNearHeight + row.top : row.top; const center = Math.round( ( row.cellHeight - that._selectionColumn.computedWidth ) / 2 ); const left = that._selectionColumn.element.parentElement.offsetLeft + that._selectionColumn.element.offsetLeft; that._inputOverlay.style.left = left + 'px'; that._inputOverlay.style.height = that._selectionColumn.computedWidth + 'px'; that._inputOverlay.style.width = that._selectionColumn.computedWidth + 'px'; that._inputOverlay.style.top = top + center - that.scrollTop + 'px'; that._inputOverlay.row = row; that._inputOverlay.onpointerdown = function () { if ( !that._inputOverlay ) { that._inputOverlay.onpointerdown = null; } const row = that._inputOverlay.row; that.beginUpdate(); row.selected = !row.selected; that.endUpdate( false ); that._recycle(); that._renderInputOverlay( row.id, event, true ); } if ( that.appearance.allowCheckBoxesSelectionAnimation && isSameRow === undefined ) { that._inputOverlay.classList.add( 'lw-animate' ); } requestAnimationFrame( () => { if ( that._inputOverlay ) { that._inputOverlay.classList.add( 'lw-input-overlay-on' ); } } ); } } _selectRow( id, event ) { const that = this; const row = that.rowById[ id ]; if ( !row || !that.selection.enabled ) { return; } if ( row.header && row.header.style.cursor === 'row-resize' ) { return; } if ( event ) { if ( !event.shiftKey || !that._selection.focusedCell ) { that._selection.focusedCell = row.getCell( that.columns[ 0 ].dataField ); } } that._lastRowsSelectionRange = null; if ( that.selection.mode === 'extended' ) { that._handleExtendedRowSelection( row, event ); } else { if ( that.selection.mode === 'one' ) { row.selected = true; } else { row.selected = !row.selected; } } } _getParentCell( row, dataField ) { const that = this; let visibleRows = that._recyclingRows; for ( let i = 0; i < that._cellsMerge.length; i++ ) { const cell = that._cellsMerge[ i ]; let rows = []; let columns = []; rows.push( cell.row ); if ( cell.rowSpan > 1 ) { const startRowIndex = visibleRows.indexOf( cell.row ); if ( startRowIndex >= 0 ) { for ( let r = startRowIndex; r < startRowIndex + cell.rowSpan; r++ ) { if ( visibleRows[ r ] && rows.indexOf( visibleRows[ r ] ) === -1 ) { rows.push( visibleRows[ r ] ); } } } } columns.push( cell.column.dataField ); if ( cell.colSpan > 1 ) { const startColumnIndex = that.columns.indexOf( that.columnByDataField[ cell.column.dataField ] ); for ( let r = startColumnIndex; r < startColumnIndex + cell.colSpan; r++ ) { if ( that.columns[ r ] && columns.indexOf( that.columns[ r ].dataField ) === -1 ) { columns.push( that.columns[ r ].dataField ); } } } if ( rows.indexOf( row ) >= 0 && columns.indexOf( dataField ) >= 0 ) { return { row: cell.row, column: cell.column, endRow: rows[ rows.length - 1 ], endColumn: that.columnByDataField[ columns[ columns.length - 1 ] ] }; } } return null; } _selectCellsRange( startRow, endRow, dataField, endDataField ) { const that = this; const selectionRect = that._selection.selectionRect; if ( that._lastRowsSelectionRange && that._lastRowsSelectionRange.id === startRow.id && that._lastRowsSelectionRange.endId === endRow.id && ( that._lastColumnSelectionRange && that._lastColumnSelectionRange.dataField === dataField && that._lastColumnSelectionRange.endDataField === endDataField ) ) { return; } that.beginUpdate(); that._clearSelection(); that._lastRowsSelectionRange = { id: startRow.id, endId: endRow.id }; that._lastColumnSelectionRange = { dataField: dataField, endDataField: endDataField }; if ( !selectionRect || ( selectionRect && !selectionRect.captured ) ) { if ( that._selection.focusedCell ) { that._renderCellSelectionRect( that._selection.focusedCell.row, // begin row that._selection.focusedCell.column, // begin column that.rowById[ that._lastRowsSelectionRange.endId ], // end row that.columnByDataField[ that._lastColumnSelectionRange.endDataField ] ); // end column } } let visibleRows = that._recyclingRows; let startColumnIndex = -1; let endColumnIndex = that.columns.length; let startIndex = visibleRows.indexOf( startRow ); let endIndex = visibleRows.indexOf( endRow ); for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; if ( !column.allowSelect ) { continue; } if ( column.dataField === dataField ) { startColumnIndex = i; } if ( column.dataField === endDataField ) { endColumnIndex = i; } } let minIndex = Math.min( startIndex, endIndex ); let maxIndex = Math.max( startIndex, endIndex ); let minColumnIndex = Math.min( startColumnIndex, endColumnIndex ); let maxColumnIndex = Math.max( startColumnIndex, endColumnIndex ); const updateMinMax = function ( parentCell ) { const rowStartIndex = visibleRows.indexOf( parentCell.row ); const rowEndIndex = visibleRows.indexOf( parentCell.endRow ); const rowStartColumnIndex = that.columns.indexOf( parentCell.column ); const rowEndColumnIndex = that.columns.indexOf( parentCell.endColumn ); minIndex = Math.min( minIndex, rowStartIndex ); minIndex = Math.min( minIndex, rowEndIndex ); maxIndex = Math.max( maxIndex, rowStartIndex ); maxIndex = Math.max( maxIndex, rowEndIndex ); minColumnIndex = Math.min( minColumnIndex, rowStartColumnIndex ); minColumnIndex = Math.min( minColumnIndex, rowEndColumnIndex ); maxColumnIndex = Math.max( maxColumnIndex, rowStartColumnIndex ); maxColumnIndex = Math.max( maxColumnIndex, rowEndColumnIndex ); } const parentCell = that._getParentCell( startRow, dataField ); const endParentCell = that._getParentCell( endRow, endDataField ); if ( parentCell ) { updateMinMax( parentCell ); } if ( endParentCell ) { updateMinMax( endParentCell ); } if ( maxIndex < 0 || minIndex < 0 ) { that.endUpdate( false ); that._recycle(); return; } for ( let i = minIndex; i <= maxIndex; i++ ) { const row = visibleRows[ i ]; if ( !row.allowSelect ) { continue; } for ( let j = 0; j < that.columns.length; j++ ) { const column = that.columns[ j ]; if ( !column.allowSelect ) { continue; } if ( j >= minColumnIndex && j <= maxColumnIndex ) { const cell = row.getCell( column.dataField ); cell.selected = true; } } } that.endUpdate( false ); that._recycle(); } _selectRowsRange( startRow, endRow ) { const that = this; if ( that._lastRowsSelectionRange && that._lastRowsSelectionRange.id === startRow.id && that._lastRowsSelectionRange.endId === endRow.id ) { return; } that.beginUpdate(); that._clearSelection(); that._lastRowsSelectionRange = { id: startRow.id, endId: endRow.id }; let visibleRows = that._recyclingRows; const startIndex = visibleRows.indexOf( startRow ); const endIndex = visibleRows.indexOf( endRow ); const minIndex = Math.min( startIndex, endIndex ); const maxIndex = Math.max( startIndex, endIndex ); if ( maxIndex < 0 ) { that.endUpdate( false ); that._recycle(); return; } for ( let i = minIndex; i <= maxIndex; i++ ) { const visibleRow = visibleRows[ i ]; if ( !visibleRow ) { continue; } if ( !visibleRow.allowSelect ) { continue; } visibleRow.selected = true; } that.endUpdate( false ); that._recycle(); } _selectColumnsRange( dataField, endDataField ) { const that = this; if ( that._lastColumnSelectionRange && that._lastColumnSelectionRange.dataField === dataField && that._lastColumnSelectionRange.endDataField === endDataField ) { return; } that.beginUpdate(); that._clearSelection(); that._lastColumnSelectionRange = { dataField: dataField, endDataField: endDataField }; let startIndex = -1; let endIndex = that.columns.length; for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; if ( !column.allowSelect ) { continue; } if ( column.dataField === dataField ) { startIndex = i; } if ( column.dataField === endDataField ) { endIndex = i; } } const minIndex = Math.min( startIndex, endIndex ); const maxIndex = Math.max( startIndex, endIndex ); for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; if ( !column.allowSelect ) { continue; } if ( i >= minIndex && i <= maxIndex ) { column.selected = true; } } that.endUpdate( false ); that._recycle(); } _selectColumn( dataField, event ) { const that = this; const column = that.columnByDataField[ dataField ]; if ( !column || !that.selection.enabled || (false === column.allowSelect) || !that.selection.allowColumnHeaderSelection ) { return; } if ( column && column.element.style.cursor === 'col-resize' ) { return; } let canSelect = false; if ( column && (column.allowSelect || (column.allowSelect === null && !event))) { canSelect = true; } if (!canSelect) { return; } if ( event ) { if ( that.selection.mode === 'extended' ) { if ( !event.ctrlKey && !event.shiftKey ) { that._rangeSelectionStartColumn = column; that._rangeSelectionEndColumn = column; } column.selected = true; if ( event && event.shiftKey ) { if ( !that._rangeSelectionStartColumn ) { that._rangeSelectionStartColumn = column; } that._rangeSelectionEndColumn = column; that._selection.columns = []; const startIndex = that.columns.indexOf( that._rangeSelectionStartColumn ); const endIndex = that.columns.indexOf( that._rangeSelectionEndColumn ); const minIndex = Math.min( startIndex, endIndex ); const maxIndex = Math.max( startIndex, endIndex ); for ( let i = minIndex; i <= maxIndex; i++ ) { const column = that.columns[ i ]; if (column.allowSelect !== false) { column.selected = true; } } } } else { if ( that.selection.mode === 'one' ) { column.selected = true; } else { if ( column.selected === null ) { column.selected = true; } else { column.selected = !column.selected; } } } } } _getSelectedRows( onlyVisibleRows, onlyInCurrentPage ) { const that = this; const selectedRows = []; let rows = that.rows; that.rows.canNotify = false; if ( onlyVisibleRows ) { rows = that.getVisibleRows(); } if ( that.paging.enabled && onlyInCurrentPage ) { rows = rows.slice( that.paging.pageIndex * that.paging.pageSize, ( that.paging.pageIndex + 1 ) * that.paging.pageSize ); } for ( let i = 0; i < rows.length; i++ ) { const row = rows[ i ]; if ( row.getProperty( 'selected' ) ) { selectedRows.push( row ); } else { row.canNotify = false; row.selected = false; row.canNotify = true; } } that.rows.canNotify = true; return selectedRows; } _dragSelectionEnd( event ) { const that = this; that._dragSelectionStartDataField = null; that._dragSelectionStartRow = null; if ( that.__selectionStarted ) { that.$.fireEvent( 'change', { started: false, finished: true, originalEvent: event } ); delete that.__selectionStarted; delete that.__selectionStartedFired; } if ( !that.selection.allowDragSelection || !that.selection.isDragging ) { return; } that.selection.isDragging = false; if ( that._autoScrollSelectionDragInterval ) { clearInterval( that._autoScrollSelectionDragInterval ); if ( !that.editing.isEditing ) { that._recycle(); } } } _dragSelection( event ) { const that = this; if ( that.selection.mode !== 'extended' || that.selection.allowDragSelection === false ) { return; } if ( !that._dragSelectionStartDataField && !that._dragSelectionStartRow ) { return; } const fireSelectionEvent = () => { if ( that.__selectionStarted && !that.__selectionStartedFired ) { that.$.fireEvent( 'change', { started: true, finished: false, originalEvent: event } ); that.__selectionStartedFired = true; } that.$.fireEvent( 'change', { started: false, finished: false, originalEvent: event } ); } if ( that.selection.allowCellSelection && ( that._dragSelectionStartDataField && !that._columnResizeLine && !that._dragSelectionStartDataField.startsWith( '_' ) ) && ( that._dragSelectionStartRow && !that._rowResizeLine ) ) { const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); let columnDataField = null; for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.getAttribute( 'data-field' ) ) { columnDataField = element.getAttribute( 'data-field' ); break; } } let row = null; for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.getAttribute( 'data-id' ) ) { row = element.row; break; } } if ( columnDataField && row ) { if ( row.id === that._dragSelectionStartRow.id && that._dragSelectionStartDataField === columnDataField ) { return; } let canFireEvent = true; if ( that._lastRowsSelectionRange && that._lastRowsSelectionRange.id === that._dragSelectionStartRow.id && that._lastRowsSelectionRange.endId === row.id && ( that._lastColumnSelectionRange && that._lastColumnSelectionRange.dataField === that._dragSelectionStartDataField && that._lastColumnSelectionRange.endDataField === columnDataField ) ) { canFireEvent = false; } that._selectCellsRange( that._dragSelectionStartRow, row, that._dragSelectionStartDataField, columnDataField ); if ( canFireEvent ) { fireSelectionEvent(); } } if ( that.selection.allowDragSelectionAutoScroll ) { if ( that._autoScrollSelectionDragInterval ) { clearInterval( that._autoScrollSelectionDragInterval ); } that.selection.isDragging = true; that._autoScrollSelectionDragInterval = setInterval( function () { const rect = that.$.scrollView.getBoundingClientRect(); if ( event.clientX <= rect.left + 20 ) { that.scrollLeft -= 15; } else if ( event.clientX >= rect.left + rect.width - 20 ) { that.scrollLeft += 15; } if ( event.clientY <= rect.top + 20 ) { that.scrollTop -= 15; } else if ( event.clientY >= rect.top + rect.height - 20 ) { that.scrollTop += 15; } }, 5 ); } return; } if ( that._dragSelectionStartRow && !that._rowResizeLine && ( ( that.selection.allowRowSelection && !that._dragSelectionStartDataField.startsWith( '_' ) ) || ( that.selection.allowRowHeaderSelection && that._dragSelectionStartDataField.startsWith( '_' ) ) ) ) { const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); let row = null; for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.getAttribute( 'data-id' ) ) { row = element.row; if ( !row && element.cell ) { row = element.cell.row; } break; } } let canFireEvent = true; if ( that._lastRowsSelectionRange && that._lastRowsSelectionRange.id === that._dragSelectionStartRow.id && row && that._lastRowsSelectionRange.endId === row.id ) { canFireEvent = false; } if (row && !row.allowSelect) { canFireEvent = false; } if ( row && row.allowSelect) { that._selectRowsRange( that._dragSelectionStartRow, row ); } if ( that._autoScrollSelectionDragInterval ) { clearInterval( that._autoScrollSelectionDragInterval ); } that.selection.isDragging = true; if ( canFireEvent ) { fireSelectionEvent(); } that._autoScrollSelectionDragInterval = setInterval( function () { const rect = that.$.scrollView.getBoundingClientRect(); if ( event.clientY <= rect.top + 20 ) { that.scrollTop -= 15; } else if ( event.clientY >= rect.top + rect.height - 20 ) { that.scrollTop += 15; } }, 5 ); } else if ( that._dragSelectionStartDataField && !that._columnResizeLine && !that._dragSelectionStartDataField.startsWith( '_' ) && that.selection.allowColumnHeaderSelection ) { const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); let columnDataField = null; for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.getAttribute( 'data-field' ) ) { columnDataField = element.getAttribute( 'data-field' ); break; } } if ( columnDataField ) { that._selectColumnsRange( that._dragSelectionStartDataField, columnDataField ); } if ( that._autoScrollSelectionDragInterval ) { clearInterval( that._autoScrollSelectionDragInterval ); } let canFireEvent = true; if ( ( that._lastColumnSelectionRange && that._lastColumnSelectionRange.dataField === that._dragSelectionStartDataField && that._lastColumnSelectionRange.endDataField === columnDataField ) ) { canFireEvent = false; } if ( canFireEvent ) { fireSelectionEvent(); } that.selection.isDragging = true; that._autoScrollSelectionDragInterval = setInterval( function () { const rect = that.$.scrollView.getBoundingClientRect(); if ( event.clientX <= rect.left + 20 ) { that.scrollLeft -= 15; } else if ( event.clientX >= rect.left + rect.width - 20 ) { that.scrollLeft += 15; } }, 5 ); } } // PUBLIC API select( id, dataField ) { const that = this; that._setSelection( id, dataField ); that.$.fireEvent( 'change', { started: false, finished: true } ); } selectRange( id, dataField, endId, endDataField ) { const that = this; const selectAndUpdate = function () { const event = new KeyboardEvent( 'keydown', { shiftKey: true } ); requestAnimationFrame( () => { if ( that.selection.mode !== 'extended' ) { that._clearSelection(); } that.beginUpdate(); that._setSelection( id, dataField ); that._setSelection( endId, endDataField, event ); that.ensureVisible( id, dataField ); that.endUpdate( false ); that._recycle(); } ); } selectAndUpdate(); that.$.fireEvent( 'change', { started: false, finished: true } ); } unselect( id, dataField ) { const that = this; if ( that._selection ) { if ( that._selection.rows && that._selection.rows[ id ] ) { delete that._selection.rows[ id ]; } if ( that._selection.columns && that._selection.columns[ dataField ] ) { delete that._selection.columns[ dataField ]; } if ( that._selection.cells ) { if ( that._selection.cells[ 'row' + id ] ) { delete that._selection.cells[ 'row' + id ][ dataField ]; if ( Object.getOwnPropertyNames( that._selection.cells[ 'row' + id ] ).length === 1 ) { delete that._selection.cells[ 'row' + id ]; } } if ( that._selection.cells[ 'column' + dataField ] ) { delete that._selection.cells[ 'column' + dataField ][ id ]; if ( Object.getOwnPropertyNames( that._selection.cells[ 'column' + dataField ] ).length === 1 ) { delete that._selection.cells[ 'column' + dataField ]; } } } that.$.fireEvent( 'change', { started: false, finished: true } ); } } getSelection() { const that = this; let rows = null; let columns = null; let cells = null; let focused = null; if ( that._selection.rows && Object.keys( that._selection.rows ).length > 0 ) { const rowKeys = Object.keys( that._selection.rows ); rows = []; for ( let i = 0; i < rowKeys.length; i++ ) { const rowKey = rowKeys[ i ]; rows.push( { id: rowKey, row: that.rowById[ rowKey ] } ); } } if ( that._selection.columns && Object.keys( that._selection.columns ).length > 0 ) { const columnKeys = Object.keys( that._selection.columns ); columns = []; for ( let i = 0; i < columnKeys.length; i++ ) { const columnKey = columnKeys[ i ]; columns.push( { dataField: columnKey, column: that.columnByDataField[ columnKey ] } ); } } if ( that._selection.cells ) { for ( let propertyName in that._selection.cells ) { if ( propertyName.startsWith( 'row' ) ) { let id = propertyName.replace( 'row', '' ); let dataField = null; for ( let columnDataField in that._selection.cells[ propertyName ] ) { dataField = columnDataField.replace( 'column', '' ); if ( !cells ) { cells = []; } cells.push( { id: id, dataField: dataField, column: that.columnByDataField[ dataField ], row: that.rowById[ id ] } ); } } } } if ( that._selection.focusedCell ) { focused = { id: that._selection.focusedCell.row.id, dataField: that._selection.focusedCell.column.dataField }; } return { rows: rows, columns: columns, cells: cells, focused: focused } } _clearSelection( removeFocus ) { const that = this; that._selection.rows = []; that._selection.columns = []; that._selection.cells = []; if ( removeFocus ) { that._selection.focusedCell = null; if ( that._selection.selectionRect ) { const selectionRect = that._selection.selectionRect; selectionRect.parentNode.removeChild( selectionRect ); const eventNames = { down: 'pointerdown', move: 'pointermove', up: 'pointerup' }; if ( LW.Utilities.Core.isMobile ) { eventNames.down = 'touchstart'; eventNames.move = 'touchmove'; eventNames.up = 'touchend'; } document.removeEventListener( eventNames.move, selectionRect.onMove ); document.removeEventListener( eventNames.up, selectionRect.onUp ); document.removeEventListener( eventNames.down, selectionRect.onDown ); that._selection.selectionRect = null; } } that._recycle(); const column = that._selectionColumn; column.refresh(); } _getSelectionCellValues() { const that = this; if ( that._selection.selectionRect ) { return that._selection.selectionRect.cellValues; } if ( that._selection.rows.length > 0 ) { let cellValues = []; for ( let id in that._selection.rows ) { const row = that.rowById[ id ]; for ( let j = 0; j < that.columns.length; j++ ) { const column = that.columns[ j ]; if ( !column ) { continue; } if ( !cellValues[ id ] ) { cellValues[ id ] = []; } cellValues[ id ][ column.dataField ] = row.data[ column.dataField ]; } } return cellValues; } if ( that._selection.columns.length > 0 ) { let cellValues = []; for ( let dataField in that._selection.columns ) { const column = that.columnByDataField[ dataField ]; if ( !column ) { continue; } for ( let j = 0; j < that._recyclingRows.length; j++ ) { const row = that._recyclingRows[ j ]; if ( !row ) { continue; } if ( !cellValues[ row.id ] ) { cellValues[ row.id ] = []; } cellValues[ row.id ][ column.dataField ] = row.data[ column.dataField ]; } } return cellValues; } } _clipboardHandler( key, event ) { const that = this; if ( that.clipboard.enabled ) { if ( event.ctrlKey && ( key === 'c' || key === 'x' ) ) { const values = that._getSelectionCellValues(); let clipboard = ''; let rows = Object.keys( values ).length; let rowIndex = 0; for ( let row in values ) { let clipboardLine = ''; let cols = Object.keys( values[ row ] ).length; let colIndex = 0; for ( let column in values[ row ] ) { const value = values[ row ][ column ]; clipboardLine += value; colIndex++; if ( colIndex < cols ) { clipboardLine += '\t'; } } clipboard += clipboardLine; rowIndex++; if ( rowIndex < rows ) { clipboard += '\r\n'; } if ( key === 'x' ) { //if (selection.cells) { // that.beginUpdate(); // for (let i = 0; i < selection.cells.length; i++) { // const cell = selection.cells[i]; // const row = that.rowById[cell.id]; // if (row) { // const rowCell = row.getCell(cell.dataField); // rowCell.value = null; // } // } // that.endUpdate(false); // that._recycle(); //} } } navigator.clipboard.writeText( clipboard ).then( function () { /* clipboard successfully set */ }, function () { /* clipboard write failed */ } ); } if ( event.ctrlKey && key === 'v' ) { navigator.clipboard.readText().then( text => { const clipboardValues = []; //const clipboard = text; const rows = text.split( '\r' ); for ( let i = 0; i < rows.length; i++ ) { const row = rows[ i ]; const cells = row.split( '\t' ); let data = {}; for ( let j = 0; j < cells.length; j++ ) { data[ j ] = cells[ j ].trim(); } clipboardValues[ i ] = data; } const selectionRect = that._selection.selectionRect; if ( selectionRect ) { that._pasteSelectedCells( { row: selectionRect.row, endRow: selectionRect.endDragRow, column: selectionRect.column, endColumn: selectionRect.endColumn }, clipboardValues ); } else { let minRow = null; let maxRow = null; for ( let id in that._selection.rows ) { const row = that.rowById[ id ]; if ( !minRow ) { minRow = row; } if ( !maxRow ) { maxRow = row; } if ( minRow.visibleIndex > row.visibleIndex ) { minRow = row; } if ( maxRow.visibleIndex < row.visibleIndex ) { maxRow = row; } } if ( minRow && maxRow ) { that._pasteSelectedCells( { row: minRow, endRow: maxRow, column: that.columns[ 0 ], endColumn: that.columns[ that.columns.length - 1 ] }, clipboardValues ); } } } ); } } } /** * KeyDown handler. */ _keyDownHandler( event ) { const that = this; if ( that.onKey ) { that.onKey( event ); if ( event.defaultPrevented ) { return; } } let key = event.key; if ( that.disabled ) { return; } if ( that.dataSource.length === 0 || that.disabled || that.displayLoadingIndicator ) { return; } if ( that.editing.editRow || that.editing.editCell || that.filtering.filterRow.cell ) { return; } if ( that.rightToLeft ) { if ( key === 'ArrowLeft' ) { key = 'ArrowRight'; } else if ( key === 'ArrowRight' ) { key = 'ArrowLeft'; } } that._refreshCellSelectionRect(); const selection = that.getSelection(); let focused = selection.focused; if ( !selection.focused ) { if ( that.editing.enabled && that.editing.isEditing !== true && ( key === 'F2' || key === 'Enter' ) ) { if ( selection.columns && selection.columns.length > 0 ) { const lastColumn = selection.columns[ selection.columns.length - 1 ] if ( lastColumn.column.allowHeaderEdit ) { that._beginColumnEdit( lastColumn.column ); } } } return; } const parentCell = that._getParentCell( that.rowById[ focused.id ], focused.dataField ); if ( parentCell ) { //const cell = parentCell.row.getCell(parentCell.column.dataField); if ( key === 'ArrowLeft' ) { focused.id = parentCell.row.id; focused.dataField = parentCell.column.dataField; } else if ( key === 'ArrowRight' ) { focused.id = parentCell.row.id; focused.dataField = parentCell.endColumn.dataField; } else if ( key === 'ArrowUp' ) { focused.id = parentCell.row.id; focused.dataField = parentCell.column.dataField; } else if ( key === 'ArrowDown' ) { focused.id = parentCell.endRow.id; focused.dataField = parentCell.column.dataField; } } if ( that._selection.selectionRect && event.shiftKey && !event.ctrlKey ) { if ( that._selection.selectionRect.endRow ) { focused.id = that._selection.selectionRect.endRow.id; } if ( that._selection.selectionRect.endColumn ) { focused.dataField = that._selection.selectionRect.endColumn.dataField; } } else if ( that.selection.allowRowSelection && !that.selection.allowCellSelection && that._rangeSelectionEndRow !== undefined ) { focused.id = that._rangeSelectionEndRow.id; } that._clipboardHandler( key, event ); if ( ( event.ctrlKey && key !== 'x' && key !== 'c' && key !== 'v' && key !== 'Control' ) || key === 'Tab' ) { that._selection.rows = []; that._selection.columns = []; that._selection.cells = []; } if ( key === 'Escape' ) { that.closeMenu(); that.cancelEdit(); that._setSelection( focused.id, focused.dataField, event ); return; } if ( that.hasMenu() ) { return; } if ( event.altKey ) { if ( key === 'ArrowDown' ) { const column = that.columnByDataField[ focused.dataField ]; if ( column && that.hasColumnMenu( column ) ) { column.showActionButton = true; column.onAction(); if ( that.menu ) { that.menu.querySelector( 'lw-menu' ).focus(); that.menu.querySelector( 'lw-menu' ).$.dispatch( event ); } } } else if ( key === 'ArrowUp' ) { that.closeMenu(); } if ( key.toLowerCase() === 's' ) { const column = that.columnByDataField[ focused.dataField ]; if ( column ) { if ( !column.sorted ) { that.sortBy( column.dataField, 'asc' ); } else if ( column.sortOrder === 'asc' ) { that.sortBy( column.dataField, 'desc' ); } else { that.sortBy( column.dataField, null ); } } } if ( key.toLowerCase() === 'g' ) { const column = that.columnByDataField[ focused.dataField ]; if ( column ) { column.group = !column.group; } } return; } const selectAndUpdate = function ( id, dataField ) { requestAnimationFrame( () => { if ( that.selection.mode !== 'extended' ) { that._clearSelection( true ); } that.beginUpdate(); that._setSelection( id, dataField, event ); that.ensureVisible( id, dataField ); that.endUpdate( false ); that._recycle(); if (event.shiftKey) { if ( that.__selectionStarted && !that.__selectionStartedFired ) { that.$.fireEvent( 'change', { started: true, finished: false } ); that.__selectionStartedFired = true; } else { that.$.fireEvent( 'change', { started: false, finished: false } ); } } else { that.$.fireEvent( 'change', { started: false, finished: true } ); } } ); event.stopPropagation(); event.preventDefault(); //prevent window scrolling } switch ( key ) { case 'Tab': { const column = !event.shiftKey ? that.nextColumn( focused.dataField ) : that.prevColumn( focused.dataField ); if ( column ) { that._selection.focusedCell = that.rowById[ focused.id ].getCell( column.dataField ); that._setSelection( focused.id, column.dataField, event ); that.focus(); event.stopPropagation(); event.preventDefault(); } else { let row = !event.shiftKey ? that.nextRow( focused.id ) : that.prevRow( focused.id ); let dataField = !event.shiftKey ? that.firstColumn().dataField : that.lastColumn().dataField; if ( that.editing.addNewRow.autoCreate && !event.shiftKey && focused.id === that.lastRow().id ) { that.addUnboundRow( 1 ); row = that.lastRow(); } if ( !row ) { return; } if ( event.shiftKey ) { that._selection.focusedCell = null; } selectAndUpdate( row.id, dataField ); } break; } case ' ': case 'F2': { const row = that.rowById[ focused.id ]; if ( !row || that.editing.editCell ) { return; } if ( key === ' ' && that.dataSource.boundHierarchy ) { row.checked = !row.checked; } if ( that.editing.enabled ) { that._beginEdit( row, focused.dataField ); setTimeout( function () { if ( that.editing.editCell && that.editing.editCell.column.dataType.indexOf( 'bool' ) >= 0 ) { const editor = that.editing.editCell.editor.instance; const value = editor.getValue(); editor.setValue( !value ); } }, 50 ); } break; } case 'Delete': case 'Backspace': { const row = that.rowById[ focused.id ]; if ( !row || that.editing.editCell ) { return; } const rowCell = row.getCell( focused.dataField ); const value = rowCell.value; if ( selection.cells ) { that.beginUpdate(); for ( let i = 0; i < selection.cells.length; i++ ) { const cell = selection.cells[ i ]; const row = that.rowById[ cell.id ]; if ( row ) { const rowCell = row.getCell( cell.dataField ); rowCell.value = null; } } that.endUpdate( false ); that._recycle(); } if ( key === 'Backspace' ) { that._beginEdit( row, focused.dataField ); rowCell.canNotify = false; rowCell.value = value; rowCell.canNotify = true; } break; } default: { if ( that.editing.enabled && !that.editing.editCell && !event.ctrlKey && !event.altKey && !that.editing.editRow ) { const row = that.rowById[ focused.id ]; if ( !row ) { return; } if ( [ 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12', 'Shift', 'Up', 'Down', 'Left', 'Right', 'Control', 'F2', 'Esc', ' ', 'Home', 'End', 'PageUp', 'PageDown' ].indexOf( key ) >= 0 ) { return; } that._beginEdit( row, focused.dataField ); setTimeout( function () { if ( that.editing.editCell ) { that.editing.editCell.editor.instance.setValue( key ); } else if ( that.editing.editRow ) { const cell = that.editing.editRow.getCell( focused.dataField ); if ( !cell ) { return; } cell.editor.instance.setValue( key ); } }, 50 ); } break; } case 'Home': { const row = that.firstRow(); if ( !row ) { return; } selectAndUpdate( row.id, focused.dataField ); break; } case 'End': { const row = that.lastRow(); if ( !row ) { return; } selectAndUpdate( row.id, focused.dataField ); break; } case 'PageUp': { const rows = that._recyclingRows; const row = that.rowById[ focused.id ]; const index = rows.indexOf( row ); for ( let i = index; i >= 0; i-- ) { const currentRow = rows[ i ]; if ( row.top - currentRow.top >= that.$.scrollView.offsetHeight ) { selectAndUpdate( currentRow.id, focused.dataField ); return; } } selectAndUpdate( that.firstRow().id, focused.dataField ); break; } case 'PageDown': { const rows = that._recyclingRows; const row = that.rowById[ focused.id ]; const index = rows.indexOf( row ); for ( let i = index; i < rows.length; i++ ) { const currentRow = rows[ i ]; if ( currentRow.top - row.top >= that.$.scrollView.offsetHeight ) { selectAndUpdate( currentRow.id, focused.dataField ); return; } } selectAndUpdate( that.lastRow().id, focused.dataField ); break; } case 'ArrowDown': case 'Enter': { let row = !event.ctrlKey ? that.nextRow( focused.id ) : that.lastRow(); if ( that.editing.addNewRow.autoCreate && key === 'Enter' && focused.id === that.lastRow().id ) { that.addUnboundRow( 1 ); row = that.lastRow(); } if ( !row ) { return; } selectAndUpdate( row.id, focused.dataField ); break; } case 'ArrowUp': { const row = !event.ctrlKey ? that.prevRow( focused.id ) : that.firstRow(); if ( !row ) { return; } selectAndUpdate( row.id, focused.dataField ); break; } case 'ArrowRight': { const row = that.rowById[ focused.id ]; const isTreeColumn = that.columnByDataField[ focused.dataField ]._treeColumn; if ( !that.selection.allowCellSelection || isTreeColumn ) { if ( false === row.leaf ) { if ( !row.expanded ) { row.expand(); return; } else { const firstChildRow = that.nextRow( focused.id ); if ( firstChildRow ) { selectAndUpdate( firstChildRow.id, focused.dataField ); return; } } } } const column = !event.ctrlKey ? that.nextColumn( focused.dataField ) : that.lastColumn(); if ( !column ) { return; } selectAndUpdate( focused.id, column.dataField ); break; } case 'ArrowLeft': { const row = that.rowById[ focused.id ]; const isTreeColumn = that.columnByDataField[ focused.dataField ]._treeColumn; if ( !that.selection.allowCellSelection || isTreeColumn ) { if ( false === row.leaf ) { if ( row.expanded ) { row.collapse(); } else if ( row.parent ) { selectAndUpdate( row.parent.id, focused.dataField ); } return; } else if ( row.leaf === true && row.parent ) { selectAndUpdate( row.parent.id, focused.dataField ); return; } } const column = !event.ctrlKey ? that.prevColumn( focused.dataField ) : that.firstColumn(); if ( !column ) { return; } selectAndUpdate( focused.id, column.dataField ); break; } } if ( [ 'Shift', 'Up', 'Down', 'Left', 'Right', 'Control', 'F2', 'Esc', ' ', 'Home', 'End', 'PageUp', 'PageDown' ].indexOf( key ) < 0 ) { return; } event.stopPropagation(); event.preventDefault(); //prevent window scrolling } /* * KeyUp handler. */ _keyUpHandler( event ) { const that = this; if ( event.key === 'Escape' && that.dragDrop ) { that._endDrag( event ); } if ( !that._focused ) { return; } if (event.key === 'Shift') { that.$.fireEvent( 'change', { started: false, finished: true } ); } } /* Public API */ firstRow() { const that = this; const rows = that._recyclingRows; if ( rows && rows.length > 0 ) { if ( !rows[ 0 ].autoGenerated ) { return rows[ 0 ]; } else { for ( let i = 0; i < rows.length; i++ ) { if ( !rows[ i ].autoGenerated ) { return rows[ i ]; } } } } return null; } lastRow() { const that = this; const rows = that._recyclingRows; if ( rows && rows.length > 0 ) { const row = rows[ rows.length - 1 ]; if ( !row.autoGenerated ) { return row; } else { for ( let i = rows.length - 1; i >= 0; i-- ) { if ( !rows[ i ].autoGenerated ) { return rows[ i ]; } } } } return null; } nextRow( id ) { const that = this; const rows = that._recyclingRows; const row = that.rowById[ id ]; const index = rows.indexOf( row ); if ( index >= 0 && rows[ index + 1 ] && !rows[ index + 1 ].autoGenerated ) { const newRow = rows[ index + 1 ]; if ( newRow.allowSelect && !newRow.disabled ) { return newRow; } else { for ( let i = index + 1; i < rows.length; i++ ) { const newRow = rows[ i ]; if ( newRow.allowSelect && !newRow.disabled ) { return newRow; } } } } return null; } prevRow( id ) { const that = this; const rows = that._recyclingRows; const row = that.rowById[ id ]; const index = rows.indexOf( row ); if ( index >= 0 && rows[ index - 1 ] && !rows[ index - 1 ].autoGenerated ) { const newRow = rows[ index - 1 ]; if ( newRow.allowSelect && !newRow.disabled ) { return newRow; } else { for ( let i = index - 1; i >= 0; i-- ) { const newRow = rows[ i ]; if ( newRow.allowSelect && !newRow.disabled ) { return newRow; } } } } return null; } firstColumn() { const that = this; const columns = that.columns; if ( columns && columns.length > 0 ) { return columns[ 0 ]; } return null; } lastColumn() { const that = this; const columns = that.columns; if ( columns && columns.length > 0 ) { return columns[ columns.length - 1 ]; } return null; } nextColumn( dataField ) { const that = this; const columns = that.columns; const column = that.columnByDataField[ dataField ]; const index = columns.indexOf( column ); if ( columns[ index + 1 ] ) { return columns[ index + 1 ]; } return null; } prevColumn( dataField ) { const that = this; const columns = that.columns; const column = that.columnByDataField[ dataField ]; const index = columns.indexOf( column ); if ( columns[ index - 1 ] ) { return columns[ index - 1 ]; } return null; } isVisible( id, dataField ) { const that = this; const vScrollBar = that._scrollView.vScrollBar; const hScrollBar = that._scrollView.hScrollBar; const row = that.rowById[ id ]; const column = that.columnByDataField[ dataField ]; const isRowVisible = ( function ( row ) { if ( !row ) { return false; } const index = row.visibleIndex; if ( index === -1 ) { return false; } if ( row.top + row.height + hScrollBar.offsetHeight + that.__frozenNearHeight >= that._scrollView.scrollTop + that.$.scrollView.offsetHeight - that.__frozenFarHeight ) { return false; } if ( row.top <= that._scrollView.scrollTop ) { return false; } return true; } )( row ); const isColumnVisible = ( function ( column ) { if ( !dataField ) { return false; } const index = column.visibleIndex; if ( index === -1 ) { return false; } if ( column.left + column.computedWidth + vScrollBar.offsetWidth >= that._scrollView.scrollLeft + that._clientSize.width ) { return false; } if ( column.left <= that._scrollView.scrollLeft ) { return false; } return true } )( column ); return { row: isRowVisible, column: isColumnVisible }; } ensureVisible( id, dataField ) { const that = this; const vScrollBar = that._scrollView.vScrollBar; const hScrollBar = that._scrollView.hScrollBar; const row = that.rowById[ id ]; const column = that.columnByDataField[ dataField ]; const ensureRowVisible = function ( row ) { if ( !row ) { return; } const index = row.visibleIndex; if ( index === -1 ) { return; } if ( row.top + row.height + hScrollBar.offsetHeight + that.__frozenNearHeight >= that._scrollView.scrollTop + that.$.scrollView.offsetHeight - that.__frozenFarHeight ) { that._scrollView.scrollTop = row.top + row.height; } if ( row.top <= that._scrollView.scrollTop ) { that._scrollView.scrollTop = row.top; } if ( index === 0 ) { that._scrollView.scrollTop = 0; } else if ( index === that.dataSource.length - 1 ) { that._scrollView.scrollTop = that._scrollView.scrollHeight; } } ensureRowVisible( row ); const ensureColumnVisible = function ( column ) { if ( !dataField ) { return; } const index = column.visibleIndex; if ( index === -1 ) { return; } if ( column.left + column.computedWidth + vScrollBar.offsetWidth >= that._scrollView.scrollLeft + that._clientSize.width ) { that._scrollView.scrollLeft = that._scrollView.scrollLeft + column.computedWidth; } if ( column.left <= that._scrollView.scrollLeft ) { that._scrollView.scrollLeft = column.left; } if ( index === 0 ) { that._scrollView.scrollLeft = 0; } else if ( index === that.columns.length - 1 ) { that._scrollView.scrollLeft = that._scrollView.scrollWidth; } } ensureColumnVisible( column ); } clearSelection() { const that = this; delete that._rangeSelectionStartRow; delete that._rangeSelectionEndRow; that._clearSelection( true ); that.$.fireEvent( 'change', { started: false, finished: true } ); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Edit', class Edit { _renderCommandBar() { const that = this; //const commandBar = that.$.headerCommandBar; const dataSource = that.editing.commandBar.dataSource; const renderCommandBar = ( commandBar ) => { for ( let item in dataSource ) { const properties = dataSource[ item ]; const commandBarItem = document.createElement( 'div' ); commandBarItem.classList.add( 'lw-grid-command-item' ); commandBarItem.label = that.localize( item ); if ( properties.icon ) { commandBarItem.innerHTML = '<span class="lw-grid-icon ' + properties.icon + '"></span>' + '<span class="lw-grid-label">' + commandBarItem.label + '</span>'; } if ( !properties.visible ) { commandBarItem.classList.add( 'lw-hidden' ); } commandBarItem.command = properties.command; commandBarItem.onclick = function () { const command = commandBarItem.command; that._applyCommand( command, [] ); } commandBar.appendChild( commandBarItem ); } } if ( that.editing.enabled && that.editing.commandBar.visible ) { that.$.headerCommandBar.innerHTML = ''; that.$.footerCommandBar.innerHTML = ''; if ( that.editing.commandBar.position !== 'far' ) { renderCommandBar( that.$.headerCommandBar ); } if ( that.editing.commandBar.position !== 'near' ) { renderCommandBar( that.$.footerCommandBar ); } } } commandKeyEditCommand() { const that = this; if ( that._selection && that._selection.focusedCell && that._selection.focusedCell.row ) { const row = that._selection.focusedCell.row; that.beginEdit( row.id ); } } commandKeyCancelCommand() { const that = this; that.cancelEdit(); } commandKeyUpdateCommand() { const that = this; that.endEdit(); } commandColumnMenuCommand() { const that = this; that._openColumnChooserMenu( that._commandColumn ); } commandColumnEditCommand( row ) { const that = this; that.beginEdit( row.id ); } commandColumnUpdateCommand(/*row*/ ) { const that = this; that.endEdit(); } commandColumnRowMenuCommand(/*row*/ ) { //const that = this; } commandColumnCancelCommand( row ) { const that = this; if ( that.editing.batch ) { const rowIndex = that._rowsDeleted ? that._rowsDeleted.indexOf( row ) : -1; if ( rowIndex >= 0 ) { that._rowsDeleted.splice( rowIndex, 1 ); } for ( let i = 0; i < that.columns.length; i++ ) { const dataField = that.columns[ i ].dataField; if ( that._cellsUpdatedValues && that._cellsUpdatedValues[ row.id + '_' + dataField ] ) { delete that._cellsUpdatedValues[ row.id + '_' + dataField ]; that._cellsUpdatedValues.length--; } } that._recycle( false ); } that.cancelEdit(); } commandColumnDeleteCommand( row ) { const that = this; that.deleteRow( row.id ); } _renderAddNewRow() { const that = this; that._frozenNearDefaultRows = []; that._frozenFarDefaultRows = []; const newNearRow = new LW.Grid.Row( {data: {}, index: -1, grid: that, freeze: 'near', visible: that.editing.addNewRow.position !== 'far', autoGenerated: true, addNewRow: true} ); const newFarRow = new LW.Grid.Row( {data: {}, index: -2, grid: that, freeze: 'far', visible: that.editing.addNewRow.position !== 'near', autoGenerated: true, addNewRow: true} ); if ( that._newNearRow ) { const index = that._frozenNearRows.indexOf( that._newNearRow ); if ( index >= 0 ) { that._frozenNearRows.splice( index, 1 ); if ( that.$.rowNearContainer.children.length > 0 ) { const firstChild = that.$.rowNearContainer.children[ 0 ]; firstChild.parentNode.removeChild( firstChild ); } } } if ( that._newFarRow ) { const index = that._frozenFarRows.indexOf( that._newFarRow ); if ( index >= 0 ) { that._frozenFarRows.splice( index, 1 ); if ( that.$.rowFarContainer.children.length > 0 ) { const lastChild = that.$.rowFarContainer.children[ that.$.rowFarContainer.children.length - 1 ]; lastChild.parentNode.removeChild( lastChild ); } } } if ( that.editing.addNewRow.visible ) { that._frozenNearDefaultRows.push( newNearRow ); that._frozenFarDefaultRows.push( newFarRow ); that._frozenNearRows.splice( 0, 0, newNearRow ); that._frozenFarRows.push( newFarRow ); } that._scrollView.vScrollBar.$.farButton.addEventListener( 'click', function () { if ( that.editing.addNewRow.autoCreate ) { if ( that._scrollView.vScrollBar.value === that._scrollView.vScrollBar.max ) { that.addUnboundRow( 1 ); that._scrollView.vScrollBar.value = that._scrollView.vScrollBar.max; } } } ); that._newNearRow = newNearRow; that._newFarRow = newFarRow; if ( that.editing.addNewRow.visible ) { if ( !that._newNearRow.element ) { const row = that._newNearRow; const element = row.createElement(); row.visible = that.editing.addNewRow.position !== 'far'; row.element = element; if ( that.$.rowNearContainer.children.length > 0 ) { that.$.rowNearContainer.insertBefore( element, that.$.rowNearContainer.children[ 0 ] ); } else { that.$.rowNearContainer.appendChild( element ); } } if ( !that._newFarRow.element ) { const row = that._newFarRow; const element = row.createElement(); row.visible = that.editing.addNewRow.position !== 'near'; row.element = element; if ( that.$.rowFarContainer.children.length > 0 ) { that.$.rowFarContainer.insertBefore( element, that.$.rowFarContainer.children[ 0 ] ); } else { that.$.rowFarContainer.appendChild( element ); } } } } _insertNewRowAfter( callback ) { const that = this; return that._insertNewRowBefore( callback, true ); } _insertNewRowBefore( callback, insertAtBottom ) { const that = this; const row = new LW.Grid.Row( {index: insertAtBottom ? 0 : -1, id: LW.Utilities.Core.createGUID(), grid: that} ); const command = function ( row, insertAtBottom ) { if ( that.editing.batch === true || ( that.editing.batch && that.editing.batch.indexOf( 'add' ) >= 0 ) ) { that._batchAddRow( row, insertAtBottom ? that.rows.length : 0 ); } else { row.index = that.rows.length; that._add( row, insertAtBottom ? that.rows.length : 0 ); } if ( insertAtBottom ) { that.scrollTop = that.scrollHeight; } else { that.scrollTop = 0; } if ( !that.editing.addDialog.enabled ) { setTimeout( function () { if ( that.editing.enabled ) { that._beginEdit( row ); } }, 100 ); } if ( callback ) { callback( row ); } }.bind( this ); if ( that.editing.addDialog.enabled ) { that._openAddRowDialog( row, command ); } else { command( row, insertAtBottom ); } return true; } commandBarBatchSaveCommand() { const that = this; that._saveBatchEdit(); } commandBarAddRowCommand() { const that = this; that._insertNewRowAfter(); } commandBarAddTopRowCommand() { const that = this; that._insertNewRowBefore(); } commandBarDeleteRowCommand() { const that = this; let index = 1; let rowToDelete = that.rows[ that.rows.length - index ]; if ( !that._rowsDeleted ) { that._rowsDeleted = []; } while ( that._rowsDeleted.indexOf( that.rows[ that.rows.length - index ] ) >= 0 ) { index++; } rowToDelete = that.rows[ that.rows.length - index ]; if ( rowToDelete ) { that.commandColumnDeleteCommand( rowToDelete ); } } commandBarBatchRevertCommand() { const that = this; that.revertBatchEdit(); } _beginEdit( row, dataField ) { const that = this; if ( !dataField ) { dataField = that.columns[ 0 ].dataField; } const column = that.columnByDataField[ dataField ]; if ( that.editing.allowColumnHeaderEdit && !row && column ) { that._beginColumnEdit( column ); return; } if ( !row || !column || ( column && column.autoGenerated ) ) { return false; } const cell = row.getCell( dataField ); if ( !cell ) { return false; } if ( that.editing.mode === 'cell' ) { that._beginCellEdit( cell ); } else if ( that.editing.mode === 'row' ) { that._beginRowEdit( row, cell ); } that.$.fireEvent( 'beginEdit', { 'row': row, 'column': column, 'cell': cell } ); } _saveUnboundRows( id ) { const that = this; if ( that._unboundRows && that._unboundRows.length > 0 && that.editing.addNewRow.autoSave ) { const row = that.rowById[ id ]; if ( !row.unbound ) { return; } const index = that._unboundRows.indexOf( row ); if ( index < 0 ) { return; } const length = index + 1; that.beginUpdate(); for ( let i = 0; i < length; i++ ) { const row = that._unboundRows[ i ]; if ( !row ) { continue; } delete that.rowById[ row.id ]; row.unbound = false; let requestFocusUpdate = false; if ( that._selection.focusedCell && that._selection.focusedCell.row.id === row.id ) { requestFocusUpdate = true; } if ( that._nearRowsAdded && that._nearRowsAdded.indexOf( row ) >= 0 ) { that._nearRowsAdded.splice( that._nearRowsAdded.indexOf( row ), 1 ); that._add( 0, row.data ); if ( requestFocusUpdate ) { that._selection.focusedCell.row = that.rows[ 0 ]; } } else if ( that._farRowsAdded && that._farRowsAdded.indexOf( row ) >= 0 ) { that._farRowsAdded.splice( that._farRowsAdded.indexOf( row ), 1 ); that._add( row.data ); if ( requestFocusUpdate ) { that._selection.focusedCell.row = that.rows[ that.rows.length - 1 ]; } } } that._unboundRows.splice( 0, length ); that.endUpdate(); } } _endCellEdit( editCell ) { const that = this; const cell = editCell || that.editing.editCell; if ( !cell || ( cell && !cell.isEditing ) ) { return null; } const value = that._getEditorValue( cell ); if ( value === 'invalid value' ) { cell.setAttribute( 'error', '' ); return false; } const commitEditChanges = function () { const id = that._getEditorId( cell ); const editor = that._cellEditors[ id ]; editor.detach(); cell.row.element.removeAttribute( 'edit' ); cell.element.removeAttribute( 'editor' ); cell.element.removeAttribute( 'error' ); cell.isEditing = false; cell.element.content.innerHTML = ''; const refresh = function () { if ( !that.editing.editRow ) { that._recycle( false ); } } const areEqual = function ( value, cellValue ) { if ( cell.column.dataType === 'date' ) { return value.valueOf() === cellValue.valueOf(); } return value === cellValue; } const modifiedValue = that._cellsUpdatedValues ? that._cellsUpdatedValues[ cell.row.id + '_' + cell.column.dataField ] : undefined; const cellValue = modifiedValue !== undefined ? modifiedValue : cell.value; if ( !areEqual( value, cellValue ) ) { const resetEditing = function () { that.editing.editCell = null; if ( !that.editing.editRow ) { that.editing.isEditing = false; } } if ( that.editing.batch === true || ( that.editing.batch && that.editing.batch.indexOf( 'update' ) >= 0 ) ) { resetEditing(); that._batchUpdateCell( cell.row, cell.column, value, cell.value ); refresh(); } else { const updateCellValue = function () { resetEditing(); cell._updating = true; cell.value = value; cell._updating = false; refresh(); } updateCellValue(); } } else { that.editing.editCell = null; if ( !that.editing.editRow ) { that.editing.isEditing = false; refresh(); } } if ( that.editing.commandColumn.visible && !that.editing.commandColumn.width && that.editing.mode === 'cell' ) { that.refresh(); } that.focus(); return true; } if ( that.onCellUpdate ) { that.beginUpdate(); that.appearance.displayLoadingIndicator = true; that._setLoadingIndicatorVisibility(); const overlay = that._createOverlay(); that.$.root.appendChild( overlay ); that.onCellUpdate( cell, that.oldValue, value, function ( confirm ) { if ( confirm ) { commitEditChanges(); } else { that.cancelEdit(); } that.appearance.displayLoadingIndicator = false; that._setLoadingIndicatorVisibility(); overlay.parentNode.removeChild( overlay ); that.endUpdate(); } ); } else { commitEditChanges(); } } _endRowEdit() { const that = this; const row = that.editing.editRow; if ( !row ) { return false; } let canEndEdit = true; const cells = row.cells; let oldValues = {}; let values = {}; for ( let i = 0; i < cells.length; i++ ) { const cell = cells[ i ]; const value = that._getEditorValue( cell ); oldValues[ cell.column.dataField ] = cell.value; values[ cell.column.dataField ] = value; if ( value === 'invalid value' ) { cell.setAttribute( 'error', '' ); canEndEdit = false; } } if ( canEndEdit ) { const commitEditChanges = function () { for ( let i = 0; i < cells.length; i++ ) { const cell = cells[ i ]; that._endCellEdit( cell ); } that.editing.isEditing = false; that.editing.editRow = null; if ( that.editing.commandColumn.visible && !that.editing.commandColumn.width ) { that.refresh(); } else { that._recycle( false ); } } if ( that.onRowUpdate ) { that.beginUpdate(); that.appearance.displayLoadingIndicator = true; that._setLoadingIndicatorVisibility(); const overlay = that._createOverlay(); that.$.root.appendChild( overlay ); that.onRowUpdate( row, oldValues, values, function ( confirm ) { if ( confirm ) { commitEditChanges(); } else { that.cancelEdit(); } that.appearance.displayLoadingIndicator = false; that._setLoadingIndicatorVisibility(); overlay.parentNode.removeChild( overlay ); that.endUpdate(); } ); } else { commitEditChanges(); } return true; } that.focus(); return false; } _batchDeleteRow( row ) { const that = this; if ( !that._rowsDeleted ) { that._rowsDeleted = []; } that._rowsDeleted.push( row ); that._recycle( false ); } _batchAddRow( row, index ) { const that = this; if ( !that._rowsAdded ) { that._rowsAdded = []; } that._rowsAdded.push( row.id ); that.rowById[ row.id ] = row; row.index = that.rows.length + ( that._rowsAdded ? that._rowsAdded.length : 0 ); if ( index === 0 ) { that._nearRowsAdded.splice( 0, 0, row ); } else { that._farRowsAdded.push( row ); } const fullRefresh = that.isInitialized && that._rowElements && that._rowElements.length < that.rows.length + that._rowsAdded.length; if ( fullRefresh ) { that._initializeRowElements(); } that.refresh(); } _batchUpdateCell( row, column, value, originalValue ) { const that = this; if ( !that._cellsUpdatedValues ) { that._cellsUpdatedValues = []; } const areEqual = function ( value, cellValue ) { if ( column.dataType === 'date' ) { return value.valueOf() === cellValue.valueOf(); } return value === cellValue; } if ( areEqual( value, originalValue ) ) { delete that._cellsUpdatedValues[ row.id + '_' + column.dataField ]; } else { that._cellsUpdatedValues[ row.id + '_' + column.dataField ] = value; } that._cellsUpdatedValues.length++; } _saveBatchEdit() { const that = this; for ( let key in that._cellsUpdatedValues ) { const value = that._cellsUpdatedValues[ key ]; const rowId = key.substring( 0, key.indexOf( '_' ) ); const columnDataField = key.substring( key.indexOf( '_' ) + 1 ); const row = that.rowById[ rowId ]; const cell = row.getCell( columnDataField ) cell._updating = true; cell.value = value; cell._updating = false; } const stopUpdates = ( that._rowsDeleted && that._rowsDeleted.length > 0 ) || ( that._rowsAdded && that._rowsAdded.length > 0 ); if ( stopUpdates ) { that.beginUpdate(); } if ( that._rowsAdded && that._rowsAdded.length > 0 ) { for ( let i in that._rowsAdded ) { const id = that._rowsAdded[ i ]; const row = that.rowById[ id ]; if ( !row ) { continue; } if ( that._nearRowsAdded.indexOf( row ) >= 0 ) { that.rows.splice( 0, 0, row ); } else if ( that._farRowsAdded.indexOf( row ) >= 0 ) { that.rows.push( row ); } } } if ( that._rowsDeleted && that._rowsDeleted.length > 0 ) { for ( let i = 0; i < that._rowsDeleted.length; i++ ) { const row = that._rowsDeleted[ i ]; const index = that.rows.indexOf( row ); if ( index < 0 ) { continue; } that.rows.splice( index, 1 ); } } if ( stopUpdates ) { that.endUpdate(); } that._clearBatchEdit( false ); } _clearBatchEdit(/*revertNewRows*/ ) { const that = this; let requiresRefresh = false; if ( that._rowsAdded && that._rowsAdded.length > 0 ) { requiresRefresh = true; } that._cellsUpdatedValues = []; that._rowsAdded = []; that._rowsDeleted = []; that._nearRowsAdded = []; that._farRowsAdded = []; if ( requiresRefresh ) { that.refresh(); } else { that._recycle( false ); } } _getEditorId( cell ) { if ( cell.editor !== cell.column.editor ) { return cell.editor.template + '_' + cell.column.dataField + '_' + cell.row.id; } return cell.editor.template + '_' + cell.column.dataField; } _applyCommand( command, params ) { const that = this; if ( !params ) { params = []; } const onApplyCommand = function () { if ( typeof command === 'function' ) { command.apply( that, params ); } else if ( that[ command ] ) { that[ command ].apply( that, params ); } else if ( LW[ command ] ) { LW[ command ].apply( that, params ); } else if ( window[ command ] ) { window[ command ].apply( that, params ); } } if ( that.onCommand ) { if ( !params ) { params = []; } if ( !params[ 1 ] ) { params[ 1 ] = null; } const args = {name: command, command: onApplyCommand, details: params[ 0 ], event: params[ 1 ], handled: false}; setTimeout( () => { that.onCommand.apply( that, [ args ] ); if ( args.handled ) { return; } onApplyCommand(); }, 200 ); } else { onApplyCommand(); } } _getCommandColumnCommandsTemplate() { const that = this; const dataSource = that.editing.commandColumn.dataSource; const showLabel = that.editing.commandColumn.displayMode !== 'icon'; const showIcon = that.editing.commandColumn.displayMode !== 'label'; let template = ''; for ( let item in dataSource ) { const properties = dataSource[ item ]; let commandColumnItem = '<div'; let isCommandSet = false; if ( item === 'commandColumnMenu' ) { continue; } if ( !isCommandSet ) { commandColumnItem += ' item="' + item + '" command="' + properties.command + '"' + ' class="lw-grid-command-item">'; isCommandSet = true; } const label = properties.label === '{{messages}}' ? that.localize( item ) : properties.label; if ( showIcon && showLabel ) { commandColumnItem += '<span class="lw-grid-icon ' + properties.icon + '"></span>'; commandColumnItem += '<span class="lw-grid-label">' + label + '</span>'; } else if ( showIcon && !showLabel ) { commandColumnItem += '<span class="lw-grid-icon ' + properties.icon + '"></span>'; } else if ( showLabel && !showIcon ) { commandColumnItem += '<span class="lw-grid-label">' + label + '</span>'; } commandColumnItem += '</div>'; template += commandColumnItem; } return template; } _updateCommandColumnCommandsVisibility( element, row ) { const that = this; const commands = element.children; //const commandItems = []; const dataSource = that.editing.commandColumn.dataSource; for ( let i = 0; i < commands.length; i++ ) { const command = commands[ i ]; const item = command.getAttribute( 'item' ); const visible = dataSource[ item ].visible; if ( visible === true ) { command.classList.remove( 'lw-hidden' ); } else if ( visible === false ) { command.classList.add( 'lw-hidden' ); } else if ( visible === 'auto' ) { if ( !that.editing.dialog.enabled && ( that.editing.editRow === row || ( that.editing.editCell && that.editing.editCell.row === row ) ) ) { if ( item === 'commandColumnEdit' ) { command.classList.add( 'lw-hidden' ); } else if ( item === 'commandColumnUpdate' || item === 'commandColumnCancel' ) { commands[ i ].classList.remove( 'lw-hidden' ); } } else { if ( item === 'commandColumnEdit' ) { command.classList.remove( 'lw-hidden' ); } else if ( item === 'commandColumnUpdate' || item === 'commandColumnCancel' ) { commands[ i ].classList.add( 'lw-hidden' ); } } } } } _handleEditKeyDown( event ) { const that = this; const key = event.key; const dataSource = that.editing.commandKeys; if ( that.editing.dialog.enabled ) { return; } for ( let item in dataSource ) { const properties = dataSource[ item ]; const keys = properties.key.replace( / /ig, '' ).split( '|' ); if ( key === 'Tab' && that.editing.editRow ) { continue; } if ( keys.indexOf( key ) >= 0 ) { that._applyCommand( properties.command ); break; } } } _getCustomCellEditor( cell ) { const that = this; cell.editor.selector = cell.editor.template; cell.editor.template = 'custom'; const id = that._getEditorId( cell ); if ( !that._cellEditors[ id ] ) { const element = document.createElement( 'div' ); that._applyCellEditorUserSettings( element, cell ); element.classList.add( 'lw-grid-cell-editor' ); const command = function ( event ) { //let key = event.key; if ( event.type === 'keydown' ) { that._handleEditKeyDown( event ); return; } }; const focus = function () { const element = cell.editor.instance.element.firstElementChild; if ( cell.editor.focus ) { setTimeout( function () { cell.editor.focus.apply( cell.editor.instance.element, [] ); }, 50 ); } else { setTimeout( function () { element.focus(); }, 50 ); } } const blur = function ( event ) { const element = cell.editor.instance.element.firstElementChild; if ( cell.editor.blur ) { cell.editor.blur.apply( cell.editor.instance.element, [ event ] ); } else { element.blur(); } } const setValue = function ( value ) { const element = cell.editor.instance.element.firstElementChild; if ( cell.editor.setValue ) { cell.editor.setValue.apply( cell.editor.instance.element, [ value ] ); } else { if ( element.innerHTML.indexOf( '{{' ) >= 0 ) { const html = element.innerHTML.replace( /{{value}}/ig, value ).replace( /{{id}}/ig, cell.row.id ); element.innerHTML = html; } element.value = value; if ( value instanceof Date ) { element.value = value.toISOString().split( 'T' )[ 0 ]; } cell.editor.instance.element.value = element.value; } } const getValue = function () { const element = cell.editor.instance.element.firstElementChild; if ( cell.editor.getValue ) { const input = element.querySelector( 'input' ); if ( input ) { input.blur(); } return cell.editor.getValue.apply( cell.editor.instance.element, [] ); } const value = element.value; return value || ''; } const detach = function () { element.removeEventListener( 'keydown', command ); if ( cell.editor.detach ) { cell.editor.detach.apply( element, [] ); } } const attach = function () { element.addEventListener( 'keydown', command ); if ( cell.editor.attach ) { cell.editor.attach.apply( element, [] ); } } let template = null; if ( cell.editor.selector.startsWith( '#' ) || cell.editor.selector.startsWith( '.' ) ) { template = document.querySelector( cell.editor.selector ); } if ( template ) { element.appendChild( template.content.cloneNode( true ).firstElementChild ); } else { const htmlToElement = function ( html ) { const template = document.createElement( 'template' ); html = html.trim(); // Never return a text node of whitespace as the result template.innerHTML = html; return template.content.firstChild; } const templateElement = htmlToElement( cell.editor.selector ); if ( templateElement ) { element.appendChild( templateElement ); } } that._cellEditors[ id ] = {element: element, focus: focus, blur: blur, getValue: getValue, setValue: setValue, attach: attach, detach: detach}; } return that._cellEditors[ id ]; } _getTextAreaCellEditor( cell ) { const that = this; const id = that._getEditorId( cell ); const element = document.createElement( 'div' ); const textarea = document.createElement( 'textarea' ); const expander = document.createElement( 'div' ); that._applyCellEditorUserSettings( element, cell ); textarea.style.direction = ''; if ( that.rightToLeft ) { textarea.style.direction = 'rtl'; } textarea.classList.add( 'lw-input' ); element.classList.add( 'lw-grid-cell-editor' ); element.classList.add( 'lw-grid-text-area-cell-editor' ); expander.classList.add( 'nav' ); expander.classList.add( 'lw-icon-resize-full', 'lw-grid-icon' ); const command = function ( event ) { let key = event.key; if ( event.type === 'keydown' ) { that._handleEditKeyDown( event ); if ( event.shiftKey && key === ' ' ) { expander.click(); event.preventDefault(); } return; } }; expander.onclick = function () { const textAreaEditorDialog = document.createElement( 'div' ); const closeButton = document.createElement( 'span' ); const popupTextArea = document.createElement( 'textarea' ); const element = cell.editor.instance.element; const textAreaContainer = document.createElement( 'div' ); const scrollBar = document.createElement( 'lw-scroll-bar' ); scrollBar.orientation = 'vertical'; textAreaEditorDialog.setAttribute( 'theme', that.theme ); textAreaContainer.appendChild( popupTextArea ); textAreaContainer.classList.add( 'lw-grid-text-area-container' ); textAreaContainer.appendChild( scrollBar ); popupTextArea.value = textarea.value; popupTextArea.classList.add( 'lw-input' ); expander.textAreaEditorDialog = textAreaEditorDialog; expander.popupTextArea = popupTextArea; closeButton.classList.add( 'close-button' ); closeButton.classList.add( 'lw-grid-icon' ); closeButton.classList.add( 'lw-icon-cancel-circled' ); //let tempValueLength = 0; const updateScrollBar = function () { scrollBar.value = popupTextArea.scrollTop; scrollBar.max = popupTextArea.scrollHeight - popupTextArea.offsetHeight; scrollBar.onChange = null; if ( popupTextArea.offsetHeight >= popupTextArea.scrollHeight ) { scrollBar.classList.add( 'lw-hidden' ); } else { scrollBar.classList.remove( 'lw-hidden' ); } scrollBar.onChange = function () { popupTextArea.scrollTop = scrollBar.value; } } popupTextArea.onscroll = function (/*event*/ ) { updateScrollBar(); } popupTextArea.onkeydown = function ( event ) { if ( event.key === 'Escape' ) { textAreaEditorDialog.parentNode.removeChild( textAreaEditorDialog ); } if ( event.key === 'Enter' && event.shiftKey ) { closeButton.click(); } //tempValueLength = popupTextArea.value.length; } closeButton.onclick = function () { expander.textAreaEditorDialog.parentNode.removeChild( expander.textAreaEditorDialog ); setTimeout( function () { textarea.value = popupTextArea.value; textarea.select(); }, 50 ); } textAreaEditorDialog.classList.add( 'lw-grid-text-area-dialog' ); textAreaEditorDialog.appendChild( textAreaContainer ); textAreaEditorDialog.appendChild( closeButton ); document.body.appendChild( textAreaEditorDialog ); setTimeout( function () { popupTextArea.select(); updateScrollBar(); }, 50 ); updateScrollBar(); textAreaEditorDialog.style.top = that._offsetTop( element ) + 'px'; textAreaEditorDialog.style.left = that._offsetLeft( element ) + 'px'; textAreaEditorDialog.style.width = element.offsetWidth + 'px'; } element.appendChild( textarea ); element.appendChild( expander ); const getValue = function () { const value = textarea.value; if ( expander.textAreaEditorDialog && expander.textAreaEditorDialog.parentNode ) { textarea.value = expander.popupTextArea.value; return textarea.value; } return value; } const setValue = function ( value ) { textarea.value = value; } const focus = function () { setTimeout( function () { textarea.select(); }, 50 ); } const blur = function () { } const attach = function () { textarea.addEventListener( 'keydown', command ); } const detach = function () { textarea.removeEventListener( 'keydown', command ); if ( expander.textAreaEditorDialog && expander.textAreaEditorDialog.parentNode ) { textarea.value = expander.popupTextArea.value; expander.textAreaEditorDialog.parentNode.removeChild( expander.textAreaEditorDialog ); } } that._cellEditors[ id ] = {element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach}; return that._cellEditors[ id ]; } _getInputCellEditor( cell ) { const that = this; const id = that._getEditorId( cell ); if ( !that._cellEditors[ id ] ) { const element = document.createElement( 'input' ); that._applyCellEditorUserSettings( element, cell ); element.classList.add( 'lw-input' ); element.classList.add( 'lw-grid-cell-editor' ); element.classList.add( 'lw-grid-input-cell-editor' ); element.style.direction = ''; if ( that.rightToLeft ) { element.style.direction = 'rtl'; } const command = function ( event ) { //let key = event.key; if ( event.type === 'keydown' ) { if ( cell.column.dataType === 'number' || cell.column.dataType === 'int' || cell.column.dataType === 'float' ) { if ( !that.editing.editColumn && !event.key.match( /[0-9]/ ) && event.key !== '-' && event.key.length === 1 ) { event.preventDefault(); event.stopPropagation(); return; } } that._handleEditKeyDown( event ); return; } }; const focus = function () { setTimeout( function () { element.select(); }, 50 ); } const blur = function () { } const setValue = function ( value ) { if ( cell.column.rowHeaderColumn && !value ) { element.value = cell.editor.row.visibleIndex + 1; return; } if ( cell.column.dataType === 'number' || cell.column.dataType === 'int' || cell.column.dataType === 'float' ) { if ( value === '' ) { return; } if ( value && !value.toString().match( /[0-9]/ ) && value !== '-' ) { return; } } element.value = value; } const getValue = function () { return element.value; } const detach = function () { element.removeEventListener( 'keydown', command ); } const attach = function () { element.addEventListener( 'keydown', command ); } that._cellEditors[ id ] = {element: element, focus: focus, blur: blur, getValue: getValue, setValue: setValue, attach: attach, detach: detach}; } return that._cellEditors[ id ]; } _applyCellEditorUserSettings( editor, cell ) { //const that = this; for ( let property in cell.editor ) { if ( property === 'template' ) { continue; } if ( property === 'list' ) { editor.setAttribute( property, cell.editor[ property ] ); continue; } editor[ property ] = cell.editor[ property ]; } } _getAutoCompleteCellEditor( cell ) { const that = this; const id = that._getEditorId( cell ); if ( !that._cellEditors[ id ] ) { const element = document.createElement( 'lw-input' ); that._applyCellEditorUserSettings( element, cell ); if ( element.readonly ) { element.dropDownButtonPosition = 'right'; } const command = function ( event ) { //let key = event.key; if ( element.opened ) { return; } if ( event.type === 'keydown' ) { that._handleEditKeyDown( event ); return; } }; element.rightToLeft = that.rightToLeft; element.classList.add( 'lw-grid-cell-editor' ); element.classList.add( 'lw-grid-auto-complete-cell-editor' ); const focus = function () { setTimeout( () => { if ( element && element.select ) { element.select(); } }, 50 ); } const setValue = function ( value ) { element.value = value; } const getValue = function () { return element.value; } const detach = function () { if ( element && element.close ) { element.value = ''; element.close(); element.removeEventListener( 'keydown', command ); } } const blur = function () { } const attach = function () { element.addEventListener( 'keydown', command ); } that._cellEditors[ id ] = {element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach}; } const rows = that.getVisibleRows(); const items = []; for ( let i = 0; i < rows.length; i++ ) { let item = that.dataSource[ rows[ i ].index ]; if ( item ) { item = item[ cell.column.dataField ]; if ( items.indexOf( item ) === -1 ) { items.push( item ); } } } that._cellEditors[ id ].element.dataSource = items; return that._cellEditors[ id ]; } _getDateTimePickerCellEditor( cell ) { const that = this; const id = that._getEditorId( cell ); if ( !that._cellEditors[ id ] ) { const element = document.createElement( 'lw-date-time-picker' ); element.calendarButton = true; element.dropDownAppendTo = 'body'; element.autoClose = true; element.dropDownDisplayMode = 'calendar'; element.rightToLeft = that.rightToLeft; that._applyCellEditorUserSettings( element, cell ); const command = function ( event ) { //let key = event.key; if ( element.opened ) { return; } if ( event.type === 'keydown' ) { that._handleEditKeyDown( event ); return; } }; element.classList.add( 'lw-grid-cell-editor' ); element.classList.add( 'lw-grid-date-time-picker-cell-editor' ); const focus = function () { setTimeout( () => { element.select(); }, 50 ); } const setValue = function ( value ) { element.value = value; } const getValue = function () { return element.value; } const detach = function () { element.value = ''; element.close(); element.removeEventListener( 'keydown', command ); } const blur = function ( event ) { const dropDownId = element.getAttribute( 'aria-controls' ); if ( dropDownId && element.opened ) { const boundingRect = that.getBoundingRect( document.getElementById( dropDownId ) ); if ( !( event.pageX < boundingRect.left || event.pageX > boundingRect.right || event.pageY < boundingRect.top || event.pageY > boundingRect.bottom ) ) { event.preventDefault(); } } } //const cancel = function () { // return false; //} const attach = function () { element.addEventListener( 'keydown', command ); } that._cellEditors[ id ] = {element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach}; } return that._cellEditors[ id ]; } _getNumberInputCellEditor( cell ) { const that = this; const id = that._getEditorId( cell ); if ( !that._cellEditors[ id ] ) { const element = document.createElement( 'div' ); const numberInput = document.createElement( 'input' ); const spinner = document.createElement( 'div' ); const spinnerUp = document.createElement( 'div' ); const spinnerDown = document.createElement( 'div' ); that._applyCellEditorUserSettings( element, cell ); spinnerUp.tabIndex = spinnerDown.tabIndex = -1; numberInput.classList.add( 'lw-input' ); element.classList.add( 'lw-grid-cell-editor' ); element.classList.add( 'lw-grid-number-input-cell-editor' ); spinner.classList.add( 'nav' ); spinnerUp.classList.add( 'up' ); spinnerDown.classList.add( 'down' ); const command = function ( event ) { if ( event.type === 'keydown' ) { that._handleEditKeyDown( event ); return; } }; numberInput.type = 'number'; spinner.appendChild( spinnerUp ); spinner.appendChild( spinnerDown ); element.appendChild( numberInput ); element.appendChild( spinner ); const getValue = function () { const value = parseFloat( numberInput.value ); if ( isNaN( value ) || value === Infinity || value === -Infinity ) { return 0; } return value; } const setValue = function ( value ) { numberInput.value = value; } const focus = function () { setTimeout( function () { numberInput.select(); }, 50 ); } const blur = function () { } const attach = function () { numberInput.addEventListener( 'keydown', command ); spinnerUp.onkeydown = command; spinnerDown.onkeydown = command; spinnerUp.onclick = function () { const oldValue = parseFloat( numberInput.value ); if ( isNaN( oldValue ) ) { return; } if ( oldValue < numberInput.max || numberInput.max === '' ) { numberInput.value = oldValue + 1; } }; spinnerDown.onclick = function () { const oldValue = parseFloat( numberInput.value ); if ( isNaN( oldValue ) ) { return; } if ( oldValue > numberInput.min || numberInput.min === '' ) { numberInput.value = oldValue - 1; } }; } const detach = function () { numberInput.removeEventListener( 'keydown', command ); spinnerUp.onclick = spinnerDown.onclick = null; spinnerUp.onkeydown = spinnerDown.onkeydown = null; } that._cellEditors[ id ] = {element: element, focus: focus, blur: blur, setValue: setValue, getValue: getValue, attach: attach, detach: detach}; } return that._cellEditors[ id ]; } _getCheckBoxCellEditor( cell ) { const that = this; const id = that._getEditorId( cell ); if ( !that._cellEditors[ id ] ) { const element = document.createElement( 'div' ); element.classList.add( 'lw-input' ); element.classList.add( 'lw-grid-cell-editor' ); element.classList.add( 'lw-grid-check-box-cell-editor' ); element.tabIndex = 0; const command = function (/*event*/ ) { if ( element.value !== true && element.value !== false && element.value !== null ) { element.value = false; } if ( element.value === null ) { element.value = false; } else { element.value = !element.value; } if ( false === element.value ) { element.removeAttribute( 'checked' ); } else { element.setAttribute( 'checked', element.value ? '' : 'indeterminate' ); } }; const keyDownHandler = function ( event ) { if ( event.key === ' ' ) { command(); return; } that._handleEditKeyDown( event ); } const setValue = function ( value ) { element.value = value; if ( false === element.value ) { element.removeAttribute( 'checked' ); } else { element.setAttribute( 'checked', element.value ? '' : 'indeterminate' ); } } const focus = function () { element.focus(); setTimeout( function () { element.focus(); }, 25 ); } const getValue = function () { return element.value; } const detach = function () { element.value = false; element.removeEventListener( 'click', command ); element.removeEventListener( 'keydown', keyDownHandler ); } const blur = function () { } const attach = function () { element.addEventListener( 'keydown', keyDownHandler ); element.addEventListener( 'click', command ); } that._cellEditors[ id ] = { getValue: getValue, setValue: setValue, focus: focus, blur: blur, element: element, detach: detach, attach: attach }; } return that._cellEditors[ id ]; } _getEditorValue( cell ) { const that = this; const id = that._getEditorId( cell ); if ( !that._cellEditors ) { return undefined; } const editor = that._cellEditors[ id ]; if ( !editor ) { return undefined; } const parseValue = function ( value ) { switch ( cell.column.dataType ) { case 'float': case 'int': case 'number': value = cell.column.dataType === 'int' ? parseInt( value ) : parseFloat( value ); if ( isNaN( value ) ) { value = 0; } break; case 'bool': case 'boolean': if ( value === 'true' || value === '1' ) { value = true; } if ( value === 'false' || value === '0' ) { value = false; } break; case 'date': value = new LW.Utilities.DateTime( value ); value = value.toDate(); break; case 'dateTime': value = new LW.Utilities.DateTime( value ); break; } return value; } let value = null; switch ( cell.editor.template ) { case 'input': case 'autoComplete': case 'numberInput': case 'deteTimePicker': case 'checkBox': { try { value = parseValue( editor.getValue() ); } catch ( error ) { value = cell.value; } if ( cell.editor.getValue ) { const customValue = cell.editor.getValue( cell, value ); if ( customValue !== undefined ) { value = customValue; } } break; } default: { value = parseValue( editor.getValue() ); } } let isValid = true; if ( cell.column.validator ) { isValid = cell.column.validator.evaluate( value ); } if ( isValid ) { return value; } return 'invalid value'; } _beginRowEdit( row, clickedCell/*, event*/ ) { const that = this; if ( row === that.editing.editRow ) { return false; } if ( that.editing.editRow ) { const canEndEdit = that.endEdit(); if ( !canEndEdit ) { return false; } } const cells = row.cells; that.editing.editRow = row; if ( that.editing.commandColumn.visible ) { that.editing.isEditing = false; that.refresh(); that.editing.isEditing = true; } row.isEditing = true; let isFirstCell = false; for ( let i = 0; i < cells.length; i++ ) { const cell = cells[ i ]; const result = that._beginCellEdit( cell ); if ( !clickedCell ) { if ( result && !isFirstCell ) { isFirstCell = true; cell.editor.instance.focus(); } } else if ( cell === clickedCell ) { cell.editor.instance.focus(); } if ( that.editing.commandColumn.visible && cell.column.commandColumn ) { cell.render(); } } return true; } _createOverlay() { const overlay = document.createElement( 'div' ); overlay.onpointerdown = function () { return false; } overlay.onmousedown = function () { return false; } overlay.onclick = function () { return; } overlay.classList.add( 'lw-grid-dialog-overlay' ); return overlay; } _createDialog( options ) { const that = this; const dialog = document.createElement( 'div' ); if ( !options ) { options = that.editing.dialog; } dialog.setAttribute( 'animation', 'none' ); dialog.classList.add( 'lw-window', 'lw-grid-dialog' ); dialog.style.width = options.width === 'auto' ? options.width : options.width + 'px'; dialog.style.height = options.height === 'auto' ? options.height : options.height + 'px'; dialog.style.left = ''; dialog.style.top = ''; dialog.innerHTML = `<div class="lw-container"> <div class ="lw-content-container" lw-id="container"> <div id="headerSection" class="lw-header-section"> <div class="lw-header"></div> <div class="lw-buttons-container"> <button class ="lw-button lw-element lw-close-button" aria-label="Close" lw-id="closeButton"></button> </div> </div> <div class="lw-content"><div></div></div> <div class ="lw-footer"> <div class ="lw-stack-layout right spacing"> <lw-button class ="lw-confirm-button item primary">Ok</lw-button> <lw-button class ="lw-cancel-button item">Cancel</lw-button> </div> </div> </div> </div> `; dialog.content = dialog.querySelector( '.lw-content' ).firstChild; dialog.footer = dialog.querySelector( '.lw-footer' ); dialog.header = dialog.querySelector( '.lw-header' ); dialog.btnConfirm = dialog.querySelector( '.lw-confirm-button' ); dialog.btnCancel = dialog.querySelector( '.lw-cancel-button' ); dialog.btnClose = dialog.querySelector( '.lw-close-button' ); const overlay = document.createElement( 'div' ); overlay.classList.add( 'lw-grid-dialog-overlay' ); overlay.onclick = function () { return; } dialog.overlay = overlay; dialog.remove = function () { if ( dialog.parentNode ) { dialog.parentNode.removeChild( dialog ); } }; dialog.close = function () { dialog.classList.remove( 'open' ); dialog.addEventListener( 'transitionend', dialog.remove ); dialog.addEventListener( 'transitioncancel', dialog.remove ); if ( dialog.modal ) { if ( dialog.overlay.parentNode ) { dialog.overlay.parentNode.removeChild( dialog.overlay ); } } if ( dialog.onClose ) { dialog.onClose(); } } dialog.open = function ( left, top ) { dialog.removeEventListener( 'transitionend', dialog.remove ); dialog.removeEventListener( 'transitioncancel', dialog.remove ); document.body.appendChild( dialog ); if ( !left ) { left = options.left; } if ( !top ) { top = options.top; } requestAnimationFrame( function () { dialog.classList.add( 'open' ); const positionFromString = function ( position, alignment ) { const offset = that.offset( that ); if ( position === 'center' && alignment === 'horizontal' ) { position = 'middle'; } switch ( position ) { case 'top': return offset.top; case 'bottom': return offset.top + that.offsetHeight - dialog.offsetHeight; case 'center': return offset.top + that.offsetHeight / 2 - dialog.offsetHeight / 2; case 'left': return offset.left; case 'middle': return offset.left + that.offsetWidth / 2 - dialog.offsetWidth / 2; case 'right': return offset.left + that.offsetWidth - dialog.offsetWidth; } if ( alignment === 'horizontal' ) { return parseInt( position ) + offset.left; } if ( alignment === 'vertical' ) { return parseInt( position ) + offset.top; } if ( typeof position === 'number' ) { return position; } return parseInt( position ); } dialog.style.left = positionFromString( left, 'horizontal' ) + 'px'; dialog.style.top = positionFromString( top, 'vertical' ) + 'px'; } ); if ( dialog.modal ) { that.appendChild( dialog.overlay ); } if ( dialog.onOpen ) { dialog.onOpen(); } } return dialog; } _openAddRowDialog( row, command ) { const that = this; if ( !that.editing.addDialog.enabled ) { return false; } const dialog = that._dialogAddRow || that._createDialog(); const header = that.editing.dialog.header === '{{message}}' ? that.localize( 'dialogAddHeader' ) : that.editing.dialog.header; const content = dialog.content; dialog.header.innerHTML = header; row.grid = that; if ( undefined === row.index ) { row.index = that.rows.length; if ( that._rowsAdded ) { row.index += that._rowsAdded.length; } } const cells = row.cells; let layoutRow = null; let layoutRowIndex = 0; if ( !that._cellEditors ) { that._cellEditors = []; } if ( !that._dialogAddRow ) { dialog.modal = true; dialog.btnConfirm.innerHTML = that.localize( 'dialogAddButtonConfirm' ); dialog.btnCancel.innerHTML = that.localize( 'dialogAddButtonCancel' ); dialog.onOpen = function () { that.editing.dialog.visible = true; } dialog.onClose = function () { that.editing.dialog.visible = false; } dialog.btnCancel.onclick = function () { dialog.close(); } dialog.btnClose.onclick = function () { dialog.close(); } dialog.btnConfirm.onclick = function () { const data = { }; for ( let i = 0; i < cells.length; i++ ) { const cell = cells[ i ]; const value = that._getEditorValue( cell ); const id = that._getEditorId( cell ); const editor = that._cellEditors[ id ]; data[ cell.column.dataField ] = value; editor.detach(); } const index = that._rowsAdded ? that._rowsAdded.length : 0; const row = new LW.Grid.Row( {index: that.rows.length + index, grid: that, data: data} ); dialog.close(); command( row, dialog.index === 0 ? true : false ); } dialog.onkeydown = function ( event ) { const key = event.key; if ( key === 'Enter' ) { dialog.btnConfirm.onclick(); } else if ( key === 'Escape' ) { dialog.close(); } } content.classList.add( 'lw-grid-layout' ); for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; if ( !column.allowEdit ) { continue; } if ( layoutRowIndex % 2 === 0 ) { layoutRow = document.createElement( 'div' ); layoutRow.classList.add( 'row' ); content.appendChild( layoutRow ); } const col = document.createElement( 'div' ); col.classList.add( 'col-sm-6' ); const stack = document.createElement( 'div' ); stack.classList.add( 'column' ); const label = document.createElement( 'label' ); label.innerHTML = that.columns[ i ].label; const fieldEditor = document.createElement( 'div' ); fieldEditor.classList.add( 'lw-grid-dialog-editor' ) fieldEditor.setAttribute( 'editor', column.dataField ); fieldEditor.setAttribute( 'template', column.editor.template ); col.appendChild( stack ); layoutRow.appendChild( col ); stack.appendChild( label ); stack.appendChild( fieldEditor ); layoutRowIndex++; } } dialog.open(); dialog.index = row.index; for ( let i = 0; i < cells.length; i++ ) { const cell = cells[ i ]; const column = cell.column; const dataField = column.dataField; const fieldEditor = dialog.querySelector( '[editor=' + dataField + ']' ); fieldEditor.innerHTML = ''; let cellValue = ''; if ( cell.value !== undefined ) { cellValue = cell.value; } else { if ( column.dataType === 'int64' || column.dataType === 'number' || column.dataType === 'int' || column.dataType === 'float' ) { cellValue = 0; } if ( column.dataType === 'date' ) { cellValue = new Date(); } if ( column.dataType === 'bool' || column.dataType === 'boolean' ) { cellValue = false; } } let editor = null; switch ( cell.editor.template ) { default: case 'custom': { editor = that._getCustomCellEditor( cell ); break; } case 'checkBox': { editor = that._getCheckBoxCellEditor( cell ); break; } case 'autoComplete': { editor = that._getAutoCompleteCellEditor( cell ); break; } case 'dateTimePicker': editor = that._getDateTimePickerCellEditor( cell ); break; case 'textArea': case 'textarea': { editor = that._getTextAreaCellEditor( cell ); break; } case 'numberInput': case 'input': { editor = cell.editor.template === 'numberInput' ? that._getNumberInputCellEditor( cell ) : that._getInputCellEditor( cell ); break; } } editor.attach(); cell.editor.instance = editor; editor.setValue( cellValue ); if ( i === 0 ) { editor.focus(); } if ( !cell.editor.isInitialized ) { cell.editor.isInitialized = true; if ( cell.editor.onInit ) { cell.editor.onInit( cell.row.index, cell.column.dataField, cell.editor.instance.element ); } } if ( cell.editor.onRender ) { cell.editor.onRender( cell.row.index, cell.column.dataField, cell.editor.instance.element ); } fieldEditor.appendChild( editor.element ); } that._dialogAddRow = dialog; } _openEditDialog( cell, editor ) { const that = this; if ( !that.editing.dialog.enabled ) { return false; } const dialog = that._dialogEdit || that._createDialog(); const header = that.editing.dialog.header === '{{message}}' ? that.localize( 'dialogEditHeader', {value: that.editing.editRow ? ( cell.row.visibleIndex + 1 ) : cell.column.label} ) : that.editing.dialog.header; const content = dialog.content; dialog.header.innerHTML = header; let row = null; let layoutRowIndex = 0; if ( !that._dialogEdit ) { dialog.modal = true; dialog.btnConfirm.innerHTML = that.localize( 'dialogEditButtonConfirm' ); dialog.btnCancel.innerHTML = that.localize( 'dialogEditButtonCancel' ); dialog.onOpen = function () { that.editing.dialog.visible = true; } dialog.onClose = function () { that.editing.dialog.visible = false; } dialog.btnCancel.onclick = function () { that.cancelEdit(); } dialog.btnClose.onclick = function () { that.cancelEdit(); } dialog.btnConfirm.onclick = function () { that.endEdit(); } dialog.onkeydown = function ( event ) { const key = event.key; const dataSource = that.editing.commandKeys; for ( let item in dataSource ) { const properties = dataSource[ item ]; if ( key === properties.key ) { that._applyCommand( properties.command ); break; } } } if ( that.editing.editRow ) { content.classList.add( 'lw-grid-layout' ); for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; if ( !column.allowEdit ) { continue; } if ( layoutRowIndex % 2 === 0 ) { row = document.createElement( 'div' ); row.classList.add( 'row' ); content.appendChild( row ); } const col = document.createElement( 'div' ); col.classList.add( 'col-sm-6' ); const stack = document.createElement( 'div' ); stack.classList.add( 'column' ); const label = document.createElement( 'label' ); label.innerHTML = that.columns[ i ].label; const fieldEditor = document.createElement( 'div' ); fieldEditor.classList.add( 'lw-grid-dialog-editor' ) fieldEditor.setAttribute( 'editor', column.dataField ); fieldEditor.setAttribute( 'template', column.editor.template ); col.appendChild( stack ); row.appendChild( col ); stack.appendChild( label ); stack.appendChild( fieldEditor ); layoutRowIndex++; } } else { const column = cell.column; const fieldEditor = document.createElement( 'div' ); fieldEditor.classList.add( 'lw-grid-dialog-editor' ) fieldEditor.setAttribute( 'editor', '' ); fieldEditor.setAttribute( 'template', column.editor.template ); content.appendChild( fieldEditor ); } } dialog.open(); if ( that.editing.editRow ) { const fieldEditor = dialog.querySelector( '[editor=' + cell.column.dataField + ']' ); fieldEditor.innerHTML = ''; fieldEditor.appendChild( editor.element ); } else { const column = cell.column; const fieldEditor = dialog.querySelector( '[editor]' ); fieldEditor.innerHTML = ''; fieldEditor.setAttribute( 'template', column.editor.template ); fieldEditor.appendChild( editor.element ); } that._dialogEdit = dialog; } _openDeleteRowDialog( row, command ) { const that = this; if ( !that.editing.deleteDialog.enabled ) { return false; } const dialog = that._dialogDelete || that._createDialog(); const header = that.editing.dialog.header === '{{message}}' ? that.localize( 'dialogDeleteHeader', {value: row.visibleIndex + 1} ) : that.editing.dialog.header; //const content = dialog.content; dialog.header.innerHTML = header; dialog.content.innerHTML = that.localize( 'dialogDeleteContent' ); dialog.row = row; if ( !that._dialogDelete ) { dialog.modal = true; dialog.btnConfirm.innerHTML = that.localize( 'dialogDeleteButtonConfirm' ); dialog.btnCancel.innerHTML = that.localize( 'dialogDeleteButtonCancel' ); dialog.onOpen = function () { that.editing.dialog.visible = true; } dialog.onClose = function () { that.editing.dialog.visible = false; } dialog.btnCancel.onclick = function () { dialog.close(); } dialog.btnClose.onclick = function () { dialog.close(); } dialog.btnConfirm.onclick = function () { command( dialog.row ); dialog.close(); } dialog.onkeydown = function ( event ) { if ( event.key === 'Escape' ) { dialog.close(); } } that._dialogDelete = dialog; } dialog.open(); setTimeout( function () { dialog.btnConfirm.focus(); }, 100 ); } _beginCellEdit( cell, event ) { const that = this; if ( cell.isEditing ) { return false; } if ( that._isUpdating ) { return false; } let allowRowHeaderEdit = false; if ( cell.column.autoGenerated && cell.column.rowHeaderColumn && that.editing.allowRowHeaderEdit ) { if ( new Date() - that._clickTime < that.behavior.doubleClickTimingDelay ) { if ( that._clickedCell === cell.element ) { allowRowHeaderEdit = true; } } } if ( !( cell.column.allowEdit && !cell.column.autoGenerated && !cell.readonly ) && !allowRowHeaderEdit ) { return false; } if ( that.editing.editCell && !that.editing.editRow ) { const successfulEdit = that._endCellEdit(); if ( false === successfulEdit ) { return false; } } if ( !that._cellEditors ) { that._cellEditors = []; } if ( !that.editing.editRow ) { that.editing.editCell = cell; } if ( that.editing.commandColumn.visible && !that.editing.editRow ) { that.editing.isEditing = false; that.refresh(); that.editing.isEditing = true; } cell.row.element.setAttribute( 'edit', '' ); that.editing.isEditing = true; if ( that._selection.selectionRect ) { that._selection.selectionRect.classList.add( 'lw-visibility-hidden' ); } const appendEditor = ( editor ) => { const element = editor.element; if ( that.editing.dialog.enabled ) { that._openEditDialog( cell, editor ); } else { if ( !cell.element ) { cell.createElement(); } cell.element.setAttribute( 'editor', typeof cell.editor.template === 'string' ? cell.editor.template : 'template' ); cell.element.content.innerHTML = ''; cell.element.content.appendChild( element ); if ( that.editing.editRow ) { cell.element.setAttribute( 'row-editor', '' ); } } editor.attach(); cell.editor.row = cell.row; cell.editor.column = cell.column; cell.editor.cell = cell; cell.editor.instance = editor; cell.isEditing = true; } const modifiedValue = that._cellsUpdatedValues ? that._cellsUpdatedValues[ cell.row.id + '_' + cell.column.dataField ] : undefined; let cellValue = modifiedValue !== undefined ? modifiedValue : cell.value; if ( cellValue === undefined ) { cellValue = ''; const column = cell.column; if ( column.dataType === 'number' || column.dataType === 'int' || column.dataType === 'float' ) { cellValue = 0; } else if ( column.dataType === 'date' ) { cellValue = new Date(); cellValue.setTime( 0, 0, 0 ); } } if ( !cell.editor ) { cell.editor = 'input'; } if ( typeof cell.editor === 'string' ) { cell.canNotify = false; cell.editor = { template: cell.editor, autoFocus: true } cell.canNotify = true; } switch ( cell.editor.template ) { default: case 'custom': { const editor = that._getCustomCellEditor( cell ); appendEditor( editor ); editor.setValue( cellValue ); break; } case 'checkBox': { const editor = that._getCheckBoxCellEditor( cell ); appendEditor( editor ); const value = cellValue === true || cellValue === 1 ? true : false; if ( cell.template === 'checkBox' && event ) { const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); if ( elements[ 0 ].classList.contains( 'lw-input' ) ) { editor.setValue( !value ); } else { editor.setValue( value ); } } else { editor.setValue( value ); } break; } case 'autoComplete': { const editor = that._getAutoCompleteCellEditor( cell ); appendEditor( editor ); editor.setValue( cellValue ); if ( cell.editor.autoOpen ) { editor.element.open(); } break; } case 'dateTimePicker': { const editor = that._getDateTimePickerCellEditor( cell ); appendEditor( editor ); editor.setValue( cellValue ); if ( cell.editor.autoOpen ) { editor.element.open(); } break; } case 'textArea': { const editor = that._getTextAreaCellEditor( cell ); appendEditor( editor ); editor.setValue( cellValue ); break; } case 'numberInput': case 'input': { const editor = cell.editor.template === 'numberInput' ? that._getNumberInputCellEditor( cell ) : that._getInputCellEditor( cell ); appendEditor( editor ); editor.setValue( cellValue ); break; } } if ( !cell.editor.isInitialized ) { cell.editor.isInitialized = true; if ( cell.editor.onInit ) { cell.editor.onInit( cell.row.index, cell.column.dataField, cell.editor.instance.element ); } } if ( cell.editor.onRender ) { cell.editor.onRender( cell.row.index, cell.column.dataField, cell.editor.instance.element ); } if ( that.editing.editCell ) { cell.editor.instance.focus(); } return true; } _onColumnDoubleClick( column/*, event*/ ) { const that = this; that._beginColumnEdit( column ); } _beginColumnEdit( column ) { const that = this; if ( that.editing.enabled && that.editing.allowColumnHeaderEdit && column.allowHeaderEdit ) { if ( that.editing.isEditing ) { that.endEdit(); } that.editing.editColumn = column; if ( !that._cellEditors ) { that._cellEditors = []; } const inputEditor = that._getInputCellEditor( {column: column, row: that.rows[ 0 ], editor: {template: 'input'}} ); //const children = column.element.children; inputEditor.element.value = column.label; inputEditor.focus(); column.headerEditor = inputEditor; column.element.setAttribute( 'edit', '' ); column.element.label.appendChild( inputEditor.element ); inputEditor.attach(); that.editing.isEditing = true; that.$.fireEvent( 'beginEdit', { 'row': null, 'column': column, 'cell': null } ); } } _endColumnEdit( cancelChanges ) { const that = this; if ( false === that.editing.isEditing || ( that.editing.isEditing && that.editing.editColumn === null ) ) { return false; } const column = that.editing.editColumn; column.canNotify = false; column.headerEditor.detach(); column.headerEditor.element.parentNode.removeChild( column.headerEditor.element ); if ( cancelChanges !== true ) { column.label = column.headerEditor.getValue(); } column.headerEditor = null; that.editing.isEditing = false; column.element.removeAttribute( 'edit' ); column.element.scrollLeft = 0; that.editing.editColumn = null; column.canNotify = true; column.refresh(); that._recycle(); return true; } _cancelColumnEdit() { const that = this; that._endColumnEdit( true ); } _onCellClick( cell, event ) { const that = this; if ( cell.row.addNewRow ) { if ( cell.row.freeze === 'far' ) { that._insertNewRowAfter(); } else { that._insertNewRowBefore(); } return; } if ( !that.editing.enabled ) { return; } if ( that.editing.editColumn ) { that.endEdit(); return; } if ( that.editing.commandColumn.visible ) { if ( cell.column.commandColumn ) { const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); let commandItem = null; for ( let i = 0; i < elements.length; i++ ) { if ( elements[ i ].classList.contains( 'lw-grid-command-item' ) ) { commandItem = elements[ i ]; break; } } if ( !commandItem ) { commandItem = cell.element.querySelector( '.lw-grid-command-item' ); } if ( commandItem && !commandItem.classList.contains( 'lw-hidden' ) ) { const command = commandItem.getAttribute( 'command' ); that._applyCommand( command, [ cell.row, event ] ); return; } } else if ( that.editing.commandColumn.inline ) { const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.pageX, event.pageY ); for ( let i = 0; i < elements.length; i++ ) { if ( elements[ i ].classList.contains( 'lw-grid-command-item' ) ) { return; } } } } if ( that.editing.action === 'none' && that.editing.isEditing ) { let canEndEdit = false; if ( that.editing.editCell && that.editing.editCell.row !== cell.row ) { canEndEdit = true; } if ( that.editing.editRow && that.editing.editRow !== cell.row ) { canEndEdit = true; } if ( that.editing.editColumn ) { canEndEdit = true; } if ( canEndEdit ) { that.endEdit(); } } if ( cell.column.autoGenerated ) { if ( that.editing.allowRowHeaderEdit && cell.column.rowHeaderColumn ) { if ( that.editing.isEditing ) { that.endEdit(); } that._beginCellEdit( cell, event ); } return; } if ( that.editing.action !== 'click' ) { return; } if ( that.selection.enabled && !cell.selected && that.selection.mode === 'extended' ) { return; } if ( that.editing.mode === 'cell' ) { const parentCell = cell.parent(); that.ensureVisible( cell.row.id, cell.column.dataField ); setTimeout( function () { if ( parentCell ) { that._beginCellEdit( parentCell, event ); } else { that._beginCellEdit( cell, event ); } }, 25 ); } else if ( that.editing.mode === 'row' ) { that._beginRowEdit( cell.row, cell, event ); } } _onCellDoubleClick( cell, event ) { const that = this; if ( !that.editing.enabled ) { return; } if ( that.editing.action !== 'doubleClick' || that.editing.isEditing ) { return; } if ( cell.column.autoGenerated ) { return; } if ( that.editing.mode === 'cell' ) { that._beginCellEdit( cell, event ); } else if ( that.editing.mode === 'row' ) { that._beginRowEdit( cell.row, cell, event ); } } _onRowClick(/*index, row, event*/ ) { //const that = this; } _onRowDoubleClick(/*index, row, event*/ ) { //const that = this; } /* Public API */ beginEdit( id, dataField ) { const that = this; const row = that.rowById[ id ]; if ( row ) { that._beginEdit( row, dataField ); } } cancelEdit() { const that = this; if ( that.editing.editRow ) { const cells = that.editing.editRow.cells; for ( let i = 0; i < cells.length; i++ ) { const cell = cells[ i ]; const element = cell.element; if ( i === 0 ) { cell.row.element.removeAttribute( 'edit' ); } if ( element ) { element.removeAttribute( 'editor' ); element.removeAttribute( 'error' ); element.content.innerHTML = ''; } cell.isEditing = false; } that.editing.editRow = null; } else if ( that.editing.editCell ) { that.editing.editCell.row.element.removeAttribute( 'edit' ); that.editing.editCell.element.removeAttribute( 'editor' ); that.editing.editCell.element.removeAttribute( 'error' ); that.editing.editCell.element.content.innerHTML = ''; that.editing.editCell.isEditing = false; that.editing.editCell = null; } else if ( that.editing.editColumn ) { that._cancelColumnEdit(); } if ( that.editing.dialog.visible && that.editing.dialog.enabled ) { that._dialogEdit.close(); } that.editing.isEditing = false; that._recycle( false ); if ( that.editing.commandColumn.visible ) { that.refresh(); } that.focus(); } deleteRow( id, callback ) { const that = this; const row = that.rowById[ id ]; if ( !row ) { return false; } const command = function ( row ) { if ( that.editing.batch === true || ( that.editing.batch && that.editing.batch.indexOf( 'delete' ) >= 0 ) ) { that._batchDeleteRow( row ); } else { const index = that.rows.indexOf( row ); that.rows.splice( index, 1 ); } if ( callback ) { callback( row ); } } if ( that.editing.deleteDialog.enabled ) { that._openDeleteRowDialog( row, command ); } else { command( row ); } return true; } addUnboundRow( count, position ) { const that = this; if ( undefined === count ) { count = 1; } if ( undefined === position ) { position = 'far'; } if ( !that._nearRowsAdded ) { that._nearRowsAdded = []; that._farRowsAdded = []; } if ( !that._unboundRows ) { that._unboundRows = []; } that.beginUpdate(); for ( let i = 0; i < count; i++ ) { const id = LW.Utilities.Core.createGUID().replace( /-/ig, '' ); const row = new LW.Grid.Row( {index: -1, unbound: true, id: id, grid: that} ); that.rowById[ row.id ] = row; if ( position === 'far' ) { that._farRowsAdded.push( row ); } else { that._nearRowsAdded.push( row ); } that._unboundRows.push( row ); } that.endUpdate(); } addNewRow( position ) { const that = this; if ( position === 'near' ) { that._insertNewRowBefore(); } else { that._insertNewRowAfter(); } } endEdit() { const that = this; let result = false; let id = null; if ( that.editing.dialog.enabled && that.editing.dialog.visible ) { if ( that._dialogEdit ) { that._dialogEdit.close(); } } let cell = null; let row = null; let column = null; if ( that.editing.editRow ) { row = that.editing.editRow; id = that.editing.editRow.id; result = that._endRowEdit(); } else if ( that.editing.editCell ) { row = that.editing.editCell.row; column = that.editing.editCell.column; cell = that.editing.editCell; id = that.editing.editCell.row.id; result = that._endCellEdit(); } else if ( that.editing.editColumn ) { id = null; column = that.editing.editColumn; result = that._endColumnEdit(); } that._saveUnboundRows( id ); if ( that._selection.selectionRect ) { that._selection.selectionRect.classList.remove( 'lw-visibility-hidden' ); } that.$.scrollView.scrollTop = 0; that.$.fireEvent( 'endEdit', { row: row, column: column, cell: cell } ); return result; } getBatchEditChanges() { const that = this; const updatedCells = []; const deletedRows = []; const addedRows = []; for ( let key in that._cellsUpdatedValues ) { const value = that._cellsUpdatedValues[ key ]; const rowId = key.substring( 0, key.indexOf( '_' ) ); const columnDataField = key.substring( key.indexOf( '_' ) + 1 ); const row = that.rowById[ rowId ]; const cell = row.getCell( columnDataField ); updatedCells.push( {id: rowId, dataField: columnDataField, oldValue: cell.value, newValue: value} ); } if ( that._rowsDeleted && that._rowsDeleted.length > 0 ) { for ( let i = 0; i < that._rowsDeleted.length; i++ ) { const row = that._rowsDeleted[ i ]; deletedRows.push( {id: row.id, data: row} ); } } if ( that._rowsAdded && that._rowsAdded.length > 0 ) { for ( let i = 0; i < that._rowsAdded.length; i++ ) { const row = that._rowsAdded[ i ]; addedRows.push( {id: row.id, data: row} ); } } return { updated: updatedCells, deleted: deletedRows, added: addedRows }; } saveBatchEdit() { const that = this; that._saveBatchEdit(); } revertBatchEdit() { const that = this; that._clearBatchEdit( true ); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign( 'Grid.Tree', class Tree { _setRowProperty( id, propertyName, value ) { const that = this; const row = that.rowById[ id ]; if ( !row ) { return; } row[ propertyName ] = value; } _setRowsProperty( propertyName, value, ids ) { const that = this; that._refreshRowHierarchy( true ); that._refreshLayout(); const rows = that._recyclingRows; that.rows.canNotify = false; for ( let i = 0; i < rows.length; i++ ) { const row = rows[ i ]; if ( ids ) { if ( ids.indexOf( row.id ) === -1 ) { continue; } } row[ propertyName ] = value; } that.rows.canNotify = true; that.refresh(); } _applyThreeStates( row ) { const that = this, branch = row !== that.rowHierarchy, children = branch ? row.children : that.rowHierarchy.filter( ( row ) => { if ( row.level === 0 ) return row; } ); let checkedChildren = 0, indeterminateChildren = 0; for ( let i = 0; i < children.length; i++ ) { const currentChild = children[ i ]; if ( row.checked ) { currentChild.checked = true; } if ( currentChild.leaf === false ) { that._applyThreeStates( currentChild ); } if ( branch ) { if ( currentChild.checked ) { checkedChildren++; } else if ( currentChild.checked === null ) { indeterminateChildren++; } } } if ( !branch ) { return; } if ( checkedChildren === row.children.length ) { row.checked = true; } else if ( checkedChildren === 0 && indeterminateChildren === 0 ) { row.checked = false; } else if ( that.checkBoxes.hasThreeStates ) { row.checked = null; } else { row.checked = false; } } _hasThreeStates( row, callerRow ) { function checkUncheckChildren( row, check ) { const children = row.children; for ( let i = 0; i < children.length; i++ ) { const currentChild = children[ i ]; currentChild.checked = check; if ( currentChild.leaf === false ) { checkUncheckChildren( currentChild, check ); } } } const that = this; let currentRow = row; if ( row !== callerRow ) { if ( row.checked ) { row.checked = false; } else { row.checked = true; } } while ( currentRow.parent ) { const parent = currentRow.parent, children = parent.children; let checkedChildren = 0, indeterminateChildren = 0; for ( let i = 0; i < children.length; i++ ) { if ( children[ i ].checked ) { checkedChildren++; } else if ( that.checkBoxes.hasThreeStates && children[ i ].checked === null ) { indeterminateChildren++; } } if ( checkedChildren === parent.children.length ) { parent.checked = true; } else if ( checkedChildren === 0 && indeterminateChildren === 0 ) { parent.checked = false; } else if ( that.checkBoxes.hasThreeStates ) { parent.checked = null; } else { parent.checked = false; } currentRow = parent; } if ( !row.leaf ) { checkUncheckChildren( row, row.checked ); } } /* Public API */ expandRow( id ) { const that = this; if ( id && Array.isArray( id ) ) { that._setRowsProperty( 'expanded', true, id ); return; } that._setRowProperty( id, 'expanded', true ); } expandAllRows() { const that = this; that._setRowsProperty( 'expanded', true ); } collapseAllRows() { const that = this; that._setRowsProperty( 'expanded', false ); } toggleRow( id ) { const that = this; const row = that.rowById[ id ]; if ( !row ) { return; } if ( row.expanded ) { row.expanded = false; } else { row.expanded = true; } } collapseRow( id ) { const that = this; if ( id && Array.isArray( id ) ) { that._setRowsProperty( 'expanded', false, id ); return; } that._setRowProperty( id, 'expanded', false ); } checkRow( id ) { const that = this; if ( id && Array.isArray( id ) ) { that._setRowsProperty( 'checked', true, id ); return; } that._setRowProperty( id, 'checked', true ); } uncheckRow( id ) { const that = this; if ( id && Array.isArray( id ) ) { that._setRowsProperty( 'checked', false, id ); return; } that._setRowProperty( id, 'checked', false ); } checkAllRows() { const that = this; that._setRowsProperty( 'checked', true ); } uncheckAllRows() { const that = this; that._setRowsProperty( 'checked', false ); } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('Grid.Export', class Export { exportData(dataFormat, callback) { const that = this; const dataExporter = new LW.Utilities.DataExporter({ exportHeader: that.dataExport.header }); const formattedRows = []; dataExporter.expandChar = that.dataExport.expandChar; dataExporter.collapseChar = that.dataExport.collapseChar; dataExporter.pageOrientation = that.dataExport.pageOrientation; dataExporter.style = that.dataExport.style; dataExporter.filterBy = that.dataExport.filterBy; dataExporter.groupBy = that.dataExport.groupBy; dataExporter.header = { columns: that.columns.toArray().slice(0), columngroups: that.columnGroups.slice(0) }; if (!that.dataExport.style) { const computedStyle = window.getComputedStyle(that); const columnComputedStyle = window.getComputedStyle(that.columns.length > 0 && that.columns[0].element ? that.columns[0].element : that.$.columnHeader); const headerComputedStyle = window.getComputedStyle(that.$.columnHeader); const isHidden = that.offsetWidth === 0 || that.offsetHeight === 0; if (!isHidden) { const getStyle = (computedStyle) => { const fontFamily = 'Helvetica'; const fontSize = computedStyle.fontSize; const borderColor = computedStyle.borderRightColor; const backgroundColor = computedStyle.backgroundColor; const color = computedStyle.color; const hexDigits = new Array ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'); //Function to convert rgb color to hex format function toHex(rgb) { rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/); if (!rgb) { return '#ffffff'; } return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]).toUpperCase(); } function hex(x) { return isNaN(x) ? '00' : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16]; } return { borderColor: toHex(borderColor), fontSize: fontSize, fontFamily: fontFamily, color: toHex(color), backgroundColor: toHex(backgroundColor) } } const gridStyle = getStyle(computedStyle); const columnStyle = getStyle(columnComputedStyle); const headerStyle = getStyle(headerComputedStyle); const header = { height: that.$.columnHeader.offsetHeight + 'px', border: '1px solid ' + gridStyle.borderColor, fontFamily: headerStyle.fontFamily, fontSize: headerStyle.fontSize, color: headerStyle.color, backgroundColor: columnStyle.backgroundColor, fontWeight: '400' }; const columns = { border: '1px solid ' + gridStyle.borderColor, fontFamily: gridStyle.fontFamily, fontSize: gridStyle.fontSize }; const rows = { height: that.rowMinHeight + 'px' }; for (let i = 0; i < that.columns.length; i++) { const column = that.columns[i]; if (!column.allowExport) { continue; } if (!column.visible) { continue; } header[column.dataField] = { textAlign: column.align, width: column.computedWidth + 'px', format: column.cellsFormat || '' }; let cellsFormat = column.cellsFormat || ''; if (column.dataType === 'date') { cellsFormat = 'd'; } else if (column.dataType === 'dateTime') { cellsFormat = 'D'; } else if (column.dataType === 'time') { cellsFormat = 't'; } const columnStyleObject = { textAlign: column.cellsAlign, format: cellsFormat }; columns[column.dataField] = columnStyleObject; if (that.dataExport.view && ['html', 'jpeg', 'pdf', 'png'].indexOf(dataFormat) !== -1 && (column.template || column.formatFunction)) { for (let i = 0; i < that.rows.length; i++) { const row = that.rows[i]; let cell = that.rows[i]['column_' + column.dataField]; if (that.dataExport.viewStart && i < that.dataExport.viewStart || (that.dataExport.viewEnd && i > that.dataExport.viewEnd)) { continue; } if (!cell || (row && row.element && row.element.classList.contains('lw-hidden'))) { const rowElement = that._rowElements[0]; if (!rowElement) { continue; } row.element = rowElement; row.grid = that; row.render(); cell = row['column_' + column.dataField]; if (!cell) { continue; } } const cellStyleObject = {}; cellStyleObject.border = cell.borderColor; cellStyleObject.background = cell.background; cellStyleObject.color = cell.color; const index = that.dataExport.viewStart !== undefined ? i - that.dataExport.viewStart : i; formattedRows[i] = Object.assign({}, row.data); formattedRows[i][column.dataField] = cell.element.textContent; columnStyleObject[index] = cellStyleObject; } } } if (that.appearance.alternationCount > 0) { rows.alternationCount = that.appearance.alternationCount; rows.alternationStart = that.appearance.alternationStart; rows.alternationEnd = that.appearance.alternationEnd; rows.alternationIndex0Color = gridStyle.color; rows.alternationIndex0BackgroundColor = gridStyle.backgroundColor; rows.alternationIndex1Color = gridStyle.color; rows.alternationIndex1BackgroundColor = '#F5F5F5'; } dataExporter.style = { border: '1px solid ' + gridStyle.borderColor, borderCollapse: 'collapse', header: header, columns: columns, rows: rows } } } const viewRows = !that.rowHierarchy || that.grouping.enabled ? that.rows.toArray() : that.rowHierarchy, rowIds = that.dataExport.rowIds, rowIdsSet = rowIds !== null; //const rows = [].concat(that._frozenNearDefaultRows, that._nearRowsAdded, viewRows, that._farRowsAdded, that._frozenFarDefaultRows); let data = []; if (that.dataExport.view) { that._recyclingRows.forEach((row, index) => { if (that.dataExport.viewStart && index < that.dataExport.viewStart || (that.dataExport.viewEnd && index > that.dataExport.viewEnd)) { return true; } if (formattedRows[index]) { data.push(formattedRows[index]); } else { data.push(row.data) } }); } else { for (let i = 0; i < viewRows.length; i++) { const row = viewRows[i]; if (row.visible && (row.filtered !== false || row.filtered === undefined)) { if (rowIdsSet && rowIds.indexOf(row.id) === -1) { continue; } data.push(row.data); } } if (viewRows === that.rowHierarchy && !rowIdsSet) { data = that.dataSource.boundHierarchy; dataExporter.hierarchical = true; } } if (!that.dataExport.groupBy && that.grouping.enabled && that.dataSource && that.dataSource.groupBy) { dataExporter.groupBy = that.dataSource.groupBy && that.dataSource.groupBy.toArray ? that.dataSource.groupBy.toArray() : null; } that.checkLicense(true); const output = dataExporter.exportData(data, dataFormat, that.dataExport.fileName, callback); if (that.dataExport.view) { that._recycle(false); } return output; } print() { const that = this; const fileName = that.dataExport.fileName; that.dataExport.fileName = null; const output = that.exportData('html'); const newWindow = window.open('', '', 'width=800,height=500'), printDocument = newWindow.document.open(), pageContent = '<!DOCTYPE html>' + '<html>' + '<head>' + '<meta charset="utf-8" />' + '<title>' + fileName + '</title>' + '</head>' + '<body>' + output + '</body></html>'; try { printDocument.write(pageContent); printDocument.close(); setTimeout(function () { newWindow.print(); newWindow.close(); }, 100); } catch (error) { // } that.dataExport.fileName = fileName; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW.Utilities.Assign('Grid.Chart', class Chart { _getChartDataFields(data) { const that = this; const record = data[0]; let stringOnly = true, xAxisDataField, series = []; for (let dataField in record) { if (dataField === '$') { continue; } const dataType = that.dataSource.dataFields.find(gridField => gridField.name === dataField).dataType; if (dataType === 'string') { const index = that.columns.findIndex(col => col.dataField === dataField); if (index === 0) { xAxisDataField = dataField; } } else { stringOnly = false; series.push({ dataField: dataField, displayText: dataField }); } } return { xAxisDataField: xAxisDataField, series: series, stringOnly: stringOnly }; } createChart(type, dataSource) { const that = this; const gridSelection = that.getSelection(), selectedRows = gridSelection.rows, selectedColumns = gridSelection.columns, selectedCells = gridSelection.cells, chart = document.createElement('lw-chart'), chartData = [], seriesGroup = {}; let rowsToPlot = [], columnsToPlot = [], series; if (selectedCells && selectedCells.length > 1) { selectedCells.forEach(cell => { if (rowsToPlot.indexOf(cell.row.index) === -1) { rowsToPlot.push(cell.row.index); } if (columnsToPlot.indexOf(cell.dataField) === -1) { columnsToPlot.push(cell.dataField); } }); } if (dataSource) { chartData.concat(dataSource); } else { for (let i = 0; i < that.dataSource.length; i++) { const record = {}; if (selectedRows) { if (!selectedRows.find(rowObject => rowObject.row.index === i)) { continue; } } else if (selectedColumns) { selectedColumns.forEach(column => { record[column.dataField] = that.dataSource[i][column.dataField]; }); chartData.push(record); continue; } else if (selectedCells) { if (selectedCells.length > 1) { if (rowsToPlot.indexOf(i) === -1) { continue; } columnsToPlot.forEach(dataField => { record[dataField] = that.dataSource[i][dataField]; }); chartData.push(record); continue; } } that.columns.forEach(column => record[column.dataField] = that.dataSource[i][column.dataField]); chartData.push(record); } } const chartDataFields = that._getChartDataFields(chartData); if (chartDataFields.stringOnly) { if (that.header.visible && that.$.header.firstElementChild) { const chartIcon = that.enableShadowDOM ? that.shadowRoot.getElementById(type) : that.querySelector('#' + type); that.$.header.firstElementChild.classList.add('warning'); if (chartIcon) { chartIcon.classList.add('warning'); } setTimeout(function () { that.$.header.firstElementChild.classList.remove('warning'); if (chartIcon) { chartIcon.classList.remove('warning'); } }, 1000); } return; } series = chartDataFields.series; chart.caption = ''; chart.description = ''; chart.clip = false; chart.showLegend = true; chart.showBorderLine = false; chart.padding = { left: 5, top: 10, right: 5, bottom: 5 }; chart.dataSource = chartData; chart.xAxis = { dataField: chartDataFields.xAxisDataField, gridLines: { visible: true } }; chart.valueAxis = { displayValueAxis: true, description: that.charting.description, axisSize: 'auto', formatSettings: that.charting.formatSettings }; chart.colorScheme = that.charting.colorScheme; chart.seriesGroups = [seriesGroup]; seriesGroup.formatSettings = that.charting.formatSettings; seriesGroup.series = series; if (type === 'line') { series.forEach(function (serie) { serie.symbolSize = 8; serie.symbolType = 'square'; }); } else if (type === 'pie') { const pieDataField = series[0].dataField; delete seriesGroup.formatSettings; seriesGroup.formatFunction = function (value, index) { if (isNaN(value)) { if (typeof value === 'object') { return index; } return value; } return value; }; seriesGroup.showLabels = true; series.length = 0; series.push({ dataField: pieDataField, displayText: chartDataFields.xAxisDataField, initialAngle: 0 }); } else if (type === 'bar') { type = 'column'; seriesGroup.orientation = 'horizontal'; chart.xAxis.textRotationAngle = 90; chart.valueAxis.textRotationAngle = 30; chart.valueAxis.flip = true; } else if (type === 'area') { let opacity = 1; for (let i = 0; i < series.length; i++) { series[i].opacity = opacity; opacity -= 0.2; opacity = Math.max(0.3, opacity); } } seriesGroup.type = type; if (that.onChartInit) { that.onChartInit(chart); } if (that.charting.appendTo) { const container = that.charting.appendTo === 'string' ? document.querySelector(that.charting.appendTo) : that.charting.appendTo; if (container) { container.appendChild(chart); } } else { that._openChartDialog(chart, type); } } _openChartDialog(chart, chartType) { const that = this; if (!that.charting.dialog.enabled) { return false; } const dialog = that._dialogChart || that._createDialog(that.charting.dialog); const chartLabel = chartType.substring(0, 1).toUpperCase() + chartType.substring(1); const header = that.charting.dialog.header === '{{message}}' ? that.localize('dialogChartHeader', { value: chartLabel }) : that.charting.dialog.header; chart.style.width = '100%'; chart.style.height = '100%'; dialog.header.innerHTML = header; dialog.content.innerHTML = ''; dialog.content.style.width = '100%'; dialog.content.style.height = '100%'; dialog.btnCancel.classList.add('lw-hidden'); if (!that._dialogChart) { dialog.modal = true; dialog.onOpen = function () { that.charting.dialog.visible = true; } dialog.onClose = function () { that.charting.dialog.visible = false; } dialog.btnConfirm.onclick = function () { dialog.close(); } dialog.btnClose.onclick = function () { dialog.close(); } dialog.onkeydown = function (event) { if (event.key === 'Escape') { dialog.close(); } } that._dialogChart = dialog; } dialog.open(); setTimeout(function () { dialog.btnConfirm.focus(); dialog.content.appendChild(chart); }, 100); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-grid-toolbar', class GridToolbar extends LW.DataView { template() { return `<div id="container" role="presentation"> <div id="header" class="lw-data-view-header" role="toolbar"> <div id="customizeButton" class="lw-data-view-header-button lw-data-view-customize-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Customize cards"><div role="presentation"></div></div> <div id="filterButton" class="lw-data-view-header-button lw-data-view-filter-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Filter"><div role="presentation"></div></div> <div id="sortButton" class="lw-data-view-header-button lw-data-view-sort-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Sort"><div role="presentation"></div></div> <div id="groupButton" class="lw-data-view-header-button lw-data-view-group-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Group"><div role="presentation"></div></div> <div id="searchButton" class="lw-data-view-header-button lw-data-view-search-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Search"></div> <div id="headerDropDown" class="lw-data-view-header-drop-down lw-visibility-hidden" role="dialog"> <div id="customize" class="lw-hidden" role="presentation"></div> <div id="filter" class="lw-hidden" role="presentation"></div> <div id="sort" class="lw-hidden" role="presentation"></div> <div id="group" class="lw-hidden" role="presentation"></div> <div id="search" class="lw-data-view-search-box lw-hidden" role="presentation"> <input type="text" id="searchInput" spellcheck="false" aria-label="Search" /> <div id="searchLabel" class="lw-data-view-search-label lw-unselectable"></div> <div id="searchPrev" class="lw-data-view-search-prev" role="button" aria-label="Previous"></div> <div id="searchNext" class="lw-data-view-search-next" role="button" aria-label="Next"></div> <div id="searchClose" class="lw-data-view-search-close" role="button" aria-label="Close search box"></div> </div> </div> </div> </div>`; } render() { const that = this; that._appliedFiltering = { filters: [], operator: 'and' }; that._appliedSorting = { dataFields: [], dataTypes: [], orderBy: [] }; that._localizeHeader(); that._getInnerElementMessages(); super.render(); } /** * Opens the "Filter" header panel (drop down). */ openFilterPanel(column) { const that = this, dataSource = that.dataSource, filterPanelDataSource = this.columns.map(col => { const field = Object.assign({}, col); field.dataType = dataSource.dataFields.find(dataField => dataField.name === field.dataField).dataType; return field; }).filter(col => { return col.allowFilter; }); super.openFilterPanel(filterPanelDataSource, null); if (column) { const filterPanel = that.$.headerDropDown.querySelector('lw-multi-column-filter-panel'); filterPanel.$.itemsContainer.appendChild(filterPanel._createItem(that.columns.find((value) => { if (value.dataField === column.dataField) { return true; } return false; }), column.dataType === 'string' ? 'CONTAINS' : 'EQUAL', '')); const items = filterPanel.querySelectorAll('.lw-grid-panel-item'); setTimeout(() => { items[items.length-1].querySelector('.editor').focus(); }, 50); } } /** * Opens the "Sort" header panel (drop down). */ openSortPanel() { const that = this, dataSource = that.dataSource, sortPanelDataSource = that.columns.map(col => { const newColumn = Object.assign({}, col), preSortedIndex = that._appliedSorting.dataFields.indexOf(newColumn.dataField); newColumn.dataType = dataSource.dataFields.find(dataField => dataField.name === newColumn.dataField).dataType; newColumn.sortIndex = preSortedIndex; if (preSortedIndex !== -1) { newColumn.sortDirection = that._appliedSorting.orderBy[preSortedIndex]; } return newColumn; }).filter(col => { return col.allowSort; }); super.openSortPanel(sortPanelDataSource); const sortPanel = that.$.headerDropDown.querySelector('lw-sort-panel'); const input = sortPanel.$.inputNotSorted; const updateInputVisibility = () =>{ const items = sortPanel.querySelectorAll('.lw-grid-panel-item'); if (that.grid.sorting.mode === 'many' || items.length < 1) { input.classList.remove('lw-visibility-hidden'); } else if (items.length >= 1){ input.classList.add('lw-visibility-hidden'); } } sortPanel.onDataSourceChange = () => { updateInputVisibility(); } updateInputVisibility(); } openCustomizePanel() { const that = this, dataSource = that.dataSource; if (!dataSource || dataSource.length === 0 || that.disabled || that.headerPosition === 'none') { return; } that._refreshColumns(); const customizePart = that.$.customize, columnPanelDataSource = that.columns.map(col => { const newColumn = Object.assign({}, col); if ([that.coverField, that.titleField].indexOf(newColumn.dataField) !== -1) { newColumn.disableToggle = true; } else { newColumn.disableToggle = false; } if (!col.allowHide){ newColumn.disableToggle = true; } return newColumn; }); let columnPanel; that._closeDialog(); that.$.headerDropDown.classList.add('customize-panel'); that.$.headerDropDown.classList.remove('filter-panel', 'sort-panel', 'search-panel', 'group-panel'); customizePart.classList.remove('lw-hidden'); that.$.filter.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); that.$.search.classList.add('lw-hidden'); that.$.group.classList.add('lw-hidden'); that._closeSearchPanel(); if (!that._customizePartCreated) { const fragment = document.createDocumentFragment(), columnPanel = document.createElement('lw-column-panel'); columnPanel.rightToLeft = that.rightToLeft; columnPanel.animation = that.animation; columnPanel.dataSource = columnPanelDataSource; columnPanel.locale = that.locale; columnPanel.messages = that._innerElementMessages.columnPanel; columnPanel.theme = that.theme; fragment.appendChild(columnPanel); that.$.customize.appendChild(fragment); that._customizePartCreated = true; } else { columnPanel = customizePart.querySelector('lw-column-panel'); columnPanel.set('dataSource', columnPanelDataSource); columnPanel.propertyChangedHandler('dataSource', undefined, columnPanelDataSource); columnPanel.rightToLeft = that.rightToLeft; } that._changedVisibility = new Map(); that._openHeaderDropDown(that.$.customizeButton); } /** * Applies filtering. */ _applyFilter(filters, operator) { const that = this; that.grid.beginUpdate(); that.grid.context = that.grid; that.grid.clearFilter(); for(let i = 0; i < filters.length; i++) { const item = filters[i]; const dataField = item[0]; const filter = item[1]; const column = that.grid.columnByDataField[dataField]; column.filter = filter; } that.grid._filterOperator = operator; that.grid.endUpdate(); that.grid.refreshFilters(); that.grid.context = document; } /** * Applies sorting. */ _applySort() { const that = this, sortByInfo = that._appliedSorting; that.grid.beginUpdate(); that.grid.context = that.grid; that.grid.clearSort(); for(let i = 0; i < sortByInfo.dataFields.length; i++) { that.grid.sortBy(sortByInfo.dataFields[i], sortByInfo.orderBy[i]) } that.grid.endUpdate(); that.grid.context = document; } _applyHandler(event) { const that = this, target = event.target, detail = event.detail, customize = that.$.customize if (customize.contains(target)) { that._applyColumns(detail.value); } else if (that.$.filter.contains(target)) { that.addFilter(detail.filters, detail.operator, detail.value); } else if (that.$.sort.contains(target)) { that.addSort(detail.sortByInfo); } that.closePanel(); } _refreshColumns() { const that = this; const grid = that.grid; let columns = Array.isArray( grid.columns ) ? [ ...grid.columns ] : [ ...grid.columns.toArray() ] columns = columns.map( ( column ) => { if ( column.data ) { if (column.data.grid !== undefined) { delete column.data.grid; } column.data.allowSort = column.allowSort; column.data.allowFilter = column.allowFilter; column.data.allowGroup = column.allowGroup; column.data.allowHide = column.allowHide; column.data.visible = column.visible; return column.data; } return column; } ); that.columns = columns; } _init(grid) { const that = this; that.grid = grid; if (grid.dataSource && grid.dataSource.boundSource) { that._refreshColumns(); that.dataSource = new LW.DataAdapter({ observable: false, dataSource: [...grid.dataSource.boundSource.toArray()], dataFields: grid.dataSource.dataFields }); } } _refresh() { const that = this; const grid = that.grid; grid.header.buttons.indexOf('sort') >= 0 && grid.sorting.enabled? that.$.sortButton.classList.remove('lw-hidden') : that.$.sortButton.classList.add('lw-hidden'); grid.header.buttons.indexOf('filter') >= 0 && grid.filtering.enabled ? that.$.filterButton.classList.remove('lw-hidden') : that.$.filterButton.classList.add('lw-hidden'); grid.header.buttons.indexOf('group') >= 0 && grid.grouping.enabled? that.$.groupButton.classList.remove('lw-hidden') : that.$.groupButton.classList.add('lw-hidden'); grid.header.buttons.indexOf('columns') >= 0 ? that.$.customizeButton.classList.remove('lw-hidden') : that.$.customizeButton.classList.add('lw-hidden'); grid.header.buttons.indexOf('search') >= 0 ? that.$.searchButton.classList.remove('lw-hidden') : that.$.searchButton.classList.add('lw-hidden'); if (grid._sortedColumns) { const sortDataFields = []; const sortOrders = []; const sortDataTypes = []; for (let i = 0; i < grid._sortedColumns.length; i++) { const sortColumn = grid._sortedColumns[i]; sortDataFields.push(sortColumn.dataField); sortOrders.push(sortColumn.sortOrder); sortDataTypes.push(sortColumn.dataType); } that._appliedSorting = { dataFields: sortDataFields, dataTypes: sortDataTypes, orderBy: sortOrders }; that._refreshSortButton(); } const newFiltering = { filters: [], operator: 'and' }; const filters = grid.getFilteredColumns(); if (filters) { for(let dataField in filters) { const filterGroup = filters[dataField]; for(let i = 0; i < filterGroup.filters.length; i++) { const filterObject = filterGroup.filters[i]; newFiltering.filters.push([dataField, filterObject.condition, filterObject.value]); } } } if (that._appliedFiltering) { newFiltering.operator = that._appliedFiltering.operator; } that._appliedFiltering = newFiltering; that._refreshFilterButton(); if (that._appliedGrouping) { that._appliedGrouping.dataFields = grid.dataSource.groupBy; } else { that._appliedGrouping = {dataFields: grid.dataSource.groupBy, expandAll: false, collapseAll:false}; } that._refreshGroupButton(); } openGroupPanel() { const that = this; let groupPanel; const grid = that.grid; that.$.headerDropDown.classList.add('group-panel'); that.$.headerDropDown.classList.remove('customize-panel', 'sort-panel', 'search-panel'); that.$.group.classList.remove('lw-hidden'); that.$.filter.classList.add('lw-hidden'); that.$.customize.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); that.$.search.classList.add('lw-hidden'); const groupPanelDataSource = that.columns.map(col => { const newColumn = Object.assign({}, col); if (that._appliedGrouping && that._appliedGrouping.dataFields) { const index = that._appliedGrouping.dataFields.indexOf(newColumn.dataField); newColumn.groupIndex = index; } return newColumn; }).filter(col => { return col.allowGroup; }); if (!that._groupPartCreated) { groupPanel = document.createElement('lw-group-panel'); groupPanel.rightToLeft = that.rightToLeft; groupPanel.animation = that.animation; groupPanel.locale = that.locale; groupPanel.messages = that._innerElementMessages.groupPanel; groupPanel.theme = that.theme; groupPanel.dataSource = groupPanelDataSource; that.$.group.appendChild(groupPanel); that._groupPartCreated = true; groupPanel.onExpandAll = () => { that._appliedGrouping.expandAll = true; that._appliedGrouping.collapseAll = false; } groupPanel.onCollapseAll = () => { that._appliedGrouping.expandAll = false; that._appliedGrouping.collapseAll = true; } groupPanel.addEventListener('apply', (event) => { const detail = event.detail.sortByInfo; that._appliedGrouping.dataFields = detail.dataFields; grid.beginUpdate(); grid.clearGroups(); for( let i = 0; i < detail.dataFields.length; i++) { const dataField = detail.dataFields[i]; grid.addGroup(dataField); } if (that._appliedGrouping.expandAll) { grid.expandAllRows(); } if (that._appliedGrouping.collapseAll) { grid.collapseAllRows(); } grid.endUpdate(); }); } else { groupPanel = that.$.group.firstElementChild; groupPanel.rightToLeft = that.rightToLeft; groupPanel.dataSource = groupPanelDataSource; } that._refreshGroupButton(); that._openHeaderDropDown(that.$.groupButton); } _refreshGroupButton() { const that = this; const numberOfGroups = that._appliedGrouping.dataFields ? that._appliedGrouping.dataFields.length : 0; if (numberOfGroups === 0) { that.$.groupButton.firstElementChild.innerHTML = that.localize('group'); that.$.groupButton.classList.remove('grouped'); return; } if (numberOfGroups === 1) { that.$.groupButton.firstElementChild.innerHTML = that.localize('groupedByOne'); } else { that.$.groupButton.firstElementChild.innerHTML = that.localize('groupedByMultiple', { n: numberOfGroups }); } that.$.groupButton.classList.add('grouped'); } openSearchPanel() { this._openSearchPanel(); } /** * Opens search panel. */ _openSearchPanel() { const that = this; const grid = that.grid; that.$.headerDropDown.classList.add('search-panel'); that.$.headerDropDown.classList.remove('customize-panel', 'filter-panel', 'sort-panel', 'group-panel'); that.$.search.classList.remove('lw-hidden'); that.$.customize.classList.add('lw-hidden'); that.$.group.classList.add('lw-hidden'); that.$.filter.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); that._openHeaderDropDown(that.$.searchButton); const rows = []; const visibleRows = grid.getVisibleRows(); for (let i = 0; i < visibleRows.length; i++) { rows.push(Object.assign(visibleRows[i].data)); } const dataAdapter = new LW.DataAdapter({ observable: false, dataSource: rows, dataFields: grid.dataSource.dataFields }); that._searchInfo = { source: dataAdapter, stringDataFields: that.dataSource.dataFields.filter(dataField => { return dataField.dataType === 'string'; }).map(dataField => dataField.name) }; if (that.$.searchInput.value !== '') { that._search(that.$.searchInput.value, false); } } _search(query, highlight = true) { const that = this; that._searchInfo.query = query; if (query === '') { that.$.search.classList.remove('matches', 'no-matches'); delete that._searchInfo.foundIdsArray; delete that._searchInfo.foundIdsObject; delete that._searchInfo.highlighted; that.grid.highlighted = null; return; } const source = that._searchInfo.source, filters = [], foundIdsArray = [], foundIdsObject = {}; that._searchInfo.stringDataFields.forEach(dataField => { const filterGroup = new LW.Utilities.FilterGroup(), filterObject = filterGroup.createFilter('string', query, 'CONTAINS'); filterGroup.addFilter('or', filterObject); filters.push([dataField, filterGroup]); }); source._filter(filters, 'or'); for (let i = 0; i < source.length; i++) { const record = source[i]; if (record.$.filtered !== false) { foundIdsArray.push(record.id); foundIdsObject[record.id] = true; } } that._searchInfo.foundIdsArray = foundIdsArray; that._searchInfo.foundIdsObject = foundIdsObject; that.grid.highlighted = null; if (foundIdsArray.length > 0) { that.$.search.classList.remove('no-matches'); that.$.search.classList.add('matches'); that.$.searchLabel.innerHTML = that.localize('found', { nth: highlight ? 1 : 0, n: foundIdsArray.length }); that._searchInfo.highlighted = foundIdsArray[0]; that.grid.highlighted = that._searchInfo.highlighted; that.grid.ensureVisible(that._searchInfo.highlighted); that.grid._recycle(false); return; } that.$.search.classList.remove('matches'); that.$.search.classList.add('no-matches'); that.$.searchLabel.innerHTML = that.localize('found', { nth: 0, n: 0 }); } _applyColumns(columns) { const that = this; const grid = that.grid; grid.beginUpdate(); for(let index in columns) { const column = columns[index]; const gridColumn = grid.columnByDataField[column.dataField]; const gridColumnIndex = grid.columns.indexOf(gridColumn); const columnIndex = parseInt(index); gridColumn.visible = column.visible; if (gridColumnIndex !== columnIndex) { grid.columns.move(gridColumnIndex, columnIndex); } } grid.endUpdate(); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW( 'lw-grid', class Grid extends LW.ScrollViewer { // Grid's properties. /* */ static get properties() { return { 'appearance': { value: { // context menu option. 'allowColumnFixing': { value: false, type: 'boolean' }, 'alternationStart': { value: 0, type: 'int' }, 'alternationEnd': { value: 0, type: 'int' }, 'alternationCount': { value: 0, type: 'int' }, 'allowHover': { value: false, type: 'boolean', defaultReflectToAttribute: true }, 'allowHeaderHover': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'allowRowToggleAnimation': { value: false, type: 'boolean' }, 'allowRowDetailToggleAnimation': { value: false, type: 'boolean' }, 'allowSortAnimation': { value: false, type: 'boolean' }, 'allowColumnLabelAnimation': { value: true, type: 'boolean' }, 'allowCheckBoxesSelectionAnimation': { value: true, type: 'boolean' }, 'allowColumnMenuAnimation': { value: true, type: 'boolean' }, 'allowColumnSortButtonAnimation': { value: true, type: 'boolean' }, 'allowColumnActionButtonAnimation': { value: true, type: 'boolean' }, 'allowColumnFilterButtonAnimation': { value: true, type: 'boolean' }, 'allowColumnStickyPosition': { value: false, type: 'boolean' }, 'autoShowColumnSortButton': { value: true, type: 'boolean' }, 'autoShowColumnActionButton': { value: true, type: 'boolean' }, 'autoGenerateRowLabelMode': { value: 'number', type: 'string' }, 'autoGenerateColumnLabelMode': { value: 'letter', type: 'string' }, 'autoShowColumnFilterButton': { value: true, type: 'boolean' }, 'displayLoadingIndicator': { value: false, type: 'boolean' }, 'loadingIndicatorPlaceholder': { value: 'Loading...', type: 'string' }, 'placeholder': { value: 'No Rows', type: 'string' }, 'sortAnimationDuration': { value: 500, type: 'number' }, 'showRowHeader': { value: false, type: 'boolean' }, 'showRowHeaderNumber': { value: false, type: 'boolean' }, 'showRowHeaderEditIcon': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'showRowHeaderDragIcon': { value: false, type: 'boolean', }, 'showRowHeaderSelectIcon': { value: false, type: 'boolean' }, 'showRowHeaderFocusIcon': { value: false, type: 'boolean' }, 'showColumnHeaderLines': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'showColumnLines': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'showRowLines': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'showFilterColumnBackground': { value: true, type: 'boolean' }, 'showSortColumnBackground': { value: true, type: 'boolean' }, 'showFrozenColumnBackground': { value: true, type: 'boolean' }, 'showFrozenRowBackground': { value: true, type: 'boolean' }, 'showColumnSortButton': { value: true, type: 'boolean' }, 'showColumnFilterButton': { value: true, type: 'boolean' }, 'showColumnDescriptionButton': { value: false, type: 'boolean' }, 'showColumnIcon': { value: false, type: 'boolean' }, 'showColumnCustomButton': { value: false, type: 'boolean' }, 'showColumnActionButton': { value: true, type: 'boolean' }, 'showTooltips': { value: false, type: 'boolean' }, 'showResizeTooltips': { value: true, type: 'boolean' }, 'showHorizontalScrollBarOnFixedColumns': { value: false, type: 'boolean' }, 'showVerticalScrollBarOnFixedColumns': { value: false, type: 'boolean' } }, type: 'object' }, 'behavior': { value: { 'allowColumnAutoSizeOnDoubleClick': { value: true, type: 'boolean' }, 'allowRowAutoSizeOnDoubleClick': { value: true, type: 'boolean' }, 'allowColumnReorder': { value: false, type: 'boolean' }, 'allowRowReorder': { value: false, type: 'boolean' }, 'doubleClickTimingDelay': { value: 300, type: 'number' }, 'columnResizeMode': { value: 'none', type: 'string', allowedValues: [ 'none', 'split', 'growAndShrink' ] }, 'rowResizeMode': { value: 'none', type: 'string', allowedValues: [ 'none', 'split', 'growAndShrink' ] }, }, type: 'object' }, 'layout': { value: { 'allowCellsWrap': { value: false, type: 'boolean' }, 'autoGenerateColumnWidth': { value: null, type: 'number?' }, 'columnWidth': { value: null, type: 'any', reflectToAttribute: false }, 'columnHeight': { value: null, type: 'any', reflectToAttribute: false }, 'columnMinHeight': { value: 30, type: 'any', reflectToAttribute: false }, 'isDirty': { value: false, type: 'boolean' }, 'loadingIndicatorPosition': { value: 'center', allowedValues: [ 'bottom', 'center', 'top' ], type: 'string' }, 'rowMinHeight': { value: 30, type: 'number' }, 'rowHeight': { value: null, type: 'any', reflectToAttribute: false } }, type: 'object' }, 'dataExport': { value: { 'header': { value: true, type: 'boolean' }, 'filterBy': { value: null, type: 'object', }, 'groupBy': { value: null, type: 'object', }, 'style': { value: null, type: 'object' }, 'fileName': { value: 'lwGrid', type: 'string?' }, 'pageOrientation': { value: 'portrait', type: 'string' }, 'expandChar': { value: '+', type: 'string' }, 'collapseChar': { value: '-', type: 'string' }, 'view': { value: false, type: 'boolean' }, 'viewStart': { value: null, type: 'number?' }, 'viewEnd': { value: null, type: 'number?' }, 'rowIds': { value: null, type: 'array?' }, }, type: 'object' }, 'clipboard': { value: { 'enabled': { value: true, type: 'boolean' }, 'autoFillMode': { value: 'copy', allowedValues: [ 'none', 'copy', 'fillSeries' ], type: 'string' }, 'onPasteValue': { value: null, type: 'any' } }, type: 'object' }, 'columns': { value: [], type: 'any', reflectToAttribute: false }, 'columnMenu': { value: { 'autoClose': { value: true, type: 'boolean' }, 'dataSource': { value: { 'columnMenuCustomizeType': { value: { command: { value: 'customizeTypeCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-ellipsis-vert', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemRename': { value: { command: { value: 'renameCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-rename', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemEditDescription': { value: { command: { value: 'editDescriptionCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-circled', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemDuplicate': { value: { command: { value: 'duplicateCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-duplicate', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemInsertLeft': { value: { command: { value: 'insertLeftCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-insert-left', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemInsertRight': { value: { command: { value: 'insertRightCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-insert-right', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemSortAsc': { value: { command: { value: 'sortAscCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: 'auto', type: 'any' }, icon: { value: 'lw-icon-sort-name-up', type: 'string' }, iconAlt: { value: 'lw-icon-sort-number-up', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemSortDesc': { value: { command: { value: 'sortDescCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: 'auto', type: 'any' }, icon: { value: 'lw-icon-sort-name-down', type: 'string' }, iconAlt: { value: 'lw-icon-sort-number-down', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemRemoveSort': { value: { command: { value: 'removeSortCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: 'auto', type: 'any' }, icon: { value: 'lw-icon-cancel-circled', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemFilter': { value: { command: { value: 'addFilterCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: 'auto', type: 'any' }, icon: { value: 'lw-icon-add-filter', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemRemoveFilter': { value: { command: { value: 'removeFilterCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: 'auto', type: 'any' }, icon: { value: 'lw-icon-cancel-circled', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemGroupBy': { value: { command: { value: 'groupByCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: 'auto', type: 'any' }, icon: { value: 'lw-icon-group', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemRemoveGroupBy': { value: { command: { value: 'removeGroupByCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: 'auto', type: 'any' }, icon: { value: 'lw-icon-ungroup', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemHide': { value: { command: { value: 'hideColumnCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-visibility-off', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false }, 'columnMenuItemDelete': { value: { command: { value: 'deleteColumnCommand', type: 'any' }, enabled: { value: true, type: 'boolean' }, visible: { value: false, type: 'any' }, icon: { value: 'lw-icon-delete', type: 'string' }, label: { value: '{{messages}}', type: 'string' } }, type: 'object', reflectToAttribute: false } }, type: 'object', reflectToAttribute: false }, 'visible': { value: false, type: 'boolean' }, 'enabled': { value: true, type: 'boolean' }, 'width': { value: 250, type: 'number' }, 'height': { value: null, type: 'number?' } }, type: 'object', reflectToAttribute: false }, 'columnGroups': { value: [], type: 'array', reflectToAttribute: false }, 'charting': { value: { 'appendTo': { value: null, type: 'any' }, 'enabled': { value: false, type: 'boolean' }, 'colorScheme': { value: 'scheme01', type: 'string' }, 'description': { value: '', type: 'string' }, 'dialog': { value: { 'header': { value: '{{message}}', type: 'string' }, 'height': { value: 400, type: 'any' }, 'width': { value: 400, type: 'any' }, 'left': { value: 'center', type: 'any' }, 'top': { value: 'center', type: 'any' }, 'enabled': { value: true, type: 'boolean' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' }, 'formatSettings': { value: {}, type: 'object' } }, type: 'object' }, 'dataSource': { value: null, type: 'any', reflectToAttribute: false }, 'grouping': { value: { 'enabled': { value: false, type: 'boolean', reflectToAttribute: false }, 'allowCollapse': { value: false, type: 'boolean', reflectToAttribute: false }, 'autoExpandAll': { value: false, type: 'boolean', reflectToAttribute: false }, 'expandMode': { value: 'buttonClick', type: 'string', allowedValues: [ 'buttonClick', 'rowClick' ], reflectToAttribute: false }, 'renderMode': { type: 'string', value: 'advanced', allowedValues: [ 'basic', 'compact', 'advanced' ] }, 'groupRowHeight': { value: 50, type: 'any', reflectToAttribute: false }, 'toggleButtonIndent': { value: 16, type: 'number', reflectToAttribute: false }, 'groupIndent': { value: 16, type: 'number', reflectToAttribute: false }, 'groupBar': { value: { 'visible': { value: false, type: 'boolean', reflectToAttribute: false }, 'allowColumnDragDrop': { value: true, type: 'boolean', reflectToAttribute: true }, 'allowColumnCloseButtons': { value: true, type: 'boolean', reflectToAttribute: true } }, type: 'object' }, 'summaryRow': { value: { 'inline': { value: true, type: 'boolean' }, 'visible': { value: true, type: 'boolean' } }, type: 'object' } }, type: 'object' }, 'messages': { extend: true, value: { 'en': { 'invalidColumnProperty': '{{elementType}}: Invalid property name "{{propertyName}}" set for Column: "{{type}}"', 'invalidRowProperty': '{{elementType}}: Invalid property name "{{propertyName}}" set for Row"', 'frozenColumns': '{{elementType}}: To Pin/Freeze a column group, all columns within it should be frozen.', 'frozenRows': '{{elementType}}: To Pin/Freeze a special cell, all rows within it should be frozen.', 'columnGroups': '{{elementType}}: Please, check the initialization of the lwGrid\'s columns array. The columns in a column group are expected to be siblings in the columns array.', 'min': 'Min: {{value}}', 'max': 'Max: {{value}} ', 'sum': 'Sum: {{value}} ', 'avg': 'Avg: {{value}} ', 'count': 'Count: {{value}} ', 'pagerFirstButton': 'First', 'pagerLastButton': 'Last', 'pagerPreviousButton': 'Previous', 'pagerNextButton': 'Next', 'pagerNavigateToLabel': 'Go to:', 'pagerPageSizeLabel': 'Show:', 'pagerNavigateToInputPlaceholder': '', 'pagerEllipsis': '...', 'pagerSummaryString': 'of', 'pagerSummaryPrefix': 'of', 'pagerSummarySuffix': '', 'columnMenuCustomizeType': 'Customize type', 'columnMenuItemRename': 'Rename', 'columnMenuItemEditDescription': 'Edit description', 'columnMenuItemDuplicate': 'Duplicate', 'columnMenuItemInsertLeft': 'Insert left', 'columnMenuItemInsertRight': 'Insert right', 'columnMenuItemSortAsc': 'Sort {{mode}}', 'columnMenuItemSortDesc': 'Sort {{mode}}', //Sort A  Z 'columnMenuItemRemoveSort': 'Remove Sort', 'columnMenuItemFilter': 'Filter', 'columnMenuItemRemoveFilter': 'Remove Filter', 'columnMenuItemGroupBy': 'Group by this column', 'columnMenuItemRemoveGroupBy': 'Remove Group', 'columnMenuItemHide': 'Hide', 'columnMenuItemDelete': 'Delete', 'columnResizeTooltip': 'width: {{value}}px', 'rowResizeTooltip': 'height: {{value}}px', 'commandBarAddRow': 'Add', 'commandBarDeleteRow': 'Delete', 'commandBarBatchRevert': 'Revert', 'commandBarBatchSave': 'Save', 'commandBarFilter': 'Filter', 'commandBarSort': 'Sort', 'commandBarSearch': 'Search', 'commandBarCustomize': 'Customize', 'commandBarGroup': 'Group', 'commandColumnEdit': 'Edit', 'commandColumnDelete': 'Delete', 'commandColumnCancel': 'Cancel', 'commandColumnUpdate': 'Update', 'commandColumnMenu': '', 'expandRow': 'Expand row', 'collapseRow': 'Collapse row', 'addNewRow': 'Click here to add a new row', 'dialogChartHeader': '{{value}} Chart', 'dialogRowDetailHeader': 'Row Id: {{value}}', 'dialogRowDetailButtonConfirm': 'OK', 'dialogRowDetailButtonCancel': 'CANCEL', 'dialogEditHeader': 'Edit {{value}}', 'dialogAddButtonConfirm': 'ADD', 'dialogAddButtonCancel': 'CANCEL', 'dialogEditButtonConfirm': 'OK', 'dialogEditButtonCancel': 'CANCEL', 'dialogFilterButtonConfirm': 'FILTER', 'dialogFilterButtonCancel': 'CLEAR', 'dialogDeleteButtonConfirm': 'DELETE', 'dialogDeleteButtonCancel': 'CANCEL', 'dialogAddHeader': 'Add Row', 'dialogDeleteHeader': 'Delete Row', 'dialogFilterHeader': 'Filter by', 'dialogFilterMinLabel': 'Min', 'dialogFilterMaxLabel': 'Max', 'groupBarLabel': 'Drag a column header here to group by that column', 'dialogDeleteContent': 'Are you sure you want to delete this row?', 'calendar': { // separator of parts of a date (e.g. '/' in 11/05/1955) '/': '/', // separator of parts of a time (e.g. ':' in 05:44 PM) ':': ':', // the first day of the week (0 = Sunday, 1 = Monday, etc) firstDay: 0, days: { // full day names names: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ], // abbreviated day names namesAbbr: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], // shortest day names namesShort: [ 'Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa' ] }, months: { // full month names (13 months for lunar calendards -- 13th month should be '' if not lunar) names: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', '' ], // abbreviated month names namesAbbr: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', '' ] }, // AM and PM designators in one of these forms: // The usual view, and the upper and lower case versions // [standard,lowercase,uppercase] // The culture does not use AM or PM (likely all standard date formats use 24 hour time) // null AM: [ 'AM', 'am', 'AM' ], PM: [ 'PM', 'pm', 'PM' ], eras: [ // eras in reverse chronological order. // name: the name of the era in this culture (e.g. A.D., C.E.) // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era. // offset: offset in years from gregorian calendar {'name': 'A.D.', 'start': null, 'offset': 0} ], currencySymbol: '$', currencySymbolPosition: 'before', decimalSeparator: '.', thousandsSeparator: ',' }, 'CONTAINS': 'Contains', 'DOES_NOT_CONTAIN': 'Does not contain', 'ENDS_WITH': 'Ends with', 'EQUAL': 'Equal', 'GREATER_THAN': 'Greater than', 'GREATER_THAN_OR_EQUAL': 'Greater than or equal', 'LESS_THAN': 'Less than', 'LESS_THAN_OR_EQUAL': 'Less than or equal', 'NOT_EQUAL': 'Not equal', 'RANGE': 'Range', 'CLEAR_FILTER': 'Clear Filter', 'STARTS_WITH': 'Starts with', 'addFilter': '+ Add filter', 'and': 'And', 'apply': 'Apply', 'booleanFirst': '', 'booleanLast': '', 'cancel': 'Cancel', 'CONTAINS_CASE_SENSITIVE': 'Contains (case sensitive)', 'dateFirst': '1', 'dateLast': '9', 'DOES_NOT_CONTAIN_CASE_SENSITIVE': 'does not contain (case sensitive)', 'EMPTY': 'empty', 'ENDS_WITH_CASE_SENSITIVE': 'ends with (case sensitive)', 'EQUAL_CASE_SENSITIVE': 'equal (case sensitive)', 'filter': 'Filter', 'customize': 'Customize Columns', 'filteredByMultiple': '{{n}} filters', 'filteredByOne': '1 filter', 'filterValuePlaceholder': 'Value', 'find': 'Find a field', 'findInView': 'Find in view', 'firstBy': 'Sort by', 'found': '{{nth}} of {{n}}', 'from': 'from', 'noFilters': 'No filters applied', 'noResults': 'No results', 'noSorting': 'No sorting applied', 'NOT_EMPTY': 'not empty', 'NOT_NULL': 'not null', 'NULL': 'null', 'numberFirst': '1', 'numberLast': '9', 'ok': 'OK', 'or': 'Or', 'pickAnother': 'Pick another field to sort by', 'sort': 'Sort', 'group': 'Group', 'sortedByMultiple': 'Sorted by {{n}} fields', 'sortedByOne': 'Sorted by 1 field', 'STARTS_WITH_CASE_SENSITIVE': 'starts with (case sensitive)', 'stringFirst': 'A', 'stringLast': 'Z', 'thenBy': 'then by', 'where': 'Where', 'collapseAll': 'Collapse all', 'expandAll': 'Expand all', 'noGrouping': 'No grouping', 'groupedByMultiple': '{{n}} groups', 'groupedByOne': '1 group', 'firstByGroup': 'Group by', 'pickAnotherGroupBy': 'Pick another field to group by' } }, type: 'object' }, 'onCellValue': { value: null, type: 'any', reflectToAttribute: false }, 'onCellUpdate': { value: null, type: 'any', reflectToAttribute: false }, 'onBeforeInit': { value: null, type: 'any', reflectToAttribute: false }, 'onInit': { value: null, type: 'any', reflectToAttribute: false }, 'onAfterInit': { value: null, type: 'any', reflectToAttribute: false }, 'onKey': { value: null, type: 'any', reflectToAttribute: false }, 'onRender': { value: null, type: 'any', reflectToAttribute: false }, 'onChartInit': { value: null, type: 'any', reflectToAttribute: false }, 'onRowInit': { value: null, type: 'any', reflectToAttribute: false }, 'onRowDetailInit': { value: null, type: 'any', reflectToAttribute: false }, 'onRowDetailUpdated': { value: null, type: 'any', reflectToAttribute: false }, 'onRowInserted': { value: null, type: 'any', reflectToAttribute: false }, 'onRowRemoved': { value: null, type: 'any', reflectToAttribute: false }, 'onRowUpdate': { value: null, type: 'any', reflectToAttribute: false }, 'onRowUpdated': { value: null, type: 'any', reflectToAttribute: false }, 'onColumnInit': { value: null, type: 'any', reflectToAttribute: false }, 'onColumnInserted': { value: null, type: 'any', reflectToAttribute: false }, 'onColumnRemoved': { value: null, type: 'any', reflectToAttribute: false }, 'onColumnUpdated': { value: null, type: 'any', reflectToAttribute: false }, 'onCommand': { value: null, reflectToAttribute: false, type: 'any' }, 'filtering': { value: { 'enabled': { value: false, type: 'boolean' }, 'filter': { value: [], type: 'array', reflectToAttribute: false }, 'filterRow': { value: { 'visible': { value: false, type: 'boolean' }, 'menuVisible': { value: false, type: 'boolean' }, 'applyMode': { value: 'auto', type: 'string', allowedValues: [ 'auto', 'click' ] }, 'autoApplyModeDelay': { value: 500, type: 'number' } }, type: 'object' }, 'filterMenu': { value: { 'visible': { value: true, type: 'boolean' }, 'buttons': { value: [ 'cancel', 'clear', 'filter' ], type: 'array' }, 'dataSource': { value: null, type: 'any' }, 'width': { value: 250, type: 'number' }, 'height': { value: 200, type: 'number' }, 'mode': { value: 'default', allowedValues: [ 'default', 'excel' ], type: 'string' }, 'messages': { value: null, type: 'object' } }, type: 'object' } }, type: 'object' }, 'editing': { value: { 'allowRowHeaderEdit': { value: false, type: 'any' }, 'allowColumnHeaderEdit': { value: false, type: 'any' }, 'active': { value: false, readonly: true, type: 'boolean' }, 'enabled': { value: false, type: 'boolean' }, 'batch': { value: false, type: 'any' }, 'action': { value: 'click', type: 'string', allowedValues: [ 'none', 'click', 'doubleClick' ] }, 'commandKeys': { value: { 'commandKeyEdit': { value: { command: 'commandKeyEditCommand', key: 'F2' }, type: 'object' }, 'commandKeyCancel': { value: { command: 'commandKeyCancelCommand', key: 'Escape' }, type: 'object' }, 'commandKeyUpdate': { value: { command: 'commandKeyUpdateCommand', key: 'Enter | Tab' }, type: 'object' } }, type: 'object' }, 'commandBar': { value: { 'visible': { value: false, type: 'boolean' }, 'position': { value: 'near', allowedValues: [ 'near', 'far', 'both' ], type: 'string' }, 'displayMode': { value: 'labelAndIcon', allowedValues: [ 'label', 'icon', 'labelAndIcon' ], type: 'string' }, 'dataSource': { value: { 'commandBarSearch': { value: { 'command': { value: 'commandBarSearchCommand', type: 'any' }, 'icon': { value: 'lw-icon-search', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: false, type: 'any' } }, type: 'object' }, 'commandBarAddRow': { value: { 'command': { value: 'commandBarAddRowCommand', type: 'any' }, 'icon': { value: 'lw-icon-plus', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: false, type: 'any' } }, type: 'object' }, 'commandBarDeleteRow': { value: { 'command': { value: 'commandBarDeleteRowCommand', type: 'any' }, 'icon': { value: 'lw-icon-delete', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: false, type: 'any' } }, type: 'object' }, 'commandBarBatchSave': { value: { 'command': { value: 'commandBarBatchSaveCommand', type: 'any' }, 'icon': { value: 'lw-icon-ok-squared', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'commandBarBatchRevert': { value: { 'command': { value: 'commandBarBatchRevertCommand', type: 'any' }, 'icon': { value: 'lw-icon-reload', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: true, type: 'any' } }, type: 'object' } }, type: 'object' } }, type: 'object' }, 'commandColumn': { value: { 'visible': { value: false, type: 'boolean' }, 'inline': { value: false, type: 'boolean' }, 'position': { value: 'far', allowedValues: [ 'near', 'far' ], type: 'string' }, 'displayMode': { value: 'icon', allowedValues: [ 'label', 'icon', 'labelAndIcon' ], type: 'string' }, 'dataSource': { value: { 'commandColumnMenu': { value: { 'command': { value: 'commandColumnMenuCommand', type: 'any' }, 'icon': { value: 'lw-icon-menu', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: false, type: 'any' } }, type: 'object' }, 'commandColumnEdit': { value: { 'command': { value: 'commandColumnEditCommand', type: 'any' }, 'icon': { value: 'lw-icon-mode-edit', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: 'auto', type: 'any' } }, type: 'object' }, 'commandColumnDelete': { value: { 'command': { value: 'commandColumnDeleteCommand', type: 'any' }, 'icon': { value: 'lw-icon-delete', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: true, type: 'any' } }, type: 'object' }, 'commandColumnUpdate': { value: { 'command': { value: 'commandColumnUpdateCommand', type: 'any' }, 'icon': { value: 'lw-icon-ok-squared', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: 'auto', type: 'any' } }, type: 'object' }, 'commandColumnCancel': { value: { 'command': { value: 'commandColumnCancelCommand', type: 'any' }, 'icon': { value: 'lw-icon-cancel-circled', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: 'auto', type: 'any' } }, type: 'object' }, 'commandColumnRowMenu': { value: { 'command': { value: 'commandColumnRowMenuCommand', type: 'any', reflectToAttribute: false }, 'icon': { value: 'lw-icon-ellipsis-vert', type: 'string' }, 'label': { value: '{{messages}}', type: 'string' }, 'visible': { value: false, type: 'any' } }, type: 'object' }, 'commandColumnCustom': { value: { 'command': { value: '', type: 'any' }, 'icon': { value: 'lw-icon-ellipsis-vert', type: 'string' }, 'label': { value: '', type: 'string' }, 'visible': { value: false, type: 'any' } }, type: 'object' } }, type: 'object' }, 'width': { value: null, type: 'number?' } }, reflectToAttribute: false, type: 'object' }, 'mode': { value: 'cell', allowedValues: [ 'cell', 'row' ], type: 'string' }, 'addNewRow': { value: { 'position': { value: 'both', allowedValues: [ 'near', 'far', 'both' ], type: 'string' }, 'visible': { value: false, type: 'boolean' }, 'autoCreate': { value: false, type: 'boolean' }, 'autoSave': { value: true, type: 'boolean' }, 'label': { value: '{{message}}', type: 'string' }, 'displayMode': { value: 'row', allowedValues: [ 'row', 'button' ], type: 'string' } }, type: 'object' }, 'dialog': { value: { 'header': { value: '{{message}}', type: 'string' }, 'height': { value: 'auto', type: 'any' }, 'width': { value: 'auto', type: 'any' }, 'left': { value: 'center', type: 'any' }, 'top': { value: 'center', type: 'any' }, 'enabled': { value: false, type: 'boolean' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' }, 'addDialog': { value: { 'header': { value: '{{message}}', type: 'string' }, 'height': { value: 'auto', type: 'any' }, 'width': { value: 'auto', type: 'any' }, 'left': { value: 'center', type: 'any' }, 'top': { value: 'center', type: 'any' }, 'enabled': { value: false, type: 'boolean' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' }, 'deleteDialog': { value: { 'header': { value: '{{message}}', type: 'string' }, 'height': { value: 'auto', type: 'any' }, 'width': { value: 'auto', type: 'any' }, 'left': { value: 'center', type: 'any' }, 'top': { value: 'center', type: 'any' }, 'enabled': { value: false, type: 'boolean' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' } }, type: 'object' }, 'paging': { value: { 'enabled': { value: false, type: 'boolean' }, 'spinner': { value: { 'enabled': { value: false, type: 'boolean' }, 'step': { value: 1, type: 'number' } }, type: 'object' }, 'pageSize': { value: 10, type: 'int', validator: 'pageSizeValidator' }, 'pageIndex': { value: 0, type: 'int', validator: 'pageIndexValidator' } }, type: 'object' }, 'pager': { value: { 'autoEllipsis': { value: 'both', allowedValues: [ 'none', 'before', 'after', 'both' ], type: 'string' }, 'position': { value: 'far', allowedValues: [ 'near', 'far', 'both' ], type: 'string' }, 'template': { value: '', type: 'string' }, 'pageSizeSelector': { value: { 'visible': { value: false, type: 'boolean' }, 'dataSource': { value: [ 10, 20, 50 ], type: 'object' }, 'position': { value: 'far', allowedValues: [ 'near', 'far' ], type: 'string' } }, type: 'object' }, 'summary': { value: { 'position': { value: 'far', allowedValues: [ 'near', 'far' ], type: 'string' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' }, 'navigationButtons': { value: { 'position': { value: 'both', allowedValues: [ 'near', 'far', 'both' ], type: 'string' }, 'prevNextButtons': { value: { 'visible': { value: true, type: 'boolean' } }, type: 'object' }, 'firstLastButtons': { value: { 'visible': { value: true, type: 'boolean' } }, type: 'object' }, 'labels': { value: { 'visible': { value: false, type: 'boolean' } }, type: 'object' } }, type: 'object' }, 'navigationInput': { value: { 'position': { value: 'far', allowedValues: [ 'near', 'far' ], type: 'string' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' }, 'pageIndexSelectors': { value: { 'visible': { value: true, type: 'boolean' }, 'dataSource': { value: 10, type: 'any' }, }, type: 'object' }, 'visible': { value: false, type: 'boolean' } }, type: 'object', reflectToAttribute: false }, 'rowDetail': { value: { 'enabled': { value: false, type: 'boolean' }, 'height': { value: 200, type: 'number' }, 'position': { value: 'near', allowedValues: [ 'near', 'far' ], type: 'string' }, 'template': { value: '', type: 'any', reflectToAttribute: false }, 'visible': { value: true, type: 'boolean' }, 'dialog': { value: { 'header': { value: '{{message}}', type: 'string' }, 'height': { value: 300, type: 'any' }, 'width': { value: 360, type: 'any' }, 'left': { value: 'center', type: 'any' }, 'top': { value: 'center', type: 'any' }, 'enabled': { value: false, type: 'boolean' }, 'visible': { value: false, type: 'boolean' } }, type: 'object' } }, type: 'object' }, 'summaryRow': { value: { 'position': { value: 'far', allowedValues: [ 'near', 'far' ], type: 'string' }, 'visible': { value: false, type: 'boolean' }, 'template': { value: '', type: 'string' } }, type: 'object' }, 'scrolling': { value: 'physical', allowedValues: [ 'physical', 'virtual', 'infinite', 'deferred' ], type: 'string' }, 'columnHeader': { value: { 'visible': { value: true, type: 'boolean' } }, type: 'object' }, 'groupHeader': { value: { 'visible': { value: false, type: 'boolean' }, 'template': { value: '', type: 'string' } }, type: 'object' }, 'header': { value: { 'visible': { value: false, type: 'boolean' }, 'template': { value: '', type: 'string' }, 'buttons': { value: ['columns', 'filter', 'group', 'sort', 'search'], type: 'array' } }, type: 'object' }, 'footer': { value: { 'visible': { value: false, type: 'boolean' }, 'template': { value: '', type: 'string' } }, type: 'object' }, 'checkBoxes': { value: { 'visible': { value: false, type: 'boolean' }, 'hasThreeStates': { value: false, type: 'boolean' } }, type: 'object' }, 'selection': { value: { 'enabled': { value: false, type: 'boolean' }, 'allowRowHeaderSelection': { value: false, type: 'boolean' }, 'allowColumnHeaderSelection': { value: false, type: 'boolean' }, 'allowRowSelection': { value: true, type: 'boolean' }, 'allowCellSelection': { value: false, type: 'boolean' }, 'allowDragSelection': { value: true, type: 'boolean' }, 'allowDragSelectionAutoScroll': { value: true, type: 'boolean' }, 'allowCellDragSelectionHandle': { value: true, type: 'boolean' }, 'allowCellDragDropSelectionHandle': { value: true, type: 'boolean' }, 'allowCellDragSelectionAutoFill': { value: true, type: 'boolean' }, 'selectAllMode': { value: 'page', allowedValues: [ 'none', 'page', 'all' ], type: 'string' }, 'mode': { value: 'many', type: 'string', allowedValues: [ 'one', 'many', 'extended' ] }, 'action': { value: 'click', type: 'string', allowedValues: [ 'none', 'click', 'doubleClick' ] }, 'checkBoxes': { value: { 'enabled': { value: false, type: 'boolean' }, 'autoShow': { value: false, type: 'boolean' }, 'action': { value: 'click', type: 'string', allowedValues: [ 'none', 'click', 'doubleClick' ] }, 'selectAllMode': { value: 'page', allowedValues: [ 'none', 'page', 'all' ], type: 'string' }, 'position': { value: 'near', allowedValues: [ 'near', 'far' ], type: 'string' } }, type: 'object' }, 'selected': { value: '', type: 'string' } }, type: 'object' }, 'sorting': { value: { 'enabled': { value: false, type: 'boolean' }, 'sort': { value: [], type: 'array' }, 'mode': { value: 'one', allowedValues: [ 'one', 'many' ], type: 'string' }, 'sortToggleThreeStates': { value: true, type: 'boolean' } }, type: 'object' } } } static get requires() { return {/* 'LW.Button': 'lw.button.js', 'LW.ScrollBar': 'lw.scrollbar.js', 'LW.Menu': 'lw.menu.js', 'LW.Calendar': 'lw.calendar.js', 'LW.TimePicker': 'lw.timepicker.js', 'LW.DateTimePicker': 'lw.datetimepicker.js', 'LW.Tree': 'lw.tree.js', 'LW.Utilities.Complex': 'lw.complex.js', 'LW.Utilities.BigNumber': 'lw.math.js', 'LW.Utilities.NumericProcessor': 'lw.numeric.js', 'LW.NumericTextBox': 'lw.numerictextbox.js', 'LW.Pager': 'lw.pager.js', 'LW.ListBox': 'lw.listbox.js', 'LW.DropDownList': 'lw.dropdownlist.js', 'LW.ComboBox': 'lw.combobox.js', 'LW.Utilities.DateTime': 'lw.date.js', 'LW.FilterBuilder': 'lw.filterbuilder.js', 'LW.FilterPanel': 'lw.filterpanel.js' */ } } static get styleUrls() { return [ 'lw.menu.css', 'lw.filterpanel.css', 'lw.pager.css', 'lw.grid.css', 'lw.textbox.css' ] } /** Button's template. */ template() { return `<div class=\'lw-container\'id=\'container\' disabled=\'[[disabled]]\' role=\'grid\'> <div id=\'header\' role="toolbar" class=\'lw-grid-header lw-hidden\'> </div> <div id=\'groupHeader\' role="presentation" class=\'lw-grid-group-header lw-hidden\'></div> <div id=\'headerPager\' top class=\'lw-grid-pager lw-hidden\'></div> <div id=\'headerCommandBar\' header top class=\'lw-grid-header lw-grid-command-bar lw-hidden\'></div> <div id=\'content\' class=\'lw-grid-content\'> <div id=\'placeholder\' class =\'lw-hidden lw-placeholder lw-grid-placeholder\'></div> <div id=\'columnHeader\' role="rowgroup" class=\'lw-grid-column-header\'> <div id=\'columnNearContainer\' role="row" class=\'near lw-hidden lw-grid-column-header-cell-container\'> </div> <div id=\'columnContainer\' role="row" class=\'center lw-grid-column-header-cell-container\'> </div> <div id=\'columnFarContainer\' role="row" class=\'far lw-hidden lw-grid-column-header-cell-container\'> </div> </div> <div id=\'scrollView' role="rowgroup" class =\'lw-grid-scroll-view\'> <div id=\'rowNearContainer\' role="presentation" class=\'near lw-hidden lw-grid-row-container\'> </div> <div id=\'rowContainer\' role="presentation" class=\'center lw-grid-row-container\'> </div> <div id=\'rowFarContainer\' role="presentation" class=\'far lw-hidden lw-grid-row-container\'> </div> <lw-scroll-bar right-to-left="[[rightToLeft]]" id=\'verticalScrollBar\' class=\'lw-grid-scroll-bar\' wait disabled=\'[[disabled]]\' orientation=\'vertical\'></lw-scroll-bar> <lw-scroll-bar right-to-left="[[rightToLeft]]" id=\'horizontalScrollBar\' class=\'lw-grid-scroll-bar\' wait disabled=\'[[disabled]]\'></lw-scroll-bar> </div> <div id=\'filterFooter\' class=\'lw-grid-filter-footer lw-hidden\'></div> </div> <div id=\'loadingIndicatorContainer\' class=\'lw-loader-container\'> <span id=\'loadingIndicator\' class=\'lw-grid-loader lw-loader\'></span> <span id=\'loadingIndicatorPlaceholder\' class =\'lw-loader-label lw-hidden\'></span> </div> <div id=\'footerCommandBar\' footer class=\'lw-grid-footer lw-grid-command-bar lw-hidden\'></div> <div id=\'footerPager\' class=\'lw-grid-pager lw-hidden\'></div> <div id=\'footer\' class=\'lw-grid-footer lw-hidden\'></div> </div>`; } /** * Grid's event listeners. */ static get listeners() { return { 'focus': '_focusHandler', 'blur': '_blurHandler', 'wheel': '_mouseWheelHandler', 'document.up': '_upHandler', 'document.move': '_moveHandler', 'document.scroll': '_scrollHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler', 'resize': '_resizeHandler', 'header.click': '_headerClickHandler', 'columnHeader.down': '_columnDownHandler', 'columnHeader.click': '_columnClickHandler', 'columnHeader.move': '_columnMoveHandler', 'columnHeader.mouseleave': '_columnMouseLeaveHandler', 'rowNearContainer.down': '_rowDownHandler', 'rowContainer.down': '_rowDownHandler', 'rowFarContainer.down': '_rowDownHandler', 'container.selectstart': '_selectStartHandler', 'styleChanged': '_styleChangedHandler', 'swipeleft': '_swipeLeftHandler', 'swiperight': '_swipeRightHandler' }; } get _tabindex() { const that = this; return that.disabled || that.unfocusable ? '' : ' tabindex="0"'; } pageSizeValidator( oldValue, newValue ) { const that = this; if ( newValue < 0 ) { return 0; } if ( that.dataSource && newValue > that.dataSource.length ) { return that.dataSource.length; } } pageIndexValidator( oldValue, newValue ) { const that = this; if ( newValue < 0 ) { return 0; } if ( that.dataSource ) { const maxPageIndex = Math.ceil( that.dataSource.length / that.paging.pageSize ); if ( newValue > maxPageIndex - 1 ) { return maxPageIndex - 1; } } } _offsetTop( element ) { const that = this; if ( !element ) { return 0; } return element.offsetTop + that._offsetTop( element.offsetParent ); } _offsetLeft( element ) { const that = this; if ( !element ) { return 0; } return element.offsetLeft + that._offsetLeft( element.offsetParent ); } offset( element ) { return {left: this._offsetLeft( element ), top: this._offsetTop( element )} } getBoundingRect( element ) { const that = this; let offsetX = window.pageXOffset, offsetY = window.pageYOffset, rect = element.getBoundingClientRect(); if ( element !== document.body ) { let parent = element.parentNode; while ( parent !== document.body ) { if (parent) { offsetX += parent.scrollLeft; offsetY += parent.scrollTop; } let currentParent = parent; parent = parent.parentNode; if ( that.enableShadowDOM && parent === that.shadowRoot ) { parent = that; } else if ( that.isInShadowDOM && (parent === that.getRootNode() || currentParent === that.getRootNode() )) { parent = that.getRootNode().host; } } } return { bottom: rect.bottom + offsetY, height: rect.height, left: rect.left + offsetX, right: rect.right + offsetX, top: rect.top + offsetY, width: rect.width }; } _upHandler( event ) { const that = this; const boundingRect = that.getBoundingRect( that ); super._upHandler(); if ( that._tapTimer ) { clearTimeout( that._tapTimer ); } if ( event.pageX < boundingRect.left || event.pageX > boundingRect.right || event.pageY < boundingRect.top || event.pageY > boundingRect.bottom ) { if ( that._inputOverlay ) { that._inputOverlay.classList.remove( 'lw-input-overlay-on' ); setTimeout( () => { if ( that._inputOverlay ) { if ( that._inputOverlay.parentNode ) { that._inputOverlay.parentNode.removeChild( that._inputOverlay ); } that._inputOverlay = null; } }, that.behavior.doubleClickTimingDelay ); } if ( that.editing.isEditing && !that.editing.dialog.enabled ) { setTimeout( () => { if ( event.defaultPrevented ) { return; } if ( that.editing.editCell && that.editing.editCell.editor.instance ) { that.editing.editCell.editor.instance.blur( event ); if ( event.defaultPrevented ) { return; } } that.endEdit(); }, 50 ); } if ( that.menu ) { let target, isInsideGrid, isInsideMenu, menuContainer; if ( that.enableShadowDOM || that.isInShadowDOM ) { target = event.originalEvent.composedPath()[ 0 ]; isInsideGrid = function () { let host = target.getRootNode().host; while ( host ) { if ( host === that ) { return host; } host = host.getRootNode().host; } }(); isInsideMenu = that.menu.contains( target ) || that.menu.firstElementChild.shadowRoot.contains( target ); menuContainer = that.menu.firstElementChild.shadowRoot; } else { target = event.originalEvent.target; isInsideGrid = that.contains( target ); isInsideMenu = that.menu.contains( target ); menuContainer = that.menu; } if ( !isInsideGrid && !isInsideMenu ) { const dropDownLists = menuContainer.querySelectorAll( 'lw-drop-down-list' ); const dateTimePickers = menuContainer.querySelectorAll( 'lw-date-time-picker' ); for ( let i = 0; i < dropDownLists.length; i++ ) { const dropDownList = dropDownLists[ i ]; const dropDown = dropDownList.$.dropDownContainer; if ( dropDown.contains( target ) ) { return; } } for ( let i = 0; i < dateTimePickers.length; i++ ) { const dateTimePicker = dateTimePickers[ i ]; const dropDown = dateTimePicker.$.dropDownContainer; if ( dropDown.contains( target ) ) { return; } } that.closeMenu(); return; } } } that._dragSelectionEnd( event ); that._endResize( event ); that._endDrag( event ); } _nextColumn( column ) { const that = this; for ( let i = 0; i < that.viewColumns.length; i++ ) { const currentColumn = that.viewColumns[ i ]; if ( currentColumn.visibleIndex === column.visibleIndex + 1 ) { return currentColumn; } } return null; } _nextRow( row ) { const that = this; const rows = that._recyclingRows; const rowIndex = rows.indexOf( row ); if ( rowIndex >= 0 ) { return rows[ rowIndex + 1 ]; } return null; } _moveHandler( event ) { const that = this; if ( !that.isInitialized ) { return; } if ( !that._selection ) { return; } if ( that.selection.enabled && that.selection.allowDragSelection && !that.editing.isEditing ) { if ( !that._selection.selectionRect || ( that._selection.selectionRect && !that._selection.selectionRect.captured ) ) { that._dragSelection( event ); const originalTarget = event.originalEvent.target.closest ? event.originalEvent.target : undefined; if ( LW.Utilities.Core.isMobile && originalTarget && originalTarget.closest( 'lw-grid' ) === that ) { event.originalEvent.preventDefault(); } } } if ( that.isScrolling ) { return; } if ( that.behavior.columnResizeMode !== 'none' && !that.classList.contains( 'lw-grid-row-resize-mode' ) ) { that._columnMoveResizeHandler( event ); } if ( that.behavior.rowResizeMode !== 'none' && !that.classList.contains( 'lw-grid-column-resize-mode' ) ) { that._rowMoveResizeHandler( event ); } that._drag( event ); } _columnMouseLeaveHandler() { const that = this; if ( !that._columnElements ) { return; } for ( let i = 0; i < that._columnElements.length; i++ ) { const element = that._columnElements[ i ]; const column = element.column; if ( column && column.autoShowActionButton ) { element._hideActionButton(); } } } _columnMoveHandler( event ) { const that = this; if ( !that.isInitialized ) { return; } if ( that._columnResizeStartLine || that._rowResizeStartLine ) { return; } for ( let i = 0; i < that._columnElements.length; i++ ) { const element = that._columnElements[ i ]; const column = element.column; if ( column && column.autoShowActionButton ) { const rect = element.getBoundingClientRect(); const offset = that.offset( element ); if ( offset.left <= event.pageX && offset.left + rect.width - 6 >= event.pageX ) { if ( offset.top <= event.pageY && offset.top + rect.height >= event.pageY ) { if ( !that.hasColumnMenu( column ) ) { continue; } element._showActionButton(); } else { element._hideActionButton(); } } else { element._hideActionButton(); } } } } _headerClickHandler(event) { const that = this; if (that.$.headerBar) { const target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; that.$.headerBar._headerClickHandler(target, that); } } _columnClickHandler( event ) { const that = this; const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); let columnDataField = null; let columnElement = null; const isDoubleClick = new Date() - that._clickTime < that.behavior.doubleClickTimingDelay; that._doubleClickHandler( event ); for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.classList.contains( 'lw-action-button' ) ) { return; } if ( element.getAttribute( 'data-field' ) ) { columnDataField = element.getAttribute( 'data-field' ); columnElement = element; break; } } if ( columnDataField ) { const column = columnElement.column; if ( !column ) { return; } if ( event.srcElement.classList.contains( 'lw-filter-button' ) ) { return; } if ( LW.Utilities.Core.isMobile ) { if ( isDoubleClick ) { if ( column.allowSortToggleOnClick && that.sorting.enabled ) { that.sortBy( columnDataField ); } } that._columnMoveHandler( event ); event.originalEvent.preventDefault(); } else { if ( column.allowSortToggleOnClick && that.sorting.enabled ) { that.sortBy( columnDataField ); } } } } _columnDownHandler( event ) { const that = this; const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( event.clientX, event.clientY ); let columnDataField = null; let columnElement = null; const isDoubleClick = new Date() - that._clickTime < that.behavior.doubleClickTimingDelay; if (that.$.headerBar) { that.$.headerBar.closePanel(); } that._doubleClickHandler( event ); for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.classList.contains( 'lw-action-button' ) ) { return; } if ( element.getAttribute( 'data-field' ) ) { columnDataField = element.getAttribute( 'data-field' ); columnElement = element; break; } } if ( columnDataField ) { const column = columnElement.column; if ( !column ) { return; } if ( columnDataField === '_commandColumn' ) { that._applyCommand( that.editing.commandColumn.dataSource.commandColumnMenu.command ); return } const selectColumn = function ( action ) { const canSelect = column.selectionColumn ? that.selection.checkBoxes.action === action && that.selection.enabled : that.selection.action === action && that.selection.enabled; if ( canSelect ) { if ( that.editing.enabled && that.editing.editColumn === column ) { return; } if ( !event.shiftKey && !event.ctrlKey ) { that._dragSelectionStartDataField = columnDataField; } else { that._dragSelectionStartDataField = null; } if ( columnDataField === '_checkBoxColumn' ) { that._toggleColumnSelection( column ); return; } that._setSelection( null, column.dataField, event ); } } if ( that.editing.isEditing ) { that.endEdit(); } that.$.fireEvent( 'columnClick', { 'column': column } ); selectColumn( 'click' ); if ( isDoubleClick ) { that.$.fireEvent( 'columnDoubleClick', { 'column': column } ); selectColumn( 'doubleClick' ); that._onColumnDoubleClick( column, event ); } if ( that._columnToResizeElement && !that._columnResizeLine ) { that._columnDownResizeHandler( event ); return; } that._beginDrag( event, column ); } that.closeMenu(); that._clickTime = new Date(); } addTransformMoveStyle( element, duration, x, y, z, opacity ) { element.style[ 'opacity' ] = opacity; element.style[ 'transition-duration' ] = duration; element.style[ 'transform' ] = 'translate3d(' + x + 'px,' + y + 'px,' + z + 'px)'; } removeTransformMoveStyle( element ) { element.style[ 'opacity' ] = ''; element.style[ 'transition-duration' ] = ''; element.style[ 'transform' ] = ''; } _rowDownHandler( event ) { const that = this; if ( that._inputOverlay ) { that._inputOverlay.classList.remove( 'lw-input-overlay-on' ); } that._doubleClickHandler( event ); that._closeMenu( that.menu ); that._rowResizeHandler( event ); if ( that._toggledRow && that.appearance.allowRowToggleAnimation ) { return; } if ( !event.target.classList.contains( 'lw-grid-row-container' ) && !event.target.classList.contains( 'lw-grid-selection-overlay' ) && !event.target.classList.contains( 'lw-selection-overlay-content' ) ) { return; } let clientX = event.clientX; let clientY = event.clientY; if ( event.touches ) { clientX = event.touches[ 0 ].clientX; clientY = event.touches[ 0 ].clientY; } const elements = ( that.enableShadowDOM ? that.shadowRoot : that.getRootNode() ).elementsFromPoint( clientX, clientY ); let rowElement = null; let toggleButton = null; let checkbox = null; let cellElement = null; //const refresh = function () { // const scrollLeft = that._scrollView.scrollLeft; // that._refreshLayout(); // that._recycle(); // that._scrollView.scrollLeft = scrollLeft; //} that._lastPointerDownTime = new Date(); for ( let i = 0; i < elements.length; i++ ) { const element = elements[ i ]; if ( element.hasAttribute( 'toggle-button' ) ) { toggleButton = element; } if ( element.hasAttribute( 'checkbox' ) ) { checkbox = element; } if ( !cellElement && element.nodeName.toLowerCase() === 'lw-grid-cell' ) { cellElement = element; } if ( !rowElement && element.nodeName.toLowerCase() === 'lw-grid-row' ) { rowElement = element; break; } } if ( rowElement && cellElement ) { const cell = cellElement ? cellElement.cell : null; if ( !cell.row.filterRow ) { that._closeMenu( that.filterRowMenu ); } if ( toggleButton && cell && !cell.column.rowDetailColumn ) { const row = rowElement.row; row.toggle( event ); } else if ( that.rowDetail.enabled && that.rowDetail.visible && toggleButton && cell && cell.column.rowDetailColumn ) { const row = rowElement.row; if ( row.showDetail ) { that.hideDetail( row.id ); } else { that.showDetail( row.id ); } } else { const row = rowElement.row; const cell = cellElement ? cellElement.cell : null; if ( cell.column._treeColumn && checkbox ) { row.checked = !row.checked; } if ( cell.element === row.header && that.behavior.allowRowReorder ) { that._beginDrag( event, row ); } that.$.fireEvent( 'rowClick', { 'row': row, originalEvent: event.originalEvent } ); that.$.fireEvent( 'cellClick', { 'cell': cell, originalEvent: event.originalEvent } ); if ( that._tapTimer ) { clearTimeout( that._tapTimer ); } that._tapTimer = setTimeout( function () { if ( that._clickedRow === rowElement ) { that.$.fireEvent( 'rowTap', { 'row': row, originalEvent: event.originalEvent } ); } if ( that._clickedCell === cellElement ) { that.$.fireEvent( 'cellTap', { 'cell': cell, originalEvent: event.originalEvent } ); } }, that.behavior.doubleClickTimingDelay ); //const isEditing = that.editing.isEditing; const selectRow = function ( action ) { if ( !that.selection.enabled || row.autoGenerated || row.allowSelect !== true ) { delete that.__selectionStarted; return; } const isEditing = that.editing.isEditing; if ( isEditing && that.editing.editCell && that.editing.editCell.row.id === row.id && that.editing.editCell.column.dataField === cell.column.dataField ) { return; } if ( isEditing && that.editing.editRow && that.editing.editRow.id === row.id ) { return; } const focus = () => { that.focus(); setTimeout( function () { that.focus(); }, 50 ); } if ( that.selection.action === action ) { if ( !event.shiftKey && !event.ctrlKey ) { if ( !that.selection.allowRowHeaderSelection && cell.column.autoGenerated ) { that._dragSelectionStartRow = null; } else { that._dragSelectionStartRow = rowElement.row; } } else { that._dragSelectionStartRow = null; } if ( !event.shiftKey && !event.ctrlKey ) { that._dragSelectionStartDataField = cell.column.dataField; } else { that._dragSelectionStartDataField = null; } if ( cell.column.rowHeaderColumn && !that.selection.allowRowHeaderSelection ) { that._dragSelectionStartRow = null; focus(); return; } that._setSelection( row.id, cell.column.dataField, event ); focus(); } else if ( cell.column.selectionColumn && that.selection.checkBoxes.enabled && that.selection.checkBoxes.action === action ) { that._setSelection( row.id, cell.column.dataField, event ); focus(); } } const isSelected = cell.selected; //const focusedCell = that._selection.focusedCell; const quickClick = that._clickedCell === cellElement && new Date() - that._clickTime < that.behavior.doubleClickTimingDelay; selectRow( 'click' ); if ( row.autoGenerated || ( cell.column.autoGenerated || cell.template ) ) { that._onRowClick( row.index, row, event ); that._onCellClick( cell, event ); } else { if ( that.selection.enabled ) { if ( that.selection.allowCellSelection ) { if ( that.selection.mode === 'extended' ) { if ( isSelected === true && isSelected === cell.selected && !that.selection.isDragging && quickClick ) { that._onRowClick( row.index, row, event ); that._onCellClick( cell, event ); } } else if ( quickClick ) { that._onRowClick( row.index, row, event ); that._onCellClick( cell, event ); } } else if ( that.selection.allowRowSelection ) { if ( that.selection.mode === 'extended' ) { if ( isSelected === true && isSelected === cell.selected && !that.selection.isDragging && quickClick ) { that._onRowClick( row.index, row, event ); that._onCellClick( cell, event ); } } else if ( quickClick ) { that._onRowClick( row.index, row, event ); that._onCellClick( cell, event ); } } else { that._onRowClick( row.index, row, event ); that._onCellClick( cell, event ); } } else { that._onRowClick( row.index, row, event ); that._onCellClick( cell, event ); } } if ( new Date() - that._clickTime < that.behavior.doubleClickTimingDelay ) { if ( that._clickedRow === rowElement ) { that._onRowDoubleClick( row.index, row, event, event ); that.$.fireEvent( 'rowDoubleClick', { 'row': row, originalEvent: event.originalEvent } ); selectRow( 'doubleClick' ); } if ( that._clickedCell === cellElement ) { that._onCellDoubleClick( cell, event ); that.$.fireEvent( 'cellDoubleClick', { 'cell': cell, originalEvent: event.originalEvent } ); } } that._clickedRow = rowElement; that._clickedCell = cellElement; that._clickTime = new Date(); } } } showDetail( id ) { const that = this; const row = that.rowById[ id ]; if ( !row ) { return; } row.showDetail = true; } hideDetail( id ) { const that = this; const row = that.rowById[ id ]; if ( !row ) { return; } row.showDetail = false; } _focusHandler() { const that = this; that._focused = true; } _blurHandler() { const that = this; that._focused = false; } _notify( propertyName, oldValue, newValue ) { const that = this; if ( that.notifyFn ) { for ( let i = 0; i < that.notifyFn.length; i++ ) { that.notifyFn[ i ]( propertyName, oldValue, newValue ); } } } notify( notifyFn ) { const that = this; if ( notifyFn ) { if ( !that.notifyFn ) { that.notifyFn = []; } that.notifyFn.push( notifyFn ); } } _applyTemplate( selector, element ) { //const that = this; let template = null; if ( selector === null || selector === '' ) { element.innerHTML = ''; return; } if ( selector.startsWith( '#' ) || selector.startsWith( '.' ) ) { template = document.querySelector( selector ); } if ( template ) { element.innerHTML = ''; element.appendChild( template.content.cloneNode( true ).firstElementChild ); } else { const htmlToElement = function ( html ) { const template = document.createElement( 'template' ); html = html.trim(); // Never return a text node of whitespace as the result template.innerHTML = html; return template.content.firstChild; } const templateElement = htmlToElement( selector ); if ( templateElement ) { element.innerHTML = ''; element.appendChild( templateElement ); } } } /** * Updates the listbox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler( propertyName, oldValue, newValue ) { const that = this; if ( !that.isInitialized ) { return; } that._notify( propertyName, oldValue, newValue ); switch ( propertyName ) { case 'appearance_displayLoadingIndicator': { return; } case 'appearance_placeholder': that.$.placeholder.innerHTML = newValue; return; case 'appearance_showColumnHeaderLines': case 'appearance_showColumnLines': case 'appearance_showRowLines': { that._recycle(); return; } case 'appearance_allowColumnStickyPosition': { if ( newValue ) { that._stickHeader(); } else { that._unstickHeader(); } break; } case 'appearance_showColumnIcon': { for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; column.setProperty( 'showIcon', that.appearance.showColumnIcon ); } that._recycle(); break; } case 'appearance_showRowHeaderNumber': case 'appearance_showRowHeader': { that._initializeRowNumberColumn(); const column = that._frozenNearColumns[ 0 ]; if ( column.rowHeaderColumn && column.element && !column.element.parentNode ) { that.$.columnNearContainer.appendChild( column.element ); } that.refresh(); break; } case 'header_template': { that._applyTemplate( newValue, that.$.header ); break; } case 'footer_template': { that._applyTemplate( newValue, that.$.footer ); break; } case 'columnWidth': { that.columns.canNotify = false; let width = parseInt( newValue ); if ( isNaN( width ) ) { width = null; } if ( width >= 30 || width === null ) { for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; column.width = width; } } that.columns.canNotify = true; that.refresh(); break; } case 'checkBoxes_visible': { that._recycle(); return; } case 'checkBoxes_hasThreeStates': { that.rows.canNotify = false; that._applyThreeStates( that.rowHierarchy ); that.rows.canNotify = true; that._recycle(); return; } case 'columnHeader_visible': { that.__columnHeaderHeight = null; that.refresh(); break; } case 'selection_checkBoxes_enabled': { that._selectionColumn.visible = newValue; break; } case 'selection_checkBoxes_autoShow': { if ( that._selectionColumn.element ) { if ( newValue ) { that._selectionColumn.element.setAttribute( 'auto-show', '' ); } else { that._selectionColumn.element.removeAttribute( 'auto-show' ); } } break; } case 'selection_checkBoxes_position': { let index = that.viewColumns.indexOf( that._selectionColumn ); that.viewColumns.canNotify = false; that.viewColumns.splice( index, 1 ); const nearIndex = that._frozenNearColumns.indexOf( that._selectionColumn ); const farIndex = that._frozenFarColumns.indexOf( that._selectionColumn ); if ( nearIndex >= 0 ) { that._frozenNearColumns.splice( nearIndex, 1 ); } if ( farIndex >= 0 ) { that._frozenFarColumns.splice( farIndex, 1 ); } if ( newValue === 'far' ) { that._selectionColumn.canNotify = false; that._selectionColumn.freeze = 'far'; that._selectionColumn.canNotify = true; that._frozenFarColumns.splice( 0, 0, that._selectionColumn ); that.viewColumns.push( that._selectionColumn ); that.$.columnFarContainer.appendChild( that._selectionColumn.element ); } else { let autoGeneratedNearColumns = 0; let index = 0; for ( let i = 0; i < that.viewColumns.length; i++ ) { if ( !that.viewColumns[ i ].autoGenerated && that.viewColumns[ i ].dataField === that.columns[ index++ ].dataField ) { break; } if ( that.viewColumns[ i ].autoGenerated ) { autoGeneratedNearColumns++; } } that._selectionColumn.canNotify = false; that._selectionColumn.freeze = 'near'; that._selectionColumn.canNotify = true; that._frozenNearColumns.splice( autoGeneratedNearColumns, 0, that._selectionColumn ); that.viewColumns.splice( autoGeneratedNearColumns, 0, that._selectionColumn ); that.$.columnNearContainer.appendChild( that._selectionColumn.element ); } that.viewColumns.canNotify = true; break; } case 'selection_mode': if ( that._selection ) { that._selection.focusedCell = null; } if ( that.selection.allowCellSelection ) { that.clearSelection(); } else { if ( newValue === 'one' ) { const selection = that.getSelection(); that.clearSelection(); if ( selection.rows && selection.rows[ 0 ] ) { selection.rows[ 0 ].row.selected = true; that._selection.focusedCell = that.rowById[ selection.rows[ 0 ].row.id ].getCell( that.columns[ 0 ].dataField ); } } } break; case 'filtering_enabled': if ( newValue ) { that._createFilterPanels(); } return; case 'filtering_filter': for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; column.canNotify = false; column.setProperty( 'filter', null ); column.canNotify = true; } for ( let j = 0; j < that.filtering.filter.length; j++ ) { const filter = that.filtering.filter[ j ]; if ( filter ) { const dataField = filter[ 0 ]; const filterExpression = filter.splice( 1 ); let filterGroup = null; if ( filterExpression instanceof LW.FilterGroup ) { filterGroup = filterExpression; } else { const column = that.columnByDataField[ dataField ]; if ( column ) { filterGroup = that.dataSource._createFilter( column.dataType, filterExpression ); } } if ( filterGroup ) { that.addFilter( dataField, filterGroup, false ); } } } that.refreshFilters(); return; case 'messages': case 'locale': { if ( that._dialogEdit ) { that._dialogEdit.close(); that._dialogEdit = null; } if ( that._dialogDelete ) { that._dialogDelete.close(); that._dialogDelete = null; } if ( that._dialogAddRow ) { that._dialogAddRow.close(); that._dialogAddRow = null; } that._recycle(); break; } case 'paging_spinner_enabled': { that._refresh(); break; } case 'pager_visible': that._renderPagers(); that._refreshPaging( false ); return; case 'paging_pageIndex': case 'pager_position': case 'paging_enabled': that._refreshPaging( true ); return; case 'paging_pageSize': that._refreshPaging( false ); return; case 'columns': { that._renderColumns(); return; } case 'dataSource': { delete that._isFirstVirtualDataSourceRequest; that.dataBind(); return; } case 'rowDetail_dialog_width': case 'rowDetail_dialog_height': case 'rowDetail_dialog_enabled': case 'rowDetail_dialog_visible': { return; } case 'rowDetail_height': case 'rowDetail_enabled': { that.beginUpdate(); that.rows.canNotify = false; const allowRowDetailToggleAnimation = that.appearance.allowRowDetailToggleAnimation; that.appearance.allowRowDetailToggleAnimation = false; for ( let i = 0; i < that._recyclingRows.length; i++ ) { const row = that._recyclingRows[ i ]; row.height = null; row.setProperty( 'showDetail', false ); row.detailHeight = that.rowDetail.height; } that.rows.canNotify = true; if ( !that.rowDetail.enabled ) { for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( column.rowDetailColumn ) { column.visible = false; break; } } } that.appearance.allowRowDetailToggleAnimation = allowRowDetailToggleAnimation; that.endUpdate(); return; } case 'rowDetail_visible': { for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( column.rowDetailColumn ) { column.visible = newValue; break; } } return; } case 'displayLoadingIndicator': { that._setLoadingIndicatorVisibility(); return; } case 'filterable': { that._refreshLayout(); return; } case 'rightToLeft': { that.refresh(); return; } case 'selectionMode': { return; } case 'editing_addNewRow_visible': { that._renderAddNewRow(); that.refresh(); break; } case 'editing_addNewRow_position': { that._renderAddNewRow(); that.refresh(); return; } case 'editing_enabled': { if ( !newValue ) { that.setAttribute( 'aria-readonly', true ); } else { that.removeAttribute( 'aria-readonly' ); } break; } case 'editing_dialog_visible': { return; } case 'editing_commandColumn_visible': { that.refresh( true ); return; } } that.refresh(); } /** * ListBox ready method. */ ready() { super.ready(); const that = this; const vScrollBar = that._scrollView.vScrollBar; const hScrollBar = that._scrollView.hScrollBar; vScrollBar.hasStyleObserver = false; hScrollBar.hasStyleObserver = false; vScrollBar.hasResizeObserver = false; hScrollBar.hasResizeObserver = false; vScrollBar.wait = false; hScrollBar.wait = false; vScrollBar.onChange = that._verticalScrollbarHandler.bind( that ); hScrollBar.onChange = that._horizontalScrollbarHandler.bind( that ); that.setFocusable( true ); that.$.loadingIndicatorPlaceholder.innerHTML = that.appearance.loadingIndicatorPlaceholder; that.$.placeholder.innerHTML = that.appearance.placeholder; that._setLoadingIndicatorVisibility(); that._cellsMerge = []; that.checkLicense(); } checkLicense( log ) { const that = this; if ( ( that.grouping.enabled ) || ( that.selection.enabled && that.selection.allowCellSelection ) || ( that.rowDetail.enabled ) || ( that.charting.enabled ) || ( that.editing.enabled && that.editing.batch ) || ( that.editing.enabled && that.editing.mode === 'row' ) || ( that.editing.enabled && that.editing.addNewRow.visible ) || ( that.editing.enabled && that.editing.commandColumn.visible ) || ( that.scrolling === 'virtual' ) || ( that.sorting.enabled && that.sorting.mode === 'many' ) || log === true ) { super.checkLicense(); } } _createFilterPanels() { const that = this; if ( !that._filterPanels ) { that._filterPanels = []; } else if ( that._filterPanels.length > 0 ) { return; } if ( that.filtering.enabled && that._filterPanels.length === 0 ) { requestAnimationFrame( () => { const stringPanel = document.createElement( 'lw-filter-panel' ); const boolPanel = document.createElement( 'lw-filter-panel' ); const numericPanel = document.createElement( 'lw-filter-panel' ); const datePanel = document.createElement( 'lw-filter-panel' ); boolPanel.filterType = 'boolean'; numericPanel.filterType = 'numeric'; datePanel.filterType = 'date'; that._filterPanels[ 'bool' ] = boolPanel; that._filterPanels[ 'date' ] = datePanel; that._filterPanels[ 'numeric' ] = numericPanel; that._filterPanels[ 'string' ] = stringPanel; for ( let filterType in that._filterPanels ) { const filterPanel = that._filterPanels[ filterType ]; filterPanel.rightToLeft = that.rightToLeft; filterPanel.classList.add( 'lw-hidden' ); that.$.content.appendChild( filterPanel ); filterPanel.parentNode.removeChild( filterPanel ); } } ); } } _applyScrolling() { const that = this; const vScrollBar = that._scrollView.vScrollBar; requestAnimationFrame( () => { vScrollBar.largeStep = that.$.scrollView.offsetHeight; switch ( that.scrolling ) { case 'physical': case 'infinite': case 'virtual': vScrollBar.step = 10; vScrollBar.mechanicalAction = 'switchWhileDragging'; break; case 'deferred': vScrollBar.step = 10; vScrollBar.mechanicalAction = 'switchWhenReleased'; break; case 'logical': vScrollBar.step = that.layout.rowMinHeight; vScrollBar.mechanicalAction = 'switchWhileDragging'; break; } } ); } get _autoRowHeight() { const that = this; if ( that.__autoRowHeight ) { return that.__autoRowHeight; } let measuredHeight = that.layout.rowMinHeight; if ( !that.dataSource || ( that.dataSource && that.dataSource.length === 0 ) ) { return measuredHeight; } const row = new LW.Grid.Row( {index: 0, grid: that} ); const measureRowElement = row.createElement(); that.$.scrollView.appendChild( measureRowElement ); that.removeAttribute( 'grouped' ); that.removeAttribute( 'tree' ); if ( that.grouping.enabled && that.dataSource.groupBy && that.dataSource.groupBy.length > 0 && that.grouping.renderMode === 'advanced' ) { that.setAttribute( 'grouped', '' ); } else if ( that.dataSource.boundHierarchy ) { that.setAttribute( 'tree', '' ); } const data = { }; for ( let i = 0; i < that.dataSource.dataFields.length; i++ ) { const dataField = that.dataSource.dataFields[ i ]; data[ dataField.name ] = 'ABCDEFHIJLMNOPQRSTUVWXYZ1234567910|'; } row.data = data; row._isMeasureRow = true; row.render(); measureRowElement.style.height = ''; measureRowElement.style.lineHeight = ''; measuredHeight = Math.max( measureRowElement.offsetHeight, measuredHeight ); for ( let i = 0; i < measureRowElement.children.length; i++ ) { measureRowElement.children[ i ].style.height = ''; } for ( let i = 0; i < measureRowElement.children[ 1 ].children.length; i++ ) { measureRowElement.children[ 1 ].children[ i ].style.height = 'auto'; const cell = row.getCell( that.columns[ 0 ].dataField ); cell.render(); measuredHeight = Math.max( measuredHeight, 8 + measureRowElement.children[ 1 ].children[ i ].offsetHeight ); break; } that.$.scrollView.removeChild( measureRowElement ); that.__autoRowHeight = measuredHeight; return measuredHeight; } get _scrollHeight() { const that = this; let rows = that._recyclingRows; let scrollHeight = 0; let measuredHeight = that._autoRowHeight; let nearHeight = 0; let farHeight = 0; if ( that.__scrollHeight ) { return that.__scrollHeight; } if ( rows.length === 0 || that.columns.length === 0 ) { return 0; } that.rows.canNotify = false; const length = rows.length; for ( let i = 0; i < length; i++ ) { let row = rows[ i ]; if ( !row.visible || row.filtered === false ) { row.height = 0; row.cellHeight = 0; row.top = scrollHeight; continue; } let recalculateRowHeight = !row.height || !row.cellHeight || row.showDetail || row.height === 'auto' || row._height === 'auto' || that.layout.rowHeight === 'auto' || that.layout.isDirty; if ( recalculateRowHeight && !row.expandHeight ) { if ( !row.detailHeight ) { row.detailHeight = 200; } if ( !that.layout.rowHeight ) { if ( row.height === 'auto' || row._height === 'auto' ) { row.element = that._rowElements[ 0 ]; if ( row.element && row.element.classList.contains( 'lw-hidden' ) ) { row.element.classList.remove( 'lw-hidden' ) } const measuredAutoHeight = row.data && that.isRendered ? row._autoSize( row ) : measuredHeight; row.height = measuredAutoHeight; row._height = 'auto'; } else { row.height = measuredHeight; } if ( row.label !== undefined && !row.summaryRow && that.grouping.renderMode === 'advanced' ) { row.height = that.grouping.groupRowHeight; } if ( row.computedHeight ) { row.height = row.computedHeight; } row.cellHeight = row.height; if ( that.rowDetail.enabled && row.showDetail && !that.rowDetail.dialog.enabled ) { row.height += row.detailHeight; } } else if ( that.layout.rowHeight ) { if ( typeof that.layout.rowHeight === 'number' ) { if ( that.layout.rowHeight < that.layout.rowMinHeight ) { that.layout.rowHeight = that.layout.rowMinHeight; } row.height = that.layout.rowHeight; if ( row.computedHeight ) { row.height = row.computedHeight; } if ( row.label !== undefined && that.grouping.renderMode === 'advanced' ) { row.height = that.grouping.groupRowHeight; } row.cellHeight = row.height; if ( that.rowDetail.enabled && row.showDetail && !that.rowDetail.dialog.enabled ) { row.height += row.detailHeight; } } else if ( that.layout.rowHeight === 'auto' ) { if ( that.layout.rowHeight < that.layout.rowMinHeight ) { that.layout.rowHeight = that.layout.rowMinHeight; } row.element = that._rowElements[ 0 ]; if ( row.element && row.element.classList.contains( 'lw-hidden' ) ) { row.element.classList.remove( 'lw-hidden' ) } const measuredAutoHeight = row.data && that.isRendered ? row._autoSize( row ) : measuredHeight; row.height = measuredAutoHeight; if ( row.computedHeight ) { row.height = row.computedHeight; } if ( row.label !== undefined && that.grouping.renderMode === 'advanced' ) { row.height = that.grouping.groupRowHeight; } row.cellHeight = row.height; if ( that.rowDetail.enabled && row.showDetail && !that.rowDetail.dialog.enabled ) { row.height += row.detailHeight; } } else { that.layout.rowHeight( i, row ); if ( !row.height ) { row.height = measuredHeight; } row.cellHeight = row.height; if ( that.rowDetail.enabled && row.showDetail && !that.rowDetail.dialog.enabled ) { row.height += row.detailHeight; } } } if ( that._rowGap && i < that.rows.length - 1 ) { row.height += that._rowGap; } } if ( row.freeze === true || row.freeze === 'near' ) { nearHeight += row.height; } else if ( row.freeze === 'far' ) { farHeight += row.height; } if ( row.freeze ) { row.top = scrollHeight; continue; } if ( row.top !== scrollHeight ) { row.top = scrollHeight; } if ( row.expandHeight ) { scrollHeight += row.cellHeight; } else { scrollHeight += row.height; } } if ( that._summaryRowCount && that.summaryRow.visible ) { scrollHeight += ( that._summaryRowCount * measuredHeight ); } if ( that.filtering && that.filtering.filterRow.visible ) { nearHeight += measuredHeight; } that.__scrollHeight = scrollHeight; that.__frozenNearHeight = nearHeight; that.__frozenFarHeight = farHeight; that._scrollView.scrollHeight = scrollHeight - that.$.scrollView.offsetHeight + nearHeight + farHeight; scrollHeight = that.__scrollHeight + nearHeight + farHeight - 1; if ( that.grouping.enabled && that.dataSource.groupBy.length > 0 && that.grouping.groupIndent > 0 && that.grouping.renderMode === 'advanced' ) { scrollHeight += parseInt( that.grouping.groupIndent / 2 ); } that.__scrollHeight = scrollHeight; that.rows.canNotify = true; return scrollHeight; } _measureColumnHeight() { const that = this; if ( that.__measuredColumnHeight ) { return that.__measuredColumnHeight; } const header = document.createElement( 'lw-grid-column' ); header.style.height = 'auto'; header.style.position = 'static'; const columnHeaderCellContentElement = document.createElement( 'div' ); columnHeaderCellContentElement.classList.add( 'lw-label' ); columnHeaderCellContentElement.innerHTML = 'aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRwWxXyYzZ1234567890'; header.appendChild( columnHeaderCellContentElement ); that.$.columnHeader.appendChild( header ); let height = that.$.columnHeader.offsetHeight; that.$.columnHeader.removeChild( header ); if ( that._columnHeights && that._columnHeights.length > 1 ) { height = that._columnHeights[ 0 ]; } if ( height < that.columnMinHeight ) { height = that.columnMinHeight; } that.__measuredColumnHeight = height; return height; } _initializeColumnGroupsHierarchy() { const that = this; let totalMaxLevel = 0; that.$.columnContainer.innerHTML = ''; if ( that.columnGroups.length > 0 ) { for ( let i = 0; i < that.columnGroups.length; i++ ) { that.columnGroups[ i ].parent = null; that.columnGroups[ i ].groups = null; } for ( let i = 0; i < that.viewColumns.length; i++ ) { that.viewColumns[ i ].parent = null; that.viewColumns[ i ].groups = null; } const getParentGroup = function ( name ) { for ( let i = 0; i < that.columnGroups.length; i++ ) { let group = that.columnGroups[ i ]; if ( group.name === name ) return group; } return null; } const getColumns = function ( group ) { let columns = new Array(); if ( group.columnGroup ) { columns.push( group ); } if ( group.groups ) { for ( let i = 0; i < group.groups.length; i++ ) { if ( group.groups[ i ].columnGroup ) { columns.push( group.groups[ i ] ); } else { if ( group.groups[ i ].groups ) { let tmpcolumns = getColumns( group.groups[ i ] ); for ( let j = 0; j < tmpcolumns.length; j++ ) { columns.push( tmpcolumns[ j ] ); } } } } } return columns; } for ( let i = 0; i < that.columnGroups.length; i++ ) { let group = that.columnGroups[ i ]; if ( !group.groups ) { group.groups = null; } if ( group.parentGroup ) { let parentGroup = getParentGroup( group.parentGroup ); if ( parentGroup ) { group.parent = parentGroup; if ( !parentGroup.groups ) { parentGroup.groups = new Array(); } if ( parentGroup.groups.indexOf( group ) === -1 ) { parentGroup.groups.push( group ); } } } } for ( let i = 0; i < that.viewColumns.length; i++ ) { let group = that.viewColumns[ i ]; if ( group.columnGroup ) { let parentGroup = getParentGroup( group.columnGroup ); if ( parentGroup ) { if ( !parentGroup.groups ) { parentGroup.groups = new Array(); } group.parent = parentGroup; if ( parentGroup.groups.indexOf( group ) === -1 ) { parentGroup.groups.push( group ); } } } } for ( let i = 0; i < that.viewColumns.length; i++ ) { const group = that.viewColumns[ i ]; let initialgroup = group; group.level = 0; while ( initialgroup.parent ) { initialgroup = initialgroup.parent; group.level++; } initialgroup = group; let maxlevel = group.level; totalMaxLevel = Math.max( totalMaxLevel, group.level ); while ( initialgroup.parent ) { initialgroup = initialgroup.parent; if ( initialgroup ) { initialgroup.level = --maxlevel; } } } for ( let i = 0; i < that.columnGroups.length; i++ ) { const group = that.columnGroups[ i ]; const columns = getColumns( group ); group.columns = columns; let indexes = new Array(); let frozen = 0; let freezePosition = 'near'; if ( columns.length === 0 ) { frozen = -1; group.visible = false; } for ( let j = 0; j < columns.length; j++ ) { indexes.push( that.viewColumns.indexOf( columns[ j ] ) ); if ( columns[ j ].freeze ) { if ( columns[ j ].freeze === 'far' ) { freezePosition = 'far'; } frozen++; } } if ( frozen === columns.length ) { group.freeze = freezePosition; } else if ( frozen > 0 && frozen < columns.length ) { that.error( that.localize( 'frozenColumns', {elementType: 'Grid'} ) ); } indexes.sort( function ( value1, value2 ) { value1 = parseInt( value1 ); value2 = parseInt( value2 ); if ( value1 < value2 ) { return -1; } if ( value1 > value2 ) { return 1; } return 0; } ); for ( let index = 1; index < indexes.length; index++ ) { if ( indexes[ index ] !== indexes[ index - 1 ] + 1 ) { that.error( that.localize( 'columnGroups', {elementType: 'Grid'} ) ); } } } } that._columnGroupsLevel = 1 + totalMaxLevel; } _refreshColumnHeights() { const that = this; that.$.columnHeader.style.height = ''; that._viewColumnsHeight = that._measureColumnHeight(); that._columnHeights = []; let height = 0; for ( let i = 0; i < that._columnGroupsLevel; i++ ) { let currentHeight = that._viewColumnsHeight; if ( that.columnHeight ) { if ( typeof that.columnHeight === 'number' ) { currentHeight = that.columnHeight ? that.columnHeight : that._viewColumnsHeight; } else { currentHeight = that.columnHeight ? that.columnHeight( i ) : that._viewColumnsHeight; } } if ( currentHeight < that.columnMinHeight ) { currentHeight = that.columnMinHeight; } if ( !currentHeight ) { height += that._viewColumnsHeight; that._columnHeights.push( that._viewColumnsHeight ); } else { that._columnHeights.push( currentHeight ); height += currentHeight; } } that._columnHeaderHeight = that._columnGroupsLevel * that._viewColumnsHeight; that._columnHeaderHeight = height; that.$.columnHeader.style.height = that._columnHeaderHeight + 'px'; const getColumnTop = function ( column ) { let top = 0; for ( let i = 0; i < column.level; i++ ) { top += that._columnHeights[ i ]; } return top; } const getColumnHeight = function ( column ) { let top = getColumnTop( column ); let totalHeight = that._columnHeaderHeight - top; for ( let i = column.level + 1; i < that._columnHeights.length; i++ ) { const level = i; for ( let j = 0; j < that.viewColumns.length; j++ ) { const currentColumn = that.viewColumns[ j ]; let breakLoop = false; if ( currentColumn.level === level ) { let col = currentColumn; while ( col.parent ) { if ( col.parent === column ) { totalHeight = that._columnHeights[ level ]; breakLoop = true; break; } col = col.parent; } if ( breakLoop ) { break; } } } } return totalHeight; } for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; const height = getColumnHeight( column ); column.computedHeight = height; column.top = getColumnTop( column ); } for ( let j = 0; j < that._columnGroupsLevel - 1; j++ ) { for ( let i = 0; i < that.columnGroups.length; i++ ) { const group = that.columnGroups[ i ]; const level = group.level; if ( level !== j ) { continue; } if ( group.groups ) { const height = getColumnHeight( group ); const top = getColumnTop( group ); group.top = top; group.computedHeight = height; } const header = group.element; if ( !header ) { continue; } header.style.width = group.computedWidth + 'px'; if ( !that.rightToLeft ) { header.style.left = group.left + 'px'; } else { header.style.right = group.left + 'px'; } header.style.top = group.top + 'px'; header.style.height = group.computedHeight + 'px'; header.style.lineHeight = group.computedHeight + 'px'; } } } _refreshColumnWidths() { const that = this; that.__clientSize = null; const vScrollWidth = ( that.$.verticalScrollBar.offsetWidth > 0 ? that.$.verticalScrollBar.offsetWidth : 0 ); const groupByDataSource = that.dataSource.groupBy || []; let indent = that.grouping.enabled && that.grouping.renderMode === 'advanced' ? that.grouping.groupIndent * ( 1 + groupByDataSource.length ) : 0; let checkBoxesIndent = 0; if ( that.selection.checkBoxes.enabled ) { checkBoxesIndent = that._selectionColumn.computedWidth ? that._selectionColumn.computedWidth : that._selectionColumn.minWidth; } const gridWidth = that._clientSize.width - vScrollWidth - indent; // 375 is default for iPhone 6, 7, & 8, X. Switches to 1 column layout instead of 2 columns layout when this point is reached. //const phoneMinWidth = 375; //const columnAdaptive = gridWidth <= phoneMinWidth; let columnsComputedWidth = 0; let columnsWithAutoWidth = []; let nearWidth = 0; let farWidth = 0; let columnsWidth = 0; if ( that.editing.enabled && !that.editing.commandColumn.inline ) { const measureColumnWidth = function () { const header = document.createElement( 'div' ); const columnHeaderCellContentElement = document.createElement( 'div' ); const dataSource = that.editing.commandColumn.dataSource; let width = 0; let commandsHTML = ''; let visibleColumnsLength = 0; columnHeaderCellContentElement.classList.add( 'lw-label' ); for ( let item in dataSource ) { const properties = dataSource[ item ]; let checkedVisibility = false; if ( item === 'commandColumnMenu' ) { continue; } let visible = false; if ( !checkedVisibility ) { if ( properties.visible === true ) { visibleColumnsLength++; visible = true; } else if ( properties.visible === 'auto' ) { if ( ( ( !that.editing.editRow && !that.editing.editCell ) || that.editing.dialog.enabled ) && item === 'commandColumnEdit' ) { visibleColumnsLength++; visible = true; } else if ( ( that.editing.editRow || that.editing.editCell ) && !that.editing.dialog.enabled ) { if ( item === 'commandColumnUpdate' ) { visibleColumnsLength++; visible = true; } else if ( item === 'commandColumnCancel' ) { visibleColumnsLength++; visible = true; } } } checkedVisibility = true; } if ( visible && that.editing.commandColumn.displayMode !== 'icon' ) { const label = properties.label === '{{messages}}' ? that.localize( item ) : properties.label; commandsHTML += '<span>' + label + '</span>'; } } columnHeaderCellContentElement.innerHTML = '<span>' + commandsHTML + '</span>'; header.appendChild( columnHeaderCellContentElement ); header.style.width = 'auto'; header.style.position = 'static'; that.$.columnHeader.appendChild( header ); width = 10 + columnHeaderCellContentElement.firstChild.offsetWidth; that.$.columnHeader.removeChild( header ); if ( that.editing.commandColumn.displayMode === 'icon' ) { width = 20 + ( visibleColumnsLength * 20 ); } else if ( that.editing.commandColumn.displayMode === 'labelAndIcon' ) { width += ( visibleColumnsLength * 25 ) } else { width += visibleColumnsLength * 10; } return width; } that._commandColumn.visible = that.editing.commandColumn.visible; if ( that.editing.commandColumn.visible ) { const width = that.editing.commandColumn.width ? that.editing.commandColumn.width : measureColumnWidth(); that.columns.canNotify = false; that._commandColumn.width = width; that.columns.canNotify = true; } } for ( let i = 0; i < that.viewColumns.length; i++ ) { const viewColumn = that.viewColumns[ i ]; const column = viewColumn; // const columnByDataField = that.columnByDataField[viewColumn.dataField]; // const column = columnByDataField ? columnByDataField : viewColumn; let width; if ( typeof column.width === 'number' ) { width = column.width; } else if ( column.width && column.width.toString().indexOf( '%' ) >= 0 ) { width = parseFloat( column.width ) / 100; width *= ( gridWidth - checkBoxesIndent ); } else if ( column.width && ( column.width.toString().indexOf( 'em' ) >= 0 || column.width.toString().indexOf( 'pt' ) >= 0 || column.width.toString().indexOf( 'fr' ) >= 0 ) ) { width = parseFloat( column.width ); width *= 16; } else if ( column.width === 'auto' ) { width = column._autoSize(); } else if ( column.visible ) { columnsWithAutoWidth.push( column ); width = 0; } if ( column.overflowWidth ) { width -= column.overflowWidth; } if ( column.visible ) { columnsComputedWidth += width; } if ( width < column.minWidth ) { width = column.minWidth; } column.computedWidth = width; } if ( columnsWithAutoWidth ) { let autoWidth = gridWidth - columnsComputedWidth; let computedAutoWidth = 0; if ( autoWidth < 0 ) { autoWidth = columnsWithAutoWidth.length * 60; } for ( let i = 0; i < columnsWithAutoWidth.length; i++ ) { const column = columnsWithAutoWidth[ i ]; let width; width = autoWidth / columnsWithAutoWidth.length; if ( i === columnsWithAutoWidth.length - 1 ) { width = autoWidth - computedAutoWidth; } if ( column.overflowWidth ) { width -= column.overflowWidth; } if ( width < column.minWidth ) { width = column.minWidth; } column.computedWidth = width; computedAutoWidth += width; } } for ( let i = 0; i < that.viewColumns.length; i++ ) { const viewColumn = that.viewColumns[ i ]; let column = viewColumn; //viewColumn.autoGenerated ? viewColumn : that.columnByDataField[viewColumn.dataField]; if ( !column.visible ) { continue; } if ( indent > 0 && !column.autoGenerated ) { column.computedWidth += indent; indent = 0; } if ( column.freeze ) { if ( column.freeze === true || column.freeze === 'near' ) { column.left = nearWidth; columnsWidth += column.computedWidth; nearWidth += column.computedWidth; } else if ( column.freeze === 'far' ) { column.left = farWidth; farWidth += column.computedWidth; } } else { column.left = columnsWidth; columnsWidth += column.computedWidth; } } for ( let j = 0; j < that._columnGroupsLevel - 1; j++ ) { for ( let i = 0; i < that.columnGroups.length; i++ ) { const group = that.columnGroups[ i ]; const level = group.level; if ( level !== j ) { continue; } let left = 99999; if ( group.groups ) { const getWidth = function ( group ) { let width = 0; for ( let j = 0; j < group.groups.length; j++ ) { let currentGroup = group.groups[ j ]; if ( !currentGroup.groups ) { if ( !currentGroup.hidden ) { left = Math.min( currentGroup.left, left ); width += currentGroup.computedWidth; } } else { width += getWidth( currentGroup ); } } return width; } group.computedWidth = getWidth( group ); group.left = left; } } } } _createColumnHeaderCellElements() { const that = this; const columnContainer = that.$.columnContainer; const fragment = document.createDocumentFragment(); let columnsWidth = 0; that._columnElements = []; that.$.columnContainer.innerHTML = ''; that.$.columnNearContainer.innerHTML = ''; that.$.columnFarContainer.innerHTML = ''; if ( that.rightToLeft ) { that.$.columnNearContainer.classList.remove( 'near' ); that.$.columnNearContainer.classList.add( 'far' ); that.$.columnFarContainer.classList.remove( 'far' ); that.$.columnFarContainer.classList.add( 'near' ); } else { that.$.columnNearContainer.classList.remove( 'far' ); that.$.columnNearContainer.classList.add( 'near' ); that.$.columnFarContainer.classList.remove( 'near' ); that.$.columnFarContainer.classList.add( 'far' ); } for ( let i = 0; i < that._frozenNearColumns.length; i++ ) { const column = that._frozenNearColumns[ i ]; column.createElement(); } for ( let i = 0; i < that._frozenFarColumns.length; i++ ) { const column = that._frozenFarColumns[ i ]; column.createElement(); } for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( column.freeze ) { continue; } const header = column.createElement(); if ( column.computedWidth === undefined ) { that._columnElements.push( header ); fragment.appendChild( header ); continue; } columnsWidth += column.computedWidth; that._columnElements.push( header ); if ( columnsWidth < 2 * that._clientSize.width ) { fragment.appendChild( header ); } } for ( let i = 0; i < that.columnGroups.length; i++ ) { const group = that.columnGroups[ i ]; const groupColumn = new LW.Grid.Column( {visible: group.visible !== undefined ? group.visible : true, allowSelect: false, grid: that, dataField: group.name, label: group.label, align: group.align, verticalAlign: group.verticalAlign} ); group.column = groupColumn; const header = groupColumn.createElement(); header.style.width = group.computedWidth + 'px'; if ( !that.rightToLeft ) { header.style.left = group.left + 'px'; } else { header.style.right = group.right + 'px'; } header.style.top = group.top + 'px'; header.style.height = group.computedHeight + 'px'; header.style.lineHeight = group.computedHeight + 'px'; fragment.appendChild( header ); group.element = header; group.grid = this; } if ( !that.htmlColumnLastChild ) { that.htmlColumnLastChild = document.createElement( 'lw-grid-column' ); that.htmlColumnLastChild.classList.add( 'top-far-corner' ); that.htmlColumnLastChild.onpointerdown = ( event ) => { event.stopPropagation(); event.preventDefault(); } that.$.columnHeader.appendChild( that.htmlColumnLastChild ); } columnContainer.appendChild( fragment ); columnContainer.style.width = that._computedColumnsWidth + 'px'; that._refreshFrozenColumns(); } _refreshFrozenColumns() { const that = this; that.$.columnNearContainer.style.width = that._frozenColumnsNearWidth + 'px'; that.$.columnFarContainer.style.width = that._frozenColumnsFarWidth + 'px'; for ( let i = 0; i < that.columnGroups.length; i++ ) { const columnGroup = that.columnGroups[ i ]; if ( columnGroup.freeze && columnGroup.element ) { if ( columnGroup.freeze === true || columnGroup.freeze === 'near' ) { that.$.columnNearContainer.appendChild( columnGroup.element ); } else if ( columnGroup.freeze === 'far' ) { that.$.columnFarContainer.appendChild( columnGroup.element ); } } } for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( column.freeze && column.element ) { if ( column.freeze === true || column.freeze === 'near' ) { that.$.columnNearContainer.appendChild( column.element ); } else if ( column.freeze === 'far' ) { that.$.columnFarContainer.appendChild( column.element ); } } } } get _clientSize() { const that = this; if ( that.__clientSize ) { return that.__clientSize; } const computedStyle = getComputedStyle( that.$.container ); const paddingX = parseFloat( computedStyle.paddingLeft ) + parseFloat( computedStyle.paddingRight ); const paddingY = parseFloat( computedStyle.paddingTop ) + parseFloat( computedStyle.paddingBottom ); const borderX = parseFloat( computedStyle.borderLeftWidth ) + parseFloat( computedStyle.borderRightWidth ); const borderY = parseFloat( computedStyle.borderTopWidth ) + parseFloat( computedStyle.borderBottomWidth ); that.__clientSize = { width: that.$.container.offsetWidth - paddingX - borderX, height: that.$.container.offsetHeight - paddingY - borderY }; return that.__clientSize; } _initializeRowElements() { const that = this; if ( !that.rows ) { return; } that.rows.canNotify = false; let rowsHeight = 0; let height = that._clientSize.height; that.$.rowNearContainer.innerHTML = ''; that.$.rowFarContainer.innerHTML = ''; that.$.rowContainer.innerHTML = ''; that._rowElements = []; that._overflowOffset = Math.max( height, 300 ); if ( that.rightToLeft ) { that.$.rowNearContainer.classList.remove( 'near' ); that.$.rowNearContainer.classList.add( 'far' ); that.$.rowFarContainer.classList.remove( 'far' ); that.$.rowFarContainer.classList.add( 'near' ); } else { that.$.rowFarContainer.classList.remove( 'near' ); that.$.rowFarContainer.classList.add( 'far' ); that.$.rowNearContainer.classList.remove( 'far' ); that.$.rowNearContainer.classList.add( 'near' ); } const offsetHeight = that.offsetHeight; that.$.container.classList.add( 'lw-hidden' ); const newOffsetHeight = that.offsetHeight; that.$.container.classList.remove( 'lw-hidden' ); if ( that.verticalScrollBarVisibility === 'hidden' || ( offsetHeight !== newOffsetHeight ) ) { height = that._scrollHeight; } const createRecyclingRows = function () { const documentFragment = document.createDocumentFragment(); if ( ( that.rows && that.rows.length === 0 ) ) { return; } for ( let i = 0; i < that.rows.length; i++ ) { const row = that.rows[ i ]; if ( row.freeze ) { continue; } const rowElement = row.createElement(); documentFragment.appendChild( rowElement ); rowsHeight += that.layout.rowMinHeight; if ( rowsHeight > that._overflowOffset + height ) { break; } } that.$.rowContainer.appendChild( documentFragment ); const rowElements = that.$.rowContainer.children; for ( let i = 0; i < rowElements.length; i++ ) { const rowElement = rowElements[ i ]; if ( that.rows[ i ] ) { that.rows[ i ].element = rowElement; } that._rowElements[ i ] = rowElement; } } for ( let i = 0; i < that._frozenNearRows.length; i++ ) { const row = that._frozenNearRows[ i ]; row.grid = that; const element = row.createElement(); row.element = element; that.$.rowNearContainer.appendChild( element ); } for ( let i = 0; i < that._frozenFarRows.length; i++ ) { const row = that._frozenFarRows[ i ]; row.grid = that; const element = row.createElement(); row.element = element; that.$.rowFarContainer.appendChild( element ); } createRecyclingRows(); let maxIterations = 0; while ( rowsHeight < 1.5 * height && ++maxIterations < 50 ) { createRecyclingRows(); } that.rows.canNotify = true; } _initializeRows() { const that = this; let frozenIndex = 0; that._frozenNearDefaultRows = []; that._frozenFarDefaultRows = []; that.rows = []; that.rowById = []; that._frozenFarRows = []; that._frozenNearRows = []; const calculateSummary = function () { let summaryObject = []; let hasSummary = false; for ( let i = 0; i < that.columns.length; i++ ) { const column = that.columns[ i ]; let columnSummary = { }; if ( column.summary && column.summary.length > 0 ) { hasSummary = true; } columnSummary[ column.dataField ] = column.summary; summaryObject.push( columnSummary ); } if ( !hasSummary ) { that._summaryItems = []; return; } that._summaryItems = that.dataSource.summarize( summaryObject ); } const addNewRow = function ( data, index ) { const row = data.grid ? data : new LW.Grid.Row( {data: data, index: index, grid: that} ); if ( that.onRowInit ) { that.onRowInit( index, row ); for ( let propertyName in row ) { if ( row.properties.indexOf( propertyName ) === -1 && !propertyName.startsWith( '_' ) ) { that.error( that.localize( 'invalidRowProperty', {elementType: 'Grid', propertyName: propertyName} ) ); } } } if ( row.selected ) { that._selection.rows[ row.id ] = true; } if ( row.freeze ) { if ( row.freeze === true || row.freeze === 'near' ) { that.rows.splice( frozenIndex++, 0, row ); const frozenRow = that.rows[ frozenIndex - 1 ]; if ( that._frozenNearRows.indexOf( frozenRow ) === -1 ) { that._frozenNearRows.push( frozenRow ); } } else if ( row.freeze === 'far' ) { that.rows.push( row ); const frozenRow = that.rows[ that.rows.length - 1 ]; if ( that._frozenFarRows.indexOf( frozenRow ) === -1 ) { that._frozenFarRows.push( frozenRow ); } } } else { if ( that.rows[ index ] ) { that.rows.splice( index, 0, row ); } else { that.rows.push( row ); } } if ( that.scrolling === 'virtual' || ( that.paging.enabled && that.dataSource && that.dataSource.virtualDataSource ) ) { return; } if ( that.onRowInserted ) { that.onRowInserted( index, row ); } } const removeLastRow = function () { const lastRow = that.rows[ that.rows.length - 1 ]; that.rows.pop(); if ( that.onRowRemoved ) { that.onRowRemoved( that.rows.length, lastRow ); } } const removeAt = function ( index ) { const row = that.rows[ index ]; that.rows.splice( index, 1 ); if ( that.onRowRemoved ) { that.onRowRemoved( index, row ); } } that._add = addNewRow; that._removeLastRow = removeLastRow; that._removeAt = removeAt; that._rowHeight = that._autoRowHeight; const dataSourceLength = that.dataSource.length; that.setAttribute( 'aria-rowcount', dataSourceLength ); for ( let i = 0; i < that.dataSource.length; i++ ) { const data = that.dataSource[ i ]; addNewRow( data, i ); } for ( let i = 0; i < that._frozenFarRows.length; i++ ) { const row = that._frozenFarRows[ i ]; that.rows.splice( that.rows.indexOf( row ), 1 ); that.rows.push( row ); } calculateSummary(); that.dataSource.notify( function ( changes ) { if ( that.dataSource._updating ) { return; } const data = changes.data; that.rows.canNotify = false; switch ( changes.action ) { case 'add': if ( data.length ) { for ( let i = 0; i < data.length; i++ ) { addNewRow( data[ i ], that.dataSource.length - data.length + i ); } } else { addNewRow( data, that.dataSource.length - 1 ); } break; case 'update': if ( data.length ) { for ( let i = 0; i < data.length; i++ ) { const index = changes.index[ i ]; if ( !that.rows[ index ] ) { addNewRow( data[ i ], that.dataSource.length - 1 ); continue; } that.rows[ index ].data = data[ i ]; if ( that.onRowUpdated ) { that.onRowUpdated( index, that.rows[ index ] ); } } } else { const index = changes.index; if ( !that.rows[ index ] ) { addNewRow( data, that.dataSource.length - 1 ); } else { that.rows[ index ].data = data; } if ( that.onRowUpdated ) { that.onRowUpdated( index, that.rows[ index ] ); } } break; case 'insert': addNewRow( data, changes.index ); for ( let i = 0; i < that.rows.length; i++ ) { const row = that.rows[ i ]; row.index = i; } break; case 'remove': removeAt( changes.index ); break; case 'removeLast': removeLastRow(); break; case 'bindingComplete': if ( ( that.dataSource && that.dataSource.url ) || ( that.dataSource && !that.dataSource.virtualDataSource ) ) { that.appearance.displayLoadingIndicator = false; that._setLoadingIndicatorVisibility(); that._toggledRow = null; if ( that.dataSource.length !== dataSourceLength ) { if ( that.paging.enabled ) { const headerPager = that.$.headerPager.querySelector( 'lw-pager' ); const footerPager = that.$.footerPager.querySelector( 'lw-pager' ); if ( headerPager ) { headerPager.pagesCount = Math.ceil( that.dataSource.length / that.paging.pageSize ); } if ( footerPager ) { footerPager.pagesCount = Math.ceil( that.dataSource.length / that.paging.pageSize ); } } that._initializeRows(); that._initializeRowElements(); that.refresh(); } that._recycle(); } break; } calculateSummary(); if ( changes.action !== 'update' ) { that._refreshLayout(); } that._recycle(); that.rows.canNotify = true; } ); that._observeRows(); if ( that.summaryRow.visible ) { for ( let i = 0; i < that._summaryRowCount; i++ ) { const summaryNearRow = new LW.Grid.Row( {height: that.layout.rowMinHeight, freeze: 'near', visible: that.summaryRow.position === 'near', summaryRowIndex: i, summaryRow: true} ); const summaryFarRow = new LW.Grid.Row( {height: that.layout.rowMinHeight, freeze: 'far', visible: that.summaryRow.position === 'far', summaryRowIndex: i, summaryRow: true} ); that._frozenNearRows.splice( 0, 0, summaryNearRow ); that._frozenFarRows.push( summaryFarRow ); } } if ( that.filtering.enabled && that.filtering.filterRow.visible ) { const row = new LW.Grid.Row( {freeze: true, autoGenerated: true, filterRow: true} ); that._frozenNearRows.splice( 0, 0, row ); } that._renderAddNewRow(); } _observeRows() { const that = this; const observables = { 'allowToggle': true, 'allowResize': true, 'allowCheck': true, 'allowSelect': true, 'allowReorder': true, 'expanded': true, 'selected': true, 'checked': true, 'visible': true, 'enabled': true, 'minHeight': true, 'height': true, 'freeze': true, 'showDetail': true, 'data': true, 'visibleIndex': true, 'index': true } that._frozenNearRows = []; that._frozenFarRows = []; that.rows = new LW.ObservableArray( that.rows, null, observables ); for ( let i = 0; i < that.rows.length; i++ ) { const row = that.rows[ i ]; if ( row.freeze === true || row.freeze === 'near' ) { that._frozenNearRows.push( row ); } else if ( row.freeze === 'far' ) { that._frozenFarRows.push( row ); } that.rowById[ that.rows[ i ].id ] = row; } const rowPropertyChanged = function ( row, propertyName, oldValue, newValue ) { row.propertyChanged( propertyName, oldValue, newValue ); } that.rows.notify( function ( changes ) { if ( !that.rows.canNotify ) { return; } const changeType = changes.action; if ( changeType === 'length' ) { return; } if ( changes.path ) { that.rows.canNotify = false; rowPropertyChanged( that.rows[ changes.index ], changes.propertyName, changes.oldValue, changes.newValue ); that.rows.canNotify = true; return; } that.rows.canNotify = false; if ( !that.dataSource ) { return; } that.dataSource.canNotify = false; switch ( changeType ) { case 'add': { const addRow = function ( index ) { let row = that.rows[ index ]; if ( row instanceof LW.Grid.Row === false ) { row = new LW.Grid.Row( row ); const notify = that.rows.canNotify; that.rows.canNotify = false; changes.object[ index ] = row; row = changes.object[ index ]; that.rows.canNotify = notify; } if ( index < that.dataSource.length ) { that.dataSource.insert( index, that.rows[ index ].data ); } else { that.dataSource.add( that.rows[ index ].data ); } row.grid = that; row.data = that.dataSource[ index ]; that.rowById[ row.id ] = row; if ( row.selected ) { that._selection.rows[ row.id ] = true; } if ( row.freeze ) { if ( row.freeze === true || row.freeze === 'near' ) { that._frozenNearRows.push( row ); } else if ( row.freeze === 'far' ) { that._frozenFarRows.push( row ); } } } for ( let i = 0; i < changes.addedCount; i++ ) { addRow( changes.index + i ); } break; } case 'update': { that.dataSource.update( changes.index, that.rows[ changes.index ] ); break; } case 'remove': { const row = changes.removed; delete that.rowById[ row.id ]; that.dataSource.removeAt( changes.index ); break; } } that.dataSource.canNotify = true; that.rows.canNotify = true; if ( !changeType ) { return; } const fullRefresh = that.isInitialized && that._rowElements && that._rowElements.length < that.rows.length; if ( fullRefresh ) { that._initializeRowElements(); } that.refresh(); that._refreshPagesCount(); } ); } render() { const that = this; const isHidden = () => { return that.offsetWidth === 0 || that.offsetHeight === 0; } if ( isHidden() ) { requestAnimationFrame( () => { if ( !that.isInitialized && !isHidden() ) { that._render(); } } ); that.setAttribute( 'role', 'grid' ); if ( !that.editing.enabled ) { that.setAttribute( 'aria-readonly', true ); } super.render(); return; } const context = that.context; that.context = that; that.setAttribute( 'role', 'grid' ); if ( !that.editing.enabled ) { that.setAttribute( 'aria-readonly', true ); } that._render(); that.context = context; super.render(); } _renderColumns( refresh ) { const that = this; that._initializeColumns(); that._initializeColumnGroupsHierarchy(); that._refreshColumnsResponsiveVisibility(); that._createColumnHeaderCellElements(); that._renderColumnGroupHeaders(); if ( refresh !== false ) { that._refresh(); } } _renderRows( refresh ) { const that = this; that._initializeRows(); that._initializeRowElements(); if ( refresh !== false ) { that._refresh(); } } _render() { const that = this; if ( !that.isInitialized ) { if ( that.onBeforeInit ) { that.onBeforeInit(); } that.$.fireEvent( 'beforeInit', { 'grid': that } ); } if ( that.dataSource === null ) { that.dataSource = new LW.DataAdapter(); } else if ( Array.isArray( that.dataSource ) ) { that.dataSource = new LW.DataAdapter( { dataSource: that.dataSource } ); } that._selection = { rows: [], columns: [], cells: [] }; if ( that.dataSource && that.dataSource.url ) { that.appearance.displayLoadingIndicator = true; that._setLoadingIndicatorVisibility(); that.dataSource.data = { sorting: that.getSortedColumns(), filtering: that.getFilteredColumns(), grouping: [] } } that._renderColumns( false ); that._renderRows( false ); that._renderPagers(); that._renderCommandBar(); if ( that.appearance.allowColumnStickyPosition ) { that._stickHeader(); } if (that.header.visible && that.header.template === '') { that.$.header.innerHTML = '<lw-grid-toolbar header-position="top"></lw-grid-toolbar>' that.$.headerBar = that.$.header.firstElementChild; that.$.headerBar._init(that); } if ( !that.isInitialized ) { for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( !column.allowSort || !column.sortOrder ) { continue; } const sortAnimation = that.appearance.allowSortAnimation; that.appearance.allowSortAnimation = false; that.sortBy( column.dataField, column.sortOrder ); that.appearance.allowSortAnimation = sortAnimation; } if ( that.filtering.filter.length > 0 ) { for ( let j = 0; j < that.filtering.filter.length; j++ ) { const filter = that.filtering.filter[ j ]; if ( filter ) { const dataField = filter[ 0 ]; const filterExpression = filter.splice( 1 ); let filterGroup = null; if ( filterExpression instanceof LW.FilterGroup ) { filterGroup = filterExpression; } else { const column = that.columnByDataField[ dataField ]; if ( column ) { filterGroup = that.dataSource._createFilter( column.dataType, filterExpression ); } } if ( filterGroup ) { that.addFilter( dataField, filterGroup, false ); } } } that.refreshFilters(); } } else { that.refreshFilters(); } that.viewColumns.canNotify = true; const isFirstRender = !that.isInitialized; if ( isFirstRender ) { if ( that.onInit ) { that.onInit(); } that.$.fireEvent( 'init', { 'grid': that } ); } that.isInitialized = true; if ( that.scrolling === 'virtual' || ( that.paging.enabled && that.dataSource && that.dataSource.virtualDataSource ) ) { that._virtualDataRequest( 'dataBind' ); } else if ( that.dataSource && that.dataSource.virtualDataSource ) { that._virtualDataRequest( 'dataBind' ); } if ( that.header.template !== '' ) { that._applyTemplate( that.header.template, that.$.header ); } if ( that.footer.template !== '' ) { that._applyTemplate( that.footer.template, that.$.footer ); } that._createFilterPanels(); that._refresh(); that._applyScrolling(); if ( that.grouping.enabled && that.grouping.autoExpandAll && that.rowHierarchy ) { that.expandAllRows(); } if ( that.onRender ) { that.onRender(); } that.isRendered = true; if ( that.layout.rowHeight === 'auto' ) { that._refreshLayout(); that._recycle(); } if ( isFirstRender ) { if ( that.onAfterInit ) { that.onAfterInit(); } that.$.fireEvent( 'afterInit', { 'grid': that } ); that.isRendering = false; if ( that.whenRenderedCallbacks ) { for ( let i = 0; i < that.whenRenderedCallbacks.length; i++ ) { that.whenRenderedCallbacks[ i ](); } that.whenRenderedCallbacks = []; } } } get _viewRows() { const that = this; if ( that.__viewRows ) { return that.__viewRows; } if ( !that._nearRowsAdded ) { that._nearRowsAdded = []; that._farRowsAdded = []; } const viewRows = !that.rowHierarchy ? that.rows.toArray() : that.rowHierarchy; const rows = [].concat( that._frozenNearDefaultRows, that._nearRowsAdded, viewRows, that._farRowsAdded, that._frozenFarDefaultRows ); that.__viewRows = rows; return rows; } _stickHeader() { const that = this; that._stickyHeaderHandler = function () { that._handleStickyHeader(); } that.$.columnHeader.style.top = ''; that.$.columnHeader.classList.remove( 'lw-columns-sticky' ); let parent = that.parentNode; if ( that.isInShadowDOM && parent === that.getRootNode() ) { parent = that.getRootNode().host; } while ( parent !== document && parent ) { parent.addEventListener( 'scroll', that._stickyHeaderHandler ); parent = parent.parentNode; if ( that.isInShadowDOM && parent === that.getRootNode() ) { parent = that.getRootNode().host; } } try { if ( window.top !== null && window.top !== window.self ) { window.top.document.addEventListener( 'scroll', that._stickyHeaderHandler ); } } catch ( error ) { // } that._handleStickyHeader(); } _unstickHeader() { const that = this; that.$.columnHeader.style.top = ''; that.$.columnHeader.classList.remove( 'lw-columns-sticky' ); let parent = that.parentNode; while ( parent !== document.body ) { parent.removeEventListener( 'scroll', that._stickyHeaderHandler ); parent = parent.parentNode; if ( that.isInShadowDOM && parent === that.getRootNode() ) { parent = that.getRootNode().host; } } try { if ( document.referrer !== '' || window.frameElement ) { if ( window.top !== null && window.top !== window.self ) { window.top.document.removeEventListener( 'scroll', that._stickyHeaderHandler ); } } } catch ( error ) { // } } _handleStickyHeader() { const that = this; if ( !that.appearance.allowColumnStickyPosition ) { return; } that.$.columnHeader.classList.add( 'lw-columns-sticky' ); if ( document.scrollTop === 0 && that.parentElement.scrollTop === 0 ) { that.$.columnHeader.style.top = ''; } else { let parent = that.parentNode; let top = 0; while ( parent !== document.body ) { top += parseInt( parent.scrollTop ); parent = parent.parentNode; if ( that.isInShadowDOM && parent === that.getRootNode() ) { parent = that.getRootNode().host; } } const headerTop = parseInt( that.clientTop + top ); that.$.columnHeader.style.top = headerTop + 'px'; let frameTop = 0; if ( window.top !== window.self ) { if ( parseInt( window.top.scrollY ) > parseInt( that._offsetTop( window.frameElement ) ) ) { frameTop = parseInt( window.top.scrollY ) - parseInt( that._offsetTop( window.frameElement ) ); } } if ( window.scrollY + frameTop > that.offsetTop ) { that.$.columnHeader.style.top = parseInt( window.scrollY ) - parseInt( that.offsetTop ) + headerTop + frameTop + 'px'; } } } _scrollHandler() { const that = this; that._handleStickyHeader(); } _initializeRowNumberColumn() { const that = this; if ( that._frozenNearColumns && that._frozenNearColumns.length > 0 && that._frozenNearColumns[ 0 ].rowHeaderColumn ) { that._frozenNearColumns[ 0 ].visible = that.appearance.showRowHeaderNumber || that.appearance.showRowHeader; return; } const column = new LW.Grid.Column( {dataField: '_rowHeaderColumn', label: '', allowSelect: false, freeze: true, visible: true, grid: that, autoGenerated: true, rowHeaderColumn: true, cellsAlign: 'center'} ); const rowsLength = that.rows ? that.rows.length : that.dataSource ? that.dataSource.length : 0; let width = that.appearance.showRowHeaderNumber ? column._measureSize( rowsLength ) : 30; if ( that.appearance.autoGenerateColumnWidth ) { width = that.appearance.autoGenerateColumnWidth; } column.width = width; column.createElement(); const observableColumn = new LW.Observable( column, column.observables ); that.viewColumns.splice( 0, 0, observableColumn ); that._frozenNearColumns.splice( 0, 0, observableColumn ); } _initializeColumns() { const that = this; if ( typeof that.columns === 'number' ) { const boundColumns = []; const charCode = 'A'.charCodeAt( 0 ); let prefix = ''; let index = 0; for ( let i = 0; i < that.columns; i++ ) { let label = i + 1; const letter = String.fromCharCode( charCode + index ); index++; const dataField = prefix + letter; if ( that.appearance.autoGenerateColumnLabelMode !== 'number' ) { label = prefix + letter; } boundColumns.push( {align: 'center', label: label, dataField: dataField, width: 100} ) if ( index >= 26 ) { index = 0; prefix += 'A'; } } that._boundColumns = boundColumns; } else { that._boundColumns = Array.isArray( that.columns ) ? [ ...that.columns ] : [ ...that.columns.toArray() ]; } that._initColumns = that.columns; that.columnByDataField = []; that.viewColumns = []; that.columns = new LW.ObservableArray(); that._frozenFarColumns = []; that._frozenNearColumns = []; that._summaryRowCount = 0; let frozenIndex = 0; const _applyBoundColumnDataType = function ( column ) { if ( that.dataSource.dataFields ) { const field = that.dataSource.dataFields.find( field => { if ( field.name === column.dataField ) { return field; } } ); const dataType = field ? field.dataType || 'string' : 'string'; column.dataType = dataType; } } if ( that._boundColumns.length === 0 && that.dataSource && that.dataSource[ 0 ] && that.dataSource.autoGenerateColumns !== false ) { const row = that.dataSource[ 0 ]; if ( row.$ && row.$.isEmpty && that.dataSource.dataFields ) { for ( let i = 0; i < that.dataSource.dataFields.length; i++ ) { const dataField = that.dataSource.dataFields[ i ]; const index = that._boundColumns.length; const column = { index: index, visibleIndex: index, label: dataField.name, dataField: dataField.name, dataType: dataField.dataType }; that._boundColumns.push( column ); } } else { for ( let dataField in row ) { if ( dataField.startsWith( '_' ) || dataField === '$' ) { continue; } const index = that._boundColumns.length; const column = { index: index, visibleIndex: index, label: dataField, dataField: dataField }; _applyBoundColumnDataType( column ); that._boundColumns.push( column ); } } } for ( let i = 0; i < that._boundColumns.length; i++ ) { let boundColumn = that._boundColumns[ i ]; if ( typeof boundColumn === 'string' ) { if ( that.dataSource.dataFields ) { const field = that.dataSource.dataFields.find( field => { if ( field.name === boundColumn ) { return field; } } ); boundColumn = { label: boundColumn, dataField: boundColumn, dataType: field ? field.dataType || 'string' : 'string' }; } } else { _applyBoundColumnDataType( boundColumn ); } boundColumn.visibleIndex = i; boundColumn.index = i; boundColumn.grid = that; const column = new LW.Grid.Column( boundColumn ); if ( that.onColumnInit ) { that.onColumnInit( i, column ); } for ( let propertyName in column ) { if ( column.properties.indexOf( propertyName ) === -1 && !propertyName.startsWith( '_' ) ) { that.error( that.localize( 'invalidColumnProperty', {elementType: 'Grid', propertyName: propertyName, type: column.dataField || 'Column'} ) ); } } column.grid = that; that.columns.push( column ); const observableColumn = that.columns[ that.columns.length - 1 ]; that._summaryRowCount = Math.max( that._summaryRowCount, column.summary.length ); if ( column.freeze ) { if ( column.freeze === true || column.freeze === 'near' ) { that.viewColumns.splice( frozenIndex++, 0, observableColumn ); that._frozenNearColumns.push( observableColumn ); } else if ( column.freeze === 'far' ) { that._frozenFarColumns.push( observableColumn ); } } else { that.viewColumns.push( observableColumn ); } if ( !that.columnByDataField[ column.dataField ] ) { that.columnByDataField[ column.dataField ] = observableColumn; } else { observableColumn.parent = that.columnByDataField[ column.dataField ]; if ( !that.columnByDataField[ column.dataField ].children ) { that.columnByDataField[ column.dataField ].children = []; } that.columnByDataField[ column.dataField ].children.push( observableColumn ); } if ( that.onColumnInserted ) { that.onColumnInserted( i, column ); } } that.viewColumns = that.viewColumns.concat( that._frozenFarColumns ); that.setAttribute( 'aria-colcount', that._boundColumns.length ); let autoGeneratedNearColumns = 0; if ( that.appearance.showRowHeaderNumber || that.appearance.showRowHeader ) { that._initializeRowNumberColumn(); autoGeneratedNearColumns++; } if ( that.rowDetail.enabled ) { const column = new LW.Grid.Column( {dataField: '_rowDetailColumn', allowSelect: false, visible: that.rowDetail.visible, label: '', grid: that, freeze: true, rowDetailColumn: true, autoGenerated: true, cellsAlign: 'center', width: 30} ); const observableColumn = new LW.Observable( column, column.observables ); if ( that.rowDetail.position === 'near' ) { column.freeze = 'near'; observableColumn.freeze = 'near'; that.viewColumns.splice( autoGeneratedNearColumns, 0, observableColumn ); that._frozenNearColumns.splice( autoGeneratedNearColumns, 0, observableColumn ); } else { that.viewColumns.push( observableColumn ); that._frozenFarColumns.splice( 0, 0, observableColumn ); } autoGeneratedNearColumns++; } const column = new LW.Grid.Column( {dataField: '_adaptiveColumn', allowSelect: false, visible: false, label: '', grid: that, freeze: 'far', adaptiveColumn: true, autoGenerated: true, cellsAlign: 'center', width: 30} ); const observableColumn = new LW.Observable( column, column.observables ); observableColumn.canNotify = false; that.viewColumns.push( observableColumn ); that._frozenFarColumns.splice( 0, 0, observableColumn ); const commandColumn = new LW.Grid.Column( {dataField: '_commandColumn', allowSelect: false, visible: that.editing.enabled && that.editing.commandColumn.visible && !that.editing.commandColumn.inline, label: '', grid: that, freeze: 'far', commandColumn: true, autoGenerated: true, align: 'center', cellsAlign: 'center', width: ''} ); const observableCommandColumn = new LW.Observable( commandColumn, commandColumn.observables ); observableCommandColumn.canNotify = false; if ( that.editing.commandColumn.position === 'near' ) { commandColumn.freeze = 'near'; observableCommandColumn.freeze = 'near'; that.viewColumns.splice( autoGeneratedNearColumns, 0, observableCommandColumn ); that._frozenNearColumns.splice( autoGeneratedNearColumns, 0, observableCommandColumn ); } else { that.viewColumns.push( observableCommandColumn ); that._frozenFarColumns.splice( 0, 0, observableCommandColumn ); } that._commandColumn = observableCommandColumn; const selectionColumn = new LW.Grid.Column( {allowSelect: false, visible: that.selection.enabled && that.selection.checkBoxes.enabled, dataField: '_checkBoxColumn', label: '', freeze: that.selection.checkBoxes.position, grid: that, selectionColumn: true, autoGenerated: true, cellsAlign: 'center', width: 32} ); const observableSelectionColumn = new LW.Observable( selectionColumn, selectionColumn.observables ); if ( selectionColumn.freeze === 'near' ) { that.viewColumns.splice( autoGeneratedNearColumns, 0, observableSelectionColumn ); that._frozenNearColumns.splice( autoGeneratedNearColumns, 0, observableSelectionColumn ); } else { that.viewColumns.push( observableSelectionColumn ); that._frozenFarColumns.splice( 0, 0, observableSelectionColumn ); } that._selectionColumn = observableSelectionColumn; that._selectionColumn.canNotify = false; that._observeColumns(); that._templateColumns(); } get styleProperties() { return [ 'grid-template-columns', '--lw-grid-row-height', '--lw-grid-column-header-height', '--lw-grid-group-header-height', '--lw-grid-filter-footer-height', '--lw-grid-group-row-vertical', '--lw-grid-group-row-horizontal-offset', '--lw-grid-freeze-splitter-size', '--lw-grid-resize-line-size', '--lw-grid-footer-height', '--lw-grid-header-height' ]; } _templateColumns() { const that = this; const computedStyle = getComputedStyle( that ); const templateColumns = computedStyle.getPropertyValue( '--lw-grid-template-columns' ).trim(); const columnGap = computedStyle.getPropertyValue( '--lw-grid-column-gap' ).trim(); const rowGap = computedStyle.getPropertyValue( '--lw-grid-row-gap' ).trim(); that._rowGap = parseInt( rowGap ); that._columnGap = parseInt( columnGap ); that._maxHeight = parseInt( computedStyle.maxHeight ); that._minHeight = parseInt( computedStyle.minHeight ); if ( templateColumns !== 'none' ) { let unboundColumnWidths = 0; for ( let i = 0; i < that.viewColumns.length; i++ ) { if ( that.viewColumns[ i ].autoGenerated ) { unboundColumnWidths += that.viewColumns[ i ].visible ? that.viewColumns[ i ].width : 0; } } let boundColumnWidths = []; const templateColumnsContainer = document.createElement( 'div' ); templateColumnsContainer.style.display = 'grid'; templateColumnsContainer.style.gridTemplateColumns = templateColumns; for ( let i = 0; i < that.columns.length; i++ ) { templateColumnsContainer.innerHTML += '<div></div>'; } templateColumnsContainer.style.width = that.clientWidth - unboundColumnWidths + 'px'; that.$.root.appendChild( templateColumnsContainer ); const templateColumnsArray = templateColumns.split( ' ' ); for ( let i = 0; i < that.columns.length; i++ ) { boundColumnWidths[ i ] = templateColumnsContainer.children[ i ].offsetWidth; if ( templateColumnsArray[ i ] === 'auto' ) { boundColumnWidths[ i ] = null; } } templateColumnsContainer.parentNode.removeChild( templateColumnsContainer ); let j = 0; for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( column.autoGenerated ) { continue; } if ( boundColumnWidths[ j ] ) { column.width = column.templateWidth = boundColumnWidths[ j++ ]; } } } else { for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( column.autoGenerated ) { continue; } if ( column.templateWidth ) { column.width = column.templateWidth = null; } } } } onAttached() { const that = this; if ( !that._scrollView ) { that._scrollView = new LW.Utilities.Scroll( that, that.$.horizontalScrollBar, that.$.verticalScrollBar ); } if ( that.isRendered && that.isCompleted ) { that._render(); } } onDetached() { const that = this, dialogs = [ '_dialogChart', '_dialogAddRow', '_dialogEdit', '_dialogDelete', '_dialogRowDetail' ]; if ( !that.isRendered ) { return; } dialogs.forEach( dialog => { if ( that[ dialog ] ) { that[ dialog ].close(); that[ dialog ] = null; } } ); if ( that.menu ) { that.menu.ownerElement = null; that.menu.remove(); that.menu = null; } that._resetCachedLayout(); const hScrollBar = that._scrollView.hScrollBar; const vScrollBar = that._scrollView.vScrollBar; vScrollBar.ownerElement = null; hScrollBar.ownerElement = null; vScrollBar.onChange = null; hScrollBar.onChange = null; if ( that._scrollView ) { that._scrollView.unlisten(); delete that._scrollView; } if ( that._columnElements ) { for ( let i = 0; i < that._columnElements.length; i++ ) { const column = that._columnElements[ i ]; column._detach(); } } that._columnElements = null; if ( that._rowElements ) { for ( let i = 0; i < that._rowElements.length; i++ ) { const row = that._rowElements[ i ]; row._detach(); } } that._rowElements = null; that.rows = []; that.rowById = []; that._initColumns = []; that.columnByDataField = []; that.viewColumns = []; that._columnToResizeElement = null; let columnArray = Array.isArray( that.columns ) ? [ ...that.columns ] : [ ...that.columns.toArray() ] columnArray = columnArray.map( ( column ) => { if ( column.data ) { if ( column.data.visibleIndex !== undefined ) { delete column.data.visibleIndex; } if ( column.data.index !== undefined ) { delete column.data.index; } if ( column.data.grid !== undefined ) { delete column.data.grid; } return column.data; } return column; } ); that.rows.notifyFn = null; that.columns.notifyFn = null; that.columns.notify = null; that.columns._array = []; that.columns = columnArray; that._boundColumns = []; that._filterPanels = []; that._frozenFarColumns = []; that._frozenNearColumns = []; that._frozenNearDefaultRows = []; that._frozenFarDefaultRows = []; that._frozenFarRows = []; that._frozenNearRows = []; that._selection = { rows: [], columns: [], cells: [] }; that.__autoHeightRows = null; that._visibleRows = null; that.__viewRows = null; that.__clientSize = null; that.__scrollHeight = null; that.__scrollWidth = null; that.__parentCells = null; that._selectionColumn = null; that._adaptiveColumn = null; that._commandColumn = null; delete that._columnFarContainerComputedStyle; delete that._columnContainerComputedStyle; delete that._columnNearContainerComputedStyle; if ( that._inputOverlay ) { if ( that._inputOverlay.parentNode ) { that._inputOverlay.parentNode.removeChild( that._inputOverlay ); } that._inputOverlay = null; } that._firstVisibleColumn = null; that._lastVisibleColumn = null; that._toggledRow = null; if ( LW( that._selector ) ) { delete LW( that._selector )._properties; delete LW( that._selector ); } delete that._selector; delete that._initProperties; } _observeColumns() { const that = this; const columnPropertyChanged = function ( column, propertyName, oldValue, newValue ) { column.propertyChanged( propertyName, oldValue, newValue ); } for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; column.onAction = function () { that._openMenu( this ); } if ( column.autoGenerated ) { column.notify( function ( changes ) { column.canNotify = false; columnPropertyChanged( column, changes.propertyName, changes.oldValue, changes.newValue ); column.canNotify = true; } ); } } that.columns.notify( function ( changes ) { let column = null; if ( changes.path ) { that.columns.canNotify = false; columnPropertyChanged( changes.target, changes.propertyName, changes.oldValue, changes.newValue ); that.columns.canNotify = true; return; } that.columns.canNotify = false; const changeType = changes.action; let unboundColumnsCount = 0; switch ( changeType ) { case 'length': { that.columns.canNotify = true; return; } case 'add': { const addColumn = function ( columnIndex ) { column = changes.object[ columnIndex ]; if ( column instanceof LW.Grid.Column === false ) { column = new LW.Grid.Column( column ); const notify = that.columns.canNotify; that.columns.canNotify = false; changes.object[ columnIndex ] = column; column = changes.object[ columnIndex ]; that.columns.canNotify = notify; } column.grid = that; if ( column.freeze ) { that._frozenNearColumns.push( column ); } else if ( column.freeze === 'far' ) { that._frozenFarColumns.push( column ); } let index = that.viewColumns.length - that._frozenFarColumns.length; if ( columnIndex < that.columns.length ) { that.viewColumns.splice( columnIndex + that._frozenNearColumns.length, 0, column ); } else { that.viewColumns.splice( index, 0, column ); } if ( !that.columnByDataField[ column.dataField ] ) { that.columnByDataField[ column.dataField ] = column; } else { that.columnByDataField[ column.dataField ].children.push( column ); column.parent = that.columnByDataField[ column.dataField ]; column.valueField = column.dataField; const dataField = column.dataField + '_' + column.parent.children.length; that.columnByDataField[ dataField ] = column; column.dataField = dataField; } if ( that.onColumnInserted ) { that.onColumnInserted( columnIndex, column ); } } for ( let i = 0; i < changes.addedCount; i++ ) { addColumn( changes.index + i ); } break; } case 'update': { column = changes.object[ changes.index ]; if ( column instanceof LW.Grid.Column === false ) { column = new LW.Grid.Column( column ); } column.grid = that; for ( let i = 0; i < changes.index; i++ ) { if ( that.viewColumns[ i ].autoGenerated ) { unboundColumnsCount++; } } that.viewColumns[ unboundColumnsCount + changes.index ] = column; that.columnByDataField[ column.dataField ] = column; if ( that.onColumnUpdated ) { that.onColumnUpdated( changes.index, column ); } break; } case 'remove': { column = changes.removed[ 0 ]; let index = changes.index; for ( let i = 0; i <= index; i++ ) { if ( that.viewColumns[ i ].autoGenerated ) { unboundColumnsCount++; } } that.viewColumns.splice( unboundColumnsCount + index, 1 ); if ( column ) { delete that.columnByDataField[ column.dataField ]; } if ( that.onColumnRemoved ) { that.onColumnRemoved( changes.index, column ); } break; } } that._initializeColumnGroupsHierarchy(); that._refreshColumnsResponsiveVisibility(); that._createColumnHeaderCellElements(); that._templateColumns(); that.refresh(); that.columns.canNotify = true; } ); } /** * Calculates the width/height of the rows. */ get _scrollWidth() { const that = this; if ( that.__scrollWidth ) { return that.__scrollWidth; } let width = 0; for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( !column.visible ) { continue; } width += column.computedWidth; } width = parseInt( width ); that.__scrollWidth = width; that._scrollView.scrollWidth = width - that._clientSize.width; return that.__scrollWidth; } /** * Horizontal Scroll Bar handler */ _horizontalScrollbarHandler() { const that = this; that.closeMenu(); that.isScrolling = true; requestAnimationFrame( () => { that._recycle(); that.isScrolling = false; } ); } /** * Container mousewheel event handler. */ _mouseWheelHandler( event ) { const that = this; if ( that._scrollView.hScrollBar.$.hasClass( 'lw-hidden' ) && that._scrollView.vScrollBar.$.hasClass( 'lw-hidden' ) ) { return; } if ( !that.disabled && !that._scrollView.vScrollBar.$.hasClass( 'lw-hidden' ) && !event.shiftKey) { const scrollTop = that.scrollTop; if ( scrollTop === 0 && event.deltaY < 0 || scrollTop === that.scrollHeight && event.deltaY > 0 ) { return; } event.stopPropagation(); event.preventDefault(); that._scrollView.scrollTo( that._scrollView.scrollTop + that._getScrollCoefficient( event, that._clientSize.height ) ); // that._scrollView.scrollTop += event.deltaY < 0 ? -100 : 100; } else if ( !that.disabled && !that._scrollView.hScrollBar.$.hasClass( 'lw-hidden' ) ) { const scrollLeft = that.scrollLeft; if ( scrollLeft === 0 && event.deltaY < 0 || scrollLeft === that.scrollWidth && event.deltaY > 0 ) { return; } event.stopPropagation(); event.preventDefault(); that._scrollView.scrollTo( that._scrollView.scrollLeft + that._getScrollCoefficient( event, that._clientSize.width ), false ); // that._scrollView.scrollTop += event.deltaY < 0 ? -100 : 100; } } _refresh() { const that = this; if ( that._isUpdating ) { return; } const vScrollWidth = that.$.verticalScrollBar.offsetWidth; that.removeAttribute( 'grouped' ); that.removeAttribute( 'tree' ); let refreshColumns = true; if ( that.__autoHeightRows ) { that.__autoHeightRows = null; that._refreshColumnsResponsiveVisibility(); that._recycle(); refreshColumns = false; } if ( that.grouping.enabled && that.dataSource.groupBy && that.dataSource.groupBy.length >= 0 ) { that.grouping.renderMode === 'advanced' ? that.setAttribute( 'grouped', '' ) : that.setAttribute( 'tree', '' ); that._renderGroupBar(); } if ( that.grouping.enabled && that.dataSource.groupBy && that.dataSource.groupBy.length === 0 ) { if ( that.$.breadcrumb ) { that.$.breadcrumb.dataSource = []; } } else if ( that.dataSource.boundHierarchy ) { that.setAttribute( 'tree', '' ); that.setAttribute( 'role', 'treegrid' ); } if ( that.isInitialized || refreshColumns ) { // resize columns first, becase we have columns with auto or percentage width depending on the Grid's width. that._refreshColumnsResponsiveVisibility(); } // refresh layout and show or hide horizontal/vertical scrollbars.. that._refreshLayout(); if ( vScrollWidth !== that.$.verticalScrollBar.offsetWidth ) { that.__scrollWidth = null; that._refreshColumnsResponsiveVisibility(); that._refreshScrollBars(); } that._refreshSelection(); that._recycle(); that._refreshHeaderBar(); if ( that._recyclingRows && that._recyclingRows.length === 0 ) { const scrollViewTop = that.$.scrollView.offsetTop > 0 ? that.$.scrollView.offsetTop / 2 : 0; that.$.placeholder.classList.remove( 'lw-hidden' ); that.$.placeholder.style.marginTop = scrollViewTop + 'px'; that.scrollWidth = 0; that.scrollHeight = 0; } requestAnimationFrame( () => { that._width = that.offsetWidth; that._height = that.offsetHeight; } ); } _refreshHeaderBar() { const that = this; if (!that.$.headerBar) { return; } that.$.headerBar._refresh(); } /** * Grid resize handler. */ _resizeHandler( event ) { const that = this, target = that.enableShadowDOM ? event.composedPath()[ 0 ] : event.target; if ( target === that && !that._isUpdatingScrollBars ) { if ( !that.isInitialized ) { that._render(); return; } that._isUpdatingScrollBars = true; that._autoHeight = false; if ( that.$.content ) { that.$.content.classList.remove( 'auto-height' ); } that.refresh(); that._isUpdatingScrollBars = false; } } _refreshColumnsResponsiveVisibility() { const that = this; //const gridWidth = 1 + that.$.scrollView.offsetWidth; const columnContainer = that.$.columnContainer; const columnNearContainer = that.$.columnNearContainer; const columnFarContainer = that.$.columnFarContainer; let nearWidth = 0; let farWidth = 0; let computedColumnsWidth = 0; let isTreeColumnSet = false; for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; column._treeColumn = false; if ( that.grouping.enabled && ( column.rowDetailColumn || column.rowHeaderColumn ) ) { // column.canNotify = false; // column.visible = false; // column.canNotify = true; } if ( column.visible && !column.autoGenerated && !isTreeColumnSet && that.dataSource.boundHierarchy ) { column._treeColumn = true; isTreeColumnSet = true; } } that._refreshColumnWidths(); let autoGeneratedNearWidth = 0; let autoGeneratedFarWidth = 0; for ( let i = 0; i < that.viewColumns.length; i++ ) { const column = that.viewColumns[ i ]; if ( !column.visible ) { continue; } if ( column.freeze ) { if ( column.freeze === true || column.freeze === 'near' ) { nearWidth += column.computedWidth; if ( column.autoGenerated ) { autoGeneratedNearWidth += column.computedWidth; } } else if ( column.freeze === 'far' ) { farWidth += column.computedWidth; if ( column.autoGenerated ) { autoGeneratedFarWidth += column.computedWidth; } } } computedColumnsWidth += column.computedWidth; } columnContainer.style.width = computedColumnsWidth + 'px'; columnNearContainer.style.width = nearWidth + 'px'; columnFarContainer.style.width = farWidth + 'px'; columnFarContainer.classList.remove( 'lw-hidden' ); columnNearContainer.classList.remove( 'lw-hidden' ); if ( farWidth === 0 ) { columnFarContainer.classList.add( 'lw-hidden' ); } if ( nearWidth === 0 ) { columnNearContainer.classList.add( 'lw-hidden' ); } columnFarContainer.classList.remove( 'border-collapse' ); if ( farWidth === autoGeneratedFarWidth ) { columnFarContainer.classList.add( 'border-collapse' ); } that._autoGeneratedColumnsNearWidth = autoGeneratedNearWidth; that._autoGeneratedColumnsFarWidth = autoGeneratedFarWidth; that._computedColumnsWidth = computedColumnsWidth; that._frozenColumnsNearWidth = nearWidth; that._frozenColumnsFarWidth = farWidth; } /** * Document select start handler. */ _selectStartHandler( event ) { const that = this; if ( that.isScrolling || that.editing.isEditing ) { return; } event.preventDefault(); } /** * Set tabIndex. */ setFocusable( focusable ) { const that = this; if ( that.disabled || !focusable ) { that.removeAttribute( 'tabindex' ); return; } that.tabIndex = 0; } /** * Set Loading Indicator Visibility */ _setLoadingIndicatorVisibility() { const that = this; if ( that.appearance.displayLoadingIndicator ) { that.$.loadingIndicatorContainer.classList.remove( 'lw-visibility-hidden' ); return; } that.$.loadingIndicatorContainer.classList.add( 'lw-visibility-hidden' ); } _refreshElementsVisibility() { const that = this; const setVisibility = function ( element, visible ) { if ( !element ) { return; } visible ? element.classList.remove( 'lw-hidden' ) : element.classList.add( 'lw-hidden' ); } setVisibility( that.$.placeholder, ( !that.rows ) || ( that.rows && that.rows.length === 0 ) || ( that.columns.length === 0 ) ); setVisibility( that.$.footer, that.footer.visible ); setVisibility( that.$.header, that.header.visible ); setVisibility( that.$.groupHeader, that.groupHeader.visible || that.grouping.groupBar.visible ); setVisibility( that.$.columnHeader, that.columnHeader.visible && that.columns.length > 0 ); setVisibility( that.$.headerCommandBar, that.editing.commandBar.visible && that.editing.commandBar.position !== 'far' ); setVisibility( that.$.footerCommandBar, that.editing.commandBar.visible && that.editing.commandBar.position !== 'near' ); setVisibility( that.$.breadcrumb, that.groupHeader.visible || that.grouping.groupBar.visible ); that.htmlColumnLastChild.classList.add( 'lw-visibility-hidden' ); if ( that.pager && that.pager.visible && that.paging.enabled ) { switch ( that.pager.position ) { case 'near': setVisibility( that.$.headerPager, true ); setVisibility( that.$.footerPager, false ); break; case 'far': setVisibility( that.$.headerPager, false ); setVisibility( that.$.footerPager, true ); break; case 'both': setVisibility( that.$.headerPager, true ); setVisibility( that.$.footerPager, true ); break; } } else { setVisibility( that.$.footerPager, false ); setVisibility( that.$.headerPager, false ); } that._refreshRowHierarchy(); } _refreshRowHierarchy( ignoreExpanded ) { const that = this; that.rowHierarchy = null; let visibleIndex = 0; let isFlatHierarchy = false; if ( !that.grouping.enabled && that.dataSource.groupBy && that.dataSource.groupBy.length > 0 ) { isFlatHierarchy = true; } if ( that.dataSource.boundHierarchy ) { const reservedNames = that.dataSource.reservedNames; const addRow = function ( data ) { const row = new LW.Grid.Row( {data: data, index: that.rows.length} ) that.rowById[ row.id ] = row; return row; } const refreshRowsVisibility = function ( boundSource, hierarchy ) { for ( let i = 0; i < boundSource.length; i++ ) { const dataItem = boundSource[ i ]; let row = that.rowById[ dataItem.$.id ]; if ( !row ) { row = addRow( dataItem ); } row.data = dataItem; row.leaf = dataItem[ reservedNames.leaf ] || false; row.level = dataItem[ reservedNames.level ]; row.groupDataField = dataItem.groupDataField; row.label = dataItem.label; row.children = []; if ( row.data ) { row.filtered = row.data.$.filtered !== undefined ? row.data.$.filtered : true; } if ( dataItem.summaryRow ) { row.summaryRow = true; } if ( that._toggledRow === null || ( that._toggledRow && that._toggledRow.id !== row.id ) ) { row.expandHeight = 0; } if ( dataItem.parent ) { row.parent = that.rowById[ dataItem.parent.$.id ]; row.parentId = dataItem.parent.$.id; } else { row.parent = null; row.parentId = null; } let expanded = ignoreExpanded ? true : row.expanded; if ( isFlatHierarchy ) { expanded = true; } if ( row.visible === true && row.filtered !== false ) { if ( expanded || dataItem[ reservedNames.leaf ] ) { hierarchy.push( row ); if ( dataItem.children && dataItem.children.length > 0 ) { const children = refreshRowsVisibility( dataItem.children, new Array() ); if ( children.length === 0 ) { row.leaf = true; } for ( let t = 0; t < children.length; t++ ) { hierarchy.push( children[ t ] ); } row.children = children; } } else { hierarchy.push( row ); if ( dataItem.children && dataItem.children.length > 0 ) { const children = refreshRowsVisibility( dataItem.children, new Array() ); if ( children.length === 0 ) { row.leaf = true; } row.children = children; } } } } return hierarchy; }; let hierarchy = that.dataSource.boundHierarchy; if ( that.paging.enabled ) { hierarchy = hierarchy.slice( that.paging.pageIndex * that.paging.pageSize, ( that.paging.pageIndex + 1 ) * that.paging.pageSize ); } that.rowHierarchy = refreshRowsVisibility( hierarchy, new Array() ); let flatHierarchy = []; for ( let i = 0; i < that.rowHierarchy.length; i++ ) { const row = that.rowHierarchy[ i ]; const notify = row.canNotify; if ( row.leaf ) { flatHierarchy.push( row ); } row.canNotify = false; row.visibleIndex = visibleIndex++; row.canNotify = notify; } if ( isFlatHierarchy ) { that.rowHierarchy = flatHierarchy; } if ( that._rowElements.length < that.rowHierarchy.length && !that._toggledRow ) { that._initializeRowElements(); } if ( that.grouping.summaryRow.visible && !that.grouping.summaryRow.inline ) { const addHierarchySummaryRow = function ( level, hierarchy, parent, index ) { if ( level !== 0 ) { if ( hierarchy.length > 0 && hierarchy[ hierarchy.length - 1 ] && !hierarchy[ hierarchy.length - 1 ].summaryRow ) { let dataItem = { label: ' ', boundSource: [], groupDataField: parent.data.groupDataField, $: { }, summaryRow: true, leaf: true, level: level, expandHeight: 0, siblings: hierarchy }; dataItem.$.id = 'SubRow' + index + '_' + parent.data.$.id; if ( parent ) { dataItem.parent = parent.data; dataItem.parentId = parent.data.$.id; } dataItem.data = Object.assign( dataItem ); hierarchy.push( dataItem ); } } for ( let i = 0; i < hierarchy.length; i++ ) { if ( hierarchy[ i ] && hierarchy[ i ].data && hierarchy[ i ].data.children ) { addHierarchySummaryRow( level + 1, hierarchy[ i ].data.children, hierarchy[ i ], i ); } } } addHierarchySummaryRow( 0, that.rowHierarchy, null, 0 ); } } } applyContent() { } _refreshContentHeight() { const that = this; let contentHeight = that._clientSize.height; const windowScrollY = window.scrollY; const offsetHeight = that.offsetHeight; that.$.container.classList.add( 'lw-hidden' ); const newOffsetHeight = that.offsetHeight; that.$.container.classList.remove( 'lw-hidden' ); if ( window.scrollY !== windowScrollY ) { window.scrollTo( window.scrollX, windowScrollY ); } if ( that.verticalScrollBarVisibility === 'hidden' || ( offsetHeight !== newOffsetHeight ) || ( that._minHeight && that._minHeight === offsetHeight ) ) { contentHeight = that._scrollHeight + that.$.columnHeader.offsetHeight + that.$.filterFooter.offsetHeight; if ( that._minHeight > contentHeight ) { contentHeight = that._minHeight; } that.$.content.style.height = contentHeight + 'px'; that._contentHeight = contentHeight; if ( that._maxHeight < contentHeight ) { that._autoHeight = false; that.$.content.classList.remove( 'auto-height' ); that.$.content.style.height = that._maxHeight + 'px'; that._contentHeight = that._maxHeight; } else { that._autoHeight = true; that.$.content.classList.add( 'auto-height' ); } return; } if ( that.header.visible ) { contentHeight -= that.$.header.offsetHeight; } if ( that.groupHeader.visible || that.grouping.groupBar.visible ) { contentHeight -= that.$.groupHeader.offsetHeight; } if ( that.footer.visible ) { contentHeight -= that.$.footer.offsetHeight; } if ( that.pager.visible ) { contentHeight -= that.$.headerPager.offsetHeight; contentHeight -= that.$.footerPager.offsetHeight; } if ( that.editing.enabled && that.editing.commandBar.visible ) { contentHeight -= that.$.headerCommandBar.offsetHeight; contentHeight -= that.$.footerCommandBar.offsetHeight; } that.$.content.style.height = contentHeight + 'px'; that._contentHeight = contentHeight; } appendChild() { const args = Array.prototype.slice.call( arguments, 2 ); return HTMLElement.prototype.appendChild.apply( this, args.concat( Array.prototype.slice.call( arguments ) ) ); } removeChild() { const args = Array.prototype.slice.call( arguments, 2 ); return HTMLElement.prototype.removeChild.apply( this, args.concat( Array.prototype.slice.call( arguments ) ) ); } get _contentBorder() { const that = this; if ( that.__contentBorder ) { return that.__contentBorder; } const contentComputedStyle = getComputedStyle( that.$.content ); const contentBorderX = parseFloat( contentComputedStyle.borderLeftWidth ) + parseFloat( contentComputedStyle.borderRightWidth ); const contentBorderY = parseFloat( contentComputedStyle.borderTopWidth ) + parseFloat( contentComputedStyle.borderBottomWidth ); const border = { left: contentBorderX, top: contentBorderY }; that.__contentBorder = border; return border; } /** * Sets the initial scroll bar sizes. */ _refreshLayout() { const that = this; const source = that.rows; if ( that._layoutSuspended ) { return; } that._visibleRows = null; that.__viewRows = null; that.__clientSize = null; that.__scrollHeight = null; that.__scrollWidth = null; that.__parentCells = null; that.$.columnFarContainer.classList.remove( 'vscroll' ); that.$.columnNearContainer.classList.remove( 'vscroll' ); that.$.scrollView.classList.remove( 'hscroll' ); that.$.scrollView.classList.remove( 'vscroll' ); that._refreshElementsVisibility(); that._refreshColumnHeights(); that._refreshContentHeight(); if ( !( source && source.url ) ) { if ( !source || source === null || source.length === 0 || that.columns.length === 0 ) { const scrollViewTop = that.$.scrollView.offsetTop > 0 ? that.$.scrollView.offsetTop / 2 : 0; that.$.placeholder.classList.remove( 'lw-hidden' ); that.$.placeholder.style.marginTop = scrollViewTop + 'px'; that.scrollWidth = 0; that.scrollHeight = 0; return; } } if ( !that.__columnHeaderHeight ) { that.__columnHeaderHeight = that.$.columnHeader.offsetHeight; } if ( !that.__filterFooterOffsetHeight ) { that.__filterFooterOffsetHeight = that.$.filterFooter.classList.contains( 'lw-hidden' ) ? 0 : that.$.filterFooter.offsetHeight; } const scrollViewOffsetHeight = that._contentHeight - that.__filterFooterOffsetHeight - that.__columnHeaderHeight; that.$.scrollView.style.height = scrollViewOffsetHeight + 'px'; that.htmlColumnLastChild.style.height = that.__columnHeaderHeight + 'px'; if ( that.paging.spinner.enabled && that.paging.enabled ) { if ( !that.pageScroll ) { const pageScroll = document.createElement( 'lw-scroll-bar' ); pageScroll.orientation = 'vertical'; pageScroll.style.height = '100%'; pageScroll.style.width = '100%'; pageScroll.max = Math.ceil( that.dataSource.length / that.paging.pageSize ); pageScroll.step = that.paging.spinner.step; pageScroll.largeStep = that.paging.spinner.step; pageScroll.setAttribute( 'spinner', '' ); pageScroll.setAttribute( 'lw-id', 'spinner' ); pageScroll.ownerElement = that; that.addPropertyBinding( '[[paging_spinner_step]]', 'step', pageScroll, that.$.columnHeader ); pageScroll.addEventListener( 'change', function ( event ) { that.paging.pageIndex = event.detail.value; } ); that.pageScroll = pageScroll; } that.htmlColumnLastChild.appendChild( that.pageScroll ); } else { that.htmlColumnLastChild.innerHTML = ''; } that._refreshScrollBars(); } _refreshScrollBars() { const that = this; const vScrollBar = that._scrollView.vScrollBar; const hScrollBar = that._scrollView.hScrollBar; const scrollViewOffsetHeight = that._contentHeight - that.__filterFooterOffsetHeight - that.__columnHeaderHeight; const scrollViewOffsetWidth = that.$.scrollView.offsetWidth; const hScrollWidth = that._scrollWidth - scrollViewOffsetWidth - that._contentBorder.left; const vScrollHeight = that._scrollHeight - scrollViewOffsetHeight - that._contentBorder.top; const columnNearContainerComputedStyle = that._columnNearContainerComputedStyle ? that._columnNearContainerComputedStyle : getComputedStyle( that.$.columnNearContainer ); const columnFarContainerComputedStyle = that._columnFarContainerComputedStyle ? that._columnFarContainerComputedStyle : getComputedStyle( that.$.columnFarContainer ); const nearWidth = parseInt( that.$.columnNearContainer.style.width ) + parseInt( columnNearContainerComputedStyle.borderRightWidth ); const farWidth = parseInt( that.$.columnFarContainer.style.width ) + parseInt( columnFarContainerComputedStyle.borderLeftWidth ); that.__frozenNearWidth = nearWidth; that.__frozenFarWidth = farWidth; that._columnNearContainerComputedStyle = columnNearContainerComputedStyle; that._columnFarContainerComputedStyle = columnFarContainerComputedStyle; that._refreshHorizontalScrollBarVisibility( hScrollWidth ); that._refreshVerticalScrollBarVisibility( vScrollHeight ); vScrollBar.style.height = scrollViewOffsetHeight + 'px'; if ( that.computedVerticalScrollBarVisibility ) { if ( !that.__scrollBarSize ) { that.__scrollBarSize = vScrollBar.offsetWidth; } that.__scrollWidth += that.__scrollBarSize; that._refreshHorizontalScrollBarVisibility( that._scrollWidth - scrollViewOffsetWidth - 1 ); if ( !that.rightToLeft ) { that.$.columnFarContainer.classList.add( 'vscroll' ); } else { that.$.columnNearContainer.classList.add( 'vscroll' ); } // increase the vertical scrollbar max after showing the horizontal. that._refreshVerticalScrollBarVisibility( vScrollHeight ); that.htmlColumnLastChild.classList.remove( 'lw-visibility-hidden' ); } hScrollBar.style.width = scrollViewOffsetWidth + 'px'; if ( !that.rightToLeft ) { hScrollBar.style.left = '0px'; } else { hScrollBar.style.right = '0px'; } if ( that.computedVerticalScrollBarVisibility && that.computedHorizontalScrollBarVisibility ) { hScrollBar.style.width = scrollViewOffsetWidth - vScrollBar.offsetWidth + 'px'; vScrollBar.style.height = scrollViewOffsetHeight - hScrollBar.offsetHeight + 'px'; } if ( that.computedHorizontalScrollBarVisibility ) { that.$.scrollView.classList.add( 'hscroll' ); if ( that._autoHeight ) { that.$.content.style.height = 'auto'; that.$.scrollView.style.height = 'auto'; that.$.scrollView.style.paddingBottom = hScrollBar.offsetHeight + 'px'; } else { that.$.scrollView.style.paddingBottom = ''; } } else { that.$.scrollView.classList.remove( 'hscroll' ); } if ( ( that.__frozenNearHeight > 0 || ( that._frozenNearRows && that._frozenNearRows.length > 0 ) ) && !that.appearance.showVerticalScrollBarOnFixedColumns ) { const rowNearContainerComputedStyle = getComputedStyle( that.$.rowNearContainer ); const nearHeight = that.__frozenNearHeight + parseInt( rowNearContainerComputedStyle.borderBottomWidth ); vScrollBar.style.height = parseInt( vScrollBar.style.height ) - nearHeight + 'px'; vScrollBar.style.top = nearHeight + 'px'; vScrollBar.style.setProperty( '--lw-scroll-bar-near-size', nearHeight + 'px' ); } else if ( that.appearance.showVerticalScrollBarOnFixedColumns ) { vScrollBar.style.top = '0px'; } if ( ( that.__frozenFarHeight > 0 || ( that._frozenFarRows && that._frozenFarRows.length > 0 ) ) && !that.appearance.showVerticalScrollBarOnFixedColumns ) { const rowFarContainerComputedStyle = getComputedStyle( that.$.rowFarContainer ); const farHeight = -2 + that.__frozenFarHeight + parseInt( rowFarContainerComputedStyle.borderTopWidth ); vScrollBar.style.height = parseInt( vScrollBar.style.height ) - farHeight + 'px'; vScrollBar.style.setProperty( '--lw-scroll-bar-far-size', farHeight + 'px' ); if ( that.__frozenNearHeight === 0 ) { vScrollBar.style.top = '0px'; } } if ( ( nearWidth > 0 || farWidth > 0 ) && !that.appearance.showHorizontalScrollBarOnFixedColumns ) { hScrollBar.style.width = parseInt( hScrollBar.style.width ) - nearWidth - farWidth + 'px'; if ( !that.rightToLeft ) { hScrollBar.style.left = nearWidth + 'px'; } else { hScrollBar.style.right = nearWidth + 'px'; } hScrollBar.style.setProperty( '--lw-scroll-bar-near-size', nearWidth + parseInt( columnNearContainerComputedStyle.borderRightWidth ) + 'px' ); hScrollBar.style.setProperty( '--lw-scroll-bar-far-size', farWidth + parseInt( columnNearContainerComputedStyle.borderLeftWidth ) + 'px' ); if ( that.computedVerticalScrollBarVisibility ) { if ( !that.__scrollBarSize ) { that.__scrollBarSize = vScrollBar.offsetWidth; } hScrollBar.style.setProperty( '--lw-scroll-bar-far-size', farWidth + that.__scrollBarSize + 'px' ); } } vScrollBar.refresh(); hScrollBar.refresh(); } /** * Enable/Disable Horizontal Scroll bar. */ _refreshHorizontalScrollBarVisibility( scrollWidth ) { const that = this; that.scrollWidth = scrollWidth; if ( !that.computedHorizontalScrollBarVisibility ) { that.scrollLeft = 0; } } /** * Enable/Disable Vertical Scroll bar. */ _refreshVerticalScrollBarVisibility( scrollHeight ) { const that = this; if ( that._autoHeight ) { that.scrollTop = 0; that.scrollHeight = 0; return; } if ( that.computedHorizontalScrollBarVisibility ) { scrollHeight += that.$.horizontalScrollBar.offsetHeight; } that.scrollHeight = scrollHeight; if ( that.paging.enabled && that.paging.spinner.visible ) { that.$.verticalScrollBarVisibility.classList.remove( 'lw-hidden' ); } if ( !that.computedVerticalScrollBarVisibility ) { that.scrollTop = 0; } } /** * Style change event. */ _styleChangedHandler( event ) { const that = this; if ( event.detail.styleProperties[ 'overflow' ] || that.classList.contains( 'lw-grid-resize-mode' ) ) { return; } if ( event.detail.styleProperties[ 'grid-template-columns' ] ) { that._templateColumns(); that.refresh(); return; } if ( event.detail.styleProperties[ 'font-size' ] ) { that.layout.isDirty = true; that._resetCachedLayout(); that.refresh(); return; } if ( event.detail.styleProperties[ '--lw-grid-row-height' ] || event.detail.styleProperties[ '--lw-font-size' ] || event.detail.styleProperties[ '--lw-grid-column-header-height' ] || event.detail.styleProperties[ '--lw-grid-group-header-height' ] || event.detail.styleProperties[ '--lw-grid-filter-footer-height' ] || event.detail.styleProperties[ '--lw-grid-group-row-vertical' ] || event.detail.styleProperties[ '--lw-grid-group-row-horizontal-offset' ] || event.detail.styleProperties[ '--lw-grid-freeze-splitter-size' ] || event.detail.styleProperties[ '--lw-grid-resize-line-size' ] || event.detail.styleProperties[ '--lw-grid-footer-height' ] || event.detail.styleProperties[ '--lw-grid-header-height' ] ) { that.layout.isDirty = true; } if ( that.offsetWidth && that.offsetHeight > 0 ) { that._resetCachedLayout(); that._refreshLayout(); that._recycle(); } } _resetCachedLayout() { const that = this; that.__cellsCommandTemplate = null; that.__autoRowHeight = null; that.__autoHeightRows = null; that.__measuredColumnHeight = null; that.__columnHeaderHeight = null; that.__filterFooterOffsetHeight = null; } /** * SwipeLeft event handler. **/ _swipeLeftHandler() { } /** * SwipeRight event handler. */ _swipeRightHandler() { } _getRowIndexByPosition( position ) { const that = this; const getRowIndex = ( rows ) => { let bottomPointer = 0; let topPointer = rows.length - 1; if ( position <= 0 ) { return 0; } const lastNode = rows[ rows.length - 1 ]; if ( lastNode.top !== -1 && lastNode.top <= position ) { return rows.length - 1; } const condition = true; while ( condition ) { const midPointer = Math.floor( ( bottomPointer + topPointer ) / 2 ); const currentrow = rows[ midPointer ]; if ( that._isRowInPosition( currentrow, position ) ) { return midPointer; } else if ( currentrow.top < position ) { bottomPointer = midPointer + 1; } else if ( currentrow.top > position ) { topPointer = midPointer - 1; } else { bottomPointer = midPointer + 1; } } }; const index = getRowIndex( that._recyclingRows ); return index; } getViewRows() { const that = this; if ( that.rowHierarchy ) { return that.rowHierarchy; } let rows = that.getVisibleRows(); return rows; } get _recyclingRows() { const that = this; if ( that.rowHierarchy ) { return that.rowHierarchy; } let rows = that.getVisibleRows(); if ( that.paging.enabled ) { rows = rows.slice( that.paging.pageIndex * that.paging.pageSize, ( that.paging.pageIndex + 1 ) * that.paging.pageSize ); } return rows; } _isRowInPosition( row, position ) { const topPixel = row.top; const bottomPixel = row.top + row.height; const pixelInRow = topPixel <= position && bottomPixel > position; if ( row.height === 0 ) { return false; } return pixelInRow; } _renderColumnGroupHeaders() { const that = this; for ( let i = 0; i < that.columnGroups.length; i++ ) { const columnGroup = that.columnGroups[ i ]; columnGroup.column.render(); columnGroup.column.allowReorder = false; columnGroup.column.element.setAttribute( 'columnHeader', '' ); if ( columnGroup.columns.length === 0 ) { columnGroup.column.element.classList.add( 'lw-hidden' ); } if ( i === 0 ) { columnGroup.column.element.classList.add( 'lw-grid-column-border-collapse' ); } } } _isLastVisibleColumn( column ) { const that = this; for ( let i = that.viewColumns.length - 1; i >= 0; i-- ) { const currentColumn = that.viewColumns[ i ]; if ( !currentColumn.visible ) { continue; } if ( currentColumn === column ) { return true; } return false; } return false; } _recycle( recycleColumns, recycleRows ) { const that = this; if ( that._layoutSuspended ) { return; } if ( that._isUpdating ) { return; } if ( that.editing.isEditing ) { that.endEdit(); if ( that._isUpdating ) { return; } } if ( that._inputOverlay ) { if ( that._inputOverlay.parentNode ) { that._inputOverlay.parentNode.removeChild( that._inputOverlay ); } that._inputOverlay = null; } if ( that._selection.selectionRect ) { that._refreshCellSelectionRect(); } const value = that._scrollView.scrollTop; let rowIndex = that._getRowIndexByPosition( value ); let rows = that._recyclingRows; let row = rows[ rowIndex ]; let rowTop = row ? row.top : 0; let columnLeft = undefined; let nearWidth = 0; let j = 0; let rowSpanOffset = 0; let colSpanOffset = 0; for ( let i = 0; i < that._cellsMerge.length; i++ ) { const cell = that._cellsMerge[ i ]; const startRowIndex = rows.indexOf( cell.row ); if ( rowIndex > startRowIndex && rowIndex <= startRowIndex + cell.rowSpan ) { rowIndex = startRowIndex; row = cell.row; rowSpanOffset = Math.max( rowSpanOffset, rowTop - row.top ); rowTop = row.top; that.$.rowContainer.style.top = that.__frozenNearHeight - value + rowTop + 'px'; } if ( cell.colSpan > 1 ) { for ( let j = 0; j < that.viewColumns.length; j++ ) { const viewColumn = that.viewColumns[ j ]; let column = viewColumn.autoGenerated ? viewColumn : that.columnByDataField[ viewColumn.dataField ]; if ( !column.visible ) { continue; } if ( column.left + column.computedWidth - that._scrollView.scrollLeft >= nearWidth && column.left - column.computedWidth - that._scrollView.scrollLeft < that._clientSize.width ) { let cellColumn = that.columnByDataField[ cell.column.dataField ] colSpanOffset = Math.max( colSpanOffset, column.left - cellColumn.left + column.computedWidth ); break; } } } } if ( recycleColumns !== false || that._cellsMerge.length > 0 ) { for ( let i = 0; i < that._columnElements.length; i++ ) { const columnElement = that._columnElements[ i ]; if ( !columnElement.parentNode ) { break; } columnElement.set( 'column', null, false ); columnElement.classList.add( 'lw-visibility-hidden' ); } for ( let i = 0; i < that.columnGroups.length; i++ ) { const column = that.columnGroups[ i ]; const header = column.element; if ( !that.rightToLeft ) { header.style.left = column.left + 'px'; } else { header.style.right = column.right + 'px'; } header.style.width = column.computedWidth + 'px'; } that._firstVisibleColumn = null; that._lastVisibleColumn = null; for ( let i = 0; i < that.viewColumns.length; i++ ) { const viewColumn = that.viewColumns[ i ]; // let column = viewColumn.autoGenerated ? viewColumn : that.columnByDataField[viewColumn.dataField]; let column = viewColumn; if ( column.visible ) { if ( !that._firstVisibleColumn ) { that._firstVisibleColumn = column; } that._lastVisibleColumn = column; } if ( column.element ) { if ( column === that._firstVisibleColumn ) { column.element.classList.add( 'lw-grid-column-border-collapse' ); } else { column.element.classList.remove( 'lw-grid-column-border-collapse' ); } column.element.removeAttribute( 'aria-colindex' ); } if ( column.freeze ) { if ( column.freeze === true || column.freeze === 'near' ) { if ( column.visible ) { nearWidth += column.computedWidth; } } if ( !column.visible ) { column.element.classList.add( 'lw-visibility-hidden' ); } else { column.element.classList.remove( 'lw-visibility-hidden' ); column.render(); } continue; } if ( !column.visible ) { continue; } if ( column.left + column.computedWidth - that._scrollView.scrollLeft >= nearWidth - colSpanOffset && column.left - column.computedWidth - that._scrollView.scrollLeft < that._clientSize.width ) { const columnElement = that._columnElements[ j++ ]; columnElement.set( 'column', column, false ); if ( !columnElement.parentNode ) { that.$.columnContainer.appendChild( columnElement ); } column.element = columnElement; column.render(); columnElement.setAttribute( 'aria-colindex', i + 1 ); if ( columnLeft === undefined ) { columnLeft = column.left; } } } } if ( columnLeft === undefined ) { columnLeft = 0; } if ( !that.rightToLeft ) { that.$.columnContainer.style.left = -that._scrollView.scrollLeft + 'px'; } else { that.$.columnContainer.style.right = that._scrollView.scrollWidth - that._scrollView.scrollLeft - that._scrollView.vScrollBar.offsetWidth + 'px'; } that.$.rowContainer.style.top = that.__frozenNearHeight - value + rowTop + 'px'; if ( recycleRows === false ) { return; } if ( !that._rowElements ) { return; } if ( rowIndex >= 0 ) { j = 0; let offsetHeight = Math.max( that._clientSize.height, that._overflowOffset ); for ( let i = rowIndex; i < rows.length; i++ ) { const row = rows[ i ]; if ( row.height === 0 || !row.visible || ( row.filtered === false ) || row.freeze ) { continue; } const rowHeight = row.height; if ( row.expandHeight ) { offsetHeight += that.offsetHeight + row.expandHeight; } if ( ( rowTop + rowHeight >= value - rowSpanOffset && rowTop <= value + offsetHeight ) || that._autoHeight ) { const rowElement = that._rowElements[ j++ ]; if ( !rowElement ) { break; } rowElement.setAttribute( 'aria-rowindex', i + 1 ); row.element = rowElement; row.grid = that; row.render(); } else { break; } rowTop += rowHeight; } } that._renderFrozenRows(); if ( j < that._rowElements.length ) { for ( let i = j; i < that._rowElements.length; i++ ) { const scrollRow = that._rowElements[ j++ ]; scrollRow.classList.add( 'lw-hidden' ); scrollRow.removeAttribute( 'aria-rowindex' ); } } } _renderFrozenRows() { const that = this; let anyFrozenNearRowVisible = false; let anyFrozenFarRowVisible = false; if ( that._frozenNearRows.length === 0 ) { that.$.rowNearContainer.classList.add( 'lw-hidden' ); } else { that.$.rowNearContainer.classList.remove( 'lw-hidden' ); } for ( let i = 0; i < that._frozenNearRows.length; i++ ) { const row = that._frozenNearRows[ i ]; if ( row.visible && row.filtered ) { anyFrozenNearRowVisible = true; row.element = that.$.rowNearContainer.children[ i ]; if ( !row.element ) { row.element = row.createElement(); that.$.rowNearContainer.appendChild( row.element ); } row.render(); } } if ( !anyFrozenNearRowVisible ) { that.$.rowNearContainer.classList.add( 'lw-hidden' ); } if ( that._frozenFarRows.length === 0 ) { that.$.rowFarContainer.classList.add( 'lw-hidden' ); } else { that.$.rowFarContainer.classList.remove( 'lw-hidden' ); } for ( let i = 0; i < that._frozenFarRows.length; i++ ) { const row = that._frozenFarRows[ i ]; if ( row.visible ) { anyFrozenFarRowVisible = true; } row.element = that.$.rowFarContainer.children[ i ]; if ( !row.element ) { row.element = row.createElement(); that.$.rowFarContainer.appendChild( row.element ); } row.render(); } if ( !anyFrozenFarRowVisible ) { that.$.rowFarContainer.classList.add( 'lw-hidden' ); } } _recycleRotate( columnHeaderCellContentElement, textElement, halign, valign, value ) { const textRectangle = textElement.getBoundingClientRect(); const boundingRectangle = columnHeaderCellContentElement.getBoundingClientRect(); const padding = 4; let left = 0; let top = 0; if ( boundingRectangle.width === 0 ) { columnHeaderCellContentElement.innerHTML = value; return false; } if ( textRectangle.left > boundingRectangle.left ) { left = boundingRectangle.left - textRectangle.left; } if ( textRectangle.top < boundingRectangle.top ) { top = boundingRectangle.top - textRectangle.top; } if ( halign === 'left' || halign === '' ) { left = padding; } if ( halign === 'center' ) { left += boundingRectangle.width / 2 - textRectangle.width / 2; } if ( halign === 'right' ) { left += boundingRectangle.width - textRectangle.width - padding; } if ( valign === 'top' || valign === '' ) { top = padding; } if ( valign === 'center' || valign === 'middle' ) { top += boundingRectangle.height / 2 - textRectangle.height / 2; } if ( valign === 'bottom' ) { top += boundingRectangle.height - textRectangle.height - padding; } textElement.style.left = left + 'px'; textElement.style.top = top + 'px'; return true; } _virtualDataRequest( action ) { const that = this; let first = -1; let last = -1; if ( !that._rowElements && that.scrolling !== 'infinite' ) { return; } if ( that.scrolling === 'virtual' ) { for ( let i = 0; i < that._rowElements.length; i++ ) { const rowElement = that._rowElements[ i ]; const row = rowElement.row; const visibleIndex = i === 0 ? row.visibleIndex : first + i; if ( rowElement.classList.contains( 'lw-hidden' ) ) { continue; } if ( first === -1 ) { first = visibleIndex; } if ( visibleIndex === -1 ) { continue; } last = 1 + visibleIndex; } } else if ( that.scrolling === 'infinite' ) { first = Infinity; last = Infinity; } else { first = 0; last = that.dataSource.length; } if ( that.paging.enabled ) { first = that.paging.pageIndex * that.paging.pageSize; last = first + that.paging.pageSize; } if ( last !== Infinity ) { last = Math.min( last, that.dataSource.length ); } that.appearance.displayLoadingIndicator = true; that._setLoadingIndicatorVisibility(); const details = { first: first, last: last, sorting: that.getSortedColumns(), filtering: that.getFilteredColumns(), grouping: [], row: that._toggledRow ? that._toggledRow.data : null, action: action } const dataSourceLength = that.dataSource.length; if ( undefined === that._isFirstVirtualDataSourceRequest ) { that._isFirstVirtualDataSourceRequest = true; } that.dataSource.onVirtualDataSourceRequested( function () { that.appearance.displayLoadingIndicator = false; that._setLoadingIndicatorVisibility(); that._toggledRow = null; const context = that.context; that.context = that; if ( that._isFirstVirtualDataSourceRequest && that._initColumns.length === 0 ) { that.columns.canNotify = false; that.columns = []; that._renderColumns(); that.columns.canNotify = true; } if ( that.dataSource.length !== dataSourceLength || that._isFirstVirtualDataSourceRequest ) { if ( that.paging.enabled ) { that.$.headerPager.querySelector( 'lw-pager' ).pagesCount = Math.ceil( that.dataSource.length / that.paging.pageSize ); that.$.footerPager.querySelector( 'lw-pager' ).pagesCount = Math.ceil( that.dataSource.length / that.paging.pageSize ); } that._initializeRows(); that._initializeRowElements(); that.refresh(); that._refreshPagesCount(); } else if ( that.dataSource.virtualDataSourceOnExpand ) { that.refresh(); } that._isFirstVirtualDataSourceRequest = false; that._recycle(); that.context = context; }, details ); } /** * Vertical Scroll Bar handler */ _verticalScrollbarHandler( data ) { const that = this; if ( that.menu && that.menu.column ) { that.closeMenu(); } that.isScrolling = true; if ( that._scrollTimer ) { clearTimeout( that._scrollTimer ); } if ( that._layoutSuspended ) { return; } that._scrollTimer = setTimeout( () => { that._recycle( false ); that.isScrolling = false; if ( data.max === data.value ) { that.$.fireEvent( 'scrollBottomReached' ); if ( that.scrolling === 'infinite' ) { that._virtualDataRequest( 'scroll' ); return; } } if ( that.scrolling === 'virtual' ) { that._virtualDataRequest( 'scroll' ); } if ( data.min === data.value ) { that.$.fireEvent( 'scrollTopReached' ); } } ); } /* Public API */ /** * Removes all rows from DOM. */ clearRows() { const that = this; that.dataSource = new LW.DataAdapter( { dataSource: [] } ); that.rowHierarchy = null; that._visibleRows = null; that.__viewRows = null; that.rows.canNotify = false; that.rows.length = 0; that.rows.canNotify = true; that.clearSelection(); } dataBind() { const that = this; delete that.__autoRowHeight; if ( that.dataSource === null || ( that.dataSource && that.dataSource.dataFields && that.dataSource.length === 0 && that.dataSource.dataSource.length === 0 && !that.dataSource.virtualDataSource ) ) { that.clearRows(); } else if ( Array.isArray( that.dataSource ) ) { that.dataSource = new LW.DataAdapter( { dataSource: that.dataSource } ); } const sortColumns = that._sortedColumns; that.clearSort(); if ( that._initColumns && that._initColumns.length === 0 ) { that.columns = []; that._renderColumns( true ); } that._renderRows(); if ( that.scrolling === 'virtual' || ( that.paging.enabled && that.dataSource && that.dataSource.virtualDataSource ) ) { that._virtualDataRequest( 'dataBind' ); } else if ( that.dataSource && that.dataSource.virtualDataSource ) { that._virtualDataRequest( 'dataBind' ); } else if ( that.paging.enabled && ( !that.dataSource || ( that.dataSource && !that.dataSource.url ) ) ) { that._refreshPagesCount(); } if ( sortColumns ) { that._refreshSort( sortColumns ); } } refresh( fullRefresh ) { const that = this; if ( !that.isInitialized ) { return; } if ( fullRefresh ) { that._initializeRows(); that._initializeRowElements(); } that._refresh(); } refreshView() { const that = this; that._recycle(); } beginUpdate() { const that = this; if ( !that._isUpdating ) { that._isUpdating = 0; } that._isUpdating++; } endUpdate( refresh ) { const that = this; that._isUpdating--; if ( that._isUpdating < 0 ) { that._isUpdating = 0; } if ( refresh !== false ) { that.refresh(); } else { that.refreshView(); } } } ); // eslint-disable-next-line strict ( function () { LW.Grid.Extend = function ( module ) { if ( !module ) { return; } const methodNames = Object.getOwnPropertyNames( module.prototype ); for ( let index in methodNames ) { const methodName = methodNames[ index ]; if ( methodName === 'constructor' ) { continue; } LW.Grid.prototype[ methodName ] = module.prototype[ methodName ]; } }; LW.Grid.Extend( LW.Utilities.Grid.Resize ); LW.Grid.Extend( LW.Utilities.Grid.Reorder ); LW.Grid.Extend( LW.Utilities.Grid.Pager ); LW.Grid.Extend( LW.Utilities.Grid.Filter ); LW.Grid.Extend( LW.Utilities.Grid.Sort ); LW.Grid.Extend( LW.Utilities.Grid.Menu ); LW.Grid.Extend( LW.Utilities.Grid.Select ); LW.Grid.Extend( LW.Utilities.Grid.Edit ); LW.Grid.Extend( LW.Utilities.Grid.Group ); LW.Grid.Extend( LW.Utilities.Grid.Tree ); LW.Grid.Extend( LW.Utilities.Grid.Export ); LW.Grid.Extend( LW.Utilities.Grid.Chart ); LW.Grid.Cell = LW.Utilities.Grid.Cell; LW.Grid.Row = LW.Utilities.Grid.Row; LW.Grid.Column = LW.Utilities.Grid.Column; } )(); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Menu Item custom element. */ LW('lw-menu-item', class MenuItem extends LW.BaseElement { // Menu Item's properties. static get properties() { return { 'checked': { value: false, type: 'boolean' }, 'label': { value: '', type: 'any' }, 'level': { value: null, type: 'number?' }, 'separator': { value: false, type: 'boolean' }, 'shortcut': { value: '', type: 'string' }, 'value': { value: null, type: 'any' } }; } get enableShadowDOM() { return false; } /** * Menu Items Group's HTML template. */ template() { return ''; } ready() { const that = this; super.ready(); that.$.addClass('lw-unselectable'); that.setAttribute('role', 'menuitem'); if (that.checked) { that.setAttribute('aria-checked', true); } } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); if (that.tagName.toLowerCase() === 'lw-tree-item') { return; } const parentMenu = that.menu, parentItem = that.parentItem, parentObject = parentItem || parentMenu; if (propertyName === 'label') { if (newValue === '') { that.label = oldValue; return; } that.setAttribute('aria-label', newValue); if (parentMenu) { parentMenu._setItemLabel(that, newValue); } return; } if (!parentMenu) { return; } if (propertyName === 'separator') { parentMenu._refreshCheckableItems(parentObject); return; } if (propertyName !== 'disabled' || newValue === false || !that.checked) { return; } super.propertyChangedHandler(propertyName, oldValue, newValue); that.checked = false; const checkMode = parentObject.checkMode; if (checkMode === 'radioButton') { parentMenu._validateRadioButtonSelection(parentItem, that.level, []); } else if (checkMode !== 'checkbox') { parentMenu._refreshCheckableItems(parentObject); } } }); /** * Menu Items Group custom element. */ LW('lw-menu-items-group', class MenuItemsGroup extends LW.BaseElement { // Menu Items Group's properties. static get properties() { return { 'checkable': { value: false, type: 'boolean' }, 'checked': { value: false, type: 'boolean' }, 'checkMode': { value: 'checkbox', type: 'string' }, 'dropDownHeight': { value: null, type: 'number?' }, 'expanded': { value: false, type: 'boolean' }, 'label': { value: '', type: 'any' }, 'level': { value: null, type: 'number?' }, 'separator': { value: false, type: 'boolean' }, 'value': { value: null, type: 'any' } }; } get enableShadowDOM() { return false; } /** * Menu Items Group's HTML template. */ template() { return ''; } ready() { const that = this; super.ready(); that.$.addClass('lw-unselectable'); that.setAttribute('role', 'menuitem'); that.setAttribute('aria-haspopup', true); that.setAttribute('aria-expanded', that.expanded); if (that.checked) { that.setAttribute('aria-checked', true); } } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); if (that.tagName.toLowerCase() === 'lw-tree-items-group') { return; } const parentMenu = that.menu, parentItem = that.parentItem, parentObject = parentItem || parentMenu; if (propertyName === 'label') { if (newValue === '') { that.label = oldValue; return; } that.setAttribute('aria-label', newValue); if (parentMenu) { parentMenu._setItemLabel(that, newValue); } return; } if (!parentMenu) { return; } if (['checkable', 'checkMode', 'disabled', 'separator'].indexOf(propertyName) === -1) { return; } switch (propertyName) { case 'checkable': if (newValue) { that.itemContainer.setAttribute('checkable', ''); } else { that.itemContainer.removeAttribute('checkable'); } if (parentMenu._isContainerOpened(that.container.level, that.container) && parentMenu.mode !== 'tree' && !parentMenu._minimized) { parentMenu._closeSubContainers(that.level + 2); } parentMenu._updateItemRoles(that); break; case 'checkMode': that.itemContainer.setAttribute('check-mode', newValue); parentMenu._changeToRadioButtonMode(newValue, that.itemContainer, that); parentMenu._updateItemRoles(that); break; case 'disabled': { if (LW.ListMenu && parentMenu instanceof LW.ListMenu) { if (parentMenu._view) { while (that.contains(parentMenu._view)) { parentMenu._backButtonClickHandler(); } } } else if (parentMenu._isContainerOpened(that.container.level, that.container)) { parentMenu._closeSubContainers(that.level + 1, that.container); } if (!that.checked) { return; } that.checked = false; const checkMode = parentObject.checkMode; if (checkMode === 'radioButton') { parentMenu._validateRadioButtonSelection(parentItem, that.level, []); } else if (checkMode !== 'checkbox') { parentMenu._refreshCheckableItems(parentObject); } break; } case 'separator': parentMenu._refreshCheckableItems(parentObject); break; } } }); /** * Menu custom element. */ LW('lw-menu', class Menu extends LW.BaseElement { // Menu's properties. static get properties() { return { 'autoCloseDelay': { value: 100, type: 'number' }, 'autoFocusOnMouseenter': { value: false, type: 'boolean' }, 'checkable': { value: false, type: 'boolean' }, 'checkboxes': { value: false, type: 'boolean' }, 'checkMode': { value: 'checkbox', type: 'string' }, 'closeAction': { value: 'up', allowedValues: ['up', 'down', 'none'], type: 'string' }, 'dataSource': { value: null, type: 'array?', reflectToAttribute: false }, 'displayMember': { value: 'label', type: 'string' }, 'dropDownAppendTo': { value: null, type: 'any?' }, 'dropDownOverlay': { value: false, type: 'boolean' }, 'dropDownPosition': { value: 'auto', allowedValues: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'overlay-left', 'overlay-right', 'auto'], type: 'string' }, 'enableMouseWheelAction': { value: false, type: 'boolean' }, 'itemsMember': { value: 'items', type: 'string' }, 'minimizeIconTemplate': { value: null, type: 'string?' }, 'minimizeWidth': { value: null, type: 'number?' }, 'mode': { value: 'horizontal', allowedValues: ['horizontal', 'vertical', 'dropDown', 'tree'], type: 'string' }, 'opened': { value: false, type: 'boolean' }, 'overflow': { value: 'auto', allowedValues: ['auto', 'hidden', 'scroll'], type: 'string' }, 'selectionMode': { value: 'click', allowedValues: ['click', 'mouseenter'], type: 'string' }, 'valueMember': { value: 'value', type: 'string' } }; } /** * Menu's event listeners. */ static get listeners() { return { 'container.click': '_selectionHandler', 'keydown': '_keydownHandler', 'mouseenter': '_mouseenterHandler', 'mouseleave': '_mouseleaveHandler', 'container.mouseout': '_mouseoutMouseoverHandler', 'container.mouseover': '_mouseoutMouseoverHandler', 'resize': '_resizeHandler', 'transitionend': '_transitionendHandler', 'hamburgerIcon.click': '_hamburgerIconClickHandler', 'mainContainer.click': '_mainContainerHandler', 'mainContainer.mouseleave': '_mainContainerHandler', 'mainContainer.mouseout': '_mainContainerHandler', 'mainContainer.mouseover': '_mainContainerHandler', 'document.down': '_documentDownHandler', 'document.up': '_documentUpHandler' }; } /** * Menu's required files. */ static get requires() { return { 'LW.RepeatButton': 'lw.button.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.button.css', 'lw.menu.css' ] } /** * Menu's items. */ get items() { return this._menuItems; } /** * Menu's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="minimizedHeader" class="lw-header lw-minimized-header lw-hidden" role="presentation"> <div id="hamburgerIcon" class="lw-hamburger-icon lw-hidden" role="button" aria-label="Toggle minimized menu" aria-haspopup="true"> <div id="hamburgerIconLineTop" class="lw-hamburger-icon-line lw-hamburger-icon-line-top" role="presentation"></div> <div id="hamburgerIconLineCenter" class="lw-hamburger-icon-line lw-hamburger-icon-line-center" role="presentation"></div> <div id="hamburgerIconLineBottom" class="lw-hamburger-icon-line lw-hamburger-icon-line-bottom" role="presentation"></div> <div id="customIconContainer" class="lw-hamburger-icon-custom-container lw-hidden" role="presentation"></div> </div> </div> <lw-repeat-button id="scrollButtonNear" class="lw-menu-scroll-button lw-spin-button lw-scroll-button-near lw-hidden" animation="[[animation]]" unfocusable right-to-left="[[rightToLeft]]"> <div id="arrowNear" class="lw-arrow" aria-hidden="true"></div> </lw-repeat-button> <div id="mainContainer" class="lw-menu-main-container" role="presentation"> <content></content> </div> <lw-repeat-button id="scrollButtonFar" class="lw-menu-scroll-button lw-spin-button lw-scroll-button-far lw-hidden" animation="[[animation]]" unfocusable right-to-left="[[rightToLeft]]"> <div id="arrowFar" class="lw-arrow" aria-hidden="true"></div> </lw-repeat-button> </div>`; } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted || !that.isRendered || that._element === 'tree' || LW.ListMenu && that instanceof LW.ListMenu) { return; } const scrollInfo = that._scrollInfo; if (that.dropDownAppendTo !== null) { if (that._minimized) { that._dropDownParent.appendChild(that.$.mainContainer); } else { for (let i = 0; i < that._containersInBody.length; i++) { that._dropDownParent.appendChild(that._containersInBody[i]); } } if (that.mode === 'dropDown') { if (that._dropDownParent === that.parentElement) { if (that._dynamicallyReparented) { delete that._dynamicallyReparented; } else { that._positionRelativeTo = null; } } else { that._positionRelativeTo = that.parentElement; that._dynamicallyReparented = true; setTimeout(function () { that._dropDownParent.appendChild(that); }, 0); } } } if (scrollInfo) { scrollInfo.forEach(function (settings, element) { element.scrollLeft = settings.left; element.scrollTop = settings.top; }); } } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); if (that._element === 'tree' || LW.ListMenu && that instanceof LW.ListMenu) { return; } that._close(); if (that.dropDownAppendTo !== null) { if (that._minimized) { that._dropDownParent.removeChild(that.$.mainContainer); } else { that._removeContainersInBody(); } } } /** * Called when the element is ready. Used for one-time configuration of the Menu. */ ready() { super.ready(); } render() { const that = this; that._element = 'menu'; that._edgeMacFF = LW.Utilities.Core.Browser.Edge || LW.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1; that._containers = []; that._containersInBody = []; that._openedContainers = []; that._containersFixedHeight = []; that._menuItemsGroupsToExpand = []; that._additionalScrollButtons = []; that._scrollInfo = new Map(); that._createElement(); super.render(); } /** * Adds an item. * * @param {HTMLElement} item A lw-menu-item to add to the Menu. * @param {HTMLElement/String} parent Optional The lw-menu-items-group (or its id or numeric path) to add the item to. */ addItem(item, parent) { const that = this; if (!(item instanceof LW.MenuItem || item instanceof LW.MenuItemsGroup)) { return; } let parentObject, level, container; if (parent === undefined) { parent = that.$.mainContainer; parentObject = that; level = 1; container = parent; } else { parent = that.getItem(parent); if (parent instanceof LW.MenuItemsGroup === false) { return; } parentObject = parent; level = parent.level + 1; container = parent.itemContainer; } that._createItemHTMLStructure(item, level, parent, container.childElementCount, 0); if (item instanceof LW.MenuItemsGroup) { that._processHTML(item, level + 1); that._checkContainersLength(); } container.appendChild(item); that._checkOverflowAddRemove(item.level, container); if (item instanceof LW.MenuItemsGroup && (that.mode === 'tree' || that._minimized)) { const arrows = item.getElementsByClassName('lw-menu-items-group-arrow'); for (let i = 0; i < arrows.length; i++) { arrows[i].className = 'lw-menu-items-group-arrow down lw-arrow-down'; } that._expandItemsByDefault(); } that._refreshCheckableItems(parentObject); } /** * Checks an item. * * @param {HTMLElement/String} item lw-menu-item/lw-menu-items-group (or its id or numeric path). */ checkItem(item) { const that = this; item = that.getItem(item); if (item === undefined || item.checked || item.disabled || item.templateApplied) { return; } that._toggleItem(item); } /** * Clears all Menu items. */ clear() { const that = this; that.$.mainContainer.innerHTML = ''; that._removeContainersInBody(); that._menuItems = {}; that._containers = []; that._containersInBody = []; that._openedContainers = []; that._containersFixedHeight = []; that._menuItemsGroupsToExpand = []; that._additionalScrollButtons = []; } /** * Closes the Menu when "mode" is 'dropDown'. */ close() { const that = this; if (that.mode !== 'dropDown' || that.opened === false && that.$.hasClass('lw-visibility-hidden')) { return; } const closingEvent = that.$.fireEvent('closing', arguments[0] || { trigger: 'programmatic' }); if (!closingEvent.defaultPrevented) { that.opened = false; that.$.addClass('lw-visibility-hidden'); that._close(); that.$.fireEvent('close'); } else { that.opened = true; } } /** * Collapses an item. * * @param {HTMLElement/String} item Optional lw-menu-item/lw-menu-items-group (or its id or numeric path). * @param {Boolean} animation Optional If set to false, disables collapse animation even if animation is enabled for the element. */ collapseItem(item, animation) { const that = this, animationType = that.animation, restoreAnimation = animation === false && that.hasAnimation; if (item !== undefined) { item = that.getItem(item); if (item === undefined || item instanceof LW.MenuItem) { return; } } else { // collapse all if (restoreAnimation) { that.animation = 'none'; } that._close(); if (restoreAnimation) { setTimeout(function () { that.animation = animationType; }, 0); } return; } const level = item.level; if (that._openedContainers[level + 1] && that._isContainerOpened(level + 1, item.container)) { const mode = that.mode; if (restoreAnimation) { that.animation = 'none'; } that._closeSubContainers(level + 1, item.container, undefined, arguments[2] !== false); if (level === 1 || mode === 'tree') { that._checkOverflow(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } if (restoreAnimation) { that.animation = animationType; } } } /** * Expands an item. * * @param {HTMLElement/String} item lw-menu-item/lw-menu-items-group (or its id or numeric path). * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element. */ expandItem(item, animation) { const that = this; item = that.getItem(item); if (item === undefined || (item instanceof LW.MenuItemsGroup && that._isContainerOpened(item.level + 1, item.container) && that._isBranchExpanded(item))) { return; } const stack = [item], animationType = that.animation, restoreAnimation = animation === false && that.hasAnimation; let stackItem = item.parentItem; if (restoreAnimation) { that.animation = 'none'; } that._discardKeyboardHover(); while (stackItem) { stack.unshift(stackItem); stackItem = stackItem.parentItem; } for (let i = 0; i < stack.length; i++) { const currentStackItem = stack[i]; if (i === stack.length - 1 && currentStackItem instanceof LW.MenuItem) { if (!(currentStackItem.disabled || currentStackItem.templateApplied)) { that._hoverViaKeyboard(currentStackItem); } break; } if (!that._isContainerOpened(currentStackItem.container.level, currentStackItem.container)) { that._menuItemsGroupSelectionHandler(currentStackItem, { target: currentStackItem, type: 'expand', isTrusted: true }, arguments[2]); } } if (restoreAnimation) { that.animation = animationType; } } /** * Gets an item by its id or numeric path. * * @param {String} id The id or numeric path of an item. */ getItem(id) { const that = this; let item; if (id === undefined || id === null) { return; } if (!that._menuItems) { return; } if (typeof id === 'string') { if (/^[0-9]*([.]?[0-9]*)*$/gm.test(id)) { return that._menuItems[id]; } //Note: that.$.mainContainer.querySelector('#' + id) This will fail in cases where the id starts with a number //Reference: Search StackOverflow -> "using-queryselector-with-ids-that-are-numbers" item = that.$.mainContainer.querySelector('[id="' + id + '"'); if (item === null) { return that._menuItems[id]; } } else if (!isNaN(id)) { return that._menuItems[id.toString()]; } else { item = id; } if (!(item instanceof LW.MenuItem || item instanceof LW.MenuItemsGroup) || !(that.contains(item) || that.$.mainContainer.contains(item) || item.parentElement.parentElement.ownerElement === that)) { return; } return item; } /** * Maximizes the Menu. */ maximize() { const that = this; if (!that._minimized) { return; } const animationType = that.animation; that.$.mainContainer.style.marginTop = ''; that.$.mainContainer.style.marginLeft = ''; if (that.enableShadowDOM && !that.$.mainContainer.id) { that.$.mainContainer.id = that.$.mainContainer.getAttribute('lw-id'); } if (animationType !== 'none') { that.animation = 'none'; } that._positionDetection.removeOverlay(); that._closeSubContainers(2); that.$minimizedHeader.addClass('lw-hidden'); that._minimized = false; if (that._minimizedDropDownOpened) { that.$hamburgerIcon.removeClass('lw-close-button'); that._minimizedDropDownOpened = false; } if (that.dropDownAppendTo !== null) { that._appendMinimizedContainerToMenu(that.$.mainContainer, that.$.scrollButtonFar); } if (that.mode !== 'tree') { that.$mainContainer.addClass('lw-menu-main-container'); that.$mainContainer.removeClass('lw-menu-minimized-items-container'); const arrows = that.$.mainContainer.getElementsByClassName('lw-menu-items-group-arrow'); for (let i = 0; i < arrows.length; i++) { that._setArrowDirection(arrows[i], arrows[i].parentElement.parentElement.level + 1); } if (that.dropDownAppendTo !== null) { that._moveDropDownsToExternalContainer(); } that._applyContainerFixedHeight(); } that.$mainContainer.removeClass('lw-visibility-hidden'); that.$hamburgerIcon.addClass('lw-hidden'); that.removeAttribute('minimized'); that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); if (animationType !== 'none') { setTimeout(function () { that.animation = animationType; }, 0); } that.$.mainContainer.removeAttribute('drop-down'); that.$.hamburgerIcon.removeAttribute('aria-expanded'); that.$.hamburgerIcon.removeAttribute('aria-owns'); that.$.mainContainer.setAttribute('role', 'presentation'); that.$.mainContainer.removeAttribute('aria-orientation'); that.setAttribute('role', 'menu'); that.setAttribute('aria-orientation', that.mode === 'horizontal' ? 'horizontal' : 'vertical'); } /** * Minimizes the Menu. */ minimize() { const that = this; if (that._minimized || that.mode === 'dropDown') { return; } that.$minimizedHeader.removeClass('lw-hidden'); const differentDropDownParent = that.dropDownAppendTo !== null, animationType = that.animation, restoreAnimation = that.hasAnimation; if (restoreAnimation) { that.animation = 'none'; } that._positionDetection.removeOverlay(); that._closeSubContainers(2); if (restoreAnimation && differentDropDownParent) { that.animation = animationType; } if (that.mode !== 'tree') { if (differentDropDownParent) { that._moveDropDownsToMenu(); } that._removeContainerFixedHeight(); } that._hideMainContainerScrollButtons(); that.$mainContainer.removeClass('lw-menu-main-container'); that.$mainContainer.addClass('lw-visibility-hidden'); if (that.enableShadowDOM) { that.$.mainContainer.removeAttribute('id'); } if (that._edgeMacFF) { that.$.mainContainer.style.left = ''; that.$.mainContainer.style.top = ''; that.$mainContainer.addClass('not-in-view'); } that.$hamburgerIcon.removeClass('lw-hidden'); if (differentDropDownParent) { that._appendMinimizedContainerToExternalElement(that.$.mainContainer); } setTimeout(function () { that.$mainContainer.addClass('lw-menu-minimized-items-container'); if (restoreAnimation && !differentDropDownParent) { that.animation = animationType; } }, 0); that._minimized = true; that.setAttribute('minimized', ''); if (that.mode !== 'tree') { for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; if (container.level > 2) { that._setArrowDirection(container.menuItemsGroup.children[0].children[1], container.level); } } } that.$.mainContainer.setAttribute('drop-down', ''); that.setAttribute('role', 'presentation'); that.removeAttribute('aria-orientation'); that.$.hamburgerIcon.setAttribute('aria-expanded', false); that.$.hamburgerIcon.setAttribute('aria-owns', that.$.mainContainer.id); that.$.mainContainer.setAttribute('role', 'menu'); that.$.mainContainer.setAttribute('aria-orientation', 'vertical'); } /** * Opens the Menu when "mode" is 'dropDown'. * * @param {Number} left Horizontal position. * @param {Number} top Vertical position. */ open(left, top) { const that = this; if (that.mode !== 'dropDown') { return; } const openingEvent = that.$.fireEvent('opening'); if (openingEvent.defaultPrevented) { that.opened = false; return; } let actualParentRect; that.opened = true; if (that._positionRelativeTo) { const targetRect = that._positionRelativeTo.getBoundingClientRect(); left += targetRect.left; top += targetRect.top; if (that._positionedParent) { actualParentRect = that._positionedParent.getBoundingClientRect(); left -= actualParentRect.left; top -= actualParentRect.top; } else { left += window.pageXOffset; top += window.pageYOffset; } } // browser bounds detection let overflowLeft = left + that.offsetWidth - document.documentElement.clientWidth, overflowTop = top + that.offsetHeight - document.documentElement.clientHeight; if (actualParentRect) { overflowLeft += actualParentRect.left; overflowTop += actualParentRect.top; } else { overflowLeft -= window.pageXOffset; overflowTop -= window.pageYOffset; } if (overflowLeft > 0) { left -= overflowLeft; } else if (actualParentRect) { left = Math.max(left, -actualParentRect.left); } else { left = Math.max(left, window.pageXOffset); } if (overflowTop > 0) { top -= overflowTop; } else if (actualParentRect) { top = Math.max(top, -actualParentRect.top); } else { top = Math.max(top, window.pageYOffset); } // browser bounds detection end that.style.right = ''; if (!isNaN(left)) { if (that.rightToLeft) { that.style.right = 'initial'; } that.style.left = left + 'px'; } if (!isNaN(top)) { that.style.top = top + 'px'; } that.$.removeClass('lw-visibility-hidden'); that.$.fireEvent('open'); if (!that.hasAnimation) { if (that._checkOverflowOnOpen) { that._checkOverflow(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); delete that._checkOverflowOnOpen; } if (!that._noAutoFocus) { that.focus(); } } } /** * Removes an item. * * @param {HTMLElement/String} item The lw-menu-item/lw-menu-items-group (or its id or numeric path) to remove. */ removeItem(item) { const that = this; item = that.getItem(item); if (item === undefined) { return; } const itemParent = item.parentElement, parentObject = item.parentItem || that; if (item instanceof LW.MenuItemsGroup) { const container = item.container; if (that._isContainerOpened(container.level, container)) { that._closeSubContainers(container.level, container); } if (item.level === 1) { const index = that._containersInBody.indexOf(container); if (index !== -1) { that._containersInBody.splice(index, 1); if (that.dropDownAppendTo !== null && that.mode !== 'tree' && !that._minimized) { that._dropDownParent.removeChild(container); } } } } itemParent.removeChild(item); that._refreshContainersArrays(); that._menuItems = {}; that._refreshItemPaths(that.$.mainContainer, true); that._checkOverflowAddRemove(item.level, itemParent); that._refreshCheckableItems(parentObject); } /** * Unchecks an item. * * @param {HTMLElement/String} item lw-menu-item/lw-menu-items-group (or its id or numeric path). */ uncheckItem(item) { const that = this; item = that.getItem(item); if (item === undefined || !item.checked || item.disabled || item.templateApplied) { return; } that._toggleItem(item); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (that._element === 'tree') { return; } function checkOverflow() { if (that.dropDownAppendTo !== null || that.mode === 'tree') { that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } } function updateAttribute(attribute, container, setAttribute) { if (setAttribute) { container.setAttribute(attribute, ''); } else { container.removeAttribute(attribute); } } switch (propertyName) { case 'animation': that.$.mainContainer.setAttribute('animation', newValue); that._additionalScrollButtons.forEach(function (element) { element[0].animation = newValue; element[1].animation = newValue; }); if (that._dropDownParent !== null) { that._containers.forEach(function (element) { element.setAttribute('animation', newValue); }); } break; case 'checkable': if (that.mode !== 'tree' && !that._minimized) { that._closeSubContainers(2); } else if (that._minimized && that.dropDownAppendTo !== null) { updateAttribute('checkable', that.$.mainContainer, newValue); } that._updateItemRoles(that); break; case 'checkboxes': that._close(); if (that.dropDownAppendTo !== null) { for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; updateAttribute('checkboxes', container, newValue); } if (that._minimized) { updateAttribute('checkboxes', that.$.mainContainer, newValue); } } that._updateItemRoles(); break; case 'checkMode': that._changeToRadioButtonMode(newValue, that.$.mainContainer); if (that._minimized && that.dropDownAppendTo !== null) { that.$.mainContainer.setAttribute('check-mode', newValue); } that._updateItemRoles(that); break; case 'dataSource': { let toMinimize = false; if (that._minimized) { that.maximize(); toMinimize = true; } that._removeContainersInBody(); that._containersInBody = []; that._menuItems = {}; that._processDataSource(); that._checkContainersLength(); if (toMinimize) { that.minimize(); } else { checkOverflow(); } that._expandItemsByDefault(); that._refreshCheckableItems(); that._suppressResizeHandler = true; setTimeout(() => delete that._suppressResizeHandler, 500); break; } case 'dropDownAppendTo': { const oldDropDownParent = that._dropDownParent; that._positionDetection.getDropDownParent(); if (that._dropDownParent === oldDropDownParent || (that.mode === 'tree' && !that._minimized)) { return; } that._close(); if (that._minimized) { if (newValue === null) { that._appendMinimizedContainerToMenu(that.$.mainContainer, that.$.scrollButtonFar); } else { that._appendMinimizedContainerToExternalElement(that.$.mainContainer); } return; } if (that._dropDownParent !== null && oldDropDownParent === null) { that._moveDropDownsToExternalContainer(); } else if (that._dropDownParent === null && oldDropDownParent !== null) { that._moveDropDownsToMenu(); } else if (that._dropDownParent !== null && oldDropDownParent !== null) { for (let i = 0; i < that._containersInBody.length; i++) { that._dropDownParent.appendChild(that._containersInBody[i]); } } if (newValue === null && !that.$mainContainer.hasClass('simple')) { that._hideMainContainerScrollButtons(); } else { that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } for (let i = 0; i < that._containersFixedHeight.length; i++) { that._containersFixedHeight[i].itemContainer.checkOverflow = true; } if (that.mode === 'dropDown') { that.close({ trigger: 'internal' }); that._reparentMenu(true, oldDropDownParent); } break; } case 'dropDownOverlay': if (!newValue) { that._positionDetection.removeOverlay(); } break; case 'disabled': if (newValue) { that._close(); } that._setFocusable(); that.$.scrollButtonNear.disabled = newValue; that.$.scrollButtonFar.disabled = newValue; if (!newValue && (that.dropDownAppendTo !== null || that.$mainContainer.hasClass('simple') || that.mode === 'tree')) { that._updateScrollButtonVisibility(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } break; case 'dropDownPosition': case 'mode': { if (propertyName === 'mode') { delete that._dynamicallyReparented; if (oldValue === 'tree' || that._minimized) { that._closeSubContainersTreeMode(2, undefined, undefined, undefined, true); that._openedContainers = []; } else { that._closeSubContainersDefaultMode(2); } that._discardKeyboardHover(true); if (that._minimized && that._minimizedDropDownOpened) { that.$mainContainer.addClass('lw-visibility-hidden'); that.$hamburgerIcon.removeClass('lw-close-button'); that.$.hamburgerIcon.setAttribute('aria-expanded', false); that._minimizedDropDownOpened = false; } if (newValue === 'horizontal' || oldValue === 'horizontal') { that._changeScrollButtonsArrows(); } if (that._minimized) { if (newValue === 'dropDown') { that.mode = oldValue; } return; } that.setAttribute('aria-orientation', that.mode === 'horizontal' ? 'horizontal' : 'vertical'); if (that.opened === false) { if (newValue === 'dropDown') { that.$.addClass('lw-visibility-hidden'); } else if (oldValue === 'dropDown') { that.$.removeClass('lw-visibility-hidden'); } } if (oldValue === 'tree') { if (that.dropDownAppendTo !== null) { that._moveDropDownsToExternalContainer(); } that.$mainContainer.addClass('lw-menu-main-container'); that.$mainContainer.removeClass('lw-menu-minimized-items-container'); that._applyContainerFixedHeight(); } else if (newValue === 'tree') { if (that.dropDownAppendTo !== null) { that._moveDropDownsToMenu(); } that._applyTreeMode(); } if (that.overflow === 'auto') { that._hideMainContainerScrollButtons(); } checkOverflow(); } if (that.mode === 'tree' || that._minimized) { if (that._minimizedDropDownOpened) { that._close(); } if (that._minimized && that.dropDownAppendTo !== null) { that.$.mainContainer.setAttribute(that.properties[propertyName].attributeName, newValue); } return; } else if (propertyName === 'dropDownPosition') { that._close(); } const menuItemsGroups = that._containers.map(container => container.menuItemsGroup); for (let i = 0; i < menuItemsGroups.length; i++) { const currentMenuItemsGroup = menuItemsGroups[i]; that._setArrowDirection(currentMenuItemsGroup.children[0].children[1], currentMenuItemsGroup.level + 1); } if (that.dropDownAppendTo !== null) { for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; container.setAttribute(LW.Utilities.Core.toDash(propertyName), newValue); if (container.level > 2) { that._setArrowDirection(container.menuItemsGroup.children[0].children[1], container.level); } } } break; } case 'minimizeIconTemplate': that._applyMinimizeIconTemplate(newValue, oldValue); break; case 'minimizeWidth': that._resizeHandler(); break; case 'opened': if (newValue) { that.open(); } else { that.close({ trigger: 'internal' }); } break; case 'overflow': that._handleOverflowChange(); break; case 'rightToLeft': { if (that.mode !== 'tree') { const menuItemsGroups = that._containers.map(container => container.menuItemsGroup); for (let i = 0; i < menuItemsGroups.length; i++) { const currentMenuItemsGroup = menuItemsGroups[i]; that._setArrowDirection(currentMenuItemsGroup.children[0].children[1], currentMenuItemsGroup.level + 1); } if (that.dropDownAppendTo !== null) { if (newValue) { that.$.mainContainer.setAttribute('right-to-left', ''); } else { that.$.mainContainer.removeAttribute('right-to-left'); } for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; newValue ? container.setAttribute('right-to-left', '') : container.removeAttribute('right-to-left'); if (container.level > 2) { that._setArrowDirection(container.menuItemsGroup.children[0].children[1], container.level); } } } } break; } case 'theme': if (that.dropDownAppendTo === null || LW.ListMenu && that instanceof LW.ListMenu) { return; } if (that._minimized) { if (oldValue !== '') { that.$mainContainer.removeClass(oldValue); } if (newValue !== '') { that.$mainContainer.addClass(newValue); } } else { for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; if (oldValue !== '') { container.classList.remove(oldValue); } if (newValue !== '') { container.classList.add(newValue); } } } break; case 'unfocusable': that._setFocusable(); break; } } /** * Adds a container to the "_openedContainers" array. */ _addOpenedContainer(level, container) { const that = this; if (that.mode === 'tree' || that._minimized) { if (!that._openedContainers[level]) { that._openedContainers[level] = []; } const menuItemsGroup = container.menuItemsGroup; menuItemsGroup.set('expanded', true); menuItemsGroup.setAttribute('aria-expanded', true); if (that._updateState) { that._updateState('expanded', menuItemsGroup.id, true); } return that._openedContainers[level].push(container); } else { that._openedContainers[level] = container; } } /** * Appends the minimized items container to external element. */ _appendMinimizedContainerToExternalElement(itemsContainer) { const that = this; itemsContainer.ownerElement = that; that._dropDownParent.appendChild(itemsContainer); itemsContainer.setAttribute('animation', that.animation); if (that.theme !== '') { itemsContainer.$.addClass(that.theme); } itemsContainer.$.addClass('lw-menu-drop-down lw-drop-down'); itemsContainer.$.addClass('lw-drop-down-repositioned'); itemsContainer.setAttribute('check-mode', that.checkMode); itemsContainer.setAttribute('drop-down-position', that.dropDownPosition); itemsContainer.setAttribute('mode', that.mode); itemsContainer.setAttribute('loading-indicator-position', that.loadingIndicatorPosition); if (that.rightToLeft) { itemsContainer.setAttribute('right-to-left', ''); } if (that.checkable) { itemsContainer.setAttribute('checkable', ''); } if (that.checkboxes) { itemsContainer.setAttribute('checkboxes', ''); } if (that.$.view && that.detachedChildren.indexOf(that.$.view)) { that.detachedChildren.push(that.$.view); } } /** * Appends the minimized items container to Menu. */ _appendMinimizedContainerToMenu(itemsContainer, sibling) { const that = this; delete itemsContainer.ownerElement; that.$.container.insertBefore(itemsContainer, sibling); itemsContainer.removeAttribute('animation'); if (that.theme !== '') { itemsContainer.$.removeClass(that.theme); } itemsContainer.$.removeClass('lw-menu-drop-down lw-drop-down'); itemsContainer.$.removeClass('lw-drop-down-repositioned'); itemsContainer.removeAttribute('checkable'); itemsContainer.removeAttribute('checkboxes'); itemsContainer.removeAttribute('check-mode'); itemsContainer.removeAttribute('drop-down-position'); itemsContainer.removeAttribute('mode'); itemsContainer.removeAttribute('loading-indicator-position'); itemsContainer.removeAttribute('style'); itemsContainer.removeAttribute('right-to-left'); } /** * Applies fixed heights to containers. */ _applyContainerFixedHeight() { const that = this; for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; if (that._containersFixedHeight.indexOf(container) !== -1) { container.style.height = container.menuItemsGroup.dropDownHeight + 'px'; container.itemContainer.checkOverflow = true; } else { container.style.height = ''; } } } /** * Applies grouping. */ _applyGrouping(item, noRecursion) { const that = this; let itemChildren; if (item === that.$.mainContainer) { itemChildren = Array.from(item.children); } else { itemChildren = Array.from(item.container.firstElementChild.children); } for (let i = 0; i < itemChildren.length; i++) { const currentItem = itemChildren[i]; currentItem.originalIndex = i; if (currentItem instanceof LW.MenuItemsGroup && noRecursion === undefined) { that._applyGrouping(currentItem); } } that._sortItems(item); } /** * Applies minimize icon template. */ _applyMinimizeIconTemplate(newValue, oldValue) { const that = this; if (newValue === null) { if (oldValue === null) { return; } that.$customIconContainer.addClass('lw-hidden'); that.$.customIconContainer.innerHTML = ''; that.$hamburgerIconLineTop.removeClass('lw-hidden'); that.$hamburgerIconLineCenter.removeClass('lw-hidden'); that.$hamburgerIconLineBottom.removeClass('lw-hidden'); } else { const potentialHTMLTemplate = document.getElementById(newValue); if (potentialHTMLTemplate !== null && potentialHTMLTemplate.tagName.toLowerCase() === 'template') { // label is the id of an HTML template const templateContent = document.importNode(potentialHTMLTemplate.content, true); that.$hamburgerIconLineTop.addClass('lw-hidden'); that.$hamburgerIconLineCenter.addClass('lw-hidden'); that.$hamburgerIconLineBottom.addClass('lw-hidden'); that.$.customIconContainer.innerHTML = ''; that.$.customIconContainer.appendChild(templateContent); that.$customIconContainer.removeClass('lw-hidden'); } else { that.minimizeIconTemplate = oldValue; } } } /** * Applies mode: 'tree'. */ _applyTreeMode() { const that = this, arrows = that.$.mainContainer.getElementsByClassName('lw-menu-items-group-arrow'); that.$mainContainer.removeClass('lw-menu-main-container'); that.$mainContainer.addClass('lw-menu-minimized-items-container'); if (that.isCompleted && that.isRendered) { for (let i = 0; i < arrows.length; i++) { arrows[i].className = 'lw-menu-items-group-arrow down'; } } that._removeContainerFixedHeight(); } /** * Default left arrow handler. */ _arrowLeftHandler(level, mode, focusedItem, lastOpenedContainer) { const that = this; if (level === 1) { if (mode === 'horizontal') { that._levelOneNavigate('_getLastEnabledChild', focusedItem, lastOpenedContainer); } } else if (level === 2) { that._levelOneNavigateFromLowerLevel('_getPreviousEnabledChild', focusedItem); } else { that._escapeHandler(focusedItem, level, lastOpenedContainer); } } /** * Default right arrow handler. */ _arrowRightHandler(level, mode, focusedItem, lastOpenedContainer) { const that = this; if (level === 1) { if (mode === 'horizontal') { that._levelOneNavigate('_getFirstEnabledChild', focusedItem, lastOpenedContainer); } else { that._levelOneOpenDropDown(focusedItem); } } else { if (focusedItem instanceof LW.MenuItemsGroup) { that._selectionHandler({ target: focusedItem, isTrusted: true }); } else { that._levelOneNavigateFromLowerLevel('_getNextEnabledChild', focusedItem); } } } /** * Repositions container if it intersects with browser bounds. */ _browserBoundsDetection(container) { const that = this; if (that.mode === 'tree' && !that._minimized) { return; } container.style.marginTop = ''; container.style.marginLeft = ''; if (that.dropDownPosition !== 'auto') { return; } // to do - when minimized and height is greater than doc height - do nothing const windowWidth = window.devicePixelRatio === 1 ? document.documentElement.clientWidth : window.innerWidth, windowHeight = window.devicePixelRatio === 1 ? document.documentElement.clientHeight : window.innerHeight, containerBoundingRect = container.getBoundingClientRect(), horizontalCorrection = windowWidth - containerBoundingRect.left - container.offsetWidth, verticalCorrection = windowHeight - containerBoundingRect.top - container.offsetHeight; if (horizontalCorrection < 10) { container.style.marginLeft = Math.min(horizontalCorrection - 10, -10) + 'px'; } if (verticalCorrection < 10) { container.style.marginTop = Math.min(verticalCorrection - 10, -10) + 'px'; } } /** * Changes the direction of scroll button arrows. */ _changeScrollButtonsArrows() { const that = this; if (that.mode === 'horizontal') { that.$.scrollButtonNear.setAttribute('aria-label', 'Scroll left'); that.$.scrollButtonFar.setAttribute('aria-label', 'Scroll right'); that.$arrowNear.removeClass('lw-arrow-up'); that.$arrowFar.removeClass('lw-arrow-down'); that.$arrowNear.addClass('lw-arrow-left'); that.$arrowFar.addClass('lw-arrow-right'); } else { that.$.scrollButtonNear.setAttribute('aria-label', 'Scroll up'); that.$.scrollButtonFar.setAttribute('aria-label', 'Scroll down'); that.$arrowNear.removeClass('lw-arrow-left'); that.$arrowFar.removeClass('lw-arrow-right'); that.$arrowNear.addClass('lw-arrow-up'); that.$arrowFar.addClass('lw-arrow-down'); } } /** * Changes to checkMode: 'radioButton'. */ _changeToRadioButtonMode(newValue, container, item) { if (newValue === 'radioButton') { const checkedChildren = []; for (let i = 0; i < container.childElementCount; i++) { const currentItem = container.children[i]; if (currentItem.checked && !currentItem.disabled && !currentItem.templateApplied) { checkedChildren.push(currentItem); } } this._validateRadioButtonSelection(item, item ? item.level + 1 : 1, checkedChildren); } } /** * Checks the number of dropdowns. */ _checkContainersLength(initialization) { const that = this; if (that._containers.length === 0) { that.$mainContainer.addClass('simple'); if (!initialization) { that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } } else if (!initialization) { that.$mainContainer.removeClass('simple'); if (that.dropDownAppendTo === null && that.mode !== 'tree') { that.$mainContainer.removeClass('scroll-buttons-shown one-button-shown'); } } } /** * Checks if items overflow and shows/hides scroll buttons. */ _checkOverflow(element, horizontal, scrollButtons) { const that = this, mainContainer = that.$.mainContainer, overflow = element === mainContainer ? that.overflow : 'auto'; if (that._minimized || overflow === 'hidden' || (that.dropDownAppendTo === null && that.mode !== 'tree' && element === mainContainer && !mainContainer.classList.contains('simple'))) { return; } if (that.mode === 'dropDown' && !that.opened) { that._checkOverflowOnOpen = true; return; } const oldScrollLeft = element.scrollLeft, scrollLeftRatio = oldScrollLeft / (element.scrollWidth - element.offsetWidth), oldScrollTop = element.scrollTop, scrollTopRatio = oldScrollTop / (element.scrollHeight - element.offsetHeight); if (overflow === 'auto') { element.classList.remove('scroll-buttons-shown'); element.classList.remove('one-button-shown'); scrollButtons[0].$.addClass('lw-hidden'); scrollButtons[1].$.addClass('lw-hidden'); } let overflowing, showNear, showFar; if (horizontal) { overflowing = Math.round(element.scrollWidth) > Math.round(element.offsetWidth); showNear = scrollLeftRatio > 0; showFar = scrollLeftRatio < 1; } else { overflowing = Math.round(element.scrollHeight) > Math.round(element.offsetHeight); showNear = scrollTopRatio > 0; showFar = scrollTopRatio < 1; } if (overflowing) { if (overflow === 'auto') { element.classList.add('scroll-buttons-shown'); if (showNear) { scrollButtons[0].$.removeClass('lw-hidden'); } if (showFar) { scrollButtons[1].$.removeClass('lw-hidden'); } if ((showNear && showFar) === false) { element.classList.add('one-button-shown'); } if (!that.disabled) { scrollButtons[0].disabled = false; scrollButtons[1].disabled = false; } element.scrollLeft = oldScrollLeft; element.scrollTop = oldScrollTop; } else { scrollButtons[0].$.removeClass('lw-hidden'); scrollButtons[1].$.removeClass('lw-hidden'); if (that.disabled) { scrollButtons[0].disabled = true; scrollButtons[1].disabled = true; } else { scrollButtons[0].disabled = !showNear; scrollButtons[1].disabled = !showFar; } } } else if (overflow === 'scroll') { scrollButtons[0].disabled = true; scrollButtons[1].disabled = true; } if (element === mainContainer && that.mode !== 'tree') { that._close(); } that._scrollInfo.set(element, { left: element.scrollLeft, top: element.scrollTop }); } /** * Checks overflow after "addItem" or "removeItem" has been called. */ _checkOverflowAddRemove(level, itemParent) { const that = this; if (level === 1 && that.dropDownAppendTo !== null || that.mode === 'tree') { that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } else if (level > 1 && itemParent.dropDownHeightSet) { if (that._isContainerOpened(level, itemParent.container)) { that._checkOverflow(itemParent, false, [itemParent.container.children[0], itemParent.container.children[2]]); } else { itemParent.checkOverflow = true; } } } /** * Closes any open dropdown containers. */ _close() { const that = this; that._positionDetection.removeOverlay(); that._closeSubContainers(2); that._discardKeyboardHover(true); if (that._minimized && that._minimizedDropDownOpened) { that.$mainContainer.addClass('lw-visibility-hidden'); if (that._edgeMacFF) { that.$.mainContainer.style.left = ''; that.$.mainContainer.style.top = ''; that.$mainContainer.addClass('not-in-view'); } that.$hamburgerIcon.removeClass('lw-close-button'); that.$.hamburgerIcon.setAttribute('aria-expanded', false); that._minimizedDropDownOpened = false; } } /** * Closes sub-containers. */ _closeSubContainers(level, container, preserveClass, fireEvent) { const that = this; if (that.mode !== 'tree' && !that._minimized) { that._closeSubContainersDefaultMode(level, container, preserveClass); } else { that._closeSubContainersTreeMode(level, container, preserveClass, fireEvent); } } /** * Closes sub-containers (in horizontal/vertical/dropDown mode). */ _closeSubContainersDefaultMode(level, container, preserveClass) { const that = this, openedContainers = that._openedContainers; function applyClasses(i) { const menuItemsGroup = openedContainers[i].menuItemsGroup; if (!(preserveClass && i === level)) { menuItemsGroup.$.removeClass('focus'); menuItemsGroup.removeAttribute('focus'); menuItemsGroup.$.removeClass('hover'); menuItemsGroup.removeAttribute('hover'); } menuItemsGroup.$.removeClass('lw-menu-items-group-opened'); menuItemsGroup.$.removeClass('lw-menu-items-group-expanded'); menuItemsGroup.setAttribute('aria-expanded', false); openedContainers[i].$.addClass('lw-visibility-hidden'); if (that._edgeMacFF && i === 2 && !that.hasAnimation) { openedContainers[i].style.left = ''; openedContainers[i].style.top = ''; openedContainers[i].$.addClass('not-in-view'); } if (that._minimized) { that._browserBoundsDetection(that.$.mainContainer); } that.$.fireEvent('collapse', { 'item': menuItemsGroup, 'label': menuItemsGroup.label, 'path': menuItemsGroup.path, 'value': menuItemsGroup.value, 'children': menuItemsGroup.itemContainer.children }); openedContainers[i] = undefined; } for (let i = openedContainers.length - 1; i >= level; i--) { if (openedContainers[i] === undefined) { continue; } applyClasses(i, true); } } /** * Closes sub-containers (in tree/minimized mode). */ _closeSubContainersTreeMode(level, container, preserveClass, fireEvent, modeChanged) { const that = this; if (fireEvent) { const menuItemsGroup = container.menuItemsGroup, collapsingEvent = that.$.fireEvent('collapsing', { 'item': menuItemsGroup, 'label': menuItemsGroup.label, 'path': menuItemsGroup.path, 'value': menuItemsGroup.value, 'children': container.itemContainer.children }); if (collapsingEvent.defaultPrevented) { return; } } if (container === undefined) { that._collapseAll(false, modeChanged); return; } const menuItemsGroup = container.menuItemsGroup; menuItemsGroup.set('expanded', false); menuItemsGroup.setAttribute('aria-expanded', false); if (that._element === 'menu') { if (preserveClass) { const currentFocus = that.$.mainContainer.getElementsByClassName('focus')[0]; if (currentFocus) { currentFocus.$.removeClass('focus'); currentFocus.removeAttribute('focus'); } menuItemsGroup.$.addClass('focus'); menuItemsGroup.setAttribute('focus', ''); that._focusedViaKeyboard = menuItemsGroup; } else { menuItemsGroup.$.removeClass('focus'); menuItemsGroup.removeAttribute('focus'); } } else { that._updateState('expanded', menuItemsGroup.id, false); } menuItemsGroup.$.removeClass('lw-' + that._element + '-items-group-opened'); if (modeChanged || !that.hasAnimation) { menuItemsGroup.$.removeClass('lw-' + that._element + '-items-group-expanded'); menuItemsGroup.setAttribute('aria-expanded', false); container.$.addClass('lw-visibility-hidden'); if (that._minimized) { that._browserBoundsDetection(that.$.mainContainer); } } else { that._collapseSection(container); } if (fireEvent) { const eventDetail = { 'item': menuItemsGroup, 'label': menuItemsGroup.label, 'path': menuItemsGroup.path, 'value': menuItemsGroup.value, 'children': menuItemsGroup.itemContainer.children }; if (that.toggleCallback) { eventDetail.type = 'collapse'; that.toggleCallback(eventDetail); } else { that.$.fireEvent('collapse', eventDetail); } } if (!that._openedContainers[level]) { return; } const index = that._openedContainers[level].indexOf(container); if (index !== -1) { that._openedContainers[level].splice(index, 1); } } /** * Collapses all items (in tree/minimized mode). */ _collapseAll(fireEvent, modeChanged) { const that = this; for (let i = that._openedContainers.length - 1; i >= 2; i--) { if (that._openedContainers[i] === undefined) { break; } for (let j = that._openedContainers[i].length - 1; j >= 0; j--) { that._closeSubContainersTreeMode(i, that._openedContainers[i][j], undefined, fireEvent, modeChanged); } } if (!that.hasAnimation) { that._checkOverflow(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); } for (let i = that._openedContainers.length - 1; i >= 2; i--) { const currentSet = that._openedContainers[i]; if (currentSet === undefined || currentSet.length === 0) { that._openedContainers.splice(i, 1); } else { break; } } if (that._openedContainers.length === 2) { that._openedContainers = []; } } /** * Collapses a section (in tree/minimized mode). */ _collapseSection(element) { const that = this, sectionHeight = element.scrollHeight + 'px'; that._treeAnimationInProgress = element; element.style.transition = 'none'; requestAnimationFrame(function () { if (that.mode !== 'tree' && !that._minimized) { element.style.transition = ''; return; } element.style.height = sectionHeight; element.style.transition = ''; requestAnimationFrame(function () { element.style.height = '0px'; if (that.tagName.toLowerCase() === 'lw-tree') { element.$.addClass('lw-visibility-hidden'); } if (sectionHeight === '0px') { that._transitionendHandlerCollapse(that, element); } }); }); element.addEventListener('transitionend', that._transitionendHandlerCollapse); } /** * Applies initial settings to the Menu element. */ _createElement() { const that = this, mode = that.mode; that.setAttribute('role', 'menu'); that.$.mainContainer.id = that.id + 'MainContainer'; that.setAttribute('aria-orientation', that.mode === 'horizontal' ? 'horizontal' : 'vertical'); that._positionDetection = new LW.Utilities.PositionDetection(that); that._positionDetection.getDropDownParent(); that._reparentMenu(); if (that.disabled) { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } if (that.dataSource === null && that.$.mainContainer.firstElementChild instanceof HTMLUListElement) { that._processUList(); } const items = (that.shadowRoot || that).querySelectorAll('lw-menu-item, lw-menu-items-group'); const itemsReady = function () { const animationType = that.animation; that._changeScrollButtonsArrows(); that._setFocusable(); if (mode === 'dropDown' && that.opened === false) { if (that.hasAnimation) { that.animation = 'none'; that.$.addClass('lw-visibility-hidden'); that.animation = animationType; } else { that.$.addClass('lw-visibility-hidden'); } } that._menuItems = {}; that.$.mainContainer.setAttribute('animation', animationType); if (that.dataSource === null) { that._processHTML(that.$.mainContainer, 1); } else { that._processDataSource(); } that._checkContainersLength(true); if ((that.dropDownAppendTo !== null || that.$mainContainer.hasClass('simple') || that.mode === 'tree') && that.overflow === 'scroll') { that.$mainContainer.addClass('scroll-buttons-shown'); that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); that._updateScrollButtonVisibility(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } that._applyMinimizeIconTemplate(that.minimizeIconTemplate, null); if (mode === 'tree') { that._applyTreeMode(); } if (that.minimizeWidth !== null && that.offsetWidth <= that.minimizeWidth) { that.minimize(); } else { that._checkOverflow(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } that._expandItemsByDefault(); that._refreshCheckableItems(); if (that.__onCompleted) { that._onCompleted = that.__onCompleted; that.__onCompleted = null; that._onCompleted(); } } if (items.length === 0 || that.enableShadowDOM || that.isInShadowDOM) { itemsReady(); } else { if (that._onCompleted) { that.__onCompleted = that._onCompleted; that._onCompleted = null; } that._ensureItemsReady(items, itemsReady); } } _ensureItemsReady(nodes, callback) { const that = this; const contextCallback = function () { const setContext = function (context) { for (let i = 0; i < nodes.length; i++) { nodes[i].context = context === 'node' ? nodes[i] : document; } } setContext('node'); callback(); setContext(); } if (nodes.length === 0) { contextCallback(); } else { that._nodesReadyListeners = 0; for (let i = 0; i < nodes.length; i++) { const node = nodes[i]; const readyEventHandler = function () { const oldContext = that.context; that.context = that; that._nodesReadyListeners--; if (that._nodesReadyListeners === 0) { contextCallback(); delete that._nodesReadyListeners; } that.context = oldContext; }.bind(that); if (!node.isCompleted) { that._nodesReadyListeners++; node.completeHandlers = []; node._onCompleted = readyEventHandler; } } if (that._nodesReadyListeners === 0) { contextCallback(); } } } /** * Creates the necessary HTML structure for a lw-menu-item/lw-menu-items-group. */ _createItemHTMLStructure(currentItem, level, item, index) { const that = this, labelContainer = document.createElement('div'), labelElement = document.createElement('div'), labelFragment = document.createDocumentFragment(); let currentItemPath, parentObject; currentItem.menu = that; if (level > 1) { currentItem.originalIndex = index; currentItemPath = item.path + '.' + currentItem.originalIndex; currentItem.parentItem = item; parentObject = item; } else { currentItem.originalIndex = index; currentItemPath = '' + index; parentObject = that; } if (that.checkboxes && parentObject.checkable) { if (parentObject.checkMode === 'checkbox') { currentItem.setAttribute('role', 'menuitemcheckbox'); } else if (parentObject.checkMode === 'radioButton') { currentItem.setAttribute('role', 'menuitemradio'); } } currentItem.path = currentItemPath; that._menuItems[currentItemPath] = currentItem; labelContainer.className = 'lw-' + that._element + '-item-label-container'; labelElement.className = 'lw-' + that._element + '-item-label-element'; if (that._element === 'tree') { // Tree item indentation that._setIndentation(labelContainer, level, that.rightToLeft ? 'paddingRight' : 'paddingLeft'); } const currentItemChildNodes = Array.from(currentItem.childNodes); for (let i = 0; i < currentItemChildNodes.length; i++) { const currentNode = currentItemChildNodes[i]; if (currentNode instanceof LW.MenuItem || currentNode instanceof LW.MenuItemsGroup) { break; } labelElement.appendChild(currentNode); } if (labelElement.innerHTML.trim() === '') { const currentItemLabel = currentItem.label || currentItem.getAttribute('label'); if (currentItemLabel && currentItemLabel !== '') { that._setLabel(currentItemLabel, labelElement, currentItem, true); } else { currentItem.set('label', 'Item ' + index); labelElement.innerHTML = 'Item ' + index; } } else { currentItem.set('label', labelElement.innerHTML.trim()); } currentItem.setAttribute('aria-label', currentItem.label); if (currentItem instanceof LW.MenuItemsGroup && currentItem.titleLabel === undefined) { currentItem.titleLabel = currentItem.label; } labelElement.innerHTML = '<span>' + labelElement.innerHTML + '</span>'; labelFragment.appendChild(labelElement); currentItem.set('level', level); currentItem.set('shortcut', currentItem.shortcut || currentItem.getAttribute('shortcut') || ''); if (currentItem.shortcut && currentItem instanceof LW.MenuItem) { const shortcutElement = document.createElement('div'); shortcutElement.id = currentItem.id + 'Shortcut'; shortcutElement.className = 'lw-' + that._element + '-item-shortcut'; shortcutElement.innerHTML = currentItem.shortcut; labelFragment.appendChild(shortcutElement); currentItem.setAttribute('aria-describedby', shortcutElement.id); } labelContainer.appendChild(labelFragment); currentItem.insertBefore(labelContainer, currentItem.children[0]); if (!currentItem.id) { currentItem.id = that.id + 'ItemP' + currentItem.path.replace(/\./g, '_') + 'L' + currentItem.label.replace(/[^a-zA-Z0-9\-\_]/g, ''); } } /** * Creates the dropdown container of lw-menu-items-group. */ _createMenuItemsGroupContainer(item, level) { const that = this, container = document.createElement('div'), itemContainer = document.createElement('div'); container.id = item.id + 'Container'; container.className = 'lw-' + that._element + '-drop-down lw-visibility-hidden'; if (that._edgeMacFF && level === 2 && that.mode !== 'tree') { container.className += ' not-in-view'; } container.$ = LW.Utilities.Extend(container); container.level = level; container.setAttribute('level', level); if (that._element === 'menu') { item.setAttribute('aria-owns', container.id); container.setAttribute('role', 'menu'); } else { container.setAttribute('role', 'group'); } container.menuItemsGroup = item; itemContainer.className = 'lw-' + that._element + '-item-container'; itemContainer.$ = LW.Utilities.Extend(itemContainer); itemContainer.container = container; itemContainer.menuItemsGroup = item; if (item.checkable) { itemContainer.setAttribute('checkable', ''); } itemContainer.setAttribute('check-mode', item.checkMode); itemContainer.setAttribute('role', 'presentation'); container.itemContainer = itemContainer; container.appendChild(itemContainer); if (item.dropDownHeight !== null) { const repeatButtonNear = document.createElement('lw-repeat-button'), repeatButtonFar = document.createElement('lw-repeat-button'); repeatButtonNear.className = 'lw-menu-scroll-button lw-spin-button lw-scroll-button-near lw-hidden'; repeatButtonNear.setAttribute('aria-label', 'Scroll up'); repeatButtonNear.innerHTML = '<div class="lw-arrow lw-arrow-up" aria-hidden="true"></div>'; repeatButtonNear.animation = that.animation; repeatButtonNear.unfocusable = true; repeatButtonNear.rightToLeft = that.rightToLeft; repeatButtonFar.className = 'lw-menu-scroll-button lw-spin-button lw-scroll-button-far lw-hidden'; repeatButtonFar.setAttribute('aria-label', 'Scroll down'); repeatButtonFar.innerHTML = '<div class="lw-arrow lw-arrow-down" aria-hidden="true"></div>'; repeatButtonFar.animation = that.animation; repeatButtonFar.unfocusable = true; repeatButtonFar.rightToLeft = that.rightToLeft; container.insertBefore(repeatButtonNear, itemContainer); container.appendChild(repeatButtonFar); container.$.addClass('drop-down-height-set'); itemContainer.dropDownHeightSet = true; itemContainer.checkOverflow = true; container.style.height = item.dropDownHeight + 'px'; that._containersFixedHeight.push(container); that._additionalScrollButtons.push([repeatButtonNear, repeatButtonFar]); } return container; } /** * Removes "focused" class added by keyboard navigation. */ _discardKeyboardHover(overrideCheck) { const that = this; if (!that._focusedViaKeyboard) { return; } if (!overrideCheck && that._focusedViaKeyboard instanceof LW.MenuItemsGroup && that._isContainerOpened(that._focusedViaKeyboard.level + 1, that._focusedViaKeyboard.container)) { return; } that._focusedViaKeyboard.$.removeClass('focus'); that._focusedViaKeyboard.removeAttribute('focus'); that._focusedViaKeyboard.$.removeClass('hover'); that._focusedViaKeyboard.removeAttribute('hover'); that._focusedViaKeyboard = undefined; } /** * Document down handler. */ _documentDownHandler(event) { const that = this; if (that.closeAction === 'down') { that._closeOnDocumentInteraction(event.originalEvent); } } /** * Document up handler. */ _documentUpHandler(event) { const that = this, target = event.originalEvent.target; if (that.disabled || that.displayLoadingIndicator || !target.closest) { return; } const closed = that.closeAction === 'up' ? that._closeOnDocumentInteraction(event.originalEvent) : false; if (closed) { return; } let activeElement, isInsideElement; if (that.isInShadowDOM) { activeElement = that.isInShadowDOM ? that.getRootNode().activeElement : (that.shadowRoot ? that.shadowRoot.activeElement || document.activeElement : document.activeElement); isInsideElement = that.$.container.contains(event.originalEvent.composedPath()[0]); } else { activeElement = document.activeElement; isInsideElement = that.contains(target); } if (!closed && that !== activeElement && activeElement.closest('[template-applied]') === null) { if (isInsideElement || target.closest('.lw-list-menu-view') === that.$.view) { that.focus(); return; } const closestDropDown = target.closest('.lw-drop-down-repositioned'); if (closestDropDown && closestDropDown.ownerElement === that) { that.focus(); } } } /** * Closes Menu drop downs on interaction with the document. */ _closeOnDocumentInteraction(event) { const that = this, target = event.target; let shadowRootTarget, isInsideElement; if (that.isInShadowDOM) { shadowRootTarget = event.composedPath()[0]; isInsideElement = that.$.container.contains(shadowRootTarget); } else { isInsideElement = that.contains(target); } if (that.mode === 'dropDown' && that.opened) { const closestDropDown = target.closest('.lw-drop-down-repositioned'); if (!isInsideElement && (!closestDropDown || closestDropDown.ownerElement !== that)) { that.close({ trigger: 'interaction', target: that.isInShadowDOM ? shadowRootTarget : target }); return true; } } if (!isInsideElement && target.closest('.lw-menu-drop-down') === null || shadowRootTarget && shadowRootTarget === that.$.mainContainer || target === that.$.mainContainer) { if (that.mode === 'tree') { return true; } that._close(); return true; } } /** * Ends swiping and scrolls kinetically. */ _endSwiping(event, now, noBounce) { const that = this; if (!that._dragStartDetails) { return; } const mainContainer = that.$.mainContainer, timeDifference = Math.abs(that._dragStartDetails.startTime - now), speed = 300 / timeDifference, distanceDifference = (that._dragStartDetails.startY - event.pageY) * speed; let remaining = Math.abs(distanceDifference); const scrollable = function () { if (distanceDifference > 0 && mainContainer.scrollTop === mainContainer.scrollHeight - mainContainer.offsetHeight || distanceDifference < 0 && mainContainer.scrollTop === 0) { return false; } return true; } let scrollStep = 0.03 * Math.abs(distanceDifference) * speed; const kineticScrolling = function () { if (scrollStep > 5) { const remainingPart = (remaining - scrollStep) / Math.abs(distanceDifference); if (remainingPart < 0.1) { scrollStep /= 1.25; } else if (remainingPart < 0.15) { scrollStep /= 1.2; } else if (remainingPart < 0.2) { scrollStep /= 1.15; } else if (remainingPart < 0.25) { scrollStep /= 1.1; } else if (remainingPart < 0.3) { scrollStep /= 1.05; } } const oldScrollTop = mainContainer.scrollTop; if (distanceDifference > 0) { mainContainer.scrollTop = Math.min(oldScrollTop + scrollStep, mainContainer.scrollHeight - mainContainer.offsetHeight); } else { mainContainer.scrollTop = Math.max(oldScrollTop - scrollStep, 0); } remaining -= scrollStep; that._updateScrollButtonVisibility(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); const canBeScrolled = scrollable(); if (remaining > 0 && canBeScrolled) { that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling); } else { that._wheelInProgress = false; if (!canBeScrolled) { if (that._fireScrollBottomReachedEvent) { that._fireScrollBottomReachedEvent(oldScrollTop); } if (noBounce !== true) { const initialScrollTop = that.$.mainContainer.scrollTop; if (initialScrollTop === 0) { that._bounceTop(); } else { that._bounceBottom(initialScrollTop); } } } } }; if (that._scrollingAnimationFrame) { cancelAnimationFrame(that._scrollingAnimationFrame); } if (timeDifference < 1000 && scrollable()) { that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling); } else { that._wheelInProgress = false; } delete that._dragStartDetails; } /** * Makes sure a lw-menu-item/lw-menu-items-group is visible by scrolling to it. */ _ensureVisible(scrollTarget) { const that = this; if (that._minimized) { return; } const mode = that.mode, mainContainer = that.$.mainContainer; let parent, scrollButtons; if (mode !== 'tree' && scrollTarget.parentElement !== mainContainer) { if (scrollTarget.dropDownHeight === null) { return; } parent = scrollTarget.parentElement; scrollButtons = [parent.container.children[0], parent.container.children[2]]; } else { parent = mainContainer; scrollButtons = [that.$.scrollButtonNear, that.$.scrollButtonFar]; } if (parent === mainContainer && (that.dropDownAppendTo === null && that.mode !== 'tree' && !mainContainer.classList.contains('simple') || !parent.$.hasClass('scroll-buttons-shown') && that.overflow !== 'hidden')) { return; } const parentBoundingRect = parent.getBoundingClientRect(), scrollTargetBoundingRect = scrollTarget.getBoundingClientRect(); if (mode === 'tree') { that._ensureVisibleTreeMode(scrollTarget, scrollTargetBoundingRect, parent, parentBoundingRect, 0); return; } function setTargetScrollValue(scrollValue, scrollDimension, dimension) { let targetScrollValue = scrollTarget.firstElementChild[dimension] + scrollValue - parent[dimension]; if (targetScrollValue < 0) { targetScrollValue = scrollValue; } parent['scroll' + scrollDimension] = targetScrollValue; } function scrollTo(scrollDimension, dimension) { let scrollValue = scrollTarget['offset' + scrollDimension], oldParentDimension = parent[dimension]; if (scrollDimension === 'Top' && parent !== mainContainer && !scrollButtons[0].$.hasClass('lw-hidden')) { scrollValue -= scrollButtons[0][dimension]; } setTargetScrollValue(scrollValue, scrollDimension, dimension); that._updateScrollButtonVisibility(parent, scrollDimension === 'Left', scrollButtons); if (oldParentDimension !== parent[dimension]) { setTargetScrollValue(scrollValue, scrollDimension, dimension); } } if ((parent === mainContainer && mode === 'horizontal') && (parentBoundingRect.left > scrollTargetBoundingRect.left || parentBoundingRect.right < scrollTargetBoundingRect.right)) { scrollTo('Left', 'offsetWidth'); } else if (parentBoundingRect.top > scrollTargetBoundingRect.top || parentBoundingRect.bottom < scrollTargetBoundingRect.bottom) { scrollTo('Top', 'offsetHeight'); } that._scrollInfo.set(parent, { left: parent.scrollLeft, top: parent.scrollTop }); } /** * Makes sure a lw-menu-item/lw-menu-items-group is visible by scrolling to it (when "mode" is 'tree'). */ _ensureVisibleTreeMode(item, scrollTargetBoundingRect, parent, parentBoundingRect, padding) { const that = this; if ((that._element === 'menu' || that.scrollMode === 'scrollButtons') && !parent.$.hasClass('scroll-buttons-shown') && that.overflow !== 'hidden') { return; } const oldHeight = parent.offsetHeight, scrollButtonNearHidden = that.$scrollButtonNear.hasClass('lw-hidden'); let newScrollTop; if (parentBoundingRect.top > scrollTargetBoundingRect.top) { newScrollTop = that._getOffsetTop(item); } else { let itemHeight = !item.expanded ? item.offsetHeight : item.firstElementChild.offsetHeight + parseInt(window.getComputedStyle(item.children[1]).marginTop, 10); if (that._element === 'tree') { itemHeight += parseFloat(getComputedStyle(that).getPropertyValue('--lw-tree-item-vertical-offset')) || 0; } if (parentBoundingRect.bottom < scrollTargetBoundingRect.top + itemHeight) { newScrollTop = that._getOffsetTop(item) - oldHeight + itemHeight + padding; } else { return; } } if (that._element === 'tree' && item.path === '0') { newScrollTop -= parseFloat(getComputedStyle(that).getPropertyValue('--lw-tree-item-vertical-offset')); } parent.scrollTop = newScrollTop; if (that._element === 'menu' || that.scrollMode === 'scrollButtons') { that._updateScrollButtonVisibility(parent, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); } if (that.overflow === 'auto' && scrollButtonNearHidden && !that.$scrollButtonNear.hasClass('lw-hidden')) { parent.scrollTop += oldHeight - parent.offsetHeight; } that._scrollInfo.set(parent, { left: parent.scrollLeft, top: parent.scrollTop }); } /** * Escape key handler. */ _escapeHandler(focusedItem, level, lastOpenedContainer) { const that = this; if (focusedItem) { focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); } that._closeSubContainers(level, undefined, undefined, true); that._hoverViaKeyboard(lastOpenedContainer.menuItemsGroup); } /** * Expand items by default. */ _expandItemsByDefault(collapseBeforehand) { const that = this; if (that._menuItemsGroupsToExpand.length === 0 && !collapseBeforehand || that.mode !== 'tree' && !that._minimized) { return; } const restoreAnimation = that.hasAnimation, animationType = that.animation; if (restoreAnimation) { that.animation = 'none'; } if (collapseBeforehand) { that._collapseAll(false); } for (let i = 0; i < that._menuItemsGroupsToExpand.length; i++) { that.expandItem(that._menuItemsGroupsToExpand[i].path, undefined, false); } if (restoreAnimation) { that.animation = animationType; } that._menuItemsGroupsToExpand = []; } /** * Expands a section (in tree/minimized mode). */ _expandSection(element) { const that = this, oldHeight = element.style.height, sectionHeight = element.scrollHeight + 'px'; element.style.height = sectionHeight; that._treeAnimationInProgress = element; if (oldHeight === sectionHeight || !parseFloat(oldHeight) && !parseFloat(sectionHeight)) { that._transitionendHandlerExpand(that, element); return; } element.addEventListener('transitionend', that._transitionendHandlerExpand); } /** * Filter input keyup handler. */ _filterInputKeyupHandler() { const that = this; if (that._filterTimer) { clearTimeout(that._filterTimer); } that._filterTimer = setTimeout(function () { const context = that.context; that.context = that; that._applyFilter(that.$.filterInput.value, that._view); that._checkOverflow(); that.context = context; }, 300); } /** * Finds an item based on filter criteria. */ _findItem(item, filterQuery) { if (filterQuery === '') { return item; } const that = this; switch (that.filterMode) { case 'startsWith': if (item.label.indexOf(filterQuery) === 0) { return item; } break; case 'startsWithIgnoreCase': if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) === 0) { return item; } break; case 'doesNotContain': if (item.label.indexOf(filterQuery) < 0) { return item; } break; case 'doesNotContainIgnoreCase': if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) < 0) { return item; } break; case 'contains': if (item.label.indexOf(filterQuery) > -1) { return item; } break; case 'containsIgnoreCase': if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) > -1) { return item; } break; case 'equals': if (item.label.localeCompare(filterQuery) === 0) { return item; } break; case 'equalsIgnoreCase': if (item.label.toLowerCase().localeCompare(filterQuery.toLowerCase()) === 0) { return item; } break; case 'endsWith': if (item.label.endsWith(filterQuery)) { return item; } break; case 'endsWithIgnoreCase': if (item.label.toLowerCase().endsWith(filterQuery.toLowerCase())) { return item; } break; } return null; } /** * Returns the first MenuItem/MenuItemsGroup that is not disabled. */ _getFirstEnabledChild(parent) { const children = parent.children; for (let i = 0; i < children.length; i++) { if (this._isChildEnabled(children[i])) { return children[i]; } } } /** * Returns the last MenuItem/MenuItemsGroup that is not disabled. */ _getLastEnabledChild(parent) { const children = parent.children; for (let i = children.length - 1; i >= 0; i--) { if (this._isChildEnabled(children[i])) { return children[i]; } } } /** * Returns the next MenuItem/MenuItemsGroup that is not disabled. */ _getNextEnabledChild(child) { if (!child) { return; } while (child.nextElementSibling) { const nextElementSibling = child.nextElementSibling; if (this._isChildEnabled(nextElementSibling)) { return nextElementSibling; } child = nextElementSibling; } } /** * Gets an item's offset from the top of the main container. */ _getOffsetTop(target) { let offsetTop = target.offsetTop; while (target.offsetParent !== this.$.mainContainer) { target = target.offsetParent; offsetTop += target.offsetTop; } return offsetTop; } /** * Returns the previous MenuItem/MenuItemsGroup that is not disabled. */ _getPreviousEnabledChild(child) { if (!child) { return; } while (child.previousElementSibling) { const previousElementSibling = child.previousElementSibling; if (this._isChildEnabled(previousElementSibling)) { return previousElementSibling; } child = previousElementSibling; } } /** * Hamburger icon click handler. */ _hamburgerIconClickHandler(event, itemContainer) { if (event) { event.stopPropagation(); } const that = this; if (itemContainer === undefined) { if (LW.ListMenu && that instanceof LW.ListMenu) { itemContainer = that.$.view; } else { itemContainer = that.$.mainContainer; } } if (that.disabled) { return; } if (!that._minimizedDropDownOpened) { that._positionDetection.placeOverlay(); if (that.dropDownAppendTo !== null) { const dropDownPosition = that.dropDownPosition, menuBoundingRect = that.getBoundingClientRect(), dropDownOffset = that._positionDetection.getDropDownOffset(); if (dropDownPosition.indexOf('right') !== -1 || dropDownPosition === 'auto') { if (that.rightToLeft) { itemContainer.style.right = 'initial'; itemContainer.style.left = (menuBoundingRect.left + menuBoundingRect.width - itemContainer.offsetWidth - dropDownOffset.x) + 'px'; } else { itemContainer.style.left = menuBoundingRect.left + dropDownOffset.x + 'px'; itemContainer.style.right = 'initial'; } } else if (dropDownPosition.indexOf('left') !== -1) { itemContainer.style.left = menuBoundingRect.right - itemContainer.offsetWidth + dropDownOffset.x + 'px'; itemContainer.style.right = 'initial'; } if (dropDownPosition.indexOf('bottom') !== -1 || dropDownPosition.indexOf('overlay') !== -1 || dropDownPosition === 'auto') { itemContainer.style.top = menuBoundingRect.bottom + dropDownOffset.y + 'px'; } else if (dropDownPosition.indexOf('top') !== -1) { itemContainer.style.top = menuBoundingRect.top + dropDownOffset.y + 'px'; } } else { itemContainer.style.right = ''; } if (that._edgeMacFF) { itemContainer.$.removeClass('not-in-view'); } itemContainer.$.removeClass('lw-visibility-hidden'); that.$hamburgerIcon.addClass('lw-close-button'); that.$.hamburgerIcon.setAttribute('aria-expanded', true); that._minimizedDropDownOpened = true; that._browserBoundsDetection(itemContainer); } else { that._close(); } } /** * Handles change to the "overflow" property. */ _handleOverflowChange() { const that = this, mainContainer = that.$.mainContainer; if ((that._minimized || that.dropDownAppendTo === null && !mainContainer.classList.contains('simple') && that.mode !== 'tree') && !(LW.ListMenu && that instanceof LW.ListMenu)) { return; } const overflow = that.overflow; let horizontal; if (that.mode === 'horizontal') { horizontal = true; mainContainer.scrollLeft = 0; } else { horizontal = false; mainContainer.scrollTop = 0; } if (overflow === 'hidden') { mainContainer.classList.remove('scroll-buttons-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); } else { that.$.scrollButtonNear.disabled = that.disabled; that.$.scrollButtonFar.disabled = that.disabled; if (overflow === 'auto') { that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); that._checkOverflow(mainContainer, horizontal, [that.$.scrollButtonNear, that.$.scrollButtonFar]); } else { mainContainer.classList.add('scroll-buttons-shown'); mainContainer.classList.remove('one-button-shown'); that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); that._updateScrollButtonVisibility(mainContainer, horizontal, [that.$.scrollButtonNear, that.$.scrollButtonFar]); } } that._scrollInfo.set(mainContainer, { left: mainContainer.scrollLeft, top: mainContainer.scrollTop }); } /** * Hides main container scroll buttons. */ _hideMainContainerScrollButtons() { const that = this; that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); that.$mainContainer.removeClass('scroll-buttons-shown'); that.$mainContainer.removeClass('one-button-shown'); } /** * Hovers an item via the keyboard. */ _hoverViaKeyboard(item) { if (!item) { return; } const that = this; item.$.addClass('focus'); item.setAttribute('focus', ''); that._focusedViaKeyboard = item; that._ensureVisible(item); } /** * Checks if all items in a tree branch are expanded. */ _isBranchExpanded(item) { const that = this; if (that.mode !== 'tree') { return true; } let expanded = true; while (item.parentItem) { expanded = expanded && item.parentItem.expanded; item = item.parentItem; } return expanded; } /** * Checks if an item can be focused. */ _isChildEnabled(child) { return !(child.disabled || child.templateApplied || child.hidden || child instanceof HTMLDivElement || child.offsetHeight === 0); } /** * Checks if a container is opened. */ _isContainerOpened(level, container) { const that = this; if (that.mode === 'tree' || that._minimized) { if (!that._openedContainers[level]) { that._openedContainers[level] = []; } return that._openedContainers[level].indexOf(container) !== -1; } else { return that._openedContainers[level] === container; } } /** * Keydown event handler. */ _keydownHandler(event) { const that = this; let key = event.key; if (that.getRootNode().activeElement !== that || ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Enter', 'Escape', 'Home', ' '].indexOf(key) === -1 || that.disabled) { return; } event.preventDefault(); const mode = that.mode; if (mode === 'tree' || that._minimized) { that._keydownHandlerTreeMode(key); return; } const dropDownPosition = that.dropDownPosition, leftOrientation = dropDownPosition.indexOf('left') !== -1, topOrientation = dropDownPosition === 'top-left' || dropDownPosition === 'top-right', openedContainers = that._openedContainers; let lastOpenedContainer = that.$.mainContainer, level = 1, focusedItem; for (let i = openedContainers.length - 1; i >= 0; i--) { if (openedContainers[i] !== undefined) { lastOpenedContainer = openedContainers[i]; level = lastOpenedContainer.level; lastOpenedContainer = lastOpenedContainer.itemContainer; break; } } focusedItem = lastOpenedContainer.querySelector('[focus][level="' + level + '"]'); if (that.rightToLeft) { if (key === 'ArrowLeft') { key = 'ArrowRight'; } else if (key === 'ArrowRight') { key = 'ArrowLeft'; } } switch (key) { case 'ArrowDown': if (level === 1) { if (mode === 'horizontal' && !topOrientation) { that._levelOneOpenDropDown(focusedItem); } else if (mode !== 'horizontal') { that._levelOneNavigate('_getFirstEnabledChild', focusedItem, lastOpenedContainer); } } else { that._navigate('_getNextEnabledChild', focusedItem, lastOpenedContainer); } break; case 'ArrowLeft': if (!leftOrientation) { that._arrowLeftHandler(level, mode, focusedItem, lastOpenedContainer); } else { if (level === 1) { if (mode === 'horizontal') { that._levelOneNavigate('_getLastEnabledChild', focusedItem, lastOpenedContainer); } else { that._levelOneOpenDropDown(focusedItem); } } else { if (focusedItem instanceof LW.MenuItemsGroup) { that._selectionHandler({ target: focusedItem, isTrusted: true }); } else { that._levelOneNavigateFromLowerLevel('_getPreviousEnabledChild', focusedItem); } } } break; case 'ArrowRight': if (!leftOrientation) { that._arrowRightHandler(level, mode, focusedItem, lastOpenedContainer); } else { if (level === 1) { if (mode === 'horizontal') { that._levelOneNavigate('_getFirstEnabledChild', focusedItem, lastOpenedContainer); } } else { if (level === 2) { that._levelOneNavigateFromLowerLevel('_getNextEnabledChild', focusedItem); } else { that._escapeHandler(focusedItem, level, lastOpenedContainer); } } } break; case 'ArrowUp': if (level === 1) { if (mode === 'horizontal' && topOrientation) { that._levelOneOpenDropDown(focusedItem); } else if (mode !== 'horizontal') { that._levelOneNavigate('_getLastEnabledChild', focusedItem, lastOpenedContainer); } } else { that._navigate('_getPreviousEnabledChild', focusedItem, lastOpenedContainer); } break; case 'End': case 'Home': { const enabledChild = key === 'End' ? that._getLastEnabledChild(lastOpenedContainer) : that._getFirstEnabledChild(lastOpenedContainer); if (!enabledChild || focusedItem === enabledChild) { return; } if (focusedItem) { focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); } that._hoverViaKeyboard(enabledChild); break; } case 'Enter': if (focusedItem) { that._selectionHandler({ target: focusedItem, isTrusted: true }); } break; case 'Escape': if (level > 1) { if (level === 2) { that._positionDetection.removeOverlay(); } that._escapeHandler(focusedItem, level, lastOpenedContainer); } else if (mode === 'dropDown' && that.opened) { that.close({ trigger: 'interaction', target: 'Escape' }); } break; case ' ': if (focusedItem) { that._toggleItem(focusedItem); } break; } } /** * Keydown event handler. */ _keydownHandlerTreeMode(key) { const that = this, menuItems = Array.from(that.$.mainContainer.querySelectorAll('lw-menu-item, lw-menu-items-group')), focusedItem = that.$.mainContainer.getElementsByClassName('focus')[0]; function canItemBefocused(item) { const level = item.level; return item.disabled === false && item.templateApplied !== true && (level === 1 || level > 1 && that._isContainerOpened(level, item.parentElement.container) && item.getBoundingClientRect().height > 0); } function moveDown(startIndex) { for (let i = startIndex; i < menuItems.length; i++) { const currentItem = menuItems[i]; if (canItemBefocused(currentItem)) { if (focusedItem) { if (focusedItem === currentItem) { break; } focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); } that._hoverViaKeyboard(currentItem); break; } } } function moveUp(startIndex) { for (let i = startIndex; i >= 0; i--) { const currentItem = menuItems[i]; if (canItemBefocused(currentItem)) { if (focusedItem) { if (focusedItem === currentItem) { break; } focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); } that._hoverViaKeyboard(currentItem); break; } } } function navigateToParentItem() { if (focusedItem.level > 1) { focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); that._hoverViaKeyboard(focusedItem.parentItem); } } let startIndex; switch (key) { case 'ArrowDown': if (focusedItem) { startIndex = menuItems.indexOf(focusedItem) + 1; } else { startIndex = 0; } moveDown(startIndex); break; case 'ArrowLeft': if (!focusedItem) { return; } if (focusedItem instanceof LW.MenuItem) { navigateToParentItem(); } else { if (that._isContainerOpened(focusedItem.level + 1, focusedItem.container)) { that._closeSubContainers(focusedItem.level + 1, focusedItem.container, true, true); return; } navigateToParentItem(); } break; case 'ArrowRight': if (!focusedItem || focusedItem instanceof LW.MenuItem) { return; } if (that._isContainerOpened(focusedItem.level + 1, focusedItem.container)) { focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); that._hoverViaKeyboard(that._getFirstEnabledChild(focusedItem.itemContainer)); } else { that._selectionHandler({ target: focusedItem, type: 'keydown', isTrusted: true }, focusedItem); } break; case 'ArrowUp': if (focusedItem) { startIndex = menuItems.indexOf(focusedItem) - 1; } else { startIndex = menuItems.length - 1; } moveUp(startIndex); break; case 'End': moveUp(menuItems.length - 1); break; case 'Enter': if (that._minimized && !that._minimizedDropDownOpened) { that._hamburgerIconClickHandler(undefined, that.$.mainContainer); } else if (focusedItem) { that._selectionHandler({ target: focusedItem, type: 'keydown', isTrusted: true }); } break; case 'Escape': if (that._minimized && that._minimizedDropDownOpened) { that._close(); } break; case 'Home': moveDown(0); break; case ' ': if (focusedItem) { that._toggleItem(focusedItem); } break; } } /** * Navigates through first-level items. */ _levelOneNavigate(method, focusedItem, lastOpenedContainer) { const that = this; if (!focusedItem) { const enabledChild = that[method](lastOpenedContainer); if (enabledChild) { that._hoverViaKeyboard(enabledChild); } } else { if (method === '_getLastEnabledChild') { that._navigate('_getPreviousEnabledChild', focusedItem, lastOpenedContainer); } else { that._navigate('_getNextEnabledChild', focusedItem, lastOpenedContainer); } } } /** * Navigates to a first-level item. */ _levelOneNavigateFromLowerLevel(method, focusedItem) { const that = this, firstLevelItem = that[method](that._openedContainers[2].menuItemsGroup); if (firstLevelItem) { if (focusedItem) { focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); } that._closeSubContainers(2); if (firstLevelItem instanceof LW.MenuItemsGroup) { that._selectionHandler({ target: firstLevelItem, isTrusted: true }); } else { that._hoverViaKeyboard(firstLevelItem); } } } /** * Opens first-level dropdown containers via the keyboard. */ _levelOneOpenDropDown(focusedItem) { if (focusedItem && focusedItem instanceof LW.MenuItemsGroup) { this._selectionHandler({ target: focusedItem, isTrusted: true }); } } /** * External main container handler. */ _mainContainerHandler(event) { const that = this; if (!that._minimized || that.dropDownAppendTo === null) { return; } switch (event.type) { case 'click': that._selectionHandler(event); break; case 'mouseleave': that._mouseleaveHandler(event); break; case 'mouseout': that._mouseoutMouseoverHandler(event); break; case 'mouseover': that._mouseoutMouseoverHandler(event); break; } } /** * lw-menu-item selection handler. */ _menuItemSelectionHandler(closestItem, event) { const that = this; function focus() { if (that.enableShadowDOM && ((that.shadowRoot.activeElement || document.activeElement) !== that && that.dropDownAppendTo !== null && event.type === 'click' && !that.shadowRoot.contains(closestItem))) { that.focus(); } else if (document.activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !that.contains(closestItem)) { that.focus(); } } if (closestItem.disabled || closestItem.templateApplied) { focus(); return; } if (!that._toggleItem(closestItem)) { that.$.fireEvent('itemClick', { 'item': closestItem, 'label': closestItem.label, 'value': closestItem.value }); if (that.mode !== 'tree') { that._close(); if (that.mode === 'dropDown') { that._ripple(closestItem, event); that.close({ trigger: 'interaction', target: closestItem }); return; } } } that._ripple(closestItem, event); focus(); } /** * lw-menu-items-group selection handler. */ _menuItemsGroupSelectionHandler(closestItemsGroup, event, fireEvent) { const that = this, mode = that.mode, container = closestItemsGroup.container, level = container.level, defaultView = mode !== 'tree' && !that._minimized; if (that._treeAnimationInProgress === container) { return; } that._discardKeyboardHover(); if (that.getRootNode().activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !that.contains(event.target)) { that.focus(); } if (event.type === 'click' && ((!event.target.classList.contains('lw-' + that._element + '-items-group-arrow') && that._toggleItem(closestItemsGroup)) || (that.selectionMode === 'mouseenter' && mode !== 'tree' && !that._minimized))) { return; } let animation = that.hasAnimation; if (that._isContainerOpened(level, container)) { that._closeSubContainers(level, container, true, fireEvent !== false); if (defaultView && closestItemsGroup.hasAttribute('focus')) { that._focusedViaKeyboard = closestItemsGroup; } } else { const expandingEvent = that.$.fireEvent('expanding', { 'item': closestItemsGroup, 'label': closestItemsGroup.label, 'path': closestItemsGroup.path, 'value': closestItemsGroup.value, 'children': closestItemsGroup.itemContainer.children }); if (expandingEvent.defaultPrevented) { return; } that._positionDetection.placeOverlay(); if (defaultView) { that._closeSubContainers(level); } if (animation && !defaultView) { if (event.type !== 'expand') { that._ensureVisibleOnTransitionend = closestItemsGroup; } that._expandSection(container); } if (that._edgeMacFF && level === 2 && defaultView) { container.$.removeClass('not-in-view'); } container.$.removeClass('lw-visibility-hidden'); if (defaultView || event.type !== 'expand') { if (!defaultView) { const currentFocus = that.$.mainContainer.getElementsByClassName('focus')[0]; if (currentFocus) { currentFocus.$.removeClass('focus'); currentFocus.removeAttribute('focus'); } that._focusedViaKeyboard = closestItemsGroup; } else if (event.type === 'keydown') { that._focusedViaKeyboard = closestItemsGroup; } closestItemsGroup.$.addClass('focus'); closestItemsGroup.setAttribute('focus', ''); } closestItemsGroup.$.addClass('lw-' + that._element + '-items-group-opened'); closestItemsGroup.$.addClass('lw-' + that._element + '-items-group-expanded'); closestItemsGroup.setAttribute('aria-expanded', true); that._addOpenedContainer(level, container); if (defaultView) { that._ensureVisible(closestItemsGroup); if (closestItemsGroup.level > 1 && closestItemsGroup.parentElement.dropDownHeightSet) { const dropDownPosition = that.dropDownPosition, top = closestItemsGroup.getBoundingClientRect().top - closestItemsGroup.parentElement.container.getBoundingClientRect().top; if (dropDownPosition.indexOf('bottom') !== -1 || dropDownPosition === 'auto') { container.style.top = top + 'px'; } else if (dropDownPosition.indexOf('top') !== -1) { container.style.top = top + closestItemsGroup.offsetHeight + 'px'; } else { container.style.top = (top + closestItemsGroup.offsetHeight / 2) + 'px'; } } if (container.itemContainer.checkOverflow && container.itemContainer.dropDownHeightSet) { that._checkOverflow(container.itemContainer, false, [container.children[0], container.children[2]]); delete container.itemContainer.checkOverflow; } } that._positionExternalContainer(container, closestItemsGroup); if (mode !== 'tree' && !that._minimized) { that._browserBoundsDetection(container); } else if (!animation) { that._browserBoundsDetection(that.$.mainContainer); } if (event.type === undefined) { that._hoverViaKeyboard(that._getFirstEnabledChild(closestItemsGroup.itemContainer)); } if (fireEvent !== false) { that.$.fireEvent('expand', { 'item': closestItemsGroup, 'label': closestItemsGroup.label, 'path': closestItemsGroup.path, 'value': closestItemsGroup.value, 'children': closestItemsGroup.itemContainer.children }); } } if (defaultView) { that._ripple(closestItemsGroup, event); } else if (mode === 'tree' && !animation) { that._checkOverflow(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); if (!that._minimized && event.type !== 'expand') { that._ensureVisible(closestItemsGroup); } } } /** * Mouseenter handler. */ _mouseenterHandler() { const that = this; if (that.autoFocusOnMouseenter && that.getRootNode().activeElement !== that) { that.focus(); } } /** * Mouseleave handler. */ _mouseleaveHandler(event) { const that = this; if (that.selectionMode === 'mouseenter' && that.mode !== 'tree' && !that._minimized) { if (that.dropDownAppendTo !== null && event.relatedTarget) { if (that.contains(event.target)) { const externalContainer = event.relatedTarget.closest('.lw-menu-drop-down'); if (externalContainer && externalContainer.ownerElement === that) { return; } } else if (that.contains(event.relatedTarget)) { return; } } that._isElementHovered = false; that._autoCloseTimeout = setTimeout(function () { const context = that.context; clearTimeout(that._autoCloseTimeout); if (!that._isElementHovered) { that.context = that; that._close(); that.context = context; } }, that.autoCloseDelay); } } /** * Mouseout/mouseover handler. */ _mouseoutMouseoverHandler(event) { const that = this; if (that.disabled || that.displayLoadingIndicator) { return; } let closestItem = event.target.closest('lw-menu-item') || event.target.closest('lw-menu-items-group'); if (that.enableShadowDOM) { closestItem = event.composedPath()[0].closest('lw-menu-item') || event.composedPath()[0].closest('lw-menu-items-group') || closestItem; } if (event.type === 'mouseover') { that._isElementHovered = true; } if (closestItem === null || closestItem.disabled || closestItem.templateApplied) { return; } if ((that.mode === 'tree' || that._minimized) && closestItem.hasAttribute('focus') && event.relatedTarget && (event.target.parentElement === event.relatedTarget || event.relatedTarget.parentElement === event.target)) { return; } that._discardKeyboardHover(false); if (event.type === 'mouseover') { if (that.selectionMode === 'mouseenter' && that.mode !== 'tree' && !that._minimized) { if (closestItem instanceof LW.MenuItemsGroup && !closestItem.hasAttribute('hover')) { that._selectionHandler(event, closestItem); } else if (closestItem instanceof LW.MenuItem) { that._closeSubContainers(closestItem.level + 1); } } const closestDropDown = event.target.closest('.lw-menu-drop-down'); if (!closestDropDown || closestDropDown && !closestItem.contains(closestDropDown)) { closestItem.$.addClass('hover'); closestItem.setAttribute('hover', ''); that._discardKeyboardHover(true); } } else { if (that.mode !== 'tree' && !that._minimized) { if (that.selectionMode === 'mouseenter' && event.relatedTarget === that.$.mainContainer) { that._close(); } if (closestItem instanceof LW.MenuItemsGroup && closestItem.container && !closestItem.container.$.hasClass('lw-visibility-hidden')) { return; } } closestItem.$.removeClass('hover'); closestItem.removeAttribute('hover'); } } /** * Moves dropdowns to external container. */ _moveDropDownsToExternalContainer() { const that = this; for (let i = 0; i < that._containersInBody.length; i++) { const container = that._containersInBody[i]; that._dropDownParent.appendChild(container); container.$.listen('click', that._selectionHandler.bind(that)); container.$.listen('mouseleave', that._mouseleaveHandler.bind(that)); container.$.listen('mouseout', that._mouseoutMouseoverHandler.bind(that)); container.$.listen('mouseover', that._mouseoutMouseoverHandler.bind(that)); } for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; container.ownerElement = that; if (that.theme !== '') { container.classList.add(that.theme); } if (that.rightToLeft) { container.setAttribute('right-to-left', ''); } container.classList.add('lw-drop-down-repositioned'); container.setAttribute('mode', that.mode); container.setAttribute('drop-down-position', that.dropDownPosition); if (that.checkboxes) { container.setAttribute('checkboxes', ''); } } } /** * Moves dropdowns to the Menu. */ _moveDropDownsToMenu() { const that = this; for (let i = 0; i < that._containersInBody.length; i++) { const container = that._containersInBody[i]; container.$.unlisten('click'); container.$.unlisten('mouseleave'); container.$.unlisten('mouseout'); container.$.unlisten('mouseover'); container.style.left = ''; container.style.right = ''; container.style.top = ''; container.style.marginLeft = ''; container.style.marginTop = ''; container.menuItemsGroup.appendChild(container); } for (let i = 0; i < that._containers.length; i++) { const container = that._containers[i]; if (that.theme !== '') { container.classList.remove(that.theme); } container.classList.remove('lw-drop-down-repositioned'); container.removeAttribute('mode'); container.removeAttribute('drop-down-position'); container.removeAttribute('checkboxes'); container.removeAttribute('right-to-left'); } } /** * Navigates to an item via the keyboard. */ _navigate(method, focusedItem, lastOpenedContainer) { const that = this; if (!focusedItem) { if (method === '_getNextEnabledChild') { that._hoverViaKeyboard(that._getFirstEnabledChild(lastOpenedContainer)); } else { that._hoverViaKeyboard(that._getLastEnabledChild(lastOpenedContainer)); } return; } const navigateToChild = that[method](focusedItem); if (navigateToChild) { focusedItem.$.removeClass('focus'); focusedItem.removeAttribute('focus'); that._hoverViaKeyboard(navigateToChild); } } /** * Positions an external dropdown container. */ _positionExternalContainer(container, menuItemsGroup) { const that = this; if (that.dropDownAppendTo === null || container.level !== 2) { return; } const dropDownPosition = that.dropDownPosition, mode = that.mode, menuItemsGroupRect = menuItemsGroup.getBoundingClientRect(), dropDownOffset = that._positionDetection.getDropDownOffset(), top = menuItemsGroupRect.top + dropDownOffset.y, bottom = menuItemsGroupRect.bottom + dropDownOffset.y; let left = menuItemsGroupRect.left + dropDownOffset.x; let right = menuItemsGroupRect.right + dropDownOffset.x; container.style.top = container.style.left = container.style.right = ''; if (that.rightToLeft) { container.style.right = 'initial'; } if (dropDownPosition.indexOf('left') !== -1) { left -= container.offsetWidth; if (mode === 'horizontal' || dropDownPosition === 'overlay-left') { left += menuItemsGroupRect.width; } container.style.left = left + 'px'; container.style.right = 'initial'; } else if (mode === 'horizontal' || dropDownPosition === 'overlay-right') { container.style.left = left + 'px'; } else { if (that.rightToLeft) { container.style.left = (right - container.offsetWidth) + 'px'; } else { container.style.left = (left + menuItemsGroupRect.width) + 'px'; } } switch (dropDownPosition) { case 'bottom-right': case 'bottom-left': case 'auto': if (mode === 'horizontal') { container.style.top = bottom + 'px'; } else { container.style.top = top + 'px'; } break; case 'top-right': case 'top-left': if (mode === 'horizontal') { container.style.top = (top - container.offsetHeight) + 'px'; } else { container.style.top = (bottom - container.offsetHeight) + 'px'; } break; case 'overlay-right': case 'overlay-left': container.style.top = (top + menuItemsGroupRect.height / 2) + 'px'; break; } } /** * Processes "dataSource" object. */ _processDataSource() { const that = this, dataSource = that.dataSource, displayMember = that.displayMember, itemsMember = that.itemsMember, valueMember = that.valueMember; function processItem(item, parent) { let element; if (Array.isArray(item[itemsMember]) && item[itemsMember].length > 0) { element = document.createElement('lw-' + that._element + '-items-group'); if (item.checkable === true) { element.set('checkable', true); } if (typeof item.checkMode === 'string') { element.set('checkMode', item.checkMode); } if (item.dropDownHeight) { element.set('dropDownHeight', item.dropDownHeight); } if (item.expanded === true && that.mode === 'tree') { element.set('expanded', true); element.setAttribute('aria-expanded', true); } for (let i = 0; i < item[itemsMember].length; i++) { processItem(item[itemsMember][i], element); } } else { element = document.createElement('lw-' + that._element + '-item'); if (item.shortcut !== undefined) { element.set('shortcut', item.shortcut); } if (item.customAttribute) { element.setAttribute(item.customAttribute, ''); } } if (item.id !== undefined && /^[A-Za-z]+[\w\-\:\.]*$/.test(item.id)) { element.id = item.id; } if (item.checked === true) { element.set('checked', true); element.setAttribute('aria-checked', true); } if (item.disabled === true) { element.set('disabled', true); } if (item[displayMember] !== undefined) { element.set('label', item[displayMember]); } else if (typeof item[itemsMember] === 'string') { element.set('label', item[itemsMember]); } if (item.selected === true) { element.set('selected', true); } if (item.separator === true) { element.set('separator', true); } if (item[valueMember] !== undefined) { element.set('value', item[valueMember]); } parent.appendChild(element); } that.$.mainContainer.innerHTML = ''; for (let i = 0; i < dataSource.length; i++) { const currentItem = dataSource[i]; processItem(currentItem, that.$.mainContainer); } that._processHTML(that.$.mainContainer, 1); } /** * Processes initial HTML structure. */ _processHTML(item, level, autoSort) { const that = this; let container, itemContainer; if (level > 1) { container = that._createMenuItemsGroupContainer(item, level); itemContainer = container.itemContainer; if ((item.expanded || item.hasAttribute('expanded')) && that.mode === 'tree') { that._menuItemsGroupsToExpand.push(item); } else { item.set('expanded', false); item.removeAttribute('expanded'); item.setAttribute('aria-expanded', false); } } const itemChildren = Array.from(item.children), checkedChildren = [], itemFragment = document.createDocumentFragment(); let pathOffset = 0; for (let i = 0; i < itemChildren.length; i++) { if (level > 1 && i === 0) { pathOffset++; continue; } const currentItem = itemChildren[i]; if (!(currentItem instanceof LW.MenuItem || currentItem instanceof LW.MenuItemsGroup)) { currentItem.parentElement.removeChild(currentItem); pathOffset++; continue; } that._createItemHTMLStructure(currentItem, level, item, i - pathOffset); if (currentItem.checked || currentItem.hasAttribute('checked')) { if (!currentItem.disabled && !currentItem.hasAttribute('disabled') && !currentItem.templateApplied) { checkedChildren.push(currentItem); } else { currentItem.set('checked', false); currentItem.removeAttribute('checked'); currentItem.removeAttribute('aria-checked'); } } if (level > 1) { itemFragment.appendChild(currentItem); } if (currentItem instanceof LW.MenuItemsGroup) { that._processHTML(currentItem, level + 1); } } if (level > 1) { itemContainer.appendChild(itemFragment); item.container = container; item.itemContainer = itemContainer; if (item instanceof LW.MenuItemsGroup) { const arrowElement = document.createElement('div'); arrowElement.className = 'lw-' + that._element + '-items-group-arrow'; if (that._element === 'menu') { arrowElement.setAttribute('role', 'presentation'); } else { arrowElement.setAttribute('role', 'button'); arrowElement.setAttribute('aria-label', 'Toggle'); } that._setArrowDirection(arrowElement, level); item.firstElementChild.appendChild(arrowElement); } that._containers.push(container); if (level === 2) { that._containersInBody.push(container); if (that._edgeMacFF) { container.addEventListener('transitionend', function (event) { if (event.target === this && this.$.hasClass('lw-visibility-hidden')) { this.style.left = ''; this.style.top = ''; this.$.addClass('not-in-view'); } }); } } if (that.dropDownAppendTo === null || that.mode === 'tree' || that._minimized) { item.appendChild(container); } else { container.ownerElement = that; that.rightToLeft ? container.setAttribute('right-to-left', '') : container.removeAttribute('right-to-left'); container.classList.add('lw-drop-down-repositioned'); container.setAttribute('mode', that.mode); container.setAttribute('drop-down-position', that.dropDownPosition); if (that.checkboxes) { container.setAttribute('checkboxes', ''); } if (that.theme !== '') { container.$.addClass(that.theme); } container.setAttribute('animation', that.animation); if (level === 2) { that._dropDownParent.appendChild(container); container.$.listen('click', that._selectionHandler.bind(that)); container.$.listen('mouseleave', that._mouseleaveHandler.bind(that)); container.$.listen('mouseout', that._mouseoutMouseoverHandler.bind(that)); container.$.listen('mouseover', that._mouseoutMouseoverHandler.bind(that)); } else { item.appendChild(container); } } } that._validateRadioButtonSelection(item, level, checkedChildren); if (that._sortItems && autoSort !== false) { that._sortItems(item); } } /** * Processes initial HTML structure with <ul> element. */ _processUList() { const that = this, menuItemsGroupOpeningTagRegex = new RegExp(/<li>(.(?!<\/li>)|\n)*?<ul>/), menuItemsGroupClosingTagRegex = new RegExp(/<\/ul>(.|\n)*?<\/li>/); let innerHTML = that.$.mainContainer.firstElementChild.innerHTML; innerHTML = innerHTML.replace(/\r?\n|\r/g, ''); innerHTML = innerHTML.replace(/<li(.|\n)*?>/g, '<li>'); innerHTML = innerHTML.replace(/<li><\/li>/g, '<li> </li>'); innerHTML = innerHTML.replace(/<ul(.|\n)*?>/g, '<ul>'); while (menuItemsGroupOpeningTagRegex.test(innerHTML)) { const match = menuItemsGroupOpeningTagRegex.exec(innerHTML), content = '<lw-' + that._element + '-items-group>' + match[0].slice(4, match[0].length - 4); innerHTML = innerHTML.replace(match[0], content); } while (menuItemsGroupClosingTagRegex.test(innerHTML)) { const match = menuItemsGroupClosingTagRegex.exec(innerHTML), content = '</lw-' + that._element + '-items-group>'; innerHTML = innerHTML.replace(match[0], content); } innerHTML = innerHTML.replace(/li>/g, 'lw-' + that._element + '-item>'); that.$.mainContainer.innerHTML = innerHTML; } /** * Refreshes the "_containers" and "_containersFixedHeight" arrays. */ _refreshContainersArrays() { const that = this; for (let i = that._containers.length - 1; i >= 0; i--) { const container = that._containers[i]; if (!document.body.contains(container)) { that._containers.splice(i, 1); const index = that._containersFixedHeight.indexOf(container); if (index > -1) { that._containersFixedHeight.splice(index, 1); that._additionalScrollButtons.splice(index, 1); } } } that._checkContainersLength(); } /** * Refreshes numeric item paths. */ _refreshItemPaths(item, firstLevel, getChildren, resetOriginalIndex) { const that = this; let container; if (firstLevel) { container = item; } else { container = item.container.itemContainer; } const children = getChildren ? getChildren(item) : container.children; for (let i = 0; i < children.length; i++) { const currentItem = children[i]; let currentItemPath; if (resetOriginalIndex) { currentItem.originalIndex = i; } if (!firstLevel) { currentItemPath = item.path + '.' + i; } else { currentItemPath = '' + i; } currentItem.path = currentItemPath; that._menuItems[currentItemPath] = currentItem; if (currentItem instanceof LW.MenuItemsGroup) { that._refreshItemPaths(currentItem, undefined, getChildren, resetOriginalIndex); } } } /** * Removes fixed heights of containers. */ _removeContainerFixedHeight() { const that = this; for (let i = 0; i < that._containersFixedHeight.length; i++) { const container = that._containersFixedHeight[i]; container.style.height = ''; container.itemContainer.$.removeClass('scroll-buttons-shown'); container.itemContainer.$.removeClass('one-button-shown'); container.children[0].$.addClass('lw-hidden'); container.children[2].$.addClass('lw-hidden'); container.itemContainer.checkOverflow = true; } } /** * Removes containers added to the body or a custom external element. */ _removeContainersInBody() { const that = this; if (that.dropDownAppendTo !== null && !that._minimized) { for (let i = 0; i < that._containersInBody.length; i++) { that._containersInBody[i].remove(); } } } /** * Changes the parent of a Menu in 'dropDown' mode. */ _reparentMenu(dynamicChange, oldDropDownParent) { const that = this; if (that.mode !== 'dropDown' || that._dropDownParent === null && !dynamicChange || that._dropDownParent === that.parentElement) { return; } if (!dynamicChange || oldDropDownParent === null) { that._positionRelativeTo = that.parentElement; } else if (that._dropDownParent === null) { that._positionRelativeTo.appendChild(that); that._positionRelativeTo = null; return; } that._dropDownParent.appendChild(that); } /** * Resize handler. */ _resizeHandler() { const that = this; if (that._suppressResizeHandler) { delete that._suppressResizeHandler; return; } const minimizeWidth = that.minimizeWidth, mode = that.mode; if (minimizeWidth !== null && mode !== 'dropDown') { if (that.offsetWidth <= minimizeWidth && !that._minimized) { that.minimize(); return; } else if (that.offsetWidth > minimizeWidth) { that.maximize(); } } if (that.dropDownAppendTo !== null || mode === 'tree' || that.$mainContainer.hasClass('simple')) { that._checkOverflow(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); } } /** * Triggers ripple effect. */ _ripple(target, event) { const that = this; if (that.hasRippleAnimation && event.type === 'click') { LW.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY); return true; } } /** * Scrolls using scroll buttons. */ _scroll(scrollButton) { if (scrollButton.closest('[template-applied]')) { return; } const that = this, mainContainer = that.$.mainContainer, mode = that.mode, scrollCoefficient = scrollButton.classList.contains('lw-scroll-button-near') ? -1 : 1; let parent; if (scrollButton.parentElement === that.$.container) { parent = mainContainer; if (mode !== 'tree') { that._closeSubContainers(2); } if (that.mode === 'horizontal') { mainContainer.scrollLeft = mainContainer.scrollLeft + scrollCoefficient * 10; that._updateScrollButtonVisibility(mainContainer, true, [that.$.scrollButtonNear, that.$.scrollButtonFar]); } else { mainContainer.scrollTop = mainContainer.scrollTop + scrollCoefficient * 10; that._updateScrollButtonVisibility(mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); } } else { const container = scrollButton.parentElement, itemContainer = container.itemContainer; parent = itemContainer; that._closeSubContainers(container.level + 1); itemContainer.scrollTop = itemContainer.scrollTop + scrollCoefficient * 10; that._updateScrollButtonVisibility(itemContainer, false, [container.children[0], container.children[2]]); } that._scrollInfo.set(parent, { left: parent.scrollLeft, top: parent.scrollTop }); } /** * Selection handler. */ _selectionHandler(event, closestItemsGroup) { const that = this, target = event.target; if (target.closest('[template-applied]')) { event.stopPropagation(); } if (that.disabled || that.displayLoadingIndicator) { return; } if (closestItemsGroup === undefined) { if (event.type === 'click') { const closestScrollButton = target.closest('lw-repeat-button'); if (closestScrollButton) { that._scroll(closestScrollButton, event); return; } } if (!event.isTrusted) { return; } const closestItem = target.closest('lw-' + that._element + '-item'); if (closestItem) { that._menuItemSelectionHandler(closestItem, event); return; } closestItemsGroup = target.closest('lw-' + that._element + '-items-group'); if (closestItemsGroup && (target === closestItemsGroup.container || target === closestItemsGroup.container.firstElementChild)) { return; } } if (closestItemsGroup && !closestItemsGroup.disabled) { that._menuItemsGroupSelectionHandler(closestItemsGroup, event); } } /** * Sets direction of arrows. */ _setArrowDirection(arrowElement, level) { const that = this, mode = that.mode; if (mode === 'tree' || that._minimized) { arrowElement.className = 'lw-' + that._element + '-items-group-arrow down lw-arrow-down'; return; } if (that.dropDownPosition.slice(0, 7) !== 'overlay') { if (level === 2 && mode === 'horizontal') { if (that.dropDownPosition.slice(0, 3) !== 'top') { arrowElement.className = 'lw-menu-items-group-arrow down lw-arrow-down'; } else { arrowElement.className = 'lw-menu-items-group-arrow up lw-arrow-up'; } } else { arrowElement.className = 'lw-menu-items-group-arrow ' + (that.rightToLeft ? 'left lw-arrow-left' : 'right lw-arrow-right'); } } else { arrowElement.className = 'lw-menu-items-group-arrow minus'; } } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); return; } const tabindex = that.getAttribute('tabindex'); if (tabindex === null || tabindex < 0) { that.setAttribute('tabindex', 0); } } /** * Sets the label of a lw-menu-item/lw-menu-items-group. */ _setItemLabel(item, label) { const that = this, oldContext = that.context, labelElement = item.querySelector('.lw-menu-item-label-element'); that.context = that; that._setLabel(label, labelElement, item, true); labelElement.innerHTML = '<span>' + labelElement.innerHTML + '</span>'; that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]); that.context = oldContext; } /** * Sets the HTML content of an item's label or shortcut. */ _setLabel(label, labelElement, item, labelSet) { const potentialHTMLTemplate = document.getElementById(label); if (potentialHTMLTemplate !== null && potentialHTMLTemplate.tagName.toLowerCase() === 'template') { // label is the id of an HTML template const templateContent = document.importNode(potentialHTMLTemplate.content, true); if (item instanceof LW.MenuItem) { labelElement.appendChild(templateContent); if (labelSet) { item.setAttribute('template-applied', ''); item.templateApplied = true; } } else if (LW.ListMenu && this instanceof LW.ListMenu) { const regex = new RegExp(/{{title="(.*)"}}/); for (let i = 0; i < templateContent.childNodes.length; i++) { if (regex.test(templateContent.childNodes[i].innerHTML)) { item.titleLabel = regex.exec(templateContent.childNodes[i].innerHTML)[1]; templateContent.childNodes[i].innerHTML = templateContent.childNodes[i].innerHTML.replace(regex, ''); } else if (regex.test(templateContent.childNodes[i].textContent)) { item.titleLabel = regex.exec(templateContent.childNodes[i].textContent)[1]; templateContent.childNodes[i].textContent = templateContent.childNodes[i].textContent.replace(regex, ''); } } if (item.titleLabel === undefined) { item.titleLabel = templateContent.textContent; } labelElement.appendChild(templateContent); } else { labelElement.innerHTML = label; item.titleLabel = label; } } else { labelElement.innerHTML = label; if (item instanceof LW.MenuItemsGroup) { item.titleLabel = label; } } } /** * Toggles an item's checked state. */ _toggleItem(item) { const that = this; if (that.checkboxes) { const parent = item.level === 1 ? that : item.parentItem; if (parent.checkable) { const itemCheckableInfo = that._getItemCheckableInfo(item, parent); let fireItemClick = false; if (itemCheckableInfo.checkMode === 'none') { return false; } if (itemCheckableInfo.checkMode === 'checkbox') { fireItemClick = true; item.set('checked', !item.checked); if (item.checked) { item.setAttribute('aria-checked', true); } else { item.removeAttribute('aria-checked'); } that.$.fireEvent('itemCheckChange', { 'item': item, 'label': item.label, 'value': item.value, checked: item.checked }); } else if (itemCheckableInfo.checkMode === 'radioButton' && !item.checked) { fireItemClick = true; item.set('checked', true); item.setAttribute('aria-checked', true); that._uncheckSiblings(item, itemCheckableInfo.siblings); that.$.fireEvent('itemCheckChange', { 'item': item, 'label': item.label, 'value': item.value, checked: true }); } if (item instanceof LW.MenuItem && fireItemClick) { that.$.fireEvent('itemClick', { 'item': item, 'label': item.label, 'value': item.value }); } if (that.mode !== 'tree' && that.elementName !== 'ListMenu') { that._close(); that.close(); } return true; } } return false; } /** * Gets information about whether an item can be checked and its parent's check mode. Accounts for mixed check modes. */ _getItemCheckableInfo(item, parent) { const allSiblings = Array.from(item.parentElement.children), parentCheckMode = parent.checkMode.replace(/\s/g, '').split(','); let checkMode, siblings; if (parentCheckMode.length === 1) { checkMode = parentCheckMode[0]; siblings = allSiblings; } else { let group = 0, stop = false; siblings = []; for (let i = 0; i < allSiblings.length; i++) { const currentSibling = allSiblings[i]; siblings.push(currentSibling); if (currentSibling === item) { stop = true; } if (currentSibling.separator) { if (stop === true) { break; } group++; siblings = []; } } checkMode = parentCheckMode[group]; } return { checkMode: checkMode, siblings: siblings }; } /** * Refreshes checkable items. */ _refreshCheckableItems(parent) { const that = this, noCheckboxes = !that.checkboxes, parents = parent ? [parent] : [that].concat(that._containers.map(container => container.menuItemsGroup)); parents.forEach(parent => { const allSiblings = Array.from((parent === that ? that.$.mainContainer : parent.itemContainer).children); let parentCheckMode = parent.checkMode.replace(/\s/g, '').split(','); if (noCheckboxes || !parent.checkable || parentCheckMode.length === 1) { allSiblings.forEach(currentSibling => currentSibling.removeAttribute('check-type')); return; } let group = 0; parentCheckMode = parentCheckMode.map(checkMode => { if (['checkbox', 'radioButton', 'none'].indexOf(checkMode) === -1) { return 'none'; } return checkMode; }); let radioSiblings = [], checkedRadioSiblings = []; for (let i = 0; i < allSiblings.length; i++) { const currentSibling = allSiblings[i]; let checkMode = parentCheckMode[group]; if (checkMode === undefined) { checkMode = parentCheckMode[group] = 'none'; } if (checkMode === 'none' || !that._isChildEnabled(currentSibling)) { currentSibling.checked = false; currentSibling.removeAttribute('aria-checked'); } if (checkMode === 'none') { currentSibling.setAttribute('role', 'menuitem'); } else if (checkMode === 'checkbox') { currentSibling.setAttribute('role', 'menuitemcheckbox'); } else if (checkMode === 'radioButton') { currentSibling.setAttribute('role', 'menuitemradio'); radioSiblings.push(currentSibling); if (currentSibling.checked) { checkedRadioSiblings.push(currentSibling); } } currentSibling.setAttribute('check-type', checkMode); if (currentSibling.separator) { if (radioSiblings.length > 0) { if (checkedRadioSiblings.length > 1) { for (let j = 0; j < checkedRadioSiblings.length - 1; j++) { checkedRadioSiblings[j].checked = false; } } else if (checkedRadioSiblings.length === 0) { for (let j = 0; j < radioSiblings.length; j++) { if (that._isChildEnabled(radioSiblings[j])) { radioSiblings[j].checked = true; break; } } } } radioSiblings = []; checkedRadioSiblings = []; group++; } } parent.checkMode = parentCheckMode.join(', '); }); } /** * transitionend handler. */ _transitionendHandler(event) { const that = this; if (that.mode === 'dropDown' && that.opened && event.target === that && event.propertyName === 'opacity') { if (that._checkOverflowOnOpen) { that._checkOverflow(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); delete that._checkOverflowOnOpen; } if (that.getRootNode().activeElement !== that && !that._noAutoFocus) { that.focus(); } } } /** * Collapse animation transitionend handler. */ _transitionendHandlerCollapse() { let menu, container; if (arguments.length === 1) { if (arguments[0].propertyName === 'visibility') { return; } container = this; menu = container.menuItemsGroup.menu; } else { menu = arguments[0]; container = arguments[1]; } container.menuItemsGroup.$.removeClass('lw-' + menu._element + '-items-group-expanded'); container.menuItemsGroup.setAttribute('aria-expanded', false); container.removeEventListener('transitionend', menu._transitionendHandlerCollapse); container.style.height = null; container.$.addClass('lw-visibility-hidden'); menu._checkOverflow(menu.$.mainContainer, false, [menu.$.scrollButtonNear, menu.$.scrollButtonFar]); if (menu._minimized) { menu._browserBoundsDetection(menu.$.mainContainer); } delete menu._treeAnimationInProgress; } /** * Expand animation transitionend handler. */ _transitionendHandlerExpand() { let menu, container; if (arguments.length === 1) { if (arguments[0].propertyName === 'visibility') { return; } container = this; menu = container.menuItemsGroup.menu; } else { menu = arguments[0]; container = arguments[1]; } container.removeEventListener('transitionend', menu._transitionendHandlerExpand); container.style.height = null; menu._checkOverflow(menu.$.mainContainer, false, [menu.$.scrollButtonNear, menu.$.scrollButtonFar]); if (menu._minimized) { menu._browserBoundsDetection(menu.$.mainContainer); } if (menu._ensureVisibleOnTransitionend) { menu._ensureVisible(menu._ensureVisibleOnTransitionend); delete menu._ensureVisibleOnTransitionend; } delete menu._treeAnimationInProgress; } /** * Unchecks siblings (when "checkMode" is 'radioButton'). */ _uncheckSiblings(item, siblings) { for (let i = 0; i < siblings.length; i++) { const currentItem = siblings[i]; if (currentItem !== item && currentItem.checked) { currentItem.set('checked', false); currentItem.removeAttribute('aria-checked'); this.$.fireEvent('itemCheckChange', { 'item': currentItem, 'label': currentItem.label, 'value': currentItem.value, checked: false }); } } } /** * Unsorts items. */ _unsortItems(item, noRecursion) { const that = this; let itemChildren, parent, originalOrder = []; if (item === that.$.mainContainer) { parent = item; itemChildren = item.children; } else { parent = item.container.firstElementChild; itemChildren = parent.children; } for (let i = 0; i < itemChildren.length; i++) { const currentItem = itemChildren[i]; originalOrder[currentItem.originalIndex] = currentItem; if (currentItem instanceof LW.MenuItemsGroup && noRecursion === undefined) { that._unsortItems(currentItem); } } if (originalOrder.length < 2) { return; } for (let i = 0; i < originalOrder.length; i++) { parent.appendChild(originalOrder[i]); } } /** * Updates the WAI-ARIA roles of lw-menu-items and lw-menu-items-groups. */ _updateItemRoles(context) { const that = this; for (let path in that._menuItems) { const item = that._menuItems[path], parent = item.parentItem || that; if (context && parent !== context) { continue; } if (that.checkboxes) { if (parent.checkable) { item.setAttribute('role', parent.checkMode === 'checkbox' ? 'menuitemcheckbox' : 'menuitemradio'); } else { item.setAttribute('role', 'menuitem'); } } else { item.setAttribute('role', 'menuitem'); } } that._refreshCheckableItems(context); } /** * Updates scroll button visibility. */ _updateScrollButtonVisibility(element, horizontal, scrollButtons) { const that = this, overflow = that.overflow, mainContainer = element === that.$.mainContainer; if (mainContainer && overflow === 'hidden') { return; } let showNear = true, showFar = true, scrollDirection, dimension, scrollDimension; if (horizontal) { scrollDirection = 'scrollLeft'; dimension = 'offsetWidth'; scrollDimension = 'scrollWidth'; } else { scrollDirection = 'scrollTop'; dimension = 'offsetHeight'; scrollDimension = 'scrollHeight'; } if (Math.round(element[scrollDirection]) === 0) { showNear = false; } if (Math.round(element[dimension] + element[scrollDirection]) >= Math.round(element[scrollDimension])) { showFar = false; } if (!mainContainer || overflow === 'auto') { if (showNear && showFar) { scrollButtons[0].$.removeClass('lw-hidden'); scrollButtons[1].$.removeClass('lw-hidden'); element.classList.remove('one-button-shown'); return; } if (showNear) { scrollButtons[0].$.removeClass('lw-hidden'); } else { scrollButtons[0].$.addClass('lw-hidden'); } if (showFar) { scrollButtons[1].$.removeClass('lw-hidden'); } else { scrollButtons[1].$.addClass('lw-hidden'); } element.classList.add('one-button-shown'); } else if (overflow === 'scroll' && !that.disabled) { scrollButtons[0].disabled = !showNear; scrollButtons[1].disabled = !showFar; } } /** * Validates radio button selection. */ _validateRadioButtonSelection(item, level, checkedChildren) { const that = this; if (that.checkboxes) { let parentItem, parentElement; if (level === 1) { parentItem = that; parentElement = that.$.mainContainer; } else { parentItem = item; parentElement = item.itemContainer; } if (parentItem.checkMode === 'radioButton' && parentItem.checkable) { if (checkedChildren.length > 1) { for (let i = checkedChildren.length - 2; i >= 0; i--) { checkedChildren[i].set('checked', false); checkedChildren[i].removeAttribute('aria-checked'); } } else if (checkedChildren.length === 0) { const firstEnabledChild = that._getFirstEnabledChild(parentElement); if (firstEnabledChild) { firstEnabledChild.set('checked', true); firstEnabledChild.setAttribute('aria-checked', true); } } } } } /** * wheel handler. */ _wheelHandler(event) { const that = this; if (!that.enableMouseWheelAction || that.disabled || that.displayLoadingIndicator) { return; } const mainContainer = that.$.mainContainer, offsetHeight = mainContainer.offsetHeight, scrollHeight = mainContainer.scrollHeight, scrollTop = mainContainer.scrollTop, delta = event.deltaY; if (offsetHeight === scrollHeight || scrollTop === 0 && delta < 0 || scrollTop + offsetHeight === scrollHeight && delta > 0) { return; } event.preventDefault(); if (that._wheelInProgress) { return } that._dragStartDetails = { startY: event.pageY, x: event.pageX, y: event.pageY, startTime: Date.now(), target: event.target }; that._wheelInProgress = true; const swipeInfo = { pageY: event.pageY + (event.deltaY > 0 ? -1 : 1) * 50 }; that._endSwiping(swipeInfo, that._dragStartDetails.startTime + 100, true); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * List Menu custom element. */ LW('lw-list-menu', class ListMenu extends LW.Menu { // List Menu's properties. static get properties() { return { 'displayLoadingIndicator': { value: false, type: 'boolean' }, 'dropDownPosition': { value: 'auto', allowedValues: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'auto'], type: 'string' }, 'filterable': { value: false, type: 'boolean' }, 'filterInputPlaceholder': { value: '', type: 'string' }, 'filterMode': { value: 'containsIgnoreCase', allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'], type: 'string' }, 'grouped': { value: false, type: 'boolean' }, 'loadingIndicatorPlaceholder': { value: 'Loading...', type: 'string' }, 'loadingIndicatorPosition': { value: 'center', allowedValues: ['bottom', 'center', 'top'], type: 'string' } }; } /** * List Menu's event listeners. */ static get listeners() { return { 'resize': '_resizeHandler', 'backButton.click': '_backButtonClickHandler', 'filterInput.keyup': '_filterInputKeyupHandler', 'mainContainer.down': '_mainContainerDownHandler', 'mainContainer.move': '_mainContainerMoveHandler', 'mainContainer.swipeleft': '_mainContainerSwipeHandler', 'mainContainer.swiperight': '_mainContainerSwipeHandler', 'mainContainer.touchmove': '_mainContainerTouchmoveHandler', 'mainContainer.touchstart': '_mainContainerTouchstartHandler', 'view.click': '_viewHandler', 'view.mouseout': '_viewHandler', 'view.mouseover': '_viewHandler', 'view.transitionend': '_viewHandler', 'view.wheel': '_wheelHandler' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.listmenu.css' ] } /** * List Menu's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="hamburgerIcon" class="lw-hamburger-icon lw-hidden" role="button" aria-label="Toggle minimized menu" aria-haspopup="true"> <div id="hamburgerIconLineTop" class="lw-hamburger-icon-line lw-hamburger-icon-line-top" role="presentation"></div> <div id="hamburgerIconLineCenter" class="lw-hamburger-icon-line lw-hamburger-icon-line-center" role="presentation"></div> <div id="hamburgerIconLineBottom" class="lw-hamburger-icon-line lw-hamburger-icon-line-bottom" role="presentation"></div> <div id="customIconContainer" class="lw-hamburger-icon-custom-container lw-hidden" role="presentation"></div> </div> <div id="view" class="lw-list-menu-view" role="presentation"> <div id="header" class="lw-header lw-hidden" role="heading" aria-level="1"> <lw-button id="backButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable right-to-left="[[rightToLeft]]" aria-label="Back"> <div id="backButtonArrow" class="lw-arrow ${this.rightToLeft ? 'lw-arrow-right' : 'lw-arrow-left'}" aria-hidden="true"></div> </lw-button> <div id="title" class="lw-title"></div> </div> <div class="lw-list-menu-filter-input-container lw-hidden" id="filterInputContainer" role="presentation"><input id="filterInput" class="lw-filter-input" disabled="[[disabled]]" placeholder="[[filterInputPlaceholder]]" type="text" role="searchbox" aria-label="[[filterInputPlaceholder]]" /></div> <lw-repeat-button id="scrollButtonNear" class="lw-menu-scroll-button lw-spin-button lw-scroll-button-near lw-hidden" animation="[[animation]]" unfocusable aria-label="Scroll up"> <div id="arrowNear" class="lw-arrow lw-arrow-up" right-to-left="[[rightToLeft]]"></div> </lw-repeat-button> <div id="mainContainer" class="lw-menu-main-container" role="presentation"> <content></content> </div> <lw-repeat-button id="scrollButtonFar" class="lw-menu-scroll-button lw-spin-button lw-scroll-button-far lw-hidden" animation="[[animation]]" unfocusable right-to-left="[[rightToLeft]]" aria-label="Scroll down"> <div id="arrowFar" class="lw-arrow lw-arrow-down"></div> </lw-repeat-button> <div id="loadingIndicatorContainer" class="lw-loader-container lw-hidden" role="presentation"> <span id="loadingIndicator" class="lw-loader" role="img" aria-label="[[loadingIndicatorPlaceholder]]"></span> <span id="loadingIndicatorPlaceHolder" class="lw-loader-label lw-hidden">[[loadingIndicatorPlaceholder]]</span> </div> </div> </div>`; } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (that.isCompleted && that.dropDownAppendTo !== null && that._minimized) { that._dropDownParent.appendChild(that.$.view); } } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); that._close(); if (that.dropDownAppendTo !== null && that._minimized) { that._dropDownParent.removeChild(that.$.view); } } /** * Adds an item. * * @param {HTMLElement} item A lw-menu-item to add to the List Menu. * @param {HTMLElement/String} parent Optional The lw-menu-items-group (or its id or numeric path) to add the item to. */ addItem(item, parent) { const that = this; if (!(item instanceof LW.MenuItem || item instanceof LW.MenuItemsGroup)) { return; } let parentView, level, container, appliedFilter; if (parent === undefined) { parent = that.$.mainContainer; parentView = undefined; level = 1; container = parent; appliedFilter = that._topLevelFilter; } else { if (typeof parent === 'string') { parent = that.getItem(parent); } if (parent === undefined || !(parent instanceof LW.MenuItemsGroup && (that.contains(parent) || parent.closest('.lw-list-menu-view') === that.$.view))) { return; } parentView = parent; level = parent.level + 1; container = parent.itemContainer; appliedFilter = parent.filter; } that._createItemHTMLStructure(item, level, parent, that._getCurrentViewItems(parentView).length, 0); if (item instanceof LW.MenuItemsGroup) { that._processHTML(item, level + 1); } if (that._view !== parent && !parent.$.hasClass('lw-hidden') && parent.offsetHeight > 0 && parent.offsetWidth > 0 && (!that._view && !that.$.mainContainer.contains(parent) || that._view && !that._view.contains(parent))) { item.$.addClass('lw-hidden'); } if (that.grouped) { const children = Array.from(container.children); for (let i = children.length - 1; i >= 0; i--) { if (children[i].$.hasClass('lw-list-menu-group-label')) { container.removeChild(children[i]); } } that._unsortItems(parent, true); } container.appendChild(item); if (that.grouped) { const view = that._view; that._applyGrouping(parent, true); that._home(); if (view) { that.changePage(view.path); } } if (that.filterable && appliedFilter !== undefined && appliedFilter !== '' && that._findItem(item, appliedFilter) === null) { item.$.addClass('lw-hidden'); item.hidden = true; } that._toggleFilterInputGroupLabelVisibility(); that._checkOverflow(); } /** * Navigates to the previous page (lw-menu-items-group). * * @param {Boolean} animation Optional If set to false, disables collapse animation even if animation is enabled for the element. */ back(animation) { const that = this, animationType = that.animation, restoreAnimation = animation === false && animationType !== 'none'; if (restoreAnimation) { that.animation = 'none'; } that._backButtonClickHandler(); if (restoreAnimation) { that.animation = animationType; } } /** * Navigates to a particular page (lw-menu-items-group). * * @param {String} id The id or numeric path of a page (lw-menu-items-group). */ changePage(id) { const that = this, item = that.getItem(id); if (item === undefined || item instanceof LW.MenuItem || item.hidden) { return; } const stack = [item]; let stackItem = item.parentItem, start = 0; that._discardKeyboardHover(); while (stackItem) { stack.unshift(stackItem); stackItem = stackItem.parentItem; } if (that._view) { const index = stack.indexOf(that._view); if (index === -1) { that._home(); } else { start = index + 1; } } for (let i = start; i < stack.length; i++) { if (stack[i].disabled || stack[i].hidden) { break; } that._menuItemsGroupSelectionHandler(stack[i], { type: 'expand' }, true); } } /** * Maximizes the List Menu. */ maximize() { const that = this; if (!that._minimized) { return; } that._positionDetection.removeOverlay(); that._minimized = false; if (that._minimizedDropDownOpened) { that.$hamburgerIcon.removeClass('lw-close-button'); that._minimizedDropDownOpened = false; } if (that.dropDownAppendTo !== null) { that._appendMinimizedContainerToMenu(that.$.view, null); } that.$view.removeClass('lw-visibility-hidden'); that.$view.removeClass('lw-list-menu-view-minimized'); that.$hamburgerIcon.addClass('lw-hidden'); that.removeAttribute('minimized'); if (that.enableShadowDOM) { that.$.view.id = that.$.view.getAttribute('lw-id'); const templateElements = that.$.view.querySelectorAll('[lw-id]'); for (let i = 0; i < templateElements.length; i++) { templateElements[i].id = templateElements[i].getAttribute('lw-id'); } } that.$.mainContainer.scrollTop = 0; that._checkOverflow(); that.$.hamburgerIcon.removeAttribute('aria-expanded'); that.$.hamburgerIcon.removeAttribute('aria-owns'); that.$.view.setAttribute('role', 'presentation'); that.$.view.removeAttribute('aria-orientation'); that.setAttribute('role', 'menu'); } /** * Minimizes the List Menu. */ minimize() { const that = this; if (that._minimized) { return; } that.$view.addClass('lw-visibility-hidden'); if (that.enableShadowDOM) { that.$.view.removeAttribute('id'); const templateElements = that.$.view.querySelectorAll('[lw-id]'); for (let i = 0; i < templateElements.length; i++) { templateElements[i].removeAttribute('id'); } } if (that._edgeMacFF) { that.$view.addClass('not-in-view'); } that.$hamburgerIcon.removeClass('lw-hidden'); setTimeout(function () { if (that.dropDownAppendTo !== null) { that._appendMinimizedContainerToExternalElement(that.$.view); } that.$view.addClass('lw-list-menu-view-minimized'); that.$.mainContainer.scrollTop = 0; that._checkOverflow(); }, 0); that._minimized = true; that.setAttribute('minimized', ''); that.setAttribute('role', 'presentation'); that.removeAttribute('aria-orientation'); that.$.hamburgerIcon.setAttribute('aria-expanded', false); that.$.hamburgerIcon.setAttribute('aria-owns', that.$.view.id); that.$.view.setAttribute('role', 'menu'); that.$.view.setAttribute('aria-orientation', 'vertical'); } /** * Removes an item. * * @param {HTMLElement/String} item The lw-menu-item/lw-menu-items-group (or its id or numeric path) to remove. */ removeItem(item) { const that = this; if (typeof item === 'string') { item = that.getItem(item); } if (item === undefined || !(item instanceof LW.MenuItem || item instanceof LW.MenuItemsGroup) || !(that.contains(item) || item.closest('.lw-list-menu-view') === that.$.view)) { return; } const itemParent = item.parentElement; while (item.contains(that._view)) { that._backButtonClickHandler(undefined, true); } const view = that._view; if (that.grouped) { that._home(); that._discardGrouping(); } itemParent.removeChild(item); that._menuItems = {}; that._refreshItemPaths(that.$.mainContainer, true, function (item) { return that._getCurrentViewItems(item === that.$.mainContainer ? undefined : item); }); if (that.grouped) { that._applyGrouping(that.$.mainContainer); if (view) { that.changePage(view.path); } } that._toggleFilterInputGroupLabelVisibility(); that._checkOverflow(); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { if (propertyName === 'disabled' || propertyName === 'dropDownOverlay' || propertyName === 'minimizeIconTemplate' || propertyName === 'minimizeWidth' || propertyName === 'overflow' || propertyName === 'unfocusable') { super.propertyChangedHandler(propertyName, oldValue, newValue); return; } const that = this; switch (propertyName) { case 'animation': that.$.view.setAttribute('animation', newValue); break; case 'checkable': case 'checkboxes': if (that._minimized && that.dropDownAppendTo !== null) { if (newValue) { that.$.view.setAttribute(propertyName, ''); } else { that.$.view.removeAttribute(propertyName); } } break; case 'checkMode': that._changeToRadioButtonMode(newValue, that.$.mainContainer); if (that._minimized && that.dropDownAppendTo !== null) { that.$.view.setAttribute('check-mode', newValue); } break; case 'dataSource': that.$header.addClass('lw-hidden'); that.$mainContainer.removeClass('header-shown'); that._view = undefined; that._menuItems = {}; that._topLevelFilter = ''; that._processDataSource(); that._toggleFilterInputGroupLabelVisibility(); that._checkOverflow(); break; case 'displayLoadingIndicator': if (newValue) { const hoveredItem = that.$.mainContainer.querySelector('[hover]'); if (hoveredItem) { hoveredItem.removeAttribute('hover'); } that._discardKeyboardHover(); that.$loadingIndicatorContainer.removeClass('lw-hidden'); } else { that.$loadingIndicatorContainer.addClass('lw-hidden'); } break; case 'dropDownAppendTo': { const oldDropDownParent = that._dropDownParent; that._positionDetection.getDropDownParent(); if (that._dropDownParent === oldDropDownParent || !that._minimized) { return; } that._close(); if (newValue === null) { that._appendMinimizedContainerToMenu(that.$.view, null); } else { that._appendMinimizedContainerToExternalElement(that.$.view); } that.$.mainContainer.scrollTop = 0; that._checkOverflow(); break; } case 'dropDownPosition': { that._close(); if (that._minimized && that.dropDownAppendTo !== null) { that.$.view.setAttribute('drop-down-position', newValue); } break; } case 'filterable': that._toggleFilterInputGroupLabelVisibility(true); if (newValue === false) { if (that._topLevelFilter !== '') { that._applyFilter(''); } for (let i = that._filteredLowerLevelGroups.length - 1; i >= 0; i--) { that._applyFilter('', that._filteredLowerLevelGroups[i]); } } that._checkOverflow(); break; case 'filterMode': if (!that.filterable) { return; } if (that._topLevelFilter !== '') { that._applyFilter(that._topLevelFilter); } for (let i = that._filteredLowerLevelGroups.length - 1; i >= 0; i--) { that._applyFilter(that._filteredLowerLevelGroups[i].filter, that._filteredLowerLevelGroups[i]); } break; case 'grouped': that._home(); if (newValue) { that._applyGrouping(that.$.mainContainer); } else { that._discardGrouping(); } that._toggleFilterInputGroupLabelVisibility(false, true); that._checkOverflow(); break; case 'loadingIndicatorPosition': if (that.dropDownAppendTo !== null && that._minimized) { that.$.view.setAttribute('loading-indicator-position', newValue); } if (newValue === 'center') { that.$loadingIndicatorPlaceHolder.addClass('lw-hidden'); } else { that.$loadingIndicatorPlaceHolder.removeClass('lw-hidden'); } break; case 'rightToLeft': if (newValue) { that.$backButtonArrow.removeClass('lw-arrow-left'); that.$backButtonArrow.addClass('lw-arrow-right'); } else { that.$backButtonArrow.removeClass('lw-arrow-right'); that.$backButtonArrow.addClass('lw-arrow-left'); } newValue ? that.$.view.setAttribute('right-to-left', '') : that.$.view.removeAttribute('right-to-left'); Array.prototype.forEach.call(that.$.mainContainer.querySelectorAll('.lw-menu-items-group-arrow'), arrow => arrow.className = 'lw-menu-items-group-arrow ' + (that.rightToLeft ? 'lw-arrow-left left' : 'lw-arrow-right right')); break; case 'theme': super.propertyChangedHandler(propertyName, oldValue, newValue); if (that.dropDownAppendTo !== null && that._minimized) { if (oldValue !== '') { that.$view.removeClass(oldValue); } if (newValue) { that.$view.addClass(newValue); } } break; } } /** * Appends group headers. */ _appendGroupLabels(groups, groupChildren) { for (let i = 0; i < groups.length; i++) { const groupLabel = document.createElement('div'); groupLabel.$ = LW.Utilities.Extend(groupLabel); groupLabel.className = 'lw-list-menu-group-label'; groupLabel.setAttribute('role', 'heading'); groupLabel.setAttribute('aria-level', 1); groupLabel.innerHTML = groups[i]; groupLabel.groupChildren = groupChildren[i]; groupChildren[i][0].parentElement.insertBefore(groupLabel, groupChildren[i][0]); for (let j = 0; j < groupChildren[i].length; j++) { groupChildren[i][j].groupLabel = groupLabel; } } } /** * Applies filter. */ _applyFilter(filterQuery, view) { const that = this, items = that._getCurrentViewItems(view); for (let i = 0; i < items.length; i++) { const item = that._findItem(items[i], filterQuery); if (item && item.hidden) { item.hidden = false; if (view === that._view || (that._view !== undefined && view !== undefined && !view.contains(that._view)) || that._view === undefined) { item.$.removeClass('lw-hidden'); } } else if (!item) { items[i].hidden = true; items[i].$.addClass('lw-hidden'); } } if (view) { view.filter = filterQuery; const index = that._filteredLowerLevelGroups.indexOf(view); if (filterQuery === '') { if (index !== -1) { that._filteredLowerLevelGroups.splice(index, 1); } } else if (index === -1) { that._filteredLowerLevelGroups.push(view); } } else { that._topLevelFilter = filterQuery; } } /** * Back button click handler. */ _backButtonClickHandler(event, noAnimation) { const that = this, view = that._view; if (event) { event.stopPropagation(); } if (!view || that.disabled && event || that.displayLoadingIndicator || that._inTransition) { return; } let animation = that.hasAnimation, animationType = that.animation, resetAnimation = false; if (animation && noAnimation) { animation = false; resetAnimation = true; that.animation = 'none'; } that._discardKeyboardHover(); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); that.$mainContainer.removeClass('scroll-buttons-shown'); view.firstElementChild.classList.remove('lw-hidden'); if (!animation) { view.$.removeClass('lw-menu-items-group-opened'); view.container.$.addClass('lw-hidden'); } else { that._inTransition = true; view.container.$.addClass('no-transition'); view.container.$.addClass('lw-hidden'); view.$.addClass('right'); view.$.removeClass('right'); view.container.$.removeClass('no-transition'); } that._showHideMenuItemsGroupSiblings(view, 'removeClass', animation); if (animation) { setTimeout(function () { view.container.style.top = view.parentElement.getBoundingClientRect().top - view.getBoundingClientRect().top + 'px'; }, 0); } else if (resetAnimation) { that.animation = animationType; } if (view.level === 1) { that.$header.addClass('lw-hidden'); that.$mainContainer.removeClass('header-shown'); that._view = undefined; } else { that.$.title.innerHTML = view.parentItem.titleLabel; that._view = view.parentItem; } that._toggleFilterInputGroupLabelVisibility(); that.$.mainContainer.scrollTop = 0; if (!animation) { that._checkOverflow(); } if (event) { that.focus(); } } /** * Applies bottom bounce effect. */ _bounceBottom(initialScrollTop) { const that = this, mainContainer = that.$.mainContainer; that.$mainContainer.addClass('bounce-bottom'); function bounceBack() { mainContainer.scrollTop -= 5; if (mainContainer.scrollTop > initialScrollTop) { window.requestAnimationFrame(bounceBack); } else { that.$mainContainer.removeClass('bounce-bottom'); } } function bounceForth() { mainContainer.scrollTop += 5; if (mainContainer.scrollTop !== mainContainer.scrollHeight - mainContainer.offsetHeight) { window.requestAnimationFrame(bounceForth); } else { window.requestAnimationFrame(bounceBack); } } window.requestAnimationFrame(bounceForth); } /** * Applies top bounce effect. */ _bounceTop() { const that = this, mainContainer = that.$.mainContainer; that.$mainContainer.addClass('bounce-top'); function bounceBack() { mainContainer.scrollTop -= 5; if (mainContainer.scrollTop > 0) { window.requestAnimationFrame(bounceBack); } else { window.requestAnimationFrame(bounceForth); } } function bounceForth() { mainContainer.scrollTop += 5; if (mainContainer.scrollTop !== 50) { window.requestAnimationFrame(bounceForth); } else { mainContainer.scrollTop = 0; that.$mainContainer.removeClass('bounce-top'); } } window.requestAnimationFrame(bounceBack); } /** * Checks if items overflow and shows/hides scroll buttons. */ _checkOverflow() { const that = this, overflow = that.overflow; if (overflow === 'hidden') { return; } const overflowing = Math.round(that.$.mainContainer.scrollHeight) > Math.round(that.$.mainContainer.offsetHeight), showNear = Math.round(that.$.mainContainer.scrollTop) > 0, showFar = Math.round(that.$.mainContainer.offsetHeight + that.$.mainContainer.scrollTop) < Math.round(that.$.mainContainer.scrollHeight); if (overflowing) { if (overflow === 'auto') { if (!that.$mainContainer.hasClass('scroll-buttons-shown')) { that.$mainContainer.addClass('scroll-buttons-shown'); } if (showNear) { that.$scrollButtonNear.removeClass('lw-hidden'); } else { that.$scrollButtonNear.addClass('lw-hidden'); } if (showFar) { that.$scrollButtonFar.removeClass('lw-hidden'); } else { that.$scrollButtonFar.addClass('lw-hidden'); } if ((showNear && showFar) === false) { that.$mainContainer.addClass('one-button-shown'); } else { that.$mainContainer.removeClass('one-button-shown'); } if (!that.disabled) { that.$.scrollButtonNear.disabled = false; that.$.scrollButtonFar.disabled = false; } } else { that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); if (that.disabled) { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } else { that.$.scrollButtonNear.disabled = !showNear; that.$.scrollButtonFar.disabled = !showFar; } } } else if (!overflowing && overflow === 'auto' && that.$mainContainer.hasClass('scroll-buttons-shown')) { that.$mainContainer.removeClass('scroll-buttons-shown'); that.$mainContainer.removeClass('one-button-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); } else if (!overflowing && overflow === 'scroll') { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } } /** * Closes any open pop-up containers. */ _close() { const that = this; that._discardKeyboardHover(true); if (that._minimized && that._minimizedDropDownOpened) { that._positionDetection.removeOverlay(); that.$view.addClass('lw-visibility-hidden'); if (that._edgeMacFF) { that.$.view.style.left = ''; that.$.view.style.top = ''; that.$view.addClass('not-in-view'); } that.$hamburgerIcon.removeClass('lw-close-button'); that._minimizedDropDownOpened = false; that.$.hamburgerIcon.setAttribute('aria-expanded', false); } } /** * Applies initial settings to the List Menu element. */ _createElement() { const that = this; if (!that.$.title.id) { that.$.title.id = that.id + 'Title'; } if (!that.$.view.id) { that.$.view.id = that.id + 'View'; } that.setAttribute('role', 'menu'); that.setAttribute('aria-labelledby', that.$.title.id); that.setAttribute('aria-orientation', 'vertical'); that.$.header.setAttribute('aria-labelledby', that.$.title.id); that.mode = 'vertical'; that._positionDetection = new LW.Utilities.PositionDetection(that); that._positionDetection.getDropDownParent(); if (that.dataSource === null && that.$.mainContainer.firstElementChild instanceof HTMLUListElement) { that._processUList(); } const items = that.getElementsByTagName('lw-menu-item'), itemsReady = function () { that._setFocusable(); that._menuItems = {}; that._topLevelFilter = ''; that._filteredLowerLevelGroups = []; that.$.view.setAttribute('animation', that.animation); if (that.dataSource === null) { that._processHTML(undefined, 1); } else { that._processDataSource(); } that._toggleFilterInputGroupLabelVisibility(); if (that.overflow === 'scroll') { that.$mainContainer.addClass('scroll-buttons-shown'); that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); that._updateScrollButtonVisibility(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); } that._applyMinimizeIconTemplate(that.minimizeIconTemplate, null); if (that.minimizeWidth !== null && that.offsetWidth <= that.minimizeWidth) { that.minimize(); } else { that._checkOverflow(); } if (that.displayLoadingIndicator) { that.$loadingIndicatorContainer.removeClass('lw-hidden'); } if (that.loadingIndicatorPosition !== 'center') { that.$loadingIndicatorPlaceHolder.removeClass('lw-hidden'); } if (that.__onCompleted) { that._onCompleted = that.__onCompleted; that.__onCompleted = null; that._onCompleted(); } } if (items.length === 0) { itemsReady(); } else { if (that._onCompleted) { that.__onCompleted = that._onCompleted; that._onCompleted = null; } that._ensureItemsReady(items, itemsReady); } } /** * Creates the pop-up container of lw-menu-items-group. */ _createMenuItemsGroupContainer(item, level) { const container = document.createElement('div'), itemContainer = document.createElement('div'); container.className = 'lw-menu-drop-down lw-hidden'; container.$ = LW.Utilities.Extend(container); container.level = level; container.setAttribute('level', level); container.setAttribute('role', 'menu'); container.menuItemsGroup = item; itemContainer.className = 'lw-menu-item-container'; itemContainer.$ = LW.Utilities.Extend(itemContainer); itemContainer.container = container; itemContainer.menuItemsGroup = item; if (item.checkable) { itemContainer.setAttribute('checkable', ''); } itemContainer.setAttribute('check-mode', item.checkMode); container.itemContainer = itemContainer; container.appendChild(itemContainer); return container; } /** * Removes grouping. */ _discardGrouping() { const that = this, groupLabels = Array.from(that.$.view.getElementsByClassName('lw-list-menu-group-label')); for (let i = 0; i < groupLabels.length; i++) { let currentGroupLabel = groupLabels[i]; currentGroupLabel.parentElement.removeChild(currentGroupLabel); } that._unsortItems(that.$.mainContainer); } /** * Removes "hover" attribute added by keyboard navigation. */ _discardKeyboardHover() { const that = this; if (!that._focusedViaKeyboard) { return; } if (that._focusedViaKeyboard === that.$.backButton) { that.$.backButton.removeAttribute('hover'); that.$.backButton.$.button.removeAttribute('hover'); } else { that._focusedViaKeyboard.removeAttribute('focus'); that._focusedViaKeyboard.removeAttribute('hover'); } that._focusedViaKeyboard = undefined; } /** * Document up handler. */ _documentUpHandler(event) { const that = this, target = event.originalEvent.target, swipeAction = (direction) => { if ((direction === 'right' && !that.rightToLeft) || (direction === 'left' && that.rightToLeft)) { that._backButtonClickHandler(); } else if (that._swipeDetails.target) { that._selectionHandler({ target: that._swipeDetails.target }, that._swipeDetails.target, true); } }; if (that._touchmoveInside) { that._endSwiping(event, Date.now()); } else { delete that._dragStartDetails; } delete that._touchCoords; delete that._touchmoveInside; if (that._swipeDetails) { const pointercancel = event.originalEvent.type === 'pointercancel'; if (that._swipeDetails.direction === 'left') { if (pointercancel || that._swipeDetails.start > event.pageX && that._swipeDetails.start - event.pageX > that.offsetWidth / 4) { swipeAction(that._swipeDetails.direction); } } else { if (pointercancel || that._swipeDetails.start < event.pageX && event.pageX - that._swipeDetails.start > that.offsetWidth / 4) { swipeAction(that._swipeDetails.direction); } } delete that._swipeDetails; return; } if (target === that.$.filterInput || that.disabled || that.displayLoadingIndicator || !target.closest) { return; } if (!that.contains(target) && target.closest('.lw-list-menu-view') !== that.$.view) { that._close(); if (that._scrolling) { delete that._scrolling; } } else if ((that.contains(target) || target.closest('.lw-list-menu-view') === that.$.view) && that !== document.activeElement) { that.focus(); } } /** * Makes sure a lw-menu-item/lw-menu-items-group is visible by scrolling to it. */ _ensureVisible(scrollTarget) { const that = this, parent = that.$.mainContainer; if (!parent.$.hasClass('scroll-buttons-shown') && that.overflow !== 'hidden') { return; } const parentBoundingRect = parent.getBoundingClientRect(), scrollTargetBoundingRect = scrollTarget.getBoundingClientRect(), scrollButtons = [that.$.scrollButtonNear, that.$.scrollButtonFar], oldScrollTop = parent.scrollTop; if (parentBoundingRect.top > scrollTargetBoundingRect.top || parentBoundingRect.bottom < scrollTargetBoundingRect.bottom) { parent.scrollTop = scrollTarget.offsetTop; that._updateScrollButtonVisibility(parent, false, scrollButtons); } that._fireScrollBottomReachedEvent(oldScrollTop); } /** * Fires the "scrollBottomReached" event. */ _fireScrollBottomReachedEvent(oldScrollTop) { const that = this, mainContainer = that.$.mainContainer, currentScrollTop = mainContainer.scrollTop; if (oldScrollTop === currentScrollTop || currentScrollTop !== mainContainer.scrollHeight - mainContainer.offsetHeight) { return; } that.$.fireEvent('scrollBottomReached'); } /** * Gets all lw-menu-item and lw-menu-items-group elements in current view. */ _getCurrentViewItems(view) { const that = this; if (!that.grouped) { if (view === undefined) { return that.$.mainContainer.children; } else { return view.container.firstElementChild.children; } } else { if (view === undefined) { return that.$.view.querySelectorAll('.lw-menu-main-container > lw-menu-item, .lw-menu-main-container > lw-menu-items-group'); } else { const allChildren = view.container.firstElementChild.children, items = []; for (let i = 0; i < allChildren.length; i++) { let currentItem = allChildren[i]; if (currentItem instanceof LW.MenuItem || currentItem instanceof LW.MenuItemsGroup) { items.push(currentItem); } } return items; } } } /** * Sorts and groups items. */ _sortItems(item) { const that = this; if (!that.grouped) { return; } const groups = [], groupChildren = []; let parent; if (item instanceof LW.MenuItemsGroup) { parent = item.container.firstElementChild; } else if (item === that.$.mainContainer) { parent = item; } const children = Array.from(parent.children); children.sort(function (a, b) { return (a.label).localeCompare(b.label); }); // sort items in DOM for (let i = children.length - 1; i >= 0; i--) { parent.insertBefore(children[i], parent.firstElementChild); } // retrieve groups and first elements in groups for (let i = 0; i < children.length; i++) { const currentChild = children[i], firstCharacter = currentChild.label.charAt(0), index = groups.indexOf(firstCharacter.toUpperCase()); if (index === -1) { groups.push(firstCharacter.toUpperCase()); groupChildren.push([currentChild]); } else { groupChildren[index].push(currentChild); } } that._appendGroupLabels(groups, groupChildren); } /** * Displays top-level view. */ _home() { const that = this; while (that._view) { that._backButtonClickHandler(undefined, true); } } /** * Keydown event handler. */ _keydownHandler(event) { const that = this, key = event.key, activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement; if (activeElement !== that || ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Enter', 'Escape', 'Home', ' '].indexOf(key) === -1 || that.disabled || that.displayLoadingIndicator) { return; } event.preventDefault(); const view = that._view, lastOpenedContainer = view ? view.itemContainer : that.$.mainContainer, hoveredItem = that.$.backButton.hasAttribute('hover') ? that.$.backButton : lastOpenedContainer.querySelector('[focus]'); switch (key) { case 'ArrowDown': that._navigate('_getNextEnabledChild', hoveredItem, lastOpenedContainer); break; case 'ArrowLeft': case 'ArrowRight': if ((key === 'ArrowLeft' && !that.rightToLeft) || (key === 'ArrowRight' && that.rightToLeft)) { that._backButtonClickHandler(); break; } if ((key === 'ArrowRight' && !that.rightToLeft) || (key === 'ArrowLeft' && that.rightToLeft)) { if (hoveredItem && hoveredItem instanceof LW.MenuItemsGroup) { that._menuItemsGroupSelectionHandler(hoveredItem, { type: 'keydown' }); } } break; case 'ArrowUp': that._navigate('_getPreviousEnabledChild', hoveredItem, lastOpenedContainer); break; case 'End': case 'Home': { if (view && key === 'Home') { that.$.mainContainer.scrollTop = 0; that._checkOverflow(); that.$.backButton.setAttribute('hover', ''); that.$.backButton.$.button.setAttribute('hover', ''); that._focusedViaKeyboard = that.$.backButton; if (hoveredItem) { hoveredItem.removeAttribute('focus'); } return; } const enabledChild = key === 'End' ? that._getLastEnabledChild(lastOpenedContainer) : that._getFirstEnabledChild(lastOpenedContainer); if (!enabledChild || hoveredItem === enabledChild) { return; } if (hoveredItem) { if (hoveredItem === that.$.backButton) { that.$.backButton.removeAttribute('hover'); that.$.backButton.$.button.removeAttribute('hover'); } else { hoveredItem.removeAttribute('focus'); } } that._hoverViaKeyboard(enabledChild); break; } case 'Enter': if (that._minimized && !that._minimizedDropDownOpened) { that._hamburgerIconClickHandler(undefined, that.$.view); } else if (hoveredItem) { if (hoveredItem === that.$.backButton) { that._backButtonClickHandler(); } else { that._selectionHandler({ target: hoveredItem }); } } break; case 'Escape': if (that._minimized && that._minimizedDropDownOpened && !that._view) { that._close(); } else { that._backButtonClickHandler(); } break; case ' ': if (hoveredItem) { if (hoveredItem === that.$.backButton) { that._backButtonClickHandler(); } else { that._toggleItem(hoveredItem); } } break; } } /** * mainContainer down handler. */ _mainContainerDownHandler(event) { const that = this; if (!LW.Utilities.Core.isMobile || that.disabled || that.displayLoadingIndicator) { return; } that._dragStartDetails = { startY: event.pageY, x: event.pageX, y: event.pageY, startTime: Date.now(), target: event.originalEvent.target }; } /** * mainContainer handler. */ _mainContainerHandler() { return; } /** * mainContainer move handler. */ _mainContainerMoveHandler(event) { const that = this; if (!that._dragStartDetails) { return; } const pageY = event.pageY, difference = that._dragStartDetails.y - pageY, oldScrollTop = that.$.mainContainer.scrollTop; that.$.mainContainer.scrollTop += difference; if (oldScrollTop !== that.$.mainContainer.scrollTop) { that._checkOverflow(); that._fireScrollBottomReachedEvent(oldScrollTop); } that._dragStartDetails = { startY: that._dragStartDetails.startY, x: event.pageX, y: pageY, startTime: that._dragStartDetails.startTime, target: event.originalEvent.target }; that._scrolling = true; } /** * mainContainer swipeleft/swiperight handler. */ _mainContainerSwipeHandler(event) { const that = this; if (!LW.Utilities.Core.isMobile || that.disabled || that.displayLoadingIndicator || Math.abs(that._dragStartDetails.startY - event.pageY) > 2) { return; } const target = event.originalEvent.target, closestItem = target.closest('lw-menu-item'), closestGroup = target.closest('lw-menu-items-group'); if ((event.type === 'swiperight' && !that.rightToLeft) || (event.type === 'swipeleft' && that.rightToLeft)) { const target = closestItem || closestGroup; if (target) { delete that._dragStartDetails; delete that._scrolling; that._swipeDetails = { direction: event.type.replace('swipe', ''), start: event.pageX, target: target }; } } else if ((event.type === 'swipeleft' && !that.rightToLeft) || (event.type === 'swiperight' && that.rightToLeft) && closestGroup && closestItem === null) { delete that._dragStartDetails; delete that._scrolling; that._swipeDetails = { direction: event.type.replace('swipe', ''), start: event.pageX, target: closestGroup }; } } /** * mainContainer touchmove handler. */ _mainContainerTouchmoveHandler(event) { const that = this; if (that._touchmoveInside && event.cancelable) { event.preventDefault(); event.stopPropagation(); return; } const mainContainer = that.$.mainContainer, size = mainContainer.offsetHeight, scrollSize = mainContainer.scrollHeight, coords = that._touchCoords; if (size === scrollSize || !coords) { return; } const touches = event.touches[0], scrolled = mainContainer.scrollTop, coord = touches.pageY, previousCoord = coords[1]; const normalizedCoord = parseFloat(coord.toFixed(5)), normalizedPreviousCoord = parseFloat(previousCoord.toFixed(5)); that._touchCoords = [touches.pageX, touches.pageY]; if (scrolled === 0 && normalizedCoord >= normalizedPreviousCoord || // pan up scrolled + size >= scrollSize && normalizedCoord <= normalizedPreviousCoord) { // pan down return; } if (coord !== previousCoord) { that._touchmoveInside = true; } if (event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * mainContainer touchstart handler. */ _mainContainerTouchstartHandler(event) { const touches = event.touches[0]; this._touchCoords = [touches.pageX, touches.pageY]; } /** * Returns the root's activeElement and isInside flag indicating whether the target is inside the element or not. * @param {any} target - target */ _getRootDetails(rootNode, event) { const that = this; if (!rootNode) { return; } if (!that.enableShadowDOM) { return { activeElement: rootNode.activeElement, isInsideElement: that.contains(event.target) }; } let activeElement, isInsideElement; while (rootNode) { if (!activeElement && rootNode.activeElement) { activeElement = rootNode.activeElement; } if (rootNode.host === that) { isInsideElement = true; } if (rootNode === document) { break; } rootNode = rootNode.host ? rootNode.host.getRootNode() : rootNode.getRootNode(); } return { activeElement: activeElement, isInsideElement: isInsideElement }; } /** * lw-menu-items-group selection handler. */ _menuItemsGroupSelectionHandler(closestItemsGroup, event, noAnimation) { const that = this, container = closestItemsGroup.container, level = container.level, rootDetails = that._getRootDetails(event.target ? event.target.getRootNode() : null, event); if (that._view === closestItemsGroup) { return; } that._discardKeyboardHover(); if (rootDetails && rootDetails.activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !rootDetails.isInsideElement) { that.focus(); } if (that._inTransition) { return; } if (event.type === 'click' && !event.target.classList.contains('lw-menu-items-group-arrow') && that._toggleItem(closestItemsGroup)) { that._ripple(closestItemsGroup, event); return; } let animation = that.hasAnimation, animationType = that.animation, resetAnimation = false; if (animation && noAnimation) { animation = false; resetAnimation = true; that.animation = 'none'; } if (level === 2) { that.$header.removeClass('lw-hidden'); that.$mainContainer.addClass('header-shown'); } that.$.title.innerHTML = closestItemsGroup.titleLabel; that._view = closestItemsGroup; that._toggleFilterInputGroupLabelVisibility(); closestItemsGroup.removeAttribute('hover'); closestItemsGroup.removeAttribute('focus'); closestItemsGroup.$.addClass('lw-menu-items-group-opened'); that._showHideMenuItemsGroupSiblings(closestItemsGroup, 'addClass', animation); if (!animation) { closestItemsGroup.firstElementChild.classList.add('lw-hidden'); } else { that._inTransition = true; closestItemsGroup.firstElementChild.classList.add('animate'); setTimeout(function () { container.style.top = closestItemsGroup.parentElement.getBoundingClientRect().top - closestItemsGroup.getBoundingClientRect().top + 'px'; }, 0); } container.$.removeClass('lw-hidden'); if (resetAnimation) { that.animation = animationType; } that.$.mainContainer.scrollTop = 0; if (!animation) { that._checkOverflow(); } that.$.fireEvent('expand', { 'item': closestItemsGroup, 'label': closestItemsGroup.label, 'path': closestItemsGroup.path, 'value': closestItemsGroup.value }); } /** * Mouseout/mouseover handler. */ _mouseoutMouseoverHandler(event) { const that = this; if (that.disabled || that.displayLoadingIndicator) { return; } const closestItem = event.target.closest('lw-menu-item') || event.target.closest('lw-menu-items-group'); if (closestItem === null || (that._view && closestItem.level <= that._view.level) || closestItem.disabled || closestItem.templateApplied) { return; } that._discardKeyboardHover(); if (event.type === 'mouseover') { closestItem.setAttribute('hover', ''); that._discardKeyboardHover(true); } else { closestItem.removeAttribute('hover'); } } /** * Navigates to an item via the keyboard. */ _navigate(method, hoveredItem, lastOpenedContainer) { const that = this; if (!hoveredItem) { if (method === '_getNextEnabledChild') { if (that._view) { that.$.backButton.setAttribute('hover', ''); that.$.backButton.$.button.setAttribute('hover', ''); that._focusedViaKeyboard = that.$.backButton; } else { that._hoverViaKeyboard(that._getFirstEnabledChild(lastOpenedContainer)); } } else { that._hoverViaKeyboard(that._getLastEnabledChild(lastOpenedContainer)); } return; } let navigateToChild; if (method === '_getNextEnabledChild' && hoveredItem === that.$.backButton) { navigateToChild = that._getFirstEnabledChild(lastOpenedContainer); if (navigateToChild) { that.$.backButton.removeAttribute('hover'); that.$.backButton.$.button.removeAttribute('hover'); } else { return; } } else if (method === '_getPreviousEnabledChild' && that._view && hoveredItem === that._getFirstEnabledChild(lastOpenedContainer)) { that.$.backButton.setAttribute('hover', ''); that.$.backButton.$.button.setAttribute('hover', ''); that._focusedViaKeyboard = that.$.backButton; hoveredItem.removeAttribute('focus'); return; } else { navigateToChild = that[method](hoveredItem); } if (navigateToChild) { hoveredItem.removeAttribute('focus'); that._hoverViaKeyboard(navigateToChild); } } /** * Processes initial HTML structure. */ _processHTML(item, level) { const that = this; let container, itemContainer; if (item === undefined) { item = that.$.mainContainer; } if (level > 1) { container = that._createMenuItemsGroupContainer(item, level); itemContainer = container.itemContainer; } const itemChildren = Array.from(item.children), checkedChildren = []; let pathOffset = 0; for (let i = 0; i < itemChildren.length; i++) { if (level > 1 && i === 0) { pathOffset++; continue; } const currentItem = itemChildren[i]; if (!(currentItem instanceof LW.MenuItem || currentItem instanceof LW.MenuItemsGroup)) { currentItem.parentElement.removeChild(currentItem); pathOffset++; continue; } that._createItemHTMLStructure(currentItem, level, item, i - pathOffset); if (currentItem.checked) { if (!currentItem.disabled && !currentItem.templateApplied) { checkedChildren.push(currentItem); } else { currentItem.checked = false; } } if (level > 1) { itemContainer.appendChild(currentItem); } if (currentItem instanceof LW.MenuItemsGroup) { that._processHTML(currentItem, level + 1); } } if (level > 1) { item.container = container; item.itemContainer = itemContainer; if (item instanceof LW.MenuItemsGroup) { const arrowElement = document.createElement('div'); arrowElement.className = 'lw-menu-items-group-arrow ' + (that.rightToLeft ? 'lw-arrow-left left' : 'lw-arrow-right right'); item.children[0].appendChild(arrowElement); } item.appendChild(container); } that._validateRadioButtonSelection(item, level, checkedChildren); that._sortItems(item); } /** * Resize handler. */ _resizeHandler() { const that = this, minimizeWidth = that.minimizeWidth; if (minimizeWidth !== null) { if (!that._minimized && that.offsetWidth <= minimizeWidth) { that.minimize(); return; } else if (that._minimized && that.offsetWidth > minimizeWidth) { that.maximize(); return; } } that._checkOverflow(); } /** * Scrolls using scroll buttons. */ _scroll(scrollButton) { const that = this, mainContainer = that.$.mainContainer, scrollCoefficient = scrollButton.classList.contains('lw-scroll-button-near') ? -1 : 1, oldScrollTop = mainContainer.scrollTop; mainContainer.scrollTop = mainContainer.scrollTop + scrollCoefficient * 10; if (oldScrollTop !== mainContainer.scrollTop) { that._updateScrollButtonVisibility(mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]); that._fireScrollBottomReachedEvent(oldScrollTop); } } /** * Selection handler. */ _selectionHandler(event, closestItemsGroup, swipe) { const that = this, target = event.target; if (that.disabled || that.displayLoadingIndicator) { return; } if (that._scrolling || that._swipeDetails && !swipe) { delete that._dragStartDetails; delete that._scrolling; delete that._swipeDetails; return; } function focus() { const rootDetails = that._getRootDetails(target.getRootNode(), event); if (rootDetails && rootDetails.activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !rootDetails.isInsideElement) { that.focus(); } } if (closestItemsGroup === undefined) { if (event.type === 'click') { const closestScrollButton = target.closest('lw-repeat-button'); if (closestScrollButton) { that._scroll(closestScrollButton, event); return; } } const closestItem = target.closest('lw-menu-item'); if (closestItem) { if (closestItem.disabled || closestItem.templateApplied) { focus(); return; } if (!that._toggleItem(closestItem)) { that.$.fireEvent('itemClick', { 'item': closestItem, 'label': closestItem.label, 'value': closestItem.value }); } that._ensureVisible(closestItem); that._ripple(closestItem, event); focus(); return; } closestItemsGroup = target.closest('lw-menu-items-group'); if (closestItemsGroup && (target === closestItemsGroup.container || target === closestItemsGroup.container.firstElementChild)) { return; } } if (closestItemsGroup && !closestItemsGroup.disabled) { that._menuItemsGroupSelectionHandler(closestItemsGroup, event); } } /** * Shows/hides the siblings of a lw-menu-items-group. */ _showHideMenuItemsGroupSiblings(menuItemsGroup, method, animation) { const parentElement = menuItemsGroup.parentElement, children = parentElement.children; for (let i = 0; i < children.length; i++) { const currentChild = children[i]; if (currentChild === menuItemsGroup) { continue; } if (!currentChild.hidden) { if (!animation) { currentChild.$[method]('lw-hidden'); } else { if (method === 'addClass') { currentChild.$.addClass('animate'); } else { currentChild.$.removeClass('lw-hidden'); currentChild.$.addClass('right'); setTimeout(function () { currentChild.$.removeClass('right'); }, 0); } } } } } /** * Toggles the visibility of the filter input. */ _toggleFilterInputGroupLabelVisibility(filterableChanged, groupedChanged) { const that = this, itemsCount = that._getCurrentViewItems(that._view).length; if (groupedChanged !== true) { const shown = !that.$filterInputContainer.hasClass('lw-hidden'); if (that.filterable && itemsCount > 1) { if (!shown) { that.$mainContainer.addClass('filter-input-shown'); that.$filterInputContainer.removeClass('lw-hidden'); } if (that._view) { that.$.filterInput.value = that._view.filter || ''; } else { that.$.filterInput.value = that._topLevelFilter; } } else if (shown) { that.$mainContainer.removeClass('filter-input-shown'); that.$filterInputContainer.addClass('lw-hidden'); } } if (!filterableChanged && that.grouped && itemsCount > 0) { const firstGroupLabel = that._view ? that._view.container.firstElementChild.firstElementChild.$ : that.$.mainContainer.firstElementChild.$; if (itemsCount === 1) { firstGroupLabel.addClass('lw-hidden'); } else { firstGroupLabel.removeClass('lw-hidden'); } } } /** * External view handler. */ _viewHandler(event) { const that = this; if (event.type === 'transitionend') { const target = event.target; if (target === that.$.view || that.$.backButton.contains(target)) { return; } if (target.classList.contains('animate')) { target.classList.remove('animate'); target.classList.add('lw-hidden'); } if (target.classList.contains('lw-menu-drop-down')) { target.style.top = ''; } if (target.classList.contains('lw-menu-items-group-opened')) { target.classList.remove('lw-menu-items-group-opened'); } that._checkOverflow(); that._inTransition = false; return; } if (!that._minimized || that.dropDownAppendTo === null) { return; } switch (event.type) { case 'click': that._selectionHandler(event); break; case 'mouseout': that._mouseoutMouseoverHandler(event); break; case 'mouseover': that._mouseoutMouseoverHandler(event); break; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Tank custom element. */ LW('lw-tank', class Tank extends LW.BaseElement { /** * Tank's properties. */ static get properties() { return { 'coerce': { value: false, type: 'boolean' }, 'customInterval': { value: false, type: 'boolean' }, 'customTicks': { reflectToAttribute: false, value: ['0', '50', '100'], type: 'array' }, 'dateLabelFormatString': { value: 'd', type: 'string' }, 'decimalSeparator': { value: '.', type: 'string' }, 'interval': { value: '1', type: 'any' }, 'inverted': { value: false, type: 'boolean' }, 'labelFormatFunction': { value: null, type: 'function?' }, 'labelsVisibility': { value: 'all', allowedValues: ['all', 'endPoints', 'none'], type: 'string' }, 'logarithmicScale': { value: false, type: 'boolean' }, 'max': { value: '100', type: 'any' }, 'mechanicalAction': { value: 'switchWhileDragging', allowedValues: ['switchUntilReleased', 'switchWhenReleased', 'switchWhileDragging'], type: 'string' }, 'messages': { value: { 'en': { 'missingReference': '{{elementType}}: Missing reference to {{files}}.', 'significantPrecisionDigits': '{{elementType}}: the properties significantDigits and precisionDigits cannot be set at the same time.', 'invalidMinOrMax': '{{elementType}}: Invalid {{property}} value. Max cannot be lower than Min.', 'noInteger': '{{elementType}}: precisionDigits could be set only on "floatingPoint" scaleType.' } }, type: 'object', extend: true }, 'min': { value: '0', type: 'any' }, 'mode': { value: 'numeric', allowedValues: ['numeric', 'date'], type: 'string' }, 'name': { value: '', type: 'string' }, 'orientation': { value: 'vertical', allowedValues: ['horizontal', 'vertical'], type: 'string' }, 'precisionDigits': { value: null, type: 'number?' }, 'scalePosition': { value: 'near', allowedValues: ['near', 'far', 'both', 'none'], type: 'string' }, 'scaleType': { value: 'floatingPoint', allowedValues: ['floatingPoint', 'integer'], type: 'string' }, 'scientificNotation': { value: false, type: 'boolean' }, 'showThumbLabel': { value: false, type: 'boolean' }, 'showTooltip': { value: false, type: 'boolean' }, 'showUnit': { value: false, type: 'boolean' }, 'significantDigits': { value: null, type: 'number?' }, 'thumbLabelPosition': { value: 'near', allowedValues: ['near', 'far'], type: 'string' }, 'ticksPosition': { value: 'scale', allowedValues: ['scale', 'track'], type: 'string' }, 'ticksVisibility': { value: 'minor', allowedValues: ['major', 'minor', 'none'], type: 'string' }, 'tooltipPosition': { value: 'near', allowedValues: ['near', 'far'], type: 'string' }, 'unit': { value: 'kg', type: 'string' }, 'validation': { value: 'strict', allowedValues: ['strict', 'interaction'], type: 'string' }, 'value': { value: '0', type: 'any' }, 'wordLength': { value: 'int32', allowedValues: ['int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'], type: 'string' } }; } /** * Tank's event listeners. */ static get listeners() { return { 'track.down': '_trackDownHandler', 'track.move': '_trackMoveHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler', 'keydown': '_keydownHandler', 'resize': '_resizeHandler', 'styleChanged': '_styleChangedHandler', 'document.selectstart': '_selectStartHandler', 'track.mouseenter': '_trackOnMouseEnterHandler', 'track.mouseleave': '_trackOnMouseLeaveHandler' }; } static get requires() { return { 'LW.Utilities.BigNumber': 'lw.math.js', 'LW.Utilities.NumericProcessor': 'lw.numeric.js', 'LW.Utilities.TickIntervalHandler': 'lw.tickintervalhandler.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.tank.css' ] } /** * Tank's HTML template. */ template() { return `<div id="container" class="lw-container" role="presentation"> <div id="scaleNear" class="lw-scale lw-scale-near" role="presentation" aria-hidden="true"></div> <div id="track" class="lw-track" role="presentation"> <div id="fill" class="lw-value" role="presentation"> <div id="bubbleContainer" class="lw-bubble-container" role="presentation"></div> <div id="tooltip" class="lw-tooltip" role="tooltip"><div id="tooltipContent" class="lw-tooltip-content lw-unselectable" role="presentation"></div></div> <div id="thumb" class="lw-thumb"> <div class="lw-thumb-label-container"> <span id="thumbLabel" class="lw-thumb-label"></span> </div> </div> </div> <div id="trackTicksContainer" class="lw-track-ticks-container lw-hidden" role="presentation"></div> </div> <div id="scaleFar" class="lw-scale lw-scale-far" role="presentation" aria-hidden="true"></div> <input id="hiddenInput" type="hidden" name="[[name]]"> </div>`; } /** * Invoked when an instance of custom element is attached to the DOM for the first time. */ ready() { super.ready(); const that = this; that._redefineProperty('customTicks'); that.checkLicense(); } render() { const that = this; that.setAttribute('role', 'slider'); this._createElement(); if (that.enableShadowDOM && that.$.hiddenInput) { that.appendChild(that.$.hiddenInput); } super.render(); } _createElement() { const that = this; if (!that.$.tooltip.id) { that.$.tooltip.id = that.id + 'Tooltip'; } that.setAttribute('aria-describedby', that.$.tooltip.id); //Escape the initial transiton that.$.fill.style.transition = 'none'; if (that.mode === 'numeric') { that._getEventValue = function () { return that.value; }; } else { that._handleDateScale(); } that._setSettingsObject(); that._setDrawVariables(); that._getLayoutType(); //Creating instances of NumericProcessor and NumberRenderer that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'scaleType'); that._numberRenderer = new LW.Utilities.NumberRenderer(); if (!that._isVisible()) { that._renderingSuspended = true; return; } that._renderingSuspended = false; that._setInitialComponentDisplay(); that._measurements = {}; that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength); that._validateInitialPropertyValues(); that._setTicksAndInterval(); // Initial adjustments that._validate(true); that._updateTooltipValue(that._drawValue); that._setFocusable(); that._setTrackSize(); //Add bubbles effect that._setBubbles(); //Restore CSS transition that.$.fill.style.transition = ''; that.$.hiddenInput.value = that._getEventValue(); that.setAttribute('aria-orientation', that.orientation); that._setAriaValue('valuenow'); } /* * Public methods */ /** * Sets or gets the value of the tank. * * @param {Number/String} value Optional value to be set to the tank. If this parameter is not set, the method gets the value. */ val(value) { const that = this; if (value !== undefined) { if (that.mode === 'date') { let newValue = LW.Utilities.DateTime.validateDate(value); newValue = newValue.getTimeStamp(); if (newValue.compare(that.value) !== 0) { that._validate(false, newValue, undefined, true); return; } return that._valueDate; } if (that.value.toString().toUpperCase() !== value.toString().toUpperCase()) { // use as value setter value = value.toString().replace(/\s/g, ''); if (that._numericProcessor.regexScientificNotation.test(value)) { value = that._numericProcessor.scientificToDecimal(value); } const valueToValidate = that._discardDecimalSeparator(value.toString()); that._validate(false, valueToValidate, undefined, true); delete that._valueBeforeCoercion; } else { return that.value = typeof (value) === 'string' ? value : value.toString(); } } else { // use as value getter return that._getEventValue(); } } /** * Adds bubbles in the fill area. */ _setBubbles() { const that = this; if (!that.hasAnimation) { //Removes the bubble elements //const bubbles = that.getElementsByClassName('bubble'); //if (bubbles.length > 0) { // for (let b = bubbles.length; b > -1; b--) { // b[0].parentElement.removeChild(b[0]); // } //} return; } let fragment = document.createDocumentFragment(), bubble; for (let b = 0; b < 5; b++) { bubble = document.createElement('div'); bubble.classList.add('bubble'); bubble.classList.add('bubble' + (b + 1)); fragment.appendChild(bubble); } that.$.bubbleContainer.appendChild(fragment); } _setTrackSize() { const that = this; //Calculte initial track size if (that.orientation === 'vertical') { that._trackSize = that.$.track.offsetWidth; } else { that._trackSize = that.$.track.offsetHeight; } } /** * Gets the optimal size of the tank. */ getOptimalSize() { const that = this; if (that._renderingSuspended) { return { width: 0, height: 0 }; } let propertiesObj, largestLabelSize, sizeObject; switch (that.labelsVisibility) { case 'all': largestLabelSize = that._numericProcessor._longestLabelSize break; case 'endPoints': largestLabelSize = Math.max(that._tickIntervalHandler.labelsSize.minLabelOtherSize, that._tickIntervalHandler.labelsSize.maxLabelOtherSize); break; case 'none': largestLabelSize = 0; break; } switch (that.orientation) { case 'horizontal': propertiesObj = { marginA: 'marginBottom', marginB: 'marginTop', nearScaleDistance: 'bottom', farScaleDistance: 'top', paddingA: 'paddingBottom', paddingB: 'paddingTop', offset: 'offsetWidth', distance: 'left' }; if (that._orientationChanged) { propertiesObj.offset = 'offsetHeight'; that._trackChanged = true; } sizeObject = that._getSize(largestLabelSize, propertiesObj); return { width: sizeObject.optimalOtherSize, height: sizeObject.optimalSize }; case 'vertical': propertiesObj = { marginA: 'marginLeft', marginB: 'marginRight', nearScaleDistance: 'right', farScaleDistance: 'left', paddingA: 'paddingLeft', paddingB: 'paddingRight', offset: 'offsetHeight', distance: 'top' }; if (that._orientationChanged) { propertiesObj.offset = 'offsetWidth'; that._trackChanged = true; } sizeObject = that._getSize(largestLabelSize, propertiesObj); return { width: sizeObject.optimalSize, height: sizeObject.optimalOtherSize }; } } /** * Invoked when the value of a public property has been changed by the user. */ propertyChangedHandler(key, oldValue, value) { super.propertyChangedHandler(key, oldValue, value); const that = this; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } // eslint-disable-next-line if (value == oldValue) { that[key] = oldValue; return; } switch (key) { case 'labelsVisibility': case 'ticksVisibility': that._updateScaleWidth(that._numericProcessor._longestLabelSize); return; case 'coerce': if (value) { const valueBeforeCoercion = that.value, coercedValue = value = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(valueBeforeCoercion))) : that._numericProcessor.getCoercedValue(valueBeforeCoercion); that._validate(false, coercedValue, true, true); that._valueBeforeCoercion = valueBeforeCoercion; // stores value before coercion } else { if (that._valueBeforeCoercion !== undefined) { that._validate(false, that._valueBeforeCoercion, false, true); } } return; case 'interval': { //Validates the Interval that._numericProcessor.validateInterval(value); const newValue = value = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(that.value))) : that._numericProcessor.getCoercedValue(that.value); that._validate(false, newValue, that.coerce, true); break; } case 'min': case 'max': { if (that.mode === 'date') { delete that._dateInterval; that[key] = LW.Utilities.DateTime.validateDate(value).getTimeStamp(); } that._validateMinMax(key, false, oldValue); const validValue = that._numericProcessor.createDescriptor(that._discardDecimalSeparator(that.value, that.decimalSeparator), undefined, true, that.validation === 'strict'); that._setTicksAndInterval(); that._numericProcessor.updateValue(validValue); let optimalSize = that.getOptimalSize(), actualSize = that.getBoundingClientRect(), trackSize = that.$.track.getBoundingClientRect(); if (optimalSize.width > actualSize.width && trackSize.width < 20) { that.style.width = optimalSize.width + 'px'; that.style.height = optimalSize.height + 'px'; } break; } case 'inverted': case 'rightToLeft': { that._getLayoutType(); if (that._normalLayout) { that.$.fill.style[that._settings.margin] = '0px'; } let invertedNumberToValidate = that._numericProcessor.createDescriptor(that.value), validInvertedValue = that._numericProcessor.validate(invertedNumberToValidate, that._minObject, that._maxObject); that._setTicksAndInterval(); that._numericProcessor.updateValue(validInvertedValue); break; } case 'orientation': { const fillStyle = that.$.fill.style, containerStyle = that.$.container.style; //resizeChange handler flag if (that._orientationChanged !== true) { that._orientationChanged = true; } that._tankSizeBeforeOrientation = { width: that.offsetWidth, height: that.offsetHeight }; that._setSettingsObject(); that._getLayoutType(); if (that.rightToLeft) { fillStyle.marginLeft = '0'; } if (that.inverted) { fillStyle.marginTop = '0'; fillStyle.marginLeft = '0'; } switch (that.orientation) { case 'vertical': if (!that.inverted) { fillStyle.marginTop = 'auto'; fillStyle.marginLeft = '0'; } fillStyle.width = '100%'; containerStyle.paddingLeft = '0'; containerStyle.paddingRight = '0'; break; case 'horizontal': if (!that.inverted || (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { fillStyle.marginTop = '0'; fillStyle.marginLeft = 'auto' } fillStyle.height = '100%'; containerStyle.paddingTop = '0'; containerStyle.paddingBottom = '0'; break; } that._validateMinMax('both'); const orientationNumberToValidate = that._numericProcessor.createDescriptor(that.value), validOrientationValue = that._numericProcessor.validate(orientationNumberToValidate, that._minObject, that._maxObject); that._setTicksAndInterval(); that._setTicksAndInterval();// that._numericProcessor.updateValue(validOrientationValue); that._trackChanged = true; that.setAttribute('aria-orientation', value); break; } case 'significantDigits': case 'precisionDigits': { if (that.mode === 'date') { return; } if (key === 'precisionDigits' && that.scaleType === 'integer') { that.error(that.localize('noInteger', { elementType: that.nodeName.toLowerCase(), property: key })); } if (key === 'significantDigits' && that.precisionDigits !== null) { that.precisionDigits = null; } else if (key === 'precisionDigits' && that.significantDigits !== null) { that.significantDigits = null; } // Validates significantDigits that._validateInitialPropertyValues(); // Redraw the labels that._setTicksAndInterval(); if (that.orientation === 'horizontal' && (that.inverted || that.rightToLeft)) { const px = that._numericProcessor.valueToPx(that._numericProcessor.getCoercedValue(that._drawValue)); that.updateFillSizeAndPosition(px, that._settings.margin, value, false); } break; } case 'decimalSeparator': { if (that.scaleType === 'integer' || that.mode === 'date') { return; } const numericValue = that._discardDecimalSeparator(that.value, oldValue), valueWithNewSeparator = that._applyDecimalSeparator(numericValue); that.value = numericValue; delete that._valueBeforeCoercion; // Redraw the labels that._numericProcessor.addTicksAndLabels(); that._updateTooltipValue(valueWithNewSeparator); break; } case 'value': { that.value = oldValue; if (value === null) { return; } if (that.mode === 'date') { let newValue = LW.Utilities.DateTime.validateDate(value); newValue = newValue.getTimeStamp(); if (newValue.compare(oldValue) !== 0) { that._validate(false, newValue, undefined, true); } return; } if (value.toString().toUpperCase() !== oldValue.toString().toUpperCase()) { let valueToValidate = value !== undefined ? value.toString().replace(/\s/g, '') : oldValue.toString().replace(/\s/g, ''); if (that._numericProcessor.regexScientificNotation.test(valueToValidate)) { valueToValidate = that._numericProcessor.scientificToDecimal(valueToValidate); } that._validate(false, valueToValidate, undefined, true); delete that._valueBeforeCoercion; } else { that.value = typeof (value) === 'string' ? value : value.toString(); } break; } case 'scaleType': if (that.mode === 'date') { that.scaleType = 'integer'; return; } that._changeScaleType(oldValue, value); break; case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'showUnit': case 'unit': { that._setTicksAndInterval(); that._moveThumbBasedOnValue(that._drawValue); break; } case 'tooltipPosition': break; case 'wordLength': { if (that.mode === 'date') { that.wordLength = 'uint64'; return; } that._wordLengthNumber = that._numericProcessor.getWordLength(value); that._validateMinMax('both'); const numberToValidate = that._numericProcessor.createDescriptor(that.value), validValue = that._numericProcessor.validate(numberToValidate, that._minObject, that._maxObject); that._setTicksAndInterval(); that._numericProcessor.updateValue(validValue); break; } case 'scalePosition': { that._setInitialComponentDisplay(); that._setTicksAndInterval(); that._moveThumbBasedOnValue(that._drawValue); break; } case 'labelFormatFunction': case 'scientificNotation': { if (that.mode === 'date' && key === 'scientificNotation') { return; } const numericValue = that._discardDecimalSeparator(that.value, that.decimalSeparator); // Recalculate label position and redraw the labels that._setTicksAndInterval(); //Update toolTip\'s value that._updateTooltipValue(numericValue); break; } case 'logarithmicScale': if (that.mode === 'date') { that.logarithmicScale = false; return; } that._validateMinMax('both'); that._setTicksAndInterval(); that._validate(false, that.value, undefined, true); break; case 'ticksPosition': if (value === 'scale') { that.$trackTicksContainer.addClass('lw-hidden'); that.$.trackTicksContainer.innerHTML = ''; } else { that.$trackTicksContainer.removeClass('lw-hidden'); } that._numericProcessor.addTicksAndLabels(); break; case 'customInterval': if (value) { if (that._customTicks) { that.customTicks = that._customTicks; } that._numericProcessor.validateCustomTicks(); } else if (that.mode === 'date') { that._customTicks = that.customTicks; } that._setTicksAndInterval(); that._coerceCustomInterval(); break; case 'customTicks': if (that.mode === 'date' && !that.customInterval) { that._customTicks = value; that.customTicks = oldValue; return; } that._numericProcessor.validateCustomTicks(); if (that.customInterval) { that._setTicksAndInterval(); that._coerceCustomInterval(); } break; case 'dateLabelFormatString': if (that.mode === 'date') { that._setTicksAndInterval(); } break; case 'mode': that.mode = oldValue; break; case 'showThumbLabel': if (value && that.showTooltip) { that.showTooltip = false; } break; case 'showTooltip': if (value && that.showThumbLabel) { that.showThumbLabel = false; } break; case 'validation': if (value === 'strict') { that._validate(false, that.value); } break; } } /** * Sets the "_settings" object. */ _setSettingsObject() { const that = this; if (that.orientation === 'horizontal') { that._settings = { clientSize: 'clientWidth', dimension: 'width', leftOrTop: 'left', margin: 'marginLeft', offset: 'offsetLeft', otherSize: 'offsetHeight', size: 'offsetWidth', page: 'pageX' }; } else { that._settings = { clientSize: 'clientHeight', dimension: 'height', leftOrTop: 'top', margin: 'marginTop', offset: 'offsetTop', otherSize: 'offsetWidth', size: 'offsetHeight', page: 'pageY' }; } } /** * Sets the display of the scales. */ _setInitialComponentDisplay() { const that = this; switch (that.scalePosition) { case 'near': that.$scaleNear.removeClass('lw-hidden'); that.$scaleFar.addClass('lw-hidden'); break; case 'far': that.$scaleNear.addClass('lw-hidden'); that.$scaleFar.removeClass('lw-hidden'); break; case 'both': that.$scaleFar.removeClass('lw-hidden'); that.$scaleNear.removeClass('lw-hidden'); break; case 'none': that.$scaleFar.addClass('lw-hidden'); that.$scaleNear.addClass('lw-hidden'); break; } that.$tooltip.addClass('lw-hidden'); if (that.ticksPosition === 'track') { that.$trackTicksContainer.removeClass('lw-hidden'); } } /** * Style changed event handler. **/ _styleChangedHandler() { const that = this; if (!that._isVisible()) { that._renderingSuspended = true; return; } else if (that._renderingSuspended) { that._createElement(); return; } if (that._renderingSuspended) { return; } that._setTicksAndInterval(); that._moveThumbBasedOnValue(that._drawValue); } /** * Validates initial property values. */ _validateInitialPropertyValues() { const that = this, value = typeof (that.value) === String ? that.value.replace(/\s/g, '') : that.value.toString().replace(/\s/g, ''); if (that.mode === 'numeric' && that._numericProcessor.regexScientificNotation.test(value)) { that.value = that._numericProcessor.scientificToDecimal(value); delete that._valueBeforeCoercion; } //Validates significantDigits that.significantDigits = (that.significantDigits !== null) ? Math.min(Math.max(that.significantDigits, 1), 21) : null; if (that.significantDigits === null && that.precisionDigits === null) { that.significantDigits = 8; } else if (that.significantDigits !== null && that.precisionDigits !== null) { that.error(that.localize('significantPrecisionDigits', { elementType: that.nodeName.toLowerCase() })); } //minMax validation that._validateMinMax('both', true); if (that.showTooltip && that.showThumbLabel) { that.showTooltip = false; } } /** * Validates the properties "min" and "max". */ _validateMinMax(validatedProperty, initialValidation, oldValue) { const that = this; let validateMin = validatedProperty === 'min' || validatedProperty === 'both', validateMax = validatedProperty === 'max' || validatedProperty === 'both'; if (typeof (initialValidation) === undefined) { initialValidation = false; } if (validatedProperty === 'both') { validator('min', oldValue); validator('max', oldValue); } else { validator(validatedProperty, oldValue); } function validator(param, oldValue) { that._numericProcessor.validateMinMax(param === 'min' || initialValidation, param === 'max' || initialValidation); const value = that['_' + param + 'Object']; let validateCondition = param === 'min' ? that._numericProcessor.compare(that.max, value, true) <= 0 : that._numericProcessor.compare(that.min, value, true) > 0; if (validateCondition) { if (oldValue) { that._numberRenderer = new LW.Utilities.NumberRenderer(oldValue); param === 'min' ? validateMin = false : validateMax = false; that[param] = oldValue; that['_' + param + 'Object'] = oldValue; } else { that.error(that.localize('invalidMinOrMax', { elementType: that.nodeName.toLowerCase(), property: param })); } } else { that._numberRenderer = new LW.Utilities.NumberRenderer(value); that[param] = that['_' + param + 'Object']; } } if (that.logarithmicScale) { that._validateOnLogarithmicScale(validateMin, validateMax, oldValue); } else { that._drawMin = that.min; that._drawMax = that.max; } that.min = that.min.toString(); that.max = that.max.toString(); that._minObject = that._numericProcessor.createDescriptor(that.min); that._maxObject = that._numericProcessor.createDescriptor(that.max); if (that.mode === 'date') { that._minDate = LW.Utilities.DateTime.fromFullTimeStamp(that.min); that._maxDate = LW.Utilities.DateTime.fromFullTimeStamp(that.max); } //Validates the Interval that._numericProcessor.validateInterval(that.interval); if (that.customInterval) { that._numericProcessor.validateCustomTicks(); } that._setAriaValue('valueminmax'); } /** * Calculates the tank's major and minor ticks interval. */ _calculateTickInterval() { const that = this; let intervals = that._tickIntervalHandler.getInterval('linear', that._drawMin, that._drawMax, that.$.track, that.logarithmicScale); if (intervals.major !== that._majorTicksInterval) { that._intervalHasChanged = true; that._majorTicksInterval = intervals.major; } else { that._intervalHasChanged = true; } that._minorTicksInterval = intervals.minor; if (that.mode === 'date') { that._calculateDateInterval(intervals.major); } } /** * Calculates the tank's ticks when the scale is date. */ _calculateDateInterval(majorTicksInterval) { const that = this, timeParts = { month: '2628000000000000000000000000000', day: '86400000000000000000000000000', hour: '3600000000000000000000000000', minute: '60000000000000000000000000', second: '1000000000000000000000000' }; let part = 'year', bigNumberTimePart = new LW.Utilities.BigNumber('31536000000000000000000000000000'), difference = bigNumberTimePart.subtract(majorTicksInterval).abs(), range = new LW.Utilities.BigNumber(that.min).subtract(that.max).abs(), projectedNumberOfTicks = range.divide(majorTicksInterval).toString(); if (projectedNumberOfTicks < 2) { majorTicksInterval = range.divide(3); } for (let timePart in timeParts) { if (timeParts.hasOwnProperty(timePart)) { const currentBigNumberTimePart = new LW.Utilities.BigNumber(timeParts[timePart]), currentDifference = currentBigNumberTimePart.subtract(majorTicksInterval).abs(); if (currentDifference.compare(difference) === -1) { part = timePart; bigNumberTimePart = currentBigNumberTimePart; difference = currentDifference; } else { break; } } } if (part === 'second') { that._numberRenderer.numericValue = parseFloat(majorTicksInterval); if (that._numberRenderer.numericValue < 1000) { that._dateIncrementMethod = 'addYoctoseconds'; that._dateIntervalNumber = 1; return; } let scientificPrefix = that._numberRenderer.toScientific(10); scientificPrefix = scientificPrefix.charAt(scientificPrefix.length - 1); that._dateIncrementMethod = that._unitToMethod[scientificPrefix]; that._dateIntervalNumber = Math.pow(10, that._numericProcessor.prefixesToPowers[scientificPrefix]); return; } that._dateInterval = true; const calculatedInterval = !that.customInterval; let customTicks, numberOfTimeParts, toAdd; if (calculatedInterval) { customTicks = [new LW.Utilities.BigNumber(that.min)]; numberOfTimeParts = range.divide(bigNumberTimePart).toString(); toAdd = Math.max(1, Math.floor(numberOfTimeParts / projectedNumberOfTicks)); } switch (part) { case 'year': if (calculatedInterval) { for (let i = that._minDate.year() + toAdd; i < that._maxDate.year(); i += toAdd) { customTicks.push(new LW.Utilities.BigNumber(new LW.Utilities.DateTime(i, 1, 1).getTimeStamp())); } } that._dateIncrementMethod = 'addYears'; break; case 'month': if (calculatedInterval) { for (let i = new LW.Utilities.DateTime(that._minDate.year(), that._minDate.month() + toAdd, 1); i.compare(that._maxDate) === -1; i.addMonths(toAdd, false)) { customTicks.push(new LW.Utilities.BigNumber(i.getTimeStamp())); } } that._dateIncrementMethod = 'addMonths'; break; case 'day': if (calculatedInterval) { for (let i = new LW.Utilities.DateTime(that._minDate.year(), that._minDate.month(), that._minDate.day() + toAdd); i.compare(that._maxDate) === -1; i.addDays(toAdd, false)) { customTicks.push(new LW.Utilities.BigNumber(i.getTimeStamp())); } } that._dateIncrementMethod = 'addDays'; that._dateIntervalNumber = 86400000000000000000000000000; break; case 'hour': if (calculatedInterval) { for (let i = new LW.Utilities.DateTime(that._minDate.year(), that._minDate.month(), that._minDate.day(), that._minDate.hour() + toAdd); i.compare(that._maxDate) === -1; i.addHours(toAdd, false)) { customTicks.push(new LW.Utilities.BigNumber(i.getTimeStamp())); } } that._dateIncrementMethod = 'addHours'; that._dateIntervalNumber = 3600000000000000000000000000; break; case 'minute': if (calculatedInterval) { for (let i = new LW.Utilities.DateTime(that._minDate.year(), that._minDate.month(), that._minDate.day(), that._minDate.hour(), that._minDate.minute() + toAdd); i.compare(that._maxDate) === -1; i.addMinutes(toAdd, false)) { customTicks.push(new LW.Utilities.BigNumber(i.getTimeStamp())); } } that._dateIncrementMethod = 'addMinutes'; that._dateIntervalNumber = 60000000000000000000000000; break; } if (calculatedInterval) { if (customTicks[customTicks.length - 1].compare(that.max) === -1) { customTicks.push(new LW.Utilities.BigNumber(that.max)); } that.customTicks = customTicks; } } /** * Formats the value. */ _formatNumber(value) { const that = this; if (that.mode === 'date') { const date = LW.Utilities.DateTime.fromFullTimeStamp(value); return date.toString(that.dateLabelFormatString); } const numberRenderer = that._numberRenderer; let renderedNumber = parseFloat(value); numberRenderer.numericValue = value; if (that.scientificNotation) { renderedNumber = that._numberRenderer.toScientific(that.significantDigits, that.precisionDigits); } else { switch (that.scaleType) { case 'floatingPoint': renderedNumber = that._applyDecimalSeparator(numberRenderer.toDigits(that.significantDigits, that.precisionDigits)); break; case 'integer': renderedNumber = numberRenderer.isENotation(renderedNumber) ? Math.round(numberRenderer.largeExponentialToDecimal(renderedNumber)) : Math.round(renderedNumber); renderedNumber = numberRenderer.toDigits(that.significantDigits, 0); break; } } return renderedNumber; } /** * Applies formatting to tank labels. */ _formatLabel(labelValue, unselectableUnit) { const that = this; let renderedLabel; if (that.labelFormatFunction) { if (that.mode === 'date') { labelValue = LW.Utilities.DateTime.fromFullTimeStamp(labelValue); } renderedLabel = that.labelFormatFunction(labelValue); if (renderedLabel !== undefined && renderedLabel !== '') { return renderedLabel; } } renderedLabel = that._formatNumber(labelValue); that._numberRenderer = new LW.Utilities.NumberRenderer(renderedLabel); if (that.showUnit) { if (unselectableUnit !== false) { renderedLabel += ' <span class="lw-unselectable">' + that.unit + '</span>'; } else { renderedLabel += ' ' + that.unit; } } return renderedLabel; } /** * Applies necessary paddings to the track container. */ _layout() { const that = this, containerStyle = that.$.container.style, paddingStart = that._tickIntervalHandler.labelsSize.minLabelSize / 2 + 'px', paddingEnd = that._tickIntervalHandler.labelsSize.maxLabelSize / 2 + 'px'; switch (that.orientation) { case 'horizontal': if (that.scalePosition === 'none') { containerStyle.paddingLeft = ''; containerStyle.paddingRight = ''; break; } if ((!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { containerStyle.paddingLeft = paddingStart; containerStyle.paddingRight = paddingEnd; } else { containerStyle.paddingLeft = paddingEnd; containerStyle.paddingRight = paddingStart; } break; case 'vertical': if (that.scalePosition === 'none') { containerStyle.paddingTop = ''; containerStyle.paddingBottom = ''; break; } if (!that.inverted) { containerStyle.paddingBottom = paddingStart; containerStyle.paddingTop = paddingEnd; } else { containerStyle.paddingBottom = paddingEnd; containerStyle.paddingTop = paddingStart; } break; } that._measurements.trackLength = that.$.track[this._settings.clientSize]; } /** * Track click event handler. */ _trackDownHandler(event) { const that = this; if (that.disabled || that.readonly || (!LW.Utilities.Core.isMobile && event.button !== 0)) { return; } if (that.mechanicalAction === 'switchUntilReleased') { that._cachedValue = {}; that._cachedValue._number = that._number; that._cachedValue._drawValue = that._drawValue; that._cachedValue.value = that.value; if (that._valueDate) { that._cachedValue._valueDate = that._valueDate; } } that._getTrackStartAndEnd(); that._moveThumbBasedOnCoordinates(event, true, that.mechanicalAction !== 'switchWhenReleased'); that._thumbDragged = true; that.$track.addClass('lw-dragged'); if (that.showTooltip) { that.$tooltip.removeClass('lw-hidden'); } } /** * Track mousemove event handler. */ _trackMoveHandler(event) { if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * Document mousemove event handler. */ _documentMoveHandler(event) { const that = this; if (that._thumbDragged) { event.originalEvent.preventDefault(); that._moveThumbBasedOnCoordinates(event, true, that.mechanicalAction !== 'switchWhenReleased'); that.$fill.addClass('disable-animation'); } } /** * Document mouseup event handler. */ _documentUpHandler(event) { const that = this; if (!that._thumbDragged) { return; } if (that.mechanicalAction === 'switchWhenReleased') { that._moveThumbBasedOnCoordinates(event, true, true); } else if (that.mechanicalAction === 'switchUntilReleased') { if (that._numericProcessor.compare(that._number, that._cachedValue._number)) { const oldValue = that._getEventValue(); that._number = that._cachedValue._number; that._drawValue = that._cachedValue._drawValue; if (that._cachedValue._valueDate) { that._valueDate = that._cachedValue._valueDate; } that.value = that._cachedValue.value; that._moveThumbBasedOnValue(that._drawValue); const value = that._getEventValue(); that.$.fireEvent('change', { 'value': value, 'oldValue': oldValue }); that.$.hiddenInput.value = value; that._setAriaValue('valuenow'); } } if (that.showTooltip) { that.$tooltip.addClass('lw-hidden'); } that._thumbDragged = false; that.$track.removeClass('lw-dragged'); that.$fill.removeClass('disable-animation'); } /** * Document select start handler. */ _selectStartHandler(event) { const that = this; if (that._thumbDragged) { event.preventDefault(); } } /** * Tank resize event handler. */ _resizeHandler() { const that = this; if (!that._isVisible()) { that._renderingSuspended = true; return; } else if (that._renderingSuspended) { that._createElement(); return; } if (that._renderingSuspended) { return; } if (that._orientationChanged !== true) { that._setTicksAndInterval(); that._moveThumbBasedOnValue(that._drawValue); } //Needed for getOptimalSize method if (that._trackChanged) { that._measurements.trackLength = that.$.track[this._settings.clientSize]; that._setTicksAndInterval(); that._moveThumbBasedOnValue(that._drawValue); } that._setTrackSize(); delete that._orientationChanged; delete that._trackChanged; } /** * Moves the tank's thumb and updates the filled part of the track based on the position of the mouse. */ _moveThumbBasedOnCoordinates(event, checkBoundaries, changeValue) { const that = this; let coordinate = checkBoundaries ? Math.min(Math.max(event[that._settings.page], that._trackStart), that._trackEnd) : event[that._settings.page], value = that._numericProcessor.pxToValue(coordinate); if (that.logarithmicScale) { that._drawValue = Math.log10(value); value = that._numericProcessor.getCoercedValue(that._drawValue); } else { that._drawValue = value; value = that._numericProcessor.getCoercedValue(value); } // Validating the coordinate coordinate = Math.min(Math.max(that._numericProcessor.valueToPx(value) + that._trackStart, that._trackStart), that._trackEnd); const size = coordinate - that._trackStart; that.updateFillSizeAndPosition(size, that._settings.margin, value, true, changeValue); if (event.originalEvent) { event.originalEvent.stopPropagation(); } } /** * Moves the tank's thumb and updates the filled part of the track based on a passed value. */ _moveThumbBasedOnValue(value) { const that = this, px = that._numericProcessor.valueToPx(that._numericProcessor.getCoercedValue(value)); that.updateFillSizeAndPosition(px, that._settings.margin, value, true); } /** * Applies the filling, updates the tooltip and the value */ updateFillSizeAndPosition(size, margin, newValue, updateTooltip, changeValue) { const that = this, fillStyle = that.$.fill.style; if (that._normalLayout) { fillStyle[that._settings.dimension] = size + 'px'; } else { fillStyle[that._settings.dimension] = Math.min(that._measurements.trackLength, Math.max(0, (that._measurements.trackLength - size))) + 'px'; fillStyle[margin] = size + 'px'; } if (updateTooltip) { const oldValue = that.value; delete that._valueBeforeCoercion; that._numericProcessor.updateToolTipAndValue(newValue, oldValue, changeValue); } } /** * Sets tooltip's value. */ _updateTooltipValue(value) { const that = this; if (value === undefined) { value = that.value; } if (that.logarithmicScale) { value = Math.pow(10, value.toString()); } value = that._formatLabel(value); that.$.tooltipContent.innerHTML = value; that.$.thumbLabel.innerHTML = value; } /** * Returns the optimal size, based on tank settings. **/ _getSize(largestLabelSize, properties) { const that = this, tankStyle = window.getComputedStyle(that), trackStyle = window.getComputedStyle(that.$.track), trackSize = that._trackSize + parseFloat(trackStyle[properties.marginA]) + parseFloat(trackStyle[properties.marginB]); let firstLabel, lastLabel, optimalSize, optimalOtherSize; function calcScaleSize(selector, distance) { const labels = selector.getElementsByClassName('lw-label'); firstLabel = labels[0]; lastLabel = labels[labels.length - 1]; const firstLabelStyle = window.getComputedStyle(labels[0])[distance]; optimalSize += parseFloat(firstLabelStyle); } optimalSize = trackSize; switch (that.scalePosition) { case 'none': optimalSize += parseFloat(tankStyle[properties.paddingA]) + parseFloat(tankStyle[properties.paddingB]); if (typeof (that._tankSizeBeforeOrientation) !== 'undefined') { optimalOtherSize = that.orientation === 'horizontal' ? that._tankSizeBeforeOrientation.height : that._tankSizeBeforeOrientation.width; } else { optimalOtherSize = that.orientation === 'horizontal' ? parseFloat(trackStyle.width) : parseFloat(trackStyle.height); } if (that._trackChanged !== true) { that._trackChanged = true; } return { optimalSize: optimalSize, optimalOtherSize: optimalOtherSize }; case 'near': optimalSize += largestLabelSize; calcScaleSize(that.$.scaleNear, properties.nearScaleDistance); break; case 'far': optimalSize += largestLabelSize; calcScaleSize(that.$.scaleFar, properties.farScaleDistance); break; case 'both': optimalSize += 2 * largestLabelSize; calcScaleSize(that.$.scaleNear, properties.nearScaleDistance); calcScaleSize(that.$.scaleFar, properties.farScaleDistance); break } let firstRect, lastRect, difference; optimalSize += parseFloat(tankStyle[properties.paddingA]) + parseFloat(tankStyle[properties.paddingB]); firstRect = firstLabel.getBoundingClientRect(); lastRect = lastLabel.getBoundingClientRect(); optimalOtherSize = that[properties.offset]; difference = firstRect[properties.distance] + firstLabel[properties.offset] - lastRect[properties.distance]; if (difference > 0) { optimalOtherSize = firstLabel[properties.offset] + lastLabel[properties.offset]; } return { optimalSize: optimalSize, optimalOtherSize: optimalOtherSize }; } /** * Calculates the tank's current value range. */ _getRange() { const that = this; if (that.logarithmicScale) { that._range = that._drawMax - that._drawMin; return; } if (that.scaleType === 'floatingPoint') { that._range = (that._drawMax - that._drawMin).toString(); } else { that._range = new LW.Utilities.BigNumber(that._drawMax).subtract(that._drawMin).toString(); } } /** * Gets the coordinates of the track and the value per pixel ratio. */ _getTrackStartAndEnd() { const that = this; let trackStart, offset = that.$.track.getBoundingClientRect(); if (that.orientation === 'horizontal') { const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft; trackStart = offset.left + scrollLeft; } else { const scrollTop = document.body.scrollTop || document.documentElement.scrollTop; trackStart = offset.top + scrollTop; } const trackEnd = trackStart + that._measurements.trackLength, pxRange = trackEnd - trackStart; that._trackStart = trackStart; that._trackEnd = trackEnd; that._valuePerPx = that._numericProcessor.getValuePerPx(that._range, pxRange); } /** * Update scale's width. */ _updateScaleWidth(longestLabelSize) { const that = this; let scaleCoeficient = that.ticksPosition === 'track' ? 4 : 12; switch (that.labelsVisibility) { case 'all': longestLabelSize = that._numericProcessor._longestLabelSize break; case 'endPoints': longestLabelSize = Math.max(that._tickIntervalHandler.labelsSize.minLabelOtherSize, that._tickIntervalHandler.labelsSize.maxLabelOtherSize); break; case 'none': longestLabelSize = 0; break; } let scaleSize = scaleCoeficient + longestLabelSize, trackComputedStyle = window.getComputedStyle(that.$.track), variablesUsed = Boolean(trackComputedStyle.getPropertyValue('--lw-tank-scale-size')); if (variablesUsed) { that.$.container.style.setProperty('--lw-tank-scale-size', scaleSize + 'px'); } else { const computedStyles = window.getComputedStyle(that), scaleNearStyle = that.$.scaleNear.style, scaleFarStyle = that.$.scaleFar.style, trackStyle = that.$.track.style, trackMinWidth = parseFloat(trackComputedStyle.getPropertyValue('min-width')); let dimension, dimension2, dimensionValue, margins, outlineWidth = parseFloat(trackComputedStyle.getPropertyValue('outline-width')) || 0, outlineOffset = parseFloat(trackComputedStyle.getPropertyValue('outline-offset')) || 0, outline = outlineWidth + outlineOffset, paddings; switch (that.orientation) { case 'horizontal': dimension = 'height'; dimension2 = 'width'; dimensionValue = that.offsetHeight; paddings = parseFloat(computedStyles.getPropertyValue('padding-top')) + parseFloat(computedStyles.getPropertyValue('padding-bottom')); margins = parseFloat(trackComputedStyle.getPropertyValue('margin-top')) + parseFloat(trackComputedStyle.getPropertyValue('margin-bottom')); break; case 'vertical': dimension = 'width'; dimension2 = 'height'; dimensionValue = that.offsetWidth; paddings = parseFloat(computedStyles.getPropertyValue('padding-left')) + parseFloat(computedStyles.getPropertyValue('padding-right')); margins = parseFloat(trackComputedStyle.getPropertyValue('margin-left')) + parseFloat(trackComputedStyle.getPropertyValue('margin-right')); break; } switch (that.scalePosition) { case 'near': scaleNearStyle.setProperty(dimension, scaleSize + 'px'); trackStyle.setProperty(dimension, Math.max(isNaN ? 0 : trackMinWidth, dimensionValue - paddings - scaleSize - 4 - margins - outline) + 'px'); break; case 'far': scaleFarStyle.setProperty(dimension, scaleSize + 'px'); trackStyle.setProperty(dimension, Math.max(isNaN ? 0 : trackMinWidth, dimensionValue - paddings - scaleSize - 4 - margins - outline) + 'px'); break; case 'both': scaleNearStyle.setProperty(dimension, scaleSize + 'px'); scaleFarStyle.setProperty(dimension, scaleSize + 'px'); trackStyle.setProperty(dimension, Math.max(isNaN ? 0 : trackMinWidth, dimensionValue - paddings - 2 * scaleSize - 4 - margins - outline) + 'px'); break; case 'none': trackStyle.setProperty(dimension, ''); break; } trackStyle.setProperty(dimension2, '100%'); scaleNearStyle.setProperty(dimension2, '100%'); scaleFarStyle.setProperty(dimension2, '100%'); } } /** * Appends ticks and labels to the scales. */ _appendTicksAndLabelsToScales(ticks, labels) { const that = this; function applyTicksAndLabels(scaleElement) { scaleElement.innerHTML = labels; if (that.ticksPosition === 'scale') scaleElement.innerHTML += ticks; } switch (that.scalePosition) { case 'near': applyTicksAndLabels(that.$.scaleNear); break; case 'far': applyTicksAndLabels(that.$.scaleFar); break; case 'both': applyTicksAndLabels(that.$.scaleNear); applyTicksAndLabels(that.$.scaleFar); break; } if (that.ticksPosition === 'track') { that.$.trackTicksContainer.innerHTML = ticks; } } /** * Replaces a custom decimal separator with the default one. */ _discardDecimalSeparator(value, separator) { const that = this; if (separator === undefined) { separator = that.decimalSeparator; } if (separator !== '.') { let decimalSeparatorRegExp = new RegExp(separator, 'g'); return typeof value === 'string' ? value.replace(decimalSeparatorRegExp, '.') : value.toString().replace(decimalSeparatorRegExp, '.'); } else { return value; } } /** * Applies a custom decimal separator. */ _applyDecimalSeparator(value) { const that = this; if (typeof value !== 'string') { value = value.toString(); } if (that.decimalSeparator !== '.') { value = value.replace(/\./g, that.decimalSeparator); } return value; } /** * Validates the value of the Tank. */ _validate(initialValidation, programmaticValue, coerced, programmaticValueIsSet) { const that = this; let value; that._programmaticValueIsSet = programmaticValueIsSet && that.validation === 'interaction'; if (initialValidation) { value = that.value; } else { value = programmaticValue; } let actualValue, validNumber; if (coerced !== true && that.coerce) { actualValue = that._numericProcessor.createDescriptor(value, true, true, true); actualValue = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(actualValue))) : that._numericProcessor.getCoercedValue(actualValue); validNumber = actualValue; } else if (that.validation === 'strict' || !initialValidation && !that._programmaticValueIsSet) { actualValue = that._numericProcessor.createDescriptor(value, true, true, true); validNumber = actualValue; } else { actualValue = that._numericProcessor.createDescriptor(value, true, true, false); validNumber = that._numericProcessor.validate(actualValue, that._minObject, that._maxObject); } if (that._numericProcessor.regexScientificNotation.test(validNumber)) { validNumber = that._numericProcessor.scientificToDecimal(validNumber); } validNumber = that._discardDecimalSeparator(validNumber, that.decimalSeparator); if (initialValidation) { that._number = validNumber; that._drawValue = that.logarithmicScale ? Math.log10(validNumber) : validNumber; if (that.mode === 'numeric') { that.value = actualValue.toString(); } else { that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(actualValue); that.value = actualValue; } delete that._valueBeforeCoercion; that._moveThumbBasedOnValue(that._drawValue); } else { that._numericProcessor.updateValue(actualValue); } that._programmaticValueIsSet = false; } /** * Changes the input format. */ _changeScaleType() { const that = this; that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'scaleType'); that._validateMinMax('both'); that._setTicksAndInterval(); that._scaleTypeChangedFlag = true; that._validate(true, that._number.toString()); that._scaleTypeChangedFlag = false; } /** * Sets new Ticks and Interval */ _setTicksAndInterval() { const that = this; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } //Set the New Format here let minLabel = that._formatLabel(that.min), maxLabel = that._formatLabel(that.max); //gets the range with the new min/max that._getRange(); //creates a new tickIntervalHandler instance that._tickIntervalHandler = new LW.Utilities.TickIntervalHandler(that, minLabel, maxLabel, 'lw-label', that._settings.size, that.scaleType === 'integer', that.logarithmicScale); //re-arranges the layout that._layout(); if (!that.customInterval) { // calculates the tickInterval that._calculateTickInterval(); if (that._dateInterval) { that._intervalHasChanged = true; that._numericProcessor.addCustomTicks(); } else { // Add the ticks and labels that._numericProcessor.addTicksAndLabels(); } } else { if (that.mode === 'date') { that._calculateTickInterval() } // custom ticks that._intervalHasChanged = true; that._numericProcessor.addCustomTicks(); } } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); return; } that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0; } /** * Increments or decrements a value when a key is pressed. */ _keyIncrementDecrement(action, preValue) { const that = this, actionCoefficient = action === 'add' ? 1 : -1, calculatePreValue = preValue === undefined; if (calculatePreValue) { preValue = that.logarithmicScale ? new LW.Utilities.BigNumber(that._drawValue) : that._drawValue; } if (that.customInterval && that.coerce) { if (calculatePreValue) { if (that.logarithmicScale) { preValue = that.value; } if (that.mode === 'numeric') { preValue = preValue.toString(); } } let possibleValues, index; if (that.mode === 'numeric') { possibleValues = that.customTicks.indexOf(that.min) !== -1 ? that.customTicks.slice(0) : [that.min].concat(that.customTicks); index = possibleValues.indexOf(preValue); } else { possibleValues = that.customTicks.findIndex(function (element) { return element.compare(that._drawMin) === 0; }) !== -1 ? that.customTicks.slice(0) : [that._drawMin].concat(that.customTicks); index = possibleValues.findIndex(function (element) { return element.compare(preValue) === 0; }); } const adjacent = possibleValues[index + 1 * actionCoefficient]; if (adjacent !== undefined) { return adjacent; } else if (preValue === that.max && action === 'subtract') { return possibleValues[possibleValues.length - 2]; } return preValue; } if (that.mode === 'numeric') { let newValue = that._numericProcessor.incrementDecrement(preValue, action, that._validInterval); if (that.logarithmicScale) { that._drawValue = newValue; newValue = Math.pow(10, Math.round(newValue)); } return newValue; } if (that.validation === 'interaction' && (that._valueDate.compare(that._minDate) === -1 || that._valueDate.compare(that._maxDate) === 1)) { that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(that._drawValue); } that._valueDate[that._dateIncrementMethod](actionCoefficient * parseFloat(that.interval), false); that._drawValue = new LW.Utilities.BigNumber(that._valueDate.getTimeStamp()); if (that._drawValue.compare(that._drawMin) === -1) { that._drawValue = new LW.Utilities.BigNumber(that._drawMin); that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(that._drawValue); } if (that._drawValue.compare(that._drawMax) === 1) { that._drawValue = new LW.Utilities.BigNumber(that._drawMax); that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(that._drawValue); } return that._drawValue; } /** * Tank keydown event handler. Changes the value when user press an arrow, home or end key. */ _keydownHandler(event) { const that = this; if ((that.disabled) || (that.readonly)) { return; } const keyCode = !event.charCode ? event.which : event.charCode, handledKeyCodes = [35, 36, 37, 38, 39, 40]; if (handledKeyCodes.indexOf(keyCode) === -1) { return; } const isIncrementKey = [35, 38, 39].indexOf(keyCode) > -1, isDecrementKey = [36, 37, 40].indexOf(keyCode) > -1; event.preventDefault(); if (that.scaleType === 'floatingPoint') { if ((parseFloat(that.value) <= parseFloat(that.min)) && isDecrementKey || (parseFloat(that.value) >= parseFloat(that.max)) && isIncrementKey) { return; } } else { let testValue = new LW.Utilities.BigNumber(that._drawValue); if ((testValue.compare(that._drawMin) !== 1) && isDecrementKey || (testValue.compare(that._drawMax) !== -1) && isIncrementKey) { return; } } let newValue; switch (keyCode) { case 40: //down arrow case 37: //left arrow newValue = that._keyIncrementDecrement('subtract'); break; case 38: //top arrow case 39: //right arrow newValue = that._keyIncrementDecrement('add'); break; case 36: //home that._drawValue = that._drawMin; newValue = that.min; break; case 35: //end that._drawValue = that._drawMax; newValue = that.max; break; } that._validate(false, newValue, keyCode); return false; } /** * Sets internal variables, used about scale drawing and preserving the value from initial validation **/ _setDrawVariables() { const that = this; if (that.logarithmicScale) { that._drawValue = Math.log10(that.value); that._drawMin = Math.log10(that.min); that._drawMax = Math.log10(that.max); } else { that._drawValue = that.value; that._drawMin = that.min; that._drawMax = that.max; } } /** * validates values when is used logarithmic scale **/ _validateOnLogarithmicScale(validateMin, validateMax) { const that = this; function findNearestPowerOfTen(value) { return Math.pow(10, Math.round(Math.log10(value) - Math.log10(5.5) + 0.5)); } if (validateMin) { if (that.min <= 0) { that.min = 1; that._drawMin = 0; } else if (Math.log10(that.min) % 1 !== 0) { let nearestPowerOfTen = findNearestPowerOfTen(parseFloat(that.min)); if (nearestPowerOfTen > that.min) { nearestPowerOfTen /= 10; } that._drawMin = Math.log10(that.min); } else { that._drawMin = Math.log10(that.min); } } if (validateMax) { if (that.max <= 0) { that.max = 1; that._drawMax = 0; } else if (Math.log10(that.max) % 1 !== 0) { let nearestPowerOfTen = findNearestPowerOfTen(parseFloat(that.max)); if (nearestPowerOfTen < that.max) { nearestPowerOfTen *= 10; } that._drawMax = Math.log10(that.max); } else { that._drawMax = Math.log10(that.max); } } if (that.scaleType === 'integer') { if (that._drawMin < 0) { that._drawMin = 0; that.min = 1; } if (that._drawMax < 0) { that._drawMax = 1; that.max = 10; } } if (that._drawMax === that._drawMin) { that._drawMax = that._drawMin + 1; } } /** * Sets the internal property "_normalLayout" based on the properties "orientation" and "inverted". */ _getLayoutType() { const that = this, orientation = that.orientation, inverted = that.inverted, rightToLeft = that.rightToLeft; that._normalLayout = orientation === 'horizontal' && ((!inverted && !rightToLeft) || (rightToLeft && inverted)) || orientation === 'vertical' && inverted; } /** * Applies a CSS class to change fill's pointer. Used instead of :hover CSS selector. **/ _trackOnMouseEnterHandler() { const that = this; if (!that.readonly && !that.disabled) { that.$track.addClass('track-hovered'); that.$.track.setAttribute('hover', ''); } } /** * Removes the CSS class used to change fill's pointer. **/ _trackOnMouseLeaveHandler() { const that = this; if (!that.readonly && !that.disabled) { that.$track.removeClass('track-hovered'); that.$.track.removeAttribute('hover'); } } /** * Checks if the element is visible. */ _isVisible() { const that = this; return !!(that.offsetWidth || that.offsetHeight || that.getClientRects().length); } /** * Coerces the value when changes to custom interval-related settings are made. */ _coerceCustomInterval() { const that = this; if (!that.coerce) { return; } const valueBeforeCoercion = that._valueBeforeCoercion, newCoercedValue = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(that.value))) : that._numericProcessor.getCoercedValue(that.value); that._validate(false, newCoercedValue, true, true); that._valueBeforeCoercion = valueBeforeCoercion; } /** * Handles date scale. */ _handleDateScale() { const that = this, dateTime = LW.Utilities.DateTime; if (!dateTime) { that.error(that.localize('missingReference', { elementType: that.nodeName.toLowerCase(), files: 'lw.date.js' })); } that._customTicks = that.customTicks; that._unitToMethod = { 'Y': 'addSeconds', 'Z': 'addMilliseconds', 'E': 'addMicroseconds', 'P': 'addNanoseconds', 'T': 'addPicoseconds', 'G': 'addFemtoseconds', 'M': 'addAttoseconds', 'k': 'addZeptoseconds' }; that._minDate = dateTime.validateDate(that.min); that.min = that._minDate.getTimeStamp(); that._maxDate = dateTime.validateDate(that.max); that.max = that._maxDate.getTimeStamp(); if (!that.rangeSlider) { that._valueDate = dateTime.validateDate(that.value); that.value = that._valueDate.getTimeStamp(); } that._properties.min.serialize = '_serializeMin'; that._properties.max.serialize = '_serializeMax'; that._properties.value.serialize = '_serializeValue'; that.scaleType = 'integer'; that.logarithmicScale = false; that.wordLength = 'uint64'; const propertiesToRedefine = ['min', 'max', 'value']; for (let i = 0; i < propertiesToRedefine.length; i++) { const propertyName = propertiesToRedefine[i]; Object.defineProperty(that, propertyName, { get: function () { if (that.context === that) { return that.properties[propertyName].value; } else { return that['_' + propertyName + 'Date']; } }, set(value) { that.updateProperty(that, that._properties[propertyName], value); } }); } that._getEventValue = function (aria) { if (aria) { that.setAttribute('aria-valuetext', that._valueDate.toString('f')); return that.value.toString(); } return that._valueDate.clone(); }; } /** * Serializes "min". */ _serializeMin() { return this._minDate.toString(); } /** * Serializes "max". */ _serializeMax() { return this._maxDate.toString(); } /** * Serializes "value". */ _serializeValue() { return this._valueDate.toString(); } /** * Redefines property getter and setter. */ _redefineProperty(propertyName) { const that = this; Object.defineProperty(that, propertyName, { get: function () { return that.properties[propertyName].value; }, set(value) { function replacer(key, value) { if (value instanceof LW.Utilities.BigNumber) { return value.toString(); } return value; } const oldValue = that.properties[propertyName].value, stringifiedOldValue = JSON.stringify(oldValue, replacer), stringifiedValue = JSON.stringify(value, replacer); if (stringifiedOldValue === stringifiedValue) { return; } that.properties[propertyName].value = value; if (that.isReady && (!that.ownerElement || (that.ownerElement && that.ownerElement.isReady)) && that.context !== that) { const context = that.context; that.context = that; that.propertyChangedHandler(propertyName, oldValue, value); that.context = context; } } }); } /** * Sets the aria-valuemax, aria-valuemin, aria-valuenow, and aria-valuetext properties. */ _setAriaValue(property) { const that = this; if (property === 'valuenow') { that.setAttribute('aria-valuenow', that._getEventValue(true)); } else { that.setAttribute('aria-valuemin', that.min.toString()); that.setAttribute('aria-valuemax', that.max.toString()); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Gauge custom element. */ LW('lw-gauge', class Gauge extends LW.Tank { /** * Gauge's properties. */ static get properties() { return { 'analogDisplayType': { value: 'needle', allowedValues: ['needle', 'fill', 'line'], type: 'string' }, 'animationDuration': { value: 300, type: 'number' }, 'digitalDisplay': { value: false, type: 'boolean' }, 'digitalDisplayPosition': { value: 'bottom', allowedValues: ['top', 'bottom', 'right', 'left', 'center'], type: 'string' }, 'drawNeedle': { value: null, type: 'function?' }, 'endAngle': { value: 210, type: 'number' }, 'needlePosition': { value: 'center', allowedValues: ['center', 'edge'], type: 'string' }, 'ranges': { value: [], type: 'array' }, 'scalePosition': { value: 'inside', allowedValues: ['outside', 'inside', 'none'], type: 'string' }, 'showRanges': { value: false, type: 'boolean' }, 'sizeMode': { value: 'circle', allowedValues: ['circle', 'auto', 'none'], type: 'string' }, 'startAngle': { value: -30, type: 'number' } }; } /** * Gauge's event listeners. */ static get listeners() { return { 'down': '_downHandler', 'resize': '_resizeHandler', 'styleChanged': '_styleChangedHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler', 'document.selectstart': '_selectStartHandler', 'keydown': '_keydownHandler', 'move': '_trackMoveHandler' }; } /** * Gauge's required files. */ static get requires() { return { 'LW.Utilities.Draw': 'lw.draw.js', 'LW.NumericTextBox': 'lw.numerictextbox.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.numerictextbox.css', 'lw.gauge.css' ] } /** * Gauge's HTML template. */ template() { const template = `<div id="container" role="presentation"> <div id="svgContainer" class="lw-svg-container" role="presentation" aria-hidden="true"></div> <div class="lw-digital-display-container" role="presentation"> <lw-numeric-text-box id="digitalDisplay" class="lw-digital-display" decimal-separator="[[decimalSeparator]]" max="[[max]]" min="[[min]]" name="[[name]]" placeholder="Digital display" readonly right-to-left="[[rightToLeft]]" input-format="[[scaleType]]" scientific-notation="[[scientificNotation]]" show-unit="[[showUnit]]" unit="[[unit]]" unfocusable validation="interaction" word-length="[[wordLength]]" role="tooltip"> </lw-numeric-text-box> </div> </div>`; return template; } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted) { return; } if (that._trackListener) { that._trackListener = new LW.Utilities.InputEvents(that._track); that._trackListener.down(function (event) { that._SVGElementDownHandler(event); }); } if (that._fillListener) { that._fillListener = new LW.Utilities.InputEvents(that._fill); that._fillListener.down(function (event) { that._SVGElementDownHandler(event); }); } if (that._lineListener) { that._lineListener = new LW.Utilities.InputEvents(that._line); that._lineListener.down(function (event) { that._SVGElementDownHandler(event); }); } } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); that._unlisten(); } /** * Invoked when an instance of custom element is attached to the DOM for the first time. */ ready() { super.ready(); } /** * Gets the optimal size of the Gauge. */ getOptimalSize() { const that = this; if (that._renderingSuspended) { return { width: 0, height: 0 }; } if (that.sizeMode !== 'auto') { return { width: that.offsetWidth, height: that._updateSize(true) }; } else { return { width: that.offsetWidth, height: that.offsetHeight }; } } /** * Sets or gets the value of the Gauge. * * @param {Number/String} value Optional value to be set to the Gauge. If this parameter is not set, the method gets the value. */ val(value) { const that = this; if (value !== undefined) { // use as value setter if (that.mode === 'date') { value = LW.Utilities.DateTime.validateDate(value); value = value.getTimeStamp(); } // eslint-disable-next-line if (that._numericProcessor.compare(value, that.value)) { const oldValue = that.value; that._validateValue(value, that.value); if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } that._animate(oldValue); } } else { // use as value getter return that._getEventValue(); } } /** * Applies initial settings to the Gauge element. */ _createElement() { const that = this; if (!that.$.digitalDisplay.id) { that.$.digitalDisplay.id = that.id + 'DigitalDisplay'; } that.setAttribute('aria-describedby', that.$.digitalDisplay.id); if (that.mode === 'numeric') { that._getEventValue = function () { return that.value; }; } else { that._handleDateScale(); that.digitalDisplay = false; } //Creating instances of NumericProcessor, NumberRenderer and Draw that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'scaleType'); that._numberRenderer = new LW.Utilities.NumberRenderer(); that._draw = new LW.Utilities.Draw(that.$.svgContainer); if (!that._isVisible()) { that._renderingSuspended = true; return; } that._renderingSuspended = false; that._setSettingsObject(); that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength); that._measurements = {}; that._validateInitialPropertyValues(); that._getMeasurements(); that._setDrawVariables(); that._getRange(); that._numericProcessor.getAngleRangeCoefficient(); if (that.mode === 'numeric' || !that.coerce) { that._validateValue(); } else { that._coerceInitialDateValue = true; } that._initTickIntervalHandler(); that._renderAnalogItems(); delete that._preventResizeHandler; that._setFocusable(); that._setUpdatePointerMethod(); } /** * Invoked when the value of a public property has been changed by the user. */ propertyChangedHandler(key, oldValue, value) { function validateMinMax(validateMin, validateMax, oldMin, oldMax) { const toValidate = validateMin && validateMax ? 'both' : key; that._validateMinMax(toValidate, false, oldValue); if (key !== 'logarithmicScale' && key !== 'scaleType' && (key !== 'wordLength' && that[key] === oldValue || key === 'wordLength' && that.min === oldMin && that.max === oldMax)) { return; } that._setDrawVariables(); that._getRange(); that._numericProcessor.getAngleRangeCoefficient(); that._initTickIntervalHandler(); that._renderAnalogItems(); that._validateValue(that.value, that.value); that._updatePointer(); } const that = this; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } switch (key) { case 'analogDisplayType': delete that._customSVGElements; that._getMeasurements(); if (value === 'needle' && that.digitalDisplayPosition === 'center') { that.digitalDisplayPosition = 'bottom'; } else if (oldValue === 'needle' && that.digitalDisplayPosition === 'bottom') { that.digitalDisplayPosition = 'center'; } that._renderAnalogItems(); that._setUpdatePointerMethod(); break; case 'coerce': if (value) { const valueBeforeCoercion = that.value; that._validateValue(valueBeforeCoercion); that._updatePointer(); that._valueBeforeCoercion = valueBeforeCoercion; // stores value before coercion } else { if (that._valueBeforeCoercion !== undefined) { that._validateValue(that._valueBeforeCoercion); // restores the value from before coercion that._updatePointer(); } } break; case 'customInterval': if (value) { if (that._customTicks) { that.customTicks = that._customTicks; } that._numericProcessor.validateCustomTicks(); } else if (that.mode === 'date') { that._customTicks = that.customTicks; } that._initTickIntervalHandler(); that._renderAnalogItems(); that._coerceCustomInterval(); break; case 'customTicks': if (that.mode === 'date' && !that.customInterval) { that._customTicks = value; that.customTicks = oldValue; return; } that._numericProcessor.validateCustomTicks(); if (that.customInterval) { that._initTickIntervalHandler(); that._renderAnalogItems(); that._coerceCustomInterval(); } break; case 'dateLabelFormatString': case 'showUnit': case 'unit': that._initTickIntervalHandler(); that._renderAnalogItems(); break; case 'decimalSeparator': case 'scientificNotation': if (that.mode === 'date') { return; } that._initTickIntervalHandler(); that._renderAnalogItems(); break; case 'digitalDisplay': case 'digitalDisplayPosition': if (that.mode === 'date') { if (key === 'digitalDisplay') { that.digitalDisplay = false; } return; } that._updateSize(); break; case 'mechanicalAction': case 'messages': break; case 'disabled': case 'readonly': case 'unfocusable': super.propertyChangedHandler(key, oldValue, value); break; case 'drawNeedle': if (that.analogDisplayType !== 'needle') { return; } if (oldValue === null) { that._draw.removeElement(that._needle); } if (value !== null) { that._updatePointer(); } else { that._renderAnalogItems(); delete that._customSVGElements; } break; case 'endAngle': case 'startAngle': that._validateAngles(); that._numericProcessor.getAngleRangeCoefficient(); that._renderAnalogItems(); break; case 'interval': that._numericProcessor.validateInterval(that.interval); that._validateValue(); that._updatePointer(); break; case 'inverted': case 'labelFormatFunction': case 'rightToLeft': case 'showRanges': that._renderAnalogItems(); break; case 'labelsVisibility': if (oldValue === 'all' && value === 'endPoints' || oldValue === 'endPoints' && value === 'all') { return; } that._getMeasurements(); that._renderAnalogItems(); break; case 'logarithmicScale': if (that.mode === 'date') { that.logarithmicScale = false; return; } that._initTickIntervalHandler(); validateMinMax(true, true); break; case 'max': case 'min': if (that.mode === 'date') { delete that._dateInterval; that[key] = LW.Utilities.DateTime.validateDate(value).getTimeStamp(); } validateMinMax(key === 'min', key === 'max'); break; case 'mode': that.mode = oldValue; break; case 'needlePosition': if (that.analogDisplayType === 'needle') { that._updatePointer(); } break; case 'precisionDigits': case 'significantDigits': if (that.mode === 'date') { return; } if (key === 'precisionDigits' && that.scaleType === 'integer') { that.error(that.localize('noInteger', { elementType: that.nodeName.toLowerCase(), property: key })); } if (key === 'significantDigits' && that.precisionDigits !== null) { that.precisionDigits = null; } else if (key === 'precisionDigits' && that.significantDigits !== null) { that.significantDigits = null; } if (value !== null) { that.$.digitalDisplay.precisionDigits = that.precisionDigits; that.$.digitalDisplay.significantDigits = that.significantDigits; } that._initTickIntervalHandler(); that._renderAnalogItems(); break; case 'ranges': if (!that.showRanges) { return; } that._renderAnalogItems(); break; case 'scaleType': if (that.mode === 'date') { that.scaleType = 'integer'; return; } that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'scaleType'); validateMinMax(true, true); break; case 'scalePosition': case 'ticksPosition': that._getMeasurements(); that._renderAnalogItems(); break; case 'sizeMode': if (value === 'none') { return; } that._preventResizeHandler = true; if (value === 'circle') { that.$.container.removeAttribute('style'); that.style.height = that.offsetWidth + 'px'; that._measurements.cachedHeight = that.offsetHeight; } else if (value === 'auto') { that.$.container.style.height = that.offsetWidth + 'px'; that._updateSize(); } break; case 'theme': super.propertyChangedHandler(key, oldValue, value); that._getMeasurements(); that._renderAnalogItems(); break; case 'ticksVisibility': if (oldValue === 'minor' && value === 'major' || oldValue === 'major' && value === 'minor') { return; } that._getMeasurements(); that._renderAnalogItems(); break; case 'validation': if (value === 'strict') { that._validateValue(that.value, that.value); } break; case 'value': { if (that.mode === 'date') { value = LW.Utilities.DateTime.validateDate(value); value = value.getTimeStamp(); } that._validateValue(value, oldValue); const stringValue = value.toString(); if (that.value.toString() === stringValue) { that._drawValue = that.logarithmicScale ? Math.log10(stringValue).toString() : stringValue; } that._animate(oldValue); break; } case 'wordLength': if (that.mode === 'date') { that.wordLength = 'uint64'; return; } that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength); if (that.scaleType === 'integer') { validateMinMax(true, true, that.min, that.max); } break; default: super.propertyChangedHandler(key, oldValue, value); } } /** * Draws the Gauge's analog display. */ _addAnalogDisplay() { const that = this, measurements = that._measurements, radius = measurements.radius, draw = that._draw; if (that.analogDisplayType === 'needle') { // needle that._drawNeedle(false); // central circle const centralCircleRadius = (measurements.needleWidth + 5) / 2; that._centralCircle = draw.circle(radius, radius, centralCircleRadius, { 'class': 'lw-needle-central-circle' }); that._minCoordinates.push(radius - centralCircleRadius); that._maxCoordinates.push(radius + centralCircleRadius); } else { const distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1; // track that._track = draw.pieslice(radius, radius, distance - measurements.trackWidth, distance, that.startAngle, that.endAngle, 0, { 'class': 'lw-track' }); that._trackListener = new LW.Utilities.InputEvents(that._track); that._trackListener.down(function (event) { that._SVGElementDownHandler(event); }); } } /** * Calculates the tick drawing distance. */ _calculateTickAndLabelDistance() { const that = this, measurements = that._measurements; if (that.scalePosition === 'none') { that._plotLabels = false; that._plotTicks = false; measurements.innerRadius = measurements.radius; return { majorTickDistance: 0, minorTickDistance: 0, labelDistance: 0, needleDistance: 0, trackDistance: 0 }; } const labelsSize = that._tickIntervalHandler.labelsSize, labelSizeCoefficient = that._largestLabelSize || Math.max(labelsSize.minLabelSize, labelsSize.minLabelOtherSize, labelsSize.maxLabelSize, labelsSize.maxLabelOtherSize); let majorTickDistance = 1, minorTickDistance, labelDistance, needleDistance, trackDistance = 0; that._largestLabelSize = labelSizeCoefficient; if (that.scalePosition === 'outside') { majorTickDistance = labelSizeCoefficient; minorTickDistance = majorTickDistance + measurements.majorTickSize - measurements.minorTickSize; labelDistance = 0; } if (that.analogDisplayType === 'needle') { if (that.scalePosition === 'outside') { needleDistance = majorTickDistance + measurements.majorTickSize; } else { needleDistance = majorTickDistance + measurements.majorTickSize + labelSizeCoefficient; } if (that.ticksVisibility === 'none') { labelDistance = 0; needleDistance -= measurements.majorTickSize; } if (that.labelsVisibility === 'none') { needleDistance -= labelSizeCoefficient; if (that.scalePosition === 'outside') { majorTickDistance -= labelSizeCoefficient; minorTickDistance -= labelSizeCoefficient; } } } else { if (that.labelsVisibility === 'none' && that.ticksVisibility === 'none') { trackDistance = 0; } else { if (that.scalePosition === 'outside') { if (that.ticksPosition === 'scale') { if (that.labelsVisibility === 'none') { majorTickDistance = 1; minorTickDistance = 1 + measurements.majorTickSize - measurements.minorTickSize; } if (that.ticksVisibility !== 'none') { trackDistance = majorTickDistance + measurements.majorTickSize + 2; } else { trackDistance = labelSizeCoefficient; } } else { if (that.labelsVisibility !== 'none') { minorTickDistance = minorTickDistance - (measurements.trackWidth + measurements.trackBorderWidth) / 4; trackDistance = majorTickDistance - 1; } else { majorTickDistance = 1; minorTickDistance = (measurements.trackWidth + measurements.trackBorderWidth) / 4 + 1; trackDistance = 0; } } } else { if (that.ticksPosition === 'scale') { majorTickDistance = measurements.trackWidth + 1.5 * measurements.trackBorderWidth + 2; if (that.ticksVisibility === 'none') { labelDistance = majorTickDistance; } } else { minorTickDistance = (measurements.trackWidth + measurements.trackBorderWidth) / 4 + 1; } } } } if (minorTickDistance === undefined) { minorTickDistance = majorTickDistance; } if (labelDistance === undefined) { labelDistance = majorTickDistance + measurements.majorTickSize; } measurements.innerRadius = measurements.radius - labelDistance; delete that._plotLabels; delete that._plotTicks; delete that._equalToHalfRadius; if (that.scalePosition === 'inside') { if (measurements.innerRadius < labelSizeCoefficient) { that._plotLabels = false; if (that.ticksPosition === 'scale') { if (that.analogDisplayType !== 'needle' && measurements.innerRadius < measurements.majorTickSize) { that._plotTicks = false; } } else { that._equalToHalfRadius = true; measurements.innerRadius = measurements.radius / 2; } } } else if (measurements.radius - trackDistance - measurements.trackBorderWidth < measurements.trackWidth) { measurements.trackWidth = measurements.radius - trackDistance - measurements.trackBorderWidth; measurements.lineSize = measurements.trackWidth + measurements.trackBorderWidth; if (that.ticksPosition === 'track') { measurements.majorTickSize = measurements.lineSize; measurements.minorTickSize = measurements.majorTickSize / 2; minorTickDistance = majorTickDistance + (measurements.majorTickSize - measurements.minorTickSize) / 2; } } return { majorTickDistance: majorTickDistance, minorTickDistance: minorTickDistance, labelDistance: labelDistance, needleDistance: needleDistance, trackDistance: trackDistance }; } /** * Calculates the tank's major and minor ticks intervals. */ _calculateTickInterval() { const that = this, intervals = that._tickIntervalHandler.getInterval('radial', that._drawMin, that._drawMax, that.$.container, that.logarithmicScale); if (intervals.major !== that._majorTicksInterval) { that._intervalHasChanged = true; that._majorTicksInterval = intervals.major; } else { that._intervalHasChanged = true; } that._minorTicksInterval = intervals.minor; if (that.mode === 'date') { that._calculateDateInterval(intervals.major); } } /** * Computes the points of a needle (needlePosition: 'center'). */ _computeNeedlePointsCenter(pointerWidth, angle) { const that = this, measurements = that._measurements, innerRadius = measurements.innerRadius, radius = measurements.radius, sin = Math.sin(angle), cos = Math.cos(angle); let pointerLength; if (that.scalePosition === 'inside') { pointerLength = (innerRadius - that._largestLabelSize) * 0.9; } else { pointerLength = (innerRadius - that._distance.needleDistance) * 0.9; } const x = radius + pointerLength * sin, y = radius + pointerLength * cos, startX1 = radius + pointerWidth * cos, startY1 = radius - pointerWidth * sin, startX2 = radius - pointerWidth * cos, startY2 = radius + pointerWidth * sin, points = 'M ' + startX1 + ',' + startY1 + ' L ' + startX2 + ',' + startY2 + ' L ' + x + ',' + y + ' Z'; return points; } /** * Computes the points of a needle (needlePosition: 'edge'). */ _computeNeedlePointsEdge(pointerWidth, angle, pointerLength) { const that = this, radius = that._measurements.radius, distance = radius - that._distance.needleDistance, distanceMinusPointerLength = distance - pointerLength, sin = Math.sin(angle), cos = Math.cos(angle), hPointX = radius + distanceMinusPointerLength * sin, hPointY = radius + distanceMinusPointerLength * cos, startPointX1 = hPointX + pointerWidth * cos, startPointY1 = hPointY - pointerWidth * sin, startPointX2 = hPointX - pointerWidth * cos, startPointY2 = hPointY + pointerWidth * sin, endPointX = radius + distance * sin, endPointY = radius + distance * cos, points = 'M ' + startPointX1 + ',' + startPointY1 + ' L ' + startPointX2 + ',' + startPointY2 + ' L ' + endPointX + ',' + endPointY + ' Z'; return points; } /** * Document (mouse)move event handler. */ _documentMoveHandler(event) { if (!this._dragging) { return; } const that = this, angle = that._getAngleByCoordinate(event.pageX, event.pageY), quadrant = that._getQuadrant(angle), rotationDirection = that._getRotationDirection(); if (that._normalizedStartAngle === that.endAngle) { let normalizedReferentAngle; if ((!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { if (that._lockCW && rotationDirection === 'ccw') { normalizedReferentAngle = that.endAngle; that._unlockRotation('_lockCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle > normalizedReferentAngle, secondCondition: angle < normalizedReferentAngle }); } else if (that._lockCCW && rotationDirection === 'cw') { normalizedReferentAngle = that._normalizedStartAngle; that._unlockRotation('_lockCCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle < normalizedReferentAngle, secondCondition: angle > normalizedReferentAngle }); } } else { if (that._lockCW && rotationDirection === 'cw') { normalizedReferentAngle = that._normalizedStartAngle; that._unlockRotation('_lockCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle < normalizedReferentAngle, secondCondition: angle > normalizedReferentAngle }); } else if (that._lockCCW && rotationDirection === 'ccw') { normalizedReferentAngle = that.endAngle; that._unlockRotation('_lockCCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle > normalizedReferentAngle, secondCondition: angle < normalizedReferentAngle }); } } } else { if (that._lockCW && rotationDirection === 'ccw' && !that._outsideRange && that._numericProcessor._getAngleDifference(angle, that._normalizedStartAngle) < 10) { that._lockCW = false; } else if (that._lockCCW && rotationDirection === 'cw' && !that._outsideRange && that._numericProcessor._getAngleDifference(angle, that.endAngle) < 10) { that._lockCCW = false; } } that._angle = angle; that._quadrant = quadrant; if (event.originalEvent) { event.originalEvent.stopPropagation(); event.originalEvent.preventDefault(); } if (that._lockCW || that._lockCCW) { return; } let newValue = that._numericProcessor.getValueByAngle(angle); if (that._normalizedStartAngle === that.endAngle) { const lockedValue = that._numericProcessor.lockRotation(rotationDirection === 'cw' && (!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted) || rotationDirection === 'ccw' && (that.inverted || (that.rightToLeft && !that.inverted)), newValue); if (lockedValue !== undefined) { newValue = lockedValue; } } else { if (rotationDirection === 'ccw' && that._outsideEnd) { that._lockCCW = true; } else if (rotationDirection === 'cw' && that._outsideStart) { that._lockCW = true; } } if (newValue !== undefined && that._numericProcessor.compare(newValue, that.value)) { cancelAnimationFrame(that._animationFrameId); that._updatePointer(newValue); if (that.mechanicalAction !== 'switchWhenReleased') { that._numericProcessor.updateGaugeValue(newValue); } else { that._valueAtMoveEnd = newValue; } } } /** * Gauge (mouse)up event handler. */ _documentUpHandler() { const that = this; if (that._dragging) { that._lockCW = false; that._lockCCW = false; that._dragging = false; that.removeAttribute('dragged'); if (that.mechanicalAction !== 'switchWhileDragging') { const newValue = that.mechanicalAction === 'switchUntilReleased' ? that._valueAtDragStart : that._valueAtMoveEnd; if (that._numericProcessor.compare(newValue, that.value)) { if (that.mechanicalAction === 'switchUntilReleased') { that._animate(that.value, newValue); } that._numericProcessor.updateGaugeValue(newValue); } } } } /** * Gauge (mouse)down event handler. */ _downHandler(event, targetIsTrack) { const that = this, target = that.enableShadowDOM || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.analogDisplayType !== 'needle' && !targetIsTrack || that.disabled || that.readonly || that.$.digitalDisplay.contains(target) || (!LW.Utilities.Core.isMobile && (('buttons' in event && event.buttons !== 1) || event.which !== 1))) { event.stopPropagation(); return; } const x = event.pageX, y = event.pageY; that._measurements.center = that._getCenterCoordinates(); if (that.analogDisplayType === 'needle') { const distanceFromCenter = Math.sqrt(Math.pow(that._measurements.center.x - x, 2) + Math.pow(that._measurements.center.y - y, 2)); if (distanceFromCenter > that._measurements.radius) { event.stopPropagation(); return; } } if (that.mechanicalAction === 'switchUntilReleased') { that._valueAtDragStart = that.value; } that._angle = that._getAngleByCoordinate(x, y); that._quadrant = that._getQuadrant(that._angle); const newValue = that._numericProcessor.getValueByAngle(that._angle); if (newValue !== undefined && that._numericProcessor.compare(newValue, that.value)) { that._animate(that.value, newValue); if (that.mechanicalAction !== 'switchWhenReleased') { that._numericProcessor.updateGaugeValue(newValue); } else { that._valueAtMoveEnd = newValue; } } that._dragging = true; that.setAttribute('dragged', ''); } /** * Animates pointer. */ _animate(oldValue, newValue) { const that = this, logarithmicScale = that.logarithmicScale, totalIterations = Math.max(1, Math.round(that.animationDuration / 15)); cancelAnimationFrame(that._animationFrameId); if (!that.hasAnimation || totalIterations === 1) { that._updatePointer(newValue); return; } const numericProcessor = that._numericProcessor; let i = 1, nextValue, getNextValue, oldDrawValue, newDrawValue; if (newValue === undefined) { newValue = that.value; } oldValue = parseFloat(numericProcessor.validate(numericProcessor.createDescriptor(oldValue), that._minObject, that._maxObject)); newValue = parseFloat(numericProcessor.validate(numericProcessor.createDescriptor(newValue), that._minObject, that._maxObject)); if (logarithmicScale) { oldDrawValue = Math.log10(oldValue); newDrawValue = Math.log10(newValue); } else { oldDrawValue = oldValue; newDrawValue = newValue; } const total = Math.abs(newDrawValue - oldDrawValue); if (newValue > oldValue) { getNextValue = function () { return Math.min(LW.Utilities.Animation.Easings.easeInOutSine(i, oldDrawValue, total, totalIterations), newDrawValue); } } else { getNextValue = function () { return Math.max(2 * oldDrawValue - LW.Utilities.Animation.Easings.easeInOutSine(i, oldDrawValue, total, totalIterations), newDrawValue); } } function getNextDrawValue() { nextValue = getNextValue(); if (logarithmicScale) { nextValue = Math.pow(10, nextValue); } } function animate() { i++; if (i === totalIterations) { nextValue = newValue; that._updatePointer(nextValue); return; } that._updatePointer(nextValue); getNextDrawValue(); that._animationFrameId = requestAnimationFrame(animate); } getNextDrawValue(); that._animationFrameId = requestAnimationFrame(animate); } /** * Draws/updates the fill or line. */ _drawFill(update, value) { const that = this; if (that.analogDisplayType === 'needle') { return; } if (value === undefined) { value = that._number; } const measurements = that._measurements, radius = measurements.radius, distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1; if (that.analogDisplayType === 'fill') { const angle = that._numericProcessor.getAngleByValue(value, true, true); let startAngle, endAngle; if ((!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { startAngle = angle; endAngle = that.endAngle; } else { startAngle = that.startAngle; endAngle = angle; } if (update) { that._fill.setAttribute('d', that._draw.pieSlicePath(radius, radius, distance - measurements.trackWidth, distance, startAngle, endAngle, 0)); } else { that._fill = that._draw.pieslice(radius, radius, distance - measurements.trackWidth, distance, startAngle, endAngle, 0, { 'class': 'lw-value' }); that._fillListener = new LW.Utilities.InputEvents(that._fill); that._fillListener.down(function (event) { that._SVGElementDownHandler(event); }); } } else { const width = distance + measurements.trackBorderWidth / 2, innerWidth = width - measurements.lineSize, angle = that._numericProcessor.getAngleByValue(value), angleSin = Math.sin(angle), angleCos = Math.cos(angle), x1 = radius + width * angleSin, y1 = radius + width * angleCos, x2 = radius + innerWidth * angleSin, y2 = radius + innerWidth * angleCos; if (update) { that._line.setAttribute('x1', x1); that._line.setAttribute('y1', y1); that._line.setAttribute('x2', x2); that._line.setAttribute('y2', y2); } else { that._line = that._draw.line(x1, y1, x2, y2, { 'class': 'lw-line' }); that._lineListener = new LW.Utilities.InputEvents(that._line); that._lineListener.down(function (event) { that._SVGElementDownHandler(event); }); } } } /** * Draws a label. */ _drawLabel(angle, value, distance, middle) { const that = this, measurements = that._measurements, r = measurements.radius, stylingObj = { 'class': 'lw-label' + (middle !== false ? ' lw-label-middle' : ''), 'font-size': measurements.fontSize, 'font-family': measurements.fontFamily, 'font-weight': measurements.fontWeight, 'font-style': measurements.fontStyle }; value = that._formatLabel(value.toString(), false); const textSize = that._draw.measureText(value, 0, stylingObj), w = r - distance - that._largestLabelSize / 2, x = Math.round(r + w * Math.sin(angle)) - textSize.width / 2, y = Math.round(r + w * Math.cos(angle)) - textSize.height / 2, label = that._draw.text(value, x, y, textSize.width, textSize.height, 0, stylingObj); that._minCoordinates.push(y); that._maxCoordinates.push(y + label.getBBox().height); } /** * Draws/updates the needle. */ _drawNeedle(update, value) { const that = this, measurements = that._measurements; if (value === undefined) { value = that._number; } const angle = that._numericProcessor.getAngleByValue(value); if (!that.drawNeedle) { let points; if (that.needlePosition === 'center') { points = that._computeNeedlePointsCenter(measurements.needleWidth / 2, angle); } else { points = that._computeNeedlePointsEdge(measurements.needleWidth / 2, angle, measurements.needleLength); } if (update) { that._needle.setAttribute('d', points); } else { that._needle = that._draw.path(points, { 'class': 'lw-needle' }); } } else { that._customSVGElements = that.drawNeedle(that, that._draw, measurements.radius, angle, that._distance.needleDistance); if (that._customSVGElements) { const parent = that._customSVGElements[0].parentElement || that._customSVGElements[0].parentNode; for (let i = 0; i < that._customSVGElements.length; i++) { parent.insertBefore(that._customSVGElements[i], that._centralCircle); } } } } /** * Draws ranges. */ _drawRanges() { const that = this, numericProcessor = that._numericProcessor, ranges = that.ranges; if (!that.showRanges || ranges.length === 0) { return; } const measurements = that._measurements, radius = measurements.radius; let distance, rangeSize, startValue, endValue; if (that.analogDisplayType === 'needle') { rangeSize = measurements.rangeSize; if (that.scalePosition === 'inside') { distance = radius - 1; } else { distance = radius - that._distance.needleDistance - 2; if (that.labelsVisibility === 'none' && that.ticksVisibility === 'none') { distance += 1; } } } else { distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1; rangeSize = measurements.trackWidth; } if ((!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { startValue = 'startValue'; endValue = 'endValue'; } else { startValue = 'endValue'; endValue = 'startValue'; } for (let i = 0; i < ranges.length; i += 1) { let currentRange = ranges[i], validStartValue = numericProcessor.validateColorRange(currentRange[startValue]), validEndValue = numericProcessor.validateColorRange(currentRange[endValue]); const range = that._draw.pieslice(radius, radius, distance - rangeSize, distance, numericProcessor.getAngleByValue(validEndValue, true, true), numericProcessor.getAngleByValue(validStartValue, true, true), 0, { 'class': 'lw-range ' + currentRange.className }); that._ranges.push(range); } } /** * Draws a tick. */ _drawTick(angle, width, type) { const that = this, measurements = that._measurements, r = measurements.radius; let className = 'lw-tick', size; if (type === 'major') { size = measurements.majorTickSize; } else { size = measurements.minorTickSize; className += ' lw-tick-minor'; } const innerWidth = width - size, x1 = r + width * Math.sin(angle), y1 = r + width * Math.cos(angle), x2 = r + innerWidth * Math.sin(angle), y2 = r + innerWidth * Math.cos(angle); that._draw.line(x1, y1, x2, y2, { 'class': className }); that._minCoordinates.push(Math.min(y1, y2)); that._maxCoordinates.push(Math.max(y1, y2)); } /** * Returns the angle equivalent of coordinates. */ _getAngleByCoordinate(x, y) { function isInRange(from, to, angle) { while (to < from) to += 360; while (angle < from) angle += 360; return angle >= from && angle <= to; } const that = this, center = that._measurements.center, angleRadians = Math.atan2(y - center.y, x - center.x); let angleDeg = -1 * angleRadians * 180 / Math.PI; if (angleDeg < 0) { angleDeg += 360; } that._actualAngle = angleDeg; if (that._normalizedStartAngle !== that.endAngle && !isInRange(that._normalizedStartAngle, that.endAngle, angleDeg)) { // coordinates are outside the range if (that._numericProcessor._getAngleDifference(angleDeg, that._normalizedStartAngle) <= that._numericProcessor._getAngleDifference(angleDeg, that.endAngle)) { angleDeg = that._normalizedStartAngle; that._outsideStart = true; that._outsideEnd = false; } else { angleDeg = that.endAngle; that._outsideEnd = true; that._outsideStart = false; } that._outsideRange = true; } else { that._outsideRange = false; that._outsideStart = false; that._outsideEnd = false; } return angleDeg; } /** * Returns the coordinates of the Gauge's center. */ _getCenterCoordinates() { const that = this, offset = that.$.container.getBoundingClientRect(), radius = that._measurements.radius, scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft, scrollTop = document.body.scrollTop || document.documentElement.scrollTop; return { x: offset.left + scrollLeft + radius, y: offset.top + scrollTop + radius }; } /** * Gets inline "fill"/"stroke" set to _track, _fill or _line. */ _getInlineColors() { const that = this; let trackColor = '', fillColor = '', lineColor = ''; if (that._track) { trackColor = that._track.style.fill; } if (that._fill) { fillColor = that._fill.style.fill; } if (that._line) { lineColor = that._line.style.stroke; } return [trackColor, fillColor, lineColor]; } /** * Measures some elements of the Gauge and stores the results. */ _getMeasurements() { const that = this; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } const measurements = that._measurements; measurements.cachedWidth = that.offsetWidth; measurements.cachedHeight = that.offsetHeight; measurements.radius = measurements.cachedWidth / 2; const measureElement = document.createElement('div'); if (that.shadowRoot) { that.shadowRoot.appendChild(measureElement); } else { that.appendChild(measureElement); } // ticks measureElement.className = 'lw-tick'; measurements.majorTickSize = measureElement.offsetWidth; measureElement.className += ' lw-tick-minor'; measurements.minorTickSize = measureElement.offsetWidth; // labels measureElement.className = 'lw-label'; const measureElementStyle = window.getComputedStyle(measureElement); measurements.fontSize = measureElementStyle.fontSize; measurements.fontFamily = measureElementStyle.fontFamily; measurements.fontWeight = measureElementStyle.fontWeight; measurements.fontStyle = measureElementStyle.fontStyle; measurements.trackWidth = 0; measurements.trackBorderWidth = 0; if (that.analogDisplayType === 'needle') { // needle measureElement.className = 'lw-needle'; measurements.needleWidth = measureElement.offsetWidth; measurements.needleLength = measureElement.offsetHeight; // ranges measureElement.className = 'lw-range'; measurements.rangeSize = measureElement.offsetWidth; } else { // 'fill' and 'line' case // track measureElement.className = 'lw-track'; measurements.trackBorderWidth = parseFloat(measureElementStyle.strokeWidth); measurements.trackWidth = Math.min(measureElement.offsetWidth, measurements.radius - measurements.trackBorderWidth) measurements.lineSize = measurements.trackWidth + measurements.trackBorderWidth; if (that.ticksPosition === 'track') { measurements.majorTickSize = measurements.lineSize; measurements.minorTickSize = measurements.majorTickSize / 2; } } if (that.shadowRoot) { that.shadowRoot.removeChild(measureElement); } else { that.removeChild(measureElement); } } /** * Returns the quadrant of an angle. */ _getQuadrant(angle) { if (angle > 270) { return 4; } else if (angle > 180) { return 3; } else if (angle > 90) { return 2; } else { return 1; } } /** * Returns the rotation direction. */ _getRotationDirection() { const that = this, quadrant = that._getQuadrant(that._actualAngle); if ((that._actualAngle < that._angle && (quadrant !== 1 || that._quadrant !== 4)) || (that._actualAngle > that._angle && quadrant === 4 && that._quadrant === 1)) { return 'cw'; } else { return 'ccw'; } } /** * Creates a new TickIntervalHandler instance. */ _initTickIntervalHandler() { const that = this; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } const minLabel = that._formatLabel(that.min, false), maxLabel = that._formatLabel(that.max, false); that._tickIntervalHandler = new LW.Utilities.TickIntervalHandler(that, minLabel, maxLabel, 'lw-label', that._settings.size, that.scaleType === 'integer', that.logarithmicScale); } /** * Gauge keydown event handler. */ _keydownHandler(event) { const that = this, oldValue = that._getEventValue(), stringValue = that._number.toString(); if (that.mode === 'numeric') { if (that.value.toString() !== stringValue) { that.value = stringValue; that.$.digitalDisplay.value = stringValue; } super._keydownHandler(event); if (that.value.toString() !== oldValue) { that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue }); } } else { if (that.value.toString() !== stringValue) { that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(stringValue); that.value = that._number; } super._keydownHandler(event); if (that._valueDate.compare(oldValue) !== 0) { that.$.fireEvent('change', { 'value': that._getEventValue(), 'oldValue': oldValue }); } } that._setAriaValue('valuenow'); } /** * Normalizes the value of an angle. */ _normalizeAngle(angle) { angle = angle % 360; if (angle < 0) { angle += 360; } return angle; } /** * Renders the analog display, ticks and labels in the correct order */ _renderAnalogItems(distanceCalculation) { const that = this; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } const colors = that._getInlineColors(); that._unlisten(); that._draw.clear(); delete that._needle; delete that._centralCircle; delete that._track; delete that._trackListener; delete that._fill; delete that._fillListener; delete that._line; delete that._lineListener; that._ranges = []; that._minCoordinates = []; that._maxCoordinates = []; if (distanceCalculation !== false) { delete that._largestLabelSize; that._distance = that._calculateTickAndLabelDistance(); } if (that._plotTicks !== false || that._plotLabels !== false) { that._calculateTickInterval(); const cachedLabelsSize = that._cachedLabelsSize, alternativeLargestLabelSize = Math.max(cachedLabelsSize.minLabelSize, cachedLabelsSize.minLabelOtherSize, cachedLabelsSize.maxLabelSize, cachedLabelsSize.maxLabelOtherSize); if (distanceCalculation !== false && that._largestLabelSize !== alternativeLargestLabelSize) { that._largestLabelSize = alternativeLargestLabelSize; that._distance = that._calculateTickAndLabelDistance(); that._calculateTickInterval(); } } if (that._coerceInitialDateValue) { that._validateValue(); delete that._coerceInitialDateValue; } that._drawRanges(); that._addAnalogDisplay(); if (that.ticksVisibility !== 'none' && that._plotTicks !== false || that.labelsVisibility !== 'none' && that._plotLabels !== false) { if (!(that.customInterval || that._dateInterval)) { that._numericProcessor.addGaugeTicksAndLabels(); } else { that._numericProcessor.addGaugeCustomTicks(); } } that._drawFill(false); that._updateSize(); that._restoreInlineColors(colors[0], colors[1], colors[2]); } /** * Gauge resize event handler. Ensures the Gauge's bounding box always has the correct proportions. */ _resizeHandler() { const that = this; if (that._preventResizeHandler) { delete that._preventResizeHandler; return; } if (!that._isVisible()) { that._renderingSuspended = true; return; } else if (that._renderingSuspended) { that._createElement(); return; } const measurements = that._measurements; if (that._renderingSuspended || measurements.cachedWidth === that.offsetWidth && measurements.cachedHeight === that.offsetHeight) { return; } if (that.sizeMode === 'circle') { if (that.offsetWidth !== that.offsetHeight) { if (measurements.cachedWidth !== that.offsetWidth) { that.style.height = that.offsetWidth + 'px'; that._preventResizeHandler = true; } else if (measurements.cachedHeight !== that.offsetHeight) { that.style.width = that.offsetHeight + 'px'; that._preventResizeHandler = true; } } } else if (that.sizeMode === 'auto') { if (measurements.cachedHeight !== that.offsetHeight && measurements.cachedWidth === that.offsetWidth) { that.style.height = measurements.cachedHeight + 'px'; that._preventResizeHandler = true; return; } that.$.container.style.height = that.offsetWidth + 'px'; } measurements.cachedWidth = that.offsetWidth; measurements.cachedHeight = that.offsetHeight; measurements.radius = measurements.cachedWidth / 2; if (!that._equalToHalfRadius) { measurements.innerRadius = measurements.radius - that._distance.labelDistance; } else { measurements.innerRadius = measurements.radius / 2; } that._renderAnalogItems(false); } /** * Restores inline "fill"/"stroke" previously set to _track, _fill or _line. */ _restoreInlineColors(trackColor, fillColor, lineColor) { const that = this; if (that._track && trackColor !== '') { that._track.style.fill = trackColor; } if (that._fill && fillColor !== '') { that._fill.style.fill = fillColor; } if (that._line && lineColor !== '') { that._line.style.stroke = lineColor; } } /** * Document select start handler. */ _selectStartHandler(event) { if (this._dragging) { event.preventDefault(); } } /** * Specifies the behaviour of the method "_updatePointer". */ _setUpdatePointerMethod() { const that = this; if (that.analogDisplayType === 'needle') { that._updatePointer = function (value) { if (that._customSVGElements) { for (let i = 0; i < that._customSVGElements.length; i++) { that._draw.removeElement(that._customSVGElements[i]); } } that._drawNeedle(true, value); } } else { that._updatePointer = function (value) { that._drawFill(true, value); } } } /** * styleChanged event handler. */ _styleChangedHandler(event) { const that = this; if (event.detail.styleProperties && event.detail.styleProperties['min-height']) { return; } if (!that._isVisible()) { that._renderingSuspended = true; return; } else if (that._renderingSuspended) { that._createElement(); return; } that._getMeasurements(); that._initTickIntervalHandler(); that._renderAnalogItems(); } /** * (Mouse)down event handler for the track, fill and line SVG elements. */ _SVGElementDownHandler(event) { const that = this, oldContext = that.context; that.context = that; that._downHandler(event, true); that.context = oldContext; } /** * Unlocks rotation of the analog display. */ _unlockRotation(lockName, angle, quadrant, referentAngle, conditions) { const that = this, firstCondition = conditions.firstCondition, secondCondition = conditions.secondCondition, angleQuadrant = that._getQuadrant(referentAngle); if (((firstCondition && (quadrant !== 4 || angleQuadrant !== 1)) || (secondCondition && (quadrant === 4 && angleQuadrant === 1))) && that._numericProcessor._getAngleDifference(angle, referentAngle) < 10) { that[lockName] = false; } } /** * Updates the size of the Gauge when "sizeMode" is 'auto'. */ _updateSize(getter) { const that = this; if (that.sizeMode !== 'auto' && getter === undefined) { return; } const minCoordinates = that._minCoordinates, maxCoordinates = that._maxCoordinates; let top = minCoordinates[0], bottom = maxCoordinates[0]; for (let i = 1; i < minCoordinates.length; i++) { top = Math.min(top, minCoordinates[i]); } for (let i = 1; i < maxCoordinates.length; i++) { bottom = Math.max(bottom, maxCoordinates[i]); } const gaugeClientRect = that.getBoundingClientRect(); if (that.digitalDisplay) { const digitalDisplayClientRect = that.$.digitalDisplay.getBoundingClientRect(); top = Math.min(top, digitalDisplayClientRect.top - gaugeClientRect.top); bottom = Math.max(bottom, digitalDisplayClientRect.bottom - gaugeClientRect.top); } if (that.analogDisplayType !== 'needle') { const trackBBox = that._track.getBBox(); top = Math.min(top, trackBBox.y); bottom = Math.max(bottom, trackBBox.y + trackBBox.height); } for (let i = 0; i < that._ranges.length; i++) { const rangeBBox = that._ranges[i].getBBox(); top = Math.min(top, rangeBBox.y - gaugeClientRect.top); bottom = Math.max(bottom, rangeBBox.y + rangeBBox.height - gaugeClientRect.top); } top -= 2; const newHeight = bottom - top; if (getter === undefined) { that._preventResizeHandler = true; that.style.height = newHeight + 'px'; that.$.container.style.marginTop = -1 * top + 'px'; that._measurements.cachedHeight = newHeight; } else { return Math.round(newHeight); } } /** * Updates the values of the Gauge and its digital display and fires the "change" event. */ _updateValue(newValue) { this._numericProcessor.updateGaugeValue(newValue); } /** * Validates the value and updates the pointer. */ _validate(initialValidation, programmaticValue, keyCode) { const that = this, oldValue = that.value; that._validateValue(programmaticValue); if (keyCode && (keyCode === 35 || keyCode === 36)) { that._animate(oldValue); } else { that._updatePointer(); } } /** * Validates the startAngle and endAngle properties. */ _validateAngles() { const that = this; that._normalizedStartAngle = that._normalizeAngle(that.startAngle); that.endAngle = that._normalizeAngle(that.endAngle); if (that._normalizedStartAngle < that.endAngle) { that.startAngle = that._normalizedStartAngle; } else { that.startAngle = that._normalizedStartAngle - 360; } that._angleDifference = that.endAngle - that.startAngle; } /** * Validates initial property values. */ _validateInitialPropertyValues() { super._validateInitialPropertyValues(); const that = this; if (that.sizeMode === 'circle') { if (that.offsetWidth < that.offsetHeight) { that.style.height = that.offsetWidth + 'px'; } else if (that.offsetWidth > that.offsetHeight) { that.style.width = that.offsetHeight + 'px'; } } else if (that.sizeMode === 'auto') { if (that.offsetHeight !== that.offsetWidth) { that.style.height = that.offsetWidth + 'px'; } that.$.container.style.height = that.offsetWidth + 'px'; } that._validateAngles(); if (that.significantDigits !== null) { that.$.digitalDisplay.significantDigits = that.significantDigits; } else if (that.precisionDigits !== null) { that.$.digitalDisplay.precisionDigits = that.precisionDigits; } } /** * Validates the Gauge's value. */ _validateValue(value, oldValue) { const that = this, numericProcessor = that._numericProcessor, logarithmicGauge = that.logarithmicScale, strictValidation = that.validation === 'strict'; let fireEvent = strictValidation && oldValue !== undefined; if (value === undefined) { fireEvent = false; value = that.value; } else { value = value.toString(); } if (numericProcessor.regexScientificNotation.test(value)) { value = numericProcessor.scientificToDecimal(value); } if (isNaN(value)) { value = oldValue || 0; } let valueNoRangeValidation, stringValueNoRangeValidation, stringValue; if (that.coerce) { valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, true), false, logarithmicGauge); that._number = valueNoRangeValidation; stringValueNoRangeValidation = valueNoRangeValidation.toString(); stringValue = stringValueNoRangeValidation; } else if (strictValidation) { valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, true), false, logarithmicGauge); that._number = valueNoRangeValidation; stringValueNoRangeValidation = valueNoRangeValidation.toString(); stringValue = stringValueNoRangeValidation; } else { fireEvent = false; valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, false), false, logarithmicGauge); that._number = numericProcessor.validate(valueNoRangeValidation, numericProcessor.createDescriptor(that._minObject), numericProcessor.createDescriptor(that._maxObject)); stringValueNoRangeValidation = valueNoRangeValidation.toString(); stringValue = that._number.toString(); } let oldValueDetail, valueDetail; if (that.mode === 'numeric') { oldValueDetail = oldValue; valueDetail = stringValueNoRangeValidation; that.value = stringValueNoRangeValidation; // the "value" property continues to return the value set by the user that.$.digitalDisplay.value = stringValueNoRangeValidation; } else { oldValueDetail = that._valueDate; that._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(stringValueNoRangeValidation); valueDetail = that._valueDate; that.value = valueNoRangeValidation; } that._drawValue = logarithmicGauge ? Math.log10(stringValue).toString() : stringValue; if (fireEvent && (numericProcessor.compare(that._number, oldValue))) { that.$.fireEvent('change', { 'value': valueDetail, 'oldValue': oldValueDetail }); } that._setAriaValue('valuenow'); delete that._valueBeforeCoercion; } /** * Removes custom event listeners. */ _unlisten() { const that = this; if (that._trackListener) { that._trackListener.unlisten(); } if (that._fillListener) { that._fillListener.unlisten(); } if (that._lineListener) { that._lineListener.unlisten(); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Slider custom element. */ LW('lw-slider', class Slider extends LW.Tank { /** * Slider's properties. */ static get properties() { return { 'enableMouseWheelAction': { value: false, type: 'boolean' }, 'orientation': { value: 'horizontal', allowedValues: ['horizontal', 'vertical'], type: 'string', defaultReflectToAttribute: true }, 'rangeSlider': { value: false, type: 'boolean' }, 'showButtons': { value: false, type: 'boolean' }, 'values': { value: ['0', '100'], type: 'array' } }; } /** * Slider's event listeners. */ static get listeners() { return { 'track.down': '_trackDownHandler', 'thumb.down': '_thumbDownHandler', 'secondThumb.down': '_thumbDownHandler', 'thumb.mouseleave': '_thumbMoveMouseleaveHandler', 'secondThumb.mouseleave': '_thumbMoveMouseleaveHandler', 'thumb.move': '_thumbMoveMouseleaveHandler', 'secondThumb.move': '_thumbMoveMouseleaveHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler', 'leftButton.click': '_spinButtonClickHandler', 'rightButton.click': '_spinButtonClickHandler', 'keydown': '_keydownHandlerSlider', 'keyup': '_keyupHandlerSlider', 'resize': '_resizeAndStyleChangedHandler', 'styleChanged': '_resizeAndStyleChangedHandler', 'document.selectstart': '_selectStartHandler', 'wheel': '_wheelHandler' }; } /** * Slider's required files. */ static get requires() { return { 'LW.RepeatButton': 'lw.button.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.slider.css', 'lw.button.css' ] } /** * Slider's HTML template. */ template() { const template = `<div id="container" class="lw-container" role="presentation"> <div id="scaleNear" class="lw-scale lw-scale-near" aria-hidden="true"></div> <div id="trackContainer" class="lw-track-container" role="presentation"> <lw-repeat-button id="leftButton" class="lw-spin-button" animation="[[animation]]" unfocusable> <div id="leftArrow" class="lw-arrow" aria-hidden="true"></div> </lw-repeat-button> <div id="track" class="lw-track" role="presentation"> <div id="fill" class="lw-value" role="presentation"></div> <div id="trackTicksContainer" class="lw-track-ticks-container lw-hidden" role="presentation"></div> <div id="thumb" class="lw-thumb" role="slider"> <span id="thumbLabel" class="lw-thumb-label" role="presentation"></span> <div id="tooltip" class="lw-tooltip" role="tooltip"> <div id="tooltipContent" class="lw-tooltip-content lw-unselectable" role="presentation"></div> </div> </div> <div id="secondThumb" class="lw-thumb" role="slider"> <span id="secondThumbLabel" class="lw-thumb-label" role="presentation"></span> <div id="secondTooltip" class="lw-tooltip" role="tooltip"> <div id="secondTooltipContent" class="lw-tooltip-content lw-unselectable" role="presentation"></div> </div> </div> </div> <lw-repeat-button id="rightButton" class="lw-spin-button" animation="[[animation]]" unfocusable> <div id="rightArrow" class="lw-arrow" aria-hidden="true"></div> </lw-repeat-button> </div> <div id="scaleFar" class="lw-scale lw-scale-far" aria-hidden="true"></div> <input id="hiddenInput" type="hidden" name="[[name]]"> </div>`; return template; } _createElement() { const that = this, numericScale = that.mode === 'numeric'; if (!that.$.tooltip.id) { that.$.tooltip.id = that.id + 'Tooltip'; that.$.secondTooltip.id = that.id + 'SecondTooltip'; } that.setAttribute('role', 'presentation'); that.setAttribute('aria-describedby', that.$.tooltip.id + ' ' + that.$.secondTooltip.id); if (!that._renderingSuspended) { if (numericScale) { that._redefineProperty('values'); } else if (!numericScale) { that._handleDateScale(); } } that._setSettingsObject(); that._setDrawVariables(); that._getLayoutType(); //Creating instances of NumericProcessor and NumberRenderer that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'scaleType'); that._numberRenderer = new LW.Utilities.NumberRenderer(); if (!that._isVisible()) { that._renderingSuspended = true; return; } that._renderingSuspended = false; that._setInitialComponentDisplay(); that._measurements = {}; that._getMeasurements(); that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength); const valuesHandler = that._valuesHandler = that.rangeSlider ? new LW.Utilities.SliderMultipleValueHandler(that) : new LW.Utilities.SliderSingleValueHandler(that); if (numericScale) { that._getEventValue = function () { return that._valuesHandler.getValue(); }; } that._validateInitialPropertyValues(); that._setTicksAndInterval(); valuesHandler.validate(true); // initial value(s) validation valuesHandler.updateTooltipValue(); window.requestAnimationFrame(function () { that.$thumb.addClass('enable-animation'); that.$secondThumb.addClass('enable-animation'); that.$fill.addClass('enable-animation'); }); that._setFocusable(); that._makeThumbAccessible(); that.$.hiddenInput.value = that._getEventValue(); that.$.thumb.setAttribute('aria-orientation', that.orientation); that.$.secondThumb.setAttribute('aria-orientation', that.orientation); that._setAriaValue('valuenow'); } /* * Public methods */ /** * Sets or gets the value of the slider. * * @param {Number/String} value Optional value to be set to the slider. If this parameter is not set, the method gets the value. */ val(value) { const that = this, valuesHandler = that._valuesHandler; if (value !== undefined) { if (that.mode === 'date') { if (!that.rangeSlider) { value = LW.Utilities.DateTime.validateDate(value); value = value.getTimeStamp(); } else { value[0] = LW.Utilities.DateTime.validateDate(value[0]); value[1] = LW.Utilities.DateTime.validateDate(value[1]); value[0] = value[0].getTimeStamp(); value[1] = value[1].getTimeStamp(); } } // use as value setter if (valuesHandler.areDifferent(value)) { valuesHandler.validate(false, value, true); } } else { // use as value getter return that._getEventValue(); } } /** * Gets the optimal size of the slider. */ getOptimalSize() { const that = this; if (that._renderingSuspended) { return { width: 0, height: 0 }; } const sliderStyle = window.getComputedStyle(that), trackStyle = window.getComputedStyle(that.$.trackContainer); let optimalSize = 0, largestLabelSize, optimalOtherSize, labels, firstLabel, lastLabel, firstRect, lastRect, difference; if (that.labelsVisibility === 'all') { largestLabelSize = that._numericProcessor._longestLabelSize } else if (that.labelsVisibility === 'endPoints') { largestLabelSize = Math.max(that._tickIntervalHandler.labelsSize.minLabelOtherSize, that._tickIntervalHandler.labelsSize.maxLabelOtherSize); } else { largestLabelSize = 0; } if (that.orientation === 'horizontal') { optimalSize += parseFloat(trackStyle.marginTop) + parseFloat(trackStyle.marginBottom) + that.$.track.offsetHeight; if (that.scalePosition === 'near' || that.scalePosition === 'both') { optimalSize += largestLabelSize; labels = that.$.scaleNear.getElementsByClassName('lw-label'); firstLabel = labels[0]; lastLabel = labels[labels.length - 1]; optimalSize += parseFloat(window.getComputedStyle(firstLabel).bottom); } if (that.scalePosition === 'far' || that.scalePosition === 'both') { optimalSize += largestLabelSize; labels = that.$.scaleFar.getElementsByClassName('lw-label'); firstLabel = labels[0]; lastLabel = labels[labels.length - 1]; optimalSize += parseFloat(window.getComputedStyle(firstLabel).top); } optimalSize += parseFloat(sliderStyle.paddingTop) + parseFloat(sliderStyle.paddingBottom); optimalOtherSize = that.offsetWidth; if (that.scalePosition !== 'none') { firstRect = firstLabel.getBoundingClientRect(); lastRect = lastLabel.getBoundingClientRect(); difference = firstRect.left + firstLabel.offsetWidth - lastRect.left; if (difference > 0) { optimalOtherSize = firstLabel.offsetWidth + lastLabel.offsetWidth + Math.max(10, that.$.thumb.offsetWidth); } } return { width: optimalOtherSize, height: optimalSize }; } else { optimalSize += parseFloat(trackStyle.marginLeft) + parseFloat(trackStyle.marginRight) + that.$.track.offsetWidth; if (that.scalePosition === 'near' || that.scalePosition === 'both') { optimalSize += largestLabelSize; labels = that.$.scaleNear.getElementsByClassName('lw-label'); firstLabel = labels[0]; lastLabel = labels[labels.length - 1]; optimalSize += parseFloat(window.getComputedStyle(firstLabel).right); } if (that.scalePosition === 'far' || that.scalePosition === 'both') { optimalSize += largestLabelSize; labels = that.$.scaleFar.getElementsByClassName('lw-label'); firstLabel = labels[0]; lastLabel = labels[labels.length - 1]; optimalSize += parseFloat(window.getComputedStyle(firstLabel).left); } optimalSize += parseFloat(sliderStyle.paddingLeft) + parseFloat(sliderStyle.paddingRight); optimalOtherSize = that.offsetHeight; if (that.scalePosition !== 'none') { firstRect = firstLabel.getBoundingClientRect(); lastRect = lastLabel.getBoundingClientRect(); difference = firstRect.top + firstLabel.offsetHeight - lastRect.top; if (difference > 0) { optimalOtherSize = firstLabel.offsetHeight + lastLabel.offsetHeight + Math.max(10, that.$.thumb.offsetHeight); } } return { width: optimalSize, height: optimalOtherSize }; } } /** * Invoked when the value of a public property has been changed by the user. */ propertyChangedHandler(key, oldValue, value) { const that = this, sameHandlers = ['disabled', 'mode', 'readonly', 'showThumbLabel', 'tooltipPosition', 'unfocusable', 'validation']; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } if (sameHandlers.indexOf(key) !== -1) { super.propertyChangedHandler(key, oldValue, value); return; } let valuesHandler = that._valuesHandler; function redraw() { that._setTicksAndInterval(); valuesHandler.validate(false, valuesHandler.getValue(), true); } // eslint-disable-next-line if (key !== 'values' && value != oldValue || key === 'values' && (value[0] != oldValue[0] || value[1] !== oldValue[1])) { switch (key) { case 'coerce': if (value) { const valueBeforeCoercion = valuesHandler.getValue(); valuesHandler.validate(false, valueBeforeCoercion.slice(0), true); that._valueBeforeCoercion = valueBeforeCoercion; // stores value before coercion } else { if (that._valueBeforeCoercion !== undefined) { valuesHandler.validate(false, that._valueBeforeCoercion.slice(0), true); // restores the value from before coercion } } break; case 'customInterval': case 'customTicks': super.propertyChangedHandler(key, oldValue, value); if (that.customInterval) { valuesHandler.validate(false, valuesHandler.getValue(), true); } break; case 'dateLabelFormatString': if (that.mode === 'date') { redraw(); } break; case 'decimalSeparator': case 'scientificNotation': if (that.mode === 'date') { return; } redraw(); break; case 'interval': //Validates the Interval that._numericProcessor.validateInterval(value); valuesHandler.validate(false, valuesHandler.getValue(), true); break; case 'inverted': case 'rightToLeft': that._getLayoutType(); if (that._normalLayout) { that.$.fill.style[that._settings.margin] = '0px'; } redraw(); break; case 'labelFormatFunction': case 'showUnit': case 'unit': redraw(); break; case 'labelsVisibility': case 'ticksVisibility': return; case 'logarithmicScale': if (that.mode === 'date') { that.logarithmicScale = false; return; } that._validateMinMax('both'); redraw(); break; case 'min': case 'max': if (that.mode === 'date') { delete that._dateInterval; that[key] = LW.Utilities.DateTime.validateDate(value).getTimeStamp(); } that._validateMinMax(key, false, oldValue); redraw(); break; case 'orientation': // clears previously applied inline styles that.$.container.removeAttribute('style'); that.$.trackContainer.removeAttribute('style'); that.$.fill.removeAttribute('style'); that.$.thumb.removeAttribute('style'); that.$.secondThumb.removeAttribute('style'); that._setSettingsObject(); that._getLayoutType(); that._getMeasurements(); redraw(); if (value === 'horizontal') { that.$leftArrow.removeClass('lw-arrow-up'); that.$rightArrow.removeClass('lw-arrow-down'); that.$leftArrow.addClass('lw-arrow-left'); that.$rightArrow.addClass('lw-arrow-right'); } else { that.$leftArrow.removeClass('lw-arrow-left'); that.$rightArrow.removeClass('lw-arrow-right'); that.$leftArrow.addClass('lw-arrow-up'); that.$rightArrow.addClass('lw-arrow-down'); } that.$.thumb.setAttribute('aria-orientation', value); that.$.secondThumb.setAttribute('aria-orientation', value); break; case 'precisionDigits': case 'significantDigits': if (that.mode === 'date') { return; } if (key === 'precisionDigits' && that.scaleType === 'integer') { that.error(that.localize('noInteger', { elementType: that.nodeName.toLowerCase(), property: key })); } if (key === 'significantDigits' && that.precisionDigits !== null) { that.precisionDigits = null; } else if (key === 'precisionDigits' && that.significantDigits !== null) { that.significantDigits = null; } redraw(); break; case 'rangeSlider': if (value) { that.values = [that.min, that.value]; that._drawValues = [that._drawMin, that._drawValue]; if (that.mode === 'date') { that._valueDate = [that._minDate.clone(), that._valueDate]; } if (that._valueBeforeCoercion !== undefined) { that._valueBeforeCoercion = [that.min, that._valueBeforeCoercion]; } valuesHandler = that._valuesHandler = new LW.Utilities.SliderMultipleValueHandler(that); } else { that.value = that.values[1]; that._drawValue = that._drawValues[1]; if (that.mode === 'date') { that._valueDate = that._valueDate[1]; } if (that._valueBeforeCoercion !== undefined) { that._valueBeforeCoercion = that._valueBeforeCoercion[1]; } valuesHandler = that._valuesHandler = new LW.Utilities.SliderSingleValueHandler(that); that.$.fill.style.marginTop = 0; that.$.fill.style.marginLeft = 0; } valuesHandler.validate(false, valuesHandler.getValue(), true); break; case 'scalePosition': that._setInitialComponentDisplay(); redraw(); break; case 'scaleType': if (that.mode === 'date') { that.scaleType = 'integer'; return; } that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'scaleType'); that._validateMinMax('both'); that._setTicksAndInterval(); valuesHandler.validate(true); break; case 'showButtons': if (value) { that.$leftButton.removeClass('lw-hidden'); that.$rightButton.removeClass('lw-hidden'); } else { that.$leftButton.addClass('lw-hidden'); that.$rightButton.addClass('lw-hidden'); } that._setTicksAndInterval(); valuesHandler.moveThumbBasedOnValue(valuesHandler.getDrawValue(), undefined, true); break; case 'showTooltip': super.propertyChangedHandler(key, oldValue, value); if (!value) { that.$tooltip.addClass('lw-hidden'); that.$secondTooltip.addClass('lw-hidden'); } break; case 'theme': super.propertyChangedHandler(key, oldValue, value); redraw(); break; case 'ticksPosition': if (value === 'scale') { that.$trackTicksContainer.addClass('lw-hidden'); that.$.trackTicksContainer.innerHTML = ''; } else { that.$trackTicksContainer.removeClass('lw-hidden'); } that._setTicksAndInterval(); break; case 'value': case 'values': if (key === 'value' && that.rangeSlider || key === 'values' && !that.rangeSlider) { return; } that[key] = oldValue; if (that.mode === 'date') { if (key === 'value') { value = LW.Utilities.DateTime.validateDate(value); value = value.getTimeStamp(); that.value = value; if (value.compare(oldValue) === 0) { return; } } else { value[0] = LW.Utilities.DateTime.validateDate(value[0]); value[1] = LW.Utilities.DateTime.validateDate(value[1]); value[0] = value[0].getTimeStamp(); value[1] = value[1].getTimeStamp(); that.values = value; if (value[0].compare(oldValue[0]) === 0 && value[1].compare(oldValue[1]) === 0) { return; } } } valuesHandler.validate(false, value, true); break; case 'wordLength': if (that.mode === 'date') { that.wordLength = 'uint64'; return; } that._wordLengthNumber = that._numericProcessor.getWordLength(value); that._validateMinMax('both'); redraw(); break; } } else if (typeof value !== 'string' && typeof oldValue === 'string') { that[key] = oldValue; } } /** * Adds the class "lw-moved-thumb" to the moved thumb. */ _addMovedThumbClass() { const that = this; if (!that.rangeSlider) { return; } that._movedThumb.$.addClass('lw-moved-thumb'); if (that._movedThumb === that.$.thumb) { that.$secondThumb.removeClass('lw-moved-thumb'); } else { that.$thumb.removeClass('lw-moved-thumb'); } } /** * Sets the display of the scales. */ _setInitialComponentDisplay() { super._setInitialComponentDisplay(); const that = this; that.$secondTooltip.addClass('lw-hidden'); if (!that.showButtons) { that.$leftButton.addClass('lw-hidden'); that.$rightButton.addClass('lw-hidden'); } } /** * Measures some elements of the slider and stores the results. */ _getMeasurements() { const that = this, measurements = that._measurements, track = that.$.track, thumb = that.$.thumb; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } if (that.orientation === 'horizontal') { measurements.trackWidth = track.offsetHeight; measurements.thumbSize = thumb.offsetWidth; measurements.borderWidth = parseFloat(window.getComputedStyle(that.$.track).borderLeftWidth); } else { measurements.trackWidth = track.offsetWidth; measurements.thumbSize = thumb.offsetHeight; measurements.borderWidth = parseFloat(window.getComputedStyle(that.$.track).borderTopWidth); } measurements.halfThumbSize = measurements.thumbSize / 2; } /** * Applies necessary paddings to the track container. */ _layout() { const that = this, measurements = that._measurements, containerStyle = that.$.container.style, thumbPadding = measurements.halfThumbSize, labelsSize = that._tickIntervalHandler.labelsSize; let minLabelPadding, maxLabelPadding, paddingStart, paddingEnd; if (that.scalePosition !== 'none') { minLabelPadding = labelsSize.minLabelSize / 2; maxLabelPadding = labelsSize.maxLabelSize / 2; } else { minLabelPadding = 0; maxLabelPadding = 0; } if (!that.showButtons) { paddingStart = Math.max(thumbPadding, minLabelPadding) + 'px'; paddingEnd = Math.max(thumbPadding, maxLabelPadding) + 'px'; } else { const spinButtonSize = that.$.leftButton[that._settings.size], buttonSize = spinButtonSize + thumbPadding; paddingStart = Math.max(minLabelPadding - buttonSize, 0) + 'px'; paddingEnd = Math.max(maxLabelPadding - buttonSize, 0) + 'px'; } if (that.orientation === 'horizontal') { if ((!that.inverted && !that.rightToLeft) || (that.rightToLeft && that.inverted)) { containerStyle.paddingLeft = paddingStart; containerStyle.paddingRight = paddingEnd; } else { containerStyle.paddingLeft = paddingEnd; containerStyle.paddingRight = paddingStart; } measurements.trackLength = that.$.track.clientWidth; that.$leftArrow.addClass('lw-arrow-left'); that.$rightArrow.addClass('lw-arrow-right'); } else { if (!that.inverted) { containerStyle.paddingBottom = paddingStart; containerStyle.paddingTop = paddingEnd; } else { containerStyle.paddingBottom = paddingEnd; containerStyle.paddingTop = paddingStart; } measurements.trackLength = that.$.track.clientHeight; that.$leftArrow.addClass('lw-arrow-up'); that.$rightArrow.addClass('lw-arrow-down'); } } /** * Track click event handler. */ _trackDownHandler(event) { const that = this, mechanicalAction = that.mechanicalAction; if (that.disabled || that.readonly || !that.rangeSlider && event.target === that.$.thumb) { return; } if (that._stopTrackDownHandler) { that._stopTrackDownHandler = false; return; } if (mechanicalAction !== 'switchWhileDragging') { that._valueAtDragStart = that._valuesHandler.getValue(); } that._getTrackStartAndEnd(); that._valuesHandler.setActiveThumbOnTrackClick(event); that._moveThumbBasedOnCoordinates(event, true, mechanicalAction !== 'switchWhenReleased'); that._thumbDragged = true; that.setAttribute('dragged', ''); if (that.showTooltip) { that._movedTooltip.removeClass('lw-hidden'); } } _trackMoveHandler() { } /** * Thumb mousedown event handler. */ _thumbDownHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } that._getTrackStartAndEnd(); if (event[that._settings.page] < that._trackStart || event[that._settings.page] > that._trackEnd) { that._stopTrackDownHandler = true; } if (that.mechanicalAction !== 'switchWhileDragging') { that._valueAtDragStart = that._valuesHandler.getValue(); } window.getSelection().removeAllRanges(); that._thumbDragged = true; that.setAttribute('dragged', ''); that.$track.addClass('lw-dragged'); that._movedThumb = event.target; that._addMovedThumbClass(); that._movedTooltip = that.$tooltip; if (that.rangeSlider) { if (that._movedThumb === that.$.thumb) { that._staticThumb = that.$.secondThumb; that.$secondTooltip.addClass('lw-hidden'); } else { that._staticThumb = that.$.thumb; that._movedTooltip = that.$secondTooltip; that.$tooltip.addClass('lw-hidden'); } } if (that.showTooltip) { that._movedTooltip.removeClass('lw-hidden'); } event.stopPropagation(); } /** * Thumb move and mouseleave event handler. */ _thumbMoveMouseleaveHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } const target = event.target; if (event.type === 'move') { const targetRect = target.getBoundingClientRect(), windowScrollX = window.scrollX || window.pageXOffset, windowScrollY = window.scrollY || window.pageYOffset, centerX = (targetRect.left + targetRect.right) / 2 + windowScrollX, centerY = (targetRect.top + targetRect.bottom) / 2 + windowScrollY, rSquared = Math.pow(targetRect.width / 2, 2); if ((Math.pow(event.pageX - centerX, 2) + Math.pow(event.pageY - centerY, 2)) > rSquared) { return; } target.setAttribute('hover', ''); } else { target.removeAttribute('hover'); } } /** * Document mousemove event handler. */ _documentMoveHandler(event) { const that = this; if (that._thumbDragged) { that.$thumb.removeClass('enable-animation'); that.$secondThumb.removeClass('enable-animation'); that.$fill.removeClass('enable-animation'); that._moveThumbBasedOnCoordinates(event, true, that.mechanicalAction !== 'switchWhenReleased'); } } /** * Document mouseup event handler. */ _documentUpHandler(event, canceled) { const that = this; if (!that._thumbDragged) { return; } that.$thumb.addClass('enable-animation'); that.$secondThumb.addClass('enable-animation'); that.$fill.addClass('enable-animation'); if (!canceled) { if (that.mechanicalAction === 'switchUntilReleased') { that._valuesHandler.validate(false, that._valueAtDragStart); } else if (that.mechanicalAction === 'switchWhenReleased') { that._moveThumbBasedOnCoordinates(event, true, true); } } if (that.showTooltip) { that._movedTooltip.addClass('lw-hidden'); } that._thumbDragged = false; that.removeAttribute('dragged'); that._makeThumbAccessible(); that._movedThumb = undefined; that.$track.removeClass('lw-dragged'); } /** * Spin button click event handler. */ _spinButtonClickHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } let operation; if (that.$.leftButton.contains(event.target) === that._normalLayout) { operation = 'subtract'; } else { operation = 'add'; } that._valuesHandler.incrementOrDecrement(operation); } /** * Slider keydown event handler. */ _keydownHandlerSlider(event) { const that = this, key = event.key; if (key === 'Escape' && that._thumbDragged && that.mechanicalAction === 'switchWhenReleased') { that._documentUpHandler(undefined, true); that._valuesHandler.validate(false, that._valueAtDragStart); return; } if (['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp'].indexOf(key) !== -1 && !that.coerce) { that.$thumb.removeClass('enable-animation'); that.$secondThumb.removeClass('enable-animation'); that.$fill.removeClass('enable-animation'); that._restoreAnimationClass = true; } this._valuesHandler.keydownHandler(event); } /** * Slider keyup event handler. */ _keyupHandlerSlider() { const that = this; if (that._restoreAnimationClass) { that.$thumb.addClass('enable-animation'); that.$secondThumb.addClass('enable-animation'); that.$fill.addClass('enable-animation'); } } /** * Slider resize and styleChanged event handler. */ _resizeAndStyleChangedHandler(event) { const that = this, valuesHandler = that._valuesHandler; if (!that._isVisible()) { that._renderingSuspended = true; return; } else if (that._renderingSuspended) { that._createElement(); return; } if (that._renderingSuspended) { return; } that._getMeasurements(); that._setTicksAndInterval(); valuesHandler.validate(false, valuesHandler.getValue(), true); if (event.type === 'styleChanged') { const changedStyleProperties = event.detail.styleProperties; if (changedStyleProperties['font-size'] || changedStyleProperties['font-family'] || changedStyleProperties['font-style'] || changedStyleProperties['font-weight']) { const optimum = that.getOptimalSize(); that.style.width = optimum.width + 'px'; that.style.height = optimum.height + 'px'; } } } /** * Moves the slider's thumb and updates the filled part of the track based on the position of the mouse. */ _moveThumbBasedOnCoordinates(event, checkBoundaries, changeValue) { const that = this, numericProcessor = that._numericProcessor, trackStart = that._trackStart, margin = that._settings.margin; let coordinate = event[that._settings.page]; if (checkBoundaries) { coordinate = that._valuesHandler.restrictThumbCoordinates(coordinate, trackStart, that._trackEnd); } let newValue = numericProcessor.pxToValue(coordinate); if (that.rangeSlider && that._movedThumb === that.$.thumb && numericProcessor.compare(newValue, that.values[1], true) === 1) { newValue = numericProcessor.createDescriptor(that.values[1]); } let actualNewValue = newValue; if (!that.logarithmicScale) { newValue = numericProcessor.getCoercedValue(newValue); actualNewValue = newValue; } else { newValue = numericProcessor.getCoercedValue(Math.log10(newValue)); actualNewValue = parseFloat(Math.pow(10, newValue).toFixed(11)); } coordinate = numericProcessor.valueToPx(newValue) + trackStart; const size = coordinate - trackStart; that._movedThumb.style[margin] = size - that._measurements.halfThumbSize + 'px'; that._valuesHandler.updateFillSizeAndPosition(size, margin, actualNewValue, true, changeValue); if (LW.Utilities.Core.isMobile && event.originalEvent) { event.originalEvent.stopPropagation(); event.originalEvent.preventDefault(); } } /** * Moves the slider's thumb and updates the filled part of the track based on a passed value. */ _moveThumbBasedOnValue(thumb, value, triggerEvent, firstPass) { const that = this, px = that._numericProcessor.valueToPx(value), margin = that._settings.margin; thumb.style[margin] = (px - that._measurements.halfThumbSize) + 'px'; const actualValue = that._getSingleActualValue(value); if (!firstPass) { that._valuesHandler.updateFillSizeAndPosition(px, margin, actualValue, triggerEvent, triggerEvent); } else if (that.rangeSlider) { that._firstPassSize = px; } } /** * Calls the appropriate validation function. */ _validate(initialValidation, programmaticValue, coerced, programmaticValueIsSet) { this._valuesHandler.validate(initialValidation, programmaticValue, programmaticValueIsSet); } /** * Calls the appropriate update function. */ _updateValue(value) { const valuesHandler = this._valuesHandler; valuesHandler.updateValue(valuesHandler.getActualValue(value)); } /** * Makes the first thumb accessible. */ _makeThumbAccessible() { const that = this; if (that.rangeSlider) { if (that.$.thumb[that._settings.offset] === that.$.secondThumb[that._settings.offset] && that._numericProcessor.compare(that.values[1], that.max) === false) { that.$thumb.addClass('accessible'); } else { that.$thumb.removeClass('accessible'); } } } /** * Returns a single, actual value. */ _getSingleActualValue(value) { if (this.logarithmicScale) { return parseFloat(Math.pow(10, value).toFixed(11)); } return value.toString(); } /** * Coerces the value when changes to custom interval-related settings are made. */ _coerceCustomInterval() { const that = this; if (that.coerce) { const valueBeforeCoercion = that._valueBeforeCoercion; that._valuesHandler.validate(false, that._valuesHandler.getValue()); that._valueBeforeCoercion = valueBeforeCoercion; } } /** * wheel event handler */ _wheelHandler(event) { const that = this; if (document.activeElement !== that || !that.enableMouseWheelAction) { return; } event.stopPropagation(); event.preventDefault(); if (event.wheelDelta > 0) { that._keydownHandlerSlider({ key: 'ArrowRight', which: 39, preventDefault: function () { } }); } else { that._keydownHandlerSlider({ key: 'ArrowLeft', which: 37, preventDefault: function () { } }); } } /** * Handles date scale. */ _handleDateScale() { const that = this, dateTime = LW.Utilities.DateTime; super._handleDateScale(); Object.defineProperty(that, 'values', { get: function () { if (that.context === that) { return that.properties.values.value; } else { return that._valueDate; } }, set(value) { function replacer(key, value) { if (value instanceof LW.Utilities.BigNumber) { return value.toString(); } return value; } const oldValue = that.properties.values.value, stringifiedOldValue = JSON.stringify(oldValue, replacer), stringifiedValue = JSON.stringify(value, replacer); if (stringifiedOldValue === stringifiedValue) { return; } that.properties.values.value = value; if (that.isReady && (!that.ownerElement || (that.ownerElement && that.ownerElement.isReady)) && that.context !== that) { const context = that.context; that.context = that; that.propertyChangedHandler('values', oldValue, value); that.context = context; } } }); if (that.rangeSlider) { that._valueDate = [dateTime.validateDate(that.values[0]), dateTime.validateDate(that.values[1])]; that.values = [that._valueDate[0].getTimeStamp(), that._valueDate[1].getTimeStamp()]; } that._properties.values.serialize = '_serializeValue'; } /** * Sets new Ticks and Interval */ _setTicksAndInterval() { const that = this; if (that._skipTrackReset) { delete that._skipTrackReset; } else { that.$.track.style[that._settings.dimension] = null; } super._setTicksAndInterval(); if (that.$.track[that._settings.size] < 10) { that._skipTrackReset = true; that.$.track.style[that._settings.dimension] = that.getOptimalSize()[that._settings.dimension] + 'px'; that._getMeasurements(); that._setTicksAndInterval(); that._valuesHandler.validate(false, that._valuesHandler.getValue()); } } /** * Sets the internal property "_normalLayout" based on the properties "orientation" and "inverted" and applies WAI-ARIA descriptions to the buttons. */ _getLayoutType() { const that = this; super._getLayoutType(); if (that._normalLayout) { that.$.leftButton.setAttribute('aria-label', 'Decrement'); that.$.rightButton.setAttribute('aria-label', 'Increment'); } else { that.$.leftButton.setAttribute('aria-label', 'Increment'); that.$.rightButton.setAttribute('aria-label', 'Decrement'); } } /** * Sets the aria-valuemax, aria-valuemin, aria-valuenow, and aria-valuetext properties. */ _setAriaValue(property) { this._valuesHandler.setAriaValue(property); } }); /** * A class for instantiating a tooltip handler object (standard case). */ LW.Utilities.Assign('SliderSingleValueHandler', class SliderSingleValueHandler { constructor(context) { this.context = context; if (context.mode === 'date') { context._getEventValue = function (aria, value) { let result; if (value !== undefined) { result = LW.Utilities.DateTime.fromFullTimeStamp(value); } else { result = context._valueDate.clone(); } if (aria) { context.$.thumb.setAttribute('aria-valuetext', result.toString('f')); return context.value.toString(); } return result; } } } applyFunctionToValue(fn, argument) { const that = this, context = that.context; if (argument === undefined) { argument = context.value; } const result = fn.apply(context, [argument]); return result; } areDifferent(other) { return this.context.value !== other; } incrementOrDecrement(operation) { const context = this.context, newValue = context._keyIncrementDecrement(operation); this.validate(false, newValue); } setActiveThumbOnTrackClick() { const context = this.context; context._movedThumb = context.$.thumb; context._addMovedThumbClass(); context._movedTooltip = context.$tooltip; } getActualValue(value) { return this.context._getSingleActualValue(value); } getCoercedLogarithmicValue(value) { const context = this.context; if (context.logarithmicScale) { const newDrawValue = context._numericProcessor.getCoercedValue(Math.log10(value)); return this.getActualValue(newDrawValue); } return value; } getDrawValue() { return this.context._drawValue; } getValue() { return this.context.value; } keydownHandler(event) { this.context._keydownHandler(event); } moveThumbBasedOnValue(value, triggerEvent, noUpdate) { const context = this.context; if (value === undefined) { value = context.value; } context._moveThumbBasedOnValue(context.$.thumb, value, triggerEvent); if (noUpdate !== true) { context._drawValue = value; const actualValue = this.getActualValue(value); let updatedValue; if (context._valueNoRangeValidation !== undefined) { updatedValue = context._valueNoRangeValidation.toString(); } else { updatedValue = actualValue.toString(); } if (context.mode === 'date') { context._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(updatedValue); } context.value = updatedValue; delete context._valueBeforeCoercion; this.updateTooltipValue(actualValue); } } restrictThumbCoordinates(coordinate, trackStart, trackEnd) { coordinate = Math.max(coordinate, trackStart); coordinate = Math.min(coordinate, trackEnd); return coordinate; } updateFillSizeAndPosition(size, margin, newValue, updateTooltip, changeValue) { const context = this.context, fillStyle = context.$.fill.style, dimension = context._settings.dimension; if (context._normalLayout) { fillStyle[dimension] = size + 'px'; } else { fillStyle[dimension] = (context._measurements.trackLength - size) + 'px'; fillStyle[margin] = size + 'px'; } if (updateTooltip) { const oldValue = context.value, eventOldValue = context._getEventValue(false, oldValue), numericProcessor = context._numericProcessor; if (numericProcessor.compare(numericProcessor.createDescriptor(newValue), numericProcessor.createDescriptor(oldValue))) { this.updateTooltipValue(newValue); if (changeValue) { let updatedValue; context._drawValue = context.logarithmicScale ? Math.log10(newValue) : newValue; if (context._valueNoRangeValidation !== undefined) { updatedValue = context._valueNoRangeValidation.toString(); } else { updatedValue = newValue.toString(); } if (context.mode === 'date') { context._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(updatedValue); } context.value = updatedValue; delete context._valueBeforeCoercion; if (context._programmaticValueIsSet !== true) { const eventValue = context._getEventValue(); //Update hidden input context.$.hiddenInput.value = eventValue; context.$.fireEvent('change', { 'value': eventValue, 'oldValue': eventOldValue }); this.setAriaValue('valuenow'); } } } } } updateTooltipValue(newValue) { const context = this.context; if (newValue === undefined) { newValue = context.value; } const newFormattedValue = context._formatLabel(newValue); if (context.$.tooltipContent.innerHTML !== newFormattedValue) { context.$.tooltipContent.innerHTML = newFormattedValue; context.$.thumbLabel.innerHTML = newFormattedValue; } } updateValue(value) { const context = this.context, renderedValue = context._numericProcessor.createDescriptor(value, true, false); context._drawValue = context.logarithmicScale ? Math.log10(renderedValue) : renderedValue; this.moveThumbBasedOnValue(context._drawValue, true); } validate(initialValidation, programmaticValue, programmaticValueIsSet) { const context = this.context, numericProcessor = context._numericProcessor; let value; context._programmaticValueIsSet = programmaticValueIsSet && context.validation === 'interaction'; if (initialValidation) { value = context.value; } else { value = programmaticValue; } let validNumber; if (context.coerce) { value = context._numericProcessor.createDescriptor(value, true, true, true); } if (context.logarithmicScale) { value = this.getCoercedLogarithmicValue(value); } else { value = numericProcessor.getCoercedValue(value); } if (context.validation === 'strict') { context._valueNoRangeValidation = numericProcessor.createDescriptor(value, true, true, true); validNumber = context._valueNoRangeValidation; } else { context._valueNoRangeValidation = numericProcessor.createDescriptor(value, true, true, false); validNumber = numericProcessor.validate(context._valueNoRangeValidation, context._minObject, context._maxObject); } if (initialValidation) { context._drawValue = context.logarithmicScale ? Math.log10(validNumber) : validNumber; value = context._valueNoRangeValidation.toString(); if (context.mode === 'date') { context._valueDate = LW.Utilities.DateTime.fromFullTimeStamp(value); } context.value = value; this.moveThumbBasedOnValue(context._drawValue, undefined, true); } else { this.updateValue(validNumber); } delete context._valueNoRangeValidation; context._programmaticValueIsSet = false; } /** * Sets the aria-valuemax, aria-valuemin, aria-valuenow, and aria-valuetext properties. */ setAriaValue(property) { const context = this.context, thumb = context.$.thumb; if (property === 'valuenow') { thumb.setAttribute('aria-valuenow', context._getEventValue(true)); } else { thumb.setAttribute('aria-valuemin', context.min.toString()); thumb.setAttribute('aria-valuemax', context.max.toString()); } } }); /** * A class for instantiating a tooltip handler object (range slider case). */ LW.Utilities.Assign('SliderMultipleValueHandler', class SliderMultipleValueHandler { constructor(context) { this.context = context; if (context.mode === 'date') { context._getEventValue = function (aria, value, index) { const result = [context._valueDate[0].clone(), context._valueDate[1].clone()]; if (value !== undefined) { result[index] = LW.Utilities.DateTime.fromFullTimeStamp(value); } if (aria) { context.$.thumb.setAttribute('aria-valuetext', result[0].toString('f')); context.$.secondThumb.setAttribute('aria-valuetext', result[1].toString('f')); return context.values.slice(0); } return result; } } } applyFunctionToValue(fn, argument) { const that = this, context = that.context, result = []; if (argument === undefined) { argument = context.values; } result[0] = fn.apply(context, [argument[0]]); result[1] = fn.apply(context, [argument[1]]); return result; } areDifferent(other) { const values = this.context.values; return (values[0] !== other[0] || values[1] !== other[1]); } incrementOrDecrement(operation) { const context = this.context, changedValues = context.values.slice(0); let changedIndex; if (operation === 'add') { changedIndex = 1; } else { changedIndex = 0; } changedValues[changedIndex] = this.keyIncrementDecrement(operation, changedIndex); this.validate(false, changedValues); } keydownHandler(event) { const context = this.context; if (context.disabled || context.readonly) { return; } const keyCode = !event.charCode ? event.which : event.charCode, handledKeyCodes = [35, 36, 37, 38, 39, 40]; if (handledKeyCodes.indexOf(keyCode) !== -1) { event.preventDefault(); const updatedValues = context.values.slice(0); let newValue; switch (keyCode) { case 40: //down arrow case 37: //left arrow newValue = this.keyIncrementDecrement('subtract', 0); updatedValues[0] = newValue; context._movedThumb = context.$.thumb; break; case 38: //top arrow case 39: //right arrow newValue = this.keyIncrementDecrement('add', 1); updatedValues[1] = newValue; context._movedThumb = context.$.secondThumb; break; case 36: //home context._drawValues[0] = context._drawMin; updatedValues[0] = context.min; context._movedThumb = context.$.thumb; break; case 35: //end context._drawValues[1] = context._drawMax; updatedValues[1] = context.max; context._movedThumb = context.$.secondThumb; break; } this.validate(false, updatedValues); return false; } } keyIncrementDecrement(action, changedIndex) { const context = this.context; let preValue, newValue; if (context.customInterval && context.coerce) { preValue = this.getValue()[changedIndex]; return context._keyIncrementDecrement(action, preValue.toString()); } if (context.mode === 'date') { preValue = context._valueDate[changedIndex]; newValue = preValue[context._dateIncrementMethod]((action === 'add' ? 1 : -1) * parseFloat(context.interval), true); newValue = newValue.getTimeStamp(); if (newValue.compare(context._drawMin) === -1) { return new LW.Utilities.BigNumber(context._drawMin); } if (newValue.compare(context._drawMax) === 1) { return new LW.Utilities.BigNumber(context._drawMax); } return newValue; } const drawValue = context._drawValues[changedIndex]; preValue = context._numericProcessor.createDescriptor(drawValue); newValue = context._numericProcessor.incrementDecrement(preValue, action, context._validInterval); if (context.logarithmicScale) { context._drawValues[changedIndex] = newValue; newValue = parseFloat(Math.pow(10, Math.round(newValue)).toFixed(11)); } return newValue; } setActiveThumbOnTrackClick(event) { const context = this.context, commonTerm = context._trackStart + context._measurements.halfThumbSize, offset = context._settings.offset, thumb = context.$.thumb, secondThumb = context.$.secondThumb, thumbOffset = thumb[offset], secondThumbOffset = secondThumb[offset], clickedCoordinate = event[context._settings.page]; let middleBetweenThumbs = context._normalLayout ? commonTerm + thumbOffset + (secondThumbOffset - thumbOffset) / 2 : commonTerm + secondThumbOffset + (thumbOffset - secondThumbOffset) / 2; if (context._normalLayout && clickedCoordinate <= middleBetweenThumbs || !context._normalLayout && clickedCoordinate > middleBetweenThumbs) { context._movedThumb = thumb; context._staticThumb = secondThumb; context._movedTooltip = context.$tooltip; context.$secondTooltip.addClass('lw-hidden'); } else { context._movedThumb = secondThumb; context._staticThumb = thumb; context._movedTooltip = context.$secondTooltip; context.$tooltip.addClass('lw-hidden'); } context._addMovedThumbClass(); } getActualValue(values) { if (this.context.logarithmicScale) { return [parseFloat(Math.pow(10, values[0].toString()).toFixed(11)), parseFloat(Math.pow(10, values[1].toString()).toFixed(11))]; } return [values[0].toString(), values[1].toString()]; } getCoercedLogarithmicValue(values) { const context = this.context; if (context.logarithmicScale) { const newDrawValues = []; newDrawValues[0] = context._numericProcessor.getCoercedValue(Math.log10(values[0])); newDrawValues[1] = context._numericProcessor.getCoercedValue(Math.log10(values[1])); return this.getActualValue(newDrawValues); } return values; } getDrawValue() { return this.context._drawValues; } getValue() { return this.context.values.slice(0); } moveThumbBasedOnValue(value, changedIndex, noUpdate) { const context = this.context, both = changedIndex === undefined; if (value === undefined) { value = context.values; } context._numericProcessor.restrictValue(value); if (both || changedIndex === 1) { context._movedThumb = context.$.secondThumb; context._moveThumbBasedOnValue(context.$.secondThumb, value[1], true, both); } if (both || changedIndex === 0) { context._movedThumb = context.$.thumb; context._moveThumbBasedOnValue(context.$.thumb, value[0], true); } delete context._firstPassSize; if (noUpdate !== true) { context._drawValues = value; const actualValues = this.getActualValue(value); let updatedValues; if (context._valuesNoRangeValidation) { updatedValues = [context._valuesNoRangeValidation[0].toString(), context._valuesNoRangeValidation[1].toString()]; } else { updatedValues = actualValues; } if (context.mode === 'date') { context._valueDate = [ LW.Utilities.DateTime.fromFullTimeStamp(actualValues[0]), LW.Utilities.DateTime.fromFullTimeStamp(actualValues[1]) ]; } context.values = updatedValues; delete context._valueBeforeCoercion; this.updateTooltipValue(); } } restrictThumbCoordinates(coordinate, trackStart, trackEnd) { const context = this.context, staticThumbOffset = trackStart + context._staticThumb[context._settings.offset] + context._measurements.halfThumbSize; if (context._movedThumb === context.$.thumb && context._normalLayout || context._movedThumb === context.$.secondThumb && !context._normalLayout) { coordinate = Math.max(coordinate, trackStart); coordinate = Math.min(coordinate, trackEnd, staticThumbOffset); } else { coordinate = Math.max(coordinate, trackStart, staticThumbOffset); coordinate = Math.min(coordinate, trackEnd); } return coordinate; } updateFillSizeAndPosition(size, margin, newValue, updateTooltip, changeValue) { const context = this.context, fillStyle = context.$.fill.style, dimension = context._settings.dimension, offset = context._settings.offset, halfThumbSize = context._measurements.halfThumbSize; let thumbOffset, secondThumbOffset; if (context._movedThumb === context.$.thumb) { thumbOffset = size - halfThumbSize; secondThumbOffset = context._firstPassSize !== undefined ? (context._firstPassSize - halfThumbSize) : context.$.secondThumb[offset]; } else { thumbOffset = context._firstPassSize !== undefined ? (context._firstPassSize - halfThumbSize) : context.$.thumb[offset]; secondThumbOffset = size - halfThumbSize; } if (context._normalLayout) { fillStyle[dimension] = Math.max(0, (secondThumbOffset - thumbOffset)) + 'px'; fillStyle[margin] = (thumbOffset + halfThumbSize) + 'px'; } else { fillStyle[dimension] = Math.max(0, (thumbOffset - secondThumbOffset)) + 'px'; fillStyle[margin] = (secondThumbOffset + halfThumbSize) + 'px'; } if (updateTooltip) { const numericProcessor = context._numericProcessor, index = context._movedThumb === context.$.thumb ? 0 : 1, oldValue = context.values[index], oldValues = context._getEventValue(false, oldValue, index); if (numericProcessor.compare(numericProcessor.createDescriptor(newValue), numericProcessor.createDescriptor(oldValue))) { const updatedValues = context.values.slice(0); updatedValues[index] = newValue.toString(); this.updateTooltipValue(newValue, index); if (changeValue) { let finalUpdatedValues; this.updateDrawValues(updatedValues); if (context._valuesNoRangeValidation) { finalUpdatedValues = [context._valuesNoRangeValidation[0].toString(), context._valuesNoRangeValidation[1].toString()]; } else { finalUpdatedValues = updatedValues; } if (context.mode === 'date') { context._valueDate = [ LW.Utilities.DateTime.fromFullTimeStamp(updatedValues[0]), LW.Utilities.DateTime.fromFullTimeStamp(updatedValues[1]) ]; } context.values = finalUpdatedValues; delete context._valueBeforeCoercion; if (context._programmaticValueIsSet !== true) { const newValues = context._getEventValue(); //Update hidden input context.$.hiddenInput.value = newValues; context.$.fireEvent('change', { 'value': newValues, 'oldValue': oldValues }); this.setAriaValue('valuenow'); } } } } } updateDrawValues(values) { const context = this.context; if (context.logarithmicScale) { context._drawValues[0] = Math.log10(values[0]); context._drawValues[1] = Math.log10(values[1]); } else { context._drawValues = values.slice(0); } } updateTooltipValue(newValue, index) { const context = this.context; if (newValue === undefined) { const values = context.values, formattedFirstValue = context._formatLabel(values[0]), formattedSecondValue = context._formatLabel(values[1]); if (context.$.tooltipContent.innerHTML !== formattedFirstValue) { context.$.tooltipContent.innerHTML = formattedFirstValue; context.$.thumbLabel.innerHTML = formattedFirstValue; } if (context.$.secondTooltipContent.innerHTML !== formattedSecondValue) { context.$.secondTooltipContent.innerHTML = formattedSecondValue; } } else { const formattedNewValue = context._formatLabel(newValue); if (index === 0 && context.$.tooltipContent.innerHTML !== formattedNewValue || index === undefined) { context.$.tooltipContent.innerHTML = formattedNewValue; context.$.thumbLabel.innerHTML = formattedNewValue; } if (index === 1 && context.$.secondTooltipContent.innerHTML !== formattedNewValue || index === undefined) { context.$.secondTooltipContent.innerHTML = formattedNewValue; context.$.secondThumbLabel.innerHTML = formattedNewValue; } } } updateValue(values) { const context = this.context, renderedValues = []; let changedIndex; renderedValues[0] = context._numericProcessor.createDescriptor(values[0], true, false); renderedValues[1] = context._numericProcessor.createDescriptor(values[1], true, false); this.updateDrawValues(renderedValues); if (context._movedThumb === context.$.secondThumb) { changedIndex = 1; } this.moveThumbBasedOnValue(context._drawValues.slice(0), changedIndex); } validate(initialValidation, programmaticValue, programmaticValueIsSet) { const context = this.context, numericProcessor = context._numericProcessor; let validNumbers = [], values; context._programmaticValueIsSet = programmaticValueIsSet && context.validation === 'interaction'; if (initialValidation) { values = context.values.slice(0); } else { values = programmaticValue; } if (context.coerce) { values[0] = numericProcessor.createDescriptor(values[0], true, true, true); values[1] = numericProcessor.createDescriptor(values[1], true, true, true); } if (context.logarithmicScale) { values = this.getCoercedLogarithmicValue(values); } else { values[0] = numericProcessor.getCoercedValue(values[0]); values[1] = numericProcessor.getCoercedValue(values[1]); } context._valuesNoRangeValidation = []; context._valuesNoRangeValidation[0] = numericProcessor.createDescriptor(values[0], true, true, false); context._valuesNoRangeValidation[1] = numericProcessor.createDescriptor(values[1], true, true, false); context._numericProcessor.restrictValue(context._valuesNoRangeValidation); validNumbers[0] = numericProcessor.validate(context._valuesNoRangeValidation[0], context._minObject, context._maxObject); validNumbers[1] = numericProcessor.validate(context._valuesNoRangeValidation[1], context._minObject, context._maxObject); if (initialValidation) { context._drawValues = []; this.updateDrawValues(validNumbers); values = [context._valuesNoRangeValidation[0].toString(), context._valuesNoRangeValidation[1].toString()]; if (context.mode === 'date') { context._valueDate = [ LW.Utilities.DateTime.fromFullTimeStamp(validNumbers[0]), LW.Utilities.DateTime.fromFullTimeStamp(validNumbers[1]) ]; } context.values = values; this.moveThumbBasedOnValue(context._drawValues, undefined, true); } else { this.updateValue(validNumbers); } delete context._valuesNoRangeValidation; context._programmaticValueIsSet = false; } /** * Sets the aria-valuemax, aria-valuemin, aria-valuenow, and aria-valuetext properties. */ setAriaValue(property) { const context = this.context, thumb = context.$.thumb, secondThumb = context.$.secondThumb; if (property === 'valuenow') { const values = context._getEventValue(true), firstValue = values[0].toString(), secondValue = values[1].toString(); thumb.setAttribute('aria-valuenow', firstValue); thumb.setAttribute('aria-valuemax', secondValue); secondThumb.setAttribute('aria-valuenow', secondValue); secondThumb.setAttribute('aria-valuemin', firstValue); } else { thumb.setAttribute('aria-valuemin', context.min.toString()); secondThumb.setAttribute('aria-valuemax', context.max.toString()); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Accordion item custom element. */ LW('lw-accordion-item', class AccordionItem extends LW.ContentElement { // Accordion item's properties. static get properties() { return { 'dragged': { value: false, type: 'boolean' }, 'expanded': { value: false, type: 'boolean' }, 'focused': { value: false, type: 'boolean' }, 'index': { value: null, type: 'number?' }, 'label': { value: '', type: 'string' } }; } get enableShadowDOM() { return false; } /** * Accordion item's event listeners. */ static get listeners() { return { 'accordionItemHeader.mouseenter': '_headerMouseEnterHandler', 'accordionItemHeader.mouseleave': '_headerMouseLeaveHandler', 'accordionItemHeader.down': '_ripple' }; } /** * Expander item's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="accordionItemHeader" class="lw-accordion-item-header lw-unselectable" role="heading" aria-level="1"> <span id="arrow" class="lw-arrow" role="presentation" aria-hidden="true"></span> <span id="label" class="lw-label" inner-h-t-m-l='[[label]]' role="button"></span> </div> <div id="accordionItemContent" class="lw-accordion-item-content"> <div id="contentContainer" class="lw-content-container" role="presentation"><content></content></div> </div> </div>`; } render() { const that = this; let contentId; if (that.id) { contentId = that.id + 'Content'; } else if (that.parentElement && that.parentElement.parentElement && that.parentElement.parentElement.id) { contentId = that.parentElement.parentElement.id + Math.floor(Math.random() * 10000) + 'Content'; } else { contentId = 'accordion' + Math.floor(Math.random() * 10000) + 'Content'; } that.$.accordionItemContent.id = contentId; that.$.label.setAttribute('aria-controls', contentId); super.render(); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (propertyName === 'expanded') { that.$.label.setAttribute('aria-expanded', newValue); const expandMode = that.parentElement && that.parentElement.parentElement ? that.parentElement.parentElement.expandMode : that.shadowParent.expandMode; if (expandMode === 'multiple' || expandMode === 'toggle') { return; } if (newValue) { that.$.label.setAttribute('aria-disabled', true); } else { that.$.label.removeAttribute('aria-disabled'); } return; } oldValue = parseInt(oldValue); newValue = parseInt(newValue); if (propertyName !== 'index' || isNaN(oldValue) || isNaN(newValue)) { return; } const allSiblingsCount = that.parentElement.parentElement._items.length; if (newValue < 0) { newValue = 0; } else if (newValue >= allSiblingsCount) { newValue = allSiblingsCount - 1; } if (newValue !== oldValue) { that.$.fireEvent('indexChange', { 'newIndex': newValue, 'oldIndex': oldValue }); } that.index = newValue; } /** * Accordion's header onMouseEnter handler. **/ _headerMouseEnterHandler() { const that = this; if (that.disabled) { return; } that.setAttribute('hover', ''); } /** * Accordion's header onMouseLeave handler. **/ _headerMouseLeaveHandler() { const that = this; if (that.disabled) { return; } that.removeAttribute('hover'); } /** * Accordion's material ripple effect **/ _ripple(event) { const that = this; if (that.disabled) { return; } if (that.hasRippleAnimation) { LW.Utilities.Animation.Ripple.animate(that.$.container, event.pageX, event.pageY); } } /** * Sets the index without "propertyChangedHandler" being called */ _setIndex(index) { const that = this, oldContext = that.context; that.context = that; that.index = index; that.context = oldContext; } focus() { const that = this; super.focus(); that.setAttribute('focus', ''); } blur() { const that = this; super.blur(); that.removeAttribute('focus'); } }); /** * Accordion custom element. */ LW('lw-accordion', class Accordion extends LW.BaseElement { /** * Accordion's properties **/ static get properties() { return { 'expandedIndexes': { value: [], type: 'array' }, 'expandMode': { allowedValues: ['single', 'singleFitHeight', 'multiple', 'toggle', 'none'], value: 'singleFitHeight', type: 'string' }, 'messages': { extend: true, value: { 'en': { 'accordionItemRequired': '{{elementType}}: "{{method}}" requires an item from type "lw-accordion-item".', 'indexOutOfBound': '{{elementType}}: Out of bound index/indexes in "{{method}}" method.', 'invalidSettings': '{{elementType}}: "{{method}}" method accepts a string or an object as it\'s second parameter.', 'missingReference': '{{elementType}}: Missing reference to {{files}}.', 'noItems': '{{elementType}}: No child elements found.', 'overridingProperties': '{{elementType}}: Overriding properties {{property1}} and {{property2}} applied. The "{{property1}}" property is used by default.' } }, type: 'object' }, 'reorder': { value: false, type: 'boolean' } } } /** * Accordion's event listeners. */ static get listeners() { return { 'down': '_downHandler', 'focus': '_focusHandler', 'indexChange': '_indexChangeHandler', 'keydown': '_keyDownHandler', 'move': '_moveHandler', 'resize': '_resizeHandler', 'styleChanged': '_resizeHandler', 'document.up': '_upHandler', 'container.move': '_containerMoveHandler' }; } /** * Accordion's HTML template. */ template() { return `<div id="container" role="presentation"> <content></content> </div>`; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.accordion.css' ] } /** * Called when the element is ready. Used for one-time configuration of the Accordion. */ ready() { super.ready(); } render() { const that = this; that._createElement(); super.render(); } /** * Updates the accordion when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (propertyName === 'expandedIndexes') { if (oldValue.toString() === newValue.toString()) { return; } let sanitizedNewValue = []; if (that._items.length > 0) { for (let i = 0; i < newValue.length; i++) { let sanitizedNewValueSingleItem = parseInt(newValue[i]); if (!isNaN(sanitizedNewValueSingleItem)) { if (that._expandModeIs(['single', 'singleFitHeight', 'toggle'])) { if ((sanitizedNewValue.length < 1) && (sanitizedNewValueSingleItem >= 0 && sanitizedNewValueSingleItem < that._items.length)) { sanitizedNewValue.push(sanitizedNewValueSingleItem); } break; } else { if (sanitizedNewValueSingleItem >= 0 && sanitizedNewValueSingleItem <= that._items.length && sanitizedNewValue.indexOf(sanitizedNewValueSingleItem) === -1) { sanitizedNewValue.push(sanitizedNewValueSingleItem); } } } } } if (sanitizedNewValue.length === 0 && that._expandModeIs(['single', 'singleFitHeight'])) { newValue = oldValue.slice(); that.expandedIndexes = newValue; return; } newValue = sanitizedNewValue; const indexes = that._compareExpandedIndexes(oldValue, newValue); that._toggleItems('collapse', indexes.collapse); that._toggleItems('expand', indexes.expand); that.expandedIndexes = newValue; return; } super.propertyChangedHandler(propertyName, oldValue, newValue); switch (propertyName) { case 'disabled': that._setFocusable(); that._enableDisableHandler(); break; case 'expandMode': { if (that._items.length === 0) { break; } if ((oldValue === 'multiple' && newValue !== 'none') || (oldValue === 'none' && newValue !== 'multiple')) { const indexesToCollapse = that.expandedIndexes.slice(1); that._toggleItems('collapse', indexesToCollapse); if (that.expandedIndexes.length === 0 && that._expandModeIs(['single', 'singleFitHeight'])) { expandFirstItem(); } } else if (oldValue === 'toggle' && that._expandModeIs(['single', 'singleFitHeight']) && that.expandedIndexes.length === 0) { expandFirstItem(); } const expandedIndex = that.expandedIndexes[0]; if (expandedIndex === undefined) { return; } if (!that._supportCSSVariables || !that._usedCSSVariables) { if (oldValue === 'singleFitHeight') { that._items[expandedIndex].$.accordionItemContent.style.height = ''; } else if (newValue === 'singleFitHeight') { that._items[expandedIndex].$.accordionItemContent.style.height = (that._expandedItemsContainerHeight - 1) + 'px'; } } if (newValue === 'multiple' || newValue === 'toggle') { that._items[expandedIndex].$.label.removeAttribute('aria-disabled'); } else { that._items[expandedIndex].$.label.setAttribute('aria-disabled', true); } break; } case 'unfocusable': that._setFocusable(); break; default: break; } function expandFirstItem() { that._toggleItems('expand', [0]); that.expandedIndexes = [0]; } } /** * Appends a "lw-accordion-item" node as the last position. */ appendChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && (node.classList.contains('lw-resize-trigger-container') || node.classList.contains('lw-measure-element'))) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!(node instanceof LW.AccordionItem)) { that.error(that.localize('accordionItemRequired', { method: 'appendChild' })); } that.insert(that._items.length, node); } /** * Collapse method. Collapses selected item */ collapse(index, programmaticUse) { const that = this; index = that._validateItemsIndex(index, 'collapse'); if (isNaN(index)) { return; } const isExpanded = that._items[index].expanded; if ((!isExpanded) || (that._expandModeIs(['single', 'singleFitHeight']) && that.expandedIndexes.indexOf(index) > -1)) { return; } that._collapseItem(index, programmaticUse); } /** * Expand method. */ expand(index, programmaticUse) { const that = this; index = that._validateItemsIndex(index, 'expand'); if (isNaN(index)) { return; } const isExpanded = that._items[index].expanded; if (isExpanded) { return; } if (that._expandModeIs(['single', 'singleFitHeight', 'toggle'])) { that._toggleItems('collapse', that.expandedIndexes); } that._expandItem(index, programmaticUse); } /** * Inserts items in specific position. It has two parameters - index and item(items). */ insert(index, items) { const that = this, accordionWasEmpty = that._items.length === 0; let item, fragment; if (!items) { if (typeof index === 'number') { items = [{ label: '', content: '' }]; } else { items = [{ label: index ? index.toString() : '', content: index ? index.toString() : '' }]; index = 0; } } if (items instanceof HTMLElement) { if (!(items instanceof LW.AccordionItem)) { that.error(that.localize('accordionItemRequired', { method: 'insert' })); } else { item = items; } } else if (Array.isArray(items)) { fragment = document.createDocumentFragment(); for (let i = 0; i < items.length; i++) { const fragmentItem = that._createItem(items[i]); fragment.appendChild(fragmentItem); } } else if (items instanceof Object) { item = that._createItem(items); } else if (typeof items === 'string' || typeof items === 'number') { item = that._createItem({ label: items.toString(), content: items.toString() }); } else { item = that._createItem({ label: '', content: '' }); } if (index > that._items.length) { item ? that.$.container.appendChild(item) : that.$.container.appendChild(fragment); } else { item ? that.$.container.insertBefore(item, that._items[index]) : that.$.container.insertBefore(fragment, that._items[index]); } item && (item.tabIndex = that._tabIndex); that._storeItems(); if (accordionWasEmpty && that._expandModeIs(['single', 'singleFitHeight'])) { that._expandItem(0); } else { that.expandedIndexes = that._getExpandedIndexes(); } that._updateExpanedContentHeight(); that._updateInlineHeight(); that._storeItemsCoordinates(); that._updateItemsIndexProperty(); } /** * Inserts the specified "lw-accordion-item" node before the reference "lw-accordion-item" node. */ insertBefore(newNode, referenceNode) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (newNode === undefined || referenceNode === undefined || !(newNode instanceof LW.AccordionItem) || !(referenceNode instanceof LW.AccordionItem)) { that.error(that.localize('accordionItemRequired', { method: 'insertBefore' })); } if (referenceNode !== undefined && referenceNode !== null) { if (!that.contains(referenceNode)) { that.error(that.localize('referenceNodeNotChild', { argument: 'referenceNode' })); } that.insert(that._items.indexOf(referenceNode), newNode); } else { that.insert(that._items.indexOf(referenceNode), newNode); } } /** * Removes an item on specific positions or "lw-accordion-item" child node. */ removeAt(index) { const that = this; let item; if (index instanceof HTMLElement) { if (!(index instanceof LW.AccordionItem)) { that.error(that.localize('accordionItemRequired', { method: 'remove' })); } else if (!that.contains(index)) { that.error(that.localize('referenceNodeNotChild', { argument: 'node' })); } item = index; index = item.index; } else { index = that._validateItemsIndex(index, 'remove'); if (isNaN(index)) { return; } item = that._items[index]; } if (item) { item.parentNode.removeChild(item); that._storeItems(); if (that._expandModeIs(['singleFitHeight'])) { that._preventAnimation = true; } if (that._expandModeIs(['single', 'singleFitHeight']) && index === that.expandedIndexes[0] && that._items.length > 0) { that._expandItem(0); that._selectedItem = that._items[0]; that._selectedItemIndex = 0; that._itemIsFocussed = true; } that.expandedIndexes = that._getExpandedIndexes(); that._updateExpanedContentHeight(); that._updateInlineHeight(); that._storeItemsCoordinates(); that._updateItemsIndexProperty(); } } /** * Removes a child "lw-accordion-item" node. */ removeChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!(node instanceof HTMLElement)) { that.error(that.localize('accordionItemRequired', { method: 'removeChild' })); } if (node.className === 'lw-resize-trigger-container') { super.removeChild(node); return; } else if (!(node instanceof LW.AccordionItem)) { that.error(that.localize('accordionItemRequired', { method: 'removeChild' })); } if (!that.contains(node)) { that.error(that.localize('referenceNodeNotChild', { argument: 'node' })); } that.removeAt(node); } /** * Sets tabIndex. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); for (let i = 0; i < that._items.length; i++) { that._items[i].removeAttribute('tabindex'); } return; } that.tabIndex = that._tabIndex; for (let i = 0; i < that._items.length; i++) { that._items[i].tabIndex = that._tabIndex; } } /** * Updates an item at a specific index. It has two parameters - index and item. */ update(index, settings) { const that = this; index = that._validateItemsIndex(index, 'update'); if (isNaN(index)) { return; } let item = that._items[index]; if (!settings) { that.error(that.localize('invalidSettings', { elementType: that.nodeName.toLowerCase(), method: 'update' })); } if (item) { if (Array.isArray(settings)) { if (settings.length === 0) { settings = { 'label': '', 'content': '' } } else { settings = settings[0]; } } if (typeof settings === 'string') { item.content = settings; } else { for (let property in settings) { item[property] = settings[property]; } } } const height = that._getItemsHeights(index); that._updateExpanedContentLocalHeight(that._items[index], height); that._updateInlineHeight(); that._storeItemsCoordinates(); } /** * Calculates item container's height if items are with set margins */ _adjustHeightValue(currentHeight) { const that = this, itemsCount = that._items.length; let expandedItem, collapsedItem; for (let i = 0; i < itemsCount; i++) { that._items[i].expanded ? expandedItem = that._items[i] : collapsedItem = that._items[i]; if (expandedItem && collapsedItem) { break; } } if (!expandedItem) { expandedItem = that._items[0]; } if (!expandedItem && !collapsedItem) { return; } const expandedItemState = expandedItem.expanded; expandedItem.expanded = true; const expandedStyles = window.getComputedStyle(expandedItem, null), collapsedStyles = collapsedItem ? window.getComputedStyle(collapsedItem, null) : false, expandedOffset = parseInt(expandedStyles.getPropertyValue('margin-top')) + parseInt(expandedStyles.getPropertyValue('margin-bottom')), collapsedOffset = collapsedStyles ? parseInt(collapsedStyles.getPropertyValue('margin-top')) + parseInt(collapsedStyles.getPropertyValue('margin-bottom')) : 0; expandedItem.expanded = expandedItemState; return (currentHeight - ((itemsCount - 1) * collapsedOffset + expandedOffset)); } /** * Collapses item with specific index. */ _collapseItem(index, programmaticUse) { const that = this; let item = that._items[index]; if (!item.expanded) { return; } if (that.expandMode === 'none' && programmaticUse) { return; } item.expanded = false; that.$.fireEvent('collapsing', { 'index': index, 'label': item.label, 'content': item.content.innerHTML }); if (that.expandedIndexes.indexOf(index) > -1) { let positionInExpandedIndexes = that.expandedIndexes.indexOf(index), currentIndexes = that.expandedIndexes.slice(); currentIndexes.splice(positionInExpandedIndexes, 1); that.expandedIndexes = currentIndexes; } item.$.accordionItemContent.style.height = ''; that._handleAnimationsDuration(item, index, 'collapse'); } /** * Compares arrays with old and new indexes. Returns which items have to be collapsed and which have to be expanded */ _compareExpandedIndexes(oldIndexes, newIndexes) { let indexesToBeCollapsed = [], commonIndexes = [], indexesToBeExpanded = [], oldIndexesCount = oldIndexes.length, newIndexesCount = newIndexes.length; for (let i = 0; i < oldIndexesCount; i++) { if (newIndexes.indexOf(oldIndexes[i]) === -1) { if (indexesToBeCollapsed.indexOf(oldIndexes[i]) === -1) { indexesToBeCollapsed.push(oldIndexes[i]); } } else { if (commonIndexes.indexOf(oldIndexes[i]) === -1) { commonIndexes.push(oldIndexes[i]); } } } for (let i = 0; i < newIndexesCount; i++) { if (commonIndexes.indexOf(newIndexes[i]) === -1) { indexesToBeExpanded.push(newIndexes[i]); } } return { collapse: indexesToBeCollapsed, expand: indexesToBeExpanded }; } /** * Initializes the element. Used as a callback in ready(). */ _createElement() { const that = this; that._reorderItemsByIndex(); that._usedCSSVariables = Boolean(window.getComputedStyle(that.$.container).getPropertyValue('--lw-accordion-animation-duration')); that._supportCSSVariables = LW.Utilities.Core.CSSVariablesSupport(); that._storeItems(); that._enableDisableHandler(); that._expandedIndexesHandler(); that._updateExpanedContentHeight(); that._tabIndex = that.tabIndex <= 0 ? 0 : that.tabIndex; that._setFocusable(); that._updateItemsIndexProperty(); that._updateInlineHeight(); for (let i = 0; i < that._items.length; i++) { that._items[i].setAttribute('part', 'lw-accordion-item'); that._items[i].$.arrow.classList.add('lw-animate-trigger'); } } /** * Creates single lw-accordion-item */ _createItem(settings) { const that = this, item = document.createElement('lw-accordion-item'); if (!settings) { return; } item.disabled = that.disabled; if (that._tabIndex > -1) { item.tabIndex = that._tabIndex; } if (typeof settings === 'string' || typeof settings === 'number') { item.label = settings + ''; item.content = settings + ''; return item; } item.label = settings.label || ''; item.content = settings.content || ''; return item; } /** * Down Handler */ _downHandler(event) { const that = this; if (that.disabled || that.readonly || that.expandMode === 'none' || that._toggled) { return; } const target = that.enableShadowDOM && that.shadowRoot ? that.shadowRoot.elementFromPoint(event.pageX - window.pageXOffset, event.pageY - window.pageYOffset) : event.originalEvent.target, clickedHeader = target.closest('.lw-accordion-item-header'); const item = target.closest('lw-accordion-item'); if (!clickedHeader) { if (item) { item.focused = true; } return; } that._pointerPosition = event.pageY - window.pageYOffset; that._selectedItem = item; that._itemIsPressed = that._itemIsFocussed = true; that._reorderedIndex = that._selectedItemIndex = that._items.indexOf(item); that._storeItemsCoordinates(); } /** * Changes disable state of the internal items. */ _enableDisableHandler() { const that = this; if (that.disabled) { for (let i = 0; i < that._items.length; i++) { that._items[i].disabled = true; } } else { for (let i = 0; i < that._items.length; i++) { that._items[i].disabled = false; } } } /** * Handles expanded indexes on initialization, according to the chosen 'expandMode'. */ _expandedIndexesHandler() { const that = this; let initialExpandedIndexes = that._getExpandedIndexes('initial'), initialExpandedIndexesCount = initialExpandedIndexes.length, expandedIndexesCount = that.expandedIndexes.length; if (that._items.length === 0) { that._animationAfterInitialization = true; return; } if (expandedIndexesCount === 0 && initialExpandedIndexesCount > 0) { that.expandedIndexes = initialExpandedIndexes; expandedIndexesCount = initialExpandedIndexesCount; } if (that._expandModeIs(['multiple', 'none']) || expandedIndexesCount === 1) { that._toggleItems('expand', that.expandedIndexes); that._animationAfterInitialization = true; return; } switch (that.expandMode) { case 'single': case 'singleFitHeight': if (expandedIndexesCount === 0) { that._toggleItems('expand', [0]); } else if (expandedIndexesCount > 1) { that._toggleItems('collapse', that.expandedIndexes.splice(0, 1)); that._toggleItems('expand', that.expandedIndexes); } break; case 'toggle': if (expandedIndexesCount > 1) { that._toggleItems('collapse', that.expandedIndexes.splice(0, 1)); that._toggleItems('expand', that.expandedIndexes); } break; default: break; } that._animationAfterInitialization = true; } /** * Expands item with specific index. */ _expandItem(index, programmaticUse) { const that = this; let item = that._items[index]; if (item.expanded || (that.expandMode === 'none' && programmaticUse)) { return; } if (!item.$.container.style.getPropertyValue('--lw-accordion-expanded-content-local-height')) { item.expanded = true; item.$.container.style.setProperty('--lw-accordion-expanded-content-local-height', item.$.accordionItemContent.scrollHeight + 'px'); item.expanded = false; } item.expanded = true; that.$.fireEvent('expanding', { 'index': index, 'label': item.label, 'content': item.content.innerHTML }); if (that.expandedIndexes.indexOf(index) === -1) { let currentIndexes = that.expandedIndexes.slice(); currentIndexes.push(index); that.expandedIndexes = currentIndexes; } if ((!that._supportCSSVariables || !that._usedCSSVariables) && that.expandMode === 'singleFitHeight') { item.$.accordionItemContent.style.height = (that._expandedItemsContainerHeight - 1) + 'px'; } that._handleAnimationsDuration(item, index, 'expand'); } /** * Check if current expand mode is one of the following. */ _expandModeIs(modesArray) { const that = this; return modesArray.indexOf(that.expandMode) > -1; } /** * Focus handler. Sets the focused state of particular item */ _focusHandler() { const that = this; if (that.disabled || that._items.length === 0) { return; } if (that._itemIsFocussed) { that._selectedItem.focused = false; } else { that._items[0].focused = false; } } /** * Gets the indexes of all expanded items. */ _getExpandedIndexes(type) { const that = this, expandedIndexes = []; for (let i = 0; i < that._items.length; i++) { if (type === 'initial') { if (that._items[i].hasAttribute('expanded')) { expandedIndexes.push(i); that._items[i].removeAttribute('expanded'); } } else { if (that._items[i].expanded) { expandedIndexes.push(i); } } } return expandedIndexes.slice(); } /** * Gets the height of each item. Calculates it via dummy element */ _getItemsHeights(itemIndex) { const that = this, items = that._items, itemsCount = items.length; let itemsHeights = []; if (itemsCount === 0) { return; } if (!isNaN(itemIndex) && itemIndex >= 0 && itemIndex < itemsCount) { const item = items[itemIndex]; let height = 0; if (item.expanded) { height = item.$.accordionItemContent.scrollHeight; } else { item.expanded = true; height = item.$.accordionItemContent.scrollHeight; item.expanded = false; } return (height + 'px'); } for (let i = 0; i < itemsCount; i++) { const item = items[i]; let height = 0; if (item.expanded) { height = item.$.accordionItemContent.scrollHeight; } else { item.expanded = true; height = item.$.accordionItemContent.scrollHeight; item.expanded = false; } itemsHeights.push(height + 'px'); } that._heightCalcAfterInitialization = true; return itemsHeights; } /** * Adds lw-toggle class for the period of the animation and fires an event at the end */ _handleAnimationsDuration(item, index, type) { const that = this, intervalOffset = 50; if (!that._animationAfterInitialization) { return; } if (that._items.length === 1 && that.expandMode === 'singleFitHeight') { that.$.fireEvent(type, { 'index': index, 'label': item.label, 'content': item.content.innerHTML }); return; } if (false === that.hasAnimation || !that._supportCSSVariables) { that.$.fireEvent(type, { 'index': index, 'label': item.label, 'content': item.content.innerHTML }); return; } if (that._preventAnimation) { that.$.fireEvent(type, { 'index': index, 'label': item.label, 'content': item.content.innerHTML }); that._preventAnimation = false; return; } that._toggled = true; let animationDuration = window.getComputedStyle(that).animationDuration, animationDurationInMs; if (animationDuration.indexOf('ms') > -1) { animationDuration = parseFloat(animationDuration.substring(0, animationDuration.length - 2)); animationDurationInMs = isNaN(animationDuration) || animationDuration < 0 ? 0 : animationDuration - intervalOffset; } else if (animationDuration.indexOf('s') > -1) { animationDuration = parseFloat(animationDuration.substring(0, animationDuration.length - 1)); animationDurationInMs = isNaN(animationDuration) || animationDuration < 0 ? 0 : animationDuration * 1000 - intervalOffset; } else { that.$.fireEvent(type, { 'index': index, 'label': item.label, 'content': item.content.innerHTML }); return; } if (item) { item.$.addClass('lw-toggled-item'); that.$container.addClass('lw-toggling'); setTimeout(function () { item.$.removeClass('lw-toggled-item'); that.$container.removeClass('lw-toggling'); that.$.fireEvent(type, { 'index': index, 'label': item.label, 'content': item.content.innerHTML }); that._toggled = false; }, animationDurationInMs); } } /** * Index change handler. Used when items are reordered via their indexes */ _indexChangeHandler(event) { const that = this, items = that._items, itemsCount = items.length, detail = event.detail; if (detail.newIndex >= itemsCount) { that.$.container.appendChild(items[detail.oldIndex]); } else { detail.newIndex > detail.oldIndex ? that.$.container.insertBefore(items[detail.oldIndex], items[detail.newIndex + 1]) : that.$.container.insertBefore(items[detail.oldIndex], items[detail.newIndex]); } let itemsReordered = that.enableShadowDOM && that.shadowRoot ? that.shadowRoot.querySelectorAll('lw-accordion-item') : that.getElementsByTagName('lw-accordion-item'); that._items = Array.from(itemsReordered); that._updateItemsIndexProperty(); } /** * KeyDown handler. Navigation between the items via arrows, home, end keys */ _keyDownHandler(event) { const that = this, keyCode = event.key; if (that.expandMode === 'none' || that.disabled || that.readonly || that._toggled) { return; } const activeElement = (that.shadowRoot ? that.shadowRoot.activeElement : document.activeElement) || document.activeElement; if (['ArrowLeft', 'ArrowDown', 'ArrowRight', 'ArrowUp', 'End', 'Home', ' ', 'Enter', 'Tab'].indexOf(keyCode) === -1 || !(activeElement instanceof LW.AccordionItem)) { return; } if (keyCode !== 'Tab') { event.preventDefault(); } let selectedItem, selectedIndex, itemsCount = that._items.length, lastItemPosition = itemsCount - 1; for (let i = 0; i < itemsCount; i++) { let item = that._items[i]; if (item.focused) { selectedItem = item; selectedIndex = i; } } switch (keyCode) { case 'Tab': event.shiftKey ? moveSelection('up') : moveSelection('down'); break; case 'ArrowLeft': that.collapse(selectedIndex); break; case 'ArrowDown': moveSelection('down'); break; case 'ArrowRight': that.expand(selectedIndex); break; case 'ArrowUp': moveSelection('up'); break; case 'End': updateSelectedItem(lastItemPosition); break; case 'Home': updateSelectedItem(0); break; case ' ': case 'Enter': if (selectedItem.expanded) { that.collapse(selectedIndex); return } that.expand(selectedIndex); break; default: return; } function updateSelectedItem(index) { if (index === selectedIndex || isNaN(index)) { return; } selectedItem.focused = false; selectedIndex = index; selectedItem = that._items[selectedIndex]; selectedItem.focused = true; } function moveSelection(direction) { if (direction === 'up') { (selectedIndex - 1) < 0 ? updateSelectedItem(0) : updateSelectedItem(selectedIndex - 1); return; } (selectedIndex + 1) > lastItemPosition ? updateSelectedItem(lastItemPosition) : updateSelectedItem(selectedIndex + 1); } } /** * iOS Fix for the lack of support for 'touch-action: none' */ _containerMoveHandler(event) { if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * Accordion's move handler. Used in reorder functionality */ _moveHandler(event) { const that = this; event.stopPropagation(); if (!that._itemIsPressed || !that.reorder || that.readonly || that._items.length < 2 || (!that.$container.hasClass('lw-reordering') && Math.abs(event.pageY - that._pointerPosition) < 5)) { return; } if (that._dragStart) { if (!that.$container.hasClass('lw-reordering')) { that.$container.addClass('lw-reordering'); } if (!that._dragging) { const item = that._selectedItem; that.$.fireEvent('dragStart', { 'position': { left: event.pageX, top: event.pageY }, 'target': event.originalEvent.target, 'index': that._selectedItemIndex, 'label': item.label, 'content': item.content.innerHTML }); that._selectedItem.dragged = that._dragging = true; } //Cancels the ripple animation during reorder but doesn't interfere with it's event listeners if (that.hasAnimation) { const ripple = that._selectedItem.querySelector('.lw-ripple'); if (ripple) { ripple.style.height = 0; } } const mouseCoordinate = event.clientY; let inItem = false; for (let i = 0; i < that._itemsCoordinates.length; i++) { const currentCoordinateSet = that._itemsCoordinates[i]; if (mouseCoordinate >= currentCoordinateSet.fromY && mouseCoordinate <= currentCoordinateSet.toY) { inItem = i; break; } } const hoveredItem = that._items[inItem]; if (inItem !== false && hoveredItem !== that._selectedItem) { if (that._lastReorderedItem && hoveredItem === that._lastReorderedItem) { return; } that._lastReorderedItem = hoveredItem; if (Math.abs(that._reorderedIndex - inItem) > 1) { const indexOffset = that._reorderedIndex - inItem < 0 ? -1 : 1; that._swapItems(that._reorderedIndex, inItem + indexOffset); } that._swapItems(that._reorderedIndex, inItem); that._reorderedIndex = inItem; that._storeItemsCoordinates(); return; } that._lastReorderedItem = undefined; } else { that._dragStart = true; } } /** * Reorders the items by their indexes when the accordion is initialized. */ _reorderItemsByIndex() { const that = this; let items = that.enableShadowDOM && that.shadowRoot ? that.shadowRoot.querySelectorAll('lw-accordion-item') : that.$.container.children, itemsArray = Array.from(items), hasInitialIndexes = false, itemsIndexes = itemsArray.map(function (item) { if (item.index !== null) { hasInitialIndexes = true; } else { item.index = 0; } return item.index; }); if (!hasInitialIndexes) { return; } const itemsCount = itemsArray.length; if (itemsCount < 2) { return; } let itemsIndexesSorted = itemsIndexes.slice(); itemsIndexesSorted.sort(function (a, b) { return parseInt(a) - parseInt(b); }); if (itemsIndexes.toString() === itemsIndexesSorted.toString()) { return; } for (let i = 0; i < itemsCount; i++) { let reorderedItem; for (let j = 0; j < itemsCount; j++) { if (items[j].index === itemsIndexesSorted[i]) { reorderedItem = items[j]; } } that.$.container.insertBefore(reorderedItem, items[i]); } } /** * Resize handler. */ _resizeHandler() { const that = this; that._updateExpanedContentHeight(); that._updateInlineHeight(); that._storeItemsCoordinates(); } /** * Stores all items in an Array and updates the animation variables. */ _storeItems() { const that = this, items = that.enableShadowDOM && that.shadowRoot ? that.shadowRoot.querySelectorAll('lw-accordion-item') : that.getElementsByTagName('lw-accordion-item'); that._items = Array.from(items); if (that._items.length === 0) { that.$container.addClass('lw-empty'); return; } that.$container.removeClass('lw-empty'); const heights = that._getItemsHeights(); for (let i = 0; i < that._items.length; i++) { that._updateExpanedContentLocalHeight(that._items[i], heights[i]); } } /** * Stores the coordinates of all items in an Array. */ _storeItemsCoordinates() { const that = this; if (that.disabled || !that.reorder) { return; } const coordinates = []; for (let i = 0; i < that._items.length; i++) { const currentItemContainer = that._items[i], boundingClientRect = currentItemContainer.getBoundingClientRect(); coordinates.push({ fromY: boundingClientRect.top + (window.scrollY || window.pageYOffset), toY: boundingClientRect.bottom + (window.scrollY || window.pageYOffset) }); } that._itemsCoordinates = coordinates; } /** * Switches the positions of two items. */ _swapItems(firstItemIndex, secondItemIndex) { function swap(list, x, y) { const temp = list[y]; list[y] = list[x]; list[x] = temp; } const that = this, lesserIndex = Math.min(firstItemIndex, secondItemIndex), greaterIndex = Math.max(firstItemIndex, secondItemIndex), items = that._items; let expandedIndexes = that.expandedIndexes.slice(); if (that._items[firstItemIndex].expanded && !that._items[secondItemIndex].expanded) { const indexPosition = expandedIndexes.indexOf(firstItemIndex); expandedIndexes[indexPosition] = secondItemIndex; that.expandedIndexes = expandedIndexes.slice(); } else if (that._items[secondItemIndex].expanded && !that._items[firstItemIndex].expanded) { const indexPosition = expandedIndexes.indexOf(secondItemIndex); expandedIndexes[indexPosition] = firstItemIndex; that.expandedIndexes = expandedIndexes.slice(); } that.selectedIndex = that.selectedIndex === firstItemIndex ? secondItemIndex : firstItemIndex; that.$.container.insertBefore(items[greaterIndex], items[lesserIndex]); swap(items, firstItemIndex, secondItemIndex); that._items[firstItemIndex].$.removeClass('hovered'); that._reorderedIndex = secondItemIndex; } /** * Expands/collapses multiple items with particular indexes. */ _toggleItems(action, indexes) { const that = this, indexesCount = indexes.length; if (indexesCount > 0) { for (let i = 0; i < indexesCount; i++) { that['_' + action + 'Item'](indexes[i]); } } } /** * Calculates item's content container height and apply it to the current expanded item. Used in singleFitHeight expandMode. */ _updateExpanedContentHeight() { const that = this; that.$.container.style.setProperty('--lw-accordion-item-header-height', ''); const itemsCount = that._items.length, containersHeight = that.$.container.offsetHeight, expanedItem = that._items[that.expandedIndexes[0]]; let collapsedItemHeight = 0, collapsedItemHeaderHeight = 0, expanedItemHeaderOffset = 0, i = 0; if (itemsCount === 1) { let item = that._items[0], expandedState = item.expanded; item.expanded = false; collapsedItemHeight = item.offsetHeight; collapsedItemHeaderHeight = item.$.accordionItemHeader.offsetHeight; item.expanded = expandedState; } else { while (collapsedItemHeight === 0 && i < itemsCount) { const item = that._items[i]; if (item instanceof LW.AccordionItem && !item.expanded) { collapsedItemHeight = item.offsetHeight; collapsedItemHeaderHeight = item.$.accordionItemHeader.offsetHeight; } i++; } } if (itemsCount > 1) { if (expanedItem instanceof LW.AccordionItem) { const expandedItemHeaderHeight = expanedItem.$.accordionItemHeader.offsetHeight; expanedItemHeaderOffset = expandedItemHeaderHeight - collapsedItemHeaderHeight; } } const rootStyle = getComputedStyle(that.$.root); const collapsedItemsHeight = collapsedItemHeight * itemsCount; let expandedItemsContainerHeight = containersHeight - collapsedItemsHeight - expanedItemHeaderOffset - parseFloat(rootStyle.paddingBottom) - parseFloat(rootStyle.paddingTop); if (that.expandMode === 'singleFitHeight') { expandedItemsContainerHeight = that._adjustHeightValue(expandedItemsContainerHeight); } expandedItemsContainerHeight = expandedItemsContainerHeight >= 0 ? expandedItemsContainerHeight : 0; that.$.container.style.setProperty('--lw-accordion-expanded-content-height', expandedItemsContainerHeight + 'px'); that.$.container.style.setProperty('--lw-accordion-item-header-height', collapsedItemHeaderHeight + 'px'); that._expandedItemsContainerHeight = expandedItemsContainerHeight; } /** * Updates the local CSS variable about single item. */ _updateExpanedContentLocalHeight(item, height) { const that = this; if (!that._supportCSSVariables || !that._usedCSSVariables) { return; } item.$.container.style.setProperty('--lw-accordion-expanded-content-local-height', height); } /** * Updates inline height in 'singleFitHeight' mode in older browsers */ _updateInlineHeight() { const that = this; if ((that._supportCSSVariables && that._usedCSSVariables) || that.expandMode !== 'singleFitHeight' || that._items.length === 0) { return; } that._items[that.expandedIndexes[0]].$.accordionItemContent.style.height = (that._expandedItemsContainerHeight - 1) + 'px'; } /** * Updates the index property of all accordion items */ _updateItemsIndexProperty() { const that = this; let newExpandedIndexes = []; for (let i = 0; i < that._items.length; i++) { that._items[i]._setIndex(i); if (that._items[i].expanded) { newExpandedIndexes.push(i); } } that.expandedIndexes = newExpandedIndexes.slice(); } /** * Up handler. */ _upHandler(event) { const that = this; if (!that._itemIsPressed || that.disabled || that.readonly) { return; } for (let i = 0; i < that._items.length; i++) { if (i !== that._selectedItemIndex) { that._items[i].focused = false; } } that._selectedItem.focused = true; if (!that._dragging) { if (that._selectedItem.expanded) { that.collapse(that._selectedItemIndex, true); } else { that.expand(that._selectedItemIndex, true); } } else { const item = that._selectedItem; that.$container.removeClass('lw-reordering'); that.$.fireEvent('dragEnd', { 'position': { left: event.pageX, top: event.pageY }, 'target': event.originalEvent.target, 'index': that._selectedItemIndex, 'label': item.label, 'content': item.content.innerHTML }); } that._reorderedIndex = undefined; that._dragStart = false; that._dragging = false; that._itemIsPressed = false; that._selectedItem.dragged = false; that._updateItemsIndexProperty(); } /** * Validates the values given to the expand and collapse methods. */ _validateItemsIndex(index, method) { const that = this; if (isNaN(parseInt(index)) || index < 0 || index > that._items.length - 1) { that.log(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: method })); return; } return parseInt(index); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-rating', class Rating extends LW.BaseElement { static get properties() { return { 'max': { value: 5, type: 'number' }, 'name': { value: 'rating', type: 'string' }, 'value': { value: 3, type: 'number' } }; } static get listeners() { return { 'stars.click': '_clickHandler', 'stars.move': '_moveHandler', 'stars.mouseout': '_mouseoutHandler' }; } attached() { // this.itemsIndexes = [...Array(this.max).keys()]; if (this.value > this.max) { this.value = this.max; } this._updateActiveStars(this.value); } template() { return `<div id="container" role="presentation"> <div id="stars" class="lw-content" role="presentation"> <template> <div id="ratingStars" *items={{max}} role="presentation"><span class="rating-star" index={{item}} role="button" aria-label="Star"></span></div> </template> </div> <input class="lw-hidden" value="[[value]]" name="[[max]]"></input> </div>`; } render() { const that = this; that.setAttribute('role', 'group'); if (!that.disabled) { that.setAttribute('tabindex', '0'); } that.$.stars.firstElementChild.setAttribute('role', 'presentation'); super.render(); } _clickHandler(event) { if (event.target.className.includes('rating-star')) { const star = event.target; const ratingContainer = star.parentNode; const starIndex = Array.prototype.indexOf.call(ratingContainer.children, star); this.value = starIndex + 1; this._updateActiveStars(this.value); this._updateHoveredStars(0); } } _moveHandler(event) { const that = this; const getOffset = (el) => { const rect = el.getBoundingClientRect(); return { left: rect.left + window.scrollX, top: rect.top + window.scrollY }; } const getHoveredStarIndex = () => { const stars = that.querySelectorAll('#ratingStars .rating-star'); for (let i = 0; i < stars.length; i++) { const offset = getOffset(stars[i]); if (event.x >= offset.left && event.x <= offset.left + stars[i].offsetWidth) { return i; } } } const starIndex = getHoveredStarIndex(); that._updateHoveredStars(starIndex + 1); } _mouseoutHandler() { this._updateHoveredStars(0); } _updateActiveStars(value) { const stars = this.getElementsByClassName('rating-star'); for (let i = 0; i < stars.length; i++) { if (i < value) { stars[i].classList.add('active'); } else { stars[i].classList.remove('active'); } } } _updateHoveredStars(value) { if (LW.Utilities.Core.isMobile) { return; } const stars = this.getElementsByClassName('rating-star'); for (let i = 0; i < stars.length; i++) { if (i < value) { stars[i].classList.add('hover'); } else { stars[i].classList.remove('hover'); } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Calendar custom element. */ LW('lw-calendar', class Calendar extends LW.BaseElement { /** * Calendar's properties */ static get properties() { return { 'animationSettings': { value: null, type: 'object' }, 'calendarMode': { value: 'default', allowedValues: ['default', 'classic'], type: 'string' }, 'dayNameFormat': { value: 'firstTwoLetters', allowedValues: ['narrow', 'firstTwoLetters', 'long', 'short'], type: 'string' }, 'dateFormatFunction': { value: null, type: 'function' }, 'disableAutoNavigation': { value: false, type: 'boolean' }, 'displayMode': { value: 'month', allowedValues: ['month', 'year', 'decade'], type: 'string' }, 'displayModeView': { value: 'table', allowedValues: ['table', 'list'], type: 'string' }, 'dropDownHeight': { value: '200', type: 'string' }, 'dropDownWidth': { value: 'initial', type: 'string' }, 'firstDayOfWeek': { value: 0, type: 'number', defaultValue: 0, validator: '_firstDayOfWeekValidator' }, 'footerTemplate': { value: null, type: 'any' }, 'headerTemplate': { value: null, type: 'any' }, 'hideDayNames': { value: false, type: 'boolean' }, 'hideOtherMonthDays': { value: false, type: 'boolean' }, 'hideTooltipArrow': { value: false, type: 'boolean' }, 'importantDates': { value: [], type: 'array', defaultValue: [] }, 'importantDatesTemplate': { value: null, type: 'any' }, 'max': { value: new Date(2100, 1, 1), type: 'any', defaultValue: new Date(2100, 1, 1) }, 'min': { value: new Date(1900, 1, 1), type: 'any', defaultValue: new Date(1900, 1, 1) }, 'months': { value: 1, type: 'number', defaultValue: 1, validator: '_monthsValidator' }, 'monthNameFormat': { value: 'long', allowedValues: ['narrow', 'firstTwoLetters', 'long', 'short', '2-digit', 'numeric'], type: 'string' }, 'name': { value: '', type: 'string' }, 'restrictedDates': { value: [], type: 'array', defaultValue: [] }, 'scrollButtonsNavigationMode': { value: 'landscape', allowedValues: ['portrait', 'landscape'], type: 'string' }, 'scrollButtonsPosition': { value: 'both', allowedValues: ['near', 'far', 'both'], type: 'string' }, 'selectedDates': { value: [], reflectToAttribute: false, type: 'array' }, 'selectionMode': { value: 'default', allowedValues: ['none', 'default', 'one', 'many', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'week', 'range'], type: 'string' }, 'spinButtonsDelay': { value: 80, type: 'number' }, 'spinButtonsInitialDelay': { value: 0, type: 'number' }, 'titleTemplate': { value: null, type: 'any' }, 'tooltip': { value: false, type: 'boolean' }, 'tooltipArrow': { value: true, type: 'boolean' }, 'tooltipArrowDirection': { allowedValues: ['bottom', 'top', 'left', 'right', 'none'], value: 'bottom', type: 'string' }, 'tooltipDelay': { value: 100, type: 'number' }, 'tooltipOffset': { value: [], type: 'array' }, 'tooltipPosition': { value: 'auto', allowedValues: ['auto', 'bottom', 'top', 'left', 'right', 'absolute'], type: 'string' }, 'tooltipTemplate': { value: null, type: 'any' }, 'view': { value: 'portrait', allowedValues: ['landscape', 'portrait'], type: 'string' }, 'viewSections': { value: ['header'], type: 'array' }, 'weekNumbers': { value: false, type: 'boolean' }, 'weeks': { value: 6, type: 'number', defaultValue: 6, validator: '_weeksValidator' }, 'yearFormat': { value: 'numeric', allowedValues: ['2-digit', 'numeric'], type: 'string' } } } /** * Calendar's event listeners. */ static get listeners() { return { 'container.down': '_downHandler', 'document.up': '_documentUpHandler', 'body.move': '_moveHandler', 'container.wheel': '_containerWheelHandler', 'body.focus': '_bodyFocusStateHandler', 'body.blur': '_bodyBlurStateHandler', 'header.click': '_headerClickHandler', 'header.change': '_headerChangeHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler', 'listViewContainer.keydown': '_listViewContainerKeyDownHandler', 'listViewContainer.change': '_listViewContainerChangeEventHandler', 'listViewContainer.itemClick': '_listViewContainerItemClickHandler', 'mouseenter': '_mouseEventsHandler', 'mouseleave': '_mouseEventsHandler', 'container.mouseover': '_mouseEventsHandler', 'container.mouseout': '_mouseEventsHandler', 'container.open': '_popupEventHandler', 'container.close': '_popupEventHandler' } } static get methods() { return { 'select': 'select(date=new Date(): date|string): void', 'clearSelection': 'clearSelection(): void', 'today': 'today(): date', 'navigate': 'navigate(step: date|string|int): bool' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.calendar.css' ] } /** * Calendar's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="title" class="lw-calendar-title" role="heading" aria-level="1"> <div id="yearContainer" class="lw-calendar-year-container" role="button"></div> <div id="dateContainer" class="lw-calendar-date-container lw-calendar-selected" role="button"></div> </div> <div id="calendarContainer" class="lw-calendar-container"> <div id="header" class="lw-calendar-header"> <lw-repeat-button prev-month class="lw-calendar-button" id="previousMonthButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]" right-to-left="[[rightToLeft]]" aria-label="Previous month"> <span aria-hidden="true"></span> </lw-repeat-button> <div id="dateElement" class="lw-calendar-date-element" role="presentation"> <div id="defaultHeaderDate" role="button"></div> <div id="classicHeaderDate"> <lw-drop-down-list class="lw-calendar-month-element" id="monthElement" drop-down-position="bottom" selection-mode="one" disabled="[[disabled]]" right-to-left="[[rightToLeft]]" readonly="[[readonly]]" drop-down-width="[[dropDownWidth]]" drop-down-height="[[dropDownHeight]]" theme="[[theme]]"> </lw-drop-down-list> <input class="lw-calendar-year-element" id="yearElement" disabled="[[disabled]]" readonly="[[readonly]]" aria-label="Year" /> <span class="lw-calendar-year-elements"> <lw-repeat-button next-year class="lw-calendar-button" id="nextYearButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]" right-to-left="[[rightToLeft]]" aria-label="Next year"> <span aria-hidden="true"></span> </lw-repeat-button> <lw-repeat-button prev-year class="lw-calendar-button" id="previousYearButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]" right-to-left="[[rightToLeft]]" aria-label="Previous year"> <span aria-hidden="true"></span> </lw-repeat-button> </span> </div> </div> <lw-repeat-button next-month class="lw-calendar-button" id="nextMonthButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]" right-to-left="[[rightToLeft]]" aria-label="Next month"> <span aria-hidden="true"></span> </lw-repeat-button> </div> <div id="body" class="lw-content lw-calendar-body" role="presentation"> <div id="monthsContainer" class="lw-calendar-months-container" role="presentation"> <div id="month" class="lw-calendar-month" role="grid"> <div id="monthName" class="lw-calendar-month-name"></div> <div id="weekTitles" class="lw-calendar-week-titles" role="row"> <div class="lw-calendar-week-title" role="columnheader"></div> <div class="lw-calendar-week-title" role="columnheader"></div> <div class="lw-calendar-week-title" role="columnheader"></div> <div class="lw-calendar-week-title" role="columnheader"></div> <div class="lw-calendar-week-title" role="columnheader"></div> <div class="lw-calendar-week-title" role="columnheader"></div> <div class="lw-calendar-week-title" role="columnheader"></div> <div class="lw-calendar-week-title" role="columnheader"></div> </div> <div id="weeks" class="lw-calendar-weeks" role="rowgroup"> <div class="lw-calendar-week" role="row"> <div class="lw-calendar-week-number" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"> </div> </div> <div class="lw-calendar-week" role="row"> <div class="lw-calendar-week-number" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> </div> <div class="lw-calendar-week" role="row"> <div class="lw-calendar-week-number" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> </div> <div class="lw-calendar-week" role="row"> <div class="lw-calendar-week-number" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> </div> <div class="lw-calendar-week" role="row"> <div class="lw-calendar-week-number" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> </div> <div class="lw-calendar-week" role="row"> <div class="lw-calendar-week-number" role="rowheader"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"></div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> <div class="lw-calendar-cell" role="gridcell"> </div> </div> </div> </div> </div> <div id="dateViewContainer" class="lw-calendar-date-view-container lw-hidden"> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> <div class="lw-calendar-cell" role="button"></div> </div> <div id="monthsSeparator" class="lw-calendar-month-separator"></div> <div id="nextMonthsContainer" class="lw-calendar-next-months-container" aria-hidden="true"></div> <lw-list-box id="listViewContainer" class="lw-calendar-list-view lw-hidden" right-to-left="[[rightToLeft]]" item-height="30" unfocusable selection-mode="one" animation="simple"> </lw-list-box> <div id="animationPanel" class="lw-calendar-animation-panel lw-hidden"></div> </div> <div id="footer" class="lw-calendar-footer lw-hidden"> <div id="selectedDatesRange"></div> </div> <lw-tooltip id="tooltip" open-mode="manual" right-to-left="[[rightToLeft]]" arrow="[[tooltipArrow]]" tooltip-template="[[tooltipTemplate]]" arrow-direction="[[tooltipArrowDirection]]" offset="[[tooltipOffset]]" position="[[tooltipPosition]]" delay="[[tooltipDelay]]" disabled="[[disabled]]"> </lw-tooltip> <input id="hiddenInput" type="hidden" name="[[name]]"> </div> </div>`; } /** * Updates the Calendar when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'animationSettings': that._applyAnimationSettings(); break; case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'calendarMode': that.displayMode = 'month'; that._refreshCalendarMode(); that._setDisplayModeContent(); break; case 'dayNameFormat': that._refreshDayOfWeekTitles(that.$.month); break; case 'dateFormatFunction': { let months = that.$.monthsContainer.children; for (let m = 0; m < months.length; m++) { months[m].firstElementChild.innerHTML = newValue ? newValue(months[m]._date) : that._monthsNames[months[m]._date.getMonth()] + ' ' + months[m]._date.toLocaleDateString(that.locale, { year: that.yearFormat }); } that._refreshHeaderTitle(); break; } case 'displayMode': if (that.calendarMode === 'classic' && newValue !== 'month') { that[propertyName] = 'month'; break; } that._setDisplayMode(oldValue, newValue); break; case 'displayModeView': that._applyAnimationSettings(true); if (that.displayMode !== 'month') { that._setDisplayModeContent(); } break; case 'firstDayOfWeek': that._handleMonths(); that._refreshDayOfWeekTitles(); break; case 'hideTooltipArrow': that.$.tooltip.arrow = newValue ? false : true; break; case 'titleTemplate': case 'headerTemplate': case 'footerTemplate': that._handleLayoutTemplate(that.$[propertyName.split(/[T]/)[0]], newValue); if (propertyName === 'titleTemplate') { that._refreshTitle(); } else if (propertyName === 'headerTemplate') { that._refreshHeaderTitle(); } else { that._refreshFooter(); } break; case 'importantDates': that.importantDates = that._getValidDates(newValue); that._refreshImportantDates(); break; case 'importantDatesTemplate': that._handleImportantDateTemplate(); that._refreshImportantDates(); break; case 'locale': that._refreshMonthNames(); that._refreshDayOfWeekTitles(); that._refreshHeaderTitle(); that._refreshTitle(); that._refreshFooter(); if (that.displayMode && that.displayMode !== 'month') { that._setDisplayModeContent(); } break; case 'max': case 'min': that._validateMinMax(propertyName, newValue, oldValue); that._validateSelectedDates(); that._noFocusingRequired = false; that._refreshHeaderElements(); break; case 'months': that._handleMonths(); break; case 'monthNameFormat': that._refreshCalendarMode(); that._refreshHeaderTitle(); break; case 'restrictedDates': that._setRestrictedDates(that.restrictedDates = that._getValidDates(newValue)); break; case 'rightToLeft': that._refreshDayOfWeekTitles(); that._handleMonths(); break; case 'scrollButtonsNavigationMode': that._setScrollButtonsNavigationMode(); break; case 'selectedDates': that._clearSelection(true); that._validateSelectedDates(that._getValidDates(newValue)); that._applySelectionMode(true); if (that._viewDates) { let lastSelectedDate = that.selectedDates[that.selectedDates.length - 1]; !that._isDateInView(lastSelectedDate) ? //true flags indicate eventPrevention and noPropertySynchronization that._handleMonths(lastSelectedDate) : that.selectedDates.map(date => that._selectDate(date, true, true)); } that._refreshFooter(); that._setWeeksVisibility(that.$.monthsContainer); //Update the hidden input that.$.hiddenInput.value = that.selectedDates.toString(); if (that.isInitialized) { that.$.fireEvent('change', { 'value': that.selectedDates }); } that._refreshTitle(); if (that.displayMode !== 'month') { that._setDisplayModeContent(); } break; case 'selectionMode': that._applySelectionMode(false, oldValue); that._refreshTitle(); break; case 'view': that._refreshTitle(); break; case 'viewSections': newValue.indexOf('title') > -1 ? that.$title.removeClass('lw-hidden') : that.$title.addClass('lw-hidden'); that._refreshTitle(); newValue.indexOf('header') > -1 ? that.$header.removeClass('lw-hidden') : that.$header.addClass('lw-hidden'); that._refreshHeaderTitle(); newValue.indexOf('footer') > -1 ? that.$footer.removeClass('lw-hidden') : that.$footer.addClass('lw-hidden'); that._refreshFooter(); that._setFocusable(); break; case 'weeks': that._setWeeksVisibility(that.$.monthsContainer); break; case 'yearFormat': that._refreshCalendarMode(); that._refreshFooter(); //Set month name if (that.months > 1 && that.displayMode === 'month') { let months = that._animationStarted ? that.$.nextMonthsContainer.children : that.$.monthsContainer.children; for (let i = 0; i < months.length; i++) { months[i].firstElementChild.innerHTML = that.dateFormatFunction ? that.dateFormatFunction(months[i]._date) : that._monthsNames[months[i]._date.getMonth()] + ' ' + months[i]._date.toLocaleDateString(that.locale, { year: newValue }); } } that._refreshTitle(); that._refreshHeaderTitle(); break; } } /** * Calendar ready method. */ ready() { super.ready(); const that = this; that._keysPressed = {}; that._applyAnimationSettings(); that.importantDates = that._getValidDates(that.importantDates); that.restrictedDates = that._getValidDates(that.restrictedDates); } render() { const that = this; that.setAttribute('role', 'dialog'); that._refreshMonthNames(); that._validateMinMax(); that._validateSelectedDates(that._getValidDates(that.selectedDates)); that._handleLayoutTemplate(that.$.title, that.titleTemplate); that._handleLayoutTemplate(that.$.header, that.headerTemplate); that._handleLayoutTemplate(that.$.footer, that.footerTemplate); that._handleImportantDateTemplate(); that._setFocusable(); that._refreshDayOfWeekTitles(); that._applySelectionMode(true); that._handleMonths(that.selectedDates.length === 0 ? new Date(new Date().setHours(0, 0, 0, 0)) : that.selectedDates[that.selectedDates.length - 1]); that._updateViewSectionsVisibility(); that._setScrollButtonsNavigationMode(); that._refreshCalendarMode(); that._setDisplayMode(); that._refreshTitle(); that._refreshFooter(); that._refreshImportantDates(); //Since lwDropDownList uses CSS vars for the width/Height of the drop down list, // recalculation of the size of the drop down is needed since the layout has been changed by populating the Calendar with data. if (that.$.monthElement) { that.$.monthElement._setDropDownSize(); } that._changeEventFired = 0; that.$.hiddenInput.value = that.selectedDates.toString(); if (that.shadowRoot) { that.appendChild(that.$.hiddenInput); } that.isInitialized = true; super.render(); } _updateViewSectionsVisibility() { const that = this; that.viewSections.indexOf('title') > -1 ? that.$title.removeClass('lw-hidden') : that.$title.addClass('lw-hidden'); that.viewSections.indexOf('header') > -1 ? that.$header.removeClass('lw-hidden') : that.$header.addClass('lw-hidden'); that.viewSections.indexOf('footer') > -1 ? that.$footer.removeClass('lw-hidden') : that.$footer.addClass('lw-hidden'); } /** * Clears the currently selected dates. Public method */ clearSelection() { this._clearSelection(); } /** * Sets tab index */ _setFocusable() { const that = this; let index = that.tabIndex > 0 ? that.tabIndex : 0; //HeaderComponents function setHeaderElement(component, componentType) { if (!componentType) { return; } if (component && component instanceof componentType) { if (typeof (component._setFocusable) === 'function' && component.isCompleted) { //If a LW element is added to the element and its not ready component.unfocusable = index <= -1; } else { component.setAttribute('tabindex', index); } return component; } } if (that.disabled || that.unfocusable) { index = -1; } that.$.previousMonthButton = setHeaderElement(that.$.previousMonthButton, LW.Button); that.$.nextMonthButton = setHeaderElement(that.$.nextMonthButton, LW.Button); that.$.nextYearButton = setHeaderElement(that.$.nextYearButton, LW.Button); that.$.previousYearButton = setHeaderElement(that.$.previousYearButton, LW.Button); that.$.monthElement = setHeaderElement(that.$.monthElement, LW.DropDownList); that.$.yearElement = setHeaderElement(that.$.yearElement, HTMLInputElement); if (that.viewSections.indexOf('title') > -1) { that.$.dateContainer.setAttribute('tabindex', index); that.$.yearContainer.setAttribute('tabindex', index); } that.$.body.setAttribute('tabindex', index); that.calendarMode === 'default' ? that.$.dateElement.setAttribute('tabindex', index) : that.$.dateElement.removeAttribute('tabindex'); if (that.unfocusable) { that.removeAttribute('tabindex'); } else { that.tabIndex = that.readonly && !that.disabled ? (that.tabIndex > 0 ? that.tabIndex : 0) : index; } } /** * Checks for missing modules. */ static get requires() { return { 'LW.DropDownList': 'lw.dropdownlist.js', 'LW.ListBox': 'lw.listbox.js', 'LW.RepeatButton': 'lw.button.js', 'LW.Tooltip': 'lw.tooltip.js' } } /** * Navigates to a month forwards or backwards. * @param {number} step The step that will determine which month to navigate to. Negative step means future month. Positive step means past month. * @param {string|Date} step The step can also be a Date Object or a string representing a valid date */ navigate(step) { const that = this; let navigationDate, nextDateToUpdateTo, noAnimation; if (!step) { return; } if (typeof step === 'number') { step = parseInt(step); if (isNaN(step) || step === 0) { return false; } if (that.weeks !== 6 && that.weeks !== 0 && that.displayMode === 'month') { if (!that._focusedCell) { that._focusCell(); } let lastVisibleDate, calendarDates; const visibleWeeks = [].slice.call(that._focusedCell.closest('.lw-calendar-weeks').children).filter(week => !week.classList.contains('lw-hidden')); if (step < 0) { calendarDates = visibleWeeks[0].querySelectorAll('.lw-calendar-cell'); lastVisibleDate = that.rightToLeft ? calendarDates[calendarDates.length - 1] : calendarDates[0]; } else { calendarDates = visibleWeeks[visibleWeeks.length - 1].querySelectorAll('.lw-calendar-cell'); lastVisibleDate = that.rightToLeft ? calendarDates[0] : calendarDates[calendarDates.length - 1]; } nextDateToUpdateTo = new Date(lastVisibleDate.value); nextDateToUpdateTo.setDate(nextDateToUpdateTo.getDate() + step); navigationDate = nextDateToUpdateTo; } else { navigationDate = that._getNextDate(step); } } else { navigationDate = step = that._getValidDate(step); noAnimation = true; if (isNaN(navigationDate.getTime())) { return false; } const firstVisibleDate = that._viewDates[0]; if (firstVisibleDate && navigationDate.getMonth() === firstVisibleDate.getMonth() && navigationDate.getFullYear() === firstVisibleDate.getFullYear()) { return false; } if (that.weeks !== 6 && that.weeks !== 0 && that.displayMode === 'month') { nextDateToUpdateTo = navigationDate; } } if (!navigationDate) { return false; } if (that.$.fireEvent('navigationChanging', { value: new Date(navigationDate), type: that.displayMode }).defaultPrevented) { return false; } if (that.displayMode !== 'month') { if (!noAnimation && that.hasAnimation) { that.$nextMonthsContainer.addClass('lw-calendar-date-view-container'); if (that.displayModeView === 'list') { that._setDisplayModeContent(navigationDate); } else { if (!that._navigationDate || that._navigationDate.getTime() !== navigationDate.getTime()) { that._animateNavigation(navigationDate, step); } } } else { that._setDisplayModeContent(navigationDate); } that.$.fireEvent('navigationChange', { value: new Date(navigationDate), type: that.displayMode }); return true; } if (that.hasAnimation) { that._animateNavigation(navigationDate, step); if (that.$nextMonthsContainer.hasClass('lw-date-view-container')) { that.$nextMonthsContainer.removeClass('lw-date-view-container'); } } else { that._handleMonths(navigationDate); //Update Header elements that._refreshHeaderElements(); that._refreshHeaderTitle(); } if (nextDateToUpdateTo) { that._focusCell(that._getCellByDate(nextDateToUpdateTo, that._animationStarted ? that.$.nextMonthsContainer : undefined), true); that._updateWeeksVisibility(step); } that.$.fireEvent('navigationChange', { value: new Date(navigationDate), type: that.displayMode }); return true; } /** * Selects a single date. * @param {any} date - Date object or a string representing a date. */ select(date) { const that = this; if (typeof (that._viewDates[0]) === 'undefined' || that.selectionMode === 'none' || !date) { return; } date = that._getValidDate(date); if (!(date instanceof Date)) { return; } if (that.selectionMode === 'one' && that.selectedDates.map(Number).indexOf(date.getTime()) > -1) { return; } if (date.getTime() < that.min.getTime() || date.getTime() > that.max.getTime()) { return; } if (that.selectionMode === 'one' || that.selectionMode === 'default' || that.selectionMode === 'zeroOrOne') { that._clearSelection(true); } that._selectDate(date); if (that.selectedDates.length === 1 && !that._isDateInView(that.selectedDates[0])) { that._handleMonths(that.selectedDates[0]); } } /** * Selects the current date(today) */ today() { const that = this; let today = new Date(); today.setHours(0, 0, 0, 0); if (today.getTime() < that.min.getTime() || today.getTime() > that.max.getTime()) { today = new Date(that.max); } else { that._selectDate(today); } that._handleMonths(today); return today; } /** * Animates the navigation between months */ _animateNavigation(navigationDate, step, completeAnimation) { const that = this; that._navigationDate = navigationDate; function scroll() { let endCondition = step > 0 ? that.$.body[that._animationSettings.scrollSize] >= scrollMax : that.$.body[that._animationSettings.scrollSize] === 0, coefficient = that._scrollStep / 2; //oldvalue = 20, used to slow down the animation after half of it has passed if (endCondition) { that._animateNavigationCompleted(); return; } if (step > 0 && that.$.body[that._animationSettings.scrollSize] > scrollMax * that._animationSettings.easeThreshold) { coefficient = Math.max(that.$.body[that._animationSettings.scrollSize] / that._animationSettings.stepEaseSize, Math.abs(coefficient - (scrollMax - that.$.body[that._animationSettings.scrollSize]) * that._animationSettings.step)); that._scrollStep = that._scrollStep * that._animationSettings.step + coefficient; } else if (step < 0 && that.$.body[that._animationSettings.scrollSize] < scrollMax * that._animationSettings.easeThreshold) { coefficient = Math.max(that.$.body[that._animationSettings.scrollMax] / that._animationSettings.stepEaseSize, Math.abs(coefficient - that.$.body[that._animationSettings.scrollSize] * that._animationSettings.step)); that._scrollStep = that._scrollStep * that._animationSettings.step + coefficient; } that.$.body[that._animationSettings.scrollSize] += step > 0 ? that._scrollStep : -that._scrollStep; that._animationId = requestAnimationFrame(scroll); } if (!that._animationSettings) { that._applyAnimationSettings(); } //If the other animation was running, reset the elements that.$animationPanel.addClass('lw-hidden'); that.$.dateViewContainer.style.transform = ''; that.$.dateViewContainer.style.opacity = ''; that.$.monthsContainer.style.transform = ''; that.$.monthsContainer.style.opacity = ''; const animationTarget = that.displayMode !== 'month' ? that.$.dateViewContainer : that.$.monthsContainer, scrollMax = that.$.body[that._animationSettings.scrollMax] - that.$.body[that._animationSettings.size]; //that.$.monthsSeparator[that._animationSettings.size]; that._scrollStep = that.$.body[that._animationSettings.size] * that._animationSettings.startSpeed; //Start speed //reset the days of the month if (that._animationStarted) { const monthCells = that._getMonthCells(that.$.monthsContainer, that.rightToLeft) //reset all item properties monthCells.map(cell => { that._setCellState(cell, 'restricted', false); that._setCellState(cell, 'selected', false); that._setCellState(cell, 'otherMonth', false); that._setCellState(cell, 'focus', false); that._setCellState(cell, 'important', false); that._setCellState(cell, 'today', false); that._setCellState(cell, 'disabled', false); that._setCellState(cell, 'hover', false); }); } that._animationStarted = true; if (that.displayMode !== 'month') { that._setCellState(that._focusedCell, 'focus', false); that._setDisplayModeContent(navigationDate, that.$.nextMonthsContainer); } else { that._handleMonths(navigationDate, that.$.nextMonthsContainer); } if (that.rightToLeft) { step *= -1; } if (!completeAnimation) { if (step > 0) { animationTarget.style.order = 1; that.$.nextMonthsContainer.style.order = 3; if (!that._animationStarted || (that._animationStarted && that.$.body[that._animationSettings.scrollSize] > that.$.body[that._animationSettings.scrollMax] * that._animationSettings.resetThreshold * 2)) { that.$.body[that._animationSettings.scrollSize] = 0; } } else { animationTarget.style.order = 3; that.$.nextMonthsContainer.style.order = 1; if (!that._animationStarted || (that._animationStarted && that.$.body[that._animationSettings.scrollSize] < that.$.body[that._animationSettings.scrollMax] * that._animationSettings.resetThreshold)) { that.$.body[that._animationSettings.scrollSize] = that.$.body[that._animationSettings.scrollMax]; } } } cancelAnimationFrame(that._animationId); that._animationId = requestAnimationFrame(scroll); } /** * Cancels an undergoing animation and resets everything to normal */ _animateNavigationCompleted() { const that = this; let animationTarget = that.displayMode !== 'month' ? that.$.dateViewContainer : that.$.monthsContainer, focusedDate, newCells, oldCells; cancelAnimationFrame(that._animationId); if (that.displayMode !== 'month') { let focusedItemIndex = [].slice.call(animationTarget.children).indexOf(that._focusedCell); animationTarget.innerHTML = that.$.nextMonthsContainer.innerHTML; let focusedItem = animationTarget.children[focusedItemIndex], lastFocusableItem; newCells = animationTarget.children; oldCells = that.$.nextMonthsContainer.children; for (let i = 0; i < newCells.length; i++) { newCells[i].value = oldCells[i].value; newCells[i].restricted = oldCells[i].restricted; newCells[i].important = oldCells[i].important; newCells[i].otherMonth = oldCells[i].otherMonth; if (newCells[i].value.getTime() <= that.max.getTime()) { lastFocusableItem = newCells[i]; } } if (focusedItem && focusedItem.value.getTime() >= that.max.getTime()) { focusedDate = lastFocusableItem.value; } else { focusedDate = that._focusedCell ? that._focusedCell.value : undefined; } } else { let newMonths = animationTarget.children, months = that.$.nextMonthsContainer.children; //if (that._focusedCell && that.$.nextMonthsContainer.contains(that._focusedCell)) { // focusedDate = that._focusedCell.value; //} for (let i = 0; i < newMonths.length; i++) { if (!months[i]._date) { break; } newMonths[i]._date = months[i]._date; newMonths[i].innerHTML = months[i].innerHTML; newCells = that._getMonthCells(newMonths[i]); oldCells = that._getMonthCells(months[i]); for (let i = 0; i < newCells.length; i++) { newCells[i].value = oldCells[i].value; newCells[i].restricted = oldCells[i].restricted; newCells[i].important = oldCells[i].important; newCells[i].otherMonth = oldCells[i].otherMonth; newCells[i].removeAttribute('focus'); } } //Synch _selectedCells if (that._selectedCells.length > 0) { that._selectedCells = that._selectedCells.map(date => date = that._getCellByDate(date.value)).filter(date => { return typeof date !== 'undefined'; }); } } that._focusCell(that._getCellByDate(focusedDate)); animationTarget.style.order = 1; that.$.nextMonthsContainer.style.order = 3; that.$.body[that._animationSettings.scrollSize] = 0; that._animationStarted = false; delete that._navigationDate; } /** * Prepares the settings used for the animation * @param {any} displayModeChangeOnly - flag indicating if the change is only in the displayModeView */ _applyAnimationSettings(displayModeChangeOnly) { const that = this; that._animationSettings = that.animationSettings ? that.animationSettings : (that._animationSettings || {}); //Settings for the scrolling direction if (that.scrollButtonsNavigationMode === 'portrait') { that._animationSettings.scrollMax = 'scrollHeight'; that._animationSettings.size = 'offsetHeight'; that._animationSettings.scrollSize = 'scrollTop'; } else { that._animationSettings.scrollMax = 'scrollWidth'; that._animationSettings.size = 'offsetWidth'; that._animationSettings.scrollSize = 'scrollLeft'; } if (displayModeChangeOnly) { return; } //Starting speed that._animationSettings.startSpeed = that._animationSettings.startSpeed ? that._animationSettings.startSpeed : 0.2; //The threshold where the easing effect begins that._animationSettings.easeThreshold = that._animationSettings.easeThreshold ? that._animationSettings.easeThreshold : 0.5; //Animation step - determines the scroll interval between animation frames in perecentages that._animationSettings.step = that._animationSettings.step ? that._animationSettings.step : 0.25; //Animation step ease size - additional ease step coefficient that kicks in when the threshold is passed that._animationSettings.stepEaseSize = that._animationSettings.stepEaseSize ? that._animationSettings.stepEaseSize : 200; //Threshold used to determine if the animation should start over or continue from it's current state that._animationSettings.resetThreshold = that._animationSettings.resetThreshold ? that._animationSettings.resetThreshold : 0.2; } /** * Apply selectionMode to reflect on the current selection. */ _applySelectionMode(initial, oldSelectionMode) { const that = this; let newDate = [], preventEvent = initial ? true : false, selectionMode = that.selectionMode; function updateAllCells(property, value) { const months = that.$.monthsContainer.children; for (let m = 0; m < months.length; m++) { that._getMonthCells(months[m]).map(cell => { that._setCellState(cell, property, value); }); } } if (selectionMode !== 'many' || selectionMode !== 'range') { updateAllCells('hover', false); } that._newRangeSelectionStarted = that.selectedDates.length > 0 && selectionMode === 'range'; if (['default', 'many', 'zeroOrMany', 'oneOrMany', 'week', 'range'].indexOf(selectionMode) !== -1) { Array.from(that.getElementsByClassName('lw-calendar-month')).forEach(month => month.setAttribute('aria-multiselectable', true)); } else { Array.from(that.getElementsByClassName('lw-calendar-month')).forEach(month => month.removeAttribute('aria-multiselectable')); } if (selectionMode === 'none' || oldSelectionMode === 'none') { updateAllCells('selected', false); } switch (selectionMode) { case 'none': that._clearSelection(preventEvent); return; case 'range': if (that.selectedDates.length > 1) { that._selectMultipleDates(that.selectedDates[0], that.selectedDates[that.selectedDates.length - 1]); } return; case 'many': case 'default': case 'oneOrMany': if (that.selectedDates.length === 0) { newDate.push(new Date(Math.min(Math.max(that.min.getTime(), new Date().setHours(0, 0, 0, 0)), that.max.getTime()))); break; } return; case 'one': if (that.selectedDates.length === 1) { return; } if (that.selectedDates.length > 1) { newDate.push(that.selectedDates[that.selectedDates.length - 1]); that._clearSelection(preventEvent); } else { newDate.push(new Date(Math.min(Math.max(that.min.getTime(), new Date().setHours(0, 0, 0, 0)), that.max.getTime()))); } break; case 'zeroOrOne': if (that.selectedDates.length > 1) { newDate.push(that.selectedDates[that.selectedDates.length - 1]); that._clearSelection(preventEvent); break; } return; case 'zeroOrMany': return; case 'week': if (that.selectedDates.length >= 1) { let date = that.selectedDates[that.selectedDates.length - 1]; for (let i = 0; i < 7; i++) { newDate.push(new Date(date)); date.setDate(date.getDate() + 1); } that._clearSelection(preventEvent); } break; } that.selectedDates = []; if (initial) { that.selectedDates = newDate; return; } const newDates = newDate.length; for (let d = 0; d < newDates; d++) { that._selectDate(newDate[d], d < newDates - 1); } } /** * Clears the currently selected dates. */ _clearSelection(eventPrevented) { const that = this, selectedDates = that.selectedDates.slice(0), selectionMode = that.selectionMode; if (!that.isRendered) { that.set('selectedDates', []); return; } if (that._selectedCells) { that._selectedCells.map(cell => { that._setCellState(cell, 'selected', false); }); } that.selectedDates = []; that._selectedCells = []; if (selectionMode === 'many' || selectionMode === 'range') { const months = that.$.monthsContainer.children; for (let m = 0; m < months.length; m++) { that._getMonthCells(months[m]).map(cell => { that._setCellState(cell, 'hover', false); }); } } if (that.$.footer) { that._refreshFooter(); } //Update the hidden input that.$.hiddenInput.value = that.selectedDates.toString(); if (!eventPrevented && that.isInitialized && selectedDates.length) { that.$.fireEvent('change', { 'value': [] }); } if (that.$.title) { that._refreshTitle(); } } _bodyBlurStateHandler(event) { const that = this; that._bodyStateHandler(event); // delete that._newRangeSelectionStarted; that.$.fireEvent('blur'); } _bodyFocusStateHandler(event) { const that = this; that._bodyStateHandler(event); that.$.fireEvent('focus'); } /** * body focus event handler. */ _bodyStateHandler(event) { const that = this; if (that._focusedCell) { if (event.type === 'blur' || (event.type === 'focus' && that._noFocusingRequired)) { that._noFocusingRequired = false; that._setCellState(that._focusedCell, 'focus', false); return; } if (that.displayMode !== 'month') { if (event.type === 'focus' && !that.$.dateViewContainer.querySelector('lw-calendar-cell[focus]')) { that._setCellState(that._focusedCell || that.$.dateViewContainer.querySelector('.lw-calendar-cell'), 'focus', true); } return; } } if (event.type === 'focus') { that._focusCell(); } } /** * Container mouse wheel event handler. */ _containerWheelHandler(event) { const that = this; if (that.disabled || that.readonly || (that.displayMode !== 'month' && that.displayModeView === 'list')) { return; } let step, activeElement; activeElement = document.activeElement; if (that.shadowRoot) { activeElement = that.shadowRoot.activeElement; } else if (that.isInShadowDOM) { activeElement = that.getRootNode().activeElement; } // Header component if (that.$.yearElement === activeElement) { step = 12; } if ((activeElement && that.shadowRoot) || activeElement.closest('lw-calendar') === that) { step = event.target === that.$.yearElement ? 12 : 1; } if (!step) { return; } //Prevent window scrolling event.preventDefault(); step = step === 12 ? step : step * that.months; event.deltaY > 0 ? that.navigate(-step) : that.navigate(step); } /** * Calendar down event handler. */ _downHandler(event) { const that = this; let target = event.originalEvent.target; that._dragStartDetails = undefined; if (that.disabled || that.readonly) { return; } if (that.hasRippleAnimation) { if (target.value instanceof Date || (target.parentElement && target.parentElement.classList.contains('lw-calendar-title')) || target.parentElement === that.$.dateElement) { LW.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY); } } target = event.originalEvent.target.closest('.lw-calendar-header'); if (event.originalEvent.target.closest('.lw-calendar-year-container') && that.displayMode !== 'decade') { if (that.calendarMode === 'classic') { return; } that._showDateView('year'); return; } if (event.originalEvent.target.closest('.lw-calendar-date-container') && that.displayMode !== 'month') { if (that.calendarMode === 'classic') { return; } that._displayModeHandler(that.displayModeView === 'list' ? that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]) : that._focusedCell, 'month'); return; } if (that._animationStarted) { that._animateNavigationCompleted(); } if (LW.Utilities.Core.isMobile && event.originalEvent.target.closest('.lw-calendar-body') === that.$.body) { that._dragStartDetails = { x: event.pageX, y: event.pageY, startTime: Date.now(), target: event.originalEvent.target }; return; } target = event.originalEvent.target; if (target.closest('.lw-calendar-week') || target.parentElement === that.$.dateViewContainer) { while (target && !(target.value instanceof Date)) { target = target.parentElement; } if (target) { that.displayMode !== 'month' ? that._displayModeHandler(target) : that._weeksDownHandler(event, target); } return; } if (target.closest('.lw-calendar-month-element')) { return; } event.originalEvent.stopPropagation(); if (that.displayModeView === 'list' && that.displayMode !== 'month') { target = (that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target).closest('lw-list-item'); if (target) { that._displayModeHandler(target); } return; } //Prevent window scrolling const scrollElement = document.scrollingElement || document.documentElement, x = scrollElement.scrollLeft, y = scrollElement.scrollTop; if (!that.unfocusable) { that.focus(); } //Prevent window scrolling window.scrollTo(x, y); } /** * Handles the dateViewSelection panels on caledarItem click * @param {any} target */ _displayModeHandler(target, newDisplayMode) { const that = this; if (that._animationStarted) { that._animateNavigationCompleted(); } if (target instanceof HTMLElement && target.parentElement.classList.contains('lw-calendar-week') && target.otherMonth) { if (that.displayMode === 'decade' && (target.value.getFullYear() < that.min.getFullYear() || target.value.getFullYear() > that.max.getFullYear())) { return; } else if (that.displayMode === 'year' && (((target.value.getFullYear() < that.min.getFullYear()) || (target.value.getFullYear() === that.min.getFullYear() && target.value.getMonth() < that.min.getMonth())) || ((target.value.getFullYear() > that.max.getFullYear()) || (target.value.getFullYear() === that.max.getFullYear() && target.value.getMonth() > that.max.getMonth())))) { return; } } newDisplayMode = newDisplayMode ? newDisplayMode : that.displayMode; switch (newDisplayMode) { case 'year': newDisplayMode = 'month'; break; case 'decade': newDisplayMode = 'year'; break; } if (that.displayMode === newDisplayMode) { return; } const isDisplayModeCHangeEventPrevented = that.$.fireEvent('displayModeChanging', { 'oldDisplayMode': that.displayMode, 'newDisplayMode': newDisplayMode }).defaultPrevented; if (isDisplayModeCHangeEventPrevented) { return; } that.displayMode = newDisplayMode; that.$nextMonthsContainer.removeClass('lw-calendar-date-view-container'); if (target.parentElement === that.$.dateViewContainer && !target.disabled && !target.restricted) { that._focusCell(target); } if (that.hasAnimation) { if (target instanceof LW.ListItem || target.ownerListBox === that.$.listViewContainer) { if (target.offsetHeight) { that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : target.offsetTop + target.offsetHeight / 2) + 'px'; } else { that.$.animationPanel.style.transformOrigin = (that.$.listViewContainer.offsetLeft + that.$.listViewContainer.offsetWidth / 2) + 'px ' + (that.$.listViewContainer.offsetTop + that.$.listViewContainer.offsetHeight / 2) + 'px'; } } else { that.$.dateViewContainer.style.order = 1; that.$.nextMonthsContainer.style.order = 3; target = that._focusedCell; //there should always be a focused item that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.offsetTop + target.offsetHeight / 2) + 'px'; } that._animateView(1, target); } else { that._setDisplayModeContent(target.value instanceof Date ? target.value : new Date(target.value)); } } /** * Animate the dateViewContainer * @param {any} direction * @param {any} target */ _animateView(direction, target) { const that = this; let date = target instanceof Date ? target : new Date(target.value), endCondition = false, scale = 1, opacity = 1, animationTarget, backgroundContainer; if (that.displayModeView === 'list') { animationTarget = target instanceof LW.ListItem || target.ownerListBox === that.$.listViewContainer ? that.$.listViewContainer : that.displayMode !== 'month' ? that.$.monthsContainer : that.$.listViewContainer; backgroundContainer = that.displayMode === 'month' ? that.$.monthsContainer : that.$.listViewContainer; } //else if (!(target instanceof LW.cell)) { else if (!(target.value instanceof Date)) { target = that._focusedCell ? that._focusedCell : that._selectedCells.length > 0 ? that._selectedCells[that._selectedCells.length - 1] : that._getCellByDate(new Date()); } if (!animationTarget) { animationTarget = target.parentElement === that.$.dateViewContainer ? that.$.dateViewContainer : that.$.monthsContainer; } if (!backgroundContainer) { backgroundContainer = that.displayMode === 'month' ? that.$.monthsContainer : that.$.dateViewContainer; } backgroundContainer.style.transformOrigin = that.$.animationPanel.style.transformOrigin; if (animationTarget instanceof LW.ListBox) { that.$.animationPanel.innerHTML = ''; that.$.animationPanel.appendChild(animationTarget.cloneNode(false)); while (animationTarget.$.itemsInnerContainer.firstElementChild) { that.$.animationPanel.children[0].appendChild(animationTarget.$.itemsInnerContainer.firstElementChild); } } else { that.$.animationPanel.innerHTML = animationTarget.innerHTML; } that._setDisplayModeContent(date); animationTarget.style.order = 1; that.$.nextMonthsContainer.style.order = 3; that.$.body[that._animationSettings.scrollSize] = 0; that.$.animationPanel.style.width = that.$.body.offsetWidth + 'px'; that.$.animationPanel.style.height = that.$.body.offsetHeight + 'px'; that.$.animationPanel.style.transform = 'scale(1)'; that.$.animationPanel.style.opacity = 1; that.$animationPanel.removeClass('lw-hidden'); backgroundContainer.style.opacity = '0'; backgroundContainer.style.transform = 'scale(3.5)'; //Use the style of the dateViewContainer if (animationTarget.$.hasClass('lw-calendar-date-view-container')) { that.$animationPanel.addClass('lw-calendar-date-view-container'); } else { that.$animationPanel.removeClass('lw-calendar-date-view-container'); } // Refresh the scrollBars and ensure item is visible after the new view has been loaded if (animationTarget instanceof LW.ListBox) { const listBox = that.$.animationPanel.children[0]; listBox.whenReady(function () { listBox._refreshLayout(); listBox.ensureVisible(listBox.selectedValues[0]); }); } function animate() { if ((direction > 0 && scale >= 3.5) || (direction < 0 && scale <= 0)) { endCondition = true; } if (endCondition) { cancelAnimationFrame(that._animationId); that.$animationPanel.addClass('lw-hidden'); that.$.animationPanel.style.transform = ''; that.$.animationPanel.style.opacity = ''; animationTarget.style.order = 1; that.$.nextMonthsContainer.style.order = 3; that.$.body[that._animationSettings.scrollSize] = 0; backgroundContainer.style.transform = ''; backgroundContainer.style.opacity = ''; //that._animationStarted = false; if (that.unfocusable) { return; } if (that.displayMode === 'month') { that.$.body.focus(); } else if (that.displayModeView === 'list') { that.focus(); } return; } that.$.animationPanel.style.opacity = opacity; backgroundContainer.style.opacity = 1 - opacity; opacity -= 0.05; if (direction > 0) { that.$.animationPanel.style.transform = 'scale(' + scale + ')'; backgroundContainer.style.transform = 'scale(' + Math.min((scale - 1) / 2, 1) + ')'; scale += 0.125; } else { that.$.animationPanel.style.transform = 'scale(' + Math.max(scale, 0) + ')'; backgroundContainer.style.transform = 'scale(' + Math.max(1 + scale, 1) + ')'; scale -= 0.06; } that._animationId = requestAnimationFrame(animate); } cancelAnimationFrame(that._animationId); that._animationId = requestAnimationFrame(animate); //that._animationStarted = true; } /** * Document up handler * @param {any} event */ _documentUpHandler(event) { const that = this; let target = event.originalEvent.target; if (that.isInShadowDOM || that.shadowRoot && target === that) { target = event.originalEvent.composedPath()[0] } //Resets the Range selecton hover style if (that._newRangeSelectionStarted && !that.$.container.contains(target)) { delete that._newRangeSelectionStarted; } if (!LW.Utilities.Core.isMobile || !that._dragStartDetails || event.originalEvent.target.closest('.lw-calendar-list-view')) { return; } delete that._previousIteration; const timeNow = Date.now(); let dragging = {}; if (that.isInShadowDOM || that.shadowRoot && target === that) { target = event.originalEvent.composedPath()[0] } if (that.scrollButtonsNavigationMode === 'portrait') { dragging.coordinate = 'y'; dragging.direction = 'pageY'; } else { dragging.coordinate = 'x'; dragging.direction = 'pageX'; } const step = that._dragStartDetails.step * (that.rightToLeft ? -1 : 1); if (Math.abs(that._dragStartDetails[dragging.coordinate] - event[dragging.direction]) <= 10) { target = that.displayModeView === 'list' && that.displayMode !== 'month' ? target.closest('lw-list-item') : target; if (!target) { that._dragStartDetails = undefined; return; } if (that.displayMode !== 'month') { that._displayModeHandler(target); //Reset scrolling if any occured that.scrollButtonsNavigationMode === 'portrait' ? that.$.body.scrollTop = 0 : that.$.body.scrollLeft = 0; that._dragStartDetails = undefined; return; } that._weeksDownHandler(event, target); if (!that.disableAutoNavigation && target.otherMonth) { return; } } else { const speed = Math.abs((event[dragging.direction] - that._dragStartDetails[dragging.coordinate]) / (timeNow - that._dragStartDetails.startTime)); if (speed > 1) { const steps = parseInt(speed); //Determine the animation iterations for (let i = 0; i < steps; i++) { if (!that.navigate(step)) { that._cancelAnimation(); break; } } that._dragStartDetails = undefined; return; } } if (!that.hasAnimation) { that.navigate(that._dragStartDetails.step); that._dragStartDetails = undefined; return; } let scrollMax = (that.displayMode !== 'month' ? that.$.dateViewContainer[that._animationSettings.scrollMax] : that.$.monthsContainer[that._animationSettings.scrollMax]) + that.$.monthsSeparator[that._animationSettings.size]; if ((that._dragStartDetails.step > 0 && that.$.body[that._animationSettings.scrollSize] > scrollMax * that._animationSettings.easeThreshold) || (that._dragStartDetails.step < 0 && that.$.body[that._animationSettings.scrollSize] < scrollMax * that._animationSettings.easeThreshold)) { that._animateNavigation(that._dragStartDetails.navigationDate, step, true); if (that.weeks !== 6 && that.weeks !== 0 && that.displayMode === 'month') { that._updateWeeksVisibility(step, that._getCellByDate(that._dragStartDetails.navigationDate, that.$.nextMonthsContainer)); } that.$.fireEvent('navigationChange', { value: new Date(that._dragStartDetails.navigationDate), type: that.displayMode }); that._dragStartDetails = undefined; return; } //Resets the touch scrolling to normal that._cancelAnimation(); that._dragStartDetails = undefined; } /** * Returns the month to its starting/ending position on touchUp. * @param {any} navigationDate - Date to navigate to * @param {any} step - animation step */ _cancelAnimation() { const that = this, animationTarget = that.displayMode !== 'month' ? that.$.dateViewContainer : that.$.monthsContainer; let scale = that.$.animationPanel.style.transform, opacity = that.$.animationPanel.style.opacity; if (scale) { scale = parseFloat(scale.substring(scale.indexOf('(') + 1 || 0, scale.indexOf(')'))); } animationTarget.style.order = 1; that.$.nextMonthsContainer.style.order = 3; that.$.body[that._animationSettings.scrollSize] = 0; function animate() { if (!scale || scale >= 3.5) { cancelAnimationFrame(that._animationId); that.$animationPanel.addClass('lw-hidden'); that.$.animationPanel.style.transform = ''; that.$.animationPanel.style.opacity = ''; const backgroundContainer = that.displayMode === 'month' ? that.$.monthsContainer : that.$.listViewContainer; backgroundContainer.style.transform = ''; backgroundContainer.style.opacity = ''; if (!that.unfocusable) { if (that.displayMode === 'month') { that.$.body.focus(); } else if (that.displayModeView === 'list') { that.focus(); } } that._animationStarted = false; return; } that.$.animationPanel.style.opacity = (opacity -= 0.25); that.$.animationPanel.style.transform = 'scale(' + (scale += 0.5) + ')'; that._animationId = requestAnimationFrame(animate); } that._animationId = requestAnimationFrame(animate); } /** * Focuses a Calendar day. */ _focusCell(cell, noFocusSet) { const that = this; if (that._focusedCell) { that._setCellState(that._focusedCell, 'focus', false); } if (that.disabled || that.readonly) { return; } if (cell) { if (that.displayMode !== 'month') { that._setCellState(cell, 'focus', true); that._focusedCell = cell; return; } if (cell.disabled || cell.restricted) { return; } if (!noFocusSet) { that._setCellState(cell, 'focus', true); } that._focusedCell = cell; return; } if (that.displayMode !== 'month' && that.$.monthsContainer.offsetHeight === 0) { return; } const lastSelectedCell = that._selectedCells[that._selectedCells.length - 1]; if (lastSelectedCell && lastSelectedCell.offsetHeight) { that._setCellState(lastSelectedCell, 'focus', true); that._focusedCell = lastSelectedCell; } else { const months = that.$.monthsContainer.children; if (!months[0]._date || that.min.getTime < months[0]._date.getTime()) { return; } const monthCells = that._getMonthCells(months[0], that.rightToLeft); for (let d = 0; d < monthCells.length; d++) { const cell = monthCells[d]; if (!cell.otherMonth) { if (cell.disabled || cell.restricted || !cell.offsetHeight) { continue; } that._focusedCell = cell; break; } } } if (that._focusedCell) { that._setCellState(that._focusedCell, 'focus', true); } } /** * Returns the selected days for a given month. */ _getDays(date, datePool) { const datesCount = datePool.length; let days = []; if (datesCount > 0) { for (let d = 0; d < datesCount; d++) { if (datePool[d].getFullYear() === date.getFullYear() && datePool[d].getMonth() === date.getMonth()) { days.push(datePool[d].getDate()); } } } return days; } /** * Get the Calendar Date instance based on day number. */ _getCellByDate(date, monthContainer) { const that = this; if (!(date instanceof Date)) { return; } if (!monthContainer) { monthContainer = that.$.monthsContainer; } if (that.displayMode !== 'month') { if (that.displayModeView === 'list') { return; } let items = arguments[1] ? that.$.nextMonthsContainer.children : that.$.dateViewContainer.children; for (let i = 0; i < items.length; i++) { if (that.displayMode === 'year') { if (items[i].value.getMonth() === date.getMonth()) { return items[i]; } continue; } else if (items[i].value.getFullYear() === date.getFullYear()) { return items[i]; } } return; } let ownerMonth, monthCells, months = monthContainer.children; for (let i = 0; i < months.length; i++) { if (date.getFullYear() === months[i]._date.getFullYear() && date.getMonth() === months[i]._date.getMonth()) { ownerMonth = months[i]; break; } } if (!ownerMonth) { return; } monthCells = that._getMonthCells(ownerMonth); for (let i = 0; i < monthCells.length; i++) { if (monthCells[i].otherMonth && !monthCells[i].hover) { continue; } if (monthCells[i].value.getMonth() === date.getMonth() && monthCells[i].value.getDate() === date.getDate()) { return monthCells[i]; } } } /** * Returns the HTML elements for the days in a month. */ _getMonthCells(month, rightToLeft) { const weeks = month.getElementsByClassName('lw-calendar-week'); let days = []; //Get days instances. if (rightToLeft) { for (let w = 0; w < weeks.length; w++) { let weekDays = weeks[w].children; for (let d = weekDays.length - 1; d > 0; d--) { if (weekDays[d].classList.contains('lw-calendar-cell')) { days.push(weekDays[d]); } } } } else { for (let w = 0; w < weeks.length; w++) { let weekDays = weeks[w].children; for (let d = 1; d < weekDays.length; d++) { if (weekDays[d].classList.contains('lw-calendar-cell')) { days.push(weekDays[d]); } } } } return days; } /** * Returns the number of the week. */ _getWeekNumber(date) { //date = new Date(date.getTime()); const that = this; let newYear = new Date(date.getFullYear(), 0, 1), dayNumber = Math.round((date.getTime() - newYear.getTime() - (date.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1, day = newYear.getDay() - that.firstDayOfWeek, //the day of week the year begins on weeknum; day = day >= 0 ? day : day + 7; //if the year starts before the middle of a week if (day < 4) { weeknum = Math.floor((dayNumber + day - 1) / 7) + 1; if (weeknum > 52) { newYear = new Date(date.getFullYear() + 1, 0, 1); day = newYear.getDay() - that.firstDayOfWeek; day = day >= 0 ? day : day + 7; //if the next year starts before the middle of the week, it is week #1 of that year weeknum = day < 4 ? 1 : 53; } } else { weeknum = Math.round((dayNumber + day - 1) / 7); } return weeknum; } /** * Handle the date selection according to the selectionMode. */ _handleDateSelection(cell) { const that = this; if (typeof (cell) === 'undefined' || cell.disabled || cell.restricted) { return; } switch (that.selectionMode) { case 'none': that._focusCell(cell); break; case 'one': case 'default': if (that._keysPressed['Control']) { if (that.selectedDates.length > 1 || (that.selectedDates.length === 1 && !cell.selected)) { that._selectDate(cell.value); return; } that._focusCell(cell); return; } if (that._keysPressed['Shift']) { that._selectMultipleDates(new Date(that.selectedDates[0]), cell); return; } that._clearSelection(true); that._selectDate(cell.value, that._selectedCells.indexOf(cell.value) > -1 ? true : false); break; case 'many': { if (that.selectedDates.length === 0) { that._selectDate(cell.value); return; } const lastSelectedDate = that.selectedDates[that.selectedDates.length - 1]; let firstSelectedDate = new Date(that.selectedDates[0]); if (cell.value.getTime() === firstSelectedDate.getTime() || cell.value.getTime() === lastSelectedDate.getTime()) { that._clearSelection(); that._focusCell(cell); return; } if (that.selectedDates.length > 0) { that._selectMultipleDates(firstSelectedDate, cell); } break; } case 'range': { if (that.selectedDates.length > 1 && (!that._keysPressed['Control'] && !that._newRangeSelectionStarted)) { that._clearSelection(true); } if (that.selectedDates.length === 0 || (that._keysPressed['Control'] && that.selectedDates.length > 1 && !that._newRangeSelectionStarted)) { if (cell.value && that.selectedDates.find(selectedDate => selectedDate.getTime() === cell.value.getTime())) { return; } that._newRangeSelectionStarted = true; that._selectDate(cell.value); return; } const lastSelectedDate = that.selectedDates[that.selectedDates.length - 1]; let firstSelectedDate = that._keysPressed['Control'] || that._newRangeSelectionStarted ? lastSelectedDate : new Date(that.selectedDates[0]); if (that.selectedDates.length > 0) { that._selectMultipleDates(firstSelectedDate, cell); } delete that._newRangeSelectionStarted; break; } case 'zeroOrMany': that._selectDate(cell.value); break; case 'oneOrMany': if (that.selectedDates.length === 1 && cell.selected) { that._focusCell(cell); return; } that._selectDate(cell.value); break; case 'zeroOrOne': if (that.selectedDates.length === 1 && cell.selected) { that._selectDate(cell.value); return; } that._clearSelection(true); that._selectDate(cell.value); break; case 'week': { if (cell.selected && (cell.value.getTime() === that.selectedDates[0].getTime() || cell.value.getTime() === that.selectedDates[that.selectedDates.length - 1].getTime())) { that._clearSelection(); that._focusCell(cell); return; } that._clearSelection(true); let date = new Date(cell.value); that._selectDate(date); for (let i = 1; i < 7; i++) { date.setDate(date.getDate() + 1); that._selectDate(date); } if (!that._isDateInView(date)) { that.navigate(1) } break; } } } /** * Set's the Template for Important days. */ _handleImportantDateTemplate() { const that = this; that._importantDatesTemplate = that._validateTemplate('importantDatesTemplate', that.importantDatesTemplate); if (!that._importantDatesTemplate || !that._importantDatesTemplate.content) { return; } let content = that._importantDatesTemplate.content; const childrenCount = content.childNodes.length, regex = /{{\w+}}/g; let bindingString; that._bindingDetails = []; for (let i = 0; i < childrenCount; i++) { bindingString = regex.exec(content.childNodes[i].innerHTML); if (bindingString) { that._bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] }); return; } } } /** * Set's the Template for the footer/header. */ _handleLayoutTemplate(selector, newTemplate) { const that = this, template = that._validateTemplate(selector.$.hasClass('lw-header') ? 'headerTemplate' : selector.$.hasClass('lw-calendar-footer') ? 'footerTemplate' : 'titleTemplate', newTemplate); if (!template || !template.content) { if (typeof newTemplate === 'function') { newTemplate(selector, {}); } return; } if (!that._layoutTemplates) { that._layoutTemplates = []; } let clone = document.importNode(template.content, true); selector.innerHTML = ''; const childrenCount = clone.childNodes.length, regex = /{{\w+}}/g; let bindingString, bindings = []; for (let i = 0; i < childrenCount; i++) { bindingString = regex.exec(clone.childNodes[i].innerHTML); if (bindingString) { bindings.push({ childNodeIndex: i, bindingString: bindingString[0] }); } } that._layoutTemplates = that._layoutTemplates.filter(template => template.selector !== selector); that._layoutTemplates.push({ selector: selector, template: template, bindings: bindings }); if (that.shadowRoot) { selector.innerHTML = '<slot></slot>' that.appendChild(clone); return; } selector.appendChild(clone); } /** * Handles the hover state of the Calendar items */ _handleCalendarCellHover(event, cell) { const that = this; if (that._animationStarted) { return; } if (that.displayMode === 'month') { if (event.type === 'mouseover' && (that.selectionMode === 'many' || (that.selectionMode === 'range' && that._newRangeSelectionStarted)) && that.selectedDates.length > 0) { const months = that.$.monthsContainer.children; for (let m = 0; m < months.length; m++) { that._getMonthCells(months[m]).map(cell => { that._setCellState(cell, 'hover', false); }); } let firstSelectedDate = new Date(that.selectionMode === 'range' ? that.selectedDates[that.selectedDates.length - 1] : that.selectedDates[0]), targetDate = new Date(cell.value), targetCell = cell; const nextCoeff = firstSelectedDate.getTime() > targetDate.getTime() ? -1 : 1, hoverCell = function () { targetCell = that._getCellByDate(firstSelectedDate); if (targetCell && !targetCell.selected && !targetCell.restricted) { that._setCellState(targetCell, 'hover', true); } }; if (firstSelectedDate.getTime() !== targetDate.getTime()) { firstSelectedDate.setDate(firstSelectedDate.getDate() + nextCoeff); while (firstSelectedDate.getTime() !== targetDate.getTime()) { hoverCell(); firstSelectedDate.setDate(firstSelectedDate.getDate() + nextCoeff); } hoverCell(); } } else { that._setCellState(cell, 'hover', false); } } if (event.type === 'mouseover' && !cell.otherMonth) { that._setCellState(cell, 'hover', true); } else { that._setCellState(cell, 'hover', false); } } /** * Handles the number of months to be drawn. */ _handleMonths(date, monthsContainer) { const that = this; let months; if (!date) { date = that._viewDates && that._viewDates.length > 0 ? that._viewDates[0] : new Date(); } date = new Date(Math.min(Math.max(that.min.getTime(), date.getTime()), that.max.getTime())); if (!monthsContainer) { monthsContainer = that.$.monthsContainer; } function initializeMonths(monthsContainer) { let nextMonth, count = monthsContainer.children.length, fragment = document.createDocumentFragment(); for (count; count < that.months; count++) { nextMonth = that.$.month.cloneNode(false); nextMonth.innerHTML = that.$.month.innerHTML; fragment.appendChild(nextMonth); } return fragment; } function populateMonths(monthsContainer) { let months = monthsContainer.children; for (let i = 0; i < months.length; i++) { that._setMonth(date, months[i]); date.setMonth(date.getMonth() + 1); } that._setWeeksVisibility(monthsContainer); //Update the Header elements that._refreshHeaderElements(); that._refreshHeaderTitle(); if (that.tooltip) { that.$.tooltip.close(); } if (that.$.body === document.activeElement) { that._focusCell(); } } that._selectedCells = []; if (that.hasAnimation) { months = that.$.nextMonthsContainer.children; if (months.length > 0 && months[0].value instanceof Date) { that.$.nextMonthsContainer.innerHTML = ''; } // FF v57/EDGE bug fix using that.$.monthsContainer.childElementCount. Scoping problem with FF and EDGE. while (that.$.nextMonthsContainer.childElementCount < that.months) { //if (months.length < that.months) { that.$.nextMonthsContainer.appendChild(initializeMonths(that.$.nextMonthsContainer)); } // FF v57/EDGE bug fix using that.$.monthsContainer.childElementCount. Scoping problem with FF and EDGE. while (that.$.nextMonthsContainer.childElementCount > that.months) { //while (months.length > that.months) { that.$.nextMonthsContainer.removeChild(months[that.$.nextMonthsContainer.childElementCount - 1]); } if (arguments[1] === that.$.nextMonthsContainer) { populateMonths(that.$.nextMonthsContainer); return; } } months = that.$.monthsContainer.children; if (months.length > that.months) { // FF v57/EDGE bug fix using that.$.monthsContainer.childElementCount. Scoping problem with FF and EDGE. while (that.$.monthsContainer.childElementCount > that.months) { that.$.monthsContainer.removeChild(months[that.$.monthsContainer.childElementCount - 1]); that._viewDates.pop(); } populateMonths(that.$.monthsContainer); return; } if (that.$.monthsContainer.children.length === that.months) { populateMonths(that.$.monthsContainer); return; } that._viewDates = []; that.$.monthsContainer.appendChild(initializeMonths(that.$.monthsContainer)); populateMonths(that.$.monthsContainer); } /** * Header change handler. */ _headerChangeHandler(event) { const that = this; event.stopPropagation(); if (that.disabled || that.readonly) { return; } if (event.target.ownerElement === that.$.monthElement && that._changeEventFired !== 0) { that._changeEventFired--; return; } const displayMode = that.displayMode; //Header elements if (event.target === that.$.yearElement) { that._viewDates[0].setFullYear(Math.min(Math.max(that.min.getFullYear(), isNaN(parseInt(that.$.yearElement.value)) ? 0 : parseInt(that.$.yearElement.value)), that.max.getFullYear())); that._handleMonths(that._viewDates[0]); } if (that.$.monthElement && (event.target === that.$.monthElement || event.target.ownerElement === that.$.monthElement)) { that._handleMonths(new Date(that.$.monthsContainer.children[0]._date.getFullYear(), that.$.monthElement.selectedIndexes[0], 1)); //Return to month view if (displayMode !== 'month') { that._setDisplayMode(that.displayMode, that.displayMode = 'month'); } } } /** * Header click handler. */ _headerClickHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } let target = event.target.closest('lw-repeat-button'); if (target && target.disabled) { return; } //Header elements switch (target) { case that.$.previousMonthButton: that._isInteractiveNavigation = true; that.navigate(-1 * that.months * (that.rightToLeft ? -1 : 1)); return; case that.$.nextMonthButton: that._isInteractiveNavigation = true; that.navigate(1 * that.months * (that.rightToLeft ? -1 : 1)); return; case that.$.previousYearButton: that.navigate(-12); return; case that.$.nextYearButton: that.navigate(12); return; } if (that.calendarMode === 'classic') { return; } if (event.target.closest('.lw-calendar-date-element')) { if (that._animationStarted) { that._animateNavigationCompleted(); } that._isInteractiveNavigation = true; that._showDateView(); } } /** * Selected multiple dates from start to end date * @param {any} firstSelectedDate - start date * @param {any} date - end date */ _selectMultipleDates(firstSelectedDate, date) { const that = this; if (date instanceof HTMLElement) { date = date.value; } if (!that._newRangeSelectionStarted) { that._clearSelection(true); } else { that._selectDate(firstSelectedDate, true); } if (that.selectionMode === 'range' && date.getTime() === firstSelectedDate.getTime()) { return; } firstSelectedDate = new Date(firstSelectedDate); if (firstSelectedDate.getTime() < date.getTime()) { while (firstSelectedDate.getTime() <= date.getTime()) { if (!that.selectedDates.find(selectedDate => selectedDate.getTime() === firstSelectedDate.getTime())) { that._selectDate(firstSelectedDate, true); } firstSelectedDate.setDate(firstSelectedDate.getDate() + 1); } } else if (firstSelectedDate.getTime() > date.getTime()) { while (firstSelectedDate.getTime() >= date.getTime()) { if (!that.selectedDates.find(selectedDate => selectedDate.getTime() === firstSelectedDate.getTime())) { that._selectDate(firstSelectedDate, true); } firstSelectedDate.setDate(firstSelectedDate.getDate() - 1); } } else { that._selectDate(date, true); } //Update the hidden input that.$.hiddenInput.value = that.selectedDates.toString(); that._refreshFooter(); if (that.isInitialized) { that.$.fireEvent('change', { 'value': that.selectedDates }); } that._refreshTitle(); } /** * Sets the displayMode */ _setDisplayMode(oldValue, newValue, animationTarget) { const that = this; that.$nextMonthsContainer.removeClass('lw-calendar-date-view-container'); if (arguments.length === 0 || !that.hasAnimation) { if (that.calendarMode === 'classic') { that.displayMode = 'month'; return; } if (that.displayMode !== 'month') { that.$monthsContainer.addClass('lw-hidden'); if (that.$dateViewContainer.hasClass('lw-hidden')) { that.$dateViewContainer.removeClass('lw-hidden'); } } if (!that.isCompleted && that.displayMode === 'month') { return; } that._setDisplayModeContent(); return; } if (that._animationStarted) { that.displayMode = oldValue; that._animateNavigationCompleted(); that.displayMode = newValue; } if ((oldValue === 'month' && newValue === 'year') || (oldValue === 'year' && newValue === 'decade')) { that.displayMode = oldValue; that._showDateView(animationTarget ? undefined : that.displayMode); } else if ((oldValue === 'month' && newValue === 'decade')) { that._showDateView(that.displayMode = 'year'); } else { let target; if (that.displayModeView === 'list') { // used because _focusedItem is not a LW.ListItem but a plain Object target = (that.$.listViewContainer.shadowRoot ? that.$.listViewContainer.shadowRoot : that.$.listViewContainer).querySelector('lw-list-item[selected]'); that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : target.offsetTop + target.offsetHeight / 2) + 'px'; } else { that.$.dateViewContainer.style.order = 1; that.$.nextMonthsContainer.style.order = 3; target = that._focusedCell; //there should always be a focused item that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.offsetTop + target.offsetHeight / 2) + 'px'; } that._animateView(1, target); } } /** * Set the content of the default dispalyMode date selection view * @param {any} newDate */ _setDisplayModeContent(newDate, nextDateViewContainer) { const that = this; let selectedDate = !newDate || newDate.toString() === 'Invalid Date' ? (that.selectedDates.length > 0 ? that.selectedDates[that.selectedDates.length - 1] : new Date()) : newDate; selectedDate.setTime((Math.min(Math.max(selectedDate.getTime(), that.min.getTime()), that.max.getTime()))); selectedDate.setHours(0, 0, 0, 0); const viewDetails = that._prepareView(selectedDate); if (!viewDetails) { return; } let dateViewContainer; if (nextDateViewContainer) { that.$.nextMonthsContainer.innerHTML = that.$.dateViewContainer.innerHTML; dateViewContainer = that.$.nextMonthsContainer; } else { dateViewContainer = that.$.dateViewContainer; } const cells = dateViewContainer.children; let selectedCell; for (let i = 0; i < cells.length; i++) { const cell = cells[i]; cell.innerHTML = viewDetails.viewContent[i]; cell.value = viewDetails.dates[i]; if (that.displayMode === 'year') { if (((cell.value.getFullYear() < that.min.getFullYear()) || (cell.value.getFullYear() === that.min.getFullYear() && cell.value.getMonth() < that.min.getMonth())) || ((cell.value.getFullYear() > that.max.getFullYear()) || (cell.value.getFullYear() === that.max.getFullYear() && cell.value.getMonth() > that.max.getMonth()))) { that._setCellState(cell, 'otherMonth', true); } else { that._setCellState(cell, 'otherMonth', false); } if (selectedDate.getFullYear() === cell.value.getFullYear() && selectedDate.getMonth() === cell.value.getMonth()) { selectedCell = cell; } } else if (that.displayMode === 'decade') { if ((i === 0 || i === cells.length - 1) || cell.value.getFullYear() < that.min.getFullYear() || cell.value.getFullYear() > that.max.getFullYear()) { that._setCellState(cell, 'otherMonth', true); } else { that._setCellState(cell, 'otherMonth', false); } if (selectedDate.getFullYear() === cell.value.getFullYear()) { selectedCell = cell; } } that._setCellState(cell, 'hover', false); that._setCellState(cell, 'focus', false); } if (selectedCell.otherMonth) { for (let i = 0; i < cells.length; i++) { if (!cells[i].otherMonth) { selectedCell = cells[i]; break; } } } if (that._mobileScrolling) { return; } if (that._focusedCell) { that._setCellState(that._focusedCell, 'focus', false); } that._focusedCell = selectedCell; that._focusCell(that._focusedCell); that._refreshHeaderTitle(); that._refreshHeaderElements(); that.$.fireEvent('displayModeChange'); if (that._isInteractiveNavigation) { that._isInteractiveNavigation = undefined; return; } that._setCellState(selectedCell, 'focus', true); //Need to be called after the new content is loaded completely setTimeout(function () { if (that.unfocusable) { return; } that.$.body.focus(); that._focusCell(that._focusedCell); }, 0); } /** * Prepare the data for table displayMode view * @param {any} selectedDate */ _prepareView(selectedDate) { const that = this; let viewContent = [], dates = [], startYear, offset; function getValidDate(year, month, day) { let date = new Date(year, month + 1, 0), daysInMonth = date.getDate(); day > daysInMonth ? date.setDate(daysInMonth) : date.setDate(day); return date; } if (that.displayMode === 'month') { if (that.$nextMonthsContainer.hasClass('lw-date-view-container')) { that.$nextMonthsContainer.removeClass('lw-date-view-container'); } that.$listViewContainer.addClass('lw-hidden'); if (that.$dateViewContainer.hasClass('lw-visibility-hidden')) { that.$dateViewContainer.removeClass('lw-visibility-hidden'); } if (!that._isDateInView(selectedDate)) { that._handleMonths(selectedDate); } if (that.$header.hasClass('lw-hidden')) { that.$header.removeClass('lw-hidden'); } if (that.$body.hasClass('lw-calendar-list-view')) { that.$body.removeClass('lw-calendar-list-view'); } that.$dateContainer.addClass('lw-calendar-selected'); that.$yearContainer.removeClass('lw-calendar-selected'); that.$dateViewContainer.addClass('lw-hidden'); that.$monthsContainer.removeClass('lw-hidden'); that._refreshHeaderTitle(); that.$.body.setAttribute('tabindex', that.tabIndex > 0 ? that.tabIndex : 0); that._refreshHeaderElements(); if (!that.unfocusable) { that.$.body.focus(); } that._focusCell(that._getCellByDate(selectedDate)); that.$.fireEvent('displayModeChange'); return; } if (that.displayModeView === 'list') { that._setDisplayModeListContent(selectedDate); that.$.fireEvent('displayModeChange'); return; } if (that.$header.hasClass('lw-hidden')) { that.$header.removeClass('lw-hidden'); } if (that.$dateViewContainer.hasClass('lw-visibility-hidden')) { that.$dateViewContainer.removeClass('lw-visibility-hidden'); } that.$listViewContainer.addClass('lw-hidden'); that.$.body.setAttribute('tabindex', that.tabIndex > 0 ? that.tabIndex : 0); if (that.displayMode === 'year') { let tempDate = new Date(); for (let i = 0; i < 12; i++) { tempDate = getValidDate(tempDate.getFullYear(), i, tempDate.getDate()); viewContent.push(tempDate.toLocaleDateString(that.locale, { month: 'short' })); dates.push(getValidDate(selectedDate.getFullYear(), i, selectedDate.getDate())); } } else { startYear = selectedDate ? selectedDate.getFullYear() : that._viewDates[0].getFullYear(), offset = startYear % 10; if (offset !== 0) { startYear -= offset; } startYear -= 1; for (let i = 0; i < 12; i++) { viewContent.push(startYear + ''); dates.push(new Date(startYear, selectedDate.getMonth(), selectedDate.getDate())); ++startYear; } } return { viewContent: viewContent, dates: dates }; } /** * Prepare the list DisplayMode view with data * @param {any} selectedDate */ _setDisplayModeListContent(selectedDate) { const that = this; let dataSource = []; function getValidDate(year, month, day) { let date = new Date(year, month + 1, 0), daysInMonth = date.getDate(); day > daysInMonth ? date.setDate(daysInMonth) : date.setDate(day); return date; } that.$dateViewContainer.addClass('lw-visibility-hidden'); if (that.$listViewContainer.hasClass('lw-hidden')) { that.$body.addClass('lw-calendar-list-view'); that.$listViewContainer.removeClass('lw-hidden'); that.$.listViewContainer._setFocusable(); that.$.body.removeAttribute('tabindex'); } if (that.displayMode === 'year') { let tempDate = new Date(); for (let i = 0; i < 12; i++) { tempDate = getValidDate(tempDate.getFullYear(), i, tempDate.getDate()); dataSource.push({ label: tempDate.toLocaleDateString(that.locale, { month: 'short' }), value: getValidDate(selectedDate.getFullYear(), i, selectedDate.getDate()).toDateString() }); } that.$yearContainer.removeClass('lw-calendar-selected'); that.$dateContainer.addClass('lw-calendar-selected'); } else { let startYear = that.min.getFullYear(), endYear = that.max.getFullYear(); endYear = Math.min(that.max.getFullYear(), selectedDate.getFullYear() + 10); startYear = Math.max(that.min.getFullYear(), endYear - 10); for (let i = startYear; i < endYear; i++) { dataSource.push({ label: i.toString(), value: new Date(i, selectedDate.getMonth(), selectedDate.getDate()).toDateString() }); } that.$yearContainer.addClass('lw-calendar-selected'); that.$dateContainer.removeClass('lw-calendar-selected'); } that.$.listViewContainer.dataSource = dataSource; that.$.listViewContainer.selectedValues = [selectedDate.toDateString()]; if (that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0])) { that.$.listViewContainer.ensureVisible(that.$.listViewContainer.selectedValues[0]); } that._refreshHeaderTitle(); that._refreshHeaderElements(); if (!that.unfocusable) { that.focus(); } } /** * Checks if date is in view. * @param {any} date - Date object */ _isDateInView(date) { const that = this; if (!date) { return false; } for (let d = 0; d < that._viewDates.length; d++) { if (date.getFullYear() === that._viewDates[d].getFullYear() && date.getMonth() === that._viewDates[d].getMonth()) { let cell = that._getCellByDate(date, that._animationStarted ? that.$.nextMonthsContainer : undefined); if (!cell) { return; } return cell.otherMonth || !cell.offsetHeight || cell.classList.contains('lw-visibility-hidden') ? false : true; } } return false; } /** * Calendar keyDown event handler. */ _keyDownHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } const activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement; //LW.RepeatButton throws click event, so it's not necessary to handle them switch (activeElement) { //Header elements case that.$.yearElement: if (event.key === 'Escape') { that._refreshHeaderElements(); } break; case that.$.dateElement: if (that.calendarMode === 'default' && event.key === ' ' || event.key === 'Enter') { event.preventDefault(); that._isInteractiveNavigation = true; that._showDateView(); return; } if (!that._focusedCell) { that._focusCell(); } if (event.key.indexOf('Arrow') > -1 && that.$.dateElement === activeElement && !that.unfocusable) { that.$.body.focus(); } that._navigateDays(event); break; case that.$.body: if (event.key === ' ') { event.preventDefault(); } //if (event.key === 'Enter') { // event.stopPropagation(); //} that._navigateDays(event); break; case that.$.yearContainer: if ((event.key === ' ' || event.key === 'Enter') && that.displayMode !== 'decade') { //Prevent window scrolling event.preventDefault(); that._isInteractiveNavigation = true; that._showDateView('year'); } if (event.key.indexOf('Arrow') > -1) { //Prevent window scrolling event.preventDefault(); if (!that._focusedCell) { that._focusCell(); } if (that.displayMode !== 'month' && that.displayModeView === 'list') { if (!that.unfocusable) { that.focus(); } that.$.listViewContainer._handleKeyStrokes(event.key); return; } that._navigateDays(event); } break; case that.$.dateContainer: if ((event.key === ' ' || event.key === 'Enter') && that.displayMode !== 'month') { //Prevent window scrolling event.preventDefault(); that._displayModeHandler(that.displayModeView === 'list' ? that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]) : that._focusedCell, 'month'); } if (event.key.indexOf('Arrow') > -1) { if (!that._focusedCell) { that._focusCell(); } if (that.displayMode !== 'month' && that.displayModeView === 'list') { if (!that.unfocusable) { that.focus(); } that.$.listViewContainer._handleKeyStrokes(event.key); return; } that._navigateDays(event); } break; default: if (that.displayMode !== 'month' && that.displayModeView === 'list') { if (['Arrow', 'End', 'Home', 'Page'].indexOf(event.key)) { //Prevent window scrolling event.preventDefault(); } if (event.key === ' ' || event.key === 'Enter' || (event.ctrlKey && (event.key === 'ArrowUp' || event.key === 'ArrowDown'))) { that._navigateDays(event); return; } that.$.listViewContainer._handleKeyStrokes(event.key); return; } if (event.key.indexOf('Arrow') > -1) { if (!that._focusedCell) { that._focusCell(); } that._navigateDays(event); } break; } } /** * ListBox in the listViewContainer itemClick event handler * @param {any} event */ _listViewContainerItemClickHandler(event) { const that = this; if (!LW.Utilities.Core.isMobile) { return; } if (that.displayModeView === 'list' && that.displayMode !== 'month') { that._displayModeHandler(event.target.items[event.detail.index]); } } /** * ListBox in the listViewContainer change event handler * @param {any} event */ _listViewContainerChangeEventHandler(event) { event.stopPropagation(); } /** * ListBox (listView) Key down event handler * @param {any} event */ _listViewContainerKeyDownHandler(event) { const that = this; if (that.displayModeView !== 'list') { return; } if (event.key === ' ' || event.key === 'Enter') { that._navigateDays(event); } } /** * Show the month/year/decade selection view */ _showDateView(newDisplayMode) { const that = this; newDisplayMode = newDisplayMode ? newDisplayMode : that.displayMode; switch (newDisplayMode) { case 'month': newDisplayMode = 'year'; break; case 'year': newDisplayMode = 'decade'; break; } if (that.displayMode === newDisplayMode) { return; } const isDisplayModeCHangeEventPrevented = that.$.fireEvent('displayModeChanging', { 'oldDisplayMode': that.displayMode, 'newDisplayMode': newDisplayMode }).defaultPrevented; if (isDisplayModeCHangeEventPrevented) { return; } that.displayMode = newDisplayMode; //Needed for animation, even if its not enabled let target; //if (arguments[0] && that.displayModeView === 'list' && that.displayMode !== 'month' && that.$.listViewContainer.items.length > 0) { if (that.displayModeView === 'list' && that.displayMode !== 'month' && that.$.listViewContainer.items.length > 0) { target = that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]); if (target.offsetHeight) { that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : target.offsetTop + target.offsetHeight / 2) + 'px'; } else { that.$.animationPanel.style.transformOrigin = (that.$.listViewContainer.offsetLeft + that.$.listViewContainer.offsetWidth / 2) + 'px ' + (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : that.$.listViewContainer.offsetTop + that.$.listViewContainer.offsetHeight / 2) + 'px'; } } else { if (!that._focusedCell) { that._focusCell(); } target = that._focusedCell; that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.offsetTop + target.offsetHeight / 2) + 'px'; } that.$monthsContainer.addClass('lw-hidden'); if (that.$dateViewContainer.hasClass('lw-hidden')) { that.$dateViewContainer.removeClass('lw-hidden'); } if (that.displayMode === 'decade') { that.$yearContainer.addClass('lw-calendar-selected'); that.$dateContainer.removeClass('lw-calendar-selected'); } if (that.hasAnimation) { that._animateView(-1, target); return; } that._setDisplayModeContent(that._focusedCell ? that._focusedCell.value : that._viewDates[0]); } /** * KeyUp event handler. */ _keyUpHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } if ((that.selectionMode === 'default' || that.selectionMode === 'range') && (event.key === 'Shift' || event.key === 'Control')) { that._keysPressed[event.key] = false; } } /** * Calendar mouse over/out events handler. */ _mouseEventsHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } const tooltip = that.$.tooltip; if (event.type === 'mouseenter') { that.$.setAttributeValue('hover', true); return; } else if (event.type === 'mouseleave') { that.$.setAttributeValue('hover', false); if (that._newRangeSelectionStarted && that.selectionMode === 'range') { const months = that.$.monthsContainer.children; for (let m = 0; m < months.length; m++) { that._getMonthCells(months[m]).map(cell => { that._setCellState(cell, 'hover', false); }); } } if (that.tooltip) { tooltip.close(); } return; } const target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target; if (!target.closest('.lw-calendar-week')) { if (that.tooltip) { clearTimeout(that._tooltipAutoCloseTimeout); tooltip[tooltip.contains(target) ? 'open' : 'close'](); } return; } const cell = target.closest('.lw-calendar-cell'); if (!cell) { return; } if (!LW.Utilities.Core.isMobile) { that._handleCalendarCellHover(event, cell); } if (!that.tooltip) { tooltip.close(); return; } const isImportantDate = cell.hasAttribute('important'); clearTimeout(that._tooltipAutoCloseTimeout); if (isImportantDate) { if (event.type === 'mouseover') { tooltip.selector = cell; if (tooltip.selector !== cell) { tooltip.close(); } else { if (!that.tooltipTemplate) { tooltip.innerHTML = tooltip.innerHTML.trim().length === 0 ? 'Important day!' : tooltip.innerHTML; } tooltip.open(); that.$.fireEvent('open', { target: tooltip, value: new Date(cell.value) }); } return; } } that._tooltipAutoCloseTimeout = setTimeout(function () { if (event.type === 'mouseout' || !cell || !isImportantDate) { tooltip.close(); } clearTimeout(that._tooltipAutoCloseTimeout); }.bind(that), that.tooltipDelay); } /** * Handles Tooltip open/close events * @param {Object} event */ _popupEventHandler(event) { const that = this, tooltip = that.$.tooltip; event.stopPropagation(); if(event.target === that.$.monthElement) { return; } if (event.target !== tooltip) { that.$.fireEvent(event.type, { target: event.target }); return; } if (event.type === 'close') { const cell = tooltip.selector; that.$.fireEvent('close', { target: tooltip, value: cell ? new Date(cell.value) : null }); return; } } /** * Calendar move event handler */ _moveHandler(event) { const that = this; if (!LW.Utilities.Core.isMobile || !that._dragStartDetails || (that.displayModeView === 'list' && that.displayMode !== 'month')) { return; } event.originalEvent.preventDefault(); event.preventDefault(); event.stopPropagation(); const details = { x: Math.round(event.pageX), y: Math.round(event.pageY) }; let step; if (that.scrollButtonsNavigationMode === 'portrait') { step = details.y > that._dragStartDetails.y ? -1 * that.months : 1 * that.months; } else { step = details.x < that._dragStartDetails.x ? 1 * that.months : -1 * that.months; } let navigationDate; if (that._previousIteration && step === that._previousIteration.step) { navigationDate = that._previousIteration.date; } else { if (that.weeks !== 6 && that.weeks !== 0 && that.displayMode === 'month') { let nextDateToUpdateTo; if (!that._focusedCell) { that._focusCell(); } let lastVisibleDate; const visibleWeeks = [].slice.call(that._focusedCell.closest('.lw-calendar-weeks').children). filter(week => !week.classList.contains('lw-hidden')); if (!visibleWeeks.length) { navigationDate = that._getNextDate(step * (that.rightToLeft ? -1 : 1)); } else { let calendarDates; if ((!that.rightToLeft && step < 0) || (that.rightToLeft && step > 0)) { calendarDates = visibleWeeks[0].querySelectorAll('.lw-calendar-cell'); lastVisibleDate = that.rightToLeft ? calendarDates[calendarDates.length - 1] : calendarDates[0]; } else { calendarDates = visibleWeeks[visibleWeeks.length - 1].querySelectorAll('.lw-calendar-cell'); lastVisibleDate = that.rightToLeft ? calendarDates[0] : calendarDates[calendarDates.length - 1]; } nextDateToUpdateTo = new Date(lastVisibleDate.value); nextDateToUpdateTo.setDate(nextDateToUpdateTo.getDate() + step * (that.rightToLeft ? -1 : 1)); navigationDate = nextDateToUpdateTo; } } else { navigationDate = that._getNextDate(step * (that.rightToLeft ? -1 : 1)); } } if (!navigationDate) { return; } if (!that._dragStartDetails.navigationDate) { if (that.$.fireEvent('navigationChanging', { value: new Date(navigationDate), type: that.displayMode }).defaultPrevented) { that._cancelAnimation(); that._dragStartDetails = undefined; return; } } that._dragStartDetails.step = step; that._dragStartDetails.navigationDate = new Date(navigationDate); if (!that.hasAnimation) { return; } that._previousIteration = { step: step, date: navigationDate }; that._mobileScrolling = true; let animationTarget; if (that.displayMode !== 'month') { that.$nextMonthsContainer.addClass('lw-calendar-date-view-container'); animationTarget = that.$.dateViewContainer; if (!(that.$.nextMonthsContainer.children[0].value instanceof Date) || that.$.nextMonthsContainer.children[1].value.getFullYear() !== navigationDate.getFullYear()) { that._setDisplayModeContent(navigationDate, that.$.nextMonthsContainer); } } else { if (that.$nextMonthsContainer.hasClass('lw-calendar-date-view-container')) { that.$nextMonthsContainer.removeClass('lw-calendar-date-view-container'); } animationTarget = that.$.monthsContainer; if (!that.$.nextMonthsContainer.children[0]._date || that.$.nextMonthsContainer.children[0]._date.getTime() !== navigationDate.getTime()) { let nextMonths = that.$.nextMonthsContainer.children; for (let i = 0; i < nextMonths.length; i++) { navigationDate.setMonth(that._dragStartDetails.navigationDate.getMonth() + i * (that.rightToLeft ? -1 : 1)); that._setMonth(new Date(navigationDate), nextMonths[i], true); } } } if (that.weeks !== 6 && that.weeks !== 0 && that.displayMode === 'month') { that._updateWeeksVisibility(step * (that.rightToLeft ? -1 : 1), that._getCellByDate(navigationDate, that.$.nextMonthsContainer)); } delete that._mobileScrolling; if (step < 0) { animationTarget.style.order = 3; that.$.nextMonthsContainer.style.order = 1; that.$.body[that._animationSettings.scrollSize] = that.$.body[that._animationSettings.scrollMax]; } else { animationTarget.style.order = 1; that.$.nextMonthsContainer.style.order = 3; that.$.body[that._animationSettings.scrollSize] = 0; } const direction = that.scrollButtonsNavigationMode === 'portrait' ? 'y' : 'x'; if (Math.abs(that._dragStartDetails[direction] - details[direction]) > 5) { that.$.body[that._animationSettings.scrollSize] += -(details[direction] - that._dragStartDetails[direction]) * 2; } } /** * Get next navigation date * @param {any} step */ _getNextDate(step) { const that = this; let targetDate; if (that.displayMode !== 'month') { let coefficient; const focusedDateYear = that._focusedCell && that._focusedCell.value.getFullYear(); if (that.displayModeView === 'list') { targetDate = new Date(that.$.listViewContainer.items[0].value); } else { let container = that._animationStarted ? that.$.nextMonthsContainer : that.$.dateViewContainer; targetDate = new Date(that.displayMode === 'year' ? container.children[0].value : container.children[1].value); } coefficient = that.displayMode === 'year' ? 1 : step !== 0 ? 10 : 1; targetDate.setFullYear(targetDate.getFullYear() + (step > 0 ? coefficient : -coefficient)); if (targetDate.getTime() < that.min.getTime()) { targetDate = that.min; } if (targetDate.getTime() > that.max.getTime()) { targetDate = that.max; } const isListViewVisible = that.displayMode !== 'month' && that.displayModeView === 'list'; //if (that.displayMode === 'year') { // if (targetDate.getFullYear() < that.min.getFullYear() || targetDate.getFullYear() > that.max.getFullYear() || // (isListViewVisible && focusedDateYear === targetDate.getFullYear())) { // return; // } //} if (targetDate.getFullYear() < that.min.getFullYear() || targetDate.getFullYear() > that.max.getFullYear() || (!isListViewVisible && focusedDateYear === targetDate.getFullYear())) { return; } } else { let dateInView = that._viewDates[0]; targetDate = new Date(dateInView); targetDate.setDate(1); targetDate.setMonth(targetDate.getMonth() + step); targetDate.setTime((Math.min(Math.max(targetDate.getTime(), that.min.getTime()), that.max.getTime()))); if (dateInView.getMonth() === targetDate.getMonth() && dateInView.getFullYear() === targetDate.getFullYear()) { return; } } return targetDate; } /** * Keyboard navigation between days in a month. */ _navigateDays(event) { const that = this; let iterations = event.key === 'ArrowUp' || event.key === 'ArrowDown' ? 7 : 1, coefficient = event.key === 'ArrowUp' || event.key === 'ArrowLeft' || event.key === 'PageUp' ? -1 : 1; switch (event.key) { case 'ArrowUp': case 'ArrowLeft': case 'ArrowDown': case 'ArrowRight': if (!that._handleArrowKeys(event, iterations, coefficient)) { return; } break; case ' ': case 'Enter': if (that.displayMode !== 'month') { that._displayModeHandler(that.displayModeView === 'list' ? that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]) : that._focusedCell); return; } break; case 'Control': case 'Shift': if (that.selectionMode === 'default') { that._keysPressed[event.key] = true; } if (that.selectionMode === 'range') { that._keysPressed[event.key] = event.key === 'Control'; } return; case 'Home': case 'End': { //Prevent window scrolling event.preventDefault(); let targetDate, getTargetMonthDay = function (days) { if (event.key === 'Home') { for (let d = 0; d < days.length; d++) { if (!days[d].otherMonth && (!days[d].disabled || !days[d].restricted) && days[d].offsetHeight) { return days[d]; } } } else { for (let d = days.length - 1; d >= 0; d--) { if (!days[d].otherMonth && (!days[d].disabled || !days[d].restricted) && days[d].offsetHeight) { return days[d]; } } } }; if (that.displayMode !== 'month') { targetDate = getTargetMonthDay(that.$.dateViewContainer.children); } else { targetDate = getTargetMonthDay(that._getMonthCells(that._focusedCell.closest('.lw-calendar-month'), that.rightToLeft)); } if (!targetDate) { return; } that._focusCell(targetDate); if (that.displayMode !== 'month') { return; } break; } case 'PageUp': case 'PageDown': { if (!that._handlePageUpDownKeys(event, coefficient)) { return; } break; } default: return; } if (that._focusedCell) { that._handleDateSelection(that._focusedCell); } } /** * Handles the arrow keys * @param {any} event * @param {any} iterations - number of days to iterate over * @param {any} coefficient - a flag indicating if the next date is in the future or in the past */ _handleArrowKeys(event, iterations, coefficient) { const that = this; let targetDate; if (that.displayMode === 'month' && !that._animationStarted && !that.unfocusable) { that.$.body.focus(); } if (!that._focusedCell) { that._focusCell(that._getCellByDate(new Date())); } if (event.altKey) { return; } if (event.ctrlKey) { if (event.key === 'ArrowDown' || event.key === 'ArrowUp') { if (that.calendarMode === 'classic') { return; } let displayMode; switch (that.displayMode) { case 'month': displayMode = event.key === 'ArrowDown' ? 'month' : 'year'; break; case 'year': displayMode = event.key === 'ArrowDown' ? 'month' : 'decade'; break; case 'decade': displayMode = event.key === 'ArrowDown' ? 'year' : 'decade'; break; } if (displayMode !== that.displayMode) { const oldValue = that.displayMode; //Change displayMode that.displayMode = displayMode; that._setDisplayMode(oldValue, displayMode, oldValue === 'month'); //KeyUpHandle isn't being thrown when displayModeView is 'list' if (that._keysPressed) { delete that._keysPressed['Control']; } } } return; } //Prevent window scrolling event.preventDefault(); if (that.rightToLeft && (event.key === 'ArrowLeft' || event.key === 'ArrowRight')) { coefficient *= -1; } if (that.displayMode !== 'month') { let items = that._animationStarted ? that.$.nextMonthsContainer.children : that.$.dateViewContainer.children; iterations = event.key === 'ArrowUp' || event.key === 'ArrowDown' ? 4 : 1; if (that.displayMode === 'year') { const targetMonth = that._focusedCell.value.getMonth() + coefficient * iterations; let lastDayOfMonth = new Date(that._focusedCell.value.getFullYear(), targetMonth + 1, 0); if (that._focusedCell.value.getDate() <= lastDayOfMonth.getDate()) { lastDayOfMonth = that._focusedCell.value; } targetDate = new Date(that._focusedCell.value.getFullYear(), targetMonth, lastDayOfMonth.getDate()); } else { targetDate = new Date(that._focusedCell.value.getFullYear() + coefficient * iterations, that._focusedCell.value.getMonth(), that._focusedCell.value.getDate()); } if (that.displayMode === 'year') { if (((targetDate.getFullYear() < that.min.getFullYear()) || (targetDate.getFullYear() === that.min.getFullYear() && targetDate.getMonth() < that.min.getMonth())) || ((targetDate.getFullYear() > that.max.getFullYear()) || (targetDate.getFullYear() === that.max.getFullYear() && targetDate.getMonth() > that.max.getMonth()))) { return; } if (targetDate.getTime() > items[items.length - 1].value.getTime()) { that.navigate(1); } else if (targetDate.getTime() < items[0].value.getTime()) { that.navigate(-1); } } else { if (targetDate.getFullYear() < that.min.getFullYear() || targetDate.getFullYear() > that.max.getFullYear()) { return; } if (targetDate.getFullYear() < items[1].value.getFullYear() || targetDate.getFullYear() > items[10].value.getFullYear()) { let focusedDate = that._focusedCell; that.navigate(coefficient); if (event.key === 'ArrowUp' || event.key === 'ArrowDown') { if (focusedDate === items[3] || focusedDate === items[4] || focusedDate === items[7] || focusedDate === items[8]) { targetDate.setFullYear(targetDate.getFullYear() + coefficient * 2); } else { targetDate.setFullYear(targetDate.getFullYear() - coefficient * 2); } } } } that._focusCell(that._getCellByDate(targetDate, that._animationStarted ? that.$.nextMonthsContainer : undefined)); return; } const restrictedDates = that.restrictedDates.map(Number); targetDate = new Date(that._focusedCell.value.getFullYear(), that._focusedCell.value.getMonth(), that._focusedCell.value.getDate() + coefficient * iterations, 0, 0, 0, 0); while (restrictedDates.indexOf(targetDate.getTime()) > -1) { targetDate.setDate(targetDate.getDate() + coefficient); } if (targetDate.getTime() < that.min.getTime() || targetDate.getTime() > that.max.getTime()) { return; } if (!that._isDateInView(targetDate)) { that.navigate(coefficient * that.months); } let cell = that._getCellByDate(targetDate, that._animationStarted ? that.$.nextMonthsContainer : undefined); that._focusCell(cell); that._updateWeeksVisibility(coefficient); if (['zeroOrMany', 'oneOrMany', 'none', 'many', 'week', 'range'].indexOf(that.selectionMode) > -1) { return; } return true; } _handlePageUpDownKeys(event, coefficient) { const that = this; //Prevent window scrolling event.preventDefault(); let targetDate; if (that.displayMode !== 'month') { targetDate = that._focusedCell; if (!that.navigate(coefficient)) { return; } while (targetDate && targetDate.classList.contains('lw-visibility-hidden')) { targetDate = targetDate.previousElementSibling === null ? targetDate.nextElementSibling : targetDate.previousElementSibling; } that._focusCell(targetDate); if (that.hasAnimation && that.displayMode === 'decade') { that._focusedCell.value.setFullYear(that._focusedCell.value.getFullYear() + 10 * coefficient); } return; } targetDate = new Date(that._focusedCell.value.getFullYear(), that._focusedCell.value.getMonth() + coefficient, 1, 0, 0, 0, 0); let daysInMonth = new Date(targetDate.getFullYear(), targetDate.getMonth() + 1, 0).getDate(); if (that._focusedCell.value.getDate() > daysInMonth) { targetDate.setDate(daysInMonth); } else { targetDate.setDate(that._focusedCell.value.getDate()); } if (!that._isDateInView(targetDate)) { that.navigate(targetDate); } if (that._animationStarted) { that._focusCell(that._getCellByDate(targetDate, that.$.nextMonthsContainer)); } else { that._focusCell(that._getCellByDate(targetDate)); } return true; } /** * Selects/Unselects a day. Accepts a LW.cell/ Day number/ Date object. */ _selectDate(date, eventPrevented, noPropSynch) { const that = this; if (typeof (that._viewDates) === 'undefined' || that.selectionMode === 'none') { return; } let selectedDates = that.selectedDates.slice(0); let cell = that._getCellByDate(date, that._animationStarted ? that.$.nextMonthsContainer : undefined); if (cell) { that._selectCell(cell); } let index; date = new Date(date); date.setHours(0, 0, 0, 0); index = selectedDates.map(Number).indexOf(date.getTime()); //Date selection if (that.restrictedDates.map(Number).indexOf(date.getTime()) > -1 || date.getTime() < that.min.getTime() || date.getTime() > that.max.getTime()) { return; } index > -1 ? selectedDates.splice(index, 1) : selectedDates.push(date); if (!noPropSynch) { that.selectedDates = selectedDates; } that._refreshFooter(); // Update the hidden input that.$.hiddenInput.value = that.selectedDates.toString(); if (!eventPrevented && that.isInitialized) { that.$.fireEvent('change', { 'value': [date] }); } that._refreshTitle(); } /** * Selects a day from the current month * @param {any} day - LW.cell instance */ _selectCell(cell) { const that = this; if (!cell || that.restrictedDates.map(Number).indexOf(cell.value.getTime()) > -1 || (that.disableAutoNavigation && false === cell.otherMonth) || cell.value.getTime() < that.min.getTime() || cell.value.getTime() > that.max.getTime()) { return; } const index = that._selectedCells.indexOf(cell); if (index > -1) { that._setCellState(cell, 'selected', false); that._selectedCells.splice(index, 1); } else { that._setCellState(cell, 'selected', true); that._selectedCells.push(cell); } that._focusCell(cell); } /** * Sets the names of the weeks. */ _refreshDayOfWeekTitles() { const that = this; let days = [], date = new Date(), dayObject; function formatDayName(date) { let result; if (that.dayNameFormat === 'firstTwoLetters') { result = new Intl.DateTimeFormat(that.locale, { weekday: 'long' }).format(date); result = result.charCodeAt(0) === 8206 ? result.substring(1, 3) : result.substring(0, 2); } else { result = new Intl.DateTimeFormat(that.locale, { weekday: that.dayNameFormat }).format(date); } return result; } for (let i = 1; i < 8; i++) { date.setDate(i); dayObject = { number: date.getDay(), name: formatDayName(date) }; days.push(dayObject); } days.sort((a, b) => (a.number > b.number ? 1 : -1)); const months = that.$.monthsContainer.children; let dayNameHolders, counter; for (let m = 0; m < months.length; m++) { dayNameHolders = months[m].getElementsByClassName('lw-calendar-week-titles')[0].children; counter = that.firstDayOfWeek > 6 ? 0 : that.firstDayOfWeek; //Validates firstDayOfWeek if (that.rightToLeft) { for (let d = dayNameHolders.length - 1; d >= 1; d--) { dayNameHolders[d].textContent = days[counter++].name; counter = counter > 6 ? 0 : counter; } } else { for (let d = 1; d < dayNameHolders.length; d++) { dayNameHolders[d].textContent = days[counter++].name; counter = counter > 6 ? 0 : counter; } } } //Update the weekTitles for nextMonths if (that.hasAnimation) { const weekTitles = that.$.monthsContainer.getElementsByClassName('lw-calendar-week-titles')[0].innerHTML, nextMonthWeekTitleContainers = that.$.nextMonthsContainer.getElementsByClassName('lw-calendar-week-titles'); for (let i = 0; i < nextMonthWeekTitleContainers.length; i++) { nextMonthWeekTitleContainers[i].innerHTML = weekTitles; } } } /** * Sets the header mode */ _refreshCalendarMode() { const that = this; if (that.headerTemplate) { return; } that._refreshMonthNames(); if (that.calendarMode === 'default') { that.$classicHeaderDate.addClass('lw-hidden'); that.$defaultHeaderDate.removeClass('lw-hidden'); const sortedDates = that._viewDates.slice(0).sort((a, b) => a.getTime() - b.getTime()), firstDateInView = sortedDates[0], lastDateInView = sortedDates[sortedDates.length - 1]; firstDateInView.setDate(2); let date = firstDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat }); if (that.months > 1) { lastDateInView.setDate(2); date += ' - ' + lastDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat }); } that.$.defaultHeaderDate.innerHTML = date; if (!that.unfocusable) { that.$.dateElement.setAttribute('tabindex', that.tabIndex > 0 ? that.tabIndex : 0); } } else { that.$defaultHeaderDate.addClass('lw-hidden'); that.$classicHeaderDate.removeClass('lw-hidden'); that.$.dateElement.removeAttribute('tabindex'); } } /** * Updates the footer with the latest date selection */ _refreshFooter() { const that = this; if ((that.viewSections.indexOf('footer') < 0 || that.$.footer.offsetHeight === 0)) { return; } function preFormatDateOutput() { if (that.selectedDates.length === 0) { return ''; } if (that.selectedDates.length === 1) { return that.selectedDates[0].toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' }); } else { let sortedDates = that.selectedDates.slice(0).sort((a, b) => a.getTime() - b.getTime()); return sortedDates[0].toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' }) + ' - ' + sortedDates[sortedDates.length - 1].toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' }); } } if (that.footerTemplate) { if (typeof that.footerTemplate === 'function') { return; } let layoutTemplate = that._layoutTemplates.filter(template => template.selector === that.$.footer)[0], clone = document.importNode(layoutTemplate.template.content, true); if (layoutTemplate.bindings.length > 0) { let bindingHolderElement = clone.childNodes[layoutTemplate.bindings[0].childNodeIndex]; layoutTemplate.selector.childNodes[layoutTemplate.bindings[0].childNodeIndex].innerHTML = bindingHolderElement.innerHTML.replace(layoutTemplate.bindings[0].bindingString, preFormatDateOutput()); } return; } that.$.selectedDatesRange.innerHTML = preFormatDateOutput(); } /** * Sets important days. */ _refreshImportantDates() { const that = this; if (that.displayMode !== 'month') { return; } that._clearImportantDates(); for (let d = 0; d < that.importantDates.length; d++) { that._setImportantDate(that.importantDates[d]); } } _clearImportantDates() { const that = this; const months = that.$.monthsContainer.children; for (let m = 0; m < months.length; m++) { that._getMonthCells(months[m]).map(cell => { that._setCellState(cell, 'important', false); }); } } _setImportantDate(date, cell) { const that = this; const cellByDate = that._getCellByDate(date); if (!cell) { cell = cellByDate; } if (cell) { that._setCellState(cell, 'important', true); that._applyImportantDateTemplate(cell); } } _applyImportantDateTemplate(cell) { const that = this; if (!that._importantDatesTemplate) { if (typeof that.importantDatesTemplate === 'function') { that.importantDatesTemplate(cell, { value: cell.value }); return; } cell.innerHTML = cell.value.getDate() + ''; return; } let clone = document.importNode(that._importantDatesTemplate.content, true); if (that._bindingDetails && that._bindingDetails.length > 0) { let bindingHolderElement = clone.childNodes[that._bindingDetails[0].childNodeIndex]; bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(that._bindingDetails[0].bindingString, cell.value.getDate()); } cell.innerHTML = ''; for (let i = 0; i < clone.childNodes.length; i++) { if (clone.childNodes[i].outerHTML) { cell.innerHTML += clone.childNodes[i].outerHTML; } } } /** * Fill's the month with dates and weeknubers. */ _setMonth(date, monthSelector, updateDatesOnly) { const that = this, selectedDates = that._getDays(date, that.selectedDates), importantDates = that._getDays(date, that.importantDates), restrictedDates = that._getDays(date, that.restrictedDates); date.setDate(1); if (!monthSelector) { monthSelector = that.$.month; } monthSelector._date = new Date(date); if (!updateDatesOnly) { if (!that._viewDates || that._viewDates.length >= that.months) { that._viewDates = []; } that._viewDates.push(new Date(date)); } date = new Date(date); //Correct the start day according to firstDayOfWeek property let firstDayOfWeek = (date.getDay() - that.firstDayOfWeek + 7) % 7; date.setDate(0); let previusMonthDays = date.getDate(); date.setDate(32); // current month. date.setDate(1); // set to first day of month. date.setDate(32); // next month. if (that._selectedCells) { for (let i = 0; i < that._selectedCells.length; i++) { if (that._selectedCells[i].closest('.lw-calendar-month') === monthSelector) { that._setCellState(that._selectedCells[i], 'selected', false); } } } that._setMonthContent(date, monthSelector, { previusMonthDays: previusMonthDays, firstDayOfWeek: firstDayOfWeek, selectedDates: selectedDates, importantDates: importantDates, restrictedDates: restrictedDates }); } /** * Populates the Calendar with days for the corresponding month and calculates week numbers. */ _setMonthContent(date, month, details) { const that = this; const daysInMonth = 32 - date.getDate(), monthCells = that._getMonthCells(month, that.rightToLeft), monthNumber = month._date.getMonth(), monthYear = month._date.getFullYear(), today = new Date(); let nextMonthDays = 1, day = 1, shouldItemBeHidden; today.setHours(0, 0, 0, 0); //reset all item properties monthCells.map(cell => { that._setCellState(cell, 'restricted', false); that._setCellState(cell, 'selected', false); that._setCellState(cell, 'otherMonth', false); that._setCellState(cell, 'focus', false); that._setCellState(cell, 'important', false); that._setCellState(cell, 'today', false); that._setCellState(cell, 'disabled', false); that._setCellState(cell, 'hover', false); }); for (let d = 0; d < monthCells.length; d++) { const cell = monthCells[d]; if (d === details.firstDayOfWeek && day <= daysInMonth) { cell.className = 'lw-calendar-cell'; cell.value = new Date(monthYear, monthNumber, day); cell.innerHTML = cell.value.getDate().toString(); if (details.restrictedDates.indexOf(day) > -1 || cell.value.getTime() < that.min.getTime() || cell.value.getTime() > that.max.getTime()) { that._setCellState(cell, 'restricted', true); } else if (details.selectedDates.indexOf(day) > -1) { that._setCellState(cell, 'selected', true); if (that._selectedCells.indexOf(cell) < 0) { that._selectedCells.push(cell); } } if (details.importantDates.indexOf(day) > -1) { that._setImportantDate(cell.value, cell); details.importantDates.splice(details.importantDates.indexOf(day), 1); } if (cell.value.getTime() === today.getTime()) { that._setCellState(cell, 'today', true); } details.firstDayOfWeek++; day++; } else { if (day === 1) { cell.value = new Date(monthYear, monthNumber - 1, ++details.previusMonthDays - details.firstDayOfWeek); shouldItemBeHidden = cell.value.getTime() < that.min.getTime() || month.previousElementSibling ? true : false; } else { cell.value = new Date(monthYear, monthNumber + 1, nextMonthDays++); shouldItemBeHidden = cell.value.getTime() > that.max.getTime() || month.nextElementSibling ? true : false; } cell.innerHTML = cell.value.getDate().toString(); that._setCellState(cell, 'otherMonth', true); if (shouldItemBeHidden) { cell.classList.add('lw-visibility-hidden'); } else { cell.classList.remove('lw-visibility-hidden'); } } } //Set month name if (that.months > 1) { month.firstElementChild.innerHTML = that.dateFormatFunction ? that.dateFormatFunction(month._date) : that._monthsNames[monthNumber] + ' ' + month._date.toLocaleDateString(that.locale, { year: that.yearFormat }); } // Set week numbers that._setMonthWeekNumbers(month); } /** * Sets the names of the months inside the dropDown, according to localization. */ _refreshMonthNames() { const that = this; let date = new Date(), formatedMonth; date.setDate(1); that._monthsNames = []; function formatMonthName(date) { let result = new Intl.DateTimeFormat(that.locale, { month: that.monthNameFormat }).format(date); if (that.monthNameFormat === 'firstTwoLetters') { //EDGE bug fix result = result.charCodeAt(0) === 8206 ? result.substring(0, 2) : result.substring(1, 3); } return result; } //get formated month names for (let m = 0; m < 12; m++) { date.setMonth(m); formatedMonth = formatMonthName(date); that._monthsNames.push(formatedMonth); } if (that.calendarMode === 'classic' && that.$.monthElement) { let months = that.$.monthsContainer.children; if (that.$.monthElement.dataSource) { that._changeEventFired = 1; //ListBox change event fired } //NOTE: when shadowDOM is Enabled, sometimes the context of the ListBox inside the DropDownList is not document and propertyChangeHandler is not fired on the ListBox if (that.shadowRoot) { that._setMonthElementPropertyInShadowDOM('dataSource', that._monthsNames); } else { that.$.monthElement.dataSource = that._monthsNames; } if (that._viewDates) { for (let m = 0; m < months.length; m++) { months[m].firstElementChild.textContent = that._monthsNames[months[m]._date.getMonth()] + ' ' + months[m]._date.getFullYear(); } that._changeEventFired = 1; //ListBox change event fired, again if (that.shadowRoot) { that._setMonthElementPropertyInShadowDOM('selectedIndexes', that._viewDates.map(date => date.getMonth())); } else { that.$.monthElement.selectedIndexes = that._viewDates.map(date => date.getMonth()); } } } } /** * Set weeks numbers. */ _setMonthWeekNumbers(month) { const that = this, isWeekVisible = function (week) { for (let d = 1; d < week.children.length; d++) { if (!week.children[d].classList.contains('lw-visibility-hidden')) { return true; } } }; let weeks = month.getElementsByClassName('lw-calendar-week'); weeks = [].slice.call(weeks); // Set week numbers for (let w = 0; w < weeks.length; w++) { if (!isWeekVisible(weeks[w])) { weeks[w].children[0].innerHTML = ''; continue; } const cell = weeks[w].children[1]; const monthOffset = cell.otherMonth ? (cell.value.getTime() > month._date.getTime() ? 1 : -1) : 0; weeks[w].children[0].innerHTML = that._getWeekNumber(new Date(month._date.getFullYear(), month._date.getMonth() + monthOffset, cell.value.getDate())); } } /** * Sets restricted dates. */ _setRestrictedDates(restrictedDates) { const that = this; const months = that.$.monthsContainer.children; for (let m = 0; m < months.length; m++) { that._getMonthCells(months[m]).map(cell => { that._setCellState(cell, 'restricted', false); }); } if (that._viewDates) { const isDateRestricted = function (date) { for (let i = 0; i < that._viewDates.length; i++) { if (that._viewDates[i].getFullYear() === date.getFullYear() && that._viewDates[i].getMonth() === date.getMonth()) { return true; } } }; for (let i = 0; i < restrictedDates.length; i++) { if (isDateRestricted(restrictedDates[i])) { const cell = that._getCellByDate(restrictedDates[i]); that._setCellState(cell, 'restricted', true); } } } } /** * Sets the arrow direction of the scrollButtons */ _setScrollButtonsNavigationMode() { const that = this; if (that.scrollButtonsNavigationMode !== 'landscape') { if (that.$.previousMonthButton) { that.$.previousMonthButton.$.button.firstElementChild.className = 'lw-arrow-down lw-arrow'; } if (that.$.nextMonthButton) { that.$.nextMonthButton.$.button.firstElementChild.className = 'lw-arrow-up lw-arrow'; } } else { if (that.$.previousMonthButton) { that.$.previousMonthButton.$.button.firstElementChild.className = 'lw-arrow-left lw-arrow'; } if (that.$.nextMonthButton) { that.$.nextMonthButton.$.button.firstElementChild.className = 'lw-arrow-right lw-arrow'; } } that._applyAnimationSettings(true); } /** * Updates Calendar's title */ _refreshTitle() { const that = this; let date = that.selectedDates.length > 0 ? that.selectedDates[that.selectedDates.length - 1] : new Date(); if (that.titleTemplate) { if (typeof that.titleTemplate === 'function') { return; } let layoutTemplate = that._layoutTemplates.filter(template => template.selector === that.$.title)[0], clone = document.importNode(layoutTemplate.template.content, true); if (layoutTemplate.bindings.length > 0) { let bindingHolderElement = clone.childNodes[layoutTemplate.bindings[0].childNodeIndex]; date = date.toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' }); layoutTemplate.selector.childNodes[layoutTemplate.bindings[0].childNodeIndex].innerHTML = bindingHolderElement.innerHTML.replace(layoutTemplate.bindings[0].bindingString, date); return; } } that.$.title.children[0].innerHTML = date.toLocaleDateString(that.locale, { year: that.yearFormat }); that.$.title.children[1].innerHTML = that.view === 'landscape' ? date.toLocaleDateString(that.locale, { weekday: 'short' }) + ',' + '</br>' + date.toLocaleDateString(that.locale, { month: 'short', day: 'numeric' }) : date.toLocaleDateString(that.locale, { weekday: 'short' }) + ', ' + date.toLocaleDateString(that.locale, { month: 'short', day: 'numeric' }); } /** * Set how many weeks will be visible. */ _setWeeksVisibility(monthContainer) { const that = this, months = monthContainer.children; let counter; //NOTE: classlist is used because when months > 1(or animation is ON) all weeks need to extend LW function setVisibility(week) { const shouldWeekBeHidden = function (week) { for (let d = 1; d < week.children.length; d++) { if (!week.children[d].classList.contains('lw-visibility-hidden')) { return false; } } return true; }; if (shouldWeekBeHidden(week) || counter >= that.weeks) { week.classList.add('lw-hidden'); return; } if (counter < that.weeks) { week.classList.remove('lw-hidden'); counter++; } } for (let m = 0; m < months.length; m++) { const month = months[m]; let weeks = month.getElementsByClassName('lw-calendar-week'); weeks = [].slice.call(weeks); let selectedDates = that._selectedCells.filter(date => date.closest('.lw-calendar-month') === months[m]); if (that.weeks === 6) { weeks.map(week => week.classList.remove('lw-hidden')); continue; } counter = 0; if (selectedDates.length > 0) { let selectedDay = selectedDates[selectedDates.length - 1], selectedDayWeekIndex = weeks.indexOf(selectedDay.parentElement); // Weeks after the one with the last selectedDay. for (let i = selectedDayWeekIndex; i < weeks.length; i++) { setVisibility(weeks[i]); } // Weeks before the one with the last selectedDay. for (let i = selectedDayWeekIndex - 1; i >= 0; i--) { setVisibility(weeks[i]); } } else { //No selectedDay, start from 1st week for (let i = 0; i < weeks.length; i++) { setVisibility(weeks[i]); } } } } /** * Updates the header elements if they haven't been changed. */ _refreshHeaderElements() { const that = this, isCalendarFocused = document.activeElement.closest('lw-calendar') === that, target = that._animationStarted ? that.$.nextMonthsContainer : that.$.dateViewContainer; let lastDateInView = that._viewDates[that._viewDates.length - 1], yearsInView = that._viewDates.map(date => date.getFullYear()), nextDate, nextYear; if (that.displayMode !== 'month' && that.displayModeView === 'list') { return; } //Previous month navigation element if (that.$.previousMonthButton && !that.disabled) { if (that.displayMode !== 'month' && that.$.dateViewContainer.children[0].value) { nextYear = that.displayMode === 'year' ? target.children[0].value.getFullYear() - 1 : target.children[1].value.getFullYear() - 1; } else if (that._viewDates[0].getMonth() - 1 < 0) { nextDate = 11; nextYear = that._viewDates[0].getFullYear() - 1; } else { nextDate = that._viewDates[0].getMonth() - 1; nextYear = that._viewDates[0].getFullYear(); } that.$.previousMonthButton.disabled = nextYear < that.min.getFullYear() || nextYear === that.min.getFullYear() && nextDate < that.min.getMonth() ? true : false; if (that.$.previousMonthButton.disabled && isCalendarFocused) { that.$.body.focus(); } } //Next month navigation element if (that.$.nextMonthButton && !that.disabled) { if (that.displayMode !== 'month' && that.$.dateViewContainer.children[0].value) { nextYear = that.displayMode === 'year' ? target.children[0].value.getFullYear() + 1 : target.children[1].value.getFullYear() + 11; } else if (lastDateInView.getMonth() + 1 > 11) { nextDate = 0; nextYear = lastDateInView.getFullYear() + 1; } else { nextDate = lastDateInView.getMonth() + 1; nextYear = lastDateInView.getFullYear(); } that.$.nextMonthButton.disabled = nextYear > that.max.getFullYear() || nextYear === that.max.getFullYear() && nextDate > that.max.getMonth() ? true : false; if (that.$.nextMonthButton.disabled && isCalendarFocused) { that.$.body.focus(); } } //Month selection element if (that.calendarMode === 'classic' && that.$.monthElement) { const items = that.$.monthElement.items; items.map(item => item.disabled = false); if (yearsInView.indexOf(that.min.getFullYear()) > -1) { for (let i = 0; i < that.min.getMonth(); i++) { items[i].disabled = true; } } if (yearsInView.indexOf(that.max.getFullYear()) > -1) { for (let i = that.max.getMonth() + 1; i < items.length; i++) { items[i].disabled = true; } } that._changeEventFired = that.$.monthElement.selectedIndexes.length; if (that.shadowRoot) { that._setMonthElementPropertyInShadowDOM('selectedIndexes', [that._viewDates[0].getMonth()]); } else { that.$.monthElement.selectedIndexes = [that._viewDates[0].getMonth()]; } that._changeEventFired = 0; } //Previous year navigation element if (that.$.previousYearButton && !that.disabled) { nextYear = that._viewDates[0].getFullYear() - 1; that.$.previousYearButton.disabled = nextYear < that.min.getFullYear() ? true : false; if (that.$.previousYearButton.disabled && isCalendarFocused) { that.$.body.focus(); } } //Next year navigation element if (that.$.nextYearButton && !that.disabled) { nextYear = lastDateInView.getFullYear() + 1; that.$.nextYearButton.disabled = nextYear > that.max.getFullYear() ? true : false; if (that.$.nextYearButton.disabled && isCalendarFocused) { that.$.body.focus(); } } //Year element if (that.$.yearElement) { that.$.yearElement.value = yearsInView[0]; that.$.yearElement.disabled = lastDateInView.getFullYear() + 1 > that.max.getFullYear() && that._viewDates[0].getFullYear() - 1 < that.min.getFullYear() ? true : false; } } /** * Fixes ShadowDOM Context issue * Note: * Since in ShadowDOM the context of the monthElement and it's listBox during element initializaion is not document this method is the solution * @param {any} propertyname * @param {any} value */ _setMonthElementPropertyInShadowDOM(propertyname, value) { const that = this, monthElement = that.$.monthElement, monthElementListBox = that.$.monthElement.$ ? that.$.monthElement.$.listBox : undefined; const monthElementContext = monthElement.context; let monthElementListboxContext; monthElement.context = document; if (monthElementListBox) { monthElementListboxContext = monthElementListBox.context; monthElementListBox.context = document; } that.$.monthElement[propertyname] = value; monthElement.context = monthElementContext; if (monthElementListBox) { monthElementListBox.context = monthElementListboxContext; } } /** * Updates the header/footer section with the appropriate date */ _refreshHeaderTitle() { const that = this; let date; function preFormatDate() { if (that.displayMode !== 'month') { if (that.displayModeView === 'list') { let items = that.$.listViewContainer.items; const selectedDate = that.$.listViewContainer.selectedValues[0]; if (!items.length) { return ''; } date = that.displayMode === 'year' ? new Date(selectedDate ? that.$.listViewContainer.getItem(selectedDate.value) : items[0].value).getFullYear() : new Date(items[0].value).getFullYear() + ' - ' + new Date(items[items.length - 1].value).getFullYear(); } else if (that.$.dateViewContainer.children[0].value) { let dateViewItems = that._animationStarted ? that.$.nextMonthsContainer.children : that.$.dateViewContainer.children; date = that.displayMode === 'year' ? dateViewItems[0].value.getFullYear() : dateViewItems[1].value.getFullYear() + ' - ' + dateViewItems[dateViewItems.length - 2].value.getFullYear(); } if (date) { return date; } } const sortedDates = that._viewDates.slice(0).sort((a, b) => a.getTime() - b.getTime()), firstDateInView = sortedDates[0], lastDateInView = sortedDates[sortedDates.length - 1]; firstDateInView.setDate(2); date = firstDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat }); if (that.months > 1) { lastDateInView.setDate(2); date += ' - ' + lastDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat }); } return date; } if (that.calendarMode === 'default') { that.$.defaultHeaderDate.innerHTML = preFormatDate(); } if (typeof that.headerTemplate === 'function' || !that._layoutTemplates) { return; } let layoutTemplate = that._layoutTemplates.filter(template => template.selector === that.$.header)[0]; if (!layoutTemplate) { return; } let clone = document.importNode(layoutTemplate.template.content, true); if (layoutTemplate.bindings.length > 0) { const bindingHolderElement = clone.childNodes[layoutTemplate.bindings[0].childNodeIndex]; //Note: HTMLSlotElements are used when the element has ShadowDOM and contents of the template are in the LightDOM (that.shadowRoot ? that : layoutTemplate.selector).childNodes[layoutTemplate.bindings[0].childNodeIndex].innerHTML = bindingHolderElement.innerHTML.replace(layoutTemplate.bindings[0].bindingString, that.dateFormatFunction ? that.dateFormatFunction(that._viewDates) : preFormatDate()); } } /** * Shows/hides the target week */ _updateWeeksVisibility(step, cell) { const that = this; let focusedWeek = (cell || that._focusedCell).parentElement; function futureWeeks() { for (let i = weekIndex; i < monthWeeks.length; i++) { if (!monthWeeks[i].classList.contains('lw-hidden') || shouldWeekBeHidden(monthWeeks[i])) { continue; } monthWeeks[i].classList.remove('lw-hidden'); counter++; if (counter === that.weeks) { return true; } } } function pastWeeks() { for (let i = weekIndex; i >= 0; --i) { if (!monthWeeks[i].classList.contains('lw-hidden') || shouldWeekBeHidden(monthWeeks[i])) { continue; } monthWeeks[i].classList.remove('lw-hidden'); counter++; if (counter === that.weeks) { return true; } } } //NOTE: classlist is used because when months > 1(or animation is ON) all weeks need to extend LW if (!cell && !focusedWeek.classList.contains('lw-hidden')) { return; } const monthWeeks = [].slice.call(focusedWeek.parentElement.children), weekIndex = monthWeeks.indexOf(focusedWeek), shouldWeekBeHidden = function (week) { for (let d = 1; d < week.children.length; d++) { if (!week.children[d].classList.contains('lw-visibility-hidden')) { return false; } } return true; }; let counter = 0; monthWeeks.map(week => week.classList.add('lw-hidden')); if (step > 0) { if (futureWeeks()) { return; } pastWeeks(); } else { if (pastWeeks()) { return; } futureWeeks(); } } /** * Validates potential date input and returns an Array of Date Objects. */ _getValidDates(dateOrDates) { let result = []; function validate(date) { if (date instanceof Date) { return date; } else if (LW.Utilities.DateTime && date instanceof LW.Utilities.DateTime) { return date.toDate(); } else if (typeof (date) === 'string') { if (date.trim() === 'new Date()' || date.trim() === 'new LW.Utilities.DateTime()') { return new Date(); } let regex = /(\d+[,-.\/]{1}\s*\d+[,-.\/]{1}\s*\d+)/; const parseDateString = () => { date = date.replace(/[,-.\/]/g, ',').split(','); if (date.length > 2) { date = new Date(parseInt(date[0]), parseInt(date[1]) - 1, parseInt(date[2])); } else { return new Date(); } return date; } if (regex.test(date)) { date = regex.exec(date)[0].replace(/[,-.\/]/g, ',').split(','); if (date) { return new Date(parseInt(date[0]), parseInt(date[1]) - 1, parseInt(date[2])); } else { return parseDateString(); } } else { return parseDateString(); } } } if (dateOrDates === undefined) { return null; } if (Array.isArray(dateOrDates)) { for (let i = 0; i < dateOrDates.length; i++) { result.push(validate(dateOrDates[i])); } } else { result.push(validate(dateOrDates)); } result = result.filter(date => date && date.toDateString() !== 'Invalid Date'); //remove invalid dates result.map(date => date.setHours(0, 0, 0, 0)); //reset time, important for date comparing return result; } _getValidDate(date) { const that = this; const validDates = that._getValidDates(date); if (validDates.length > 0) { return validDates[0]; } return null; } /** * Validates the selectedDates to be in range min>date<max. */ _validateSelectedDates(dates) { const that = this; let outOfRangeDates = []; if (!dates) { dates = that.selectedDates; } let selectedDates = dates.slice(0), filter = function (date) { if (date.getTime() >= that.min.getTime() && date.getTime() <= that.max.getTime() && !isRestrictedDate(date)) { return true; } outOfRangeDates.push(date); return; }, isRestrictedDate = function (date) { for (let d = 0; d < that.restrictedDates.length; d++) { if (that.restrictedDates[d].getTime() === date.getTime()) { return true; } } } //Synchronize the attribute. that.selectedDates = selectedDates.filter(filter); //Unselects dates that are out of range. if (that._viewDates) { outOfRangeDates.map(date => that._selectDate(date)); that._focusCell(); } } /** * min property validator */ _validateMinMax(propertyName, newValue, oldValue) { const that = this; switch (propertyName) { case 'min': newValue = that._getValidDate(that[propertyName]); that.min = newValue ? newValue : oldValue ? oldValue : that.properties.min.defaultValue; break; case 'max': newValue = that._getValidDate(that[propertyName]); that.max = newValue ? newValue : oldValue ? oldValue : that.properties.max.defaultValue; break; default: newValue = that._getValidDate(that.min); that.min = newValue ? newValue : oldValue ? oldValue : that.properties.min.defaultValue; newValue = that._getValidDate(that.max); that.max = newValue ? newValue : oldValue ? oldValue : that.properties.max.defaultValue; break; } that.min = that.min.getTime() > that.max.getTime() ? that.max : that.min; //reset time, important when comparing dates. that.min.setHours(0, 0, 0, 0); that.max.setHours(0, 0, 0, 0); let months = that.$.monthsContainer.children, days; if (that._viewDates) { if (that._viewDates[0].getTime() > that.max.getTime() || that._viewDates[0].getTime() < that.min.getTime()) { that._handleMonths(); return; } for (let i = 0; i < months.length; i++) { days = that._getMonthCells(months[i]); for (let d = 0; d < days.length; d++) { const cell = days[d]; if (cell.value.getTime() >= that.min.getTime() && cell.value.getTime() <= that.max.getTime()) { that._setCellState(cell, 'restricted', false); if (cell.value.getMonth() === months[i]._date.getMonth()) { cell.classList.remove('lw-visibility-hidden'); } else if (!that.hideOtherMonthDays) { that._setCellState(cell, 'otherMonth', true); cell.classList.remove('lw-visibility-hidden'); } if (that.displayMode !== 'month') { that._setCellState(cell, 'otherMonth', false); } } else { if (!cell.otherMonth) { that._setCellState(cell, 'restricted', true); } else if (cell.classList.contains('lw-visibility-hidden')) { that._setCellState(cell, 'restricted', false); continue; } if (that.displayMode !== 'month') { cell.classList.remove('lw-visibility-hidden'); that._setCellState(cell, 'otherMonth', true); } } } } } } _setCellState(cell, propertyName, value) { cell[propertyName] = value; const attributeName = LW.Utilities.Core.toDash(propertyName); if (value) { cell.setAttribute(attributeName, ''); if (propertyName === 'selected') { cell.setAttribute('aria-selected', true); } else if (propertyName === 'today') { cell.setAttribute('aria-current', 'date'); } else if (propertyName === 'restricted') { cell.removeAttribute('aria-selected'); } else if (propertyName === 'disabled') { cell.removeAttribute('aria-selected'); cell.setAttribute('aria-disabled', true); } } else { cell.removeAttribute(attributeName); if (propertyName === 'selected') { if (this.selectionMode === 'none' || cell.restricted || cell.disabled) { cell.removeAttribute('aria-selected'); } else { cell.setAttribute('aria-selected', false); } } else if (propertyName === 'today') { cell.removeAttribute('aria-current'); } else if (propertyName === 'restricted' && !cell.disabled) { cell.setAttribute('aria-selected', false); } else if (propertyName === 'disabled') { cell.removeAttribute('aria-disabled'); if (!cell.restricted) { cell.setAttribute('aria-selected', false); } } } } /** * Checks for HTMLTemplate support and returns it's content. */ _validateTemplate(propertyName, template) { if (template === null || !template) { return; } if (typeof (template) === 'function') { return; } const that = this; if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } if (typeof (template) === 'string') { template = document.getElementById(template); } if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: propertyName })); return; } return template; } /** * Navigates to next/previous month when clicked on other month day. */ _weeksDownHandler(event, cell) { const that = this, date = cell.value; let neighbourMonth; if (cell.otherMonth) { neighbourMonth = cell.value.getTime() > cell.closest('.lw-calendar-month')._date.getTime() ? 1 : -1; } if (date && that.hasRippleAnimation) { LW.Utilities.Animation.Ripple.animate(cell, event.pageX, event.pageY); } if (neighbourMonth) { if (that._isDateInView(date)) { return; } if (!that.disableAutoNavigation) { that.navigate(neighbourMonth * that.months); } return; } cell = that._getCellByDate(date); if (cell && (cell.disabled || cell.restricted)) { return; } that._handleDateSelection(cell); } /** * firstDayOfweek property validator */ _firstDayOfWeekValidator(oldValue, newValue) { return Math.min(Math.max(0, (isNaN(newValue) ? 6 : newValue)), 6); } /** * Weeks property validator. */ _weeksValidator(oldValue, newValue) { return Math.min(Math.max(1, (isNaN(newValue) ? 6 : newValue)), 6); } /** * Months property validator. */ _monthsValidator(oldValue, newValue) { return Math.min(Math.max(1, (isNaN(newValue) ? 1 : newValue)), 12); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Card item custom element. */ LW('lw-card', class Card extends LW.ContentElement { // Card item's properties. static get properties() { return { 'dataSource': { value: null, type: 'object?', reflectToAttribute: false }, 'itemTemplate': { value: null, type: 'any?', reflectToAttribute: false }, 'contentHandler': { value: null, type: 'function?', reflectToAttribute: false } }; } /** * Card item's event listeners. */ static get listeners() { return { 'mouseenter': '_mouseEnterHandler', 'mouseleave': '_mouseLeaveHandler', 'swipeleft': '_swipeHandler', 'swiperight': '_swipeHandler', 'swipetop': '_swipeHandler', 'swipebottom': '_swipeHandler' }; } static get styleUrls() { return [ 'lw.card.css' ] } /** * Card's HTML template. */ template() { return `<div id="container" inner-h-t-m-l="[[innerHTML]]" role="presentation"> <content></content> </div>`; } /** * Updates the Card when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'itemTemplate': that._template = that._handleTemplate(); that.innerHTML = that._processTemplate(); if (that.contentHandler) { that.contentHandler(that); } break; case 'dataSource': that.innerHTML = that._processTemplate(); if (that.contentHandler) { that.contentHandler(that); } break; case 'contentHandler': if (that.contentHandler) { that.contentHandler(that); } break; } } /** * Called when the element is ready. Used for one-time configuration of the Accordion. */ ready() { super.ready(); } render() { const that = this; that.setAttribute('role', 'group'); that._template = that._handleTemplate(); if (that._template.hasBindings) { that.innerHTML = that._processTemplate(); } else if (that.itemTemplate) { that.innerHTML = that._template.content; } if (that.contentHandler) { that.contentHandler(that); } super.render(); } _handleTemplate() { const that = this; let template = that.itemTemplate, templateContent = '', hasBindings = false, regex = /{{\w+}}/g; if (that.itemTemplate) { if (template instanceof HTMLElement) { templateContent = template.innerHTML; } else { template = document.getElementById(template); templateContent = template ? template.innerHTML : ''; } } else { templateContent = that.innerHTML; } if (regex.exec(templateContent)) { hasBindings = true; } return { content: templateContent, hasBindings: hasBindings }; } _processTemplate() { const that = this, regex = /{{\w+}}/g, bindings = that._template.content.match(regex), dataSource = that.dataSource || {}; let processedTemplate = that._template.content; if (!bindings || bindings.length === 0) { return processedTemplate; } bindings.forEach(function (binding) { const propertyName = binding.replace('{{', '').replace('}}', ''); let data = dataSource[propertyName]; if (data === undefined) { data = ''; } processedTemplate = processedTemplate.replace(binding, data); }); return processedTemplate; } /** * Swipe events handler. **/ _swipeHandler() { } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * lwCarousel custom element. */ LW('lw-carousel', class Carousel extends LW.ContentElement { /** * Element's properties */ static get properties() { return { 'autoPlay': { value: false, type: 'any' }, 'dataSource': { value: [], type: 'array', reflectToAttribute: false }, 'delay': { value: 200, type: 'number' }, 'displayMode': { allowedValues: ['default', 'multiple', '3d'], value: 'default', type: 'string' }, 'disableItemClick': { value: false, type: 'boolean' }, 'hideArrows': { value: false, type: 'boolean' }, 'hideIndicators': { value: false, type: 'boolean' }, 'indicatorTemplate': { value: null, type: 'any' }, 'interval': { value: 5000, type: 'number' }, 'itemTemplate': { value: null, type: 'any' }, 'keyboard': { value: false, type: 'boolean' }, 'loop': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'htmlTemplateNotSuported': '{{elementType}}: Browser doesn\'t support HTMLTemplate elements.' } }, type: 'object', extend: true }, 'slideShow': { value: false, type: 'boolean' }, 'swipe': { value: false, type: 'boolean' }, 'wheel': { value: false, type: 'boolean' } } } /** * Element's event listeners. */ static get listeners() { return { 'arrowLeft.click': '_handleArrowClick', 'arrowRight.click': '_handleArrowClick', 'indicatorsContainer.click': '_handleIndicatorsContainerClick', 'keydown': '_handleKeyDown', 'swipeleft': '_handleSwipe', 'swiperight': '_handleSwipe', 'wheel': '_handleMouseWheel', 'itemsContainer.click': '_handleItemClick', 'itemsContainer.transitionend': '_handleTransitionEnd' } } /* * Checks for missing modules. */ static get requires() { return { 'LW.RepeatButton': 'lw.button.js' } } static get styleUrls() { return [ 'lw.button.css', 'lw.carousel.css' ] } /** * Element ShadowDOM enabler getter */ get enableShadowDOM() { const that = this, enableShadowDOM = LW.EnableShadowDOM; //NOTE: CardView flag to avoid ShadowDOM creation if (that._isInShadowDOM) { return !that._isInShadowDOM; } if (that.isCompleted) { return that.shadowRoot !== null; } return enableShadowDOM; } /** * Element's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="itemsContainer" inner-h-t-m-l="[[innerHTML]]" class="lw-items-container" role="presentation"><content></content></div> <lw-repeat-button initial-delay="0" right-to-left="[[rightToLeft]]" delay="[[delay]]" id="arrowLeft" animation="[[animation]]" unfocusable class="lw-arrow lw-arrow-left" aria-label="Previous slide"></lw-repeat-button> <lw-repeat-button initial-delay="0" right-to-left="[[rightToLeft]]" delay="[[delay]]" id="arrowRight" animation="[[animation]]" unfocusable class="lw-arrow lw-arrow-right" aria-label="Next slide"></lw-repeat-button> <div id="indicatorsContainer" class="lw-indicators-container" role="tablist"></div> </div>`; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); switch (propertyName) { case 'disabled': that._setFocusable(); break; case 'dataSource': that._currentIndex = 0; that._generateIndicators(); that._generateItems(); that._handleIndicatorsState(0, 0); that._handleItemsState(0, 0); that._handle3dMode(0); if (that.autoPlay !== false) { const interval = parseInt(that.autoPlay); if (interval) { setTimeout(function () { that.play(); }, interval); } else { that.play(); } } that._animationTrigger(that._currentIndex); break; case 'itemTemplate': that._generateItems(); that._handleItemsState(that._currentIndex, that._currentIndex + 1); break; case 'indicatorTemplate': that._generateIndicators(); that._handleIndicatorsState(that._currentIndex, that._currentIndex + 1); break; case 'interval': that.pause(); that.play(); break; case 'loop': that._handleArrowsActiveState(that._currentIndex, that._currentIndex); break; case 'hideArrows': if (!newValue) { that._handleArrowsActiveState(that._currentIndex, that._currentIndex); } break; case 'displayMode': if (oldValue === 'multiple') { that.$.itemsContainer.removeAttribute('style'); } break; } } /** * Called when the element and it's styles are rendered. After ready */ render() { const that = this; that.setAttribute('role', 'region'); that.setAttribute('aria-roledescription', 'carousel'); that._setInitialState(); that._generateIndicators(); that._generateItems(); that._handleIndicatorsState(0, 0); that._handleItemsState(0, 0); that._handle3dMode(0); if (that.autoPlay !== false) { const interval = parseInt(that.autoPlay); interval ? setTimeout(function () { that.play() }, interval) : that.play(); } that._setFocusable(); that._animationTrigger(that._currentIndex); that._handleArrowsActiveState(0, that._currentIndex); super.render(); } /** * Moves to the slide with the next index. * In loop mode if current is last index, carousel moves to the first slide. */ next() { const that = this, availableItems = that.dataSource.length; if (that.disabled || availableItems === 0) { return; } let nextItem = that._currentIndex; if (that.loop) { nextItem = nextItem >= availableItems - 1 ? 0 : nextItem + 1; } else { nextItem = nextItem >= availableItems - 1 ? nextItem : nextItem + 1; } that._goToItem(nextItem); } /** * Pauses slideShow. */ pause() { const that = this; that._handleRotation(); that._rotate = false; } /** * Slides to the element with the given index. */ slideTo(index) { const that = this; index = index ? parseInt(index) : 0; if (that.disabled || index < 0 || index > that._items.length) { return; } that._goToItem(index); } /** * Moves to the slide with the previous index. * In loop mode if current is first index, carousel moves to the last slide. */ prev() { const that = this, availableItems = that.dataSource.length; if (that.disabled || availableItems === 0) { return; } let previousItem = that._currentIndex; if (that.loop) { previousItem = previousItem <= 0 ? availableItems - 1 : previousItem - 1; } else { previousItem = previousItem <= 0 ? 0 : previousItem - 1; } that._goToItem(previousItem); } /** * Starts slideShow. */ play() { const that = this; if (that.disabled || !that.slideShow) { return; } if (that._rotationInterval) { clearInterval(that._rotationInterval); } that._handleRotation(true); that._rotate = true; } /** * Prevents animation on the selected animation slide immediately after items initialization */ _animationTrigger(skip) { const that = this; for (let i = 0; i < that._items.length; i++) { if (i === skip) { continue; } that._items[i].classList.add('lw-animate-trigger'); } } /** * In "3d" mode sets positions of carousel items in relation to the active slide. */ _handle3dMode(newIndex) { const that = this, itemsCount = that.dataSource.length; if (that.disabled || !itemsCount || that.displayMode !== '3d') { return; } newIndex = newIndex || 0; for (let i = 0; i < itemsCount; i++) { const currentPosition = (i - newIndex) * (that.rightToLeft ? -1 : 1); currentPosition ? that._items[i].setAttribute('position', currentPosition) : that._items[i].removeAttribute('position'); } } /** * Enables/disables arrows */ _handleArrowsActiveState(newIndex/*, oldIndex*/) { const that = this, itemsCount = that.dataSource.length; if (that.loop) { that.$.arrowLeft.disabled = that.$.arrowRight.disabled = false; return; } if (that.rightToLeft) { that.$.arrowRight.disabled = newIndex === 0; that.$.arrowLeft.disabled = newIndex === (itemsCount - 1); } else { that.$.arrowLeft.disabled = newIndex === 0; that.$.arrowRight.disabled = newIndex === (itemsCount - 1); } } /** * Handles click on carousel's arrows. */ _handleArrowClick(event) { const that = this, previousIndex = that._currentIndex; if (that.disabled) { return; } if (that.rightToLeft) { that.$.arrowLeft.contains(event.target) ? that.next() : that.prev(); } else { that.$.arrowLeft.contains(event.target) ? that.prev() : that.next(); } that._changeEvent(previousIndex, that._currentIndex); } /** * Handles slides, set via inner HTML as LI elements. */ _handleDefaultInnerHTML() { const that = this; if (that.dataSource && that.dataSource.length > 0) { return; } if (that.$.itemsContainer.innerHTML.indexOf('<ul') >= 0) { const firstUl = that.$.itemsContainer.getElementsByTagName('ul')[0], items = firstUl.getElementsByTagName('li'); for (let i = 0; i < items.length; i++) { const slide = { HTMLcontent: items[i].innerHTML }; that.dataSource.push(slide); } } } /** * Handles indicator's state. */ _handleIndicatorsState(from, to) { const that = this; if (that.disabled || that._indicators.length === 0 || (!from && from !== 0) || (!to && to !== 0)) { return; } if (from !== to) { that._indicators[from].classList.remove('lw-active'); that._indicators[from].setAttribute('aria-selected', false); } that._indicators[to].classList.add('lw-active'); that._indicators[to].setAttribute('aria-selected', true); } /** * On '3d' mode makes clicked item active */ _handleItemClick(event) { const that = this, clickedItem = event.target.closest('.lw-carousel-item'); if (that.disabled || !clickedItem || that.displayMode !== '3d' || that.disableItemClick) { return; } const itemId = parseInt(clickedItem.getAttribute('item-id')), itemPosition = parseInt(clickedItem.getAttribute('position')); if (Math.abs(itemPosition) > 3) { return; } that._goToItem(itemId); } /** * Handles items's state. */ _handleItemsState(from, to) { const that = this; if (that.disabled || that._items.length === 0 || (!from && from !== 0) || (!to && to !== 0)) { return; } if (from !== to) { that._items[from].classList.remove('lw-active'); that._items[from].classList.add('lw-out'); } that._items[to].classList.add('lw-active'); } /** * Handles click on indicators. */ _handleIndicatorsContainerClick(event) { const that = this, clickedItem = event.target.closest('.lw-indicator'), previousIndex = that._currentIndex; if (that.disabled || !clickedItem) { return; } const itemId = parseInt(clickedItem.getAttribute('indicator-id')); if (previousIndex === itemId) { return; } that._goToItem(itemId); that._changeEvent(previousIndex, that._currentIndex); } /** * In "multiple" mode sets positions of carousel items in relation to the active slide. */ _handleMultipleMode(newIndex) { const that = this; if (that.displayMode !== 'multiple') { return; } const item = that._items[newIndex], itemWidth = item.offsetWidth, containerWidth = that.$.container.offsetWidth, itemsContainerWidth = that.$.itemsContainer.offsetWidth; let itemOffset = 0; if (newIndex === 0) { that.$.itemsContainer.style.marginLeft = '0px'; return; } else if (newIndex === (that._items.length - 1)) { that.$.itemsContainer.style.marginLeft = '-' + (itemsContainerWidth - containerWidth) + 'px'; return; } for (let i = 0; i < newIndex; i++) { itemOffset = itemOffset + that._items[newIndex].offsetWidth; } if (((itemOffset + itemWidth / 2) >= containerWidth / 2) && ((itemOffset + itemWidth) < itemsContainerWidth)) { that.$.itemsContainer.style.marginLeft = '-' + ((itemOffset + itemWidth / 2) - containerWidth / 2) + 'px'; } } /** * Fires change/changing events. */ _changeEvent(from, to) { if (from === to) { return; } const that = this; if (that.onIndexChange) { that.onIndexChange(to); return; } that.$.fireEvent('changing', { 'index': to, 'previousIndex': from }); if (!that.hasAnimation || that.displayMode === 'default') { that.$.fireEvent('change', { 'index': to, 'previousIndex': from }); } } /** * Handles keyboard navigation. */ _handleKeyDown(event) { const that = this, key = event.key, previousIndex = that._currentIndex, allowedKeys = ['ArrowLeft', 'ArrowDown', 'ArrowRight', 'ArrowUp', 'Home', 'End', ' ', 'Enter']; if (that.disabled || !that.keyboard || allowedKeys.indexOf(key) === -1) { return; } switch (key) { case 'ArrowLeft': case 'ArrowDown': that.rightToLeft ? that.next() : that.prev(); break; case 'ArrowUp': case 'ArrowRight': that.rightToLeft ? that.prev() : that.next(); break; case 'Home': that._goToItem(0); break; case 'End': that._goToItem(that.dataSource.length - 1); break; case ' ': that._rotate ? that.pause() : that.play(); break; case 'Enter': that.play(); break; } that._changeEvent(previousIndex, that._currentIndex); } /** * Allows navigation between slides via mouse wheel. */ _handleMouseWheel(event) { const that = this, previousIndex = that._currentIndex; if (that.disabled || !that.wheel || document.activeElement !== that) { return } event.stopPropagation(); event.preventDefault(); event.deltaY > 0 ? that.next() : that.prev(); that._changeEvent(previousIndex, that._currentIndex); } /** * Start/stop slideShow. */ _handleRotation(on) { const that = this; if (on) { that._rotationInterval = setInterval(function () { if (!that.slideShow) { return; } that.next(); }, that.interval); } else { clearInterval(that._rotationInterval); } } /** * Slides to next/prev slide on swipeRight/swipeLeft. */ _handleSwipe(event) { const that = this; if (that.disabled || !that.swipe) { return; } event.stopPropagation(); event.preventDefault(); event.type === 'swipeleft' ? that.prev() : that.next(); } /** * Generates single indicator item */ _generateIndicator(id) { const that = this, indicatorContainer = document.createElement('span'), indicatorId = id ? id : 0; if (that.indicatorTemplate) { const template = that._validateTemplate(that.indicatorTemplate); indicatorContainer.innerHTML = that._processItemTemplate(template.content, that.dataSource[indicatorId]) } indicatorContainer.setAttribute('role', 'tab'); indicatorContainer.setAttribute('aria-selected', false); indicatorContainer.classList.add('lw-indicator'); indicatorContainer.setAttribute('indicator-id', indicatorId); return indicatorContainer; } /** * Fills indicators container by generating multiple indicators. */ _generateIndicators() { const that = this, itemsCount = that.dataSource.length; let indicators = [], fragment = document.createDocumentFragment(); for (let i = 0; i < itemsCount; i++) { const item = that._generateIndicator(i); indicators.push(item); fragment.appendChild(item); } that._indicators = indicators; const indicatorsContainer = that.$.indicatorsContainer; while (indicatorsContainer.firstChild) { indicatorsContainer.removeChild(indicatorsContainer.firstChild); } indicatorsContainer.appendChild(fragment); } /** * Generates single slide */ _generateItem(id) { const that = this, itemId = id ? id : 0, item = that.dataSource[itemId], itemContainer = document.createElement('div'); itemContainer.id = that.id + 'Slide' + id; if (that.itemTemplate) { const template = that._validateTemplate(that.itemTemplate); itemContainer.innerHTML = that._processItemTemplate(template.content, that.dataSource[itemId]); } else { if (typeof item === 'string') { itemContainer.style.backgroundImage = 'url("' + item + '")'; } else { itemContainer.innerHTML = `<div class="lw-carousel-item-container" style="background-image:url('${item.image || ''}')" role="presentation"> <h2 id="${itemContainer.id + 'Label'}" class="lw-carousel-item-label">${item.label || ''}</h2 > <p class="lw-carousel-item-content">${item.content || ''}</p> </div> <div class="lw-carousel-html-content">${item.HTMLcontent || ''}</div> </div>`; } } if (item.label) { itemContainer.setAttribute('aria-labelledby', itemContainer.id + 'Label'); that._indicators[id].setAttribute('aria-labelledby', itemContainer.id + 'Label'); } else { itemContainer.setAttribute('aria-label', 'Slide ' + id); that._indicators[id].setAttribute('aria-label', 'Slide ' + id); } that._indicators[id].setAttribute('aria-controls', itemContainer.id); itemContainer.setAttribute('role', 'tabpanel'); itemContainer.classList.add('lw-carousel-item'); itemContainer.setAttribute('item-id', itemId); return itemContainer; } /** * Binds template and data source item */ _processItemTemplate(template, dataSource) { const regex = /{{\w+}}/g, bindings = template.match(regex); let processedTemplate = template; if (!bindings || bindings.length === 0) { return processedTemplate; } bindings.forEach(function (binding) { const propertyName = binding.replace('{{', '').replace('}}', ''); processedTemplate = processedTemplate.replace(binding, (dataSource[propertyName] || '')); }); return processedTemplate; } /** * Fills slides container by generating multiple items. */ _generateItems() { const that = this, itemsCount = that.dataSource.length; let items = [], fragment = document.createDocumentFragment(); for (let i = 0; i < itemsCount; i++) { const item = that._generateItem(i); items.push(item); fragment.appendChild(item); } that._items = items; const itemsContainer = that.$.itemsContainer; while (itemsContainer.firstChild) { itemsContainer.removeChild(itemsContainer.firstChild); } itemsContainer.appendChild(fragment); } /** * Moves slides to an item with particular index. */ _goToItem(index, fireEvent) { const that = this, itemsCount = that.dataSource.length, oldIndex = that._currentIndex; let newIndex = index; if (index < 0) { newIndex = 0; } else if (index > (itemsCount - 1)) { newIndex = itemsCount - 1 } that._removeFadeOut(); that._animationTrigger(); that._handleIndicatorsState(oldIndex, newIndex); that._handleItemsState(oldIndex, newIndex); that._currentIndex = newIndex; fireEvent && that._changeEvent(oldIndex, newIndex); that._handle3dMode(newIndex); that._handleMultipleMode(newIndex); that._handleArrowsActiveState(newIndex, oldIndex); } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); that.tabIndex = -1; return; } let index = that.tabIndex > 0 ? that.tabIndex : 0; that.setAttribute('tabindex', index); that.tabIndex = index; } /** * Sets initial values to inner variables, used in latest stage. */ _setInitialState() { const that = this; that._currentIndex = 0; that._indicators = []; that._items = []; that._rotate = false; that._handleDefaultInnerHTML(); } /** * Sets initial values to inner variables, used in latest stage. */ _validateTemplate(template) { const that = this; let templateContent = '', hasBindings = false, regex = /{{\w+}}/g; if (typeof template === 'function') { templateContent = template(); } if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); that.itemTemplate = null; return; } if (template instanceof HTMLElement) { templateContent = template.innerHTML; } else { template = document.getElementById(template); templateContent = template ? template.innerHTML : ''; } if (regex.exec(templateContent)) { hasBindings = true; } return { content: templateContent, hasBindings: hasBindings }; } /** * Detect animation end and updates animated item's class list */ _handleTransitionEnd(event) { if (!event.target.classList.contains('lw-carousel-item') || event.target.getAttribute('position')) { return; } const that = this, currentTransitionEndId = event.target.getAttribute('item-id'); if (that._lastTransitionEndId === currentTransitionEndId) { return; } that._removeFadeOut(); this.$.fireEvent('change', { 'index': currentTransitionEndId, 'previousIndex': that._lastTransitionEndId }); that._lastTransitionEndId = currentTransitionEndId; } /** * Removes the class related to items fade out effect */ _removeFadeOut() { const that = this, fadeOutItems = that.$.itemsContainer.getElementsByClassName('lw-out'); if (fadeOutItems.length) { for (let i = 0; i < fadeOutItems.length; i++) { fadeOutItems[i].classList.remove('lw-out'); } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Chip item custom element. */ LW('lw-chip', class Chip extends LW.ContentElement { // Chip item's properties. static get properties() { return { 'avatar': { value: null, type: 'string?' }, 'closeButton': { value: false, type: 'boolean' }, 'itemTemplate': { value: null, type: 'any?', reflectToAttribute: false }, 'value': { value: '', type: 'string' } }; } /** * Chip item's event listeners. */ static get listeners() { return { 'click': '_clickHandler', 'keydown': '_keyDownHandler' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.chip.css' ] } /** * Chip's HTML template. */ template() { return `<div id="container" role="presentation"> <span id="avatar" class="lw-avatar">[[avatar]]</span><!-- --><span id="value" class="lw-value" inner-h-t-m-l="[[innerHTML]]"><content></content></span><!-- --><span id="closeButton" class="lw-close-button" role="button" aria-label="Close"></span> </div>`; } /** * Updates the Chip when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'avatar': that.itemTemplate ? that._setAvatar(that._customAvatar) : that._setAvatar(that.$.avatar); break; case 'itemTemplate': that._applyTemplate(); break; case 'value': if (that.itemTemplate) { that._applyTemplate(); } else { that.$.value.innerHTML = newValue || ''; } break; } } render() { const that = this; that.value = that.value ? that.value : that.innerHTML; that._applyTemplate(); that._setFocusable(); super.render(); } close() { const that = this; that.$.fireEvent('close', { 'value': that.value }); that.parentElement.removeChild(that); } _applyTemplate() { const that = this; let template = that.itemTemplate; if (!template) { that.$.value.innerHTML = that.value; that._setAvatar(that.$.avatar); return; } if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } if (!(template instanceof HTMLTemplateElement)) { template = document.getElementById(template); } if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase() })); return; } let templateContent = template.innerHTML; that.$.container.innerHTML = templateContent.replace(/{{\s*value\s*}}/g, that.value); that._customAvatar = that.$.container.querySelector('.lw-avatar'); that._setAvatar(that._customAvatar); } _clickHandler(event) { const that = this; if (that.disabled) { return; } const target = that.enableShadowDOM ? that.shadowRoot.elementFromPoint(event.pageX, event.pageY) : event.target; if (!target.closest || !target.closest('.lw-close-button')) { return; } that.close(); } /** * KeyDown handler. */ _keyDownHandler(event) { const that = this; let key = event.key; if (that.disabled || that.readonly || key !== 'Delete') { return; } that.close(); } _setAvatar(element) { if (!element) { return; } const that = this, isAvatarImage = (/\.(gif|jpg|jpeg|tiff|png)$/i).test(that.avatar); element.innerHTML = isAvatarImage ? `<img src="${that.avatar}" aria-label="${that.value ? 'Avatar of ' + that.value : 'Avatar'}" />` : (that.avatar || ''); } /** * Set tabIndex. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); return; } that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * DateTimePicker custom element. */ LW('lw-date-time-picker', class DateTimePicker extends LW.BaseElement { /** * DateTimePicker's properties. */ static get properties() { return { 'animationSettings': { value: null, type: 'object' }, 'autoClose': { value: false, type: 'boolean' }, 'autoCloseDelay': { value: 0, type: 'number' }, 'calendarButton': { value: false, type: 'boolean' }, 'calendarButtonPosition': { value: 'right', allowedValues: ['left', 'right'], type: 'string' }, 'calendarMode': { value: 'default', allowedValues: ['default', 'classic'], type: 'string' }, 'dayNameFormat': { value: 'firstTwoLetters', allowedValues: ['narrow', 'firstTwoLetters', 'long', 'short'], type: 'string' }, 'disableAutoNavigation': { value: false, type: 'boolean' }, 'displayKind': { value: 'unspecified', allowedValues: ['UTC', 'local', 'unspecified'], type: 'string' }, 'displayModeView': { value: 'table', allowedValues: ['table', 'list'], type: 'string' }, 'displayMode': { allowedValues: ['outlined', 'filled', 'underlined'], value: 'outlined', type: 'string' }, 'dropDownAppendTo': { value: null, type: 'any' }, 'dropDownDisplayMode': { value: 'default', allowedValues: ['default', 'classic', 'calendar', 'timePicker', 'auto'], type: 'string' }, 'dropDownOverlay': { value: false, type: 'boolean' }, 'dropDownPosition': { value: 'auto', allowedValues: ['auto', 'bottom', 'overlay-top', 'overlay-center', 'overlay-bottom', 'top', 'center-bottom', 'center-top'], type: 'string' }, 'editMode': { value: 'default', allowedValues: ['default', 'full', 'partial'], type: 'string' }, 'enableMouseWheelAction': { value: false, type: 'boolean' }, 'firstDayOfWeek': { value: 0, type: 'number' }, 'footerTemplate': { value: null, type: 'any' }, 'formatString': { value: 'dd-MMM-yy HH:mm:ss.fff', type: 'string' }, 'headerTemplate': { value: null, type: 'any' }, 'hideDayNames': { value: false, type: 'boolean' }, 'hideOtherMonthDays': { value: false, type: 'boolean' }, 'hideTooltipArrow': { value: false, type: 'boolean' }, 'hint': { value: '', type: 'string' }, 'importantDates': { value: [], type: 'array' }, 'importantDatesTemplate': { value: null, type: 'any' }, 'interval': { value: new LW.Utilities.TimeSpan(0, 0, 1), type: 'any' }, 'label': { value: '', type: 'string' }, 'max': { value: new LW.Utilities.DateTime(3001, 1, 1), type: 'any' }, 'messages': { value: { 'en': { 'now': 'Now', 'dateTabLabel': 'DATE', 'timeTabLabel': 'TIME' } }, type: 'object', extend: true }, 'min': { value: new LW.Utilities.DateTime(1600, 1, 1), type: 'any' }, 'name': { value: '', type: 'string' }, 'nullable': { value: false, type: 'boolean' }, 'opened': { value: false, type: 'boolean' }, 'placeholder': { value: 'Enter date', type: 'string' }, 'restrictedDates': { value: [], type: 'array' }, 'spinButtons': { value: false, type: 'boolean' }, 'spinButtonsDelay': { value: 75, type: 'number' }, 'spinButtonsInitialDelay': { value: 0, type: 'number' }, 'spinButtonsPosition': { value: 'right', allowedValues: ['left', 'right'], type: 'string' }, 'tooltip': { value: false, type: 'boolean' }, 'tooltipDelay': { value: 100, type: 'number' }, 'tooltipPosition': { value: 'top', allowedValues: ['bottom', 'top', 'left', 'right', 'absolute'], type: 'string' }, 'tooltipTemplate': { value: null, type: 'any' }, 'validation': { value: 'strict', allowedValues: ['strict', 'interaction'], type: 'string' }, 'value': { defaultReflectToAttribute: true, value: new LW.Utilities.DateTime(), type: 'any' }, 'weekNumbers': { value: false, type: 'boolean' }, 'weeks': { value: 6, type: 'number' }, 'yearCutoff': { value: 1926, type: 'number' } }; } /** * DateTimePicker's event listeners. */ static get listeners() { return { 'container.mouseout': '_mouseoutHandler', 'container.mouseover': '_mouseoverHandler', 'calendarButton.click': '_calendarButtonClickHandler', 'calendarDropDown.change': '_calendarDropDownChangeHandler', 'calendarDropDown.click': '_calendarDropDownClickHandler', 'downButton.click': '_spinButtonsClickHandler', 'input.blur': '_inputBlurHandler', 'input.change': '_inputChangeHandler', 'input.dragstart': '_inputDragstartHandler', 'input.focus': '_inputFocusHandler', 'input.keydown': '_inputKeydownHandler', 'input.down': '_inputDownHandler', 'input.paste': '_inputPasteHandler', 'input.select': '_inputSelectHandler', 'input.up': '_inputUpHandler', 'input.wheel': '_inputWheelHandler', 'dropDownContainer.keydown': '_dropDownKeydownHandler', 'dropDownContainer.transitionend': '_dropDownTransitionendHandler', 'dropDownHeader.click': '_dropDownHeaderClickHandler', 'upButton.click': '_spinButtonsClickHandler', 'document.up': '_documentUpHandler' }; } /** * DateTimePicker's required files. */ static get requires() { return { 'LW.Utilities.DateTime': 'lw.date.js', 'LW.Utilities.Draw': 'lw.draw.js', 'LW.Utilities.BigNumber': 'lw.math.js', 'LW.Utilities.NumericProcessor': 'lw.numeric.js', 'LW.RepeatButton': 'lw.button.js', 'LW.Calendar': 'lw.calendar.js', 'LW.TimePicker': 'lw.timepicker.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.datetimepicker.css' ] } /** * DateTimePicker's HTML template. */ template() { return `<div id="container" role="presentation"> <span id="label" class="lw-label">[[label]]</span> <div id="content" class="lw-content"> <input id="input" class="lw-input lw-date-time-input" type="text" readonly="[[readonly]]" disabled="[[disabled]]" placeholder="[[placeholder]]" name="[[name]]" aria-label="[[placeholder]]" /> <div id="spinButtonsContainer" class="lw-spin-buttons-container" role="presentation"> <lw-repeat-button initial-delay="[[spinButtonsInitialDelay]]" animation="[[animation]]" delay="[[spinButtonsDelay]]" readonly="[[readonly]]" unfocusable id="upButton" right-to-left="[[rightToLeft]]" class="lw-spin-button" aria-label="Increment"> <div class="lw-arrow lw-arrow-up" aria-hidden="true"></div> </lw-repeat-button> <lw-repeat-button initial-delay="[[spinButtonsInitialDelay]]" animation="[[animation]]" delay="[[spinButtonsDelay]]" readonly="[[readonly]]" unfocusable id="downButton" right-to-left="[[rightToLeft]]" class="lw-spin-button" aria-label="Decrement"> <div class="lw-arrow lw-arrow-down" aria-hidden="true"></div> </lw-repeat-button> </div> <div id="calendarButton" class="lw-drop-down-button lw-calendar-button" role="button" aria-haspopup="dialog" aria-label="Toggle popup"></div> <div id="dropDownContainer" class="lw-drop-down lw-date-time-drop-down lw-drop-down-container lw-visibility-hidden" role="dialog"> <div id="dropDownHeader" class="lw-drop-down-header lw-hidden" role="heading" aria-level="1"> <div id="selectDate" class="lw-selected" role="button"></div> <div id="selectTime" role="button"></div> </div> <div id="dropDownContent" class="lw-drop-down-content" role="presentation"> <lw-calendar id="calendarDropDown" class="lw-hidden" animation="[[animation]]" animation-settings="[[animationSettings]]" calendar-mode="[[calendarMode]]" day-name-format="[[dayNameFormat]]" disable-auto-navigation="[[disableAutoNavigation]]" display-mode-view="[[displayModeView]]" first-day-of-week="[[firstDayOfWeek]]" header-template="[[headerTemplate]]" hide-day-names="[[hideDayNames]]" hide-other-month-days="[[hideOtherMonthDays]]" hide-tooltip-arrow="[[hideTooltipArrow]]" important-dates="[[importantDates]]" important-dates-template="[[importantDatesTemplate]]" locale="[[locale]]" right-to-left="[[rightToLeft]]" selection-mode="one" spin-buttons-delay="[[spinButtonsDelay]]" spin-buttons-initial-delay="[[spinButtonsInitialDelay]]" theme="[[theme]]" tooltip="[[tooltip]]" tooltip-delay="[[tooltipDelay]]" tooltip-position="[[tooltipPosition]]" tooltip-template="[[tooltipTemplate]]" unfocusable="[[unfocusable]]" view-sections='["header", "footer"]' week-numbers="[[weekNumbers]]" weeks="[[weeks]]"></lw-calendar> </div> </div> </div> <span id="hint" class="lw-hint lw-hidden">[[hint]]</span> </div>`; } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted) { return; } if (that._defaultFooterTemplateApplied) { that._addCalendarFooterListeners(); } if (that.$.timePickerDropDown) { that._addTimePickerListener(); } if (that._positionDetection) { that._positionDetection.dropDownAttached(); } } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); that.close(); if (that._defaultFooterTemplateApplied) { const footer = that.$.calendarDropDown.$footer; footer.unlisten('change'); footer.unlisten('click'); footer.unlisten('wheel'); } if (that.$.timePickerDropDown) { that.$.timePickerDropDown.$.unlisten('change'); } if (that._positionDetection) { that._positionDetection.dropDownDetached(); } } /** * Called when the element is ready. Used for one-time configuration of the DateTimePicker. */ ready() { super.ready(); const that = this; that._edgeMacFF = LW.Utilities.Core.Browser.Edge || LW.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1; that._iOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform); if (that._edgeMacFF) { that.$dropDownContainer.addClass('not-in-view'); } that._defaultFooterTemplate = document.createElement('template'); that._defaultFooterTemplate.innerHTML = `<div class="lw-date-time-picker-footer"> <div class="lw-footer-component lw-footer-component-hour" role="presentation"> <input type="text" class="lw-hour-element" aria-label="Hours" /> <span role="presentation"> <lw-repeat-button initial-delay="0" delay="75" aria-label="Increment hours"> <span class="lw-arrow lw-arrow-up" aria-hidden="true"></span> </lw-repeat-button> <lw-repeat-button initial-delay="0" delay="75" aria-label="Decrement hours"> <span class="lw-arrow lw-arrow-down" aria-hidden="true"></span> </lw-repeat-button> </span> </div> <div class="lw-footer-component lw-footer-component-minute" role="presentation"> <input class="lw-minute-element" aria-label="Minutes" /> <span role="presentation"> <lw-repeat-button initial-delay="0" delay="75" aria-label="Increment minutes"> <span class="lw-arrow lw-arrow-up" aria-hidden="true"></span> </lw-repeat-button> <lw-repeat-button initial-delay="0" delay="75" aria-label="Decrement minutes"> <span class="lw-arrow lw-arrow-down" aria-hidden="true"></span> </lw-repeat-button> </span> </div> <div class="lw-footer-component lw-footer-component-ampm" role="presentation"> <input type="text" class="lw-am-pm-element" aria-label="AM/PM" /> </div> <div class="lw-footer-component lw-footer-component-today" role="presentation"> <div tabindex="-1" class="lw-today-element" role="button" aria-label="Now"></div> </div> </div>`; that._codeToMethod = { 'y': 'addYears', 'yy': 'addYears', 'yyyy': 'addYears', 'yyyyy': 'addYears', 'M': 'addMonths', 'MM': 'addMonths', 'MMM': 'addMonths', 'MMMM': 'addMonths', 'd': 'addDays', 'dd': 'addDays', 'ddd': 'addDays', 'dddd': 'addDays', 'H': 'addHours', 'HH': 'addHours', 'h': 'addHours', 'hh': 'addHours', 'm': 'addMinutes', 'mm': 'addMinutes', 's': 'addSeconds', 'ss': 'addSeconds', 'f': 'addDeciseconds', 'ff': 'addCentiseconds', 'fff': 'addMilliseconds', 'u': 'addMicroseconds', 'uu': 'addMicroseconds', 'n': 'addNanoseconds', 'nn': 'addNanoseconds', 'p': 'addPicoseconds', 'pp': 'addPicoseconds', 'e': 'addFemtoseconds', 'ee': 'addFemtoseconds', 'a': 'addAttoseconds', 'aa': 'addAttoseconds', 'x': 'addZeptoseconds', 'xx': 'addZeptoseconds', 'o': 'addYoctoseconds', 'oo': 'addYoctoseconds' }; that._codeToIndex = { 'y': 0, 'yy': 0, 'yyyy': 0, 'yyyyy': 0, 'M': 1, 'MM': 1, 'MMM': 1, 'MMMM': 1, 'd': 2, 'dd': 2, 'ddd': 2, 'dddd': 2, 'H': 3, 'HH': 3, 'h': 3, 'hh': 3, 'm': 4, 'mm': 4, 's': 5, 'ss': 5, 'f': 6, 'ff': 6, 'fff': 6, 'u': 7, 'uu': 7, 'n': 8, 'nn': 8, 'p': 9, 'pp': 9, 'e': 10, 'ee': 10, 'a': 11, 'aa': 11, 'x': 12, 'xx': 12, 'o': 13, 'oo': 13 }; that._getLocalizedNames(); that.checkLicense(); } render() { const that = this; if (that.rightToLeft) { that.calendarButtonPosition = that.calendarButtonPosition === 'right' ? 'left' : 'right'; } that._positionDetection = new LW.Utilities.PositionDetection(that, that.$.dropDownContainer, that.$.content, 'close'); that._positionDetection.customPositionDropDown = that._positionExternalDropDown; that._positionDetection.getDropDownParent(true); that._positionDetection.setDropDownPosition(); that.$.dropDownContainer.style.left = null; that._positionDetection.handleAutoPositioning(); that._setIds(); that._validateInitialPropertyValues(); that._setFocusable(); that.setAttribute('role', 'presentation'); that.$.input.setAttribute('aria-describedby', that.$.hint.id); that.$.input.setAttribute('aria-labelledby', that.$.label.id); that.$.calendarButton.setAttribute('aria-owns', that.$.dropDownContainer.id); that.$.dropDownContainer.setAttribute('animation', that.animation); that.$.dropDownContainer.setAttribute('drop-down-display-mode', that.dropDownDisplayMode); if (!that.hint) { that.hint = that.placeholder; } super.render(); that.isInitialized = true; } /** * Closes the calendar dropdown. */ close() { const that = this; if (!that.opened) { return; } that._close(); } /** * Focuses the input. */ focus() { this.$.input.focus(); } select() { this.$.input.select(); } /** * Opens the calendar dropdown. */ open() { const that = this; if (that.opened) { return; } that._open(); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'animation': case 'theme': if (that.$.timePickerDropDown) { that.$.timePickerDropDown[propertyName] = newValue; } if (propertyName === 'animation') { that.$.dropDownContainer.setAttribute('animation', that.animation); if (that._defaultFooterTemplateApplied) { Array.from(that.$.calendarDropDown.$.footer.getElementsByTagName('lw-repeat-button')).forEach(function (button) { button.animation = newValue; }); } } break; case 'calendarButton': that.$.dropDownContainer.style.transition = 'none'; if (!newValue) { that.close(); } break; case 'calendarButtonPosition': that.$.dropDownContainer.style.transition = 'none'; that.close(); if (newValue === 'left') { that.$.content.insertBefore(that.$.calendarButton, that.$.content.firstElementChild); } else if (that._dropDownParent === null) { that.$.content.insertBefore(that.$.calendarButton, that.$.dropDownContainer); } else { that.$.content.appendChild(that.$.calendarButton); } break; case 'disabled': if (newValue) { that.close(); that.$.upButton.disabled = true; that.$.downButton.disabled = true; } else { that._disableSpinButtons(); } that._setFocusable(); that._positionDetection.handleAutoPositioning(); break; case 'displayKind': { const oldOutputTimeZone = that._outputTimeZone; switch (newValue) { case 'unspecified': that._outputTimeZone = that._inputTimeZone; break; case 'UTC': that._outputTimeZone = 'UTC'; break; case 'local': that._outputTimeZone = 'Local'; break; } if (that._outputTimeZone === oldOutputTimeZone) { return; } if (that._value !== null) { that.close(); that._toSync = true; that._value = that._value.toTimeZone(that._outputTimeZone); that._applyFormatString(); } that.min = that.min.toTimeZone(that._outputTimeZone); that.max = that.max.toTimeZone(that._outputTimeZone); for (let i = 0; i < that.restrictedDates.length; i++) { let currentRestrictedDate = that.restrictedDates[i]; currentRestrictedDate = currentRestrictedDate.toTimeZone(that._outputTimeZone); } break; } case 'dropDownAppendTo': that._positionDetection.dropDownAppendToChangedHandler(); break; case 'dropDownDisplayMode': that._changeDropDownDisplayMode(); break; case 'dropDownOverlay': if (!newValue) { that._positionDetection.removeOverlay(); } break; case 'dropDownPosition': that._positionDetection.dropDownPositionChangedHandler(); break; case 'footerTemplate': if (newValue !== null) { that._defaultFooterTemplateApplied = false; const footer = that.$.calendarDropDown.$footer; footer.unlisten('change'); footer.unlisten('click'); footer.unlisten('wheel'); that.$.calendarDropDown.footerTemplate = newValue; } else { that._setDefaultFooterTemplate(); const value = that._value; that._hourElement.value = value.toString('hh'); that._minuteElement.value = value.toString('mm'); that._ampmElement.value = value.toString('tt'); } break; case 'formatString': if (newValue === '') { that.formatString = 'dd-MMM-yy HH:mm:ss.fff'; } that._getFormatStringRegExp(); that._applyFormatString(); if (that.dropDownDisplayMode === 'auto') { that._changeDropDownDisplayMode(); } break; case 'interval': that._validateInterval(oldValue); break; case 'locale': case 'messages': that.$.selectDate.innerHTML = that.localize('dateTabLabel'); that.$.selectTime.innerHTML = that.localize('timeTabLabel'); if (that._defaultFooterTemplateApplied) { that._todayElement.title = that.localize('now'); } if (propertyName === 'messages') { return; } that._getLocalizedNames(); that.min.calendar.days = that._localizedDays; that.min.calendar.months = that._localizedMonths; that.min.calendar.locale = that.locale; that.max.calendar.days = that._localizedDays; that.max.calendar.months = that._localizedMonths; that.max.calendar.locale = that.locale; if (that.value !== null) { that._value.calendar.days = that._localizedDays; that._value.calendar.months = that._localizedMonths; that._value.calendar.locale = that.locale; that.value.calendar.days = that._localizedDays; that.value.calendar.months = that._localizedMonths; that.value.calendar.locale = that.locale; } LW.Utilities.DateTime.cache = []; that._applyFormatString(); break; case 'max': case 'min': that._validateMinMax(propertyName, oldValue); if (that.validation === 'strict') { that._validateValue(); } else { that._minMaxChanged = true; } break; case 'nullable': if (oldValue === true && that._value === null) { that._validateValue(that._now(), null); } break; case 'opened': if (newValue) { that._open(); } else { that._close(); } break; case 'readonly': case 'unfocusable': if (newValue) { that.close(); } if (propertyName === 'unfocusable') { that._setFocusable(); } break; case 'restrictedDates': that._validateRestrictedDates(); that._validateValue(); break; case 'spinButtonsPosition': if (newValue === 'right') { that.$.content.insertBefore(that.$.spinButtonsContainer, that.$.input.nextElementSibling); } else { that.$.content.insertBefore(that.$.spinButtonsContainer, that.$.input); } break; case 'validation': if (newValue === 'strict') { delete that._minMaxChanged; that._validateValue(); } break; case 'value': { let parsedValue; if (newValue !== null) { parsedValue = LW.Utilities.DateTime.validateDate(newValue, that._now(), that.formatString); parsedValue = parsedValue.toTimeZone(that._outputTimeZone); } else { parsedValue = null; } that._validateValue(parsedValue, that._value, undefined, true); break; } } } /** * Adds calendar footer listeners. */ _addCalendarFooterListeners() { const that = this, footer = that.$.calendarDropDown.$footer; footer.listen('change', that._footerChangeHandler.bind(that)); footer.listen('click', that._footerClickHandler.bind(that)); footer.listen('wheel', that._footerWheelHandler.bind(that)); } /** * Adds time picker change event listener. */ _addTimePickerListener() { const that = this; that.$.timePickerDropDown.$.listen('change', function (event) { const oldContext = that.context, newTimePickerValue = event.detail.value, updatedValueConstructorParameters = LW.Utilities.DateTime.getConstructorParameters(that._value !== null ? that._value : that._now()); that.context = that; updatedValueConstructorParameters[3] = newTimePickerValue.getHours(); updatedValueConstructorParameters[4] = newTimePickerValue.getMinutes(); that._timePickerInitiatedChange = true; updatedValueConstructorParameters.unshift(null); that._validateValue(new (Function.prototype.bind.apply(LW.Utilities.DateTime, updatedValueConstructorParameters))); that._timePickerInitiatedChange = false; that.context = oldContext; }); } /** * Applies format string. */ _applyFormatString() { const that = this; if (that.value !== null) { that.$.input.value = that._value.toString(that.formatString); } } _calendarButtonMouseEnterHandler() { const that = this; that.$.calendarButton.setAttribute('hover', ''); } _calendarButtonMouseLeaveHandler() { const that = this; that.$.calendarButton.removeAttribute('hover'); } /** * Calendar button click handler. */ _calendarButtonClickHandler(event) { const that = this; that._highlightedTimePart = undefined; if (that.disabled || that.readonly) { return; } if (that.hasRippleAnimation) { LW.Utilities.Animation.Ripple.animate(that.$.calendarButton, event.pageX, event.pageY); } if (that.opened) { that._close(); } else { that._open(); } } /** * Calendar dropdown change handler. */ _calendarDropDownChangeHandler(event) { const that = this; event.stopPropagation(); if (that._disregardCalendarChangeEvent) { that._disregardCalendarChangeEvent = false; return; } if (this.$.calendarDropDown.selectedDates.length > 0) { const newCalendarValue = event.detail.value[0], oldValue = that._value !== null ? that._value : that._now(), updatedValueConstructorParameters = LW.Utilities.DateTime.getConstructorParameters(oldValue); updatedValueConstructorParameters[0] = newCalendarValue.getFullYear(); updatedValueConstructorParameters[1] = newCalendarValue.getMonth() + 1; updatedValueConstructorParameters[2] = newCalendarValue.getDate(); that._calendarInitiatedChange = true; updatedValueConstructorParameters.unshift(null); that._validateValue(new (Function.prototype.bind.apply(LW.Utilities.DateTime, updatedValueConstructorParameters))); if (that._defaultFooterTemplateApplied) { const value = that._value; if (that._hourElement.value === '') { that._hourElement.value = value.toString('hh'); } if (that._ampmElement.value === '') { that._ampmElement.value = value.toString('tt'); } if (that._minuteElement.value === '') { that._minuteElement.value = value.toString('mm'); } } that._calendarInitiatedChange = false; } else { that._setNullValue(); } } /** * Calendar dropdown click handler. */ _calendarDropDownClickHandler(event) { const that = this; if (that.autoClose && event.target.closest('.lw-calendar-cell')) { clearTimeout(that._autoCloseTimeout); that._autoCloseTimeout = setTimeout(function () { that.close(); }, that.autoCloseDelay); } } /** * Changes dropdown display mode. */ _changeDropDownDisplayMode() { function toggleVisibility(dropDownHeader, calendarDropDown, timePickerDropDown, sync) { that.$dropDownHeader[dropDownHeader]('lw-hidden'); that.$calendarDropDown[calendarDropDown]('lw-hidden'); if (that._timePickerInitialized) { that.$.timePickerDropDown.$[timePickerDropDown]('lw-hidden'); } if (sync) { if (that.opened) { that.$.calendarDropDown._refreshTitle(); } else { that._toSync = true; } } } const that = this, oldDropDownDisplayMode = that._dropDownDisplayMode; that._detectDisplayMode(); if (that._dropDownDisplayMode === oldDropDownDisplayMode) { return; } if (that._dropDownDisplayMode === 'default') { that.calendarMode = 'default'; that.$.calendarDropDown.viewSections = ['title', 'header']; that.$selectDate.addClass('lw-selected'); that.$selectTime.removeClass('lw-selected'); toggleVisibility('removeClass', 'removeClass', 'addClass', true); } else if (that._dropDownDisplayMode === 'classic') { that.calendarMode = 'classic'; that.$.calendarDropDown.viewSections = ['header', 'footer']; toggleVisibility('addClass', 'removeClass', 'addClass'); } else if (that._dropDownDisplayMode === 'calendar') { that.calendarMode = 'default'; that.$.calendarDropDown.viewSections = ['title', 'header']; toggleVisibility('addClass', 'removeClass', 'addClass', true); } else { that.calendarMode = 'default'; toggleVisibility('addClass', 'addClass', 'removeClass'); if (!that._timePickerInitialized) { that._initializeTimePicker(); } } that.$.dropDownContainer.setAttribute('drop-down-display-mode', that.dropDownDisplayMode); } /** * Clones the value object. */ _cloneValue() { const that = this; if (that._value !== null) { return that._value.clone(); } else { return null; } } /** * Closes the calendar dropdown. */ _close() { const that = this, closingEvent = that.$.fireEvent('closing'); if (!closingEvent.defaultPrevented) { that.$.calendarDropDown.disabled = true; that.$calendarButton.removeClass('lw-calendar-button-pressed'); that.$.calendarButton.removeAttribute('active'); that.$dropDownContainer.addClass('lw-visibility-hidden'); const hoveredCalendarCell = that.$.calendarDropDown.$.container.querySelector('.lw-calendar-cell[hover]'); if (hoveredCalendarCell) { hoveredCalendarCell.removeAttribute('hover'); } that.opened = false; that._positionDetection.removeOverlay(true); that.$.fireEvent('close'); if (that._edgeMacFF && !that.hasAnimation) { that.$.dropDownContainer.style.top = null; that.$.dropDownContainer.style.left = null; that.$dropDownContainer.addClass('not-in-view'); } } else { that.opened = true; } that.$.calendarButton.setAttribute('aria-expanded', that.opened); } /** * Detects dropdown display mode. */ _detectDisplayMode() { const that = this; if (that.dropDownDisplayMode !== 'auto') { that._dropDownDisplayMode = that.dropDownDisplayMode; } else { that._dropDownDisplayMode = LW.Utilities.DateTime.detectDisplayMode(that.value || that.min, that.formatString, that._formatStringRegExp); } if (that._dropDownDisplayMode === 'timePicker') { that.$calendarButton.addClass('time'); if (that.placeholder === 'Enter date') { that.placeholder = 'Enter time'; } } else { that.$calendarButton.removeClass('time'); if (that.placeholder === 'Enter time') { that.placeholder = 'Enter date'; } } if (that._dropDownDisplayMode === 'default') { that.$dropDownContent.removeClass('partial'); } else { that.$dropDownContent.addClass('partial'); } } /** * Disables or enables spin buttons. */ _disableSpinButtons() { const that = this; if (that.disabled) { return; } const disabled = that._value === null; that.$.upButton.disabled = disabled; that.$.downButton.disabled = disabled; } /** * Document up handler. */ _documentUpHandler(event) { const that = this, activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement, target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (!LW.Utilities.Core.isMobile && activeElement === that.$.input && that.editMode === 'partial' && that._value !== null && (target !== that.$.input || that.$.input.selectionStart === that.$.input.selectionEnd)) { that._highlightedTimePartEdit = false; that._validateValue(that.$.input.value, that._cloneValue(), false); that._highlightTimePartBasedOnCursor(); } else { if (target !== that.$.calendarButton && (!that.$.dropDownContainer.contains(target) && !that.$.dropDownContainer.contains(that._getRootShadowHost(target)))) { that.close(); if (activeElement !== that.$.input && !that.contains(target)) { that._highlightedTimePart = undefined; } } } that._mouseFocus = false; } /** * Returns the root node of an element inside the shadowDOM of a child element * @param {any} target */ _getRootShadowHost(target) { const that = this; if (!that.shadowRoot && !that.isInShadowDOM) { return; } let host = target.getRootNode().host, rootHost; while (host && host !== that && host !== document) { rootHost = host; host = host.getRootNode().host; } return rootHost; } /** * Dropdown header click handler */ _dropDownHeaderClickHandler(event) { const that = this; if (event.target === that.$.selectDate) { if (that.$selectDate.hasClass('lw-selected')) { return; } that.$selectDate.addClass('lw-selected'); that.$selectTime.removeClass('lw-selected'); that.$.timePickerDropDown.$.addClass('lw-hidden'); that.$calendarDropDown.removeClass('lw-hidden'); } else { if (that.$selectTime.hasClass('lw-selected')) { return; } that.$selectDate.removeClass('lw-selected'); that.$selectTime.addClass('lw-selected'); that.$calendarDropDown.addClass('lw-hidden'); if (that._timePickerInitialized) { that.$.timePickerDropDown.$.removeClass('lw-hidden'); } else { that._initializeTimePicker(); } } } /** * Dropdown keydown handler. */ _dropDownKeydownHandler(event) { const that = this, key = event.key, activeElement = that.shadowRoot ? that.shadowRoot.activeElement : document.activeElement; if (that.$.dropDownHeader.contains(activeElement) && (key === 'Enter' || key === ' ')) { event.preventDefault(); that._dropDownHeaderClickHandler({ target: activeElement }); } else if (key === 'Escape' || event.altKey && key === 'ArrowUp') { event.preventDefault(); that.close(); that.$.input.focus(); } else if ((key === 'Enter' || key === ' ') && activeElement.classList.contains('lw-footer-component-today')) { event.preventDefault(); that._validateValue(that._now()); that.close(); } else if (key === 'Enter' && (activeElement === that.$.calendarDropDown.$.body && that.$.calendarDropDown.querySelectorAll('.lw-calendar-cell[selected][focus]').length > 0 || that._timePickerInitialized && activeElement === that.$.timePickerDropDown.$.picker)) { event.preventDefault(); that.close(); } } /** * Dropdown transitionend handler. */ _dropDownTransitionendHandler() { const that = this; if (!that.hasAnimation) { return; } if (that.opened && that._toFocus) { that._toFocus.focus(); delete that._toFocus; if (that._timePickerInitialized && !that.$.timePickerDropDown.classList.contains('lw-hidden')) { requestAnimationFrame(() => that.$.timePickerDropDown._highlightLabel()); } return; } if (that._edgeMacFF && !that.opened) { that.$.dropDownContainer.style.top = null; that.$.dropDownContainer.style.left = null; that.$dropDownContainer.addClass('not-in-view'); return; } } /** * Footer change handler. */ _footerChangeHandler(event) { const that = this, oldContext = that.context, target = event.target, dateTimePickerValue = that._value !== null ? that._value : that._now(); let value = target.value, timePartCode; that.context = that; event.stopPropagation(); if (target.classList.contains('lw-hour-element')) { value = parseInt(value, 10); if (isNaN(value) || value < 0 || value > 12) { target.value = dateTimePickerValue.toString('hh'); return; } if (value > 0 && value < 12 && dateTimePickerValue.toString('tt') === 'PM') { value += 12; } timePartCode = 'hh'; } else if (target.classList.contains('lw-minute-element')) { value = parseInt(value, 10); if (isNaN(value) || value < 0 || value > 59) { target.value = dateTimePickerValue.toString('mm'); return; } timePartCode = 'mm'; } else { if (that._value === null) { target.value = ''; return; } const oldValue = dateTimePickerValue.toString('tt'); value = value.toLowerCase(); if ((oldValue === 'PM' && (value === 'a' || value === 'am')) || (oldValue === 'AM' && (value === 'p' || value === 'pm'))) { that._incrementDecrement(undefined, 'tt'); target.value = that._value.toString('tt'); } else { target.value = oldValue; } return; } const newValueConstructorParameters = LW.Utilities.DateTime.getConstructorParameters(dateTimePickerValue); newValueConstructorParameters[that._codeToIndex[timePartCode]] = value; newValueConstructorParameters.unshift(null); that._validateValue(new (Function.prototype.bind.apply(LW.Utilities.DateTime, newValueConstructorParameters))); target.value = that._value.toString(timePartCode); that.context = oldContext; } /** * Footer click handler. */ _footerClickHandler(event) { const that = this, oldContext = that.context, target = event.target; that.context = that; if (target.classList.contains('lw-today-element')) { // "Now" icon is clicked that._validateValue(that._now()); if (that.autoClose) { clearTimeout(that._autoCloseTimeout); that._autoCloseTimeout = setTimeout(function () { that.close(); }, that.autoCloseDelay); } } else { const closestRepeatButton = target.closest('lw-repeat-button'); if (closestRepeatButton !== null) { const decrement = closestRepeatButton === closestRepeatButton.parentElement.children[1], timePartCode = closestRepeatButton.closest('.lw-footer-component').classList.contains('lw-footer-component-hour') ? 'hh' : 'mm'; that._incrementDecrement(decrement, timePartCode); } } that.context = oldContext; } /** * Footer wheel handler. */ _footerWheelHandler(event) { const that = this, activeElement = that.shadowRoot ? that.shadowRoot.activeElement : document.activeElement; if (that.enableMouseWheelAction && event.target instanceof HTMLInputElement && activeElement === event.target) { const oldContext = that.context, target = event.target; that.context = that; if (target.classList.contains('lw-hour-element')) { that._incrementDecrement(event.deltaY > 0, 'hh'); } else if (target.classList.contains('lw-minute-element')) { that._incrementDecrement(event.deltaY > 0, 'mm'); } else { that._incrementDecrement(undefined, 'tt'); } that.context = oldContext; event.stopPropagation(); } } /** * Gets and highlights a time part. */ _getAndHighlightTimePart(matchIndex, regExpIndex, index) { const that = this; that._programmaticSelection = true; if (that.$.input.selectionStart !== matchIndex || that.$.input.selectionEnd !== regExpIndex) { that.$.input.setSelectionRange(matchIndex, regExpIndex); } else { setTimeout(function () { that.$.input.setSelectionRange(matchIndex, regExpIndex); }, 200); } that._highlightedTimePart = { code: that._formatStringRegExp.groups[index], index: index, from: matchIndex, to: regExpIndex }; } /** * Gets format string regular expression. */ _getFormatStringRegExp() { const that = this; that._formatStringRegExp = that.min.getParseRegExp(that.min.calendar, that.formatString.replace(/y+/g, 'yyyyy')); that._formatStringRegExp.regExp = new RegExp(that._formatStringRegExp.regExp); } /** * Gets and stores month and day names based on locale. */ _getLocalizedNames() { const that = this, localizedNames = LW.Utilities.DateTime.getLocalizedNames(that.locale); that._localizedDays = localizedNames.days; that._localizedMonths = localizedNames.months; that.$.selectDate.innerHTML = that.localize('dateTabLabel'); that.$.selectTime.innerHTML = that.localize('timeTabLabel'); } /** * Handles manual time part edit. */ _handleManualTimePartEdit(newTimePartValue) { const that = this, newValueConstructorParameters = LW.Utilities.DateTime.getConstructorParameters(that._value); newTimePartValue = newTimePartValue[that._highlightedTimePart.index + 1]; if (!isNaN(newTimePartValue)) { if (that._highlightedTimePart.code === 'f') { newTimePartValue = parseInt(newTimePartValue, 10) * 100; } else if (that._highlightedTimePart.code === 'ff') { newTimePartValue = parseInt(newTimePartValue, 10) * 10; } else if (that._highlightedTimePart.code.indexOf('y') !== -1 && newTimePartValue.length < 3) { const yearCutoff = that.yearCutoff.toString(), threshold = parseInt(yearCutoff.slice(2), 10); let decade = parseInt(yearCutoff.slice(0, 2), 10); newTimePartValue = parseInt(newTimePartValue, 10); if (newTimePartValue < threshold) { decade++; } newTimePartValue = newTimePartValue.toString(); newTimePartValue = decade + '' + '0'.repeat(2 - newTimePartValue.length) + newTimePartValue; } else if (that._highlightedTimePart.code.indexOf('h') !== -1) { const previousHours = that._value.hour(); newTimePartValue = parseInt(newTimePartValue, 10); if (previousHours > 11 && newTimePartValue <= 11) { newTimePartValue += 12; } } newValueConstructorParameters[that._codeToIndex[that._highlightedTimePart.code]] = parseInt(newTimePartValue, 10); } else if (that._codeToIndex[that._highlightedTimePart.code] === 1) { // month name has been entered let index = -1; if (newTimePartValue.length > 1) { that._localizedMonths.names.some(function (element, i) { if (element.toLowerCase().indexOf(newTimePartValue.toLowerCase()) !== -1) { index = i; return true; } }); } if (index !== -1) { newValueConstructorParameters[1] = index + 1; } else { that._applyFormatString(); return; } } try { newValueConstructorParameters.unshift(null); that._validateValue(new (Function.prototype.bind.apply(LW.Utilities.DateTime, newValueConstructorParameters))); } catch (error) { that._applyFormatString(); } } /** * Highlights a time part based on the cursor's position in the input. */ _highlightTimePartBasedOnCursor(caretPosition) { const that = this, inputValue = that.$.input.value, matches = that._formatStringRegExp.regExp.exec(inputValue); function getCaretPosition() { if (caretPosition === undefined) { return that.$.input.selectionStart; } return caretPosition; } if (matches === null) { that._highlightedTimePart = undefined; return; } if (!that._iOS && caretPosition === undefined) { caretPosition = that.$.input.selectionStart; } let regExpIndex = matches.index, matchIndex; for (let i = 1; i < matches.length; i++) { const match = matches[i]; matchIndex = inputValue.indexOf(match, regExpIndex); regExpIndex = matchIndex + match.length; if (i === 1 && getCaretPosition() < matchIndex) { that._getAndHighlightTimePart(matchIndex, regExpIndex, 0); break; } if (getCaretPosition() >= matchIndex && getCaretPosition() <= regExpIndex) { that._getAndHighlightTimePart(matchIndex, regExpIndex, i - 1); break; } const nextMatch = matches[i + 1]; if (nextMatch) { const indexOfNextMatch = inputValue.indexOf(nextMatch, regExpIndex); if (getCaretPosition() > regExpIndex && getCaretPosition() < indexOfNextMatch) { if (getCaretPosition() - regExpIndex <= indexOfNextMatch - getCaretPosition()) { that._getAndHighlightTimePart(matchIndex, regExpIndex, i - 1); } else { that._formatStringRegExp.groups[i]; that._programmaticSelection = true; that.$.input.setSelectionRange(indexOfNextMatch, indexOfNextMatch + nextMatch.length); } break; } } else { that._programmaticSelection = true; that.$.input.setSelectionRange(matchIndex, regExpIndex); that._highlightedTimePart = { code: that._formatStringRegExp.groups[i - 1], index: i - 1, from: matchIndex, to: regExpIndex }; break; } } } /** * Highlights a time part based on its index in the format string. */ _highlightTimePartBasedOnIndex(index) { const that = this, inputValue = that.$.input.value, matches = that._formatStringRegExp.regExp.exec(inputValue); if (matches === null) { that._validateValue(undefined, that._cloneValue(), false); that._highlightTimePartBasedOnIndex(index); return; } let regExpIndex = matches.index, matchIndex; const activeElement = that.shadowRoot ? that.shadowRoot.activeElement : document.activeElement; if (index < 0 || index >= matches.length) { return; } if (that.$.input !== activeElement) { that.$.input.focus(); } for (let i = 1; i < matches.length; i++) { const match = matches[i]; matchIndex = inputValue.indexOf(match, regExpIndex); regExpIndex = matchIndex + match.length; if (index === i - 1) { that._getAndHighlightTimePart(matchIndex, regExpIndex, index); break; } } } /** * Increments or decrements the value. */ _incrementDecrement(decrement, timePartCode) { const that = this, oldValue = that._cloneValue(); if (that._minMaxChanged) { that._value = that._rangeValidation(that._value); delete that._minMaxChanged; } if (timePartCode === undefined && that._highlightedTimePart) { timePartCode = that._highlightedTimePart.code; } if (timePartCode !== undefined) { if (timePartCode === 'z' || timePartCode === 'zz' || timePartCode === 'zzz') { that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index); return; } if (timePartCode === 't' || timePartCode === 'tt') { that._value = that._value.addHours(that._value.hour() < 12 ? 12 : -12, true); } else { that._value = that._value[that._codeToMethod[timePartCode]](decrement ? -1 : 1, true); } that._validateValue(undefined, oldValue, false); if (that._highlightedTimePart) { that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index); } } else { that._value = that._value.add(decrement ? that.interval.negate() : that.interval, undefined, true); that._validateValue(undefined, oldValue, false); } if (oldValue.compare(that._value) !== 0 && that.isInitialized) { that.$.fireEvent('change', { 'oldValue': oldValue.toTimeZone(that._inputTimeZone), 'value': that.value }); } } /** * Initializes TimePicker instance. */ _initializeTimePicker() { const that = this; const timePickerDropDown = document.createElement('lw-time-picker'); timePickerDropDown.rightToLeft = that.rightToLeft; timePickerDropDown.animation = that.animation; timePickerDropDown.theme = that.theme; timePickerDropDown.value = that._value !== null ? that._value.toDate() : that._now(); that.$.timePickerDropDown = timePickerDropDown; timePickerDropDown.$ = LW.Utilities.Extend(timePickerDropDown); that.$.dropDownContent.appendChild(timePickerDropDown); that._timePickerInitialized = true; that._addTimePickerListener(); } /** * Input blur handler. */ _inputBlurHandler() { const that = this; that.removeAttribute('focus'); that._fullEdit = false; that._highlightedTimePartEdit = false; that.$.fireEvent('blur'); } /** * Input change handler. */ _inputChangeHandler(event) { const that = this; if (event) { event.stopPropagation(); } if (that.$.input.value === '') { that._setNullValue(); return; } if (that._fullEdit || that._value === null) { that._fullEdit = false; that._validateValue(that.$.input.value); that._highlightTimePartBasedOnCursor(); } else if (that._highlightedTimePartEdit) { that._highlightedTimePartEdit = false; let newTimePartValue = that._formatStringRegExp.regExp.exec(that.$.input.value); if (newTimePartValue !== null) { that._handleManualTimePartEdit(newTimePartValue); } else { that._applyFormatString(); } } } /** * Input dragstart handler. */ _inputDragstartHandler(event) { event.preventDefault(); } /** * Input focus handler. */ _inputFocusHandler() { const that = this; that.setAttribute('focus', ''); if (that.editMode !== 'full') { const timeout = LW.Utilities.Core.isMobile ? 10 : 0; // Timeout is necessary due to an issue in Chrome (https://bugs.chromium.org/p/chromium/issues/detail?id=526516) setTimeout(function () { if (that._iOS) { that._highlightTimePartBasedOnCursor(); } else if (that._mouseFocus !== true) { if (that._highlightedTimePart === undefined) { that._highlightTimePartBasedOnCursor(that._iOS ? undefined : 0); } else { that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index); } } }, timeout); } that.$.fireEvent('focus'); } /** * Input keydown handler. */ _inputKeydownHandler(event) { const that = this, editMode = that.editMode, key = event.key; if (key === 'Tab') { return; } if (event.altKey && key === 'ArrowDown') { event.preventDefault(); that.open(); return; } if (key === 'Escape' || event.altKey && key === 'ArrowUp') { event.preventDefault(); that.close(); return; } if (editMode === 'full') { that._fullEdit = true; return; } else if (editMode === 'partial') { if (key === 'Delete') { if (that._value !== null) { that._setNullValue(); event.preventDefault(); } return; } if (that._value === null) { that._validateValue(that._now(), null, false); that._highlightTimePartBasedOnIndex(0); } if (['/', '.', '-', ',', ' '].indexOf(key) !== -1) { that._inputChangeHandler(); that._navigateToNextTimePart(); event.preventDefault(); return; } else if (key === 'Backspace') { that._resetTimePart(); if (that._highlightedTimePart.index > 0) { that._navigateToPreviousTimePart(); } else { that._highlightTimePartBasedOnIndex(0); } event.preventDefault(); return; } } else if (that._fullEdit || that._highlightedTimePartEdit || that.readonly || ['Alt', 'Control', 'Shift'].indexOf(key) !== -1 || event.altKey || event.ctrlKey) { return; } if (['End', 'Home', 'ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(key) === -1) { if (that._highlightedTimePart) { if (editMode !== 'partial' && (that._highlightedTimePart.to - that._highlightedTimePart.from !== that.$.input.selectionEnd - that.$.input.selectionStart)) { that._fullEdit = true; return; } const code = that._highlightedTimePart.code; if (code === 'ddd' || code === 'dddd' || code === 'z' || code === 'zz' || code === 'zzz' || code === 't' || code === 'tt') { // weekday name, time zone offset and a.m./p.m. cannot be edited event.preventDefault(); return; } else if (editMode === 'partial' && code !== 'MMM' && code !== 'MMMM' && new RegExp(/^\d+$/).test(key) === false) { if (key.length < 2 || key.charAt(0) !== 'F') { event.preventDefault(); } return; } that._highlightedTimePartEdit = true; } return; } event.preventDefault(); if (editMode === 'partial' && that._highlightedTimePartEdit) { that._inputChangeHandler(); } if (that._value === null) { return; } switch (key) { case 'End': that._highlightTimePartBasedOnIndex(that._formatStringRegExp.groups.length - 1); break; case 'Home': that._highlightTimePartBasedOnIndex(0); break; case 'ArrowLeft': that._navigateToPreviousTimePart(); break; case 'ArrowUp': that._incrementDecrement(); break; case 'ArrowRight': that._navigateToNextTimePart(); break; case 'ArrowDown': that._incrementDecrement(true); break; } } /** * Input mousedown handler. */ _inputDownHandler() { const that = this; if (that._fullEdit || that._highlightedTimePartEdit || that.editMode === 'full' || LW.Utilities.Core.isMobile) { return; } // Timeout is necessary due to an issue in Chrome (https://bugs.chromium.org/p/chromium/issues/detail?id=526516) setTimeout(function () { that._mouseFocus = true; that._highlightTimePartBasedOnCursor(); }, 0); } /** * Input paste handler. */ _inputPasteHandler(event) { const that = this; if (that.editMode === 'partial') { event.preventDefault(); } else { this._fullEdit = true; } } /** * Input select handler. */ _inputSelectHandler() { const that = this, activeElement = that.shadowRoot ? that.shadowRoot.activeElement : document.activeElement; if (that.editMode !== 'partial' || activeElement !== that.$.input) { return; } if (that._programmaticSelection === true) { that._programmaticSelection = false; } else { if (that._highlightedTimePart) { that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index); } else { that._highlightTimePartBasedOnIndex(0); } } } /** * Input up handler. */ _inputUpHandler() { const that = this; if (LW.Utilities.Core.isMobile) { if (that._iOS) { that._mouseFocus = true; setTimeout(function () { if (document.activeElement === that.$.input) { that._highlightTimePartBasedOnCursor(); } }, 50); } else { // Timeout is necessary due to an issue in Chrome (https://bugs.chromium.org/p/chromium/issues/detail?id=526516) setTimeout(function () { that._mouseFocus = true; that._highlightTimePartBasedOnCursor(); }, 10); } } } /** * Input wheel handler. */ _inputWheelHandler(event) { const that = this, activeElement = that.shadowRoot ? that.shadowRoot.activeElement : document.activeElement; if (activeElement === that.$.input && that.enableMouseWheelAction && !that.disabled && !that.readonly) { event.preventDefault(); that._incrementDecrement(event.deltaY > 0); } } /** * Checks if a date is restricted. */ _isRestricted(date) { const restrictedDates = this.restrictedDates; let isRestricted = false; for (let i = 0; i < restrictedDates.length; i++) { if (date.equalDateParts(restrictedDates[i])) { isRestricted = true; break; } } return isRestricted; } /** * Mouseout handler. */ _mouseoutHandler(event) { const that = this, target = event.target; if (!that.disabled && (target === that.$.input || target === that.$.calendarButton)) { target.removeAttribute('hover'); that.removeAttribute('hover'); } } /** * Mouseover handler. */ _mouseoverHandler(event) { const that = this, target = event.target; if (!that.disabled && (target === that.$.input || target === that.$.calendarButton)) { target.setAttribute('hover', ''); that.setAttribute('hover', ''); } } /** * Navigates to next time part (if any). */ _navigateToNextTimePart() { const that = this; that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index + 1); } /** * Navigates to previous time part (if any). */ _navigateToPreviousTimePart() { const that = this; that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index - 1); } /** * Returns a new DateTime object with the current time. */ _now() { const that = this, now = new LW.Utilities.DateTime('today', 'Local'); if (that._outputTimeZone !== 'Local') { return now.toTimeZone(that._outputTimeZone); } return now; } /** * Opens the calendar dropdown. */ _open(initial) { const that = this; if (that.disabled || that.readonly) { that.opened = false; that.$.calendarButton.setAttribute('aria-expanded', false); return; } const openingEvent = that.$.fireEvent('opening'); if (openingEvent.defaultPrevented) { that.opened = false; that.$.calendarButton.setAttribute('aria-expanded', false); return; } if (that._edgeMacFF) { that.$dropDownContainer.removeClass('not-in-view'); } const dropDownContainer = that.$.dropDownContainer; dropDownContainer.style.marginLeft = null; if (!initial) { dropDownContainer.style.transition = ''; } that.$.calendarDropDown.disabled = false; that.$calendarButton.addClass('lw-calendar-button-pressed'); that.$.calendarButton.setAttribute('active', ''); if (that._dropDownDisplayMode !== 'default' && that._dropDownDisplayMode !== 'timePicker' || !that._timePickerInitialized || (that._timePickerInitialized && that.$.timePickerDropDown.$.hasClass('lw-hidden'))) { that.$calendarDropDown.removeClass('lw-hidden'); } that.opened = true; that.$.calendarButton.setAttribute('aria-expanded', true); that._positionDetection.placeOverlay(); that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that.$dropDownContainer.removeClass('lw-visibility-hidden'); const windowWidth = window.devicePixelRatio === 1 ? document.documentElement.clientWidth : window.innerWidth, dropDownContainerBoundingRect = dropDownContainer.getBoundingClientRect(); if (dropDownContainerBoundingRect.left < 0) { dropDownContainer.style.marginLeft = -1 * dropDownContainerBoundingRect.left + 'px'; } else if (dropDownContainerBoundingRect.right > windowWidth) { dropDownContainer.style.marginLeft = windowWidth - dropDownContainerBoundingRect.right + 'px'; } that.$.fireEvent('open'); if (that._toSync) { const value = that._value; if (value !== null) { that._disregardCalendarChangeEvent = true; that.$.calendarDropDown.selectedDates = [value.toDate()]; if (that._defaultFooterTemplateApplied) { that._hourElement.value = value.toString('hh'); that._minuteElement.value = value.toString('mm'); that._ampmElement.value = value.toString('tt'); } if (that._timePickerInitialized) { that.$.timePickerDropDown.value = value.toDate(); } } else { const oldContext = that.$.calendarDropDown.context; that.$.calendarDropDown.context = that.$.calendarDropDown; that.$.calendarDropDown._clearSelection(true); that.$.calendarDropDown.context = oldContext; if (that._defaultFooterTemplateApplied) { that._hourElement.value = ''; that._minuteElement.value = ''; that._ampmElement.value = ''; } } that._toSync = false; } let toFocus; function check() { if (!that._toFocus) { return; } if (that.$.dropDownContainer.getBoundingClientRect().height === 0) { requestAnimationFrame(check); } else { that._dropDownTransitionendHandler(); } } switch (that._dropDownDisplayMode) { case 'default': if (that.$selectDate.hasClass('lw-selected')) { toFocus = that.$.calendarDropDown; } else { toFocus = that.$.timePickerDropDown.$.picker; } break; case 'classic': case 'calendar': toFocus = that.$.calendarDropDown; break; case 'timePicker': toFocus = that.$.timePickerDropDown.$.picker; break; } if (that.hasAnimation) { that._toFocus = toFocus; check(); } else { toFocus.focus(); } } /** * Positions external dropdown. */ _positionExternalDropDown(elementRect) { const that = this.context, buttonOnTheRight = !that.calendarButton || that.calendarButtonPosition === 'right', dropDownPosition = that._dropDownListPosition, dropDown = that.$.dropDownContainer; let left = buttonOnTheRight ? elementRect.right - dropDown.offsetWidth : elementRect.left, top; switch (dropDownPosition) { case 'bottom': top = elementRect.bottom; break; case 'overlay-top': top = elementRect.bottom - dropDown.offsetHeight; break; case 'overlay-center': top = elementRect.top + elementRect.height / 2 - dropDown.offsetHeight / 2; break; case 'overlay-bottom': top = elementRect.top; break; case 'top': top = elementRect.top - dropDown.offsetHeight; break; case 'center-bottom': case 'center-top': if (dropDownPosition === 'center-bottom') { top = elementRect.bottom + 5; } else { top = elementRect.top - 5 - dropDown.offsetHeight; } if (buttonOnTheRight) { left = elementRect.right - dropDown.offsetWidth / 2 - that.$.calendarButton.offsetWidth / 2; } else { left = elementRect.left - dropDown.offsetWidth / 2 + that.$.calendarButton.offsetWidth / 2; } break; } return { left: left, top: top }; } /** * Returns a date in the range between "min" and "max" */ _rangeValidation(initialDate) { const that = this; if (initialDate.compare(that.min) === -1) { return that.min.clone(); } else if (initialDate.compare(that.max) === 1) { return that.max.clone(); } else { return initialDate; } } /** * Resets a time part */ _resetTimePart() { const that = this, code = that._highlightedTimePart.code, index = that._codeToIndex[code], newValueConstructorParameters = LW.Utilities.DateTime.getConstructorParameters(that._value); let value; if (index > 2) { value = 0; } else if (index > 0) { value = 1; } else { value = that.min.year(); } newValueConstructorParameters[index] = value; newValueConstructorParameters.unshift(null); that._validateValue(new (Function.prototype.bind.apply(LW.Utilities.DateTime, newValueConstructorParameters))); } /** * Sets ids to elements from the template (whenever necessary). */ _setIds() { const that = this; if (!that.$.label.id) { that.$.label.id = that.id + 'Label'; } if (!that.$.input.id) { that.$.input.id = that.id + 'Input'; } if (!that.$.calendarButton.id) { that.$.calendarButton.id = that.id + 'CalendarButton'; } if (!that.$.dropDownContainer.id) { that.$.dropDownContainer.id = that.id + 'DropDownContainer'; } if (!that.$.hint.id) { that.$.hint.id = that.id + 'Hint'; } } /** * Sets default footer template */ _setDefaultFooterTemplate(initialization) { const that = this; that.$.calendarDropDown.footerTemplate = that._defaultFooterTemplate; if (initialization) { that.$.calendarDropDown._handleLayoutTemplate(that.$.calendarDropDown.$.footer, that._defaultFooterTemplate); } that._hourElement = that.$.calendarDropDown.getElementsByClassName('lw-hour-element')[0]; that._minuteElement = that.$.calendarDropDown.getElementsByClassName('lw-minute-element')[0]; that._ampmElement = that.$.calendarDropDown.getElementsByClassName('lw-am-pm-element')[0]; that._todayElement = that.$.calendarDropDown.getElementsByClassName('lw-today-element')[0]; that._todayElement.title = that.localize('now'); Array.from(that.$.calendarDropDown.$.footer.getElementsByTagName('lw-repeat-button')).forEach(function (button) { button.animation = that.animation; }); that._addCalendarFooterListeners(); that._defaultFooterTemplateApplied = true; } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.$.input.tabIndex = -1; that.$.selectDate.removeAttribute('tabindex'); that.$.selectTime.removeAttribute('tabindex'); if (that._defaultFooterTemplateApplied) { that._hourElement.tabIndex = -1; that._ampmElement.tabIndex = -1; that._minuteElement.tabIndex = -1; } return; } const index = that.tabIndex > 0 ? that.tabIndex : 0; that.$.input.removeAttribute('tabindex'); that.$.selectDate.tabIndex = index; that.$.selectTime.tabIndex = index; if (that._defaultFooterTemplateApplied) { that._hourElement.removeAttribute('tabindex'); that._ampmElement.removeAttribute('tabindex'); that._minuteElement.removeAttribute('tabindex'); that.$.calendarDropDown.getElementsByClassName('lw-footer-component-today')[0].tabIndex = index; } } /** * Sets the value to null and updates the input. */ _setNullValue(oldValue) { const that = this; if (oldValue === undefined) { oldValue = that._cloneValue(); } if (that.nullable) { that._value = null; that.value = null; that._highlightedTimePart = undefined; that.$.input.value = ''; if (oldValue !== null) { if (that.opened) { if (!that._calendarInitiatedChange) { const oldContext = that.$.calendarDropDown.context; that.$.calendarDropDown.context = that.$.calendarDropDown; that.$.calendarDropDown._clearSelection(true); that.$.calendarDropDown.context = oldContext; } if (that._defaultFooterTemplateApplied) { that._hourElement.value = ''; that._ampmElement.value = ''; that._minuteElement.value = ''; } that._toSync = false; } else { that._toSync = true; } if (that.isInitialized) { that.$.fireEvent('change', { 'oldValue': oldValue.toTimeZone(that._inputTimeZone), 'value': null }); } } that._disableSpinButtons(); } else { that._validateValue(that._now(), oldValue); } } /** * Spin buttons click handler. */ _spinButtonsClickHandler(event) { const that = this; if (that._value !== null && !that.disabled && !that.readonly) { that._incrementDecrement(that.$.downButton.contains(event.target)); } } /** * Validates initial property values. */ _validateInitialPropertyValues() { const that = this, calendar = that.$.calendarDropDown; if (that.calendarButtonPosition === 'left') { that.$.content.insertBefore(that.$.calendarButton, that.$.input); } if (that.spinButtonsPosition === 'left') { that.$.content.insertBefore(that.$.spinButtonsContainer, that.$.input); } if (that.disabled) { that.$.upButton.disabled = true; that.$.downButton.disabled = true; } if (that.opened) { if (!that.disabled && !that.readonly) { that.$.dropDownContainer.style.transition = 'none'; that._open(true); } else { that.opened = false; } } that.$.calendarButton.setAttribute('aria-expanded', that.opened); if (that.footerTemplate === null) { that._setDefaultFooterTemplate(true); } else { calendar.footerTemplate = that.footerTemplate; calendar._handleLayoutTemplate(calendar.$.footer, that.footerTemplate); } if (that.formatString === '') { that.formatString = 'dd-MMM-yy HH:mm:ss.fff'; } const displayKind = that.displayKind; if (displayKind === 'UTC') { that._outputTimeZone = 'UTC'; } else if (displayKind === 'local') { that._outputTimeZone = 'Local'; } let parsedValue; if (that.value !== null) { parsedValue = LW.Utilities.DateTime.validateDate(that.value, new LW.Utilities.DateTime(), that.formatString); that._inputTimeZone = parsedValue.timeZone; if (displayKind !== 'unspecified' && that._inputTimeZone !== that._outputTimeZone) { parsedValue = parsedValue.toTimeZone(that._outputTimeZone); } else if (displayKind === 'unspecified') { that._outputTimeZone = that._inputTimeZone; } } else { parsedValue = null; that._inputTimeZone = 'Local'; } that._validateRestrictedDates(); that._validateMinMax('both'); that._validateValue(parsedValue, that._now(), false, true); that._validateInterval(new LW.Utilities.TimeSpan(0, 0, 1)); that._getFormatStringRegExp(); if (that._defaultFooterTemplateApplied && that._hourElement.value === '' && that.value !== null) { const value = that.value; that._hourElement.value = value.toString('hh'); that._ampmElement.value = value.toString('tt'); that._minuteElement.value = value.toString('mm'); } that._detectDisplayMode(); const dropDownDisplayMode = that._dropDownDisplayMode; if (dropDownDisplayMode === 'default' || dropDownDisplayMode === 'calendar') { calendar.viewSections = ['title', 'header']; if (calendar.$title.hasClass('lw-hidden')) { calendar.propertyChangedHandler('viewSections', ['header', 'footer'], ['title', 'header']); } if (dropDownDisplayMode === 'default') { that.$dropDownHeader.removeClass('lw-hidden'); } } else if (dropDownDisplayMode === 'timePicker') { that.$calendarDropDown.addClass('lw-hidden'); that._initializeTimePicker(); } } /** * Validates "interval" */ _validateInterval(referenceValue) { const that = this, interval = that.interval; let validValue = interval; if (interval instanceof LW.Utilities.TimeSpan) { validValue = interval; } else if (typeof interval === 'string') { const indexOfTimeSpan = interval.indexOf('TimeSpan('), indexOfBracket = interval.indexOf(')'); if (indexOfTimeSpan !== -1 && indexOfBracket !== -1) { validValue = interval.slice(indexOfTimeSpan + 9, indexOfBracket); validValue = validValue.replace(/'/g, '').replace(/"/g, '').replace(/^\s+|\s+$|\s+(?=\s)/g, ''); if (new RegExp(/(^(\d+)(,\s*\d+)*$)/g).test(validValue)) { validValue = validValue.replace(/\s/g, ''); validValue = validValue.split(','); validValue.map(function (argument, index) { validValue[index] = parseInt(argument); }); validValue.unshift(null); validValue = new (Function.prototype.bind.apply(LW.Utilities.TimeSpan, validValue)); } } if (validValue instanceof LW.Utilities.TimeSpan === false) { if (validValue.trim() === '') { that.interval = referenceValue; return; } if (!isNaN(validValue)) { validValue = parseInt(validValue, 10) * 10000; } try { validValue = new LW.Utilities.TimeSpan(validValue); } catch (error) { that.interval = referenceValue; return; } } } else if (typeof interval === 'number') { validValue = new LW.Utilities.TimeSpan(interval); } else { that.interval = referenceValue; return; } if (validValue._ticks === 0) { that.interval = referenceValue; } else { that.interval = validValue; } } /** * Validates "min" and "max" */ _validateMinMax(which, referenceValue) { const that = this; let minChanged = false; if (which !== 'max') { that.min = LW.Utilities.DateTime.validateDate(that.min, referenceValue || new LW.Utilities.DateTime(1600, 1, 1), that.formatString); that.min = that.min.toTimeZone(that._outputTimeZone); minChanged = true; } if (which !== 'min') { that.max = LW.Utilities.DateTime.validateDate(that.max, referenceValue || new LW.Utilities.DateTime(3001, 1, 1), that.formatString); that.max = that.max.toTimeZone(that._outputTimeZone); that.max.calendar.days = that._localizedDays; that.max.calendar.months = that._localizedMonths; that.max.calendar.locale = that.locale; that.$.calendarDropDown.max = that.max.toDate(); } if (that.min.compare(that.max) > 0) { that.min = that.max.clone(); minChanged = true; } if (minChanged) { that.min.calendar.days = that._localizedDays; that.min.calendar.months = that._localizedMonths; that.min.calendar.locale = that.locale; that.$.calendarDropDown.min = that.min.toDate(); } } /** * Validates "restrictedDates". */ _validateRestrictedDates() { const that = this, dateTimeInputRestrictedDates = [], calendarRestrictedDates = []; for (let i = 0; i < that.restrictedDates.length; i++) { const currentRestrictedDate = that.restrictedDates[i]; let validRestrictedDate = LW.Utilities.DateTime.validateDate(currentRestrictedDate, 'invalid', that.formatString); if (validRestrictedDate !== 'invalid') { validRestrictedDate = validRestrictedDate.toTimeZone(that._outputTimeZone); dateTimeInputRestrictedDates.push(validRestrictedDate); calendarRestrictedDates.push(validRestrictedDate.toDate()); } } that.restrictedDates = dateTimeInputRestrictedDates; that.$.calendarDropDown.restrictedDates = calendarRestrictedDates; } /** * Validates the value and updates the input. */ _validateValue(value, referenceValue, fireEvent, programmatic) { const that = this, oldValue = referenceValue !== undefined ? referenceValue : that._cloneValue(); if (value === null || value === '') { that._setNullValue(oldValue); return; } if (value !== undefined) { that._value = LW.Utilities.DateTime.validateDate(value, oldValue, that.formatString); } if (that._value === null) { that._setNullValue(oldValue); return; } let valueNotRestricted = that._value; while (that._isRestricted(valueNotRestricted) === true) { valueNotRestricted.addDays(1, false); } const valueInRange = that._rangeValidation(valueNotRestricted); if (!programmatic || that.validation === 'strict') { that._value = valueInRange; delete that._minMaxChanged; } else if (valueNotRestricted.equals(valueInRange) === false) { that._minMaxChanged = true; } that.value = that._value.toTimeZone(that._inputTimeZone); const validValue = that._value; validValue.calendar.days = that._localizedDays; validValue.calendar.months = that._localizedMonths; validValue.calendar.locale = that.locale; that._applyFormatString(); that._disableSpinButtons(); if (((oldValue === null || validValue === null) && oldValue !== validValue) || ((oldValue !== null && validValue !== null) && oldValue.compare(validValue) !== 0)) { if (fireEvent !== false && that.isInitialized) { that.$.fireEvent('change', { 'oldValue': oldValue !== null ? oldValue.toTimeZone(that._inputTimeZone) : null, 'value': that.value }); } if (that._calendarInitiatedChange) { return; } if (that.opened) { if (oldValue === null || that.$.calendarDropDown.selectedDates.length === 0 || oldValue.year() !== validValue.year() || oldValue.month() !== validValue.month() || oldValue.day() !== validValue.day() || !that.$.calendarDropDown._isDateInView(validValue.toDate())) { that._disregardCalendarChangeEvent = true; that.$.calendarDropDown.selectedDates = [validValue.toDate()]; } if (that._defaultFooterTemplateApplied) { if (oldValue === null || oldValue.hour() !== validValue.hour()) { that._hourElement.value = validValue.toString('hh'); that._ampmElement.value = validValue.toString('tt'); } if (oldValue === null || oldValue.minute() !== validValue.minute()) { that._minuteElement.value = validValue.toString('mm'); } } if (that._timePickerInitialized && !that._timePickerInitiatedChange) { that.$.timePickerDropDown.value = validValue.toDate(); } that._toSync = false; } else { that._toSync = true; } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * lwDockingLayout custom element. */ LW('lw-docking-layout', class DockingLayout extends LW.ContentElement { /** * Element's properties */ static get properties() { return { 'autoLoadState': { value: false, type: 'boolean' }, 'autoSaveState': { value: false, type: 'boolean' }, 'draggable': { value: true, type: 'boolean' }, 'floatable': { value: true, type: 'boolean' }, 'hideSplitterBars': { value: false, type: 'boolean' }, 'layout': { value: [], type: 'array', reflectToAttribute: false }, 'liveResize': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'invalidNode': '{{elementType}}: "{{method}}" method accepts an instance of LW.TabsWindow', 'invalidNodeRemove': '{{elementType}}: "{{method}}" method accepts an instance of LW.TabsWindow that is a child of the DockingLayout.', 'invalidNodeType': '{{elementType}}: The method "{{method}}" requires a "lw-tabs-window" element to be passed as an argument.', 'invalidTargetNode': '{{elementType}}: The method "{{method}}" requires an index of an item that is not hidden/closed. Only visible items that are part of the Layout are valid.', 'invalidIndex': '{{elementType}}: "{{method}}" method accepts an index of type number.', 'noId': 'lwDockingLayout requires an id in order to save/load a state.' } }, type: 'object', extend: true }, 'resizeStep': { value: 5, type: 'number' }, 'snapMode': { value: 'advanced', allowedValues: ['simple', 'advanced'], type: 'string' } } } /** * Element's event listeners. */ static get listeners() { return { 'autoHideWindow.close': '_autoHideWindowCloseHandler', 'autoHideWindow.resizeEnd': '_autoHideWindowResizeEndHandler', 'container.dock': '_dockEventHandler', 'move': '_moveHandler', 'document.down': '_documentDownHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler', 'document.selectstart': '_documentSelectStartHandler', 'document.dragstart': '_documentDragStartHandler', 'container.tabStripResize': '_containerTabStripResizeHandler', 'horizontalHiddenItemsContainer.resize': '_resizeHandler', 'itemsContainer.close': '_itemsContainerCloseHandler', 'itemsContainer.autoHide': '_itemsContainerAutoHideHandler', 'itemsContainer.resizeEnd': '_itemsContainerResizeHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler', 'mouseleave': '_mouseLeaveHandler' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.dockinglayout.css' ] } /** * Element's HTML template. */ template() { return `<div id="container" role="presentation"> <lw-splitter id="horizontalHiddenItemsContainer" class="lw-horizontal-hidden-items-container" orientation="horizontal"> <lw-splitter-item class="lw-docking-layout-item-holder"> <lw-splitter id="verticalHiddenItemsContainer" class="lw-vertical-hidden-items-container"> <lw-splitter-item class="lw-docking-layout-item-holder"> <lw-splitter id="itemsContainer" class="lw-items-container"> <content></content> <lw-splitter-item id="placeholderItem" class="lw-placeholder" pinned> <lw-tabs-window tab-position="hidden" opened header-buttons='[]'> <lw-tab-item></lw-tab-item> </lw-tabs-window> </lw-splitter-item> </lw-splitter> </lw-splitter-item> </lw-splitter> </lw-splitter-item> </lw-splitter> <lw-tabs-window id="tabsWindowFeedback" class="lw-tabs-window-feedback lw-hidden"></lw-tabs-window> <lw-tabs-window id="autoHideWindow" class="lw-docking-layout-auto-hide-window" pinned header-buttons='["close", "dock"]' right-to-left="[[rightToLeft]]" tab-position="hidden"> <lw-tab-item></lw-tab-item> </lw-tabs-window> </div>`; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'autoSaveState': that._handleAutoSave(); break; case 'layout': that._handleLayout(); break; case 'liveResize': case 'resizeStep': { const allSplitters = that.getElementsByTagName('lw-splitter'); for (let i = 0; i < allSplitters.length; i++) { allSplitters[i][propertyName] = newValue; } if (propertyName === 'liveResize') { that.$.autoHideWindow[propertyName] = newValue; } break; } case 'snapMode': that._handleSnapping(); that._snapFeedback = undefined; break; case 'hideSplitterBars': that._setSplitterBarVisibility(); break; case 'rightToLeft': case 'theme': if (that._items) { that._items.forEach(item => item[propertyName] = newValue); } break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Element's ready method. */ ready() { super.ready(); } render() { const that = this; that.setAttribute('role', 'group'); //AutoLoadState if (that.autoLoadState) { const previousState = that.loadState(); if (previousState) { that.layout = previousState; } } that.$.itemsContainer.liveResize = that.liveResize; that.$.itemsContainer.resizeStep = that.resizeStep; that._handleLayout(); //Prevents visual redraw on element initialization that.$tabsWindowFeedback.removeClass('lw-hidden'); that._setFocusable(); that.checkLicense(); super.render(); } /** * Checks for missing modules. */ static get requires() { return { 'LW.TabsWindow': 'lw.window.js', 'LW.Splitter': 'lw.splitter.js' } } /** * Appends an HTML element content section of the Window. */ appendChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild' })); return } if (!(node instanceof LW.TabsWindow)) { that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'appendChild' })); return; } that.insertBefore(node, null); } /** * AutoHides and item to the bottom side * @param {any} item */ autoHideBottom(item) { this._autoHide(item, 'bottom'); } /** * AutoHides and item to the left side * @param {any} item */ autoHideLeft(item) { this._autoHide(item, 'left'); } /** * AutoHides and item to the right side * @param {any} item */ autoHideRight(item) { this._autoHide(item, 'right'); } /** * AutoHides and item to the top side * @param {any} item */ autoHideTop(item) { this._autoHide(item, 'top'); } /** * Clears the previously saved state */ clearState() { const that = this; if (!that.id) { that.warn(that.localize('noId')); return; } window.localStorage.removeItem('lwDockingLayout' + that.id); } /** * Docks an autoHidden item/ Inserts an external window into the Layout * @param {any} item */ dock(item) { this._dock(item); } /** * Undocks a tabsWindow or TabItem if it was docked( inside the Layout ) */ undock(tabsWindow) { const that = this; if (typeof tabsWindow === 'number') { tabsWindow = that._items[tabsWindow]; } else if (typeof tabsWindow === 'string') { tabsWindow = that._getItemById(tabsWindow); } if (!tabsWindow) { return; } if (!(that.shadowRoot || that).contains(tabsWindow) && that._getClosestDockingLayout(tabsWindow) !== that) { return; } const shadowHost = tabsWindow.getRootNode() && tabsWindow.getRootNode().host ? tabsWindow.getRootNode().host : undefined, splitterItem = tabsWindow.closest('lw-splitter-item') || (shadowHost ? shadowHost.closest('lw-splitter-item') : undefined); if (!splitterItem) { return; } const splitterItemRect = splitterItem.getBoundingClientRect(); let targetWindow; if (tabsWindow instanceof LW.TabsWindow) { if (tabsWindow.autoHide) { //Close the autoHideWindow that.$.autoHideWindow.close(); if (tabsWindow._autoHideWindow) { tabsWindow.style.width = tabsWindow._autoHideWindow.offsetWidth + 'px'; tabsWindow.style.height = tabsWindow._autoHideWindow.offsetHeight + 'px'; } if (tabsWindow.tabPosition === 'left' || tabsWindow.tabPosition === 'right') { tabsWindow.style.height = that.offsetHeight + 'px'; } else { tabsWindow.style.width = that.offsetWidth + 'px'; } } else { tabsWindow.style.width = tabsWindow.offsetWidth + 'px'; tabsWindow.style.height = tabsWindow.offsetHeight + 'px'; } tabsWindow.windowParent = 'body'; //Reset window properties tabsWindow.opened = true; if (tabsWindow.autoHide) { tabsWindow.tabPosition = 'top'; } //Reset the proeprties of the Window tabsWindow.autoHide = tabsWindow.allowToggle = tabsWindow.pinned = false; tabsWindow.style.maxWidth = tabsWindow.style.maxHeight = ''; targetWindow = tabsWindow; const splitterParent = splitterItem.closest('lw-splitter'); splitterParent.removeChild(splitterItem); that._removeUnneccessaryItems(splitterParent); } else if (tabsWindow instanceof LW.TabItem) { const parentTabsWindow = tabsWindow.closest('lw-tabs-window') || (shadowHost ? shadowHost.closest('lw-tabs-window') : undefined); let newTabsWindow; if (parentTabsWindow.items.length === 1) { newTabsWindow = parentTabsWindow; splitterItem.closest('lw-splitter').removeChild(splitterItem); } else { newTabsWindow = that._createTabsWindowFromObject({ label: tabsWindow.label }); parentTabsWindow.removeChild(tabsWindow); //Removes the Tab label from the parent lwTabs newTabsWindow.appendChild(tabsWindow); } if (newTabsWindow.windowParent !== 'body') { newTabsWindow.windowParent = 'body'; } if (newTabsWindow.parentElement !== that.getShadowRootOrBody()) { that.getShadowRootOrBody().appendChild(newTabsWindow); that._ownTabWindow(newTabsWindow); } newTabsWindow.allowToggle = newTabsWindow.autoHide = newTabsWindow.pinned = false; newTabsWindow.label = tabsWindow.label; newTabsWindow.opened = true; //Remember the previous item newTabsWindow._parentInfo = { closestItem: parentTabsWindow, position: tabsWindow.index }; targetWindow = newTabsWindow; tabsWindow = parentTabsWindow; } else { return; } if (tabsWindow._originalTabPosition) { targetWindow.tabPosition = tabsWindow._originalTabPosition; } else if (tabsWindow.autoHide) { targetWindow.tabPosition = 'top'; } targetWindow.tabTextOrientation = tabsWindow._originalTextOrientation || 'horizontal'; if (targetWindow === tabsWindow) { delete targetWindow._originalTabPosition; delete targetWindow._originalTextOrientation; } that._setFloatingItemsHeaderButtons(targetWindow); //Position on the same place targetWindow.style.left = splitterItemRect.left + 'px'; targetWindow.style.top = splitterItemRect.top + 'px'; targetWindow.resizeMode = 'both'; const itemIndex = that._items.indexOf(tabsWindow); targetWindow.layout = that; if (itemIndex > -1) { that._items.splice(itemIndex, 1); if (targetWindow.position) { targetWindow.style.top = targetWindow.position.top; targetWindow.style.left = targetWindow.position.left; delete targetWindow.position; } } if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) { that.$.itemsContainer.appendChild(that.$.placeholderItem); } that._validateWindowPosition(targetWindow); that._setAutoHidePaddings(); if (!that._noStateChangeFiring) { that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'float', item: targetWindow }); } if (document.activeElement !== targetWindow) { const scrollElement = document.scrollingElement || document.documentElement, x = scrollElement.scrollLeft, y = scrollElement.scrollTop; targetWindow.focus(); targetWindow.bringToFront(); window.scrollTo(x, y); } } /** * Inserts a TabsWindow element before another inside the Layout */ insertBefore(newNode, node, topLevelInsert) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } let newTabsWindow = newNode; if (newTabsWindow instanceof LW.TabsWindow) { newNode = document.createElement('lw-splitter-item'); newNode.size = newTabsWindow.size || ''; newNode.max = newTabsWindow.max || ''; newNode.min = newTabsWindow.min || ''; newNode.locked = newTabsWindow.locked || false; newNode.collapsible = newTabsWindow.collapsible || false; newNode.collapsed = newTabsWindow.collapsed || false; newNode.appendChild(newTabsWindow); } else if (newTabsWindow instanceof LW.SplitterItem) { newTabsWindow = newTabsWindow.querySelector('lw-tabs-window'); } else { that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore' })); } newTabsWindow.opened = newTabsWindow.pinned = true; newTabsWindow.style.width = newTabsWindow.style.height = ''; newTabsWindow.style.top = newTabsWindow.style.left = ''; newTabsWindow.style.paddingTop = newTabsWindow.style.paddingBottom = ''; newTabsWindow.style.paddingLeft = newTabsWindow.style.paddingRight = ''; newNode.style.top = newNode.style.left = ''; let parentSplitter; if (that._items.indexOf(newTabsWindow) > -1) { that._items.splice(that._items.indexOf(newTabsWindow), 1); } if (node) { parentSplitter = node.closest('lw-splitter'); if (parentSplitter === that.$.verticalHiddenItemsContainer || parentSplitter === that.$.horizontalHiddenItemsContainer) { parentSplitter = that.$.itemsContainer; if (that._items.length === 0) { node = null; } else if (node.tabPosition === 'top' || node.tabPosition === 'left') { node = that._items[0]; } else { node = that._items[that._items.length - 1]; } } else if (topLevelInsert) { parentSplitter = that.$.itemsContainer; } if (!(node instanceof LW.TabsWindow)) { that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore' })); return; } parentSplitter.autoFitMode = 'proportional'; parentSplitter.insertBefore(newNode, parentSplitter._items.filter(item => item.contains(node))[0]); that._items.splice(that._items.indexOf(node), 0, newTabsWindow); } else { parentSplitter = that.$.itemsContainer; if (that._dockingAutoHideTabItem) { parentSplitter.autoFitMode = 'end'; } that._items.push(newTabsWindow); that.$.itemsContainer.insertBefore(newNode); } parentSplitter.autoFitMode = 'proportional'; if (newTabsWindow.autoHide) { that._autoHide(newTabsWindow, newTabsWindow.autoHidePosition); } else { //Reset the TabsWindow if it's been an autoHidden one newTabsWindow.autoHide = newTabsWindow.allowToggle = false; if (newTabsWindow._originalTabPosition) { newTabsWindow.tabPosition = newTabsWindow._originalTabPosition; delete newTabsWindow._originalTabPosition; } if (newTabsWindow._originalTextOrientation) { newTabsWindow.tabTextOrientation = newTabsWindow._originalTextOrientation; delete newTabsWindow._originalTextOrientation; } that._setDockedItemsHeaderButtons(newTabsWindow); const scrollElement = document.scrollingElement || document.documentElement, x = scrollElement.scrollLeft, y = scrollElement.scrollTop; newTabsWindow.focus(); window.scrollTo(x, y); } if (that._items.filter(item => item.opened).length > 0 && that.$.placeholderItem.parentElement) { that.$.itemsContainer.removeChild(that.$.placeholderItem); } newTabsWindow.layout = that; newTabsWindow.minimized = false; newTabsWindow.maximized = false; newTabsWindow.locked = false; newTabsWindow.resizeMode = 'none'; that._handleAutoHiddenSplitterBars(); that._setSplitterBarVisibility(); that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'dock', item: newTabsWindow }); } /** * Inserts a new item before the targetItem that corresponds to the index * @param {any} index - the index of the target item * @param {any} item - the new item to be inserted */ insertBeforeItem(index, item) { this._insert(index, item, 'top', 'insertBeforeItem'); } /** * Inserts a new item after the targetItem that corresponds to the index * @param {any} index - the index of the target item * @param {any} item - the new item to be inserted */ insertAfterItem(index, item) { this._insert(index, item, 'bottom', 'insertAfterItem'); } /** * Inserts a new item inside the target item at it's left side * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertIntoLeft(index, item) { this._insert(index, item, 'inside-left', 'insertIntoLeft'); } /** * Inserts a new item inside the target item at it's right side * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertIntoRight(index, item) { this._insert(index, item, 'inside-right', 'insertIntoRight'); } /** * Inserts a new item inside the target item at it's top side * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertIntoTop(index, item) { this._insert(index, item, 'inside-top', 'insertIntoTop'); } /** * Inserts a new item inside the target item at it's top side * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertIntoBottom(index, item) { this._insert(index, item, 'inside-bottom', 'insertIntoBottom'); } /** * Inserts a new item at top level of hierarchy inside the layout at position top */ insertLayoutTop(item) { this._insert(0, item, 'layout-top', 'insertLayoutTop'); } /** * Inserts a new item at top level of hierarchy inside the layout at position bottom * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertLayoutBottom(item) { this._insert(0, item, 'layout-bottom', 'insertLayoutBottom'); } /** * Inserts a new item at top level of hierarchy inside the layout at position left */ insertLayoutLeft(item) { this._insert(0, item, 'layout-left', 'insertLayoutLeft'); } /** * Inserts a new item at top level of hierarchy inside the layout at position left * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertLayoutRight(item) { this._insert(0, item, 'layout-right', 'insertLayoutRight'); } /** * Inserts a new item at position top by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item. * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertOutsideTargetGroupTop(index, item) { this._insert(index, item, 'outside-top', 'insertOutsideTargetGroupTop'); } /** * Inserts a new item at position bottom by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item. * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertOutsideTargetGroupBottom(index, item) { this._insert(index, item, 'outside-bottom', 'insertOutsideTargetGroupBottom'); } /** * Inserts a new item at position left by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item. * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertOutsideTargetGroupLeft(index, item) { this._insert(index, item, 'outside-left', 'insertOutsideTargetGroupLeft'); } /** * Inserts a new item at position right by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item. * @param {any} index - the index of the target Layout item * @param {any} item - an instance of LW.TabsWindow or an object defining a TabsWindow. */ insertOutsideTargetGroupRight(index, item) { this._insert(index, item, 'outside-right', 'insertOutsideTargetGroupRight'); } /** * Returns an array of auto-hide items that are available inside the Layout * @param {any} orientation */ getAutoHideItems(orientation) { const that = this; function getItems(splitter) { let items = []; if (!splitter._items) { return items; } for (let i = 0; i < splitter._items.length; i++) { if (!splitter._items[i].$.hasClass('lw-docking-layout-item-holder')) { items.push(splitter._items[i].getElementsByTagName('lw-tabs-window')[0]); } } return items; } if (!orientation) { return getItems(that.$.horizontalHiddenItemsContainer).concat(getItems(that.$.verticalHiddenItemsContainer)); } if (orientation === 'horizontal') { return getItems(that.$.horizontalHiddenItemsContainer); } return getItems(that.$.verticalHiddenItemsContainer); } /** * Returns the index of the item * @param {any} item */ getIndex(item) { const that = this; if (!that.isReady) { return; } if (!that._items.length) { return; } return that._items.indexOf(item); } /** * Returns an array of Splitter items that are auto hidden inside the element */ get autoHideItems() { const that = this; if (!that.isReady) { return [] } return that.getAutoHideItems(); } /** * Returns an array of Splitter items that are inside the element */ get items() { const that = this; if (!that.isReady) { return []; } return that._items.filter(item => item.opened).concat(that.getAutoHideItems()); } /** * Returns all closed TabsWindow items */ get closedItems() { const that = this; if (!that.isReady) { return [] } return that._items.filter(item => !item.opened); } /** * Returns all items of the DockingLayout that have been undocked */ get undockedItems() { const that = this; if (!that.isReady) { return []; } const tabsWindows = document.getElementsByTagName('lw-tabs-window'); let undockedWindows = []; for (let i = 0; i < tabsWindows.length; i++) { if ((!tabsWindows[i].closest('lw-docking-layout') && !that._getClosestDockingLayout(tabsWindows[i])) && tabsWindows[i].layout === that) { tabsWindows[i].undocked = true; undockedWindows.push(tabsWindows[i]); } } return undockedWindows; } /** * Returns the Splitter parent of a Layout item */ getItemGroupElement(item) { const that = this; if (!that.isReady || !item || !(item instanceof LW.TabsWindow) || !(that.shadowRoot || that).contains(item)) { return; } return item.closest('lw-splitter'); } /** * Returns the current Layout structure as an array of objects. Contains HTML references. */ getState(noInstances) { const that = this, autoHideItems = that.getAutoHideItems(), undockedItems = that.undockedItems, structure = []; for (let i = 0; i < autoHideItems.length; i++) { structure.push(that._createTabsWindowStructure(autoHideItems[i], noInstances)); } for (let i = 0; i < undockedItems.length; i++) { structure.push(that._createTabsWindowStructure(undockedItems[i], noInstances)); } return [{ type: 'LayoutGroup', items: structure.concat(that._createLayoutStructure(that.$.itemsContainer, noInstances)), orientation: that.$.itemsContainer.orientation }]; } /** * Returns the nearest splitter bars of an item * @param {any} item - a lwTabsWindow item or it's index or id */ getClosestSplitterBars(item) { const that = this; if (!that._items || !that._items.length) { return; } if (typeof item === 'string') { item = that._getItemById(item); } else if (typeof item === 'number') { item = that._items[parseInt(item)]; } if (!(item instanceof LW.TabsWindow) || !that._items.find(i => i === item)) { return } let closestSplitter = item.closest('lw-splitter'); while (closestSplitter) { if (closestSplitter.bars.length) { break; } closestSplitter = closestSplitter.closest('lw-splitter'); } if (closestSplitter) { return closestSplitter.bars; } } /** * Returns a JSON structure of the current Layout state. Does not contain any HTML references. Used for local storaging. */ getJSONStructure() { return this.getState(true); } /** * Load the previously saved state of the Layout */ loadState(previousState) { const that = this; if (!previousState) { if (!that.id) { that.warn(that.localize('noId')); return; } previousState = JSON.parse(window.localStorage.getItem('lwDockingLayout' + that.id)); } if (previousState) { that._loadState(previousState); return previousState; } } /** * Removes a TabsWindow element from the Layout. */ removeAt(item) { const that = this; if (typeof (item) === 'number') { item = that._items[item]; } else if (typeof item === 'string') { item = that._getItemById(item); } if (!(item instanceof LW.TabsWindow)) { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'remove' })); return; } if (item.closest('lw-docking-layout') !== that && that._getClosestDockingLayout(item) !== that) { that.error(that.localize('invalidNodeRemove', { elementType: that.nodeName.toLowerCase(), method: 'remove' })); return; } that.removeChild(item); } /** * Removes all items from the Layout */ removeAll() { this._removeAll(); } /** * Removes a lwTabsWindow item from the Layout */ removeChild(node) { const that = this; if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild' })); return } if (!(node instanceof LW.TabsWindow)) { that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'removeChild' })); return; } if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } const splitterItem = node.closest('lw-splitter-item'); if (!splitterItem) { return; } const splitter = splitterItem.closest('lw-splitter'); if (!splitter) { return; } splitterItem.closest('lw-splitter').removeChild(splitterItem); that._items.splice(that._items.indexOf(node), 1); that._removeUnneccessaryItems(splitter); if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) { that.$.itemsContainer.appendChild(that.$.placeholderItem); } node.layout = that; that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'remove', item: node }); } /** * Saves the current state of the Layout */ saveState() { const that = this; if (!that.id) { that.warn(that.localize('noId')); return; } //Save to LocalStorage window.localStorage.setItem('lwDockingLayout' + that.id, JSON.stringify(that.getJSONStructure())); } /** * Updates the content of a TabsWindow item * @param {any} index * @param {any} item * @param {any} position */ update(item, settings) { const that = this; if (typeof item === 'number') { item = that._items[parseInt(item)]; } else if (typeof item === 'string') { item = that._getItemById(item); } if (!item || !(item instanceof LW.TabsWindow)) { that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'update' })); return; } if (!(that.shadowRoot || that).contains(item) && that._getClosestDockingLayout(item) !== that) { return; } if (!settings || typeof settings !== 'object') { return; } if (settings.items) { for (let i = 0; i < settings.items.length; i++) { const tabItemIndex = settings.items[i].index; if (typeof tabItemIndex !== 'number' || isNaN(tabItemIndex)) { continue; } if (item.items && !item.items[tabItemIndex]) { item.insert(tabItemIndex, settings.items[i]) } else { item.update(settings.items[i].index, settings.items[i].label, settings.items[i].content); } } } if (settings.id) { item.id = settings.id; } if (settings.label) { item.label = settings.label; } item.tabCloseButtons = settings.tabCloseButtons || false; if (settings.headerButtons && Array.isArray(settings.headerButtons)) { item.headerButtons = settings.headerButtons.length === 0 ? ['close', 'autoHide'] : settings.headerButtons; } const parentSplitterItem = item.closest('lw-splitter-item'); if (!parentSplitterItem) { return; } if (item.autoHide) { that._autoHide(item); } else { parentSplitterItem.size = settings.size !== undefined ? settings.size : parentSplitterItem.size; parentSplitterItem.min = settings.min !== undefined ? settings.min : parentSplitterItem.min; parentSplitterItem.max = settings.max !== undefined ? settings.max : parentSplitterItem.max; parentSplitterItem.locked = settings.locked !== undefined ? settings.locked : parentSplitterItem.locked; parentSplitterItem.collapsible = settings.collapsible !== undefined ? settings.collapsible : parentSplitterItem.collapsible; parentSplitterItem.collapsed = settings.collapsed !== undefined ? settings.collapsed : parentSplitterItem.collapsed; } } /** * Autohides a TabsWindow */ _autoHide(tabsWindow, position) { const that = this; if (typeof tabsWindow === 'number') { tabsWindow = that._items[tabsWindow]; } else if (typeof tabsWindow === 'string') { tabsWindow = that._getItemById(tabsWindow); } if (!tabsWindow) { return; } if (tabsWindow instanceof LW.TabItem) { const parentTabsWindow = tabsWindow.closest('lw-tabs-window') || (tabsWindow.getRootNode() && tabsWindow.getRootNode().host ? tabsWindow.getRootNode().host.closest('lw-tabs-window') : undefined); if (parentTabsWindow && parentTabsWindow.items.length < 2) { tabsWindow = parentTabsWindow; } else { const tabItem = tabsWindow; if (parentTabsWindow) { if (parentTabsWindow.autoHide && parentTabsWindow.tabPosition === position) { return; } parentTabsWindow.removeChild(tabsWindow); } tabsWindow = that._createTabsWindowFromObject({ label: tabsWindow.label }); tabsWindow.appendChild(tabItem); } } if (!(tabsWindow instanceof LW.TabsWindow)) { that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'appendChild' })); return; } let splitterItem = tabsWindow.closest('lw-splitter-item'), tabsWindowSize; const splitterContainer = tabsWindow.closest('lw-splitter') || (tabsWindow.isInShadowDOM ? tabsWindow.getRootNode().host : undefined) || that.$.itemsContainer, positionDetails = that._getAutoHidePositionDetails(position, tabsWindow, splitterItem), autoHideSplitter = positionDetails.autoHideSplitter; position = positionDetails.position; if (tabsWindow.offsetHeight) { tabsWindowSize = position === 'left' || position === 'right' ? tabsWindow.offsetWidth : tabsWindow.offsetHeight; } if (!splitterItem) { splitterItem = document.createElement('lw-splitter-item'); splitterItem.appendChild(tabsWindow); } splitterItem.min = 30; const autoHideName = 'auto-hide-' + position; //Check if it's already autoHidden if (tabsWindow.autoHide && splitterItem.$.hasClass(autoHideName)) { return; } const tabsWindowIndex = that._items.indexOf(tabsWindow); that._items.splice(tabsWindowIndex, tabsWindowIndex > -1 ? 1 : 0); if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) { position === 'left' ? that.$.itemsContainer.insert(1, that.$.placeholderItem) : that.$.itemsContainer.appendChild(that.$.placeholderItem); } that._handleAutoHideWindow({ position: position, tabsWindow: tabsWindow, splitterItem: splitterItem, autoHideName: autoHideName, splitterContainer: splitterContainer, autoHideSplitter: autoHideSplitter }); autoHideSplitter.bars.map(bar => bar.hide()); if (!that.shadowRoot || (that.shadowRoot && that.isCompleted)) { that._setAutoHidePaddings(); } const tabsWindowItems = tabsWindow.items; if (tabsWindowItems) { for (let i = 0; i < tabsWindowItems.length; i++) { if (!tabsWindowItems[i]._autoHideWindowSize) { tabsWindowItems[i]._autoHideWindowSize = tabsWindowSize; } } } if (that.$.autoHideWindow.opened && that.$.autoHideWindow._tabsWindow) { that.$.autoHideWindow._tabsWindow._setAutoHideWindowSize(that.$.autoHideWindow._tabsWindow.selectedIndex); } if (that.isCompleted) { that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'autoHide', item: tabsWindow }); //NOTE: ShadowDOM Styles are loaded slwly so additional recalculation is required ! if (that.shadowRoot) { setTimeout(function () { if (position === 'top' || position === 'bottom') { that.$.horizontalHiddenItemsContainer.items.filter(item => item.className.indexOf('auto-hide-') > -1).forEach(item => { const tabsWindow = item.querySelector('lw-tabs-window'); item.style.height = ''; tabsWindow.refreshTabs(); }); that.$.horizontalHiddenItemsContainer.refresh(); } else { that.$.verticalHiddenItemsContainer.items.filter(item => item.className.indexOf('auto-hide-') > -1).forEach(item => { const tabsWindow = item.querySelector('lw-tabs-window'); item.style.width = ''; tabsWindow.refreshTabs(); }); that.$.verticalHiddenItemsContainer.refresh(); } that._setAutoHidePaddings(); }, 150); } } } /** * iOS Safari bug fix. (iOS Safari doesn't support 'touch-action: none') */ _moveHandler(event) { if (this.hasAttribute('dragged') && event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * Returns the position and the autoHideSplitter according to the position * @param {any} position */ _getAutoHidePositionDetails(position, tabsWindow, splitterItem) { const that = this, splitterContainer = tabsWindow.closest('lw-splitter') || that.$.itemsContainer, index = splitterContainer ? splitterContainer._items.indexOf(splitterItem) : 0; let autoHideSplitter; switch (position) { case 'top': case 'bottom': autoHideSplitter = that.$.horizontalHiddenItemsContainer; break; case 'left': case 'right': autoHideSplitter = that.$.verticalHiddenItemsContainer; break; default: if (splitterContainer.orientation === 'vertical') { autoHideSplitter = that.$.verticalHiddenItemsContainer; const autoHiddenItems = autoHideSplitter.items.filter(item => item.className.indexOf('auto-hide-') > -1); if (autoHiddenItems.length === 1 && that._items.length === 1) { position = autoHiddenItems[0].$.hasClass('auto-hide-right') ? 'right' : 'left'; } else { position = index >= splitterContainer.items.length / 2 ? 'right' : 'left'; } } else { autoHideSplitter = that.$.horizontalHiddenItemsContainer; const autoHiddenItems = autoHideSplitter.items.filter(item => item.className.indexOf('auto-hide-') > -1); if (autoHiddenItems.length === 1 && that._items.length === 1) { position = autoHiddenItems[0].$.hasClass('auto-hide-bottom') ? 'bottom' : 'top'; } else { position = index >= splitterContainer.items.length / 2 ? 'bottom' : 'top'; } } break; } return { autoHideSplitter: autoHideSplitter, position: position }; } /** * Places the target Window in a new AutoHideWindow or an already existing one * @param {any} details */ _handleAutoHideWindow(details) { const that = this, autoHideName = details.autoHideName, splitterItem = details.splitterItem, splitterContainer = details.splitterContainer, position = details.position, autoHideSplitter = details.autoHideSplitter; let tabsWindow = details.tabsWindow, autoHiddenItem = (that.shadowRoot || that).querySelector('.' + autoHideName), size = 'offset' + (position === 'left' || position === 'right' ? 'Width' : 'Height'); //splitterItem.locked = false; tabsWindow.locked = false; if (autoHiddenItem) { const tabItems = [].slice.call(tabsWindow.isCompleted ? tabsWindow.items : tabsWindow.children), autoHideTabsWindow = autoHiddenItem.querySelector('lw-tabs-window'), autoHiddenItemsCount = autoHideTabsWindow.items.length; for (let i = 0; i < tabItems.length; i++) { autoHideTabsWindow.insert(autoHiddenItemsCount, { node: tabItems[i] }); tabItems[i]._autoHideWindowSize = tabsWindow[size]; } if (splitterItem.parentElement) { splitterContainer.removeChild(splitterItem); } that._removeUnneccessaryItems(splitterContainer); tabsWindow = autoHideTabsWindow; } else { if (splitterContainer && splitterContainer.contains(splitterItem)) { splitterContainer.removeChild(splitterItem); } //Remembers the tabPosition before autoHidding if (that._initializingItems || !tabsWindow.autoHide) { tabsWindow._originalTabPosition = tabsWindow.tabPosition; tabsWindow._originalTextOrientation = tabsWindow.tabTextOrientation; tabsWindow._originalLocked = tabsWindow.locked; } tabsWindow.autoHideWindow = that.$.autoHideWindow; tabsWindow.autoHide = tabsWindow.allowToggle = true; tabsWindow.selectedIndex = null; if (tabsWindow.$.tabsElement && tabsWindow.$.tabsElement.selectedIndex !== tabsWindow.selectedIndex) { tabsWindow.$.tabsElement.selectedIndex = tabsWindow.selectedIndex; } tabsWindow.tabTextOrientation = position === 'right' || position === 'left' ? 'vertical' : 'horizontal'; tabsWindow.tabPosition = position; tabsWindow.style.top = tabsWindow.style.left = ''; tabsWindow.style.width = tabsWindow.style.height = ''; tabsWindow.opened = true; tabsWindow.resizeMode = 'none'; //Make sure no other auto-hide classes are added for (let c = 0; c < splitterItem.classList.length; c++) { if (splitterItem.classList[c].indexOf('auto-hide-') > -1) { splitterItem.$.removeClass(splitterItem.classList[c]); } } splitterItem.$.addClass(autoHideName); splitterItem.style.paddingLeft = splitterItem.style.paddingRight = splitterItem.style.paddingTop = splitterItem.style.paddingBottom = ''; if (splitterItem.min) { splitterItem.min = ''; } that._removeUnneccessaryItems(splitterContainer); if (position === 'top' || position === 'left') { autoHideSplitter.insert(0, splitterItem); } else { autoHideSplitter.appendChild(splitterItem); } autoHideSplitter.autoFitMode = 'proportional'; //Specific browser bug fixes with height: auto and textOrientation: vertical if (LW.Utilities.Core.Browser.Safari && (position === 'left' || position === 'right')) { const tabStrip = tabsWindow.querySelector('.lw-tab-strip'); tabsWindow.size = tabStrip.offsetWidth; } else { if (LW.Utilities.Core.Browser.Firefox && (position === 'top' || position === 'bottom')) { const tabStrip = (tabsWindow.shadowRoot || tabsWindow).querySelector('.lw-tab-strip'); if (tabStrip) { tabsWindow.size = tabStrip.offsetHeight; } } tabsWindow.size = 'auto'; } //Refreshes the min property if (tabsWindow.min) { tabsWindow.min = ''; } tabsWindow.min = 30; tabsWindow.locked = true; autoHideSplitter.autoFitMode = 'end'; } } /** * AutoHideContainer Close event handler */ _autoHideWindowCloseHandler() { const that = this, targetTabsWindow = that.$.autoHideWindow._tabsWindow, scrollElement = document.scrollingElement || document.documentElement, x = scrollElement.scrollLeft, y = scrollElement.scrollTop; targetTabsWindow._moveContent(targetTabsWindow._autoHideWindow.items[0], targetTabsWindow._autoHideWindow._tab); if (!that.$.autoHideWindow.opened) { targetTabsWindow.selectedIndex = null; if (document.activeElement !== targetTabsWindow.$.tabsElement) { targetTabsWindow.$.tabsElement.focus(); window.scrollTo(x, y); } return; } if (!targetTabsWindow.allowToggle) { return; } if (targetTabsWindow.$.tabsElement.selectedIndex !== null) { targetTabsWindow.select(targetTabsWindow.$.tabsElement.selectedIndex); if (document.activeElement !== targetTabsWindow.$.tabsElement) { targetTabsWindow.$.tabsElement.focus(); window.scrollTo(x, y); } } } /** * AutoHideWindow ResizeEnd event handler */ _autoHideWindowResizeEndHandler(event) { const autoHideWindow = event.target, dimension = autoHideWindow.resizeMode === 'left' || autoHideWindow.resizeMode === 'right' ? 'width' : 'height'; if (autoHideWindow._tab) { autoHideWindow._tab._autoHideWindowSize = event.detail[dimension]; } } /** * Cancels a drag operation and returns the item ot it's initial position. Used when dragging operation is interupted */ _cancelDragOperation(noEndDrag) { const that = this; that.removeAttribute('dragged'); that._dragDetails.windowFeedback.removeAttribute('tabs-window-dragged'); that._dragDetails.windowFeedback.removeAttribute('ontop'); that._returnItemToOrigin(that._dragDetails.windowFeedback); that._noStateChangeFiring = true; if (!noEndDrag) { that._endDrag(); } } /** * Creates a new TabsWindow from an Object */ _createTabsWindowFromObject(settings, retrieveContent) { const that = this, tabsWindow = document.createElement('lw-tabs-window'); let item, headerButtons = ['close', 'autoHide']; tabsWindow.layout = that; if (settings.id) { tabsWindow.id = settings.id; } if (settings.disabled) { tabsWindow.disabled = settings.disabled; } if (settings.label) { tabsWindow.label = settings.label; } if (settings.headerPosition) { tabsWindow.headerPosition = settings.headerPosition; } if (settings.tabCloseButtons) { tabsWindow.tabCloseButtons = settings.tabCloseButtons; } if (settings.dropPosition) { tabsWindow.dropPosition = settings.dropPosition; } if (settings.resizeMode) { tabsWindow.resizeMode = settings.resizeMode; } tabsWindow.animation = that.animation; tabsWindow.rightToLeft = that.rightToLeft; tabsWindow.theme = that.theme; tabsWindow.draggable = settings.draggable !== undefined ? settings.draggable : true; tabsWindow.floatable = settings.floatable !== undefined ? settings.floatable : true; tabsWindow.tabCloseButtons = settings.tabCloseButtons ? settings.tabCloseButtons : tabsWindow.tabCloseButtons; if (settings.autoHide) { tabsWindow.autoHideWindow = that.$.autoHideWindow; tabsWindow.autoHide = tabsWindow.allowToggle = settings.autoHide; tabsWindow.autoHidePosition = settings.autoHidePosition; } else if (settings.undocked) { headerButtons = ['close', 'maximize', 'minimize']; tabsWindow.undocked = settings.undocked; tabsWindow.position = { top: settings.top ? ((settings.top + '').indexOf('%') > -1 ? settings.top : parseFloat(settings.top) + 'px') : undefined, left: settings.left ? ((settings.left + '').indexOf('%') > -1 ? settings.left : parseFloat(settings.left) + 'px') : undefined, width: settings.width, height: settings.height }; } tabsWindow.tabPosition = settings.tabPosition || tabsWindow.tabPosition; tabsWindow.opened = tabsWindow.pinned = true; if (settings.headerButtons) { headerButtons = settings.headerButtons; } if (!settings.headerButtons || Array.isArray(settings.headerButtons) && settings.headerButtons.length === 0) { headerButtons = ['close', 'autoHide']; } tabsWindow.headerButtons = headerButtons; tabsWindow.size = settings.size || ''; tabsWindow.max = settings.max || ''; tabsWindow.min = settings.min ? settings.min : 30; tabsWindow.locked = settings.locked || false; tabsWindow.collapsible = settings.collapsible || false; tabsWindow.collapsed = settings.collapsed || false; if (settings.items && Array.isArray(settings.items)) { for (let i = 0; i < settings.items.length; i++) { if (retrieveContent && settings.items[i].instance) { item = settings.items[i].instance; item.index = null; item.id = settings.items[i].id || ''; } else { item = document.createElement('lw-tab-item'); item.label = settings.items[i].label ? settings.items[i].label : ''; item.id = settings.items[i].id || ''; //Get Content from that.layout property const content = settings.items[i].content, selectorRegex = /^[#.]{1}\w(\w|-)+$/gm; if (selectorRegex.test(content)) { const elements = document.querySelectorAll(content); for (let e = 0; e < elements.length; e++) { const el = elements[e]; item.appendChild(el instanceof HTMLTemplateElement ? document.importNode(el.content, true) : el); } } else { item.content = settings.items[i].content ? settings.items[i].content : ''; } item.selected = settings.items[i].selected ? settings.items[i].selected : false; tabsWindow._isItemSelected = true; } item.draggable = settings.items[i].draggable !== undefined ? settings.items[i].draggable : true; item.floatable = settings.items[i].floatable !== undefined ? settings.items[i].floatable : true; if (settings.items[i].id) { item.id = settings.items[i].id; } tabsWindow.appendChild(item); } } return tabsWindow; } /** * Creates Layout items from Array * @param {any} source * @param {any} retrieveContenent */ _createItemsFromArray(source, retrieveContenent) { const that = this; let layoutConfig = source; const layoutLength = layoutConfig.length; that._removeAll(true); that._initializingItems = true; //Remove all undocked windows const undockedItems = that.undockedItems; for (let i = 0; i < undockedItems.length; i++) { undockedItems[i].layout = null; undockedItems[i].parentElement.removeChild(undockedItems[i]); } //Check if itemContainer settings are applied if (layoutLength === 1 && layoutConfig[0].type && layoutConfig[0].type.toLowerCase() === 'layoutgroup') { that.$.itemsContainer.orientation = layoutConfig[0].orientation || that.$.itemsContainer.orientation; that.$.itemsContainer.liveResize = layoutConfig[0].liveResize || that.$.itemsContainer.liveResize; that.$.itemsContainer.resizeMode = layoutConfig[0].resizeMode || that.$.itemsContainer.resizeMode; layoutConfig = layoutConfig[0].items; } let item; //Allows to style the items through CSS on element initialization that.$.itemsContainer.autoFitMode = 'end'; for (let i = 0; i < layoutConfig.length; i++) { item = that._createLayoutItem(layoutConfig[i], retrieveContenent); if (item) { if (that.$.placeholderItem.parentElement) { that.$.itemsContainer.removeChild(that.$.placeholderItem); } that.$.itemsContainer.appendChild(item); } } if (that._items.filter(item => item.opened).length === 0) { if (!that.$.placeholderItem.parentElement) { that.$.itemsContainer.appendChild(that.$.placeholderItem); } } else if (that.$.placeholderItem.parentElement) { that.$.itemsContainer.removeChild(that.$.placeholderItem); } //Restore the desired autoFitMode that.$.itemsContainer.autoFitMode = 'proportional'; delete that._initializingItems; } /** * Creates the Layout items * @param {any} settings * @param {any} retrieveContent */ _createLayoutItem(settings, retrieveContent) { if (!settings) { return; } const that = this, splitteritem = document.createElement('lw-splitter-item'); let item; if (settings.type && settings.type.toLowerCase() === 'layoutgroup') { //Create a splitter item = document.createElement('lw-splitter'); item._isInShadowDOM = that.isInShadowDOM; item.autoFitMode = 'proportional'; if (settings.id) { item.id = settings.id; } if (settings.orientation) { item.orientation = settings.orientation; } if (settings.resizeMode) { item.resizeMode = settings.resizeMode; } item.liveResize = that.liveResize; item.resizeStep = that.resizeStep; let newItem; for (let i = 0; i < settings.items.length; i++) { newItem = that._createLayoutItem(settings.items[i], retrieveContent); if (newItem) { item.appendChild(newItem); } } if (!item.querySelector('lw-splitter-item')) { return; } } else { //Create a TabsWindow item item = that._createTabsWindowFromObject(settings.type && settings.type.toLowerCase() === 'layoutgroup' ? settings.items[0] : settings, retrieveContent); if (item.autoHide) { that._autoHide(item, item.autoHidePosition); delete item.autoHidePosition; return; } else if (item.undocked) { that.undock(item); that.getShadowRootOrBody().appendChild(item); that._ownTabWindow(item); item.opened = true; item.pinned = false; item.layout = that; if (item.position) { item.style.left = item.position.left; item.style.top = item.position.top; item.style.width = item.position.width; item.style.height = item.position.height; delete item.position; } if (item.size) { item.style.left = item.position.left; item.style.top = item.position.top; } return; } that._items.push(item); } splitteritem.size = settings.size || ''; splitteritem.max = settings.max || ''; splitteritem.min = settings.min || 30; splitteritem.locked = settings.locked || false; splitteritem.collapsible = settings.collapsible || false; splitteritem.collapsed = settings.collapsed || false; splitteritem.appendChild(item); return splitteritem; } /** * Creates a JSON Array with the item structure of the Layout * @param {any} splitter */ _createLayoutStructure(splitter, noInstance) { const that = this, structure = []; let items = splitter._items, item, splitterItem; const firstItemChild = items[0].$.content.children[0]; function getItem(container) { let item = container.firstElementChild; while (item) { if (item instanceof LW.Splitter) { return item; } else if (item instanceof LW.TabsWindow) { return item; } item = item.nextElementSibling; } } if (items.length === 1 && firstItemChild instanceof LW.Splitter) { items = firstItemChild._items; if (splitter === that.$.itemsContainer) { that.$.itemsContainer.orientation = firstItemChild.orientation; } } for (let i = 0; i < items.length; i++) { if (items[i] === that.$.placeholderItem) { continue; } splitterItem = getItem(items[i].$.content); if (splitterItem instanceof LW.TabsWindow) { item = that._createTabsWindowStructure(splitterItem, noInstance); } else if (splitterItem instanceof LW.Splitter) { //Avoids unneccessarly complex structures like a single splitter in a splitter parent while (splitterItem._items.length === 1 && splitterItem._items[0].$.content.children[0] instanceof LW.Splitter) { splitterItem = splitterItem._items[0].$.content.children[0]; } //Avoids unnecesssary splitter creations with only 1 item inside if (splitterItem._items.length === 1) { item = that._createTabsWindowStructure(splitterItem._items[0].$.content.children[0], noInstance); } else { item = { type: 'LayoutGroup', items: that._createLayoutStructure(splitterItem, noInstance), orientation: splitterItem.orientation }; } if (splitterItem.id) { item.id = splitterItem.id } //Splitter settings if (splitterItem.resizeMode !== 'adjacent') { item.resizeMode = splitterItem.resizeMode; } if (splitterItem.resizeStep !== 5) { item.resizeStep = splitterItem.resizeStep; } if (splitterItem.liveResize) { item.resizeStep = splitterItem.liveResize; } } //SplitterItem settings item.size = items[i][splitter._measurements.size]; if (items[i].locked) { item.locked = true; } if (items[i].min) { item.min = items[i].min; } if (items[i].max) { item.max = items[i].max; } structure.push(item); } return structure; } /** * Cretes the JSON structure for a TabsWindow * @param {any} tabsWindow */ _createTabsWindowStructure(tabsWindow, noInstance) { function createTabItemStructure(tabItem) { const tabItemStructure = {}; tabItemStructure.type = 'LayoutPanelItem'; tabItemStructure.label = tabItem.label || ''; if (tabItem.selected) { tabItemStructure.selected = tabItem.selected; } if (tabItem.disabled) { tabItemStructure.disabled = tabItem.disabled; } tabItemStructure.draggable = tabItem.draggable !== undefined ? tabItem.draggable : true; tabItemStructure.floatable = tabItem.floatable !== undefined ? tabItem.floatable : true; if (!noInstance) { tabItemStructure.instance = tabItem; } if (tabItem.id) { tabItemStructure.id = tabItem.id; } return tabItemStructure; } const item = { type: 'LayoutPanel' }; if (tabsWindow.id) { item.id = tabsWindow.id; } if (tabsWindow.disabled) { item.disabled = tabsWindow.disabled; } if (tabsWindow.label) { item.label = tabsWindow.label; } if (tabsWindow.autoHide) { item.autoHide = tabsWindow.autoHide; item.autoHidePosition = tabsWindow.tabPosition; } else if (tabsWindow.tabPosition !== 'top') { item.tabPosition = tabsWindow.tabPosition; } if (!tabsWindow.closest('lw-docking-layout') && !this._getClosestDockingLayout(tabsWindow)) { item.undocked = true; item.top = tabsWindow.style.top; item.left = tabsWindow.style.left; item.width = tabsWindow.style.width; item.height = tabsWindow.style.height; } if (tabsWindow.dropPosition && tabsWindow.dropPosition[0] !== 'all') { item.dropPosition = tabsWindow.dropPosition; } item.draggable = tabsWindow.draggable !== undefined ? tabsWindow.draggable : true; item.floatable = tabsWindow.floatable !== undefined ? tabsWindow.floatable : true; if (tabsWindow.floatable !== undefined) { item.floatable = tabsWindow.floatable; } if (tabsWindow.resizeMode !== 'none') { item.resizeMode = tabsWindow.resizeMode; } if (tabsWindow.items) { item.items = []; for (let i = 0; i < tabsWindow.items.length; i++) { item.items.push(createTabItemStructure(tabsWindow.items[i])); } } return item; } /** * Called when the tab strip of the Tab has been resized via inline JS. Check function called _fixTabStripNotChrome() in lw.tabs.js */ _containerTabStripResizeHandler(event) { const that = this, splitter = event.target.closest('lw-splitter'); if (splitter === that.$.horizontalHiddenItemsContainer || splitter === that.$.verticalHiddenItemsContainer) { splitter._resizeEventHandler(); that._setAutoHidePaddings(); } } /** * Finds a TabItem/TabsWindow by id inside ShadowDOMs */ _getItemById(tabsWindow) { const that = this, itemId = tabsWindow; tabsWindow = document.getElementById(itemId); if (tabsWindow) { return tabsWindow; } if (that.shadowRoot) { //Check for TabsWindow tabsWindow = that.shadowRoot.querySelector('#' + itemId); //Check for TabItem if (!tabsWindow) { let items = that.items; for (let i = 0; i < items.length; i++) { const item = items[i]; if (item.shadowRoot) { tabsWindow = item.shadowRoot.querySelector('#' + itemId); if (tabsWindow) { return tabsWindow; } } } //Searhes for external TabsWindows that belong to the DockingLayout items = document.querySelectorAll('lw-tabs-window'); for (let i = 0; i < items.length; i++) { const item = items[i]; if (item.layout !== that) { continue; } if (item.shadowRoot) { tabsWindow = item.shadowRoot.querySelector('#' + itemId); if (tabsWindow) { return tabsWindow; } } } } } } /** * Docks a TabsWindow */ _dock(tabsWindow, position) { const that = this; if (typeof tabsWindow === 'number') { tabsWindow = that._items[tabsWindow]; } else if (typeof tabsWindow === 'string') { tabsWindow = that._getItemById(tabsWindow); } if (!tabsWindow) { return; } let newTabsWindow; if (tabsWindow instanceof LW.TabItem) { const tabItemDockingDetails = that._handleTabItemDocking(tabsWindow); tabsWindow = tabItemDockingDetails.tabsWindow; newTabsWindow = tabItemDockingDetails.newTabsWindow; } else if (typeof tabsWindow === 'object' && !(tabsWindow instanceof HTMLElement)) { tabsWindow = that._createTabsWindowFromObject(tabsWindow); } if (!(tabsWindow instanceof LW.TabsWindow) || !tabsWindow.autoHide) { if (that._items.indexOf(tabsWindow) < 0 || (!tabsWindow.opened && !tabsWindow.parentElement)) { tabsWindow.autoHide = false; //TODO: Check if lastItem and if it is use the tabsWindow instead if (tabsWindow.items.length === 0 && that.snapMode === 'simple') { tabsWindow.parentElement.removeChild(tabsWindow); } //Dock inside the Layout if (!position) { that.appendChild(tabsWindow); } else { that._insert(-1, tabsWindow, position ? 'layout-' + position : undefined); } } return; } if (!(that.shadowRoot || that).contains(tabsWindow)) { return; } const splitterItem = tabsWindow.closest('lw-splitter-item'), splitter = tabsWindow.closest('lw-splitter'), isLastItem = splitterItem.nextElementSibling ? false : true; if (!position) { if (splitter.orientation === 'horizontal') { position = isLastItem ? 'bottom' : 'top'; } else { position = isLastItem ? 'right' : 'left'; } } if (tabsWindow.items.length === 0) { splitterItem.closest('lw-splitter').removeChild(splitterItem); } if (newTabsWindow) { tabsWindow = newTabsWindow; } if (tabsWindow.autoHide) { if (that.$.verticalHiddenItemsContainer.contains(tabsWindow)) { that.$.verticalHiddenItemsContainer.removeChild(tabsWindow.closest('lw-splitter-item')) } else if (that.$.horizontalHiddenItemsContainer.contains(tabsWindow)) { that.$.horizontalHiddenItemsContainer.removeChild(tabsWindow.closest('lw-splitter-item')) } tabsWindow.tabPosition = tabsWindow._originalTabPosition || 'top'; delete tabsWindow._originalTabPosition; } that._setDockedItemsHeaderButtons(tabsWindow); //Reset the proeprties of the Window tabsWindow.autoHide = tabsWindow.allowToggle = tabsWindow.maximized = tabsWindow.minimized = tabsWindow.collapsed = tabsWindow.locked = false; tabsWindow.tabTextOrientation = 'horizontal'; that.$.autoHideWindow.close(); that._insert(-1, tabsWindow, 'layout-' + position); that._setAutoHidePaddings(); delete that._dockingAutoHideTabItem; } /** * Handles the dokcing of TabItems. Called in _dock method. * @param {any} tabsWindow */ _handleTabItemDocking(tabsWindow) { const that = this, parentTabsWindow = (tabsWindow.isInShadowDOM ? tabsWindow.getRootNode().host : tabsWindow).closest('lw-tabs-window'); let newTabsWindow; if (parentTabsWindow) { const autoHideWindow = that.$.autoHideWindow; if (!parentTabsWindow.autoHide) { return { tabsWindow: parentTabsWindow, newTabsWindow: parentTabsWindow }; } that._dockingAutoHideTabItem = true; newTabsWindow = parentTabsWindow.items.length === 1 ? parentTabsWindow : document.createElement('lw-tabs-window'); delete tabsWindow._autoHideWindowSize; newTabsWindow.size = autoHideWindow.resizeMode === 'left' || autoHideWindow.resizeMode === 'right' ? autoHideWindow.offsetWidth : autoHideWindow.offsetHeight; parentTabsWindow.removeChild(tabsWindow); if (parentTabsWindow.items.length === 0 && !newTabsWindow.id) { if (!(that.shadowRoot || that).contains(parentTabsWindow)) { parentTabsWindow.parentElement.removeChild(parentTabsWindow); } } //Copy settings to the new Window newTabsWindow.tabCloseButtons = parentTabsWindow.tabCloseButtons; newTabsWindow.dropPosition = parentTabsWindow.dropPosition; newTabsWindow.draggable = tabsWindow.draggable; newTabsWindow.floatable = tabsWindow.floatable; } if (!newTabsWindow) { newTabsWindow = document.createElement('lw-tabs-window'); } newTabsWindow.animation = that.animation; newTabsWindow.rightToLeft = that.rightToLeft; newTabsWindow.theme = that.theme; newTabsWindow.min = 30; newTabsWindow.opened = newTabsWindow.pinned = newTabsWindow.autoHide = true; newTabsWindow.style.maxWidth = newTabsWindow.style.maxHeight = ''; newTabsWindow._originalTabPosition = parentTabsWindow._originalTabPosition || undefined; newTabsWindow._originalTextOrientation = parentTabsWindow._originalTextOrientation || undefined; if (newTabsWindow !== parentTabsWindow) { delete parentTabsWindow._originalTabPosition; delete parentTabsWindow._originalTextOrientation; } newTabsWindow.label = tabsWindow.label; newTabsWindow.appendChild(tabsWindow); tabsWindow = parentTabsWindow; return { tabsWindow: tabsWindow, newTabsWindow: newTabsWindow }; } /** * lwTabsWindow Dock event handler * @param {any} event */ _dockEventHandler(event) { const that = this; let tabsWindow = event.target; if (tabsWindow._tabsWindow) { tabsWindow = tabsWindow._tabsWindow; } if (tabsWindow.autoHide) { that._dock(tabsWindow.items[tabsWindow.selectedIndex]); } else { that._autoHide(tabsWindow, that._items.indexOf(tabsWindow) < (that._items.length - 1) / 2); } } /** * Down Event Handler * @param {any} event */ _documentDownHandler(event) { const that = this; let target = event.originalEvent.target; if (target.shadowRoot) { target = event.originalEvent.composedPath()[0]; while (target) { if (target.closest('.lw-window')) { target = target.closest('.lw-window'); break; } target = target.getRootNode().host; } } else { target = target.closest('.lw-window'); } if (that.$.autoHideWindow._tabsWindow && (!target || (target !== that.$.autoHideWindow && target !== that.$.autoHideWindow._tabsWindow))) { that.$.autoHideWindow._tabsWindow.selectedIndex = null; } if (that._dragDetails) { that._cancelDragOperation(); return; } //Check for TabsWindow because all TabsWindows should be abble to be inserted into the Layout if (!(target instanceof LW.TabsWindow) || !that.draggable || that.disabled) { return; } if (that._dragDetails || target.maximized || target.minimized || (!LW.Utilities.Core.isMobile && event.which !== 1) || (target._dragDetails && target._dragDetails.type === 'resize' && target._dragDetails.started)) { return; } const originalTarget = event.originalEvent.target.shadowRoot ? event.originalEvent.composedPath()[0] : event.originalEvent.target; target = originalTarget.closest('.lw-header-section') || originalTarget.closest('.lw-tab-label-container'); that._dragDetails = {}; if (target && target.classList.contains('lw-header-section') && (that.snapMode === 'simple' || originalTarget.closest('.lw-buttons-container'))) { target = undefined; } that._dragDetails.windowFeedback = that.$.tabsWindowFeedback; if (target) { const rootNode = target.getRootNode() && target.getRootNode().host ? target.getRootNode().host : target; that._dragDetails.selectedTabsWindow = target.closest('lw-tabs-window') || (rootNode ? rootNode.closest('lw-tabs-window') : undefined); if (that._dragDetails.selectedTabsWindow === that.$.autoHideWindow) { that._dragDetails.selectedItem = that.$.autoHideWindow._tabsWindow.closest('lw-splitter-item'); if (!that.$.autoHideWindow._tabsWindow.draggable) { that._dragDetails = undefined; return; } } else { that._dragDetails.selectedItem = that._dragDetails.selectedTabsWindow.closest('lw-splitter-item'); } if (!that._dragDetails.selectedTabsWindow || !that._dragDetails.selectedTabsWindow.draggable || that._dragDetails.selectedTabsWindow.layout !== that) { that._dragDetails = undefined; return; } that._dragDetails.offset = { x: 0, y: 0 }; that._dragDetails.selectedTabLabel = target; that._dragDetails.x = event.pageX; that._dragDetails.y = event.pageY; if (that._dragDetails.selectedTabLabel.$.hasClass('lw-header-section')) { if (!that._dragDetails.selectedItem && that._dragDetails.selectedTabsWindow.pinned) { that._dragDetails = undefined; return; } that._dragDetails.windowFeedback = that._dragDetails.selectedTabsWindow; const targetRect = target.getBoundingClientRect(); that._dragDetails.offset.x = event.clientX - targetRect.left; that._dragDetails.offset.y = event.clientY - targetRect.top; } else { if (!that._dragDetails.selectedTabLabel.tab || (that._dragDetails.selectedTabLabel.tab.draggable !== undefined && !that._dragDetails.selectedTabLabel.tab.draggable)) { that._dragDetails = undefined; return; } if (that._dragDetails.selectedTabsWindow.items.length === 1) { that._dragDetails.windowFeedback = that._dragDetails.selectedTabsWindow; that._dragDetails.windowFeedback.floatable = that._dragDetails.selectedTabsWindow.items[0].floatable; } } } that._items.map(item => item.removeAttribute('ontop')); if (that._dragDetails.windowFeedback !== that.$.autoHideWindow) { that._dragDetails.windowFeedback.setAttribute('ontop', ''); } } /** * ShadowDOM check if the target is inside the element */ _getClosestDockingLayout(target) { const that = this, targetElement = (that.shadowRoot || that.isInShadowDOM ? that.getRootNode().host : that).nodeName.toLowerCase(), closestDockingHost = this._getClosestElement(targetElement, target); return closestDockingHost ? that : closestDockingHost; } _getClosestElement(hostName, target) { const that = this; if (!target || !that.isInShadowDOM) { return; } if (!target.getRootNode()) { return; } let host = target.getRootNode().host; while (host) { if (!host.closest) { return; } if (host.closest(hostName)) { return host.closest(hostName); } host = host.getRootNode() ? host.getRootNode().host : undefined; } } /** * Document Move Event Handler * @param {any} event */ _documentMoveHandler(event) { const that = this, target = LW.Utilities.Core.isMobile ? document.elementFromPoint(event.pageX - window.pageXOffset, event.pageY - window.pageYOffset) : ((that.isInShadowDOM || event.originalEvent.target.shadowRoot) ? event.originalEvent.composedPath()[0] : event.originalEvent.target); if (that.disabled || !that._dragDetails || (that._dragDetails && !that._dragDetails.selectedTabsWindow) || !target) { return; } if (Math.abs(event.pageX - that._dragDetails.x) <= 5 && Math.abs(event.pageY - that._dragDetails.y) <= 5) { return; } //Keep starting x,y scoll cordinates const scrollElement = document.scrollingElement || document.documentElement, x = scrollElement.scrollLeft, y = scrollElement.scrollTop, selectedTabsWindow = that._dragDetails.selectedTabsWindow; that._dragDetails.isInsideTheLayout = target.closest && target.closest('lw-docking-layout') === that; if (!that._dragDetails.isInsideTheLayout && (that.shadowRoot || that.isInShadowDOM)) { that._dragDetails.isInsideTheLayout = that._getClosestDockingLayout(target); } that._dragDetails.started = true; if (that._dragDetails.windowFeedback === that.$.autoHideWindow) { const selectedTabsWindowRect = that._dragDetails.selectedTabsWindow.getBoundingClientRect(); let newTabsWindow; if (that.$.autoHideWindow._tabsWindow.items.length === 1) { newTabsWindow = that.$.autoHideWindow._tabsWindow; } else { newTabsWindow = document.createElement('lw-tabs-window'); newTabsWindow.draggable = true; newTabsWindow.min = 30; newTabsWindow.layout = that; } newTabsWindow.style.width = selectedTabsWindowRect.width + 'px'; newTabsWindow.style.height = selectedTabsWindowRect.height + 'px'; newTabsWindow.style.left = selectedTabsWindowRect.left + 'px'; newTabsWindow.style.top = selectedTabsWindowRect.top + 'px'; newTabsWindow.setAttribute('ontop', ''); that._dragDetails.windowFeedback = newTabsWindow; that.$.autoHideWindow.$.addClass('no-transition'); that.$.autoHideWindow.close(); that.$.autoHideWindow.$.removeClass('no-transition'); } that._setDragDetailsOnMove(target); that.$.autoHideWindow.close(); if (!that._dragDetails.windowFeedback.classList.contains('lw-tabs-window-feedback')) { that._handleWindowOnDrag(); } else { if (!that._dragDetails._parentInfo) { that._dragDetails._parentInfo = { closestItem: selectedTabsWindow, position: that._originalTabIndex || that._dragDetails.selectedTabLabel.tab.index }; that._originalTabIndex = undefined; } if (!that.getShadowRootOrBody().contains(that._dragDetails.windowFeedback)) { that.getShadowRootOrBody().appendChild(that._dragDetails.windowFeedback); } if (that._dragDetails.selectedItem) { const closestSplitter = that._dragDetails.selectedItem.closest('lw-splitter'); if (!that._dragDetails.windowFeedback.size && closestSplitter) { that._dragDetails.windowFeedback.size = that._dragDetails.selectedTabsWindow[closestSplitter._measurements.size]; } } } if (!that._dragDetails.selectedTabLabel.classList.contains('lw-header-section')) { that._dragDetails.windowFeedback.setAttribute('tabs-window-dragged', ''); } if (that._dragDetails.windowFeedback.hasAttribute('tabs-window-dragged') || that._dragDetails.selectedTabsWindow === that.$.autoHideWindow || (that._dragDetails._parentInfo && typeof (that._dragDetails._parentInfo.position) === 'string')) { that._dragDetails.windowFeedback.style.left = (event.pageX - that._dragDetails.offset.x) + 'px'; that._dragDetails.windowFeedback.style.top = (event.pageY - that._dragDetails.offset.y) + 'px'; that._setWindowFeedbackSize(); } that._dragDetails.windowFeedback.opened = true; if (document.activeElement !== that) { that.focus(); window.scrollTo(x, y); } let tabHeader = that._dragDetails.hoveredTabsWindow ? target.closest('.lw-tabs-header-section') : undefined; if (!tabHeader && (that.shadowRoot || that.isInShadowDOM)) { tabHeader = that._getClosestElement('.lw-tabs-header-section', target); } if (tabHeader) { that._dragDetails.hoveredTabArea = tabHeader; } else { that._dragDetails.hoveredTabArea = that._dragDetails.hoveredTabsWindow && target.closest('.lw-tabs-content-section') ? that._dragDetails.hoveredTabsWindow.$.tabsElement.$.tabContentSection : that._dragDetails.hoveredTabsWindow; } //Fixes the tabSelectionBar if (that.shadowRoot && that._dragDetails.selectedTabsWindow === that._dragDetails.windowFeedback) { requestAnimationFrame(() => { if (that._dragDetails) { that._dragDetails.windowFeedback.refreshTabHeader(); } }) } //Snapping handler that._setSnappingMarkers(event, tabHeader); } /** * Sets additional dragDetails on DocumentMove. Used in _documentMoveHandler * @param {any} target */ _setDragDetailsOnMove(target) { const that = this; let closestDockingLayout; if (!that.hasAttribute('dragged')) { //Avoid page scrollbar appearing that._originalBodyOverflow = { overflowX: document.body.style.overflowX, overflowY: document.body.style.overflowY, overflow: document.body.style.overflow }; const isVerticalScrollable = (document.scrollingElement || document.documentElement).scrollHeight > document.documentElement.clientHeight, isHorizontalScrollable = (document.scrollingElement || document.documentElement).scrollWidth > document.documentElement.clientWidth; let selectedTabsWindow = that._dragDetails.selectedTabsWindow; document.body.style.overflow = document.body.style.overflowX = document.body.style.overflowY = ''; if (isVerticalScrollable && !isHorizontalScrollable) { document.body.style.overflowX = 'hidden'; } else if (isHorizontalScrollable && !isVerticalScrollable) { document.body.style.overflowY = 'hidden'; } else if (!isHorizontalScrollable && !isVerticalScrollable) { document.body.style.overflow = 'hidden'; } if (that._dragDetails.windowFeedback.$.hasClass('lw-tabs-window-feedback') || selectedTabsWindow === that.$.autoHideWindow) { const tabItem = that._dragDetails.selectedTabLabel.tab || that.$.autoHideWindow._tab; let feedbackWindow = that.$.tabsWindowFeedback if (selectedTabsWindow === that.$.autoHideWindow) { selectedTabsWindow = that.$.autoHideWindow._tabsWindow; feedbackWindow = that._dragDetails.windowFeedback; feedbackWindow.label = tabItem.label; feedbackWindow.floatable = tabItem.draggable; feedbackWindow.floatable = tabItem.floatable; } //Prevents touchmove event from braking on iOS if (LW.Utilities.Core.isMobile && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform)) { that._dragDetails.selectedTabLabel._lazyRemove = true; } if (tabItem.parentElement) { selectedTabsWindow.removeChild(tabItem); if (!that._dragDetails.selectedItem.style.width) { that._dragDetails.selectedItem.closest('lw-splitter').refresh(); } } that._originalTabIndex = tabItem.index; feedbackWindow.appendChild(tabItem); const draggedWindow = that._dragDetails.selectedTabsWindow; if (draggedWindow === that.$.autoHideWindow) { if (draggedWindow._tabsWindow.items.length > 1) { feedbackWindow.tabPosition = draggedWindow.tabPosition; feedbackWindow.tabTextOrientation = draggedWindow._originalTextOrientation || draggedWindow.tabTextOrientation; } } else { const isAutoHide = draggedWindow.autoHide; feedbackWindow.tabPosition = draggedWindow._originalTabPosition || (isAutoHide ? 'top' : draggedWindow.tabPosition); feedbackWindow.tabTextOrientation = draggedWindow._originalTextOrientation || (isAutoHide ? 'horizontal' : draggedWindow.tabTextOrientation); } if (tabItem._autoHideWindowSize) { feedbackWindow.size = tabItem._autoHideWindowSize; } else if (selectedTabsWindow.autoHide) { const sizeName = 'offset' + (selectedTabsWindow.tabPosition === 'top' || selectedTabsWindow.tabPosition === 'bottom' ? 'Height' : 'Width'); feedbackWindow.size = (selectedTabsWindow._autoHideWindow || selectedTabsWindow)[sizeName]; } } closestDockingLayout = that._dragDetails.selectedTabsWindow.closest('lw-docking-layout'); if (!closestDockingLayout && that.shadowRoot) { closestDockingLayout = that._getClosestDockingLayout(that._dragDetails.selectedTabsWindow); } if (!closestDockingLayout && !that._dragDetails.windowFeedback._originalPinnedState) { that._dragDetails.windowFeedback._originalPinnedState = that._dragDetails.windowFeedback.pinned; } that._dragDetails.windowFeedback.pinned = false; that.setAttribute('dragged', ''); } that._dragDetails.hoveredItem = target.closest('lw-splitter-item'); if (!that._dragDetails.hoveredItem && (that.shadowRoot || that.isInShadowDOM)) { that._dragDetails.hoveredItem = that._getClosestElement('lw-splitter-item', target); } if (that._dragDetails.hoveredItem) { closestDockingLayout = that._dragDetails.hoveredItem.closest('lw-docking-layout'); if (!closestDockingLayout && that.shadowRoot) { closestDockingLayout = that._getClosestDockingLayout(that._dragDetails.hoveredItem); } if (closestDockingLayout && closestDockingLayout === that) { that._dragDetails.hoveredTabsWindow = that._dragDetails.hoveredItem.querySelector('lw-tabs-window'); } else { that._dragDetails.hoveredItem = that._dragDetails.hoveredTabsWindow = undefined; } } else { that._dragDetails.hoveredTabsWindow = target.closest('lw-tabs-window') || (target.getRootNode() && target.getRootNode().host ? target.getRootNode().host.closest('lw-tabs-window') : undefined); } if (that._dragDetails.hoveredTabsWindow) { closestDockingLayout = that._dragDetails.hoveredTabsWindow.closest('lw-docking-layout'); if (!closestDockingLayout && that.shadowRoot) { closestDockingLayout = that._getClosestDockingLayout(that._dragDetails.hoveredTabsWindow); } if (closestDockingLayout && closestDockingLayout !== that) { that._dragDetails.hoveredTabsWindow = undefined; } else { that._dragDetails.hoveredTabsWindow.bringToFront(); } } } /** * Document Drag Start event handler * @param {any} event */ _documentDragStartHandler(event) { const that = this; if (that.contains(event.target) || that.contains(event.composedPath()[0]) || (that.snapMode === 'simple' && that._dragDetails && that._dragDetails.selectedTabLabel)) { event.preventDefault(); } } /** * Document Select Start event handler */ _documentSelectStartHandler(event) { const that = this; if (that._dragDetails && that._dragDetails.started) { event.preventDefault(); } } /** * Document Up Event Handler */ _documentUpHandler(event) { const that = this, originalEvent = event.originalEvent || event, target = originalEvent.target.getRootNode().host ? originalEvent.composedPath()[0] : originalEvent.target; if (!that._dragDetails || (that._dragDetails && !that._dragDetails.started) || that.disabled) { delete that._dragDetails; return; } that._noStateChangeFiring = true; that.removeAttribute('dragged'); that._dragDetails.windowFeedback.removeAttribute('tabs-window-dragged'); that._dragDetails.windowFeedback.removeAttribute('ontop'); let isInsideTheLayout = target.closest && target.closest('lw-docking-layout'); if (!isInsideTheLayout && (that.shadowRoot || that.isInShadowDOM)) { isInsideTheLayout = that._getClosestDockingLayout(target); } if (event.ctrlKey) { that._snapFeedback._position = isInsideTheLayout = undefined; } const snapFeedbackPosition = that._snapFeedback ? that._snapFeedback._position : undefined; if ((!isInsideTheLayout && !snapFeedbackPosition) || (isInsideTheLayout && !that._dragDetails.hoveredTabArea && !snapFeedbackPosition)) { that._dropWindowOutsideLayout(event, snapFeedbackPosition, isInsideTheLayout); } else if (that._dragDetails.hoveredTabsWindow && snapFeedbackPosition) { if (that._dragDetails.hoveredTabArea && that._dragDetails.hoveredTabArea.classList.contains('lw-tabs-header-section')) { let tabLabelCount = that._dragDetails.hoveredTabsWindow.itemLabels.length; let hoveredTabLabel = target.closest('.lw-tab-label-container'), addToEnd; if (!hoveredTabLabel || hoveredTabLabel.$.hasClass('lw-add-new-tab') || !hoveredTabLabel.tab) { hoveredTabLabel = that._dragDetails.hoveredTabsWindow.itemLabels[tabLabelCount - 1]; addToEnd = true; } let items; if (that._dragDetails.selectedTabLabel.$.hasClass('lw-tab-label-container') && that._dragDetails.windowFeedback.$.hasClass('lw-tabs-window-feedback')) { items = [that._dragDetails.selectedTabLabel.tab]; } else { items = [].slice.call(that._dragDetails.windowFeedback.items); } let size; if (that._dragDetails.hoveredTabsWindow.autoHide) { const autoHidePosition = that._dragDetails.hoveredTabsWindow.tabPosition; size = that._dragDetails.windowFeedback['offset' + (autoHidePosition === 'top' || autoHidePosition === 'bottom' ? 'Height' : 'Width')]; } for (let i = 0; i < items.length; i++) { items[i]._autoHideWindowSize = size || that._dragDetails.windowFeedback.size; that._dragDetails.windowFeedback.removeChild(items[i]); that._dragDetails.hoveredTabsWindow.insert(addToEnd ? tabLabelCount : hoveredTabLabel.tab.index, { node: items[i] }); tabLabelCount = that._dragDetails.hoveredTabsWindow.items.length; } that._dragDetails.targetWindow = that._dragDetails.hoveredTabsWindow; } else { that._dragDetails.targetWindow = that._handleItemNesting(); that._eventAlreadyFired = true; } //Close the autoHideWindow that.$.autoHideWindow.close(); that._noStateChangeFiring = false; } //Fixes the tabSelectionBar if (that.shadowRoot || that.isInShadowDOM) { const targetWindow = that._dragDetails.targetWindow; setTimeout(() => targetWindow.refreshTabHeader(), 100); } that._endDrag(); } /** * Drops a dragged window outside of the Layout. A possible outcome from _documentUpHandler * @param {any} event * @param {any} snapFeedbackPosition */ _dropWindowOutsideLayout(event, snapFeedbackPosition, isInsideTheLayout) { const that = this; let targetWindow; if (!that.floatable || (that._dragDetails.windowFeedback.floatable !== undefined && !that._dragDetails.windowFeedback.floatable)) { that._cancelDragOperation(true); return; } if (that._dragDetails.windowFeedback.classList.contains('lw-tabs-window-feedback')) { const tabItem = that._dragDetails.windowFeedback.items[0]; if (tabItem && tabItem.floatable !== undefined && !tabItem.floatable) { that._cancelDragOperation(true); return; } //Leave outside the Layout const selectedTabItem = that._dragDetails.selectedTabLabel.tab; let newWindow = document.createElement('lw-tabs-window'); newWindow.opened = true; newWindow.animation = that.animation; newWindow.rightToLeft = that.rightToLeft; newWindow.theme = that.theme; newWindow.label = selectedTabItem.label; that._dragDetails.windowFeedback.removeChild(selectedTabItem); that._dragDetails.selectedTabLabel.tab.$.removeClass('lw-visibility-hidden'); newWindow.appendChild(that._dragDetails.selectedTabLabel.tab); newWindow.style.left = event.pageX + 'px'; newWindow.style.top = event.pageY + 'px'; newWindow.style.maxWidth = newWindow.style.maxHeight = ''; newWindow.resizeMode = that._dragDetails.selectedTabsWindow.resizeMode; newWindow.tabTextOrientation = that._dragDetails.windowFeedback.tabTextOrientation; newWindow.tabPosition = that._dragDetails.windowFeedback.tabPosition; newWindow.min = 30; newWindow.style.width = that._dragDetails.windowFeedback.style.width; newWindow.style.height = that._dragDetails.windowFeedback.style.height newWindow.draggable = selectedTabItem.draggable !== undefined ? selectedTabItem.draggable : true; newWindow.floatable = selectedTabItem.floatable !== undefined ? selectedTabItem.floatable : true; that.getShadowRootOrBody().appendChild(newWindow); newWindow.pinned = newWindow.autoHide = newWindow.allowToggle = false; that._noStateChangeFiring = false; targetWindow = newWindow; } else { if (that._dragDetails._parentInfo && that._dragDetails._parentInfo.closestItem) { if (that._dragDetails.windowFeedback.parentElement !== that.getShadowRootOrBody()) { that._dragDetails.windowFeedback.windowParent = 'body'; that.getShadowRootOrBody().appendChild(that._dragDetails.windowFeedback); } //Reset window properties that._dragDetails.windowFeedback.style.maxWidth = that._dragDetails.windowFeedback.style.maxHeight = ''; that._dragDetails.windowFeedback.pinned = that._dragDetails.windowFeedback.allowToggle = that._dragDetails.windowFeedback.autoHide = false; if (that._dragDetails.selectedTabLabel.$.hasClass('lw-tab-label-container')) { that._dragDetails.windowFeedback.label = that._dragDetails.selectedTabLabel.tab.label; } } else if (!snapFeedbackPosition && !(that._dragDetails.selectedItem instanceof LW.SplitterItem) && that._dragDetails.selectedTabLabel.$.hasClass('lw-tab-label-container')) { that._returnItemToOrigin(that._dragDetails.windowFeedback); } targetWindow = that._dragDetails.windowFeedback; targetWindow.locked = false; if (that._dragDetails.selectedItem) { that._noStateChangeFiring = false; } } //Close the autoHideWindow that.$.autoHideWindow.close(); if (!isInsideTheLayout) { that._dragDetails.windowFeedback.pinned = false; } that._validateWindowPosition(targetWindow); //Remember the previous item if (that._dragDetails._parentInfo) { targetWindow._parentInfo = { closestItem: that._dragDetails._parentInfo.closestItem, position: that._dragDetails._parentInfo.position }; } targetWindow.layout = that; that._dragDetails.targetWindow = targetWindow; //Reset the tabPosition of floating windows targetWindow.resizeMode = 'both'; that._setFloatingItemsHeaderButtons(targetWindow); that._ownTabWindow(targetWindow); } /** * Resets the position of a dragged item if the destination is invalid */ _endDrag() { const that = this, windowFeedback = that._dragDetails.windowFeedback; that.$.tabsWindowFeedback.close(); if (windowFeedback.$.tabsElement._tabs.length === 0 && !windowFeedback.$.hasClass('lw-tabs-window-feedback')) { windowFeedback.remove(); } if (!(that.shadowRoot || that).contains(that._dragDetails.windowFeedback) && that._dragDetails.windowFeedback._originalPinnedState !== undefined) { that._dragDetails.windowFeedback.pinned = that._dragDetails.windowFeedback._originalPinnedState; delete that._dragDetails.windowFeedback._originalPinnedState; } if (that._originalBodyOverflow) { document.body.style.overflow = that._originalBodyOverflow.overflow; document.body.style.eoverflowX = that._originalBodyOverflow.overflowX; document.body.style.overflowY = that._originalBodyOverflow.overflowY; delete that._originalBodyOverflow; } if (that._dragDetails.targetWindow) { that._dragDetails.targetWindow.focus(); if (that._dragDetails.selectedTabsWindow) { that._dragDetails.selectedTabsWindow.removeAttribute('active'); } } else { that._dragDetails.windowFeedback.bringToFront(); } //Ends the dragging that._dragDetails.started = false; that._dragDetails.hoveredItem = that._dragDetails.hoveredTabsWindow = that._dragDetails.isInsideTheLayout = undefined; windowFeedback.removeAttribute('dragged'); that._handleSnapping(); if (that._dragDetails.selectedTabsWindow) { delete that._dragDetails.selectedTabsWindow._ownerLayout; } if (windowFeedback.items.length === 0) { if ((that.shadowRoot || that).contains(windowFeedback)) { windowFeedback.opened = false; } if (windowFeedback.$.hasClass('lw-tabs-window-feedback')) { that.$.container.appendChild(windowFeedback); } } if (!that._eventAlreadyFired && !that._noStateChangeFiring) { that._handleAutoSave(); let eventDetail = { item: that._dragDetails.targetWindow }; eventDetail.type = that._items.indexOf(that._dragDetails.targetWindow) > -1 ? 'dock' : 'float'; that.$.fireEvent('stateChange', eventDetail); } that._noStateChangeFiring = that._eventAlreadyFired = undefined; if (that._dragDetails._parentInfo && that._dragDetails._parentInfo.closestItem) { that._removeUnneccessaryItems(that._dragDetails._parentInfo.closestItem.closest('lw-splitter')); } let isInsideDockingLayout = that._getClosestDockingLayout(windowFeedback); if (windowFeedback.closest('lw-docking-layout') || isInsideDockingLayout) { windowFeedback.style.top = windowFeedback.style.left = ''; delete that._dragDetails; return; } if (windowFeedback.top) { windowFeedback.style.top = windowFeedback.top; } if (windowFeedback.left) { windowFeedback.style.left = windowFeedback.left; } //iOS Safari bug. Can't remove the HTMLElement that is being dragged on 'move' event if (that._dragDetails.selectedTabLabel && that._dragDetails.selectedTabLabel._lazyRemove) { if (that._dragDetails.selectedTabLabel) { that._dragDetails.selectedTabLabel.remove(); } delete that._dragDetails.selectedTabLabel._lazyRemove; } windowFeedback._cancelDragging(); delete that._dragDetails; } /** * Returns the contents of a TabItem as a DocumentFragment * @param {any} tabItem */ _getTabItemContent(tabItem) { const content = tabItem.isCompleted ? tabItem.$.content : tabItem, fragment = document.createDocumentFragment(); while (content.firstChild) { fragment.appendChild(content.firstChild); } return fragment; } /** * Returns the dimension of the header label that hovered */ _getHeaderLabelDimensions(event) { const that = this; function continueOperation(coeff) { if (!that._dragDetails) { clearInterval(that._scrollInterval); that._scrollInterval = undefined; return; } tabStrip.scrollLeft += coeff; tabsElement._updateScrollButtonVisibility(); tabsElement._positionTabSelectionBar(tabsElement._tabLabelContainers[tabsElement.selectedIndex], true); } if (!that._dragDetails || !that._dragDetails.hoveredTabsWindow) { return; } const tabsElement = that._dragDetails.hoveredTabsWindow.$.tabsElement, tabStrip = tabsElement.$.tabStrip, tabStripRect = tabStrip.getBoundingClientRect(), isTabPositionVertical = tabsElement.tabPosition === 'left' || tabsElement.tabPosition === 'right', scrollLeft = that.rightToLeft && LW.Utilities.Core.Browser.Chrome ? tabStrip.scrollLeft - (tabStrip.scrollWidth - tabStrip.offsetWidth) : tabStrip.scrollLeft; let nearTabStripScrollButtonOffsetLeft = 0, nearTabStripScrollButtonOffsetTop = 0; if (tabsElement.tabTextOrientation === 'horizontal') { nearTabStripScrollButtonOffsetLeft = tabsElement.$.scrollButtonNear.offsetWidth; } else { nearTabStripScrollButtonOffsetTop = tabsElement.$.scrollButtonNear.offsetHeight; } if (tabsElement.tabPosition === 'top' || tabsElement.tabPosition === 'bottom') { if (that._scrollInterval) { clearInterval(that._scrollInterval); } //AutoScroll the TabItems inside the TabStrip that._scrollInterval = setInterval(function () { //20px is the autoScroll zone size if (event && (scrollLeft || that.rightToLeft) && event.clientX <= tabStripRect.left + Math.max(nearTabStripScrollButtonOffsetLeft, 20)) { continueOperation(-1); } else if (event && scrollLeft !== (that.rightToLeft ? 0 : tabStrip.scrollWidth) && event.clientX >= tabStripRect.left + tabStripRect.width - Math.max(nearTabStripScrollButtonOffsetLeft, 20)) { continueOperation(1); } else { clearInterval(that._scrollInterval); that._scrollInterval = undefined; } }, 1); } let lastTabItemOffsetLeft = 0, lastTabItemOffsetTop = 0, width, height; //Tab header item if (that._dragDetails.hoveredTabArea) { width = that._dragDetails.hoveredTabArea.offsetWidth; height = that._dragDetails.hoveredTabArea.offsetHeight; lastTabItemOffsetLeft = that._dragDetails.hoveredTabArea.offsetLeft; lastTabItemOffsetTop = that._dragDetails.hoveredTabArea.offsetTop; } else { if (tabStrip.children.length > 0) { const lastTabItem = tabsElement.$.tabStrip.children[tabsElement.$.tabStrip.children.length - 1]; lastTabItemOffsetLeft = lastTabItem.offsetLeft + (that.rightToLeft ? -1 : 1) * (!isTabPositionVertical ? lastTabItem.offsetWidth : 0); lastTabItemOffsetTop = lastTabItem.offsetTop + (isTabPositionVertical ? lastTabItem.offsetHeight : 0); width = lastTabItem.offsetWidth; height = lastTabItem.offsetHeight; } } //In case no item is hovered, use the whole tabHeaderSection offsets that._dragDetails.hoveredTabArea = tabsElement.$.tabsHeaderSection; const hoveredAreaRect = that._dragDetails.hoveredTabArea.getBoundingClientRect(), left = (tabStripRect.left - hoveredAreaRect.left) + hoveredAreaRect.left + lastTabItemOffsetLeft - scrollLeft - nearTabStripScrollButtonOffsetLeft, top = (tabStripRect.top - hoveredAreaRect.top) + hoveredAreaRect.top + lastTabItemOffsetTop - tabStrip.scrollTop - nearTabStripScrollButtonOffsetTop, leftHiddenSize = Math.min(lastTabItemOffsetLeft - scrollLeft - nearTabStripScrollButtonOffsetLeft, 0), topHiddenSize = Math.min(lastTabItemOffsetTop - tabStrip.scrollTop - nearTabStripScrollButtonOffsetTop, 0); return { width: Math.min(tabStripRect.width, Math.max(0, width + leftHiddenSize), Math.max(0, tabStripRect.left + tabStripRect.width - left)), height: Math.min(tabStripRect.height, Math.max(0, height + topHiddenSize), Math.max(0, tabStripRect.top + tabStripRect.height - top)), top: top + window.pageYOffset - topHiddenSize, left: left + window.pageXOffset - leftHiddenSize }; } /** * Handles AutoSaveState property */ _handleAutoSave() { const that = this; if (!that.autoSaveState) { return; } that.saveState(); } /** * Hides the Splitter Bars that are before or after a locked auto-hidden item */ _handleAutoHiddenSplitterBars() { const that = this, autoHiddenItems = that.$.itemsContainer.querySelectorAll('.auto-hide-left,.auto-hide-right, .auto-hide-top, .auto-hide-bottom'); for (let i = 0; i < autoHiddenItems.length; i++) { if (autoHiddenItems[i].previousElementSibling instanceof LW.SplitterBar) { autoHiddenItems[i].previousElementSibling.hide(); } else if (autoHiddenItems[i].nextElementSibling instanceof LW.SplitterBar) { autoHiddenItems[i].nextElementSibling.hide(); } } } /** * Handle item insertion with position */ _handleItemPositionInserting(item, targetItem, position) { const that = this; if (item.autoHide || position.indexOf('layout') > -1) { that._handleLayoutItemInserting(targetItem, item, position); } else if (position.indexOf('outside-') > -1) { that._handleOutsideItemInserting(targetItem, item, position); } else { if (position.indexOf('inside-') > -1) { that._handleInsideItemInserting(targetItem, item, position) } else { that._handleNormalItemInserting(targetItem, item, position); } that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'dock', item: item }); that._setSplitterBarVisibility(); } } /** * Creates a new Splitter when nesting items * @param {any} targetItem */ _handleInsideItemInserting(targetItem, item, position) { const that = this, newItem = document.createElement('lw-splitter-item'), newHostItem = document.createElement('lw-splitter-item'); let targetSplitterItem = targetItem.closest('lw-splitter-item'), targetSplitter = targetItem.closest('lw-splitter'), targetItemIndex = that._items.indexOf(targetItem), newSplitter; if (targetSplitter && targetSplitter._items.length === 1) { newSplitter = targetSplitter; } else { newSplitter = document.createElement('lw-splitter'); } newSplitter._isInShadowDOM = that.isInShadowDOM; newSplitter.autoFitMode = 'proportional'; newSplitter.liveResize = that.liveResize; newSplitter.resizeStep = that.resizeStep; item.windowParent = null; newItem.appendChild(item); targetItem.windowParent = null; position = position.replace('inside-', ''); newSplitter.orientation = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical'; const newItemMaxSize = targetSplitterItem[newSplitter.orientation === 'horizontal' ? 'offsetHeight' : 'offsetWidth'] / 2; if (newSplitter.parentElement) { newSplitter.insertBefore(newItem, position === 'top' || position === 'left' ? targetSplitterItem : null); } else { newHostItem.appendChild(targetItem); if (targetItem.min) { newHostItem.min = targetItem.min; } if (position === 'top' || position === 'left') { newSplitter.appendChild(newItem); newSplitter.appendChild(newHostItem); } else { newSplitter.appendChild(newHostItem); newSplitter.appendChild(newItem); } targetSplitterItem.appendChild(newSplitter); } if (item.size) { const isInPercentages = typeof (item.size) === 'string' && item.size.indexOf('%') > -1; newItem.size = isInPercentages ? item.size : Math.min(newItemMaxSize, parseFloat(item.size)); } newItem.max = item.max || ''; newItem.min = item.min ? item.min : 30; newItem.locked = item.locked || false; newItem.collapsible = item.collapsible || false; newItem.collapsed = item.collapsed || false; if (position === 'bottom' || position === 'right') { targetItemIndex = Math.min(targetItemIndex + 1, that._items.length); } item.pinned = true; item.autoHide = item.allowToggle = item.maximized = item.minimized = item.collapsed = false; if (item._originalTabPosition) { item.tabPosition = item._originalTabPosition; delete item._originalTabPosition; } else { item.tabPosition = 'top'; } if (item._originalTextOrientation) { item.tabTextOrientation = item._originalTextOrientation; delete item._originalTextOrientation; } else { item.tabTextOrientation = 'horizontal'; } that._items.splice(targetItemIndex, 0, item); that._handleAutoHiddenSplitterBars(); } /** * Creates a new Splitter inside the main layout * @param {any} targetItem */ _handleLayoutItemInserting(targetItem, item, position) { const that = this, newSplitterItem = document.createElement('lw-splitter-item'), size = position === 'bottom' || position === 'top' ? 'offsetHeight' : 'offsetWidth'; if (!item.size) { item.size = item[size]; } position = position.replace('layout-', ''); newSplitterItem.size = item.size || ''; newSplitterItem.max = item.max || ''; newSplitterItem.min = item.min || ''; newSplitterItem.locked = item.locked || false; newSplitterItem.collapsible = item.collapsible || false; newSplitterItem.collapsed = item.collapsed || false; if (newSplitterItem.size && !that._dockingAutoHideTabItem) { newSplitterItem.size = Math.min(that[size] / 2, parseFloat(item.size)); } if (that.$.itemsContainer.orientation === 'horizontal' && (position === 'right' || position === 'left') || that.$.itemsContainer.orientation === 'vertical' && (position === 'top' || position === 'bottom')) { let newSplitterItemWithCurrentItems, currentItemsContainerOrientation = that.$.itemsContainer.orientation; const mainSplitter = that.$.itemsContainer, currentItems = [].slice.call(mainSplitter._items), appendItemsToMainSplitter = function (currentItem, newItem) { mainSplitter.appendChild(currentItem); mainSplitter.insertBefore(newItem, position === 'right' || position === 'bottom' ? null : currentItem); }; item.windowParent = null; newSplitterItem.appendChild(item); currentItems.map(item => item.size = item[mainSplitter._measurements.size]); const isLastItem = position === 'right' || position === 'bottom'; isLastItem ? that._items.push(item) : that._items.splice(0, 0, item); mainSplitter.removeAll(); mainSplitter.orientation = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical'; const newSplitterItemWithCurrentItemsSize = mainSplitter[mainSplitter._measurements.size] - newSplitterItem.size; if (currentItems.length > 1) { const currentItemsSplitter = document.createElement('lw-splitter'); currentItemsSplitter._isInShadowDOM = that.isInShadowDOM; //The insert item logic of 'end' mode is needed currentItemsSplitter.autoFitMode = 'end'; currentItemsSplitter.orientation = currentItemsContainerOrientation; currentItemsSplitter.liveResize = that.liveResize; currentItemsSplitter.resizeStep = that.resizeStep; newSplitterItemWithCurrentItems = document.createElement('lw-splitter-item'); //Setting a default min newSplitterItemWithCurrentItems.min = 30; newSplitterItemWithCurrentItems.appendChild(currentItemsSplitter); newSplitterItemWithCurrentItems.size = newSplitterItemWithCurrentItemsSize; appendItemsToMainSplitter(newSplitterItemWithCurrentItems, newSplitterItem); //Append the items in the approriate order so their size can be calculated properly for (let i = 0; i < currentItems.length; i++) { currentItemsSplitter.appendChild(currentItems[i]); } currentItemsSplitter.autoFitMode = 'proportional'; } else { currentItems[0].size = newSplitterItemWithCurrentItemsSize; if (that._dockingAutoHideTabItem) { mainSplitter.autoFitMode = 'end'; } appendItemsToMainSplitter(currentItems[0], newSplitterItem); mainSplitter.autoFitMode = 'proportional'; } that._handleAutoHiddenSplitterBars(); that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'dock', item: item }); that._setSplitterBarVisibility(); } else { const itemToBeInsertedBefore = position.indexOf('left') > -1 || position.indexOf('top') > -1 ? that._items.filter(item => item.opened)[0] : undefined; item.windowParent = null; newSplitterItem.appendChild(item); that.insertBefore(newSplitterItem, itemToBeInsertedBefore, that.$.itemsContainer); return true; } } /** * Inserts a new item in the same splitter as the target item at a specified position * @param {any} targetItem * @param {any} item * @param {any} position */ _handleNormalItemInserting(targetItem, item, position) { let targetSplitterItem = targetItem.closest('lw-splitter-item'); const that = this, targetSplitter = targetItem.closest('lw-splitter'), newItem = document.createElement('lw-splitter-item'), targetSplitterItemIndex = position === 'right' || position === 'bottom' ? targetSplitter._items.indexOf(targetSplitterItem) + 1 : targetSplitter._items.indexOf(targetSplitterItem); let targetItemIndex = that._items.indexOf(targetItem); item.windowParent = null; newItem.appendChild(item); newItem.size = item.size || ''; newItem.min = item.min || ''; targetSplitter.insert(targetSplitterItemIndex, newItem); if (position === 'bottom' || position === 'right') { targetItemIndex = Math.min(targetItemIndex + 1, that._items.length); } item.pinned = true; item.locked = false; item.autoHide = item.allowToggle = item.maximized = item.minimized = item.collapsed = false; if (item._originalTabPosition) { item.tabPosition = item._originalTabPosition; delete that._originalTabPosition; } else { item.tabPosition = 'top'; } if (item._originalTextOrientation) { item.tabTextOrientation = item._originalTextOrientation; delete item._originalTextOrientation; } else { item.tabTextOrientation = 'horizontal'; } that._items.splice(targetItemIndex, 0, item); that._handleAutoHiddenSplitterBars(); } /** * Inserts the new item outside of the target by nesting the target and it's splitter ( if possible) inside a new splitter item * @param {any} targetItem * @param {any} item * @param {any} position */ _handleOutsideItemInserting(targetItem, item, position) { const that = this, newSplitterItem = document.createElement('lw-splitter-item'); let targetSplitter = targetItem.closest('lw-splitter'); if (!targetSplitter) { targetSplitter = that.$.itemsContainer; } newSplitterItem.size = item.size || ''; newSplitterItem.max = item.max || ''; newSplitterItem.min = item.min || ''; newSplitterItem.locked = item.locked || false; newSplitterItem.collapsible = item.collapsible || false; newSplitterItem.collapsed = item.collapsed || false; if (targetSplitter !== that.$.itemsContainer) { let targetSplitterItem = targetSplitter.closest('lw-splitter-item'); const newSplitter = document.createElement('lw-splitter'), newSplitterItemWithCurrentItems = document.createElement('lw-splitter-item'); newSplitter._isInShadowDOM = that.isInShadowDOM; position = position.replace('outside-', ''); newSplitter.autoFitMode = 'proportional'; newSplitter.liveResize = that.liveResize; newSplitter.resizeStep = that.resizeStep; item.windowParent = null; newSplitterItem.appendChild(item); //Setting a default min for the item newSplitterItemWithCurrentItems.min = 30; newSplitterItemWithCurrentItems.appendChild(targetSplitter); newSplitter.orientation = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical'; targetSplitterItem.appendChild(newSplitter); if (position === 'right' || position === 'bottom') { newSplitter.appendChild(newSplitterItemWithCurrentItems); newSplitter.appendChild(newSplitterItem); that._items.splice(that._items.indexOf(targetItem) + 1, 0, item); } else { newSplitter.appendChild(newSplitterItem); newSplitter.appendChild(newSplitterItemWithCurrentItems); that._items.splice(that._items.indexOf(targetItem), 0, item); } if (!newSplitterItem.size) { newSplitterItem.size = newSplitter[newSplitter._measurements.size] / 2; } else { const newSize = newSplitterItem.size; newSplitterItem.size = ''; newSplitterItem.size = newSize; } that._handleAutoHiddenSplitterBars(); that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'dock', item: item }); that._setSplitterBarVisibility(); } else { item.windowParent = null; newSplitterItem.appendChild(item); that.insertBefore(newSplitterItem, position.indexOf('left') > -1 || position.indexOf('top') > -1 ? that._items[0] : undefined, that.$.itemsContainer); return true; } } /** * Apply the layout */ _handleLayout() { const that = this; that._items = []; if (typeof that.layout === 'string') { that.layout = JSON.parse(that.layout); } if (that.layout !== null && Array.isArray(that.layout)) { that._createItemsFromArray(that.layout); return; } const initialItems = Array.from(that.$.itemsContainer.children); that.$.itemsContainer.innerHTML = ''; for (let i = 0; i < initialItems.length; i++) { if (initialItems[i].tagName !== 'LW-TABS-WINDOW') { initialItems[i].parentElement.removeChild(initialItems[i]); } initialItems[i].layout = that; const splitterItem = document.createElement('lw-splitter-item'); splitterItem.appendChild(initialItems[i]); that.$.itemsContainer.appendChild(splitterItem); that._items.push(initialItems[i]); } } /** * Handles the snapping feedback * @param {any} position */ _handleSnapping(position, event) { const that = this; if (that.snapMode === 'simple') { that._handleSimpleSnapping(position, event); } else { that._handleAdvancedSnapping(event); } } /** * Handles Advanced snapping mode */ _handleAdvancedSnapping(event) { const that = this; if (!that._dragDetails) { return; } if (that._snapFeedback && !that._dragDetails.hoveredTabsWindow) { that._snapFeedback._position = undefined; if (that._snapFeedback.areaHighlighter && that.getShadowRootOrBody().contains(that._snapFeedback.areaHighlighter)) { that._snapFeedback.areaHighlighter.remove(); } if (that._snapFeedback.headerHighlighter && that.getShadowRootOrBody().contains(that._snapFeedback.headerHighlighter)) { that._snapFeedback.headerHighlighter.remove(); } if (!that._dragDetails.hoveredItem) { if (that._snapFeedback.innerSnapElement && that.getShadowRootOrBody().contains(that._snapFeedback.innerSnapElement)) { that._snapFeedback.innerSnapElement.remove(); } if (that._snapFeedback.outherSnapElement && !that._dragDetails.isInsideTheLayout) { const outherElements = [].slice.call(that.$.container.children); for (let i = 0; i < outherElements.length; i++) { if (outherElements[i].className.indexOf('lw-docking-layout-snap') > -1) { that._snapFeedback.outherSnapElement.appendChild(outherElements[i]); } } } return; } } if (!that._snapFeedback) { that._snapFeedback = { innerSnapElement: document.createElement('div'), outherSnapElement: document.createElement('div'), areaHighlighter: document.createElement('div'), headerHighlighter: document.createElement('div') }; that._snapFeedback.innerSnapElement.classList.add('lw-docking-layout-snap'); that._snapFeedback.areaHighlighter.classList.add('lw-docking-layout-snap-highlighter'); that._snapFeedback.headerHighlighter.classList.add('lw-docking-layout-snap-highlighter-header'); that._snapFeedback.innerSnapElement.innerHTML = ` <div> <div class="top"> <div><div></div></div> </div> </div> <div> <div class="left"> <div><div></div></div> </div> <div class="center"> <div><div></div></div> </div> <div class="right"> <div><div></div></div> </div> </div> <div> <div class="bottom"> <div><div></div></div> </div> </div>`; that._snapFeedback.outherSnapElement.innerHTML = ` <div class="lw-docking-layout-snap layout-top"> <div><div></div></div> </div> <div class="lw-docking-layout-snap layout-left"> <div><div></div></div> </div> <div class="lw-docking-layout-snap layout-right"> <div><div></div></div> </div> <div class="lw-docking-layout-snap layout-bottom"> <div><div></div></div> </div>`; } if (that._snapFeedback.areaHighlighter.parentElement) { that._snapFeedback.areaHighlighter.removeAttribute('position'); that._snapFeedback.areaHighlighter.classList.remove('lw-hidden'); } that._snapFeedback.areaHighlighter.style.width = ''; that._snapFeedback.areaHighlighter.style.height = ''; that._snapFeedback._position = that._dragDetails.hoveredItem && !(that._dragDetails.hoveredItem instanceof LW.SplitterItem) ? that._dragDetails.hoveredItem.className : ''; if (that._dragDetails.hoveredItem && that._dragDetails.hoveredItem.className.indexOf('layout-') > -1) { that._snapFeedback._position = that._snapFeedback._position.replace('lw-docking-layout-snap ', ''); that._snapFeedback.areaHighlighter.setAttribute('position', that._snapFeedback._position); const selectedTabsWindow = that._dragDetails.selectedTabsWindow; if (selectedTabsWindow.dropPosition.indexOf('all') > -1 || selectedTabsWindow.dropPosition.indexOf(that._snapFeedback._position) > -1) { that._dragDetails.hoveredItem.setAttribute('show', ''); that.$.container.appendChild(that._snapFeedback.areaHighlighter); that._dragDetails.hoveredTabsWindow = true; //Sets the size of the outher(layout) highlighters if (['layout-left', 'layout-right'].indexOf(that._snapFeedback._position) > -1) { that._snapFeedback.areaHighlighter.style.width = that._dragDetails.windowFeedback.style.width || (that._dragDetails.windowFeedback.offsetWidth + 'px'); } else if (['layout-top', 'layout-bottom'].indexOf(that._snapFeedback._position) > -1) { that._snapFeedback.areaHighlighter.style.height = that._dragDetails.windowFeedback.style.height || (that._dragDetails.windowFeedback.offsetHeight + 'px'); } } else { that._dragDetails.hoveredItem.removeAttribute('show'); that._snapFeedback._position = undefined; } return; } let dropPosition = that._dragDetails.hoveredTabsWindow ? that._dragDetails.hoveredTabsWindow.dropPosition : ['all']; if (dropPosition.length === 0) { dropPosition = ['all']; } if (that._dragDetails.hoveredTabsWindow instanceof LW.TabsWindow && that._dragDetails.hoveredTabArea && that._dragDetails.hoveredTabArea.closest('.lw-tabs-header-section') && (dropPosition.indexOf('all') > -1 || dropPosition.indexOf('header') > -1)) { that._dragDetails.hoveredTabArea = that._dragDetails.hoveredTabArea.classList.contains('lw-tab-label-container') ? that._dragDetails.hoveredTabArea : undefined; const dimensions = that._getHeaderLabelDimensions(event), headerHighLighter = that._snapFeedback.headerHighlighter; headerHighLighter.style.width = dimensions.width + 'px'; headerHighLighter.style.height = dimensions.height + 'px'; headerHighLighter.style.top = dimensions.top + 'px'; headerHighLighter.style.left = dimensions.left + 'px'; headerHighLighter.classList.remove('lw-hidden'); if (!that.getShadowRootOrBody().contains(headerHighLighter)) { that.getShadowRootOrBody().appendChild(headerHighLighter); } that._snapFeedback._position = 'header'; } else { if (that._scrollInterval) { clearInterval(that._scrollInterval); that._scrollInterval = undefined; } that._snapFeedback.headerHighlighter.style.width = that._snapFeedback.headerHighlighter.style.height = 0; } const innerSnapElementParent = that._snapFeedback.innerSnapElement.closest('lw-splitter-item'); if (that._dragDetails.hoveredItem instanceof LW.SplitterItem) { if (innerSnapElementParent && that._dragDetails.hoveredItem !== innerSnapElementParent) { innerSnapElementParent.removeChild(that._snapFeedback.innerSnapElement); } if (that._dragDetails.hoveredItem.className.indexOf('auto-hide') < 0) { const highlighSections = that._snapFeedback.innerSnapElement.querySelectorAll('.top, .bottom, .left, .right, .center'); for (let i = 0; i < highlighSections.length; i++) { if (dropPosition.indexOf(highlighSections[i].className) > -1 || dropPosition.indexOf('all') === 0) { highlighSections[i].setAttribute('show', ''); } else { highlighSections[i].removeAttribute('show'); } } that._snapFeedback.innerSnapElement.classList.remove('lw-hidden'); if (!that._dragDetails.hoveredItem.contains(that._snapFeedback.innerSnapElement)) { that._dragDetails.hoveredItem.appendChild(that._snapFeedback.innerSnapElement); } } const outherElements = [].slice.call(that._snapFeedback.outherSnapElement.children), selectedTabsWindow = that._dragDetails.selectedTabsWindow; let position; for (let i = 0; i < outherElements.length; i++) { position = outherElements[i].className.replace('lw-docking-layout-snap ', ''); outherElements[i].classList.remove('lw-hidden'); if (selectedTabsWindow.dropPosition.indexOf('all') > -1 || selectedTabsWindow.dropPosition.indexOf(position) > -1) { outherElements[i].setAttribute('show', ''); } else { outherElements[i].removeAttribute('show'); } that.$.container.appendChild(outherElements[i]); } } if (!that._snapFeedback._position || dropPosition.indexOf('all') < 0 && dropPosition.indexOf(that._snapFeedback._position) < 0) { that._snapFeedback._position = that._dragDetails.hoveredTabArea = undefined; return; } if (that._snapFeedback._position === 'center' && that._items.filter(item => item.opened).length > 0) { that._dragDetails.hoveredTabArea = that._dragDetails.hoveredTabsWindow.$.tabsElement.$.tabsHeaderSection; } //Sets the size of the inner highlighters if (['left', 'right'].indexOf(that._snapFeedback._position) > -1) { that._snapFeedback.areaHighlighter.style.width = that._dragDetails.windowFeedback.style.width || (that._dragDetails.windowFeedback.offsetWidth + 'px'); } else if (['top', 'bottom'].indexOf(that._snapFeedback._position) > -1) { that._snapFeedback.areaHighlighter.style.height = that._dragDetails.windowFeedback.style.height || (that._dragDetails.windowFeedback.offsetHeight + 'px'); } that._snapFeedback.areaHighlighter.setAttribute('position', that._snapFeedback._position); if (that._snapFeedback._position === 'header') { that._dragDetails.hoveredTabsWindow.$.tabsElement.$.tabContentSection.appendChild(that._snapFeedback.areaHighlighter); } else { const orientation = that._dragDetails.hoveredTabsWindow.closest('lw-splitter').orientation; if (((that._snapFeedback._position === 'left' || that._snapFeedback._position === 'right') && orientation === 'horizontal') || ((that._snapFeedback._position === 'top' || that._snapFeedback._position === 'bottom') && orientation === 'vertical')) { that._snapFeedback._position = 'inside-' + that._snapFeedback._position; } that._dragDetails.hoveredItem.closest('lw-splitter-item').appendChild(that._snapFeedback.areaHighlighter); } } /** * Handles Simple snapping mode * @param {any} position */ _handleSimpleSnapping(position, event) { const that = this; function transitionEndHandler() { if (that._snapFeedback.classList.contains('lw-visibility-hidden') && that.getShadowRootOrBody().contains(that._snapFeedback)) { that._snapFeedback.remove(); } } if (!position) { if (that._dragDetails) { that._dragDetails.hoveredTabsWindow = that._dragDetails.hoveredTabArea = undefined; } if (that._snapFeedback instanceof HTMLElement) { that._snapFeedback._position = undefined; if (that.getShadowRootOrBody().contains(that._snapFeedback)) { that._snapFeedback.classList.add('lw-visibility-hidden'); } } return; } if (!that._snapFeedback) { that._snapFeedback = document.createElement('div'); that._snapFeedback.addEventListener('transitionend', transitionEndHandler); } for (let i = 0; i < that._snapFeedback.classList.length; i++) { if (that._snapFeedback.classList[i].indexOf('lw-docking-snap-') > -1) { that._snapFeedback.classList.remove(that._snapFeedback.classList[i]); } } that._snapFeedback._position = position; position = position.replace('inside-', ''); that._snapFeedback.classList.add('lw-docking-snap-' + position + '-feedback'); that._snapFeedback.classList.remove('lw-visibility-hidden'); let dropPosition = position.indexOf('layout') === 0 ? that._dragDetails.selectedTabsWindow.dropPosition : that._dragDetails.hoveredTabsWindow.dropPosition; if (dropPosition.length === 0) { dropPosition = ['all']; } if (dropPosition.indexOf('all') > -1 || dropPosition.indexOf(position) > -1) { that._snapFeedback.removeAttribute('disabled'); } else { that._snapFeedback.setAttribute('disabled', ''); that._snapFeedback._position = undefined; } let width, height, top, left, hoveredAreaRect; const layoutRect = that.getBoundingClientRect(), tabsWindowStyles = getComputedStyle(that._dragDetails.hoveredTabsWindow.$.contentSection), paddingLeft = parseFloat(tabsWindowStyles.getPropertyValue('padding-left') || 0), paddingRight = parseFloat(tabsWindowStyles.getPropertyValue('padding-right') || 0), paddingTop = parseFloat(tabsWindowStyles.getPropertyValue('padding-top') || 0), paddingBottom = parseFloat(tabsWindowStyles.getPropertyValue('padding-bottom') || 0), leftHiddenItem = that.$.verticalHiddenItemsContainer.getElementsByClassName('auto-hide-left')[0], topHiddenItem = that.$.horizontalHiddenItemsContainer.getElementsByClassName('auto-hide-top')[0]; //Resets the highlighter that._snapFeedback.style.display = ''; switch (position) { case 'header': { const dimensions = that._getHeaderLabelDimensions(event); width = dimensions.width; height = dimensions.height; top = dimensions.top; left = dimensions.left; //Hides the highlighter if it's overflowing if (!width || !height) { that._snapFeedback.style.display = 'none'; } break; } case 'left': case 'right': hoveredAreaRect = that._dragDetails.hoveredTabArea.getBoundingClientRect(); height = that._dragDetails.hoveredTabArea.offsetHeight; width = that._dragDetails.hoveredTabArea.offsetWidth / 2; top = hoveredAreaRect.top + window.pageYOffset; left = hoveredAreaRect.left + (position === 'right' ? that._dragDetails.hoveredTabArea.offsetWidth / 2 : 0) + window.pageXOffset; break; case 'top': case 'bottom': hoveredAreaRect = that._dragDetails.hoveredTabArea.getBoundingClientRect(); height = that._dragDetails.hoveredTabArea.offsetHeight / 2; width = that._dragDetails.hoveredTabArea.offsetWidth; top = hoveredAreaRect.top + window.pageYOffset + (position === 'bottom' ? that._dragDetails.hoveredTabArea.offsetHeight / 2 : 0); left = hoveredAreaRect.left + window.pageXOffset; break; case 'layout-left': case 'layout-right': { if (that.getShadowRootOrBody().contains(that._snapFeedback) && that._snapFeedback.maxWidth === undefined) { that._snapFeedback.maxWidth = parseFloat(getComputedStyle(that._snapFeedback).getPropertyValue('max-width')) || 0; } width = that.$.itemsContainer.offsetWidth * 0.07 - (paddingLeft + paddingRight); if (that._snapFeedback.maxWidth) { width = Math.min(that._snapFeedback.maxWidth, width); } height = that.$.itemsContainer.offsetHeight - (paddingTop + paddingBottom); top = layoutRect.top + window.pageYOffset + paddingTop + (topHiddenItem ? topHiddenItem.offsetHeight : 0); left = layoutRect.left + window.pageXOffset + (position === 'layout-left' ? paddingLeft : 0) + (leftHiddenItem ? leftHiddenItem.offsetWidth : 0) + (position === 'layout-right' ? that.$.itemsContainer.offsetWidth - width - paddingRight : 0); break; } case 'layout-top': case 'layout-bottom': if (that.getShadowRootOrBody().contains(that._snapFeedback) && that._snapFeedback.maxHeight === undefined) { that._snapFeedback.maxHeight = parseFloat(getComputedStyle(that._snapFeedback).getPropertyValue('max-height')) || 0; } height = that.$.itemsContainer.offsetHeight * 0.07 - (paddingTop + paddingBottom); if (that._snapFeedback.maxHeight) { height = Math.min(that._snapFeedback.maxHeight, height); } width = that.$.itemsContainer.offsetWidth - (paddingLeft + paddingRight); top = layoutRect.top + window.pageYOffset + (topHiddenItem ? topHiddenItem.offsetHeight : 0) + (position === 'layout-bottom' ? that.$.itemsContainer.offsetHeight - height + paddingTop : paddingTop); left = layoutRect.left + window.pageXOffset + paddingLeft + (leftHiddenItem ? leftHiddenItem.offsetWidth : 0); break; } that._snapFeedback.style.height = height + 'px'; that._snapFeedback.style.width = width + 'px'; that._snapFeedback.style.left = left + 'px'; that._snapFeedback.style.top = top + 'px'; if (!that._snapFeedback._position) { that._dragDetails.hoveredTabArea = undefined; } if ((that._snapFeedback && !that.getShadowRootOrBody().contains(that._snapFeedback))) { that.getShadowRootOrBody().appendChild(that._snapFeedback); } } /** * Nest item inside another item. **/ _handleItemNesting() { const that = this; let targetWindow = that._dragDetails.windowFeedback; if (targetWindow.classList.contains('lw-tabs-window-feedback')) { let newWindow = document.createElement('lw-tabs-window'); const selectedTabItem = that._dragDetails.selectedTabLabel.tab; newWindow.min = 30; newWindow.opened = newWindow.pinned = true; newWindow.headerPosition = that._dragDetails.selectedTabsWindow.headerPosition; if (that._dragDetails.selectedTabsWindow.autoHide) { newWindow.tabTextOrientation = that._dragDetails.selectedTabsWindow._originalTextOrientation || 'horizontal'; newWindow.tabPosition = that._dragDetails.selectedTabsWindow._originalTabPosition || 'top'; } else { newWindow.tabPosition = that._dragDetails.selectedTabsWindow.tabPosition; newWindow.tabTextOrientation = that._dragDetails.selectedTabsWindow.tabTextOrientation; } newWindow.animation = that.animation; newWindow.rightToLeft = that.rightToLeft; newWindow.theme = that.theme; if (that._snapFeedback._position.indexOf('top') > -1 || that._snapFeedback._position.indexOf('bottom') > -1) { newWindow.size = parseFloat(targetWindow.style.height) || targetWindow.offsetHeight; } else { newWindow.size = parseFloat(targetWindow.style.width) || targetWindow.offsetWidth; } newWindow.label = selectedTabItem.label; newWindow.id = ''; that._dragDetails.windowFeedback.removeChild(selectedTabItem); newWindow.appendChild(selectedTabItem); newWindow.style.left = newWindow.style.top = ''; newWindow.draggable = selectedTabItem.draggable !== undefined ? selectedTabItem.draggable : true; newWindow.floatable = selectedTabItem.floatable !== undefined ? selectedTabItem.floatable : true; targetWindow = newWindow; } else { //Returns the window to it's initial position const context = targetWindow.context; targetWindow.context = targetWindow; targetWindow.windowParent = null; targetWindow.context = context; targetWindow.animation = that.animation; targetWindow.rightToLeft = that.rightToLeft; targetWindow.theme = that.theme; if (that._snapFeedback._position.indexOf('top') > -1 || that._snapFeedback._position.indexOf('bottom') > -1) { targetWindow.size = parseFloat(targetWindow.style.height) || targetWindow.offsetHeight; } else { targetWindow.size = parseFloat(targetWindow.style.width) || targetWindow.offsetWidth; } targetWindow.style.top = targetWindow.style.left = targetWindow.style.width = targetWindow.style.height = ''; targetWindow.pinned = true; //targetWindow.locked = false; if (!targetWindow._originalTabPosition) { targetWindow._originalTabPosition = targetWindow.tabPosition; } } that._insert(that._items.indexOf(that._dragDetails.hoveredTabsWindow), targetWindow, that._snapFeedback._position); that._disownTabWindow(targetWindow); return targetWindow; } /** * Handles windows that are not dummies while dragging. Applies settings and caches data related to them. */ _handleWindowOnDrag() { const that = this; //Avoids unnecessary calls if (that._dragDetails.windowFeedback.hasAttribute('dragged')) { return; } let selectedItem = that._dragDetails.selectedItem, selectedTabsWindow = that._dragDetails.selectedTabsWindow, closestSplitter = selectedTabsWindow.closest('lw-splitter'); that._setWindowFeedbackSize(); if (selectedTabsWindow === that.$.autoHideWindow && !that._dragDetails._parentInfo) { that._dragDetails._parentInfo = {}; if (selectedTabsWindow._tabsWindow.items.length > 1) { that._dragDetails._parentInfo.closestItem = selectedTabsWindow._tabsWindow; that._dragDetails._parentInfo.position = that.$.autoHideWindow._tab.index; } else { that._dragDetails._parentInfo.closestItem = that.$.itemsContainer; that._dragDetails._parentInfo.position = selectedTabsWindow._tabsWindow.tabPosition; that._dragDetails.windowFeedback.headerButtons = that.$.autoHideWindow._tabsWindow.headerButtons; that._noStateChangeFiring = true; that.undock(that._dragDetails.windowFeedback); } that._originalTabIndex = undefined; } else { if (closestSplitter && closestSplitter !== that.$.itemsContainer && closestSplitter._items.length === 1) { while (closestSplitter._items.length === 1 && closestSplitter !== that.$.itemsContainer) { closestSplitter = closestSplitter.parentElement.closest('lw-splitter'); selectedItem = selectedItem.parentElement.closest('lw-splitter-item'); } } if (!that._dragDetails._parentInfo) { that._dragDetails._parentInfo = {}; if (selectedTabsWindow.closest('lw-docking-layout') === that || that._getClosestDockingLayout(selectedTabsWindow) === that) { if (selectedTabsWindow.autoHide) { that._dragDetails._parentInfo.closestItem = that.$.itemsContainer; that._dragDetails._parentInfo.position = selectedTabsWindow.tabPosition; if (selectedTabsWindow._originalTabPosition) { selectedTabsWindow.tabPosition = selectedTabsWindow._originalTabPosition; } if (selectedTabsWindow._originalTextOrientation) { selectedTabsWindow.tabTextOrientation = selectedTabsWindow._originalTextOrientation; } } else if (closestSplitter) { const selectedItemIndex = closestSplitter._items.indexOf(selectedItem), itemsCount = closestSplitter._items.length; if (itemsCount === 1) { that._dragDetails._parentInfo.position = closestSplitter.orientation === 'horizontal' ? 'top' : 'left'; that._dragDetails._parentInfo.closestItem = undefined; } else { if (selectedItemIndex === 0) { that._dragDetails._parentInfo.position = closestSplitter.orientation === 'horizontal' ? 'top' : 'left'; that._dragDetails._parentInfo.closestItem = closestSplitter._items[selectedItemIndex + 1].getElementsByTagName('lw-tabs-window')[0]; } else { that._dragDetails._parentInfo.position = closestSplitter.orientation === 'horizontal' ? 'bottom' : 'right'; that._dragDetails._parentInfo.closestItem = closestSplitter._items[selectedItemIndex - 1].getElementsByTagName('lw-tabs-window')[0]; } that._dragDetails._parentInfo.closestItemSize = that._dragDetails._parentInfo.closestItem[closestSplitter._measurements.size]; if (closestSplitter !== that._dragDetails._parentInfo.closestItem.closest('lw-splitter')) { if (closestSplitter === that.$.itemsContainer) { that._dragDetails._parentInfo.position = 'layout-' + that._dragDetails._parentInfo.position; } else { that._dragDetails._parentInfo.position = 'outside-' + that._dragDetails._parentInfo.position; } } else if (closestSplitter._items.length === 2) { that._dragDetails._parentInfo.position = 'inside-' + that._dragDetails._parentInfo.position; } } } } else { that._dragDetails._parentInfo.position = { top: selectedTabsWindow.offsetTop, left: selectedTabsWindow.offsetLeft }; } } } if (closestSplitter) { that._dragDetails.windowFeedback.size = that._dragDetails.windowFeedback[closestSplitter._measurements.size]; } else if (selectedTabsWindow === that.$.autoHideWindow) { const autoHidePosition = that.$.autoHideWindow._tabsWindow.tabPosition; that._dragDetails.windowFeedback.size = that.$.autoHideWindow['offset' + (autoHidePosition === 'top' || autoHidePosition === 'bottom' ? 'Height' : 'Width')]; } that._dragDetails.windowFeedback.setAttribute('dragged', ''); if (that._dragDetails.windowFeedback.parentElement !== that.getShadowRootOrBody()) { that._dragDetails.windowFeedback.windowParent = 'body'; that.getShadowRootOrBody().appendChild(that._dragDetails.windowFeedback); that._ownTabWindow(that._dragDetails.windowFeedback); } //Reset tabPosition if ((that.snapMode !== 'advanced' && that._dragDetails.windowFeedback.tabPosition === 'none') || that._dragDetails.windowFeedback.autoHide) { that._dragDetails.windowFeedback.tabPosition = that._dragDetails.windowFeedback._originalTabPosition || 'top'; } //Reset the proeprties of the Window that._dragDetails.windowFeedback.autoHide = false; that._dragDetails.windowFeedback.allowToggle = false; const itemIndex = that._items.indexOf(that._dragDetails.windowFeedback); if (itemIndex > -1) { that._items.splice(itemIndex, 1); } if (selectedItem && selectedItem.parentElement) { if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) { that.$.itemsContainer._items[0].className.indexOf('auto-hide') > -1 ? that.$.itemsContainer.insert(1, that.$.placeholderItem) : that.$.itemsContainer.insert(0, that.$.placeholderItem); } if (closestSplitter) { closestSplitter.removeChild(selectedItem); that._dragDetails.initialSplitterOrientation = closestSplitter.orientation === 'horizontal'; that._removeUnneccessaryItems(closestSplitter); } else if (selectedTabsWindow === that.$.autoHideWindow && that.$.autoHideWindow._tabsWindow.items.length === 0) { that.$.autoHideWindow._tabsWindow.closest('lw-splitter').removeChild(selectedItem); } that._setAutoHidePaddings(); } } /** * Sets the size of the window feedback on documentMove */ _setWindowFeedbackSize() { const that = this, selectedTabsWindow = that._dragDetails.selectedTabsWindow; if (!that._dragDetails._isWindowFeedbackSizeSet) { let width, height; if (selectedTabsWindow.autoHide && selectedTabsWindow._autoHideWindow) { if (selectedTabsWindow.tabPosition === 'top' || selectedTabsWindow.tabPosition === 'bottom') { width = selectedTabsWindow.offsetWidth + 'px'; height = selectedTabsWindow._autoHideWindow.offsetHeight + 'px'; } else { width = selectedTabsWindow._autoHideWindow.offsetWidth + 'px'; height = selectedTabsWindow.offsetHeight + 'px'; } } else { width = selectedTabsWindow.style.width || (selectedTabsWindow.offsetWidth + 'px'); height = selectedTabsWindow.style.height || (selectedTabsWindow.offsetHeight + 'px'); } that._dragDetails.windowFeedback.style.width = width; that._dragDetails.windowFeedback.style.height = height; that._dragDetails._isWindowFeedbackSizeSet = true; } } /** * Inserts a TabsWindow element inside the Layout. * index - lwTabsWindow index or it's instance * item - a lwTabsWindow instance to be inserted * position - defines the position ( top, bottom, left, right ) if the item should be nested */ _insert(index, item, position) { const that = this; let targetItem; if (typeof index === 'string') { targetItem = that._getItemById(item); if (targetItem) { index = that._items.indexOf(targetItem); } } else if (index instanceof LW.TabsWindow && that.contains(index)) { index = that._items.indexOf(index); } if (typeof index !== 'number') { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: arguments[3] || 'insert' })); return; } if (typeof item === 'object' && !(item instanceof HTMLElement)) { item = that._createTabsWindowFromObject(item); } else if (typeof item === 'string') { item = that._getItemById(item); } else if (item instanceof LW.TabItem) { let parentTabsWindow = item.closest('lw-tabs-window'); if (!parentTabsWindow && that.shadowRoot && item.getRootNode() && item.getRootNode().host) { parentTabsWindow = item.getRootNode().host.closest('lw-tabs-window'); } if (parentTabsWindow && parentTabsWindow.autoHide) { that._dock(parentTabsWindow, position); return; } item = that._createTabsWindowFromObject({ label: item.label, items: [{ label: item.label, content: item.content }] }); } if (!item || !(item instanceof LW.TabsWindow)) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: arguments[3] || 'insert' })); return; } if ((that.shadowRoot || that).contains(item) && item.autoHide) { that._dock(item, position); return; } if (position && position.indexOf('layout') > -1) { const openedItems = that._items.filter(item => item.opened); if (openedItems > 0) { index = position.indexOf('left') > -1 || position.indexOf('top') > -1 ? 0 : openedItems[openedItems.length - 1]; } else { index = 0; } } targetItem = that._items[index]; if (that._items[index] && !that._items[index].opened) { targetItem = that._items.filter(item => item.opened)[0]; } if (that._items.length === 0) { that.$.itemsContainer.orientation = position.indexOf('left') > -1 || position.indexOf('right') > -1 ? 'vertical' : 'horizontal'; } item.style.top = item.style.left = ''; item.style.width = item.style.height = ''; item.opened = true; item.pinned = true; const parentSplitterItem = item.closest('lw-splitter-item'); if (!targetItem) { that.insertBefore(item, targetItem || null); if (parentSplitterItem) { let closestSplitter = parentSplitterItem.closest('lw-splitter'); if (!closestSplitter && that.shadowRoot && parentSplitterItem.getRootNode() && parentSplitterItem.getRootNode().host) { closestSplitter = parentSplitterItem.getRootNode().host.closest('lw-splitter'); } if (closestSplitter) { closestSplitter.removeChild(parentSplitterItem); } } return; } delete item._parentInfo; if (item.autoHide) { if (that.$.verticalHiddenItemsContainer.contains(item)) { that.$.verticalHiddenItemsContainer.removeChild(item.closest('lw-splitter-item')) } else if (that.$.horizontalHiddenItemsContainer.contains(item)) { that.$.horizontalHiddenItemsContainer.removeChild(item.closest('lw-splitter-item')) } } if (position) { that._handleItemPositionInserting(item, targetItem, position); } else { that.insertBefore(item, targetItem || null); } if (parentSplitterItem) { const closestSplitter = parentSplitterItem.closest('lw-splitter'); if (closestSplitter) { closestSplitter.removeChild(parentSplitterItem); } } if (item.autoHide) { that._autoHide(item, position); } else { const scrollElement = document.scrollingElement || document.documentElement, x = scrollElement.scrollLeft, y = scrollElement.scrollTop; item.focus(); //Note: Applying focus sometimes breaks the style window.scrollTo(x, y); } if (that._items.filter(item => item.opened).length > 0 && that.$.placeholderItem.parentElement) { that.$.itemsContainer.removeChild(that.$.placeholderItem); } item.layout = that; item.resizeMode = 'none'; item.minimized = false; item.maximized = false; that._setDockedItemsHeaderButtons(item); } /** * Tabs Windows(inside itemsContainer) Close Event Handler * @param {any} event */ _itemsContainerCloseHandler(event) { const that = this; if (event.target instanceof LW.Tabs) { const targetTabs = event.target; if (targetTabs._tabs.length === 0) { that.removeChild(targetTabs.closest('lw-tabs-window')); } return; } if (!(event.target instanceof LW.TabsWindow)) { return; } const splitterItem = event.target.closest('lw-splitter-item'), splitter = splitterItem.closest('lw-splitter'); if (splitter) { splitter.removeChild(splitterItem); that._removeUnneccessaryItems(splitter); } event.target.close(); event.target.remove(); if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) { that.$.itemsContainer.appendChild(that.$.placeholderItem); } } /** * Menu autoHide event handler */ _itemsContainerAutoHideHandler(event) { const that = this, button = event.detail.button, tabsWindow = button.closest('lw-tabs-window') || button.getRootNode().host; if (!tabsWindow) { return; } const closestSplitterItem = tabsWindow.closest('lw-splitter-item'); if (!closestSplitterItem) { return; } const closestSplitter = tabsWindow.closest('lw-splitter'); if (!closestSplitter) { return; } const closestSplitterItems = closestSplitter.items, isHorizontal = closestSplitter.orientation === 'horizontal', isFarItem = closestSplitterItems.indexOf(closestSplitterItem) >= closestSplitterItems.length / 2; if (isHorizontal) { isFarItem ? that.autoHideBottom(tabsWindow) : that.autoHideTop(tabsWindow); } else { isFarItem ? that.autoHideRight(tabsWindow) : that.autoHideLeft(tabsWindow); } } /** * Menu open/close event handler */ _itemsContainerMenuHandler(event) { const that = this, menu = that.$.menu, layoutRect = that.getBoundingClientRect(), menuButtonRect = event.detail.button.getBoundingClientRect(); menu.open(menuButtonRect.left - layoutRect.left, menuButtonRect.top - layoutRect.top); that._menuOpenButton = event.detail.button; } /** * ItemsContainer resizeEnd event handler. Called when a splitter item inside the Layout has been resized */ _itemsContainerResizeHandler() { const that = this, targetItem = event.target._items ? event.target._items[event.detail.firstItem.index] : undefined; that._handleAutoSave(); that.$.fireEvent('stateChange', { type: 'resize', item: targetItem }); } /** * Key down event handler * @param {any} event */ _keyDownHandler(event) { const that = this; if (that.disabled || !that.hasAttribute('dragged') || !that._snapFeedback) { return; } event.preventDefault(); if (event.key === 'Control') { //Hide the snap feedback if (that.snapMode === 'advanced') { for (let el in that._snapFeedback) { if (that._snapFeedback[el] instanceof HTMLElement) { if (el === 'outherSnapElement') { const outherElements = that.$.container.children; for (let i = 0; i < outherElements.length; i++) { if (outherElements[i].className.indexOf('lw-docking-layout-snap') > -1) { outherElements[i].classList.add('lw-hidden'); } } continue; } that._snapFeedback[el].classList.add('lw-hidden'); } } } else { that._snapFeedback.classList.add('lw-hidden'); } } else if (event.key === 'Escape') { that._cancelDragOperation(); } } /** * Key up event handler * @param {any} event */ _keyUpHandler(event) { const that = this; if (that.disabled || event.key !== 'Control' || !that.hasAttribute('dragged') || !that._snapFeedback) { return; } event.preventDefault(); //Show that._snapFeedback if (that.snapMode === 'advanced') { for (let el in that._snapFeedback) { if (that._snapFeedback[el] instanceof HTMLElement) { if (el === 'outherSnapElement') { const outherElements = that.$.container.children; for (let i = 0; i < outherElements.length; i++) { if (outherElements[i].className.indexOf('lw-docking-layout-snap') > -1) { outherElements[i].classList.remove('lw-hidden'); } } continue; } that._snapFeedback[el].classList.remove('lw-hidden'); } } that._handleSnapping(); } else { that._snapFeedback.classList.remove('lw-hidden'); } } /** * Loads the previously saved state to the element * @param {any} state */ _loadState(state) { const that = this; that._createItemsFromArray(state, true); } /** * Removes all Layout items */ _removeAll(noPlaceholder) { const that = this; function removeAutoHideItems(splitter) { const items = splitter._items; if (!items) { return; } for (let i = 0; i < items.length; i++) { if (!items[i].$.hasClass('lw-docking-layout-item-holder')) { splitter.removeChild(items[i]); } } } that.$.itemsContainer.removeAll(); //Remove auto-hidden-items removeAutoHideItems(that.$.horizontalHiddenItemsContainer); removeAutoHideItems(that.$.verticalHiddenItemsContainer); that._items = []; if (!noPlaceholder) { that.$.itemsContainer.appendChild(that.$.placeholderItem); } } /** * Removes unneccessary splitter elements when moving or removing items * @param {any} splitterContainer * @param {any} splitterItemForRemoval */ _removeUnneccessaryItems(splitterContainer) { if (!splitterContainer) { return; } const that = this; let parentItem; while (splitterContainer._items && splitterContainer._items.length === 0 && splitterContainer !== that.$.itemsContainer) { (parentItem = splitterContainer.closest('lw-splitter-item')).removeChild(splitterContainer); splitterContainer = parentItem.closest('lw-splitter'); splitterContainer.removeChild(parentItem); } } /** * Return item to original position * @param {any} item */ _returnItemToOrigin(item) { const that = this; if (!item || !that._dragDetails) { return; } let parentInfo = that._dragDetails._parentInfo; if (!parentInfo) { return; } if (typeof (parentInfo.position) === 'number') { const tabItems = [].slice.call(item.items); for (let i = 0; i < tabItems.length; i++) { item.removeChild(tabItems[i]); parentInfo.closestItem.insert(parentInfo.position, { node: tabItems[i] }); } } else if (typeof parentInfo.position === 'object') { item.style.top = parentInfo.position.top + 'px'; item.style.left = parentInfo.position.left + 'px'; } else { if (!parentInfo.closestItem) { that.appendChild(item); } else { if (parentInfo.closestItem === that.$.itemsContainer) { that._autoHide(item, parentInfo.position); } else { that._insert(that._items.indexOf(parentInfo.closestItem), item, parentInfo.position); } } } } /** * Calculates the paddings if the horizontal autoHidden items if vertical auto hiden items are present. */ _setAutoHidePaddings() { const that = this, leftAutoHiddenItem = that.$.verticalHiddenItemsContainer.getElementsByClassName('auto-hide-left')[0], rightAutoHiddenItem = that.$.verticalHiddenItemsContainer.getElementsByClassName('auto-hide-right')[0], topAutoHiddenitem = that.$.horizontalHiddenItemsContainer.getElementsByClassName('auto-hide-top')[0], bottomAutoHiddenitem = that.$.horizontalHiddenItemsContainer.getElementsByClassName('auto-hide-bottom')[0]; if (topAutoHiddenitem) { topAutoHiddenitem.style.paddingLeft = leftAutoHiddenItem ? leftAutoHiddenItem.offsetWidth + 'px' : ''; topAutoHiddenitem.style.paddingRight = rightAutoHiddenItem ? rightAutoHiddenItem.offsetWidth + 'px' : ''; } if (bottomAutoHiddenitem) { bottomAutoHiddenitem.style.paddingLeft = leftAutoHiddenItem ? leftAutoHiddenItem.offsetWidth + 'px' : ''; bottomAutoHiddenitem.style.paddingRight = rightAutoHiddenItem ? rightAutoHiddenItem.offsetWidth + 'px' : ''; } } /** * Sets the header buttons for all docked items * @param {any} tabsWindow */ _setDockedItemsHeaderButtons(tabsWindow) { let headerButtons = tabsWindow.headerButtons, reservedButtons = ['close', 'maximize', 'minimize']; let dockedItemHeaderButtons = headerButtons.filter(buttonName => reservedButtons.indexOf(buttonName) < 0); if (dockedItemHeaderButtons.length === 0) { dockedItemHeaderButtons = ['close', 'autoHide']; } else { dockedItemHeaderButtons = headerButtons; } tabsWindow.headerButtons = dockedItemHeaderButtons; } /** * Sets the header buttons for the Floating Items * @param {any} tabsWindow */ _setFloatingItemsHeaderButtons(tabsWindow) { const defaultButtons = ['close', 'autoHide']; // ['dock', 'autoHide'] tabsWindow._originalTabPosition = tabsWindow.tabPosition; let floatingItemButtons = tabsWindow.headerButtons.filter(buttonName => defaultButtons.indexOf(buttonName) < 0); //Default FloatingItems buttons if (floatingItemButtons.length === 0) { floatingItemButtons = ['close', 'maximize', 'minimize']; } else { floatingItemButtons = tabsWindow.headerButtons; } tabsWindow.headerButtons = floatingItemButtons; } /** * Sets tab index */ _setFocusable() { const that = this; if (!that.disabled && !that.unfocusable) { let index = that.tabIndex > 0 ? that.tabIndex : 0; that.setAttribute('tabindex', index); } else { that.removeAttribute('tabindex'); } } /** * Checks if snapping highlighters/markers should appear or not */ _setSnappingMarkers(event, tabHeader) { const that = this; let target = LW.Utilities.Core.isMobile ? document.elementFromPoint(event.pageX - window.pageXOffset, event.pageY - window.pageYOffset) : event.originalEvent.target; let isInsideLayout = target.closest && target.closest('lw-docking-layout'); if (target.shadowRoot || that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; } if (!isInsideLayout) { isInsideLayout = that._getClosestDockingLayout(target); } if (that.snapMode === 'advanced') { if (event.ctrlKey) { return; } that._dragDetails.hoveredItem = target.closest('.lw-docking-layout-snap') ? target : (that._dragDetails.hoveredItem && that._dragDetails.hoveredItem.getElementsByTagName('lw-splitter').length > 0 ? undefined : that._dragDetails.hoveredItem); that._dragDetails.hoveredTabArea = tabHeader ? (target.closest('.lw-tab-label-container') || tabHeader) : that._dragDetails.hoveredTabArea; that._handleSnapping('', event); return; } if (!isInsideLayout || isInsideLayout !== that) { that._handleSnapping(); return; } if (!that._dragDetails.hoveredTabsWindow || (that._dragDetails.windowFeedback !== that.$.tabsWindowFeedback && that._dragDetails.hoveredTabsWindow === that._dragDetails.selectedTabsWindow)) { that._dragDetails.hoveredItem = target.closest('.lw-docking-layout-snap') ? target : (that._dragDetails.hoveredItem && that._dragDetails.hoveredItem.getElementsByTagName('lw-splitter').length > 0 ? undefined : that._dragDetails.hoveredItem); that._handleSnapping(); return; } let hoveredTabOffset = {}; if (that._dragDetails.hoveredItem) { const hoveredItemRect = that._dragDetails.hoveredItem.getBoundingClientRect(), mainSplitterRect = that.$.itemsContainer.getBoundingClientRect(); hoveredTabOffset.left = that._dragDetails.hoveredItem ? hoveredItemRect.left - mainSplitterRect.left : 0; hoveredTabOffset.top = that._dragDetails.hoveredItem ? hoveredItemRect.top - mainSplitterRect.top : 0; } else { hoveredTabOffset.left = hoveredTabOffset.top = 0; } const layoutRect = that.getBoundingClientRect(), itemsContainerRect = that.$.itemsContainer.getBoundingClientRect(), left = Math.max(0, event.pageX - window.pageXOffset - layoutRect.left - (itemsContainerRect.left - layoutRect.left)), top = Math.max(0, event.pageY - window.pageYOffset - layoutRect.top - (itemsContainerRect.top - layoutRect.top)); if (that._dragDetails.hoveredTabArea === tabHeader) { that._dragDetails.hoveredTabArea = target.closest('.lw-tab-label-container'); that._handleSnapping('header', event); } else if (that._dragDetails.hoveredItem && !that._dragDetails.hoveredTabsWindow.autoHide) { if (left < that.$.itemsContainer.offsetWidth * 0.05 && left < that._dragDetails.hoveredItem.offsetWidth * 0.15) { that._handleSnapping('layout-left'); } else if (left > that.$.itemsContainer.offsetWidth * 0.95 && left > that._dragDetails.hoveredItem.offsetWidth * 0.85 + that._dragDetails.hoveredItem.offsetLeft) { that._handleSnapping('layout-right'); } else if (top < that.$.itemsContainer.offsetHeight * 0.05) { that._handleSnapping('layout-top'); } else if (top > that.$.itemsContainer.offsetHeight * 0.95) { that._handleSnapping('layout-bottom'); } else if (target.closest('.lw-tabs-content-section')) { const orientation = that._dragDetails.hoveredItem.closest('lw-splitter').orientation; if (left < hoveredTabOffset.left + that._dragDetails.hoveredTabArea.offsetWidth * 0.3) { that._handleSnapping(orientation === 'horizontal' ? 'inside-left' : 'left'); } else if (left > hoveredTabOffset.left + that._dragDetails.hoveredTabArea.offsetWidth * 0.7) { that._handleSnapping(orientation === 'horizontal' ? 'inside-right' : 'right'); } else if (top < hoveredTabOffset.top + that._dragDetails.hoveredTabArea.offsetTop + that._dragDetails.hoveredTabArea.offsetHeight * 0.5 + that._dragDetails.hoveredTabsWindow.$.headerSection.offsetHeight) { that._handleSnapping(orientation === 'vertical' ? 'inside-top' : 'top'); } else { that._handleSnapping(orientation === 'vertical' ? 'inside-bottom' : 'bottom'); } } else { that._handleSnapping(); } } else { that._handleSnapping(); } } /** * Handles the hideSplitterBars property */ _setSplitterBarVisibility() { const that = this, splitterBars = that.$.itemsContainer.getElementsByTagName('lw-splitter-bar'); for (let i = 0; i < splitterBars.length; i++) { that.hideSplitterBars ? splitterBars[i].hide() : splitterBars[i].show(); } } /** * Keeps the window in the browser viewport * @param {any} targetWindow */ _validateWindowPosition(targetWindow) { //Keeps the target inside view if possible. documentElement.clientSize !== scrollElement.clientSize in EDGE and Safari ! targetWindow.$.addClass('no-transition', ''); const scrollElement = document.scrollingElement || document.documentElement; if (scrollElement.scrollTop > 0) { targetWindow.style.top = (parseFloat(targetWindow.style.top) || targetWindow.offsetTop) + 'px'; } else { //Keeps the window in the available ( window ) drop zone targetWindow.style.top = Math.max(0, Math.min(parseFloat(targetWindow.style.top) || targetWindow.offsetTop, document.documentElement.clientHeight - targetWindow.offsetHeight)) + 'px'; } if (scrollElement.scrollLeft > 0) { targetWindow.style.left = (parseFloat(targetWindow.style.left) || targetWindow.offsetLeft) + 'px'; } else { //Keeps the window in the available ( window ) drop zone targetWindow.style.left = Math.max(0, Math.min(parseFloat(targetWindow.style.left) || targetWindow.offsetLeft, document.documentElement.clientWidth - targetWindow.offsetWidth)) + 'px'; } //Avoid transitions requestAnimationFrame(() => targetWindow.$.removeClass('no-transition')); } /** * Sets the WAI-ARIA property aria-owns */ _ownTabWindow(tabWindow) { const that = this, tabWindowId = tabWindow.id; let owns = that.getAttribute('aria-owns'); if (!owns) { that.setAttribute('aria-owns', tabWindowId); return; } owns = owns.split(' '); if (owns.indexOf(tabWindowId) === -1) { owns.push(tabWindowId); that.setAttribute('aria-owns', owns.join(' ')); } } /** * Removes a TabsWindow from the aria-owns collection */ _disownTabWindow(tabWindow) { const that = this, tabWindowId = tabWindow.id; let owns = that.getAttribute('aria-owns'); if (!owns) { return; } owns = owns.split(' '); const index = owns.indexOf(tabWindowId); if (index === -1) { return; } owns.splice(index, 1).join(' '); if (owns.length > 0) { that.setAttribute('aria-owns', owns); } else { that.removeAttribute('aria-owns'); } } /** * Docking Layout resize handler */ _resizeHandler() { const that = this; //Repositiones the AutoHideWindow if opened if (that.$.autoHideWindow.opened && that.$.autoHideWindow._tabsWindow) { that.$.autoHideWindow._tabsWindow._setAutoHideWindowSize(that.$.autoHideWindow._tabsWindow.selectedIndex); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * lwFileUpload custom element. */ LW('lw-file-upload', class FileUpload extends LW.BaseElement { /** * Element's properties */ static get properties() { return { 'accept': { value: null, type: 'string?' }, 'appendTo': { value: null, type: 'any' }, 'autoUpload': { value: false, type: 'boolean' }, 'directory': { value: false, type: 'boolean' }, 'dropZone': { value: null, type: 'any' }, 'hideFooter': { value: false, type: 'boolean' }, 'itemTemplate': { value: null, type: 'any' }, 'messages': { value: { 'en': { 'browse': 'Browse', 'uploadFile': 'Upload File', 'cancelFile': 'Cancel File', 'pauseFile': 'Pause File', 'uploadAll': 'Upload All', 'cancelAll': 'Cancel All', 'pauseAll': 'Pause All', 'totalFiles': 'Total files: ', 'connectionError': '{{elementType}}: File Upload requires connection to the server.', 'wrongItemIndex': '{{elementType}}: There is no file with such an index in the list of uploaded files.', 'tooLongFileName': '{{elementType}}: File name is too long.' } }, type: 'object', extend: true }, 'multiple': { value: false, type: 'boolean' }, 'name': { value: '', type: 'string' }, 'responseHandler': { value: null, type: 'function?', reflectToAttribute: false }, 'setHeaders': { value: null, type: 'function?', reflectToAttribute: false }, 'showProgress': { value: false, type: 'boolean' }, 'validateFile': { value: null, type: 'function?', reflectToAttribute: false }, 'uploadUrl': { value: '', type: 'string', reflectToAttribute: false } } } /** * Element's event listeners. */ static get listeners() { return { 'browseButton.click': 'browse', 'browseButton.focus': '_focusHandler', 'browseButton.blur': '_blurHandler', 'browseInput.change': '_browseInputChangeHandler', 'selectedFiles.click': '_selectedFilesClickHandler', 'uploadAllButton.click': 'uploadAll', 'cancelAllButton.click': 'cancelAll', 'pauseAllButton.click': 'pauseAll', 'dropZone.dragenter': '_dropZoneHandler', 'dropZone.dragleave': '_dropZoneHandler', 'dropZone.dragover': '_dropZoneHandler', 'dropZone.drop': '_dropZoneHandler', 'resize': '_handleComponentsByAvailableHeight' } } _blurHandler() { this.$.fireEvent('blur'); } _focusHandler() { this.$.fireEvent('focus'); } /** * Checks for missing modules. */ static get requires() { return { 'LW.Button': 'lw.button.js', 'LW.ProgressBar': 'lw.progressbar.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.fileupload.css' ] } /** * Element's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="fileUploadHeader" class="lw-file-upload-header" role="presentation"> <lw-button class="lw-browse-button" id="browseButton" disabled="[[disabled]]" theme="[[theme]]" right-to-left="[[rightToLeft]]"></lw-button> <input type="file" class="lw-browse-input" id="browseInput" name="[[name]]" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]" multiple="[[multiple]]" webkitdirectory="[[directory]]" mozdirectory="[[directory]]" /> </div> <div id="fileUploadContainer" class="lw-file-upload-container"> <div id="dropZone" class="lw-drop-zone" aria-label="Drag files here"></div> <div id="selectedFiles" class="lw-selected-files" role="list" aria-label="Selected files"></div> </div> <div id="totalFiles" class="lw-total-files lw-hidden" role="presentation">Total flies: 0</div> <div id="fileUploadFooter" class="lw-file-upload-footer lw-hidden">`+ '<lw-button class="lw-upload-all-button success" id="uploadAllButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"" theme="[[theme]]" right-to-left="[[rightToLeft]]"></lw-button>' + '<lw-button class="lw-cancel-all-button error" id="cancelAllButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]" theme="[[theme]]" right-to-left="[[rightToLeft]]"></lw-button>' + '<lw-button class="lw-pause-all-button primary" id="pauseAllButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]" theme="[[theme]]" right-to-left="[[rightToLeft]]"></lw-button>' + `</div> </div>`; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); switch (propertyName) { case 'accept': that.$.browseInput.accept = newValue; break; case 'dropZone': case 'appendTo': that._handleContainers(); break; case 'messages': case 'locale': that._updateTextValues(); break; case 'multiple': that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false; if (!newValue && that._selectedFiles.length > 1) { that._selectedFiles.splice(1); that._renderSelectedFiles(); } break; case 'itemTemplate': if (that._items.length > 0) { that._renderSelectedFiles(); that._handleComponentsByAvailableHeight(); } break; case 'rightToLeft': if (that._items) { that._items.forEach(item => { const progressBar = item.querySelector('lw-progress-bar'); if (progressBar) { progressBar.rightToLeft = newValue; } newValue ? item.setAttribute('right-to-left', '') : item.removeAttribute('right-to-left'); }); } if (newValue) { that.$.dropZone.setAttribute('right-to-left', ''); } else { that.$.dropZone.removeAttribute('right-to-left'); } break; } } /** * Called when the element is attached to the DOM. */ attached() { super.attached(); const that = this; that._handleContainers(); } /** * Called when the element is detached from the DOM. */ detached() { super.detached(); const that = this; if (!that.$.fileUploadContainer.contains(that.$.dropZone)) { that.$.fileUploadContainer.insertBefore(that.$.dropZone, that.$.fileUploadContainer.firstChild); } if (!that.$.fileUploadContainer.contains(that.$.selectedFiles)) { that.$.fileUploadContainer.appendChild(that.$.selectedFiles); } } /** * Element's ready method. */ ready() { super.ready(); const that = this; if (!that.$.dropZone.id) { that.$.dropZone.id = that.id + 'DropZone'; } if (!that.$.selectedFiles.id) { that.$.selectedFiles.id = that.id + 'SelectedFiles'; } that.$.fileUploadContainer.setAttribute('aria-owns', that.$.dropZone.id + ' ' + that.$.selectedFiles.id); that.setAttribute('role', 'dialog'); if (that.rightToLeft) { that.$.dropZone.setAttribute('right-to-left', ''); } else { that.$.dropZone.removeAttribute('right-to-left'); } that._setInitialValues(); that._updateTextValues(); that._handleContainers(); that._handleComponentsByAvailableHeight(); } /** * Browses for a file */ browse() { const that = this; if (that.disabled || (!that.multiple && that._selectedFiles.length > 0)) { return; } that.$.browseInput.click(); } /** * Cancels all selected files */ cancelAll() { const that = this; if (that.disabled || that._items.length === 0) { return; } for (let i = that._items.length - 1; i >= 0; i--) { that.cancelFile(that._items[i].index); } that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false; } /** * Cancels single file. * @param {number/string} index - File index. */ cancelFile(index) { const that = this; if (!(typeof index === 'number') || that.disabled || that._selectedFiles.length === 0) { return; } const item = that._getFileItem(index, true); if (!item) { that.error(that.localize('wrongItemIndex', { elementType: that.nodeName.toLowerCase() })); return; } const itemIndexInArray = that._items.indexOf(item); that.$.selectedFiles.removeChild(item); if (item && item.xhr) { item.xhr.abort(); } that._selectedFiles.splice(itemIndexInArray, 1); that._items.splice(itemIndexInArray, 1); that.$.fireEvent('uploadCanceled', { 'filename': item.file.name, 'type': item.file.type, 'size': item.file.size, 'index': item.index }); that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false; if (that._selectedFiles.length === 0) { that.$.fileUploadFooter.classList.add('lw-hidden'); } that._handleComponentsByAvailableHeight(); } get value() { const that = this; return that._selectedFiles; } /** * Pauses upload of all files */ pauseAll() { const that = this; if (that.disabled || that._items.length === 0) { return; } for (let i = that._items.length - 1; i >= 0; i--) { let item = that._items[i]; if (item.xhr) { item.xhr.abort(); } } } /** * Pauses particular file upload * @param {number/string} index - File index. */ pauseFile(index) { const that = this; if ((typeof index !== 'number' && typeof index !== 'string') || that.disabled || that._items.length === 0) { return; } const item = that._getFileItem(index, true); if (!item) { that.error(that.localize('wrongItemIndex', { elementType: that.nodeName.toLowerCase() })); return; } item.classList.remove('lw-uploading-start'); if (item && item.xhr) { item.xhr.abort(); } that.$.fireEvent('uploadPaused', { 'filename': item.file.name, 'type': item.file.type, 'size': item.file.size, 'index': item.index }); } /** * Uploads all selected files */ uploadAll() { const that = this; if (that.disabled || that._items.length === 0) { return; } for (let i = that._items.length - 1; i >= 0; i--) { if (!that._items[i].uploading) { that.uploadFile(that._items[i].index); } } } /** * Uploads single file. Selection by index * @param {number/string} index - File index. */ uploadFile(index) { const that = this; let isOnProgress = false; if (!(typeof index === 'number') || that.disabled || that._selectedFiles.length === 0) { return; } const selectedItem = that._getFileItem(index, true); if (!selectedItem) { return; } let formData = new FormData(), progressBar = that.showProgress ? selectedItem.getElementsByTagName('lw-progress-bar')[0] : null, // to be handled case with custom template selectedFile = selectedItem.file; selectedItem.classList.remove('lw-pause', 'lw-error'); selectedItem.classList.add('lw-uploading-start'); formData.append('userfile[]', selectedFile); let request = new XMLHttpRequest(); request.open('POST', that.uploadUrl); if (that.setHeaders && typeof that.setHeaders === 'function') { that.setHeaders(request, selectedFile); } that.$.fireEvent('uploadStarted', { 'filename': selectedItem.file.name, 'type': selectedItem.file.type, 'size': selectedItem.file.size, 'index': selectedItem.index }); request.upload.onprogress = function (event) { if (!isOnProgress) { isOnProgress = true; selectedItem.classList.remove('lw-uploading-start'); selectedItem.classList.add('lw-uploading'); selectedItem.uploading = true; selectedItem.xhr = request; } if (progressBar) { progressBar.value = Math.round((event.loaded / event.total) * 100); } selectedItem.classList.remove('lw-pause', 'lw-error'); }; request.onabort = function () { selectedItem.classList.remove('lw-uploading-start', 'lw-uploading'); selectedItem.classList.add('lw-pause'); selectedItem.addEventListener('animationend', function () { selectedItem.classList.remove('lw-pause', 'lw-error'); }); }; request.onerror = function () { selectedItem.classList.remove('lw-uploading-start', 'lw-uploading'); selectedItem.classList.add('lw-error'); selectedItem.addEventListener('animationend', function () { selectedItem.classList.remove('lw-pause', 'lw-error'); }); }; request.onload = function () { isOnProgress = false; selectedItem.classList.remove('lw-uploading-start', 'lw-uploading'); if (request.status >= 200 && request.status <= 299) { let actualIndex = that._items.indexOf(selectedItem); that.$.selectedFiles.removeChild(selectedItem); that._selectedFiles.splice(that._selectedFiles.indexOf(selectedFile), 1); that._items.splice(actualIndex, 1); that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false; that.$.fireEvent('uploadCompleted', { 'filename': selectedItem.file.name, 'type': selectedItem.file.type, 'size': selectedItem.file.size, 'status': request.status, 'index': selectedItem.index }); if (that._selectedFiles.length === 0) { that.$.fileUploadFooter.classList.add('lw-hidden'); } } else { selectedItem.classList.add('lw-error'); selectedItem.classList.remove('lw-uploading'); that.$.fireEvent('uploadError', { 'filename': selectedItem.file.name, 'type': selectedItem.file.type, 'size': selectedItem.file.size, 'status': request.status, 'index': selectedItem.index }); } }; request.onreadystatechange = function () { if (!that.responseHandler || typeof that.responseHandler !== 'function') { return; } that.responseHandler(request); }; request.send(formData); } /** * Click handler about "selectedFiles" container */ _selectedFilesClickHandler(event) { const that = this; if (that.disabled) { return; } const target = event.target, isItemUploadClicked = target.closest('.lw-item-upload-button'), isItemCancelClicked = target.closest('.lw-item-cancel-button'), isItemAbortClicked = target.closest('.lw-item-pause-button'), clickedItem = target.closest('.lw-file'); if (isItemUploadClicked) { that.uploadFile(clickedItem.index); } else if (isItemCancelClicked) { that.cancelFile(clickedItem.index); } else if (isItemAbortClicked) { that.pauseFile(clickedItem.index); } } /** * Change handler of the browse input. When files are selected, they are updated into files array and rendered in the file list **/ _browseInputChangeHandler() { const that = this, selectedFiles = that._filterNewFiles(Array.from(that.$.browseInput.files)); let validNewFiles = []; if (that.disabled || selectedFiles.length === 0) { return; } if (that.validateFile && typeof that.validateFile === 'function') { validNewFiles = selectedFiles.filter(file => { if (that.validateFile(file)) { return true; } that.$.fireEvent('validationError', { 'filename': file.name, 'type': file.type, 'size': file.size }); return false; }); } else { validNewFiles = selectedFiles; } that._selectedFiles = that._selectedFiles.concat(validNewFiles); if (that._selectedFiles.length === 0) { return; } that._renderSelectedFiles(validNewFiles); that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false; that.$.browseInput.value = ''; if (that.autoUpload) { that.uploadAll(); } } /** * Returns the default item template * @param {string} fileName */ _defaultItemTemplate(fileName, index) { const that = this, uploadString = that.localize('uploadFile'), cancelString = that.localize('cancelFile'), pauseString = that.localize('pauseFile'), rightToLeft = that.rightToLeft ? 'right-to-left ' : ''; return `<span id="${that.id + 'File' + index + 'Name'}" class="lw-item-name">${fileName}</span>` + `<span class="lw-item-upload-button" title="${uploadString}" role="button" aria-label="${uploadString}"></span>` + `<span class="lw-item-cancel-button" title="${cancelString}" role="button" aria-label="${cancelString}"></span>` + `<span class="lw-item-pause-button" title="${pauseString}" role="button" aria-label="${pauseString}"></span>` + `<lw-progress-bar ${rightToLeft}aria-label="Upload progress"></lw-progress-bar>`; } /** * dropZone event handler */ _dropZoneHandler(event) { const that = this; event.preventDefault(); event.stopPropagation(); if (that.disabled) { return; } if (event.type === 'dragenter' || event.type === 'dragleave') { event.type === 'dragenter' ? that.$.dropZone.classList.add('lw-drag-over') : that.$.dropZone.classList.remove('lw-drag-over'); return; } if (event.type === 'drop') { that.$.dropZone.classList.remove('lw-drag-over'); if (!that.multiple && that._selectedFiles.length > 0) { return; } if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) { const droppedFiles = that._filterNewFiles(Array.from(event.dataTransfer.files)); if (droppedFiles.length === 0) { return; } if (!that.multiple) { droppedFiles.splice(1); } that._selectedFiles = that._selectedFiles.concat(droppedFiles); that._renderSelectedFiles(droppedFiles); } that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false; } } /** * Check for duplicated items during selection and add only new items in the selection list * @param {array} newSelection - an array with selected files **/ _filterNewFiles(newSelection) { const that = this; let newFiles = []; for (let i = 0; i < newSelection.length; i++) { let notYetSelected = true; for (let j = 0; j < that._selectedFiles.length; j++) { const oldFile = that._selectedFiles[j], newFile = newSelection[i]; if (newFile.name === oldFile.name && newFile.size === oldFile.size && newFile.type === oldFile.type && newFile.lastModified === oldFile.lastModified) { notYetSelected = false; break; } } if (notYetSelected) { newFiles.push(newSelection[i]); } } return newFiles; } /** * Gets an item from the array with files if it matches particular file name or index */ _getFileItem(value, byIndex) { const that = this; let match = null; if (!value || (typeof value !== 'string' && typeof value !== 'number')) { return; } if (!that._items || that._items.length === 0) { return null; } for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; if ((byIndex && item.index === parseInt(value)) || (item.file.name === value)) { match = item; } } return match; } /** * Handles "dropZone" and "selectedFiles" contaners if they are append to external elements */ _handleContainers() { const that = this, dropZone = that._validateDOMElement(that.dropZone), appendTo = that._validateDOMElement(that.appendTo); if (dropZone) { dropZone.appendChild(that.$.dropZone); } else { that.$.fileUploadContainer.insertBefore(that.$.dropZone, that.$.fileUploadContainer.firstChild); } if (appendTo) { appendTo.appendChild(that.$.selectedFiles); } else { that.$.fileUploadContainer.appendChild(that.$.selectedFiles); } } /** * Applies the item template * @param {string} fileName */ _handleItemTemplate(filename, index) { const that = this; let template = that.itemTemplate; if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } if (!template) { return that._defaultItemTemplate(filename, index); } if (typeof template === 'string') { template = document.getElementById(template); } if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' })); return; } const content = template.innerHTML, regex = /{{\w+}}/g; return content.replace(regex, filename); } /** * Renders selected files - by defauld file name, upload button, cancel button * @param {array} files - Array with all selected files. **/ _renderSelectedFiles(files) { const that = this, itemsFragment = document.createDocumentFragment(), filesToRender = files || that._selectedFiles; if (!files) { that._items = []; that.$.selectedFiles.innerHTML = ''; } for (let i = 0; i < filesToRender.length; i++) { const fileName = that.directory ? filesToRender[i].webkitRelativePath : filesToRender[i].name, item = document.createElement('div'); that._incrementIndex++; item.className = 'lw-file'; item.index = that._incrementIndex; item.setAttribute('item-id', that._incrementIndex); item.innerHTML = that.itemTemplate ? that._handleItemTemplate(fileName, that._incrementIndex) : that._defaultItemTemplate(fileName, that._incrementIndex); item.file = filesToRender[i]; item.uploading = false; item.xhr = null; item.setAttribute('role', 'listitem'); item.setAttribute('aria-labelledby', that.id + 'File' + that._incrementIndex + 'Name'); if (that.rightToLeft) { item.setAttribute('right-to-left', ''); } itemsFragment.appendChild(item); that._items.push(item); that.$.fireEvent('fileSelected', { 'filename': filesToRender[i].name, 'type': filesToRender[i].type, 'size': filesToRender[i].size, 'index': item.index }); } that.$.selectedFiles.appendChild(itemsFragment); that.$.fileUploadFooter.classList.remove('lw-hidden'); that._handleComponentsByAvailableHeight(); // flag about cancel all to prevent recalculations every time when file is canceled } /** * Sets values on initialization **/ _setInitialValues() { const that = this; that.$.browseInput.accept = that.accept; that._selectedFiles = []; that._items = []; that._incrementIndex = 0; } /** * Updates the values of all file uploads buttons an popups **/ _updateTextValues() { const that = this, buttons = ['browse', 'uploadAll', 'cancelAll', 'pauseAll']; for (let i = 0; i < buttons.length; i++) { const localizationString = buttons[i], buttonName = localizationString + 'Button'; that.$[buttonName].innerHTML = that.localize(localizationString); } for (let i = 0; i < that._selectedFiles.length; i++) { const item = that._items[i]; item.querySelector('.lw-item-upload-button').title = that.localize('uploadFile'); item.querySelector('.lw-item-cancel-button').title = that.localize('cancelFile'); item.querySelector('.lw-item-pause-button').title = that.localize('pauseFile'); } } /** * Validates if an element exists in DOM * @param {string} fileName **/ _validateDOMElement(element) { if (!element) { return; } if (typeof element === 'string') { return document.getElementById(element); } else if (element instanceof HTMLElement) { return element; } } /** * Validates element's height **/ _handleComponentsByAvailableHeight() { const that = this; that._calculateAvailableContainerHeight(); if (that._elementsAutoHeight > that.offsetHeight) { that.$.container.classList.add('lw-overflow'); that._containerOverflows = true; if (that._rowHeight) { const remainingFiles = parseInt(that._availableHeight / that._rowHeight); for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; i < remainingFiles ? item.classList.remove('lw-hidden') : item.classList.add('lw-hidden'); } if (that._items.length > remainingFiles) { that.$.totalFiles.innerHTML = that.localize('totalFiles') + that._items.length; that.$.totalFiles.classList.remove('lw-hidden'); } else { that.$.totalFiles.classList.add('lw-hidden'); } } } else if (that.dropZone === '' && that._elementsAutoHeight < that.offsetHeight) { that.$.container.classList.remove('lw-overflow'); that._containerOverflows = false; } } /** * Calculates available container height **/ _calculateAvailableContainerHeight() { const that = this, containerStyles = window.getComputedStyle(that.$.fileUploadContainer, null), fileUploadContainerOffset = parseInt(containerStyles.getPropertyValue('margin-top')) + parseInt(containerStyles.getPropertyValue('margin-bottom')) + parseInt(containerStyles.getPropertyValue('padding-top')) + parseInt(containerStyles.getPropertyValue('padding-bottom')), fileRow = that.$.container.querySelector('.lw-file'), headersHeight = that.$.fileUploadHeader.offsetHeight, footersHeight = that.$.fileUploadFooter.offsetHeight, inlineHeight = that.style.height; let totalFilesContainerHeight = 0; if (fileRow) { that._rowHeight = fileRow.offsetHeight; } that.style.height = 'auto'; if (that._containerOverflows) { that.$.container.classList.remove('lw-overflow'); } that._elementsAutoHeight = that.offsetHeight; that.style.height = inlineHeight; if (that._containerOverflows) { that.$.container.classList.add('lw-overflow'); } if (that.$.totalFiles.classList.contains('lw-hidden')) { that.$.totalFiles.classList.remove('lw-hidden'); totalFilesContainerHeight = that.$.totalFiles.offsetHeight; that.$.totalFiles.classList.add('lw-hidden'); } that._availableHeight = that.offsetHeight - (headersHeight + footersHeight) - fileUploadContainerOffset - totalFilesContainerHeight; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * lwFilterBuilder custom element. */ LW('lw-filter-builder', class FilterBuilder extends LW.BaseElement { /** * Element's properties */ static get properties() { return { 'customOperations': { value: [], type: 'array', reflectToAttribute: false }, 'disableContextMenu': { value: false, type: 'boolean' }, 'fields': { value: null, type: 'array?', reflectToAttribute: false }, 'formatStringDate': { value: 'dd-MMM-yy', type: 'string' }, 'formatStringDateTime': { value: 'dd-MMM-yy HH:mm:ss', type: 'string' }, 'hint': { value: null, type: 'string?' }, 'icons': { value: { '=': '=', '<>': '', '>': '>', '>=': '', '<': '<', '<=': '', 'startswith': 'a|bc', 'endswith': 'ab|c', 'contains': 'abc', 'notcontains': '!abc', 'isblank': '', 'isnotblank': '' }, type: 'object', reflectToAttribute: false }, 'maxConditions': { value: null, type: 'number?', validator: '_maxValidator' }, 'maxConditionsPerGroup': { value: null, type: 'number?', validator: '_maxValidator' }, 'maxLevel': { value: null, type: 'number?', validator: '_maxValidator' }, 'messages': { value: { 'en': { 'add': 'Add', 'addCondition': 'Add Condition', 'addGroup': 'Add Group', 'and': 'And', 'notand': 'Not And', 'or': 'Or', 'notor': 'Not Or', '=': 'Equals', '<>': 'Does not equal', '>': 'Greater than', '>=': 'Greater than or equal to', '<': 'Less than', '<=': 'Less than or equal to', 'startswith': 'Starts with', 'endswith': 'Ends with', 'contains': 'Contains', 'notcontains': 'Does not contain', 'isblank': 'Is blank', 'isnotblank': 'Is not blank', 'wrongParentGroupIndex': '{{elementType}}: Wrong parent group index in "{{method}}" method.', 'missingFields': '{{elementType}}: Fields are required for proper condition\'s adding. Set "fields" source and then conditions will be added as expected.', 'wrongElementNode': '{{elementType}}: Incorect node / node Id in "{{method}}" method.', 'invalidDataStructure': '{{elementType}}: Used invalid data structure in updateCondition/updateGroup method.', 'dateTabLabel': 'DATE', 'timeTabLabel': 'TIME' } }, type: 'object', extend: true }, 'restrictedMode': { value: false, type: 'boolean' }, 'showIcons': { value: false, type: 'boolean' }, 'value': { value: ['or'], type: 'array?', reflectToAttribute: false }, 'valueFormatFunction': { value: null, type: 'function?', reflectToAttribute: false }, 'valuePlaceholder': { value: '&lt;enter a value&gt;', type: 'string' } } } /** * Filter Builder's required files */ static get requires() { return { 'LW.Button': 'lw.button.js', 'LW.CheckBox': 'lw.checkbox.js', 'LW.ScrollBar': 'lw.scrollbar.js', 'LW.ListBox': 'lw.listbox.js', 'LW.DropDownList': 'lw.dropdownlist.js', 'LW.ComboBox': 'lw.combobox.js', 'LW.Calendar': 'lw.calendar.js', 'LW.TimePicker': 'lw.timepicker.js', 'LW.Tooltip': 'lw.tooltip.js', 'LW.Utilities.DateTime': 'lw.date.js', 'LW.DateTimePicker': 'lw.datetimepicker.js', 'LW.Menu': 'lw.menu.js' } } /** * Element's event listeners. */ static get listeners() { return { 'down': '_downHandler', 'document.click': '_documentClickHandler', 'conditionsMenu.itemClick': '_menuItemClickHandler', 'container.change': '_containerChangeHandler', 'scrollableContainer.wheel': '_scrollViewerWheelHandler', 'scrollableOuterContainer.resize': '_resizeHandler', 'innerContainer.keydown': '_innerContainerKeydownHandler' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.filterbuilder.css' ] } /** * Element's HTML template. */ template() { return `<div id="container" title="[[hint]]"> <div id="innerContainer" class="lw-inner-container"> <div id="scrollableOuterContainer" class="lw-scrollable-outer-container"> <lw-scroll-viewer id="scrollableContainer" class="lw-scrollable-container" animation="[[animation]]"> <div id="contentContainer" class="lw-content-container"></div> </lw-scroll-viewer> </div> <div id="editorsContainer" class="lw-editors-container"> <div id="customEditor" class="lw-custom-editor lw-hidden"></div> </div> </div> <lw-menu id="conditionsMenu" mode="dropDown" class="lw-conditions-menu" theme="[[theme]]" animation="[[animation]]"></lw-menu> </div>`; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; const editors = ['textBoxEditor', 'numericTextBoxEditor', 'comboBoxEditor', 'dateTimePickerEditor', 'checkBoxEditor']; super.propertyChangedHandler(propertyName, oldValue, newValue); switch (propertyName) { case 'animation': case 'theme': editors.forEach(editor => that.$[editor] && (that.$[editor][propertyName] = newValue)); break; case 'customOperations': that._handleCustomOperations(); that._refresh(); break; case 'fields': that._mapFieldsToMenu(); that._refresh(); break; case 'formatStringDate': case 'formatStringDateTime': case 'showIcons': case 'valueFormatFunction': that._refresh(); break; case 'locale': case 'messages': that._localizeInitialValues(); that._refresh(); that._handleCustomOperations();// if (that.$.dateTimePickerEditor) { if (!that.$.dateTimePickerEditor.messages[that.locale]) { that.$.dateTimePickerEditor.messages[that.locale] = {}; } that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel = that.localize('dateTabLabel'); that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel = that.localize('timeTabLabel'); if (propertyName === 'locale') { that.$.dateTimePickerEditor.locale = that.locale; } else if (propertyName === 'messages') { that.$.dateTimePickerEditor.$.selectDate.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel; that.$.dateTimePickerEditor.$.selectTime.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel; } } break; case 'maxConditions': case 'maxConditionsPerGroup': case 'maxLevel': case 'value': { that._totalConditions = 0; that._validateValue(); that._emptyElementsStructure(true); that._convertValueToFlat(that.value); that._getFieldsFromValue(); that._mapFieldsToMenu(); that._generateHTMLStructureFromFlatValue(); that.$.scrollableContainer.refresh(); const oldValueAsString = JSON.stringify(that.value); if (that._oldValueAsString !== oldValueAsString) { that._oldValueAsString = oldValueAsString; that.$.fireEvent('change', { 'value': JSON.parse(oldValueAsString) }); } break; } case 'valuePlaceholder': that._updatePlaceholder(); break; } } /** * Validates the value of "maxConditions", "maxConditionsPerGroup", and "maxLevel" * @param {any} oldValue - the old value * @param {any} value - the new value */ _maxValidator(oldValue, newValue) { if (typeof newValue !== 'number') { return newValue; } return Math.max(1, newValue); } /** * Element's ready method. */ ready() { super.ready(); const that = this; that._validateValue(); that._setInitialValues(); that._handleCustomOperations(); that._emptyElementsStructure(true); that._totalConditions = 0; that._convertValueToFlat(that.value); that._getFieldsFromValue(); that._generateHTMLStructureFromFlatValue(); that.$.conditionsMenu._noAutoFocus = true; that._oldValueAsString = JSON.stringify(that.value); that.$.scrollableContainer.refresh(); } /* * Creates new condition * @param {Any} parentGroup - html object or group id * @param {Array} data - contains dataField, operator and value */ addCondition(parentGroup, data) { const that = this; that._checkFieldsExistence(); that._addElement('condition', parentGroup, data); } /* * Creates new empty group by given operator and parent group * @param {Any} parentGroup - could be html object or nodeId * @param {String} groupOperator - 'and'/'or'/'notand'/'notor' */ addGroup(parentGroup, groupOperator) { const that = this; that._addElement('group', parentGroup, groupOperator); } /* * Removes condition * @param {Any} elementNode - HTML element or nodeId of the element */ removeCondition(elementNode) { const that = this; that._validateNode(elementNode, 'removeCondition'); that._deleteElement(elementNode, 'condition'); that._refresh(); } /* * Removes a group with all of it's children * @param {Any} elementNode - HTML element or nodeId of the element */ removeGroup(elementNode) { const that = this; that._validateNode(elementNode, 'removeGroup'); that._deleteElement(elementNode, 'group'); that._refresh(); } /** * Generates string representation of the value * @param {Boolean} useLabels - controls the way of string representation. In mode without labels the object is stringified. In mode with */ toString(useLabels) { const that = this; if (!useLabels) { return JSON.stringify(that.value); } let formattedValueFlat = [], groupsWithItems = []; for (let i = 0; i < that._valueFlat.length; i++) { const item = that._valueFlat[i]; let formattedItem = {}; if (item.type === 'condition') { const fieldData = that._getFieldByFieldName(item.data[0]), type = fieldData.dataType, category = '[' + (fieldData.label || fieldData.value) + ']', operator = that.localize(item.data[1]), value = ['boolean', 'number'].indexOf(type) !== -1 ? item.data[2] + '' : '\'' + item.data[2] + '\''; formattedItem.data = category + ' ' + operator + ' ' + value; } else { formattedItem.data = item.data; } formattedItem.nodeId = item.nodeId; formattedItem.parentId = item.parentId; formattedItem.type = item.type; formattedValueFlat.push(formattedItem); } for (let i = 0; i < formattedValueFlat.length; i++) { const item = formattedValueFlat[i]; let group = {}; if (item.type === 'group') { const hasItems = formattedValueFlat.filter(testItem => { return (testItem.parentId === item.nodeId && testItem.type === 'condition'); }); if (hasItems.length > 0) { let content = hasItems.map(mappedItem => mappedItem.data), prefix = '', sufix = '', groupOperator = item.data; if (['notand', 'notor'].indexOf(groupOperator) !== -1) { prefix = 'Not ('; sufix = ')'; groupOperator = groupOperator.substring(3); } group.nodeId = item.nodeId; group.parentId = item.parentId; group.data = item.data; group.structure = prefix + content.join(' ' + that.localize(groupOperator) + ' ') + sufix; groupsWithItems.push(group); } } } groupsWithItems = groupsWithItems.filter(item => { return (item.structure.length > 1); }); groupsWithItems.sort(function (a, b) { return (b.nodeId.split('.').length - a.nodeId.split('.').length); }); for (let i = 0; i < groupsWithItems.length; i++) { const curentElement = groupsWithItems[i], parentElement = groupsWithItems.filter(item => { return (item.nodeId === curentElement.parentId) })[0]; if (parentElement && parentElement.structure) { let groupOperator = parentElement.data; if (['notand', 'notor'].indexOf(groupOperator) !== -1) { groupOperator = groupOperator.substring(3); parentElement.structure = parentElement.structure.slice(0, parentElement.structure.length - 1) + ' ' + that.localize(groupOperator) + ' (' + curentElement.structure + '))'; } else { parentElement.structure = parentElement.structure + ' ' + that.localize(groupOperator) + ' (' + curentElement.structure + ')'; } } } return groupsWithItems[groupsWithItems.length - 1].structure; } /* * Updates content of a condition * @param {Any} elementNode - HTML element or nodeId of the element * @param {Array} data - an array with a new condition settings */ updateCondition(elementNode, data) { const that = this, editedItem = that._validateNode(elementNode, 'updateCondition'); that._validateUserData(data, true); editedItem.data = data; that._refresh(); } /* * Updates content of a group * @param {Any} elementNode - HTML element or nodeId of the element * @param {String} data - the new state of the group condition operator */ updateGroup(elementNode, data) { const that = this, editedItem = that._validateNode(elementNode, 'updateGroup'); that._validateUserData(data); editedItem.data = data; that._refresh(); } /* * Creates new group or condition * @param {String} type - 'group' or 'condition' * @param {Any} parentGroup - html object or group id * @param {Any} data - if type is group - contains group's operator; if type is condition - dataField, operator and value */ _addElement(type, parentGroup, data/*, noRefresh*/) { parentGroup = parentGroup || '0'; const that = this, parentGroups = that._valueFlat.filter(item => { return (item.nodeId === parentGroup && item.type === 'group') }), parentGroupExists = parentGroups.length > 0 ? parentGroups[0] : false, siblings = that._valueFlat.filter(item => { return item.parentId === parentGroup }); let addGroupAtPosition = 0, groupSeparator = ''; if (!parentGroupExists) { that.error(that.localize('wrongParentGroupIndex', { elementType: that.nodeName.toLowerCase(), method: 'addGroup/addCondition' })); } if (type === 'group') { data = data || 'or'; } else { if (siblings.filter(item => item.type === 'condition').length === that.maxConditionsPerGroup || that._totalConditions === that.maxConditions) { return; } const defaultDataField = that.fields && that.fields.length > 0 ? that.fields[0].dataField : that._valueFields[0].dataField; that._totalConditions++; data = data || []; data[0] = data[0] || defaultDataField; data[1] = data[1] || '='; data[2] = typeof data[2] !== undefined ? data[2] : null; } if (siblings) { let siblingsIndexes = siblings.map(index => { const indexPath = index.nodeId.split('.'); return parseInt(indexPath[indexPath.length - 1]); }); siblingsIndexes = (siblingsIndexes.length === 0) ? [0] : siblingsIndexes; addGroupAtPosition = siblingsIndexes.reduce(function (a, b) { return Math.max(a, b); }) + 1; } if (parentGroup && parentGroup.length > 0) { groupSeparator = '.'; } const itemId = parentGroup + groupSeparator + addGroupAtPosition, itemData = { nodeId: itemId, parentId: parentGroup, type: type, data: data, htmlNode: null }; that._valueFlat.push(itemData); that._refresh(); } /** * Sets condition row's value to null and sets value's container with valuePlaceholder */ _clearConditionsValue(nodeId, type) { const that = this, itemAsHTML = (that.shadowRoot || that).querySelector('[node-id="' + (nodeId || 0) + '"]'), valueContainer = itemAsHTML.querySelector('.lw-value-container'); for (let i = 0; i < that._valueFlat.length; i++) { if (that._valueFlat[i].nodeId === nodeId) { const item = that._valueFlat[i], dataType = type ? that.fields.find(field => field.dataField === type).dataType : that.fields.find(field => field.dataField === item.data[0]).dataType; item.data[2] = that._defaultValueByType(dataType); } } valueContainer.innerHTML = that.valuePlaceholder; valueContainer.closest('.lw-filter-value').setAttribute('placeholder', ''); } /** * Converts value(represented as nested array) to flat array. Used about internal data representation * @param {Array} groupData - an array with group data * @param {String} nodeId - the id of the current element */ _convertValueToFlat(groupData, nodeId) { const that = this, regEx = /^(and|or|notAnd|notOr)$/i; if (!groupData) { return; } const operatorsFilter = groupData.filter(element => ((typeof element === 'string') && element.match(regEx))), groupOperator = operatorsFilter ? operatorsFilter[0] : null, conditions = groupData.filter(element => { return (Array.isArray(element) && element.length === 3 && element.filter(subElement => (typeof subElement === 'string') && subElement.match(regEx)).length === 0) }), subGroups = groupData.filter(element => !conditions.includes(element) && element !== groupOperator); if (!operatorsFilter) { return; } const groupSeparator = that._lastProcessedItemInCurrentGroup.parentId ? '.' : '', groupNodeId = (that._lastProcessedItemInCurrentGroup.parentId || '') + groupSeparator + ((nodeId || 0)); if (that._isMaxLevelExceeded(groupNodeId)) { return; } const itemData = { nodeId: groupNodeId, parentId: that._lastProcessedItemInCurrentGroup.parentId, type: 'group', data: groupOperator, htmlNode: null }/*, allowedConditionsInGroup = that.maxConditionsPerGroup ? that.maxConditionsPerGroup : conditions.length*/; that._valueFlat.push(itemData); that._lastProcessedItemInCurrentGroup.position = 0; for (let i = 0; i < conditions.length; i++) { if (!conditions[i]) { break; } const conditionNodeId = groupNodeId + '.' + ((that._lastProcessedItemInCurrentGroup.position || 0)); if (that._isMaxLevelExceeded(conditionNodeId)) { break; } const itemData = { nodeId: conditionNodeId, parentId: groupNodeId, type: 'condition', data: conditions[i], htmlNode: null }; that._totalConditions++; that._valueFlat.push(itemData); that._lastProcessedItemInCurrentGroup.position++; } // process nested elements for (let i = 0; i < subGroups.length; i++) { that._lastProcessedItemInCurrentGroup.parentId = groupNodeId; that._convertValueToFlat(subGroups[i], conditions.length + i); that._lastProcessedItemInCurrentGroup.position++; } } /** * Checks the construction for maxLevel nesting */ _isMaxLevelExceeded(groupId) { const that = this, valueFlat = that._valueFlat; if (that.maxLevel === null || valueFlat.length < 1) { return; } //NOTE: 2 because - 1 is for the 0th (root) group, and -1 because we want to start from 0 //Checks a specific item if (groupId) { return groupId.split('.').length - 2 >= that.maxLevel; } //Checks the whole structure for (let i = 0; i < valueFlat.length; i++) { const data = valueFlat[i]; if (data.nodeId.split('.').length - 2 > that.maxLevel) { return true; } } } /** * Handles click event according to the target's type (filter button, add button, delete button, etc.). */ _clickHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target, conditionRow = target ? target.closest('.lw-filter-group-condition') : null, conditionId = conditionRow ? conditionRow.getAttribute('node-id') : null, filterGroup = target ? target.closest('.lw-filter-group') : null, filterGroupId = filterGroup ? filterGroup.getAttribute('node-id') : null, isAddButton = target.closest('.lw-filter-add-btn'), isDeleteButton = target.closest('.lw-filter-delete-btn'), isFilterButton = target.closest('.filter-builder-item'), itemId = conditionId || filterGroupId, item = that._getItemById(itemId); let clickedComponent; if (that.disabled) { return; } if (isFilterButton || isDeleteButton || isAddButton) { if (isFilterButton) { if (isFilterButton.classList.contains('lw-filter-field-name')) { clickedComponent = 'fieldButton'; } else if (isFilterButton.classList.contains('lw-filter-operation')) { clickedComponent = 'operationButton'; } else if (isFilterButton.classList.contains('lw-filter-value')) { clickedComponent = 'valueButton'; } else { clickedComponent = 'groupOperationButton'; } } else if (isAddButton) { clickedComponent = 'addButton'; } else { clickedComponent = 'deleteButton'; } that.$.fireEvent('itemClick', { id: item.nodeId, type: item.type, component: clickedComponent, data: item.data }); } if (isDeleteButton) { const groupOperatorRow = target.closest('.lw-filter-group-operator'), conditionRow = target.closest('.lw-filter-group-condition'); that._clickHandlerDeleteButton(groupOperatorRow, conditionRow, filterGroup); return; } else if (isAddButton) { that._closeEditor(); that._contextMenuOptions = that._addOptions; that._handleContextMenu(target); return; } else if (isFilterButton) { const elementClassList = isFilterButton.classList; that._clickHandlerFilterButton(elementClassList, itemId, target); return; } if (that.$.conditionsMenu.opened) { that.$.fireEvent('menuClosing'); that.$.conditionsMenu.close(); that.$.fireEvent('menuClose'); } const isTargetADropDown = target.closest('.lw-drop-down'), targetIsEditor = (that._editor && that._editor.contains(target) || (isTargetADropDown && isTargetADropDown.ownerElement === that._editor)) || target.closest('.lw-custom-editor'); if (!that._editorIsOpen || !that._editor || targetIsEditor) { return; } if (that._scrollBarDown) { delete that._scrollBarDown; return; } that._closeEditor(); } /** * Handling click on delete button */ _clickHandlerDeleteButton(groupOperatorRow, conditionRow, filterGroup) { const that = this; if (that.$.conditionsMenu.opened) { that.$.fireEvent('menuClosing'); that.$.conditionsMenu.close(); that.$.fireEvent('menuClose'); } that._closeEditor(); if (groupOperatorRow) { that._deleteElement(filterGroup, 'group'); that._generateValue(); } else if (conditionRow) { that._deleteElement(conditionRow); that._generateValue(); } that.$.scrollableContainer.refresh(); } /** * Handling click on delete buton */ _clickHandlerFilterButton(elementClassList, itemId, target) { const that = this; if (target.closest('.lw-editors-container')) { return; } that._closeEditor(); that._editedItem = that._getItemById(itemId); if (!elementClassList.contains('lw-filter-field-name') && (!that._editedItem.data || !that._editedItem.data.length)) { return; } if (elementClassList.contains('lw-filter-group-operation')) { prepareContextMenu(target, that._groupOperationDescriptions, that._editedItem.data); return; } else if (elementClassList.contains('lw-filter-add-btn')) { prepareContextMenu(target, that._groupOperationDescriptions); } else if (elementClassList.contains('lw-filter-field-name')) { if (!that._fields) { that._mapFieldsToMenu(); } prepareContextMenu(target, that._fields, that._editedItem.data[0]); return; } else if (elementClassList.contains('lw-filter-operation')) { const selectedField = that._getFieldByFieldName(that._editedItem.data[0]); if (!selectedField) { return; } let filteredOptions = that._filterOperationDescriptions.slice(); if (selectedField && selectedField.filterOperations) { filteredOptions = that._filterOperationDescriptions.filter(item => { return selectedField.filterOperations.indexOf(item.value) > -1; }); } else { let filterOperationsByType; switch (selectedField.dataType) { case 'number': filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank']; break; case 'date': filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank']; break; case 'dateTime': filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank']; break; case 'boolean': filterOperationsByType = ['=', '<>', 'isblank', 'isnotblank']; break; case 'object': filterOperationsByType = ['isblank', 'isnotblank']; break; case 'string': filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', 'isblank', 'isnotblank']; break; default: filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank']; break; } filteredOptions = that._filterOperationDescriptions.filter(item => { return filterOperationsByType.indexOf(item.value) > -1; }); } if (that.showIcons) { filteredOptions = filteredOptions.map(item => { item.label = '<div class="lw-filter-builder-icon">' + that.icons[item.value] + '</div><div class="lw-filter-builder-menu-item">' + that.localize(item.value) + '</div>'; return item; }); } prepareContextMenu(target, filteredOptions.slice(), that._editedItem.data[1]); return; } else { that._openEditor(target); return; } function deSelectMenuItem() { const alredySelectedItem = that.$.conditionsMenu.querySelector('.lw-selected-menu-item'); if (alredySelectedItem) { alredySelectedItem.classList.remove('lw-selected-menu-item'); } } function prepareContextMenu(target, dataSource, selectedItem) { deSelectMenuItem(); that._contextMenuOptions = dataSource.length === 0 ? that._defaultFilterOperationDescriptions : dataSource; that._handleContextMenu(target); const selectedField = selectedItem, chosenMenuItem = that.$.conditionsMenu.querySelector('lw-menu-item[value="' + selectedField + '"]'); if (!that.$.conditionsMenu.opened || !chosenMenuItem) { return; } chosenMenuItem.classList.add('lw-selected-menu-item'); } } /** * Closes an editor and sets the new value in the value's cotainer * @param {Boolean} preventEventFiring (optional). */ _closeEditor(preventEventFiring) { const that = this; let storedValue; if (!that._editedItem || !that._editorIsOpen) { return; } if (that._editor === that.$.dateTimePickerEditor) { that._editor._inputChangeHandler(); storedValue = that._editor.value; if (storedValue) { storedValue = storedValue.toDate(); } } else if (that._editor === that.$.checkBoxEditor) { storedValue = that._editor.checked; } else if (that._editor === that.$.customEditor) { storedValue = that._selectedCustomCondition.handleValue(that._editor); } else if (that._editor === that.$.numericTextBoxEditor) { that._editor._inputBlurHandler(); storedValue = that._editor.value; } else { const selectedField = that._getFieldByFieldName(that._editedItem.data[0]); if (selectedField.dataType === 'array') { storedValue = that._editor.value.split(','); } else if (selectedField.dataType === 'object') { storedValue = JSON.parse(that._editor.value); } else { storedValue = that._editor.value; } } const editedItem = that._editedItem, editedRow = editedItem.htmlNode, nodeId = editedItem.nodeId, valueDataType = that._getFieldByFieldName(editedItem.data[0]).dataType, editedHTMLvalueComponent = editedRow.querySelector('.lw-filter-value'), editedHTMLvalueContainer = editedRow.querySelector('.lw-value-container'), eventData = { value: storedValue, valueType: valueDataType || 'string', editedItem: editedItem }; that.$.fireEvent('editorClosing', eventData); that._updateValueInFlatArray(nodeId, storedValue, 'value', (valueDataType || 'string')); that._generateValue(preventEventFiring); editedHTMLvalueComponent.removeAttribute('edited'); that.$.editorsContainer.removeAttribute('open'); if (that._editor === that.$.checkBoxEditor) { editedHTMLvalueContainer.innerHTML = that._editor.checked ? 'true' : 'false'; } else if (that._editor === that.$.customEditor) { const value = that._selectedCustomCondition.valueTemplate(that._editor); editedHTMLvalueContainer.innerHTML = value; } else { editedHTMLvalueContainer.innerHTML = that._formatValueStringRepresentation(that._editor.value, that._editedItem.data[0]); } that._editor.classList.add('lw-hidden'); that._editorIsOpen = that._enterIsPressedInEditor = false; that.$.fireEvent('editorClose', eventData); that.$.scrollableContainer.refresh(); } _defaultValueByType(type) { let defaultValue; switch (type) { case 'number': defaultValue = 0; break; case 'date': case 'dateTime': { defaultValue = new Date(); defaultValue.setHours(0, 0, 0); break; } case 'boolean': defaultValue = false; break; case 'object': defaultValue = null; break; default: defaultValue = ''; } return defaultValue; } /** * Removes a condition and it's HTML representation * @param {Any} elementNode. * @param {String} type. */ _deleteElement(elementNode, type) { const that = this, actualElement = elementNode instanceof HTMLElement ? elementNode : that._valueFlat.find(item => item.nodeId === elementNode).htmlNode, nodeId = typeof elementNode === 'string' ? elementNode : elementNode.getAttribute('node-id'); if (!nodeId || nodeId.length === 1) { return; } type === 'group' ? deleteGroup(nodeId) : deleteCondition(nodeId); function deleteCondition(nodeId) { const items = that._valueFlat.filter(item => { return (nodeId === item.nodeId); }); let item = items ? items[0] : null; that._valueFlat.splice(that._valueFlat.indexOf(item), 1); that._totalConditions--; } function deleteGroup(nodeId) { const items = that._valueFlat.filter(item => { return (nodeId === item.nodeId); }), item = items ? items[0] : null; for (let i = 0; i < that._valueFlat.length; i++) { const nestedItem = that._valueFlat[i], nestedNodeId = nestedItem.nodeId; if (nestedItem.parentId === nodeId) { nestedItem.type === 'group' ? deleteGroup(nestedNodeId) : deleteCondition(nestedNodeId); } } (that._valueFlat.indexOf(item) > -1) && that._valueFlat.splice(that._valueFlat.indexOf(item), 1); } for (let i = (that._valueFlat.length - 1); i >= 0; i--) { const parentGroup = that._valueFlat.filter(item => { return (that._valueFlat[i].parentId === item.nodeId); }); if (parentGroup.length === 0 && that._valueFlat[i].nodeId !== '0') { that._valueFlat.splice(i, 1); that._totalConditions--; } } that._generateValue(); actualElement.parentElement.removeChild(actualElement); function updateNodeIds(siblings, parentId) { siblings.forEach((element, index) => { const valueFlatItem = that._valueFlat.find(item => item.htmlNode === element), id = parentId + '.' + index; element.setAttribute('node-id', id); valueFlatItem.parentId = parentId; valueFlatItem.nodeId = id; if (element.classList.contains('lw-filter-group')) { updateNodeIds(Array.from(element.children[1].children), id); } }); } updateNodeIds(Array.from(that.$.contentContainer.firstElementChild.children[1].children), '0'); } /** * Document click handler - closes menu and/or editor on click outside of the element */ _documentClickHandler(event) { const that = this; if ((that.isInShadowDOM ? event.composedPath()[0] : event.target).closest('lw-filter-builder')) { that._clickHandler(event); return; } if (that._editorIsOpen && !that._scrollBarDown) { that._closeEditor(); } delete that._scrollBarDown; } /** * down handler */ _downHandler(event) { const that = this; if ((that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target).closest('lw-scroll-bar')) { that._scrollBarDown = true; } else { delete that._scrollBarDown; } } /** * Editor's change handler */ _containerChangeHandler(event) { event.stopPropagation(); } /** * Generates HTML structure from flat array and adds/replaces * @param {Array} data - contains dataField, operator and value */ _emptyElementsStructure(emptyValueFlat) { const that = this, contentContainer = that.$.contentContainer; while (contentContainer.firstChild) { contentContainer.removeChild(contentContainer.firstChild); } that._valueFlat = emptyValueFlat ? [] : that._valueFlat; that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null }; } /** * Creates filter group row * @param {String} groupOperator (optional). */ _filterGroupRow(groupOperator) { const that = this; groupOperator = that.localize(groupOperator || 'or'); let groupRow = document.createElement('div'), template = `<span class="lw-filter-delete-btn"></span> <span class="filter-builder-item lw-filter-group-operation">${groupOperator}</span> <span class="lw-filter-add-btn"></span>`; groupRow.className = 'lw-filter-group-operator'; groupRow.innerHTML = template; groupRow.data = groupOperator || 'or';// return groupRow; } /** * Removes a condition and it's HTML representation * @param {Any} value. * @param {String} field. */ _formatValueStringRepresentation(value, field) { const that = this, fieldData = that._getFieldByFieldName(field); let valueFormattedByType; if (!fieldData) { return value; } if (((!value || value.length === 0) && fieldData.dataType !== 'boolean' && (fieldData.dataType === 'number' && value === null)) || (fieldData.dataType === 'string' && (!value || value.length === 0))) { return that.valuePlaceholder; } switch (fieldData.dataType) { case 'date': case 'dateTime': if (value) { value = validateDateTimeValue(value); value.calendar.days = that._localizedDays; value.calendar.months = that._localizedMonths; value.calendar.locale = that.locale; LW.Utilities.DateTime.cache = []; valueFormattedByType = value.toString(fieldData.dataType === 'date' ? that.formatStringDate : that.formatStringDateTime); } else { valueFormattedByType = that.valuePlaceholder; } break; case 'array': valueFormattedByType = typeof value === 'string' ? value.split(',') : value; break; case 'object': valueFormattedByType = typeof value === 'string' ? value : JSON.stringify(value); break; case 'number': valueFormattedByType = value; break; case 'boolean': valueFormattedByType = value === false ? 'false' : 'true'; break; default: valueFormattedByType = value + ''; break; } if (!that.valueFormatFunction) { return valueFormattedByType; } function validateDateTimeValue(value) { if (value === 0 || typeof value === 'number' || typeof value === 'string' || value === true || value === '' || value === '0' || Array.isArray(value) || typeof value === 'object' && value.constructor === Date) { return new LW.Utilities.DateTime(value); } else { return value; } } return that.valueFormatFunction(valueFormattedByType, field, (fieldData.dataType || 'string')); } /** * Generates HTML structure from flat array and adds/replaces */ _generateHTMLStructureFromFlatValue() { const that = this, fragment = document.createDocumentFragment(); if (!that._valueFlat || that._valueFlat.length === 0) { return; } for (let i = 0; i < that._valueFlat.length; i++) { const item = that._valueFlat[i], customOperation = that.customOperations ? that.customOperations.find(operation => operation.name === item.data[1]) : false, parentGroupHTMLcontainer = item.parentId ? (that.shadowRoot || that).querySelector('[node-id="' + item.parentId + '"]'). querySelector('.lw-filter-group-condition-container') : that.$.contentContainer; if (item.type === 'group') { const groupContainerBlock = document.createElement('div'), groupOperatorBlock = that._filterGroupRow(item.data), groupConditionsContainerBlock = document.createElement('div'); groupContainerBlock.className = 'lw-filter-group'; groupConditionsContainerBlock.className = 'lw-filter-group-condition-container'; groupContainerBlock.appendChild(groupOperatorBlock); groupContainerBlock.appendChild(groupConditionsContainerBlock); fragment.appendChild(groupContainerBlock); groupContainerBlock.setAttribute('node-id', item.nodeId); that._valueFlat[i].htmlNode = groupContainerBlock; if (that._isMaxLevelExceeded(item.nodeId + '.0')) { groupContainerBlock.setAttribute('max-level', ''); } } else { const condition = that._newFilterConditionRow(item.data); condition.setAttribute('node-id', item.nodeId); fragment.appendChild(condition); that._valueFlat[i].htmlNode = condition; if (['isblank', 'isnotblank'].indexOf(item.data[1]) !== -1 || (customOperation && customOperation.hideValue)) { condition.children[3].classList.add('lw-hidden'); } } parentGroupHTMLcontainer.appendChild(fragment); } } /** * Generates the new value of "value" property from flat array */ _generateValue() { const that = this; let groupsWithItems = [], value = that._valueFlat.slice(); createNestedArray(value); function createNestedArray(flatValue) { for (let i = 0; i < flatValue.length; i++) { const item = flatValue[i]; let group = {}; if (item.type === 'group') { group.nodeId = item.nodeId; group.parentId = item.parentId; group.structure = [item.data || 'or']; groupsWithItems.push(group); } } for (let i = 0; i < groupsWithItems.length; i++) { const group = groupsWithItems[i], conditions = flatValue.filter(item => { return (item.parentId === group.nodeId && item.type === 'condition'); }); for (let i = 0; i < conditions.length; i++) { i === 0 ? group.structure.unshift(conditions[i].data) : group.structure.push(conditions[i].data); } } groupsWithItems = groupsWithItems.filter(item => { return (item.structure.length > 1); }); groupsWithItems.sort(function (a, b) { return (b.nodeId.split('.').length - a.nodeId.split('.').length); }); for (let i = 0; i < groupsWithItems.length; i++) { const curentElement = groupsWithItems[i], parentElement = groupsWithItems.filter(item => { return (item.nodeId === curentElement.parentId) })[0]; if (parentElement && parentElement.structure) { parentElement.structure.push(curentElement.structure); } } } if (groupsWithItems.length > 0) { that.value = that._valueFlat.length > 1 ? groupsWithItems[groupsWithItems.length - 1].structure : groupsWithItems; } else { that.value = [that._getItemById('0').data]; } const oldValueAsString = JSON.stringify(that.value); if (that._oldValueAsString !== oldValueAsString) { that._oldValueAsString = oldValueAsString; that.$.fireEvent('change', { 'value': JSON.parse(oldValueAsString) }); } } /** * Return field's data by given field name * @param {String} fieldName */ _getFieldByFieldName(fieldName) { const that = this, fields = that.fields ? that.fields.filter(item => { return item.dataField === fieldName; }) : that._valueFields.filter(item => { return item.dataField === fieldName; }); return fields[0] || null; } /** * Generates an array of field objecst, used as a backup when fields property is not set */ _getFieldsFromValue() { const that = this, items = that._valueFlat, fieldsNames = [], fields = []; for (let i = 0; i < items.length; i++) { if (items[i].type === 'condition') { const fieldName = items[i].data[0]; if (fieldsNames.indexOf(fieldName) === -1) { const fieldElement = { label: fieldName, dataField: fieldName, dataType: 'string', format: null }; fieldsNames.push(fieldName); fields.push(fieldElement); } } } that._valueFields = fields; } /** * Return item's data by given id * @param {String} id - item's id (or parent id - demending on the second parameter) * @param {Boolean} isParent (optional) - of the items is searched by parentId */ _getItemById(id, isParent) { const that = this, matches = that._valueFlat.filter(item => { if (isParent) { return item.parentId === id; } return item.nodeId === id; }), editedItem = matches.length > 0 ? matches[0] : null; return editedItem; } /** * Handles context menu position * @param {HTML element} target (optional) - the component which is clicked */ _handleContextMenu(target) { const that = this; if (that._selectedElement === target && that.$.conditionsMenu.opened) { return; } const targetCoordinates = target.getBoundingClientRect(), elementCoordinates = that.getBoundingClientRect(), offsetTop = targetCoordinates.height, x = targetCoordinates.left + that.$.contentContainer.scrollLeft - elementCoordinates.left, y = targetCoordinates.top + that.$.contentContainer.scrollTop - elementCoordinates.top + offsetTop; if (target.closest('.lw-filter-add-btn') && that.restrictedMode) { that._checkFieldsExistence(); const conditionField = that.fields ? that.fields[0] : that._valueFields[0], operation = (conditionField.filterOperations && conditionField.filterOperations.length > 0) ? conditionField.filterOperations[0] : '='; that._addElement('condition', 0, [conditionField.dataField, operation, that._defaultValueByType(conditionField.dataType)]); return; } that._closeEditor(); if (that.disableContextMenu) { that._selectedElement = target; return; } that.$.conditionsMenu.dataSource = that._contextMenuOptions; that.$.conditionsMenu.open(x, y); that._selectedElement = target; that.$.scrollableContainer.refresh(); } /** * Add custom operations to the menu's operations list */ _handleCustomOperations() { const that = this; that._filterOperationDescriptions = that._defaultFilterOperationDescriptions; for (let i = 0; i < that.customOperations.length; i++) { const operation = that.customOperations[i]; that._filterOperationDescriptions.push({ label: operation.label, value: operation.name, custom: true, index: i, editorTemplate: operation.editorTemplate, valueTemplate: operation.valueTemplate, handleValue: operation.handleValue }); } } /** * Initializes Editors instance if it's not initialized. */ _initializeEditor(editor) { const that = this, editorTagName = 'lw-' + LW.Utilities.Core.toDash(editor), editorElement = document.createElement(editorTagName); if (editor === 'numericTextBox') { editorElement.spinButtons = true; editorElement.inputFormat = 'floatingPoint'; } else if (editor === 'dateTimePicker') { editorElement.calendarButton = true; editorElement.dropDownDisplayMode = 'auto'; editorElement.enableMouseWheelAction = true; editorElement.locale = that.locale; if (!editorElement.messages[that.locale]) { editorElement.messages[that.locale] = {}; } editorElement.messages[that.locale].dateTabLabel = that.localize('dateTabLabel'); editorElement.messages[that.locale].timeTabLabel = that.localize('timeTabLabel'); } editorElement.tabIndex = '1'; editorElement.theme = that.theme; editorElement.animation = that.animation; that.$[editor + 'Editor'] = editorElement; editorElement.$ = LW.Utilities.Extend(editorElement); editorElement.className = editorTagName + '-editor lw-hidden'; that.$.editorsContainer.appendChild(editorElement); that['_' + editor + 'Initialized'] = true; } /** * InnerContainer keydown eventHandler * @param {any} event */ _innerContainerKeydownHandler(event) { const that = this; if (event.key !== 'Escape' && event.key !== 'Enter' || !that._editorIsOpen) { return; } that._closeEditor(); } /** * Updates value on blur */ _inputBlurHandler() { const that = this; let storedValue; if (that._editor === that.$.dateTimePickerEditor) { storedValue = that._editor.value; if (storedValue) { storedValue = storedValue.toDate(); } } else if (that._editor === that.$.checkBoxEditor) { storedValue = that._editor.checked; } else if (that._editor === that.$.customEditor) { storedValue = that._selectedCustomCondition.handleValue(that._editor); } else { const selectedField = that._getFieldByFieldName(that._editedItem.data[0]); if (selectedField.dataType === 'array') { storedValue = that._editor.value.split(','); } else if (selectedField.dataType === 'object') { storedValue = JSON.parse(that._editor.value); } else { storedValue = that._editor.value; } // storedValue = that._editor.value; } const editedItem = that._editedItem, nodeId = editedItem.nodeId, valueDataType = that._getFieldByFieldName(editedItem.data[0]).dataType; that._updateValueInFlatArray(nodeId, storedValue, 'value', (valueDataType || 'string')); that._generateValue(); } /** * Localizes default values for the menus. */ _localizeInitialValues() { const that = this, localizedNames = LW.Utilities.DateTime.getLocalizedNames(that.locale); that._addOptions = [ { label: that.localize('addCondition'), value: 'addCondition' }, { label: that.localize('addGroup'), value: 'addGroup' } ]; that._groupOperationDescriptions = [ { label: that.localize('and'), value: 'and' }, { label: that.localize('notand'), value: 'notand' }, { label: that.localize('or'), value: 'or' }, { label: that.localize('notor'), value: 'notor' } ]; that._defaultFilterOperationDescriptions = that._filterOperationDescriptions = [ { label: that.localize('='), value: '=', custom: false }, { label: that.localize('<>'), value: '<>', custom: false }, { label: that.localize('>'), value: '>', custom: false }, { label: that.localize('>='), value: '>=', custom: false }, { label: that.localize('<'), value: '<', custom: false }, { label: that.localize('<='), value: '<=', custom: false }, { label: that.localize('startswith'), value: 'startswith', custom: false }, { label: that.localize('endswith'), value: 'endswith', custom: false }, { label: that.localize('contains'), value: 'contains', custom: false }, { label: that.localize('notcontains'), value: 'notcontains', custom: false }, { label: that.localize('isblank'), value: 'isblank', custom: false }, { label: that.localize('isnotblank'), value: 'isnotblank', custom: false } ]; that._localizedDays = localizedNames.days; that._localizedMonths = localizedNames.months; } /** * Map fields data source to match menu's label and value. */ _mapFieldsToMenu() { const that = this; if (!that.fields && !that._valueFields) { return; } that._fields = (that.fields || that._valueFields).map(field => { let menuField = {}; menuField.label = field.label; menuField.value = field.dataField; menuField.dataType = field.dataType; return menuField; }); } /** * Handles menu item click. */ _menuItemClickHandler(event) { const that = this, selectedElement = that._selectedElement.closest('.filter-builder-item'), details = event.detail, value = details.value, label = that.localize(value) || details.label; if (selectedElement) { const selectedIsCondition = selectedElement.closest('.lw-filter-group-condition'), selectedIsGroup = selectedElement.closest('.lw-filter-group'), nodeId = selectedIsCondition ? selectedIsCondition.getAttribute('node-id') : selectedIsGroup.getAttribute('node-id'); let updatedPosition = 2; selectedElement.innerHTML = label; selectedElement.value = value; if (that._editedItem && selectedElement.classList.contains('lw-filter-field-name') && that._editedItem.data[0] !== value) { const valueHTMLnode = selectedElement.parentNode.querySelector('.lw-filter-value'), customOperationsWithoutValue = that.customOperations.map(item => { if (item.hideValue) { return item.name; } }).filter(item => item), operationsWithoutValue = customOperationsWithoutValue.concat(['isblank', 'isnotblank']); that._clearConditionsValue(nodeId, value); that._setInitialFilterOperation(nodeId, value); (operationsWithoutValue.indexOf(value) > -1) ? valueHTMLnode.classList.add('lw-hidden') : valueHTMLnode.classList.remove('lw-hidden'); } if (selectedElement.classList.contains('lw-filter-field-name')) { updatedPosition = 0; } else if (selectedElement.classList.contains('lw-filter-operation')) { const valueHTMLnode = selectedElement.parentNode.querySelector('.lw-filter-value'); let customOperation; if (that.customOperations) { const customOperations = that.customOperations.filter(operation => { return operation.name === value; }); if (customOperations.length > 0) { customOperation = customOperations[0]; } } if (['isblank', 'isnotblank'].indexOf(value) > -1 || (customOperation && customOperation.hideValue)) { that._clearConditionsValue(nodeId); valueHTMLnode.classList.add('lw-hidden'); } else { valueHTMLnode.classList.remove('lw-hidden'); } updatedPosition = 1; } else if (selectedElement.classList.contains('lw-filter-group-operation')) { for (let i = 0; i < that._valueFlat.length; i++) { if (that._valueFlat[i].nodeId === nodeId) { that._valueFlat[i].data = selectedElement.value; } } that._generateValue(); that.$.scrollableContainer.refresh(); return; } for (let i = 0; i < that._valueFlat.length; i++) { if (that._valueFlat[i].nodeId === nodeId) { that._valueFlat[i].data[updatedPosition] = selectedElement.value; } } that._generateValue(); that.$.scrollableContainer.refresh(); return; } const selectedFilterGroup = that._selectedElement.closest('.lw-filter-group'), selectedFilterGroupId = selectedFilterGroup.getAttribute('node-id'); if (that._isMaxLevelExceeded(selectedFilterGroupId + '.0')) { return; } if (value === 'addCondition' && ((that.maxConditions && (that._totalConditions < that.maxConditions)) || !that.maxConditions)) { that._checkFieldsExistence(); const conditionField = that.fields ? that.fields[0] : that._valueFields[0], operation = (conditionField.filterOperations && conditionField.filterOperations.length > 0) ? conditionField.filterOperations[0] : '='; that._addElement('condition', selectedFilterGroupId, [conditionField.dataField, operation, that._defaultValueByType(conditionField.dataType)]); } else if (value === 'addGroup') { that._addElement('group', selectedFilterGroupId, 'and'); } that.$.scrollableContainer.refresh(); } _setInitialFilterOperation(nodeId, fieldName) { const that = this; const newField = that.fields.find(field => field.dataField === fieldName), selectedItem = that._valueFlat.find(item => item.nodeId === nodeId), operationHtmlNode = selectedItem.htmlNode.getElementsByClassName('lw-filter-operation')[0], newFieldOperation = (newField && newField.filterOperations && newField.filterOperations.length > 0) ? newField.filterOperations[0] : '='; let newFieldOperationLabel = that.localize(newFieldOperation); if (!newFieldOperationLabel) { newFieldOperationLabel = that.customOperations.find(operation => operation.name === newFieldOperation).label; } selectedItem.data[1] = newFieldOperation; operationHtmlNode.innerHTML = newFieldOperationLabel; } _checkFieldsExistence() { const that = this; if ((!that.fields || that.fields.length === 0) && (!that._valueFields || that._valueFields.length === 0)) { that.error(that.localize('missingFields', { elementType: that.nodeName.toLowerCase() })); } } /** * Creates new filter condition row * @param {Array} condition (optional). An array with a condition params. If "condition" parameter is not set - in the method is used default value */ _newFilterConditionRow(condition) { condition = condition || []; const that = this, dataField = condition[0] ? condition[0] : that.fields[0].dataField, value = that._formatValueStringRepresentation(condition[2], condition[0]), dataFieldsWithLabels = that.fields ? that.fields.filter(item => { return item.dataField === dataField; }) : that._valueFields.filter(item => { return item.dataField === dataField; }), dataFieldsLabel = dataFieldsWithLabels.length > 0 ? dataFieldsWithLabels[0].label : condition[0]; let operation = that.localize(condition[1]); if (!operation && that.customOperations && that.customOperations.length > 0) { operation = that.customOperations.find(operation => operation.name === condition[1]).label; } let conditionRow = document.createElement('div'), template = `<span class="lw-filter-delete-btn"></span> <span class="filter-builder-item lw-filter-field-name">${dataFieldsLabel}</span> <span class="filter-builder-item lw-filter-operation">${operation || ''}</span> <span class="filter-builder-item lw-filter-value"><span class="lw-value-container">${value}</span></span>`; conditionRow.className = 'lw-filter-group-condition'; conditionRow.innerHTML = template; return conditionRow; } /** * Open an editor at the position of the current editted condition value container * @param {Html element} target - the clicked HTML element. Used to be localized element's data and set into editor */ _openEditor(target) { const that = this, id = target && target.closest('.lw-filter-group-condition') ? target.closest('.lw-filter-group-condition').getAttribute('node-id') : null, valueContainer = target.closest('.lw-filter-value'), editedItem = that._getItemById(id), field = editedItem.data[0] || that.fields[0].dataField || that._valueFields[0].dataField, fieldData = that._getFieldByFieldName(field); let value; if (editedItem) { value = editedItem.data[2]; if (value === undefined) { value = ''; } } else { value = ''; } if (!fieldData) { return; } if (that._editorIsOpen) { that._closeEditor(); } if (that.$.conditionsMenu.opened) { that.$.conditionsMenu.close(); } valueContainer.setAttribute('edited', ''); that._editedItem = editedItem; const fields = that.fields || that._valueFields, fieldItemsMatch = fields.filter(item => { return item.dataField === field; }), foundCustomConditions = that._filterOperationDescriptions.filter(item => { return ((item.value === editedItem.data[1]) && item.custom); }), fieldItem = fieldItemsMatch.length > 0 ? fieldItemsMatch[0] : null, fieldType = (fieldData.lookup && fieldData.lookup.dataSource) ? 'lookup' : fieldItem.dataType; if (foundCustomConditions.length === 0 || !foundCustomConditions[0].editorTemplate) { that._openEditorByFieldType(fieldType, value, fieldData); } else { that._selectedCustomCondition = foundCustomConditions[0]; that._openCustomEditor(fieldType, value, fieldData); } that.$.fireEvent('editorOpening', { value: value, type: fieldType, editedItem: editedItem }); setTimeout(function () { that._editor.focus(); if (that._editor === that.$.numericTextBoxEditor || that._editor === that.$.textBoxEditor) { that.$.scrollableContainer.scrollLeft = that.$.scrollableContainer.$.scrollViewerContainer.scrollLeft; that.$.scrollableContainer.scrollTop = that.$.scrollableContainer.$.scrollViewerContainer.oldTop; that.$.scrollableContainer.$.scrollViewerContainer.scrollLeft = 0; that.$.scrollableContainer.$.scrollViewerContainer.scrollTop = 0; that._editor.$.input.selectionStart = that._editor.$.input.selectionEnd = that._editor.$.input.value.length; } that.$.scrollableContainer.refresh(); that.$.fireEvent('editorOpen', { value: value, type: fieldType, editedItem: editedItem }); }, 0); that._editor.classList.remove('lw-hidden'); that._editorIsOpen = true; that.$.editorsContainer.setAttribute('open', ''); valueContainer.appendChild(that.$.editorsContainer); that.$.scrollableContainer.refresh(); } /** * Open specific editor, regarding field type settings and set it's value * @param {String} fieldType - type of the edited field, each type has different handling * @param {Any} value - the value, that must be set to the editor */ _openEditorByFieldType(fieldType, value, fieldData) { const that = this; switch (fieldType) { case 'lookup': if (!that._comboBoxInitialized) { that._initializeEditor('comboBox'); } that._editor = that.$.comboBoxEditor; that._editor.dataSource = fieldData.lookup.dataSource; that._editor.dropDownAppendTo = that.$.container; that._editor.selectedValues = [value]; break; case 'boolean': if (!that._checkBoxInitialized) { that._initializeEditor('checkBox'); } that._editor = that.$.checkBoxEditor; that._editor.checked = !!value; break; case 'dateTime': if (!that._dateTimePickerInitialized) { that._initializeEditor('dateTimePicker'); } that._editor = that.$.dateTimePickerEditor; that._editor.formatString = that.formatStringDateTime; that._editor.dropDownAppendTo = that.$.container; that._editor.value = value; break; case 'date': if (!that._dateTimePickerInitialized) { that._initializeEditor('dateTimePicker'); } that._editor = that.$.dateTimePickerEditor; that._editor.formatString = that.formatStringDate; that._editor.dropDownAppendTo = that.$.container; that._editor.value = value; break; case 'number': if (!that._numericTextBoxInitialized) { that._initializeEditor('numericTextBox'); } value = value ? value : 0; that._editor = that.$.numericTextBoxEditor; that._editor.value = value; break; case 'array': if (!that._textBoxInitialized) { that._initializeEditor('textBox'); } that._editor = that.$.textBoxEditor; that._editor.value = value.toString(); break; case 'object': if (!that._textBoxInitialized) { that._initializeEditor('textBox'); } value = value ? value : {}; that._editor = that.$.textBoxEditor; that._editor.value = JSON.stringify(value); break; default: if (!that._textBoxInitialized) { that._initializeEditor('textBox'); } that._editor = that.$.textBoxEditor; that._editor.value = value + ''; } } /** * Open custom editor */ _openCustomEditor(fieldType, value, fieldData) { const that = this, editorStructure = that.customOperations[that._selectedCustomCondition.index].editorTemplate(fieldType, value, fieldData); that.$.customEditor.innerHTML = ''; if (editorStructure) { that.$.customEditor.appendChild(editorStructure); } that._editor = that.$.customEditor; } /** * Refreshes the structure */ _refresh() { const that = this; that._generateValue(); that._emptyElementsStructure(); that._generateHTMLStructureFromFlatValue(); that.$.scrollableContainer.refresh(); } /** * Handles scrollbars on resize */ _resizeHandler() { const that = this; that.$.scrollableContainer.refresh(); } /** * scrollViewer wheel handler. */ _scrollViewerWheelHandler(event) { const that = this; if (event.type === 'wheel' && that.$.scrollableContainer.scrollHeight) { event.stopPropagation(); event.preventDefault(); } } /** * Set default values for the menus */ _setInitialValues() { const that = this; that._mapFieldsToMenu(); that._localizeInitialValues(); that.$.conditionsMenu.dropDownAppendTo = that.$.container; that.$.conditionsMenu.dataSource = that._groupOperationDescriptions; that._valueFlat = []; that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null }; } /** * Updates innerHTML of all fields. */ _updatePlaceholder() { const that = this; for (let i = 0; i < that._valueFlat.length; i++) { const item = that._valueFlat[i]; if (item.type === 'condition' && (item.data[2] === null || item.data[2] === '')) { item.htmlNode.querySelector('.lw-value-container').innerHTML = that.valuePlaceholder; } } if (that.$.textBoxEditor) { that.$.textBoxEditor.placeholder = that.valuePlaceholder; } } /** * Updates value in the flat array. * @param {String} nodeId * @param {Any} value * @param {String} updatedComponent * @param {String} valueType */ _updateValueInFlatArray(nodeId, value, updatedComponent, valueType) { const that = this; if (!nodeId || that.disabled) { return; } valueType = valueType || 'string'; updatedComponent = updatedComponent || 'value'; if (value !== null) { switch (valueType) { case 'number': value = parseFloat(value); break; case 'boolean': value = !!value; break; case 'string': value = value + ''; break; } } for (let i = 0; i < that._valueFlat.length; i++) { if (that._valueFlat[i].nodeId === nodeId) { switch (updatedComponent) { case 'column': that._valueFlat[i].data[0] = value; break; case 'filterCondition': that._valueFlat[i].data[1] = value; break; case 'value': that._valueFlat[i].data[2] = value; break; case 'groupCondition': that._valueFlat[i].data = value; break; } } } } /* * Validates if node exists in the internal element's structure. * @param {Any} elementNode - HTML element or nodeId of the element * @param {String} methodName - an array with a new condition settings */ _validateNode(elementNode, methodName) { const that = this; let editedItem; if (elementNode instanceof HTMLElement) { editedItem = that._getItemById(elementNode.getAttribute('node-id')); } else if (typeof elementNode === 'string') { editedItem = that._getItemById(elementNode); } else { that.error(that.localize('wrongElementNode', { elementType: that.nodeName.toLowerCase(), method: methodName })); } if (!editedItem) { that.error(that.localize('wrongElementNode', { elementType: that.nodeName.toLowerCase(), method: methodName })); } return editedItem; } /* * Validates if node exists in the internal element's structure. * @param {Any} data - HTML element or nodeId of the element * @param {Boolean} isCondition - flag defined where the data will be used (condition or group) */ _validateUserData(data, isCondition) { const that = this; if (isCondition) { if (!Array.isArray(data) || data.length < 3) { that.error(that.localize('invalidDataStructure', { elementType: that.nodeName.toLowerCase() })); } } else { const regEx = /^(and|or|notAnd|notOr)$/i; if (!(typeof data === 'string') || !data.match(regEx)) { that.error(that.localize('invalidDataStructure', { elementType: that.nodeName.toLowerCase() })); } } } /** * Validates the structure of the "value" array. */ _validateValue() { const that = this, maxConditions = that.maxConditions, maxConditionsPerGroup = that.maxConditionsPerGroup, maxLevel = that.maxLevel; let totalConditions = 0; if (maxConditions === null && maxConditionsPerGroup === null && maxLevel === null) { return; } const value = that.value, finalResult = []; function isCondition(structure) { return structure.length === 3 && typeof structure[0] === 'string' && typeof structure[1] === 'string'; } function process(structure, level, result) { let conditionsPerGroup = 0; structure.forEach(item => { if (Array.isArray(item)) { if (isCondition(item)) { // condition if (maxConditions !== null && maxConditions === totalConditions || maxConditionsPerGroup !== null && maxConditionsPerGroup === conditionsPerGroup) { return; } result.push(item); conditionsPerGroup++; totalConditions++; } else { // inner group if (maxLevel !== null && maxLevel === level + 1) { return; } const group = []; result.push(group); process(item, level + 1, group); } } else { // operator result.push(item); } }); } process(value, 0, finalResult); that.value = finalResult; } }); /** * lwQueryBuilder custom element. */ LW('lw-query-builder', class QueryBuilder extends LW.BaseElement { /** * Element's properties */ static get properties() { return { 'allowDrag': { value: false, type: 'boolean' }, 'applyMode': { allowValues: ['immediately', 'change'], value: 'change', type: 'string' }, 'customOperations': { value: [], type: 'array', reflectToAttribute: false }, 'customOperators': { value: {}, type: 'object', reflectToAttribute: false }, 'dropDownWidth': { type: 'any', value: '100%' }, //'disableContextMenu': { // value: false, // type: 'boolean' //}, 'fields': { value: null, type: 'array?', reflectToAttribute: false }, 'fieldsMode': { value: 'dynamic', allowedValues: ['dynamic', 'static'], type: 'string' }, 'formatStringDate': { value: 'dd-MMM-yy', type: 'string' }, 'formatStringDateTime': { value: 'dd-MMM-yy HH:mm:ss', type: 'string' }, 'getDynamicField': { value: null, type: 'function?' }, 'icons': { value: { '=': 'equals', '<>': 'notequals', '>': 'greaterthan', '>=': 'greaterthanorequal', '<': 'lessthan', '<=': 'lessthanorequal', 'startswith': 'startswith', 'endswith': 'endswith', 'contains': 'contains', 'notcontains': 'notcontains', 'isblank': 'isblank', 'isnotblank': 'isnotblank' }, type: 'object', reflectToAttribute: false }, //'maxConditions': { // value: null, // type: 'number?' //}, //'maxConditionsPerGroup': { // value: null, // type: 'number?' //}, 'messages': { value: { 'en': { 'add': 'Add', 'addCondition': 'Add Condition', 'addGroup': 'Add Group', 'and': 'And', 'notand': 'Not And', 'or': 'Or', 'notor': 'Not Or', '=': 'Equals', '<>': 'Does not equal', '>': 'Greater than', '>=': 'Greater than or equal to', '<': 'Less than', '<=': 'Less than or equal to', 'startswith': 'Starts with', 'endswith': 'Ends with', 'contains': 'Contains', 'notcontains': 'Does not contain', 'isblank': 'Is blank', 'isnotblank': 'Is not blank', 'wrongParentGroupIndex': '{{elementType}}: Wrong parent group index in "{{method}}" method.', 'wrongElementNode': '{{elementType}}: Incorect node / node Id in "{{method}}" method.', 'invalidDataStructure': '{{elementType}}: Used invalid data structure in updateCondition/updateGroup method.', 'dateTabLabel': 'DATE', 'timeTabLabel': 'TIME', 'queryLabel': 'Query' } }, type: 'object', extend: true }, 'operatorPlaceholder': { value: 'Operator', type: 'string' }, 'propertyPlaceholder': { value: 'Property', type: 'string' }, //'requiredFields': { // value: null, // type: 'array?', // reflectToAttribute: false //}, 'showIcons': { value: false, type: 'boolean' }, 'value': { value: [], type: 'any', reflectToAttribute: false }, 'valueFormatFunction': { value: null, type: 'function?', reflectToAttribute: false }, 'valuePlaceholder': { value: 'Value', type: 'string' } } } /** * Required files */ static get requires() { const requiredFiles = { 'LW.Button': 'lw.button.js', 'LW.Calendar': 'lw.calendar.js', 'LW.CheckBox': 'lw.checkbox.js', 'LW.DateTimePicker': 'lw.datetimepicker.js', 'LW.DropDownList': 'lw.dropdownlist.js', 'LW.Input': 'lw.input.js', 'LW.ListBox': 'lw.listbox.js', 'LW.Menu': 'lw.menu.js', 'LW.NumericTextBox': 'lw.numerictextbox.js', 'LW.ScrollBar': 'lw.scrollbar.js', 'LW.TimePicker': 'lw.timepicker.js', 'LW.Tooltip': 'lw.tooltip.js', 'LW.Utilities.BigNumber': 'lw.math.js', 'LW.Utilities.DateTime': 'lw.date.js', 'LW.Utilities.Draw': 'lw.draw.js', 'LW.Utilities.NumericProcessor': 'lw.numeric.js', }; if (!window.NIComplex) { requiredFiles['LW.Utilities.Complex'] = 'lw.complex.js'; } return requiredFiles; } /** * Element's event listeners. */ static get listeners() { return { 'down': '_downHandler', 'resize': '_resizeHandler', 'editorsContainer.keydown': '_innerContainerKeydownHandler', 'conditionsMenu.close': '_menuCloseHandler', 'conditionsMenu.closing': '_menuClosingHandler', 'conditionsMenu.itemClick': '_menuItemClickHandler', 'contentContainer.change': '_contentContainerChangeHandler', 'scrollableContainer.touchmove': '_scrollableContainerTouchmoveHandler', 'document.down': '_documentDownHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.querybuilder.css' ] } /** * Element's HTML template. */ template() { return `<div id="container" role="presentation"> <lw-scroll-viewer id="scrollableContainer" class="lw-scrollable-container" animation="[[animation]]" right-to-left="[[rightToLeft]]"> <div id="queryLabel" class="lw-query-builder-label lw-unselectable"></div> <div id="contentContainer" class="lw-content-container"></div> </lw-scroll-viewer> <div id="editorsContainer" class="lw-editors-container" role="presentation"> <div id="customEditor" class="lw-custom-editor lw-hidden"></div> </div> <lw-menu id="conditionsMenu" mode="dropDown" class="lw-conditions-menu" theme="[[theme]]" animation="[[animation]]" right-to-left="[[rightToLeft]]"></lw-menu> </div>`; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'animation': case 'theme': ['textBoxEditor', 'numericTextBoxEditor', 'comboBoxEditor', 'dateTimePickerEditor', 'checkBoxEditor'] .forEach(editor => that.$[editor] && (that.$[editor][propertyName] = newValue)); break; case 'formatStringDate': case 'formatStringDateTime': case 'valueFormatFunction': that._refresh(); break; case 'operatorPlaceholder': Array.from((that.shadowRoot || that).querySelectorAll('.lw-filter-operation[placeholder]')).forEach(element => element.firstElementChild.innerHTML = newValue); break; case 'propertyPlaceholder': Array.from((that.shadowRoot || that).querySelectorAll('.lw-filter-field-name[placeholder]')).forEach(element => element.firstElementChild.innerHTML = newValue); break; case 'showIcons': that._closeEditor(); if (newValue) { that._filterOperationDescriptions.map(item => item.icon = that.icons[item.value]); } else { that._filterOperationDescriptions.map(item => delete item.icon); } break; case 'customOperations': case 'fields': case 'value': { const oldValueAsString = JSON.stringify(that._validValue); if (propertyName === 'customOperations') { that._handleCustomOperations(); } else if (propertyName === '') { that._mapFieldsToMenu(); } that._applyValue(); if (that._oldValueAsString !== oldValueAsString) { that._oldValueAsString = oldValueAsString; that.$.fireEvent('change', { value: JSON.parse(oldValueAsString), 'linq': that._parseQueryToLinq(that._validValue) }); } break; } case 'valuePlaceholder': Array.from((that.shadowRoot || that).querySelectorAll('.lw-filter-value[placeholder]')).forEach(element => element.firstElementChild.innerHTML = newValue); break; case 'locale': case 'messages': that._localizeInitialValues(); that._refresh(); that._handleCustomOperations();// if (that.$.dateTimePickerEditor) { if (!that.$.dateTimePickerEditor.messages[that.locale]) { that.$.dateTimePickerEditor.messages[that.locale] = {}; } that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel = that.localize('dateTabLabel'); that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel = that.localize('timeTabLabel'); if (propertyName === 'locale') { that.$.dateTimePickerEditor.locale = that.locale; } else if (propertyName === 'messages') { that.$.dateTimePickerEditor.$.selectDate.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel; that.$.dateTimePickerEditor.$.selectTime.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel; } } break; case 'icons': that._closeEditor(); break; } } /** * Element's ready method. */ ready() { super.ready(); const that = this; if (!that.$.queryLabel.id) { that.$.queryLabel.id = that.id + 'Label'; } that.setAttribute('role', 'dialog'); that.setAttribute('aria-labelledby', that.$.queryLabel.id); if (navigator.platform.toLowerCase().lastIndexOf('mac') !== -1) { that.$.contentContainer.classList.add('mac'); } that._setInitialValues(); that._handleCustomOperations(); that._applyValue(); Object.defineProperty(that, 'value', { get: function () { if (that.context === that) { return that.properties.value.value; } else { return that._validValue; } }, set(value) { that.updateProperty(that, that._properties.value, value); } }); } /** * Returns a LINQ representation of the current value */ getLinq() { const that = this; if (!that._validValue) { return; } return that._parseQueryToLinq(that._validValue) } /** * Set default values for the menus */ _setInitialValues() { const that = this; that._autoScrollCoefficient = LW.Utilities.Core.Browser.Firefox ? 4 : LW.Utilities.Core.Browser.Edge ? 8 : 2; that._isMobile = LW.Utilities.Core.isMobile; that._manuallyAddedFields = []; that._localizeInitialValues(); that.$.conditionsMenu.dropDownAppendTo = that.$.container; that.$.conditionsMenu.dataSource = that._groupOperationDescriptions; that._valueFlat = []; that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null }; } /** * Applies value. */ _applyValue() { const that = this; that._emptyElementsStructure(true); that._validateValue(); //that._setRequiredFields(); that._convertValueToFlat(that.value); that._getFieldsFromValue(); that._mapFieldsToMenu(); that._validateValueByType(); that._generateHTMLStructureFromFlatValue(true); that._restrictNesting(); that._validValue = that._getValidValue(); that._oldValueAsString = JSON.stringify(that._validValue); } /** * Validates the value field inside the conditions according to the dataType of the field */ _validateValueByType() { const that = this; if (!that._valueFlat || !that._valueFlat.length) { return; } const items = that._valueFlat; for (let i = 0; i < items.length; i++) { const item = items[i]; if (item.type !== 'condition') { continue; } const field = item.data[0]; if (!field || item.data.length < 3) { continue; } item.data[2] = that._validateStoredValue(item.data[2], field); } that._generateValue(true); } /** * Set's the requested fields */ _setRequiredFields() { const that = this; if (!that.requiredFields || !that.requiredFields.length) { return; } const currentValue = that.value; let reqGroup = []; for (let i = 0; i < that.requiredFields.length; i++) { const reqField = that.requiredFields[i], field = that.fields.find(field => field.dataField === reqField); if (field) { let valueRecords = []; if (currentValue) { let i = 0; //Doing a lookup on the value for records that contain 'requiredFields' //Modifies the value dynamically while (i < currentValue.length) { const val = currentValue[i]; if (Array.isArray(val)) { let r = 0; while (r < val.length) { let record = val[r]; if (record && record[0] === field.dataField) { valueRecords.push(record); val.splice(r > 0 ? r - 1 : r, 2); continue; } r++; } } if (!val.length) { currentValue.splice(i, 2); continue; } i++; } } //Check if group records exist inside value if (valueRecords) { for (let r = 0; r < valueRecords.length; r++) { reqGroup.push(valueRecords[r]); reqGroup.push('and'); } } else { //If no records create a placeholder reqGroup.push([reqField]); reqGroup.push('and'); } } } //Remove the lastly added 'and' condition if (typeof reqGroup[reqGroup.length - 1] === 'string') { reqGroup.pop(); } //Add the Required Fields on Top of the value that.value.unshift(reqGroup, 'and') } /** * Change event Handler for the ContentContainer * @param {any} event */ _contentContainerChangeHandler(event) { const that = this; event.stopPropagation(); if (that.applyMode !== 'immediately' || !that._editorIsOpen || !that._editor) { return; } const editedHTMLField = that._editor.closest('.filter-builder-item'); if (!editedHTMLField.classList.contains('lw-filter-value')) { that._closeEditor(); } } /** * Map field's data with menu's label and value. */ _mapFieldsToMenu() { const that = this; if (!that.fields && !that._valueFields) { return; } that._fields = (that.fields || that._valueFields).concat(that._manuallyAddedFields).map(field => { return { label: field.label, value: field.dataField, dataType: field.dataType, filterOperations: field.filterOperations, lookup: field.lookup }; }); } /** * Localizes default values for the menus. */ _localizeInitialValues() { const that = this; that.$.queryLabel.innerHTML = that.localize('queryLabel'); that._addOptions = [ { label: that.localize('addCondition'), value: 'addCondition' }, { label: that.localize('addGroup'), value: 'addGroup' } ]; that._groupOperationDescriptions = [ { label: that.localize('and'), value: 'and' }, //{ label: that.localize('notand'), value: 'notand' }, { label: that.localize('or'), value: 'or' } //{ label: that.localize('notor'), value: 'notor' } ]; that._defaultFilterOperationDescriptions = that._filterOperationDescriptions = [ { label: that.localize('='), value: '=', custom: false }, { label: that.localize('<>'), value: '<>', custom: false }, { label: that.localize('>'), value: '>', custom: false }, { label: that.localize('>='), value: '>=', custom: false }, { label: that.localize('<'), value: '<', custom: false }, { label: that.localize('<='), value: '<=', custom: false }, { label: that.localize('startswith'), value: 'startswith', custom: false }, { label: that.localize('endswith'), value: 'endswith', custom: false }, { label: that.localize('contains'), value: 'contains', custom: false }, { label: that.localize('notcontains'), value: 'notcontains', custom: false }, { label: that.localize('isblank'), value: 'isblank', custom: false }, { label: that.localize('isnotblank'), value: 'isnotblank', custom: false } ]; //TODO: To Be moved to _formatValueStringRepresentation const localizedNames = LW.Utilities.DateTime.getLocalizedNames(that.locale); that._localizedDays = localizedNames.days; that._localizedMonths = localizedNames.months; } /** * Add custom operations to the menu's operations list */ _handleCustomOperations() { const that = this; that._filterOperationDescriptions = that._defaultFilterOperationDescriptions.slice(0); for (let i = 0; i < that.customOperations.length; i++) { let operation = that.customOperations[i], existingOperationIndex = that._filterOperationDescriptions.findIndex(op => op.value === operation.name), newOperation = { label: operation.label, value: operation.name, custom: true, index: i, editorTemplate: operation.editorTemplate, valueTemplate: operation.valueTemplate, handleValue: operation.handleValue, hideValue: operation.hideValue }; if (existingOperationIndex > -1) { that._filterOperationDescriptions[existingOperationIndex] = newOperation; continue; } that._filterOperationDescriptions.push(newOperation); } } /** * InnerContainer keydown eventHandler * @param {any} event */ _innerContainerKeydownHandler(event) { const that = this; if (that._editorIsOpen && (event.key === 'Escape' || event.key === 'Enter')) { that._closeEditor(); } } /** * Document down handler - closes menu and/or editor on click outside of the element */ _documentDownHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if ((target.shadowParent && target.shadowParent.closest('.lw-input-drop-down-menu')) || target.closest('.lw-input-drop-down-menu') || that.$.conditionsMenu.contains(target)) { return; } const isDropDown = target.closest('.lw-drop-down'); if (target.getRootNode().host === that || target.closest('lw-query-builder') === that || (isDropDown && that.contains(isDropDown.ownerElement))) { if (that._isMobile) { const currentScroll = that.$.scrollableContainer.scrollTop, currentTop = that.getBoundingClientRect().top; setTimeout(function () { if (that.$.scrollableContainer.scrollTop !== currentScroll || that.getBoundingClientRect().top !== currentTop) { return; } else { const oldContext = that.context; that.context = that; that._clickHandler(event.originalEvent); that.context = oldContext; } }, 250); } else { that._clickHandler(event.originalEvent); } return; } if (that._editorIsOpen && !that._scrollBarDown) { that._closeEditor(); } delete that._scrollBarDown; } /** * Generates HTML structure from flat array and adds/replaces * @param {Array} data - contains dataField, operator and value */ _emptyElementsStructure(emptyValueFlat) { const that = this, contentContainer = that.$.contentContainer; while (contentContainer.firstChild) { contentContainer.removeChild(contentContainer.firstChild); } that._valueFlat = emptyValueFlat ? [] : that._valueFlat; that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null }; } /** * Resize handler */ _resizeHandler() { this.$.scrollableContainer.refresh(); } /** * Returns the number of all conditions */ _getTotalConditions() { return this.getElementsByClassName('lw-filter-group-condition').length; } /** * Finds and returns the valid queries in a Linq expressions * @param {any} expr */ _getQueryFromExpression(expr) { const that = this; let allQueries = []; const getQuery = function (expr) { //string check for expresions const customOperatorsWithExpressions = that.customOperations.filter(op => op.expressionTemplate); for (let i = 0; i < customOperatorsWithExpressions.length; i++) { const operator = customOperatorsWithExpressions[i], expRegex = new RegExp(operator.expressionTemplate.replace(/\(/gm, '\\('). replace(/\)/gm, '\\)').replace(/\[/gm, '\\[').replace(/\]/gm, '\\]'). replace(/"{\d+}"/gm, '\\W*"([^"]*)[^a-zA-Z0-9-\\s\\)]+').replace(/{\d+}/gm, '([@|$]*\\w+(?!\\s)*)\\s{0}'). replace(/ /gm, '\\s'), 'gm'); if (expRegex.test(expr)) { expRegex.lastIndex = 0; let fieldName, value, match = expRegex.exec(expr); match = match.filter((item, index) => match.indexOf(item) === index); //Custom Expression. Expect an object with fieldName and value if (operator.expressionReaderCallback) { let customArguments = operator.expressionReaderCallback(match[0], match.slice(1)); if (customArguments) { fieldName = customArguments.fieldName; value = customArguments.value; } } if (fieldName === undefined) { fieldName = match[1] || ''; } if (value === undefined) { value = match[2] || ''; } allQueries.push({ expr: match[0], query: [fieldName, operator.name, value] }); return match[0] } } } if (!expr) { return; } //Find all valid LinQ expressions and converts them to queries while (expr.length) { if (expr) { expr = expr.trim(); //Removes the starting/ending brackets if (expr[0] === '(' && expr[expr.length - 1] === ')') { expr = expr.trim().replace(/^\(|\)$/gm, ''); } //Removes the logical operators infron and after an expressions expr = expr.replace(/^&{2}|^\|{2}|&{2}$|\|{2}$/gm, '').trim(); } //Check for valid expression const match = getQuery(expr); if (!match) { break; } //Remove the match from the expressions expr = expr.replace(match, '').trim(); } //Returns the final query with the logical operators between the groups return that._constructValueFromQueries(arguments[0], allQueries); } /** * Constructs the final value from LinQ expression */ _constructValueFromQueries(expression, queries) { let newValue = []; //Sorts the queries depending on their possition in the expression queries.sort((a, b) => { return expression.indexOf(a.expr) - expression.indexOf(b.expr) }); //Finds the correct Logical operators between the groups for (let i = 0; i < queries.length; i++) { let previousExpr = queries[i - 1]; if (previousExpr) { const operator = expression.substring(expression.indexOf(previousExpr.expr) + previousExpr.expr.length, expression.indexOf(queries[i].expr)).trim(); newValue.push(operator === '||' ? 'or' : 'and'); } if (queries[i].outher) { queries[i].query.forEach(q => newValue.push(Array.isArray(q) ? [q] : q)); } else { newValue.push(queries[i].query); } } return newValue; } /** * Parses Dynamic LINQ to QueryBuilder value */ _parseLinqToValue() { const that = this, queryString = that.value; let groupStarted = 0, groupStartIndex, leafQueries = []; //Find the query groups surrounded by brackets for (let i = 0; i < queryString.length; i++) { if (queryString[i] === '(') { groupStarted++; if (groupStartIndex === undefined) { groupStartIndex = i; } } else if (queryString[i] === ')' && groupStarted > 0) { groupStarted--; if (groupStarted === 0) { let group = queryString.substring(groupStartIndex, i + 1).trim(); if (group.length && (group.includes('&&') || group.includes('||'))) { leafQueries.push({ expr: group }); } groupStartIndex = undefined; } } } //Handle any expressions that are not surrounded by brackets ( outher groups ) let outherGroups = [], previousGroup; if (leafQueries.length) { for (let g = 0; g < leafQueries.length; g++) { let outherGroup; leafQueries[g].query = that._getQueryFromExpression(leafQueries[g].expr); if (previousGroup) { outherGroup = queryString.substring(queryString.indexOf(previousGroup) + previousGroup.length, queryString.indexOf(leafQueries[g].expr)).trim(); } else { outherGroup = queryString.substring(0, queryString.indexOf(leafQueries[g].expr)).trim(); } if (outherGroup) { outherGroups.push(outherGroup); } previousGroup = leafQueries[g].expr; } } //Handles outher groups after a subGroup if (previousGroup) { outherGroups.push(queryString.substring(queryString.indexOf(previousGroup) + previousGroup.length).trim()); } else { outherGroups.push(queryString.trim()); } //Handles all outher groups for (let i = 0; i < outherGroups.length; i++) { const outherGroup = outherGroups[i].replace(/^&{2}|^\|{2}|&{2}$|\|{2}$/gm, '').trim(); if (outherGroup.length) { leafQueries.push({ expr: outherGroup, query: that._getQueryFromExpression(outherGroup), outher: true }); } } //Builds the final query and sets it as the new value of the element that.set('value', that._constructValueFromQueries(queryString, leafQueries)) } /** * Converts the value to Dynamic Linq expression * @param {any} query */ _getExpressionFromQuery(query) { const that = this, name = query[0], operation = query[1]; let value = query[2]; const operator = that.customOperations.find(customOp => customOp.name === operation); if (!operator || !operator.expressionTemplate) { return ''; } // In the case where a property value has a quotation in it we need to explicitly json // the property value so it is a valid dynamic linq expression when built if (typeof value === 'string' && value.includes('"') && operator.expressionTemplate.includes('"')) { value = JSON.stringify(value).slice(1, -1); } // Handle building of dynamic linq expression based upon the selected property/operation return operator.expressionBuilderCallback ? operator.expressionBuilderCallback(name, operation, value) : operator.expressionTemplate.replace('{0}', name).replace('{1}', value) } /** * Builds a Dynamic Linq expression from the value of the element * @param {any} value */ _parseQueryToLinq(value) { const that = this, logicalOperator = { 'and': '&&', 'or': '||' }; let queryString = ''; for (let i = 0; i < value.length; i++) { const query = value[i]; if (Array.isArray(query)) { if (query.indexOf('and') > -1 || query.indexOf('or') > -1 || (query.length === 1 && Array.isArray(query[0]))) { const nestedQuery = that._parseQueryToLinq(query); if (nestedQuery) { queryString += query.length > 1 ? '(' + nestedQuery + ')' : nestedQuery; } else if (/\s(&|\|){2}\s$/gm.test(queryString)) { //Remove the unnecessary logical operator for the empty expression queryString = queryString.replace(/\s(&|\|){2}\s$/gm, ''); } } else { queryString += that._getExpressionFromQuery(query) || ''; } } else { if (queryString) { queryString += ' ' + logicalOperator[query] + ' '; } } } return queryString; } /** * Validates the structure of the "value" array. */ _validateValue() { const that = this; if (typeof that.value === 'string') { that._parseLinqToValue(); } const value = that.value; if (!Array.isArray(value) || JSON.stringify(value).replace(/[\[\]]/g, '') === '') { that.value = [[[]]]; return; } if (value.length === 3 && typeof value[0] === 'string') { that.value = [[value]]; } if (Array.isArray(value[0]) && value[0].length === 3 && typeof value[0][0] === 'string') { that.value = [value]; } while (typeof value[0] === 'string') { value.shift(); } while (typeof value[value.length - 1] === 'string') { value.pop(); } that.value.forEach(item => { if (Array.isArray(item) && item.length === 0) { item.push([]); } }); } /** * Converts value(represented as nested array) to flat array. Used for internal data representation * @param {Array} groupData - an array with group data * @param {String} nodeId - the id of the current element */ _convertValueToFlat(groupData) { const that = this, operatorList = ['and', 'or', 'notAnd', 'notOr']; if (!groupData) { return; } let totalConditions = 0, totalGroups = 0; function createItems(groupData, groupIndex) { let operator; for (let i = 0; i < groupData.length; i++) { const data = groupData[i], isDataAnOperator = typeof data === 'string' && (operatorList.indexOf(data) > -1 || that.customOperators[data]); let item = { htmlNode: null }; if (isDataAnOperator) { operator = (that.customOperators[data] || data).trim(); continue; } operator = operator || 'and'; //Check if condition/group if (Array.isArray(data)) { let groupConditions = that._valueFlat.filter(item => item.parentId + '' === groupIndex + '').length; //Check if condition if (!data.find(item => Array.isArray(item))) { if (that.maxConditions && totalConditions >= that.maxConditions || that.maxConditionsPerGroup && groupConditions >= that.maxConditionsPerGroup) { continue; } //Create Operator if (i !== 0) { that._valueFlat.push({ nodeId: groupIndex + '.' + groupConditions, type: 'operator', data: operator, parentId: groupIndex + '' }); operator = ''; groupConditions++; } //Create Condition item.nodeId = groupIndex + '.' + groupConditions; item.parentId = groupIndex + ''; item.type = 'condition'; item.data = data; totalConditions++; that._valueFlat.push(item); } else { item.nodeId = (totalGroups += 1) + ''; item.type = 'group'; item.data = operator; that._valueFlat.push(item); createItems(data, item.nodeId); operator = ''; } } } } //Empty the flat value that._valueFlat = []; createItems(groupData, 0); delete that._totalGroups; } /** * Generates an array of field objects, used as a backup when fields property is not set */ _getFieldsFromValue() { const that = this, items = that._valueFlat, fieldsNames = [], fields = []; function getDataType(data) { if (typeof data === 'boolean') { return 'boolean'; } if (data instanceof Date) { if (data.getHours() > 0 || data.getMinutes() > 0 || data.getSeconds() > 0) { return 'dateTime'; } return 'date'; } if (!isNaN(data)) { return 'number'; } return 'string'; } for (let i = 0; i < items.length; i++) { const item = items[i]; if (item.type === 'condition') { const fieldName = item.data[0]; if (fieldName && fieldsNames.indexOf(fieldName) === -1) { const fieldElement = { label: fieldName, dataField: fieldName, dataType: getDataType(item.data[2]), format: null }; fieldsNames.push(fieldName); fields.push(fieldElement); } } } that._valueFields = fields; } /* * Creates new group or condition * @param {String} type - 'group' or 'condition' * @param {Any} parentGroup - html object or group id * @param {Any} data - if type is group - contains group's operator; if type is condition - dataField, operator and value */ _addElement(type, parentGroup, data, noRefresh) { const that = this, siblings = that._valueFlat.filter(item => { return item.parentId === parentGroup }); let addGroupAtPosition = 0, groupSeparator = ''; data = data || (type === 'group' ? 'or' : []); if (siblings.length) { let siblingsIndexes = siblings.map(index => { const indexPath = index.nodeId.split('.'); return parseInt(indexPath[indexPath.length - 1]); }); siblingsIndexes = (siblingsIndexes.length === 0) ? [0] : siblingsIndexes; addGroupAtPosition = siblingsIndexes.reduce((a, b) => Math.max(a, b)) + 1; } if (parentGroup && parentGroup.length > 0) { groupSeparator = '.'; } let itemId = (parentGroup || '') + groupSeparator + (type === 'group' ? that._valueFlat.filter(item => item.type === 'group').length + 1 : addGroupAtPosition); let lastGroupSibling = siblings[0]; if (siblings.length) { for (let s = 0; s < siblings.length; s++) { const sibling = siblings[s], siblingIndex = sibling.nodeId.split('.').pop(); if (parseInt(siblingIndex) > parseInt(lastGroupSibling.nodeId.split('.').pop())) { lastGroupSibling = sibling; } } } else { lastGroupSibling = that._valueFlat.find(item => item.nodeId === parentGroup); } let lastGroupSiblingIndex = lastGroupSibling ? that._valueFlat.indexOf(lastGroupSibling) + 1 : that._valueFlat.length; if (type === 'condition' && siblings.length > 0) { that._valueFlat.splice(lastGroupSiblingIndex, 0, { nodeId: itemId, parentId: parentGroup, type: 'operator', data: ['and'], htmlNode: null }); itemId = (parentGroup || '') + groupSeparator + (addGroupAtPosition + 1); lastGroupSiblingIndex++; } const itemData = { nodeId: itemId, parentId: parentGroup, type: type, data: data, htmlNode: null }; that._valueFlat.splice(lastGroupSiblingIndex, 0, itemData); if (type === 'group') { that._addElement('condition', itemId, [], true); } if (!noRefresh) { that._refresh(); } } /** * Removes a condition and it's HTML representation * @param {Any} elementNode. * @param {String} type. */ _deleteElement(elementNode, type) { const that = this, nodeId = typeof elementNode === 'string' ? elementNode : elementNode.getAttribute('node-id'); if (!nodeId || nodeId.length === 1) { return; } function deleteOperator(index) { const operator = that._valueFlat[index]; //Remove the nested operator for the condition if (operator && operator.type === 'operator') { that._valueFlat.splice(index, 1); operator.htmlNode.parentElement.removeChild(operator.htmlNode); return true; } } function deleteCondition(nodeId) { let item, indexInGroup = 0, groupId = nodeId.split('.'); groupId.pop(); groupId = groupId.join('.'); for (let i = 0; i < that._valueFlat.length; i++) { const flatItem = that._valueFlat[i]; if (flatItem.type !== 'condition') { continue; } if (flatItem.nodeId === nodeId) { item = flatItem; break; } if (flatItem.parentId === groupId) { indexInGroup++; } } const itemIndex = that._valueFlat.indexOf(item); //Remove the condition that._valueFlat.splice(itemIndex, 1); //that._totalConditions--; item.htmlNode.parentElement.removeChild(item.htmlNode); //Remove the operator for the condition const isPreviousOperatorRemoved = deleteOperator(itemIndex - 1); //If the removed condition was 1st in the group, remove the next nested condition as well if (!indexInGroup) { deleteOperator(itemIndex - (isPreviousOperatorRemoved ? 1 : 0)); } const groupNode = that._valueFlat.filter(item => item.nodeId === groupId)[0].htmlNode; if (groupNode.children[1].childElementCount > 0 && groupNode.children[2].hasAttribute('limit-selection') && !groupNode.children[1].lastElementChild.hasAttribute('limit-selection')) { groupNode.children[2].removeAttribute('limit-selection'); } } function deleteGroup(nodeId) { const item = that._valueFlat.filter(item => nodeId === item.nodeId && item.type === 'group')[0]; for (let i = 0; i < that._valueFlat.length; i++) { const nestedItem = that._valueFlat[i], nestedNodeId = nestedItem.nodeId; if (nestedItem.parentId === nodeId) { nestedItem.type === 'group' ? deleteGroup(nestedNodeId) : deleteCondition(nestedNodeId); } } that._valueFlat.indexOf(item) > -1 && that._valueFlat.splice(that._valueFlat.indexOf(item), 1); item.htmlNode.parentElement.removeChild(item.htmlNode); } type === 'group' ? deleteGroup(nodeId) : deleteCondition(nodeId); //Delete the group if it's empty if (!type || type === 'condition') { let groupId = nodeId.split('.'); groupId.pop(); groupId = groupId.join('.'); if (!that._valueFlat.filter(i => i.parentId === groupId).length) { if (that._valueFlat.filter(item => item.type === 'group').length > 1) { deleteGroup(groupId); } //Set the new 0th group if (groupId === '0') { const firstGroup = that._valueFlat.find(item => item.type === 'group'), oldGroupId = firstGroup.nodeId; firstGroup.nodeId = '0'; firstGroup.htmlNode.setAttribute('node-id', '0'); const groupConditions = that._valueFlat.filter(item => item.parentId === oldGroupId); for (let c = 0; c < groupConditions.length; c++) { const con = groupConditions[c]; con.parentId = '0'; con.nodeId = '0.' + c; con.htmlNode.setAttribute('node-id', con.nodeId); } } } //if (that.requiredFields && that.requiredFields.length) { // const firstNonRestrictedGroup = that._valueFlat.find(item => item.type === 'group' && !item.restricted); // if (firstNonRestrictedGroup) { // firstNonRestrictedGroup.htmlNode.querySelector('.lw-filter-group-operator').setAttribute('restricted', ''); // } //} that._generateValue(); } } /** * Generates a flat structure form HTML */ _generateHTMLStructureFromFlatValue(validation) { const that = this, fragment = document.createDocumentFragment(); if (!that._valueFlat || that._valueFlat.length === 0) { return; } //let lastGroup; for (let i = 0; i < that._valueFlat.length; i++) { const item = that._valueFlat[i], customOperation = that.customOperations ? that.customOperations.find(operation => operation.name === item.data[1]) : false, parentGroupHTMLcontainer = item.parentId ? (that.shadowRoot || that).querySelector('[node-id="' + item.parentId + '"]'). querySelector('.lw-filter-group-condition-container') : that.$.contentContainer; if (item.type === 'group') { const groupContainerBlock = document.createElement('div'), groupOperator = that.localize(item.data) || ''; groupContainerBlock.className = 'lw-filter-group'; groupContainerBlock.innerHTML = '<div class="lw-filter-group-operator" role="button" aria-expanded="false" aria-haspopup="menu">' + groupOperator + '</div>' + '<div class="lw-filter-group-condition-container" role="group"></div>' + '<div class="lw-filter-add-condition-btn" role="button" aria-label="Add condition"><div>' + that.localize('add') + '</div></div>' + '<div class="lw-filter-add-btn" role="button" aria-expanded="false" aria-haspopup="menu" aria-label="Add group"></div>'; //Set the group operator 'data' attribute groupContainerBlock.firstElementChild.data = groupOperator; fragment.appendChild(groupContainerBlock); groupContainerBlock.setAttribute('node-id', item.nodeId); that._valueFlat[i].htmlNode = groupContainerBlock; //if (!lastGroup && that.requiredFields && that.requiredFields.length) { // groupContainerBlock.setAttribute('restricted', ''); // item.restricted = true; //} //lastGroup = groupContainerBlock; } else if (item.type === 'condition') { const condition = that._newFilterConditionRow(item.data); condition.setAttribute('node-id', item.nodeId); fragment.appendChild(condition); that._valueFlat[i].htmlNode = condition; if (item.data[0] !== undefined && item.data[1] === undefined) { const validOperations = that._getFilterOperations(that._fields.find(field => field.value === item.data[0])); that._handleOnlyOperation(validOperations, item.data, condition); } else if (['isblank', 'isnotblank'].indexOf(item.data[1]) !== -1 || (customOperation && customOperation.hideValue)) { item.data.splice(2, 1); condition.children[2].classList.add('lw-visibility-hidden'); } } else { const operator = document.createElement('div'); operator.className = 'lw-filter-nested-operator'; operator.setAttribute('node-id', item.nodeId); operator.setAttribute('role', 'button'); operator.setAttribute('aria-expanded', false); operator.setAttribute('aria-haspopup', 'menu'); operator.innerHTML = that.localize(item.data); fragment.appendChild(operator); that._valueFlat[i].htmlNode = operator; } parentGroupHTMLcontainer.appendChild(fragment); } if (validation) { that._validateValueAdvanced(); } that.$.scrollableContainer.refresh(); } /** * Advanced value validation. */ _validateValueAdvanced() { const that = this, value = that.value; let toRefresh = false, toRefreshValue = false, consecutiveStrings = 0; for (let i = 0; i < value.length; i++) { const group = value[i]; if (typeof group === 'string') { continue; } for (let j = group.length - 1; j >= 0; j--) { let item = group[j]; if (Array.isArray(item) && item.length === 0 && j !== group.length - 1) { group.splice(j, 1); if (j === 0) { group.splice(0, 1); } toRefresh = true; } else if (typeof item === 'string') { item = item.toLowerCase(); consecutiveStrings++; if (consecutiveStrings > 1 || item !== 'and' && item !== 'or') { toRefreshValue = true; } continue; } consecutiveStrings = 0; } } if (toRefresh) { that._emptyElementsStructure(true); that._convertValueToFlat(that.value); that._generateHTMLStructureFromFlatValue(); } if (toRefreshValue) { that._generateValue(true); } } /** * Restict nesting in condition groups if a "placeholder" condition is already present. */ _restrictNesting() { const that = this, addConditionBtns = Array.from(that.getElementsByClassName('lw-filter-add-condition-btn')); addConditionBtns.forEach(btn => { const lastCondition = btn.previousElementSibling.lastElementChild; if (lastCondition && lastCondition.hasAttribute('limit-selection')) { btn.setAttribute('limit-selection', ''); } }); } /** * Handles click event according to the target's type (filter button, add button, delete button, etc.). */ _clickHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target; if (that.disabled || !target || !target.closest || (!that._isMobile && event.button !== 0)) { return; } if (that._scrollBarDown) { delete that._scrollBarDown; return; } const isTargetADropDown = target.closest('.lw-drop-down'), targetIsEditor = (that._editor && that._editor.contains(target) || (isTargetADropDown && (that._editor.contains(isTargetADropDown.ownerElement) || that._editor === isTargetADropDown.ownerElement))) || target.closest('.lw-custom-editor'); if (that._editor && that._editorIsOpen && !targetIsEditor) { that._closeEditor(); } const filterItem = target.closest('.lw-filter-group-condition') || target.closest('.lw-filter-nested-operator') || target.closest('.lw-filter-group'); if (!filterItem) { return; } const item = that._getItemById(filterItem.getAttribute('node-id')); if (!item) { return; } that.$.fireEvent('itemClick', { id: item.nodeId, type: item.type, data: item.data }); if (target.closest('.lw-filter-delete-btn')) { that._clickHandlerDeleteButton(item.htmlNode); return; } const isAddButton = target.closest('.lw-filter-add-btn') || target.closest('.lw-filter-add-condition-btn'); //Add group if (isAddButton) { const selectedFilterGroupId = isAddButton.closest('.lw-filter-group').getAttribute('node-id'); if (isAddButton.classList.contains('lw-filter-add-condition-btn') && ((that.maxConditions && (that._getTotalConditions() < that.maxConditions)) || !that.maxConditions)) { that._addElement('condition', selectedFilterGroupId, []); //that._totalConditions++; } else { that._clickHandlerFilterButton(isAddButton.classList, item.nodeId, target); } return; } const isFilterButton = target.closest('.filter-builder-item') || target.closest('.lw-filter-group-operator') || target.closest('.lw-filter-nested-operator'); if (isFilterButton) { const elementClassList = isFilterButton.classList; that._clickHandlerFilterButton(elementClassList, item.nodeId, target); } } /** * down handler */ _downHandler(event) { const that = this; if (!event.originalEvent || (!that._isMobile && event.button !== 0)) { return; } const target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target, isDraggingPossible = that.rightToLeft ? (event.pageX > target.getBoundingClientRect().right) : (event.pageX < target.getBoundingClientRect().left); if (that.allowDrag && target.classList.contains('lw-filter-group-condition') && isDraggingPossible) { const conditions = that._valueFlat.filter(item => item.type === 'condition'); if (conditions.length === 1 || conditions.length === 2 && conditions[0].parentId === conditions[1].parentId && conditions[1].htmlNode.hasAttribute('limit-selection')) { return; } that._dragDetails = { coords: { x: event.pageX, y: event.pageY }, item: target, originalEvent: event }; that.$.scrollableContainer._scrollView.disableSwipeScroll = true; that._hoveredCondition = target; window.getSelection().removeAllRanges(); return; } this._scrollBarDown = target.closest('lw-scroll-bar'); event.stopPropagation(); event.preventDefault(); } /** * scrollableContainer touchmove handler. */ _scrollableContainerTouchmoveHandler(event) { if (this._dragDetails && event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * document move handler. */ _documentMoveHandler(event) { const that = this, dragDetails = that._dragDetails; if (!dragDetails) { return; } const draggedItem = dragDetails.item; if (!dragDetails.feedbackShown) { if (Math.abs(dragDetails.coords.x - event.pageX) > 5 || Math.abs(dragDetails.coords.y - event.pageY) > 5) { const draggedItemData = that._valueFlat.filter(item => item.htmlNode === draggedItem)[0], dragStartEvent = that.$.fireEvent('dragStart', { data: draggedItemData.data, item: draggedItem, originalEvent: event }); if (dragStartEvent.defaultPrevented) { delete that._dragDetails; delete that._hoveredCondition; that.$.scrollableContainer._scrollView.disableSwipeScroll = false; return; } dragDetails.allConditions = Array.from((that.shadowRoot || that).querySelectorAll('.lw-filter-group-condition')); dragDetails.data = draggedItemData; dragDetails.feedback = that._addDragFeedback(); dragDetails.feedbackShown = true; draggedItem.classList.add('dragged'); } else { return; } } const y = event.clientY; let target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target, hoveredItem; that.$.fireEvent('dragging', { data: dragDetails.data, item: draggedItem, originalEvent: event }); that.setAttribute('dragging', ''); dragDetails.feedback.style.left = (event.pageX + 10) + 'px'; dragDetails.feedback.style.top = (event.pageY + 10) + 'px'; if (that._isMobile) { const oldHoveredItem = that._hoveredCondition; if (oldHoveredItem) { oldHoveredItem.classList.remove('drop-target', 'top', 'bottom'); delete that._hoveredCondition; } const realTarget = document.elementFromPoint(event.clientX, y); if (realTarget) { target = realTarget; } } let closestCondition = target.closest('.lw-filter-group-condition'), side; if (closestCondition) { hoveredItem = closestCondition; const rect = hoveredItem.getBoundingClientRect(), topDistance = Math.abs(y - rect.top), bottomDisatnce = Math.abs(y - rect.bottom); side = topDistance < bottomDisatnce ? 'top' : 'bottom'; } else { let closest, closestDistance; dragDetails.allConditions.forEach(condition => { const rect = condition.getBoundingClientRect(), topDistance = Math.abs(y - rect.top), bottomDisatnce = Math.abs(y - rect.bottom), bestDistance = Math.min(topDistance, bottomDisatnce); if (closestDistance === undefined || bestDistance < closestDistance) { closest = condition; closestDistance = bestDistance; side = topDistance < bottomDisatnce ? 'top' : 'bottom'; } }); closestCondition = closest; } if (closestCondition !== draggedItem && !(closestCondition.hasAttribute('limit-selection') && side === 'bottom')) { const conditionsInGroup = Array.from(closestCondition.parentElement.getElementsByClassName('lw-filter-group-condition')), indexOfDraggedItem = conditionsInGroup.indexOf(draggedItem); if (indexOfDraggedItem !== -1) { if (side === 'top' && closestCondition === conditionsInGroup[indexOfDraggedItem + 1] || side === 'bottom' && closestCondition === conditionsInGroup[indexOfDraggedItem - 1]) { closestCondition = undefined; } } } else { closestCondition = undefined; } hoveredItem = closestCondition; dragDetails.side = side; clearInterval(that._dragInterval); that._dragInterval = setInterval(function () { const rect = that.getBoundingClientRect(); if (that.$.scrollableContainer.scrollHeight > 0 && rect.left <= event.clientX && rect.left + rect.width >= event.clientX) { if (y >= rect.top && y <= rect.top + 36) { that.$.scrollableContainer.scrollTop -= that._autoScrollCoefficient; } else if (y >= rect.top + rect.height - 36 && y <= rect.top + rect.height) { that.$.scrollableContainer.scrollTop += that._autoScrollCoefficient; } else { clearInterval(that._dragInterval); } } else { clearInterval(that._dragInterval); } }, 1); if (hoveredItem) { if (that._hoveredCondition && hoveredItem !== that._hoveredCondition) { that._hoveredCondition.classList.remove('drop-target', 'top', 'bottom'); } const hoveredItemGroup = hoveredItem.closest('.lw-filter-group'); if (hoveredItemGroup && hoveredItemGroup.hasAttribute('restricted')) { that._hoveredCondition = undefined; return; } that._hoveredCondition = hoveredItem; hoveredItem.classList.remove('top', 'bottom'); hoveredItem.classList.add(side, 'drop-target'); } else if (that._hoveredCondition) { that._hoveredCondition.classList.remove('drop-target', 'top', 'bottom'); delete that._hoveredCondition; } } /** * Adds drag feedback. */ _addDragFeedback() { const that = this, feedback = document.createElement('div'); that.rightToLeft ? feedback.setAttribute('right-to-left', '') : feedback.removeAttribute('right-to-left'); feedback.className = 'lw-query-builder-drag-feedback'; if (that.theme) { feedback.setAttribute('theme', that.theme); } document.body.appendChild(feedback); return feedback; } /** * document move handler. */ _documentUpHandler(event) { const that = this, dragDetails = that._dragDetails; if (!dragDetails) { if (that.$.conditionsMenu.opened && that._selectedElement && !that._selectedElement.classList.contains('lw-filter-add-btn')) { that.$.conditionsMenu._hoverViaKeyboard(that.$.conditionsMenu.querySelector('lw-menu-item[value="' + that._editedItem.data + '"]')); } return; } const draggedItem = dragDetails.item, draggedItemData = dragDetails.data, hoveredItem = that._hoveredCondition; delete that._dragDetails; delete that._hoveredCondition; that.$.scrollableContainer._scrollView.disableSwipeScroll = false; if (!that.hasAttribute('dragging')) { return; } clearInterval(that._dragInterval); window.getSelection().removeAllRanges(); that.removeAttribute('dragging'); draggedItem.classList.remove('dragged'); dragDetails.feedback.remove(); if (!hoveredItem) { that.$.fireEvent('dragEnd', { data: draggedItemData.data, item: draggedItem, originalEvent: event, target: null, targetData: null, targetSide: null }); return; } const hoveredItemData = that._valueFlat.filter(item => item.htmlNode === hoveredItem)[0], dragEndEvent = that.$.fireEvent('dragEnd', { data: draggedItemData.data, item: draggedItem, originalEvent: event, target: hoveredItem, targetData: hoveredItemData.data, targetSide: dragDetails.side }); hoveredItem.classList.remove('drop-target', 'top', 'bottom'); if (dragEndEvent.defaultPrevented) { return; } const value = that.value, draggedPath = draggedItemData.nodeId.split('.').map(index => parseFloat(index)), groupInValue = value[(draggedPath[0] - 1) * 2], hoveredPath = hoveredItemData.nodeId.split('.').map(index => parseFloat(index)), targetGroupInValue = value[(hoveredPath[0] - 1) * 2]; let operator = 'and'; if (groupInValue.length > 1) { if (draggedPath[1] === 0) { // condition is first in group operator = groupInValue[1]; groupInValue[1] = '!remove!'; } else { // condition is not first in group operator = groupInValue[draggedPath[1] - 1]; groupInValue[draggedPath[1] - 1] = '!remove!'; } } groupInValue[draggedPath[1]] = '!remove!'; if (dragDetails.side === 'top') { targetGroupInValue.splice(hoveredPath[1], 0, draggedItemData.data, operator); } else { targetGroupInValue.splice(hoveredPath[1] + 1, 0, operator, draggedItemData.data); } for (let i = 0; i < value.length; i++) { if (Array.isArray(value[i])) { value[i] = value[i].filter(member => member !== '!remove!'); } } for (let i = value.length - 1; i >= 0; i--) { if (Array.isArray(value[i]) && value[i].length === 0) { if (i === 0) { value.splice(0, 2); } else { value.splice(i - 1, 2); i--; } } } that._emptyElementsStructure(true); that._convertValueToFlat(value); that._generateHTMLStructureFromFlatValue(); that._validValue = that._getValidValue(); const oldValueAsString = JSON.stringify(that._validValue); if (that._oldValueAsString !== oldValueAsString) { that._oldValueAsString = oldValueAsString; that.$.fireEvent('change', { value: JSON.parse(oldValueAsString), 'linq': that._parseQueryToLinq(that._validValue) }); } } /** * Handling click on delete button */ _clickHandlerDeleteButton(item, isEmptyCheck) { const that = this; if (!item || !item.classList) { return; } that._closeEditor(); if (that.getElementsByClassName('lw-filter-group-condition').length === 1) { // resets only condition const containers = that._valueFlat[1].htmlNode.children; that.value = [[[]]]; that._validValue = that._getValidValue(); that._valueFlat[1].data = []; that._valueFlat[1].htmlNode.setAttribute('limit-selection', ''); containers[0].setAttribute('placeholder', ''); containers[1].setAttribute('placeholder', ''); containers[2].setAttribute('placeholder', ''); containers[0].firstElementChild.innerHTML = that.propertyPlaceholder; containers[1].firstElementChild.innerHTML = that.operatorPlaceholder; containers[2].firstElementChild.innerHTML = that.valuePlaceholder; const oldValueAsString = JSON.stringify(that._validValue); if (that._oldValueAsString !== oldValueAsString) { that._oldValueAsString = oldValueAsString; that.$.fireEvent('change', { value: JSON.parse(oldValueAsString), 'linq': that._parseQueryToLinq(that._validValue) }); } return; } if (item.classList.contains('lw-filter-group')) { if (isEmptyCheck && that._valueFlat.filter(conditionItem => conditionItem.parentId === item.getAttribute('node-id')).length > 0) { return; } that._deleteElement(item, 'group'); } else { that._deleteElement(item); } that._generateValue(); that.$.scrollableContainer.refresh(); Array.from(that.$.contentContainer.children).forEach((filterGroup, index) => { const parentId = (index + 1).toString(); filterGroup.setAttribute('node-id', parentId); that._valueFlat.filter(item => item.htmlNode === filterGroup)[0].nodeId = parentId; Array.from(filterGroup.children[1].children).forEach((element, index) => { const valueFlatItem = that._valueFlat.filter(item => item.htmlNode === element)[0], id = parentId + '.' + index; element.setAttribute('node-id', id); valueFlatItem.parentId = parentId; valueFlatItem.nodeId = id; }); }); } /** * Handles menu closing. */ _menuCloseHandler() { const that = this, button = that.$.conditionsMenu.controlledBy; button.setAttribute('aria-expanded', false); button.removeAttribute('aria-controls'); delete that.$.conditionsMenu.controlledBy; } /** * Handles menu closing. */ _menuClosingHandler(event) { const detail = event.detail; if (detail.trigger === 'interaction' && this._selectedElement === detail.target) { event.preventDefault(); } } /** * Handles menu item click. */ _menuItemClickHandler(event) { const that = this, selectedElement = that._selectedElement.closest('.lw-filter-group-operator, .lw-filter-nested-operator'), details = event.detail, value = details.value; let nodeId; if (selectedElement) { selectedElement.innerHTML = that.localize(value) || details.label; selectedElement.value = value; if (selectedElement.classList.contains('lw-filter-nested-operator')) { nodeId = selectedElement.getAttribute('node-id'); } else { nodeId = selectedElement.parentElement.getAttribute('node-id'); } for (let i = 0; i < that._valueFlat.length; i++) { if (that._valueFlat[i].nodeId === nodeId) { that._valueFlat[i].data = selectedElement.value; break; } } that._generateValue(); } else { nodeId = that._selectedElement.parentElement.getAttribute('node-id'); that._addElement('group', null, value); } that.$.scrollableContainer.refresh(); } /** * Creates new filter condition row * @param {Array} condition (optional). An array with a condition params. If "condition" parameter is not set - in the method is used default value */ _newFilterConditionRow(condition = []) { const that = this, dataField = condition[0]; let dataFieldWithLabel = that._fields.find(item => item.value === dataField), dataFieldsLabel = dataFieldWithLabel ? dataFieldWithLabel.label : undefined; let operation; if (dataField === undefined || !dataFieldsLabel && that.fieldsMode === 'static') { condition.length = 0; } else { if (!dataFieldsLabel) { dataFieldWithLabel = that._getDynamicFieldInfo(dataField); dataFieldsLabel = dataFieldWithLabel.label; condition[0] = dataFieldWithLabel.dataField; } const validOperations = that._getFilterOperations(dataFieldWithLabel); operation = validOperations.find(validOperation => validOperation.value === condition[1]); if (!operation) { condition.splice(1, 2); } else { operation = operation.label; } } const value = that._formatValueStringRepresentation(condition[2], condition[0], condition[1]); let conditionRow = document.createElement('div'), id = 'condition' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1), template = '<div class="filter-builder-item lw-filter-field-name" id="' + id + 'Field" ' + (dataFieldsLabel ? '><div class="lw-value-container" role="presentation">' + dataFieldsLabel : 'placeholder><div class="lw-value-container" role="presentation">' + that.propertyPlaceholder) + '</div></div>' + '<div class="filter-builder-item lw-filter-operation" id="' + id + 'Operation" ' + (operation ? '><div class="lw-value-container" role="presentation">' + operation : 'placeholder><div class="lw-value-container" role="presentation">' + that.operatorPlaceholder) + '</div></div>' + '<div class="filter-builder-item lw-filter-value" id="' + id + 'Value" ' + (condition[2] !== undefined ? '><div class="lw-value-container" role="presentation">' + value : 'placeholder><div class="lw-value-container" role="presentation">' + that.valuePlaceholder) + '</div></div>' + '<div class="lw-filter-delete-btn" role="button" aria-label="Close"></div>'; conditionRow.className = 'lw-filter-group-condition'; conditionRow.setAttribute('role', 'group'); conditionRow.innerHTML = template; that._setAriaLabel(conditionRow); if (!condition.length) { conditionRow.setAttribute('limit-selection', ''); } return conditionRow; } /** * Sets the WAI-ARIA property aria-label */ _setAriaLabel(conditionRow) { const label = []; for (let i = 0; i < conditionRow.children.length - 1; i++) { const child = conditionRow.children[i]; if (!child.classList.contains('lw-visibility-hidden') && !child.hasAttribute('placeholder')) { label.push(conditionRow.children[i].innerText); } } if (label.length === 0) { conditionRow.setAttribute('aria-label', 'Empty condition row'); return; } conditionRow.setAttribute('aria-label', label.join(' ')); } /** * Removes a condition and it's HTML representation * @param {Any} value. * @param {String} field. */ _formatValueStringRepresentation(value, field, operation) { const that = this, fieldData = that._getFieldByFieldName(field); let valueFormattedByType; if (!fieldData) { return value; } if (value === undefined || value === null) { return that.valuePlaceholder; } if (operation !== undefined && that.customOperations && that.customOperations.length > 0) { operation = that.customOperations.find(customOperation => customOperation.name === operation); if (operation && operation.valueTemplate) { return '<span>' + operation.valueTemplate(that._editor, value) + '</span>'; } } switch (fieldData.dataType.toLowerCase()) { case 'date': case 'datetime': value = value instanceof Date || typeof value === 'string' || (typeof value === 'number' && !isNaN(value)) ? new LW.Utilities.DateTime(value) : value; value.calendar.days = that._localizedDays; value.calendar.months = that._localizedMonths; value.calendar.locale = that.locale; valueFormattedByType = value.toString(fieldData.dataType === 'date' ? that.formatStringDate : that.formatStringDateTime); break; case 'array': valueFormattedByType = typeof value === 'string' ? value.split(',') : value; break; case 'object': valueFormattedByType = typeof value === 'string' ? value : JSON.stringify(value); break; case 'number': valueFormattedByType = value; break; case 'boolean': valueFormattedByType = !!value; break; default: valueFormattedByType = value + ''; break; } if (!that.valueFormatFunction) { return '<span>' + valueFormattedByType + '</span>'; } return '<span>' + that.valueFormatFunction(valueFormattedByType, field, (fieldData.dataType || 'string')) + '</span>'; } /** * Return field's data by given field name * @param {String} fieldName */ _getFieldByFieldName(fieldName) { return Object.assign({}, this._fields.find(item => item.value === fieldName)); } /** * Refreshes the structure */ _refresh() { const that = this; that._generateValue(); that._emptyElementsStructure(); that._generateHTMLStructureFromFlatValue(); that._restrictNesting(); } /** * Generates the new value of "value" property from flat */ _generateValue(preventEventFiring) { const that = this; let groupsWithItems = [], value = that._valueFlat.slice(0), structure = []; //Get all condition groups for (let i = 0; i < value.length; i++) { const item = value[i]; let group = {}; if (item.type === 'group') { group.nodeId = item.nodeId; group.parentId = item.parentId; group.data = item.data; //group.structure = [item.data || 'or']; //group.structure = item.data ? [item.data] : []; group.structure = []; groupsWithItems.push(group); } } for (let i = 0; i < groupsWithItems.length; i++) { const group = groupsWithItems[i]; //let conditions = [], //operators = []; for (let g = 0; g < value.length; g++) { const item = value[g]; if (item.parentId === group.nodeId) { if (item.type === 'condition') { //const operator = value.filter(item => { // return (item.parentId === group.nodeId && item.type === 'condition' && item.data.length) //}); const operator = value[g - 1]; if (operator && operator.parentId === group.nodeId && operator.type === 'operator') { group.structure.push(operator.data.toString()); } group.structure.push(item.data); } //else if (item.type === 'operator') { // operators.push(item); //} } } //conditions = value.filter(item => { // return (item.parentId === group.nodeId && item.type === 'condition' && item.data.length); //}), //operators = value.filter(item => { // return (item.parentId === group.nodeId && item.type === 'condition' && item.data.length); //}); //for (let i = 0; i < conditions.length; i++) { // i === 0 ? group.structure.unshift(conditions[i].data) : group.structure.push(conditions[i].data); //} } groupsWithItems = groupsWithItems.filter(item => { return (item.structure.length > 0); }); groupsWithItems.sort(function (a, b) { return (b.nodeId.split('.').length - a.nodeId.split('.').length); }); for (let i = 0; i < groupsWithItems.length; i++) { const currentElement = groupsWithItems[i], group = groupsWithItems.filter(item => { return (item.nodeId === currentElement.parentId) })[0]; if (group && group.structure) { group.structure.push(currentElement.structure); continue; } if (currentElement.nodeId === '0') { structure = structure.concat(currentElement.structure); continue; } //Push the group operator if (currentElement.data) { if (i > 0) { structure.push(currentElement.data); } //Concat the group structure structure.push(currentElement.structure); } } //if (groupsWithItems.length > 0) { // that.value = that._valueFlat.length > 1 ? groupsWithItems[groupsWithItems.length - 1].structure : groupsWithItems; //} //else { //const data = that._getItemById('0').data; //that.value = data ? [data] : []; //} that.value = structure; that._validateValue(); that._validValue = that._getValidValue(); if (!preventEventFiring) { const oldValueAsString = JSON.stringify(that._validValue); if (that._oldValueAsString !== oldValueAsString) { that._oldValueAsString = oldValueAsString; that.$.fireEvent('change', { value: JSON.parse(oldValueAsString), 'linq': that._parseQueryToLinq(that._validValue) }); } } } /** * Return item's data by given id * @param {String} id - item's id (or parent id - demending on the second parameter) * @param {Boolean} isParent (optional) - of the items is searched by parentId */ _getItemById(id, isParent) { const that = this, matches = that._valueFlat.filter(item => { if (isParent) { return item.parentId === id; } return item.nodeId === id; }), editedItem = matches.length > 0 ? matches[0] : null; return editedItem; } /** * Validates the value that is going to be stored */ _validateStoredValue(storedValue, fieldName) { const that = this; if (!fieldName && !that._editedItem) { return storedValue; } if (!fieldName) { fieldName = that._editedItem.data[0]; if (!fieldName) { return storedValue; } } const dataType = that._getFieldByFieldName(fieldName).dataType; if (dataType === undefined) { return storedValue + ''; } //Validate the value switch (dataType.toLowerCase()) { case 'date': case 'datetime': storedValue = new LW.Utilities.DateTime(storedValue).toDate(); break; case 'number': if (typeof storedValue !== 'number') { storedValue = parseFloat(storedValue); } break; case 'boolean': if (typeof storedValue !== 'boolean') { storedValue = !!storedValue; } break; case 'object': if (typeof storedValue !== 'object') { storedValue = {}; } break; case 'array': if (!Array.isArray(storedValue)) { storedValue = [storedValue]; } break; default: if (typeof storedValue !== 'string') { storedValue += ''; } break; } return storedValue; } /** * Closes an editor and sets the new value in the value's cotainer * @param {Boolean} preventEventFiring (optional). */ _closeEditor(preventEventFiring) { const that = this; let storedValue; if (!that._editedItem || !that._editorIsOpen) { return; } const editedItem = that._editedItem, //editedRow = editedItem.htmlNode, //nodeId = editedItem.nodeId, editedHTMLField = that._editor.closest('.filter-builder-item'), editedHTMLvalueContainer = editedHTMLField.querySelector('.lw-value-container'), condition = editedHTMLField.parentElement, valueContainer = condition.children[2]; if (that._editor === that.$.dateTimePickerEditor) { that._editor._inputChangeHandler(); storedValue = that._editor.value; if (storedValue) { storedValue = storedValue.toDate(); } } else if (that._editor === that.$.checkBoxEditor) { storedValue = that._editor.checked; } else if (that._editor === that.$.customEditor) { if (that._editor) { const customNumericTextBoxes = Array.from(that._editor.getElementsByTagName('lw-numeric-text-box')); customNumericTextBoxes.forEach(customNumericTextBox => customNumericTextBox._inputBlurHandler()); } storedValue = that._validateStoredValue(that._selectedCustomCondition.handleValue(that._editor)); } else if (that._editor === that.$.numericTextBoxEditor) { that._editor._inputBlurHandler(); storedValue = that._editor.value; } else if (editedHTMLField.classList.contains('lw-filter-value')) { const selectedField = that._getFieldByFieldName(that._editedItem.data[0]); if (selectedField.dataType === 'array') { storedValue = that._editor.value.split(','); } else if (selectedField.dataType === 'object') { storedValue = JSON.parse(that._editor.value); } else { storedValue = that._editor.value; } } else { storedValue = that._editor.value; } //editedHTMLvalueComponent = editedRow.querySelector('.lw-filter-value'), //that._updateValueInFlatArray(nodeId, storedValue, 'value', (valueDataType || 'string')); //Converted the new value to the appropriate type //Update the condition object with the new value if (editedHTMLField.classList.contains('lw-filter-field-name')) { if (storedValue.trim() === '') { that._hideEditor(editedHTMLField, editedItem.data[0] === undefined); return; } if (condition.hasAttribute('limit-selection')) { // "placeholder" condition condition.removeAttribute('limit-selection'); condition.parentElement.nextElementSibling.removeAttribute('limit-selection'); } const existingField = that._fields.find(item => item.label === storedValue), oldFieldValue = editedItem.data[0]; if (existingField) { editedItem.data[0] = existingField.value; } else if (that.fieldsMode === 'dynamic') { const dynamicFieldInfo = that._getDynamicFieldInfo(storedValue); storedValue = dynamicFieldInfo.label; editedItem.data[0] = dynamicFieldInfo.dataField; } else { editedHTMLvalueContainer.innerHTML = that._fields.find(item => item.value === oldFieldValue).label; that._hideEditor(editedHTMLField); return; } editedHTMLvalueContainer.innerHTML = storedValue; that._handleFieldChange([oldFieldValue, editedItem.data[0]], [valueContainer, editedItem, condition]); } else if (editedHTMLField.classList.contains('lw-filter-operation')) { that._handleOperationChange([editedItem, storedValue, that._editor.$.input.dataValue], [editedHTMLvalueContainer, valueContainer]); } else { editedItem.data[2] = storedValue; editedHTMLvalueContainer.innerHTML = that._formatValueStringRepresentation(storedValue, that._editedItem.data[0], that._editedItem.data[1]); } that._generateValue(preventEventFiring); that._hideEditor(editedHTMLField); } /** * Gets the info of a dynamic field. */ _getDynamicFieldInfo(value) { const that = this, dynamicFieldInfo = { label: value, dataField: value, dataType: 'string' }; if (that.getDynamicField) { const customInfo = that.getDynamicField(value); if (customInfo.label) { dynamicFieldInfo.label = customInfo.label; } if (customInfo.dataField) { dynamicFieldInfo.dataField = customInfo.dataField; } if (customInfo.dataType) { dynamicFieldInfo.dataType = customInfo.dataType; } if (customInfo.filterOperations && Array.isArray(customInfo.filterOperations) && customInfo.filterOperations.length > 0) { dynamicFieldInfo.filterOperations = customInfo.filterOperations; } if (customInfo.lookup) { dynamicFieldInfo.lookup = customInfo.lookup; } } that._manuallyAddedFields.push(dynamicFieldInfo); that._mapFieldsToMenu(); return dynamicFieldInfo; } /** * Handles field change. */ _handleFieldChange(fields, elements) { const that = this, oldFieldValue = fields[0], editedItem = elements[1], condition = elements[2], valueContainer = elements[0], newField = that._fields.find(field => field.value === fields[1]), newOperations = that._getFilterOperations(newField), propertySelectedCheck = function () { if (newField.value !== oldFieldValue) { that.$.fireEvent('propertySelected', { label: newField.label, value: newField.value }); } }; if (!oldFieldValue || editedItem.data[1] === undefined) { that._handleOnlyOperation(newOperations, editedItem.data, condition); propertySelectedCheck(); return; } const oldField = that._fields.find(field => field.value === oldFieldValue), oldFieldType = oldField.dataType, newFieldType = newField.dataType; if (newField === oldField || newFieldType === oldFieldType && !newField.filterOperations && !oldField.filterOperations) { return; } const validInNewOperations = !!newOperations.find(operation => operation.value === editedItem.data[1]); if (validInNewOperations) { if (newFieldType === oldFieldType) { return; } if (newFieldType === 'date' && oldFieldType === 'dateTime' || newFieldType === 'dateTime' && oldFieldType === 'date') { // reformat previous value valueContainer.firstElementChild.innerHTML = that._formatValueStringRepresentation(editedItem.data[2], editedItem.data[0], editedItem.data[1]); propertySelectedCheck(); return; } // remove previous value editedItem.data.splice(2, 1); valueContainer.setAttribute('placeholder', ''); valueContainer.firstElementChild.innerHTML = that.valuePlaceholder; propertySelectedCheck(); return; } // remove previous operator and value editedItem.data.splice(1, 2); condition.children[1].setAttribute('placeholder', ''); condition.children[1].firstElementChild.innerHTML = that.operatorPlaceholder; valueContainer.setAttribute('placeholder', ''); valueContainer.firstElementChild.innerHTML = that.valuePlaceholder; valueContainer.classList.remove('lw-visibility-hidden'); that._handleOnlyOperation(newOperations, editedItem.data, condition); propertySelectedCheck(); } /** * Handles change to a field with only one operation. */ _handleOnlyOperation(newOperations, data, condition) { if (newOperations.length === 1) { const onlyOperation = newOperations[0]; data[1] = onlyOperation.value; condition.children[1].removeAttribute('placeholder', ''); condition.children[1].firstElementChild.innerHTML = newOperations[0].label; if (onlyOperation.value === 'isblank' || onlyOperation.value === 'isnotblank' || onlyOperation.custom && onlyOperation.hideValue) { data.splice(2, 1); condition.children[2].classList.add('lw-visibility-hidden'); } } } /** * Handles operation change. */ _handleOperationChange(data, elements) { const that = this, editedItem = data[0], storedLabel = data[1], storedValue = data[2], editedHTMLvalueContainer = elements[0], valueContainer = elements[1], oldOperation = editedItem.data[1] !== undefined ? that._filterOperationDescriptions.find(item => item.value === editedItem.data[1]) : undefined, newOperation = that._filterOperationDescriptions.find(item => item.value === storedValue), newOperationValue = newOperation.value; if (newOperation === oldOperation) { return; } const fieldName = editedItem.data[0], operation = editedItem.data[1], value = editedItem.data[2]; editedItem.data[1] = newOperationValue; editedHTMLvalueContainer.innerHTML = storedLabel; if (newOperationValue === 'isblank' || newOperationValue === 'isnotblank' || newOperation.custom && newOperation.hideValue) { editedItem.data.splice(2, 1); valueContainer.classList.add('lw-visibility-hidden'); } else if (valueContainer.classList.contains('lw-visibility-hidden')) { valueContainer.setAttribute('placeholder', ''); valueContainer.classList.remove('lw-visibility-hidden'); valueContainer.firstElementChild.innerHTML = that.valuePlaceholder; } else if (newOperation.custom) { //Sets that._editor to the custom editor const field = that._getFieldByFieldName(fieldName); if (newOperation.editorTemplate) { const editorStructure = newOperation.editorTemplate(field.dataType, operation, field); if (editorStructure) { that.$.customEditor.innerHTML = ''; that.$.customEditor.appendChild(editorStructure); } } valueContainer.firstElementChild.innerHTML = newOperation.valueTemplate ? newOperation.valueTemplate(that.$.customEditor, value) : value; } else if (value === undefined) { editedItem.data.splice(2, 1); valueContainer.setAttribute('placeholder', ''); valueContainer.firstElementChild.innerHTML = that.valuePlaceholder; } else if (!newOperation.custom) { valueContainer.firstElementChild.innerHTML = value; } } /** * Hides editor. */ _hideEditor(editedHTMLField, placeholder) { const that = this; if (placeholder) { editedHTMLField.setAttribute('placeholder', ''); } editedHTMLField.removeAttribute('edited'); that.$.editorsContainer.removeAttribute('open'); if (that._editor.close) { that._editor.close(); } that._editor.classList.add('lw-hidden'); that._editorIsOpen = that._enterIsPressedInEditor = false; that.$.scrollableContainer.refresh(); that._setAriaLabel(editedHTMLField.parentElement); } /** * Handling click on delete buton */ _clickHandlerFilterButton(elementClassList, itemId, target) { const that = this; function prepareContextMenu(target, dataSource, selectedItem) { that._contextMenuOptions = dataSource.length === 0 ? that._defaultFilterOperationDescriptions : dataSource; that._handleContextMenu(target); if (that.$.conditionsMenu.opened) { that.$.conditionsMenu._discardKeyboardHover(); that.$.conditionsMenu._hoverViaKeyboard(that.$.conditionsMenu.querySelector('lw-menu-item[value="' + selectedItem + '"]')); } } if (target.closest('.lw-editors-container')) { return; } that._closeEditor(); that._editedItem = that._getItemById(itemId); if (elementClassList.contains('lw-filter-add-btn')) { prepareContextMenu(target, that._groupOperationDescriptions); return; } if (!elementClassList.contains('lw-filter-field-name') && (!that._editedItem.data || !that._editedItem.data.length)) { return; } if (elementClassList.contains('lw-filter-group-operator') || elementClassList.contains('lw-filter-nested-operator')) { prepareContextMenu(target, that._groupOperationDescriptions, that._editedItem.data); } else { const filterBuilderItem = target.closest('.filter-builder-item'); filterBuilderItem.removeAttribute('placeholder'); that._openEditor(target); } } /** * Handles context menu position * @param {HTML element} target (optional) - the component that is clicked */ _handleContextMenu(target) { const that = this; if (that._selectedElement === target && that.$.conditionsMenu.opened) { that.$.conditionsMenu.close(); return; } that._closeEditor(); if (that.disableContextMenu) { that._selectedElement = target; return; } const targetCoordinates = target.getBoundingClientRect(), elementCoordinates = that.getBoundingClientRect(), x = targetCoordinates.left + that.$.contentContainer.scrollLeft - elementCoordinates.left, y = targetCoordinates.top + that.$.contentContainer.scrollTop - elementCoordinates.top + targetCoordinates.height; if (target.hasAttribute('aria-haspopup')) { if (that.$.conditionsMenu.controlledBy) { that.$.conditionsMenu.controlledBy.setAttribute('aria-expanded', false); that.$.conditionsMenu.controlledBy.removeAttribute('aria-controls'); } target.setAttribute('aria-controls', that.$.conditionsMenu.id); target.setAttribute('aria-expanded', true); that.$.conditionsMenu.controlledBy = target; } that.$.conditionsMenu.dataSource = that._contextMenuOptions; that.$.conditionsMenu.open(x, y + 3); that._selectedElement = target; that.$.scrollableContainer.refresh(); } /** * Open an editor at the position of the current editted condition value container * @param {Html element} target - the clicked HTML element. Used to be localized element's data and set into editor */ _openEditor(target) { const that = this, id = target && target.closest('.lw-filter-group-condition') ? target.closest('.lw-filter-group-condition').getAttribute('node-id') : null, valueContainer = target.closest('.filter-builder-item'), editedItem = that._getItemById(id); let field = ''; if (editedItem.data[0] !== undefined) { field = editedItem.data[0]; } else if (that._fields.length) { field = that._fields[0].value; } let fieldData = that._getFieldByFieldName(field), value = '', dataValue; //filterItemIndex = target.contains('lw-filter-field-name') ? 0 : (target.contains('lw-filter-operation') ? 1 : 2); //value = editedItem ? editedItem.data[filterItemIndex] : '' || ''; let filterItemIndex; if (valueContainer.classList.contains('lw-filter-field-name')) { filterItemIndex = 0; if (!that._fields) { that._mapFieldsToMenu(); } fieldData.lookup = { dataSource: that._fields.slice(), readonly: false }; value = fieldData.label || ''; dataValue = fieldData.value; } else if (valueContainer.classList.contains('lw-filter-operation')) { filterItemIndex = 1; let filteredOptions = that._getFilterOperations(fieldData); fieldData.lookup = { dataSource: filteredOptions, readonly: true }; let correspondingOption = filteredOptions.find(option => option.value === editedItem.data[filterItemIndex]) || filteredOptions[0]; value = correspondingOption.label; dataValue = correspondingOption.value; } else { filterItemIndex = 2; value = editedItem.data[filterItemIndex]; if (value === undefined) { value = ''; } } if (that._editorIsOpen) { that._closeEditor(); } valueContainer.setAttribute('edited', ''); that._editedItem = editedItem; const fields = that._fields, fieldItemsMatch = fields.filter(item => { return item.value === field; }), foundCustomConditions = that._filterOperationDescriptions.filter(item => { return ((item.value === editedItem.data[1]) && item.custom); }), fieldItem = fieldItemsMatch.length > 0 ? fieldItemsMatch[0] : null, fieldType = (fieldData.lookup && fieldData.lookup.dataSource) ? 'lookup' : fieldItem.dataType; if (filterItemIndex !== 2 || foundCustomConditions.length === 0 || !foundCustomConditions[0].editorTemplate) { that._openEditorByFieldType(fieldType, value, fieldData, dataValue); } else { that._selectedCustomCondition = foundCustomConditions[0]; that._openCustomEditor(fieldType, value, fieldData); } that._editor.classList.remove('lw-hidden'); that._editorIsOpen = true; that.$.editorsContainer.setAttribute('open', ''); valueContainer.appendChild(that.$.editorsContainer); that.$.scrollableContainer.refresh(); if (!that._editor.classList.contains('lw-custom-editor')) { requestAnimationFrame(() => that._editor.focus()); } if (fieldData.lookup && fieldData.lookup.readonly) { that._editor.open(); } } /** * Returns filter operations by field. */ _getFilterOperations(fieldData) { const that = this; let filteredOptions = that._filterOperationDescriptions.slice(); if (fieldData.filterOperations) { filteredOptions = that._filterOperationDescriptions.filter(item => fieldData.filterOperations.indexOf(item.value) > -1); } else { let filterOperationsByType; switch (fieldData.dataType) { case 'date': case 'dateTime': case 'number': filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank']; break; case 'boolean': filterOperationsByType = ['=', '<>', 'isblank', 'isnotblank']; break; case 'object': filterOperationsByType = ['isblank', 'isnotblank']; break; case 'string': filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', 'isblank', 'isnotblank']; break; default: filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank']; break; } filteredOptions = that._filterOperationDescriptions.filter(item => filterOperationsByType.indexOf(item.value) > -1); } if (that.showIcons) { filteredOptions.map(item => item.icon = that.icons[item.value]); } return filteredOptions; } /** * Open custom editor */ _openCustomEditor(fieldType, value, fieldData) { const that = this, editorStructure = that.customOperations[that._selectedCustomCondition.index].editorTemplate(fieldType, value, fieldData); that.$.customEditor.innerHTML = ''; if (editorStructure) { that.$.customEditor.appendChild(editorStructure); } that._editor = that.$.customEditor; } /** * Open specific editor, regarding field type settings and set it's value * @param {String} fieldType - type of the edited field, each type has different handling * @param {Any} value - the value, that must be set to the editor */ _openEditorByFieldType(fieldType, value, fieldData, dataValue) { const that = this; if (fieldType) { switch (fieldType.toLowerCase()) { case 'boolean': that._initializeEditor('checkBox'); that._editor.checked = !!value; return; case 'date': case 'datetime': that._initializeEditor('dateTimePicker'); that._editor.formatString = fieldType === 'date' ? that.formatStringDate : that.formatStringDateTime; that._editor.value = value; return; case 'number': that._initializeEditor('numericTextBox'); that._editor.value = value ? value : 0; return; } } that._initializeEditor('input'); that._editor.dropDownWidth = that.dropDownWidth; if (fieldType === 'lookup') { const minLength = fieldData.lookup.minLength; that._editor.autoCompleteDelay = fieldData.lookup.autoCompleteDelay || 100; that._editor.dataSource = fieldData.lookup.dataSource; that._editor.dropDownAppendTo = that.$.container; that._editor.dropDownButtonPosition = that.rightToLeft ? 'left' : 'right'; that._editor.minLength = isNaN(minLength) || minLength === null ? 1 : minLength; that._editor.readonly = !!fieldData.lookup.readonly; } else { that._editor.dataSource = []; that._editor.dropDownButtonPosition = 'none'; that._editor.readonly = false; } if (fieldType === 'object') { that._editor.value = JSON.stringify(value ? value : {}); } else { if (value === '' && that._editor.readonly) { value = fieldData.lookup.dataSource[0].label || ''; } that._editor.value = value + ''; if (dataValue) { that._editor.$.input.dataValue = dataValue; } } } /** * Initializes Editors instance if it's not initialized. */ _initializeEditor(editor) { const that = this; if (that.$[editor + 'Editor']) { that._editor = that.$[editor + 'Editor']; return; } const editorElement = document.createElement('lw-' + LW.Utilities.Core.toDash(editor)); if (editor === 'numericTextBox') { editorElement.spinButtons = true; editorElement.inputFormat = 'floatingPoint'; } else if (editor === 'dateTimePicker') { editorElement.dropDownAppendTo = that.$.container; editorElement.calendarButton = true; editorElement.dropDownDisplayMode = 'auto'; editorElement.enableMouseWheelAction = true; editorElement.locale = that.locale; if (!editorElement.messages[that.locale]) { editorElement.messages[that.locale] = {}; } editorElement.messages[that.locale].dateTabLabel = that.localize('dateTabLabel'); editorElement.messages[that.locale].timeTabLabel = that.localize('timeTabLabel'); } editorElement.rightToLeft = that.rightToLeft; editorElement.theme = that.theme; editorElement.animation = that.animation; editorElement.$.addClass('lw-hidden underlined'); that.$.editorsContainer.appendChild(editorElement); that._editor = that.$[editor + 'Editor'] = editorElement; } /** * Gets the value without invalid or incomplete conditions. */ _getValidValue() { const that = this, value = that.properties.value.value, result = []; let emptyGroup = false; value.forEach((group) => { if (Array.isArray(group)) { let groupIsValid = false, emptyCondition = false; const groupContent = []; group.forEach((condition) => { if (Array.isArray(condition)) { const field = condition[0], operation = condition[1], val = condition[2]; if (field === undefined || operation === undefined) { emptyCondition = true; return; } if (val !== undefined || operation === 'isblank' || operation === 'isnotblank') { groupIsValid = true; groupContent.push(condition); return; } const operationInfo = that._filterOperationDescriptions.find(currentOperation => currentOperation.value === operation); if (operationInfo.custom && operationInfo.hideValue) { groupIsValid = true; groupContent.push(condition); } else { emptyCondition = true; } } else if (emptyCondition) { emptyCondition = false; } else { groupContent.push(condition); } }); if (groupIsValid) { if (typeof groupContent[groupContent.length - 1] === 'string') { groupContent.pop(); } result.push(groupContent); } else { emptyGroup = true; } } else if (emptyGroup) { emptyGroup = false; } else { result.push(group); } }); if (typeof result[result.length - 1] === 'string') { result.pop(); } return result; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Filter panel custom element. */ LW( 'lw-filter-panel', class FilterPanel extends LW.BaseElement { /** * Filter panel's properties. */ static get properties() { return { 'buttons': { value: [ 'clear', 'filter' ], type: 'array' }, 'data': { value: null, type: 'array?', reflectToAttribute: false }, 'dataField': { value: null, type: 'string?' }, 'dataSource': { value: null, type: 'any', reflectToAttribute: false }, 'evaluateFilterExpression': { value: null, type: 'function?', reflectToAttribute: false }, 'filterType': { value: 'string', allowedValues: [ 'numeric', 'string', 'date', 'boolean' ], type: 'string' }, 'formatString': { value: 'd', type: 'string' }, 'messages': { value: { 'en': { 'addCondition': 'Add Condition', 'addGroup': 'Add Group', 'and': 'and', 'blanks': '(Blanks)', 'cancel': 'Cancel', 'clear': 'Clear', 'contains': 'contains', 'containsCaseSensitive': 'contains (case sensitive)', 'dateTabLabel': 'DATE', 'doesNotContain': 'does not contain', 'doesNotContainCaseSensitive': 'does not contain (case sensitive)', 'empty': 'empty', 'endsWith': 'ends with', 'endsWithCaseSensitive': 'ends with (case sensitive)', 'equal': 'equal', 'equalCaseSensitive': 'equal (case sensitive)', 'filter': 'Filter', 'greaterThan': 'greater than', 'greaterThanOrEqual': 'greater than or equal', 'lessThan': 'less than', 'lessThanOrEqual': 'less than or equal', 'mismatchedProperties': 'lwFilterPanel: The "filterType" and the data type of the selected "dataField" are mismatched.', 'missingProperty': 'lwFilterPanel: When mode is \'excel\', either "data" and "dataField" or "dataSource" of type Array have to be set.', 'notEmpty': 'not empty', 'notEqual': 'not equal', 'notNull': 'not null', 'null': 'null ', 'or': 'or', 'placeholderBoolean': 'Select value', 'placeholderDate': 'Enter date', 'placeholderNumber': 'Enter number', 'placeholderTime': 'Enter time', 'placeholderValue': 'Enter value', 'selectAll': '(Select All)', 'showRows': 'Show rows where:', 'startsWith': 'starts with', 'startsWithCaseSensitive': 'starts with (case sensitive)', 'timeTabLabel': 'TIME' } }, type: 'object', extend: true }, 'mode': { value: 'default', allowedValues: [ 'default', 'excel' ], type: 'string' } }; } /** * Filter panel's event listeners. */ static get listeners() { return { 'cancelButton.click': 'cancel', 'clearButton.click': 'clear', 'filterButton.click': 'filter' }; } /** * Filter panel's HTML template. */ template() { const template = `<div id="container" class="lw-container" role="presentation"> <div id="label" class="lw-filter-panel-label"></div> <div id="mainContainer" role="presentation"></div> <div id="buttonContainer" class="lw-filter-panel-button-container" role="presentation"> <lw-button id="filterButton" class="primary" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"></lw-button> <lw-button id="clearButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"></lw-button> <lw-button id="cancelButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"></lw-button> </div> </div>`; return template; } static get styleUrls() { return [ 'lw.grid.css', 'lw.dropdownlist.css', 'lw.menu.css', 'lw.filterpanel.css', 'lw.textbox.css' ] } /** * Invoked when an instance of custom element is attached to the DOM for the first time. */ ready() { super.ready(); } render() { const that = this, filterType = that.filterType; if ( !that.$.label.id ) { that.$.label.id = that.id + 'Label'; } that.setAttribute( 'role', 'dialog' ); that.setAttribute( 'aria-labelledby', that.$.label.id ); that._localize(); that._setButtonsVisibility(); that._filterType = filterType + 'Filter'; that._filterHandler = new LW.Utilities[ filterType.slice( 0, 1 ).toUpperCase() + filterType.slice( 1 ) + 'FilterHandler' ]( that ); super.render(); } /** * Discards current filtering. */ cancel() { const that = this; that._filterHandler[ that.mode + 'Cancel' ](); that.$.fireEvent( 'cancel' ); } /** * Clears current filtering. */ clear() { const that = this; that._filterHandler[ that.mode + 'Clear' ](); that.$.fireEvent( 'clear' ); } reset() { const that = this; that.$.clearButton.removeAttribute( 'hover' ); that.$.filterButton.removeAttribute( 'hover' ); that.$.cancelButton.removeAttribute( 'hover' ); that._filterHandler[ that.mode + 'Clear' ](); that._filterHandler.filterObject = new LW.Utilities.FilterGroup(); } getFilter() { if ( this._filterHandler ) { const filter = new LW.Utilities.FilterGroup(); for ( let filterProperty in this._filterHandler.filterObject ) { filter[ filterProperty ] = this._filterHandler.filterObject[ filterProperty ]; } return filter; } return null; } /** * Evaluates a filter. */ evaluate( value ) { try { return this._filterHandler.evaluate( value ); } catch ( error ) { return false; } } /** * Applies current filtering. */ filter() { const that = this; that._filterHandler[ that.mode + 'Filter' ](); that.$.fireEvent( 'filter' ); } /** * Gets the current filter state. */ getState() { return this._filterHandler.cachedFilter; } /** * Loads a previously saved filter state. * * @param {Object} state An object returned by the method getState. */ loadState( state ) { try { const that = this; that._filterHandler.cachedFilter = state; that._filterHandler[ that.mode + 'Cancel' ](); } catch ( error ) { // } } /** * Called when a property is changed. */ propertyChangedHandler( propertyName, oldValue, newValue ) { super.propertyChangedHandler( propertyName, oldValue, newValue ); const that = this, filterHandler = that._filterHandler; function clearStoredObjects() { const objectNames = [ 'cachedFilter', 'caseSensitive', 'customExcelFilterObjects', 'customItems', 'dataSource', 'defaultListSelection', 'defaultListSource', 'displayMode', 'filterBuilder', 'filterBuilderObject', 'filterBuilderOperations', 'filterObject', 'firstInput', 'firstList', 'operationsMapping', 'operatorList', 'secondInput', 'secondList', 'timeOnly', 'tree' ]; objectNames.forEach( function ( index ) { delete filterHandler[ objectNames[ index ] ]; } ); delete that._filterHandler; } function reRender() { that.$.mainContainer.innerHTML = ''; clearStoredObjects(); that._filterHandler = new LW.Utilities[ that.filterType.slice( 0, 1 ).toUpperCase() + that.filterType.slice( 1 ) + 'FilterHandler' ]( that ); } switch ( propertyName ) { case 'animation': case 'disabled': case 'unfocusable': switch ( that.mode ) { case 'default': [ filterHandler.firstList, filterHandler.firstInput, filterHandler.logicalOperatorList, filterHandler.secondList, filterHandler.secondInput ].forEach( function ( element ) { element[ propertyName ] = newValue; } ); break; case 'excel': filterHandler.tree[ propertyName ] = newValue; break; case 'filterBuilder': filterHandler.filterBuilder[ propertyName ] = newValue; if ( filterHandler.caseSensitive ) { filterHandler.caseSensitive[ propertyName ] = newValue; } break; } break; case 'buttons': that._setButtonsVisibility(); break; case 'data': case 'dataField': if ( that.mode === 'excel' && !Array.isArray( that.dataSource ) ) { reRender(); } break; case 'dataSource': if ( that.mode === 'excel' ) { reRender(); } break; case 'filterType': that._filterType = newValue + 'Filter'; reRender(); break; case 'mode': reRender(); break; case 'formatString': if ( that.filterType !== 'date' ) { return; } switch ( that.mode ) { case 'default': filterHandler.firstInput.formatString = newValue; filterHandler.secondInput.formatString = newValue; break; case 'excel': reRender(); break; case 'filterBuilder': filterHandler.filterBuilder.formatStringDate = newValue; filterHandler.filterBuilder.formatStringDateTime = newValue; break; } break; case 'locale': case 'messages': { that._localize(); switch ( that.mode ) { case 'default': { const firstListSelection = filterHandler.firstList.selectedIndexes, operatorListSelection = filterHandler.logicalOperatorList.selectedIndexes, secondListSelection = filterHandler.secondList.selectedIndexes, inputs = [ filterHandler.firstInput, filterHandler.secondInput ]; filterHandler.setDefaults(); filterHandler.firstList.dataSource = filterHandler.defaultListSource; filterHandler.logicalOperatorList.dataSource = [ { value: 0, label: that.localize( 'and' ) }, { value: 1, label: that.localize( 'or' ) } ]; filterHandler.secondList.dataSource = filterHandler.defaultListSource; switch ( that.filterType ) { case 'date': inputs.forEach( function ( input ) { if ( !input.messages[ that.locale ] ) { input.messages[ that.locale ] = {}; } input.messages[ that.locale ].dateTabLabel = that.localize( 'dateTabLabel' ); input.messages[ that.locale ].timeTabLabel = that.localize( 'timeTabLabel' ); if ( propertyName === 'locale' ) { input.locale = that.locale; } else { input.$.selectDate.innerHTML = input.messages[ that.locale ].dateTabLabel; input.$.selectTime.innerHTML = input.messages[ that.locale ].timeTabLabel; } if ( input._dropDownDisplayMode === 'timePicker' ) { input.placeholder = that.localize( 'placeholderTime' ); input.placeholder = that.localize( 'placeholderTime' ); } else { input.placeholder = that.localize( 'placeholderDate' ); input.placeholder = that.localize( 'placeholderDate' ); } } ); break; case 'numeric': inputs[ 0 ].placeholder = that.localize( 'placeholderNumber' ); inputs[ 1 ].placeholder = that.localize( 'placeholderNumber' ); break; case 'string': inputs[ 0 ].placeholder = that.localize( 'placeholderValue' ); inputs[ 1 ].placeholder = that.localize( 'placeholderValue' ); break; case 'boolean': inputs[ 0 ].placeholder = that.localize( 'placeholderBoolean' ); inputs[ 1 ].placeholder = that.localize( 'placeholderBoolean' ); break; } filterHandler.firstList.selectedIndexes = firstListSelection; filterHandler.logicalOperatorList.selectedIndexes = operatorListSelection; filterHandler.secondList.selectedIndexes = secondListSelection; break; } case 'excel': filterHandler.tree.selectAll.label = that.localize( 'selectAll' ); if ( filterHandler.tree.blanks ) { filterHandler.tree.blanks.label = that.localize( 'blanks' ); } break; case 'filterBuilder': filterHandler.localizeFilterBuilder(); if ( propertyName === 'messages' ) { filterHandler.filterBuilder._localizeInitialValues(); filterHandler.filterBuilder._refresh(); } filterHandler.filterBuilder.$.scrollableContainer.refresh(); break; } break; } } } /** * Localizes element. */ _localize() { const that = this; that.$.label.innerHTML = that.localize( 'showRows' ); that.$.filterButton.innerHTML = that.localize( 'filter' ); that.$.clearButton.innerHTML = that.localize( 'clear' ); that.$.cancelButton.innerHTML = that.localize( 'cancel' ); } /** * Sets buttons visibility. */ _setButtonsVisibility() { const that = this, buttonsVisibility = that.buttons; [ 'cancel', 'clear', 'filter' ].forEach( function ( button ) { if ( buttonsVisibility.indexOf( button ) !== -1 ) { that[ '$' + button + 'Button' ].removeClass( 'lw-hidden' ); } else { that[ '$' + button + 'Button' ].addClass( 'lw-hidden' ); } } ); } } ); LW.Utilities.Assign( 'BaseFilterHandler', class BaseFilterHandler { constructor ( context ) { const that = this; that.context = context; that.filterObject = new LW.Utilities.FilterGroup(); that.setDefaults(); if ( context.filterType === 'date' ) { const sampleDateTime = new LW.Utilities.DateTime(), formatString = context.formatString, formatStringRegExp = sampleDateTime.getParseRegExp( sampleDateTime.calendar, formatString.replace( /y+/g, 'yyyyy' ) ); that.displayMode = LW.Utilities.DateTime.detectDisplayMode( sampleDateTime, formatString, formatStringRegExp ); that.timeOnly = that.displayMode === 'timePicker'; } if ( context.mode === 'default' ) { that.createDefaultHTMLStructure(); return; } that.operationsMapping = { '=': 'EQUAL', '<>': 'NOT_EQUAL', '<': 'LESS_THAN', '>': 'GREATER_THAN', '<=': 'LESS_THAN_OR_EQUAL', '>=': 'GREATER_THAN_OR_EQUAL', 'isblank': 'EMPTY', 'isnotblank': 'NOT_EMPTY', 'contains': 'CONTAINS', 'notcontains': 'DOES_NOT_CONTAIN', 'startswith': 'STARTS_WITH', 'endswith': 'ENDS_WITH', 'NULL': 'NULL', 'NOT_NULL': 'NOT_NULL' }; if ( context.mode === 'excel' ) { that.createExcelHTMLStructure(); } else if ( context.mode === 'filterBuilder' ) { that.createBuilderHTMLStructure(); } } /** * Sets default source and selection. */ setDefaults() { const that = this, context = that.context; that.defaultListSource = [ { value: 'EQUAL', label: context.localize( 'equal' ) }, { value: 'NOT_EQUAL', label: context.localize( 'notEqual' ) }, { value: 'LESS_THAN', label: context.localize( 'lessThan' ) }, { value: 'LESS_THAN_OR_EQUAL', label: context.localize( 'lessThanOrEqual' ) }, { value: 'GREATER_THAN', label: context.localize( 'greaterThan' ) }, { value: 'GREATER_THAN_OR_EQUAL', label: context.localize( 'greaterThanOrEqual' ) }, { value: 'NULL', label: context.localize( 'null' ) }, { value: 'NOT_NULL', label: context.localize( 'notNull' ) } ]; that.filterBuilderOperations = [ '<', '=', '<>', '<=', '>', '>=', 'NULL', 'NOT_NULL' ]; that.defaultListSelection = 2; } /** * Creates the filter panel's HTML structure in default mode. */ createDefaultHTMLStructure() { const that = this, context = that.context, firstList = document.createElement( 'lw-drop-down-list' ), operatorList = document.createElement( 'lw-drop-down-list' ), secondList = document.createElement( 'lw-drop-down-list' ), fragment = document.createDocumentFragment(); firstList.classList.add( 'lw-filter-panel-list' ); firstList.dataSource = that.defaultListSource; firstList.selectedIndexes = [ that.defaultListSelection ]; operatorList.classList.add( 'lw-filter-panel-operator-list' ); operatorList.dataSource = [ { value: 0, label: context.localize( 'and' ) }, { value: 1, label: context.localize( 'or' ) } ]; secondList.classList.add( 'lw-filter-panel-list' ); secondList.dataSource = that.defaultListSource; secondList.selectedIndexes = [ that.defaultListSelection ]; that.firstList = firstList; that.logicalOperatorList = operatorList; that.secondList = secondList; that.appendInputs(); that.firstInput.classList.add( 'lw-filter-panel-input' ); that.secondInput.classList.add( 'lw-filter-panel-input' ); operatorList.dropDownHeight = 'auto'; operatorList.selectedIndexes = [ 0 ]; [ firstList, that.firstInput, operatorList, secondList, that.secondInput ].forEach( function ( element ) { element.animation = context.animation; element.disabled = context.disabled; element.unfocusable = context.unfocusable; element.dropDownPosition = 'bottom'; element.dropDownAppendTo = 'body'; element.dropDownMaxHeight = 200; element.rightToLeft = context.rightToLeft; fragment.appendChild( element ); } ); that.context.$.mainContainer.appendChild( fragment ); that.cacheFilter( that.defaultListSelection, 0, that.defaultListSelection ); } /** * Caches filter. */ cacheFilter( firstFilterComparison, operator, secondFilterComparison ) { const that = this; that.cachedFilter = { firstFilterComparison: firstFilterComparison, firstFilterValue: that.firstInput.value, logicalOperator: operator, secondFilterComparison: secondFilterComparison, secondFilterValue: that.secondInput.value }; } /** * Applies filter. */ defaultFilter() { const that = this, context = that.context, firstFilterComparison = that.firstList.selectedValues[ 0 ], firstFilterValue = that.getFilterInputValue( that.firstInput ), operator = parseFloat( that.logicalOperatorList.selectedValues[ 0 ] ), secondFilterComparison = that.secondList.selectedValues[ 0 ], secondFilterValue = that.getFilterInputValue( that.secondInput ), filterObject = that.filterObject; filterObject.clear(); if ( firstFilterValue !== '' || [ 'NULL', 'NOT_NULL', 'EMPTY', 'NOT_EMPTY' ].indexOf( firstFilterComparison ) !== -1 ) { const firstFilter = filterObject.createFilter( context._filterType, firstFilterValue, firstFilterComparison, undefined, context.formatString, context.locale, that.firstInput._dropDownDisplayMode === 'timePicker' ); filterObject.addFilter( operator, firstFilter ); } if ( secondFilterValue !== '' || [ 'NULL', 'NOT_NULL', 'EMPTY', 'NOT_EMPTY' ].indexOf( secondFilterComparison ) !== -1 ) { const secondFilter = filterObject.createFilter( context._filterType, secondFilterValue, secondFilterComparison, undefined, context.formatString, context.locale, that.secondInput._dropDownDisplayMode === 'timePicker' ); filterObject.addFilter( operator, secondFilter ); } that.cacheFilter( that.firstList.selectedIndexes[ 0 ], that.logicalOperatorList.selectedIndexes[ 0 ], that.secondList.selectedIndexes[ 0 ] ); } /** * Parses filter input value. */ getFilterInputValue( input ) { return input.value; } /** * Applies filter ('excel' mode). */ excelFilter() { const that = this, context = that.context; if ( Array.isArray( context.dataSource ) ) { that.customExcelFilter(); return; } const tree = that.tree, filterObject = that.filterObject; filterObject.clear(); that.customItems = []; if ( tree._menuItems[ '0' ].selected ) { return; } const selectedIndexes = tree.selectedIndexes; selectedIndexes.forEach( function ( index ) { const item = tree._menuItems[ index ]; if ( item instanceof LW.TreeItem ) { const value = item.value; if ( item.hasAttribute( 'default-item' ) ) { const filterComparison = that.getExcelComparison( value ), filter = filterObject.createFilter( context._filterType, value, filterComparison, undefined, context.formatString, context.locale, that.timeOnly ); filterObject.addFilter( 'or', filter ); } else { that.customItems.push( item ); } } } ); if ( selectedIndexes.length === 0 ) { const filterComparison = that.getExcelComparison( "Empty Filter" ), filter = filterObject.createFilter( context._filterType, "Empty Filter", filterComparison, undefined, context.formatString, context.locale, that.timeOnly ); filterObject.addFilter( 'or', filter ); } that.cachedFilter = selectedIndexes.slice( 0 ); } /** * Applies filter ('excel' mode with custom data source). */ customExcelFilter() { const that = this, tree = that.tree; delete that.customExcelFilterObjects; if ( tree._menuItems[ '0' ].selected ) { return; } const context = that.context, filterObjects = [], selectedIndexes = tree.selectedIndexes; selectedIndexes.forEach( function ( index ) { const item = tree._menuItems[ index ]; if ( item instanceof LW.TreeItem ) { let value = item.value; if ( !Array.isArray( value ) ) { return; } if ( !Array.isArray( value[ 0 ] ) ) { value = [ value ]; } const filterObject = new LW.Utilities.FilterGroup(); for ( let i = 0; i < value.length; i++ ) { const condition = value[ i ], operation = that.operationsMapping[ condition[ 1 ] ], filter = filterObject.createFilter( context._filterType, condition[ 2 ], operation, undefined, context.formatString, context.locale, that.timeOnly ); filterObject.addFilter( 'and', filter ); } filterObjects.push( filterObject ); } } ); that.customExcelFilterObjects = filterObjects; that.cachedFilter = selectedIndexes.slice( 0 ); } /** * Gets filter comparison ('excel' mode). */ getExcelComparison( value ) { return value === '' ? 'NULL' : 'EQUAL'; } /** * Applies filter ('filterBuilder' mode). */ filterBuilderFilter() { const that = this, filterSettings = that.filterBuilder.value, caseSensitive = that.context.filterType === 'string' ? that.caseSensitive.checked : false, filterResult = { filters: [] }; function recursion( currentContext, collection ) { const filterObject = new LW.Utilities.FilterGroup(), operator = currentContext[ 1 ]; collection.logicalOperator = operator; for ( let i = 0; i < currentContext.length; i++ ) { if ( i === 1 ) { continue; } const node = currentContext[ i ]; if ( Array.isArray( node ) ) { if ( Array.isArray( node[ 0 ] ) ) { const subCollection = { filters: [] }; collection.filters.push( subCollection ); recursion( node, subCollection ); } else { filterObject.addFilter( operator, that.createFilterBuilderFilter( filterObject, node, caseSensitive ) ); } } } if ( filterObject.filters.length > 0 ) { collection.filters.push( filterObject ); } } recursion( filterSettings, filterResult ); that.filterBuilderObject = filterResult; that.cachedFilter = { filterBuilder: JSON.parse( JSON.stringify( that.filterBuilder.value ), function ( key, value ) { return /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}).(\d{3})Z$/.test( value ) ? new Date( value ) : value; } ), caseSensitive: caseSensitive }; } /** * Calls the "createFilter" method with the correct arguments. */ createFilterBuilderFilter( filterObject, node, caseSensitive ) { const that = this, context = that.context; let operation = that.operationsMapping[ node[ 1 ] ] if ( caseSensitive && [ 'CONTAINS', 'DOES_NOT_CONTAIN', 'STARTS_WITH', 'ENDS_WITH', 'EQUAL' ].indexOf( operation ) !== -1 ) { operation += '_CASE_SENSITIVE'; } return filterObject.createFilter( context._filterType, node[ 2 ], operation, undefined, context.formatString, context.locale, false ); } /** * Clears filter. */ defaultClear() { const that = this; that.firstList.selectedIndexes = [ that.defaultListSelection ]; that.firstInput.value = ''; that.logicalOperatorList.selectedIndexes = [ 0 ]; that.secondList.selectedIndexes = [ that.defaultListSelection ]; that.secondInput.value = ''; that.filterObject.clear(); that.cacheFilter( that.defaultListSelection, 0, that.defaultListSelection ); } /** * Clears filter ('excel' mode). */ excelClear() { const that = this; if ( that.tree.offsetHeight !== 0 ) { that.tree.select( '0' ); } that.filterObject.clear(); that.cachedFilter = that.tree.selectedIndexes.slice( 0 ); } /** * Clears filter ('filterBuilder' mode). */ filterBuilderClear() { const that = this; that.filterBuilder.value = [ 'and' ]; if ( that.context.filterType === 'string' ) { that.caseSensitive.checked = false; } that.cachedFilter = { filterBuilder: [ 'and' ], caseSensitive: false }; } /** * Cancels current filter application. */ defaultCancel() { const that = this; that.firstList.selectedIndexes = [ that.cachedFilter.firstFilterComparison ]; that.firstInput.value = that.cachedFilter.firstFilterValue; that.logicalOperatorList.selectedIndexes = [ that.cachedFilter.logicalOperator ]; that.secondList.selectedIndexes = [ that.cachedFilter.secondFilterComparison ]; that.secondInput.value = that.cachedFilter.secondFilterValue; } /** * Cancels current filter application ('excel' mode). */ excelCancel() { const that = this; that.tree.selectedIndexes = that.cachedFilter.slice( 0 ); } /** * Cancels current filter application ('filterBuilder' mode). */ filterBuilderCancel() { const that = this; that.filterBuilder.value = that.cachedFilter.filterBuilder; if ( that.context.filterType === 'string' ) { that.caseSensitive.checked = that.cachedFilter.caseSensitive; } } /** * Creates the filter panel's HTML structure in 'excel' mode. */ createExcelHTMLStructure() { const that = this, context = that.context, tree = document.createElement( 'lw-tree' ), uniqueValuesDetails = { data: context.data, dataField: context.dataField, filterType: context._filterType }; if ( !context.dataSource || !Array.isArray( context.dataSource ) ) { if ( !context.data || !context.dataField ) { context.error( context.localize( 'missingProperty' ) ); } if ( context.filterType === 'date' ) { uniqueValuesDetails.formatString = context.formatString; uniqueValuesDetails.displayMode = that.displayMode; that.dataSource = that.filterObject.getUniqueValues( uniqueValuesDetails, context ); try { that.getHierarchicalDataSource( that.displayMode ); } catch ( error ) { context.error( context.localize( 'mismatchedProperties' ) ); } if ( that.timeOnly ) { tree.classList.add( 'standard-excel' ); } else { tree.classList.add( 'date-excel' ); } } else { that.dataSource = that.filterObject.getUniqueValues( uniqueValuesDetails, context ); tree.classList.add( 'standard-excel' ); } if ( typeof context.dataSource === 'function' ) { that.dataSource = context.dataSource( that.dataSource ) || that.dataSource; } } else { that.processCustomDataSource( tree ); } tree.animation = context.animation; tree.disabled = context.disabled; tree.unfocusable = context.unfocusable; tree.dataSource = [ { label: context.localize( 'selectAll' ), value: '', items: that.dataSource, expanded: true, selected: true } ]; tree.selectionMode = 'checkBox'; tree.hasThreeStates = true; tree.toggleMode = 'arrow'; tree.addEventListener( 'collapsing', function ( event ) { if ( event.detail.item.level === 1 ) { event.preventDefault(); } } ); tree._onCompleted = function () { that.cachedFilter = tree.selectedIndexes.slice( 0 ); if ( tree.classList.contains( 'date-excel' ) ) { for ( let path in tree._menuItems ) { if ( path === '0' ) { continue; } const item = tree._menuItems[ path ]; item.firstElementChild.style.paddingLeft = ( ( item.level - 1 ) * 20 - 10 ) + 'px'; } } else { tree._menuItems[ '0' ].firstElementChild.style.paddingLeft = 0; } tree.selectAll = tree._menuItems[ '0' ]; tree.blanks = tree.querySelector( '[label="' + context.localize( 'blanks' ) + '"]' ); } that.tree = tree; context.$.mainContainer.appendChild( tree ); } /** * Processes custom data source in 'excel' mode. */ processCustomDataSource( tree ) { const that = this, context = that.context, dataSource = context.dataSource; tree.classList.add( 'standard-excel' ); that.dataSource = dataSource; } /** * Creates the filter panel's HTML structure in 'filterBuilder' mode. */ createBuilderHTMLStructure() { const that = this, context = that.context, filterBuilder = document.createElement( 'lw-filter-builder' ), dataField = context.dataField, dataType = context.filterType === 'numeric' ? 'number' : context.filterType; that.filterBuilder = filterBuilder; filterBuilder.animation = context.animation; filterBuilder.disabled = context.disabled; filterBuilder.unfocusable = context.unfocusable; filterBuilder.value = [ 'and' ]; filterBuilder.fields = [ { label: dataField, dataField: dataField, dataType: dataType, filterOperations: that.filterBuilderOperations } ]; that.localizeFilterBuilder(); context.$.mainContainer.appendChild( filterBuilder ); if ( dataType === 'string' ) { const caseSensitive = document.createElement( 'lw-check-box' ); caseSensitive.classList.add( 'case-sensitive' ); caseSensitive.innerHTML = 'Case sensitive'; caseSensitive.animation = context.animation; caseSensitive.disabled = context.disabled; caseSensitive.unfocusable = context.unfocusable; caseSensitive.checked = false; that.caseSensitive = caseSensitive; context.$.mainContainer.appendChild( caseSensitive ); } that.filterBuilderObject = { filters: [] }; that.cachedFilter = { filterBuilder: [ 'and' ], caseSensitive: false }; } /** * Localizes filter builder. */ localizeFilterBuilder() { const that = this, context = that.context, filterBuilder = that.filterBuilder; let defaultMessages = filterBuilder.messages[ context.locale ]; if ( !defaultMessages ) { defaultMessages = {}; filterBuilder.messages[ context.locale ] = defaultMessages; } filterBuilder.customOperations = [ { name: 'NULL', label: context.localize( 'null' ), hideValue: true }, { name: 'NOT_NULL', label: context.localize( 'notNull' ), hideValue: true } ]; defaultMessages[ 'addCondition' ] = context.localize( 'addCondition' ); defaultMessages[ 'addGroup' ] = context.localize( 'addGroup' ); defaultMessages[ '<' ] = context.localize( 'lessThan' ); defaultMessages[ '<=' ] = context.localize( 'lessThanOrEqual' ); defaultMessages[ '<>' ] = context.localize( 'notEqual' ); defaultMessages[ '=' ] = context.localize( 'equal' ); defaultMessages[ '>' ] = context.localize( 'greaterThan' ); defaultMessages[ '>=' ] = context.localize( 'greaterThanOrEqual' ); defaultMessages[ 'and' ] = context.localize( 'and' ); defaultMessages[ 'contains' ] = context.localize( 'contains' ); defaultMessages[ 'endswith' ] = context.localize( 'endsWith' ); defaultMessages[ 'isblank' ] = context.localize( 'empty' ); defaultMessages[ 'isnotblank' ] = context.localize( 'notEmpty' ); defaultMessages[ 'notcontains' ] = context.localize( 'doesNotContain' ); defaultMessages[ 'or' ] = context.localize( 'or' ); defaultMessages[ 'startswith' ] = context.localize( 'startsWith' ); defaultMessages[ 'dateTabLabel' ] = context.localize( 'dateTabLabel' ); defaultMessages[ 'timeTabLabel' ] = context.localize( 'timeTabLabel' ); filterBuilder.formatStringDate = context.formatString; filterBuilder.formatStringDateTime = context.formatString; filterBuilder.locale = context.locale; filterBuilder.valuePlaceholder = context.localize( 'filterBuilderPlaceholder' ); } /** * Evaluates a filter. */ evaluate( value ) { const that = this, context = that.context; if ( context.mode === 'default' ) { return that.filterObject.evaluate( value ); } if ( context.mode === 'excel' ) { let result = false; if ( Array.isArray( context.dataSource ) ) { if ( !that.customExcelFilterObjects || that.customExcelFilterObjects.length === 0 ) { return true; } for ( let i = 0; i < that.customExcelFilterObjects.length; i++ ) { result = result || that.customExcelFilterObjects[ i ].evaluate( value ); } return result; } if ( that.customItems && that.customItems.length > 0 ) { if ( that.filterObject.filters.length > 0 ) { result = that.filterObject.evaluate( value ); } if ( that.customItems && context.evaluateFilterExpression ) { for ( let i = 0; i < that.customItems.length; i++ ) { const customCalculation = context.evaluateFilterExpression( value, that.customItems[ i ].value ); if ( customCalculation !== undefined ) { result = result || customCalculation; } } } } else { result = that.filterObject.evaluate( value ); } return result; } function evaluateGroup( group ) { let result = group.logicalOperator === 'and' ? true : false; for ( let i = 0; i < group.filters.length; i++ ) { let currentResult; if ( group.filters[ i ] instanceof LW.Utilities.FilterGroup ) { currentResult = group.filters[ i ].evaluate( value ); } else { currentResult = evaluateGroup( group.filters[ i ] ); } result = group.logicalOperator === 'and' ? result && currentResult : result || currentResult; } return result; } if ( !that.filterBuilderObject.logicalOperator ) { return true; } return evaluateGroup( that.filterBuilderObject ); } } ); LW.Utilities.Assign( 'NumericFilterHandler', class NumericFilterHandler extends LW.Utilities.BaseFilterHandler { /** * Appends inputs specific to filter type. */ appendInputs() { let that = this, firstInput = document.createElement( 'lw-numeric-text-box' ), secondInput = document.createElement( 'lw-numeric-text-box' ); firstInput.placeholder = that.context.localize( 'placeholderNumber' ); secondInput.placeholder = that.context.localize( 'placeholderNumber' ); if ( !LW.NumericTextBox ) { firstInput = document.createElement( 'input' ); secondInput = document.createElement( 'input' ); firstInput.setAttribute( 'aria-label', firstInput.placeholder ); firstInput.classList.add( 'lw-input' ); secondInput.setAttribute( 'aria-label', secondInput.placeholder ); secondInput.classList.add( 'lw-input' ); that.firstInput = firstInput; that.secondInput = secondInput; return; } firstInput.inputFormat = 'floatingPoint'; firstInput.nullable = true; firstInput.spinButtons = true; firstInput.value = null; secondInput.inputFormat = 'floatingPoint'; secondInput.nullable = true; secondInput.spinButtons = true; secondInput.value = null; that.firstInput = firstInput; that.secondInput = secondInput; } /** * Parses filter input value. */ getFilterInputValue( input ) { if ( input.value === null || input.value === '' ) { return ''; } return parseFloat( input.value ); } } ); LW.Utilities.Assign( 'StringFilterHandler', class StringFilterHandler extends LW.Utilities.BaseFilterHandler { /** * Sets default source and selection. */ setDefaults() { const that = this, context = that.context; that.defaultListSource = [ { value: 'EMPTY', label: context.localize( 'empty' ) }, { value: 'NOT_EMPTY', label: context.localize( 'notEmpty' ) }, { value: 'CONTAINS', label: context.localize( 'contains' ) }, { value: 'CONTAINS_CASE_SENSITIVE', label: context.localize( 'containsCaseSensitive' ) }, { value: 'DOES_NOT_CONTAIN', label: context.localize( 'doesNotContain' ) }, { value: 'DOES_NOT_CONTAIN_CASE_SENSITIVE', label: context.localize( 'doesNotContainCaseSensitive' ) }, { value: 'STARTS_WITH', label: context.localize( 'startsWith' ) }, { value: 'STARTS_WITH_CASE_SENSITIVE', label: context.localize( 'startsWithCaseSensitive' ) }, { value: 'ENDS_WITH', label: context.localize( 'endsWith' ) }, { value: 'ENDS_WITH_CASE_SENSITIVE', label: context.localize( 'endsWithCaseSensitive' ) }, { value: 'EQUAL', label: context.localize( 'equal' ) }, { value: 'EQUAL_CASE_SENSITIVE', label: context.localize( 'equalCaseSensitive' ) }, { value: 'NULL', label: context.localize( 'null' ) }, { value: 'NOT_NULL', label: context.localize( 'notNull' ) } ]; that.filterBuilderOperations = [ 'contains', 'isblank', 'isnotblank', 'notcontains', 'startswith', 'endswith', '=', 'NULL', 'NOT_NULL' ]; that.defaultListSelection = 2; } /** * Appends inputs specific to filter type. */ appendInputs() { const that = this, firstInput = document.createElement( 'input' ), secondInput = document.createElement( 'input' ); firstInput.placeholder = that.context.localize( 'placeholderValue' ); firstInput.setAttribute( 'aria-label', firstInput.placeholder ); secondInput.placeholder = that.context.localize( 'placeholderValue' ); secondInput.setAttribute( 'aria-label', secondInput.placeholder ); firstInput.classList.add( 'lw-input' ); secondInput.classList.add( 'lw-input' ); that.firstInput = firstInput; that.secondInput = secondInput; } /** * Gets filter comparison ('excel' mode). */ getExcelComparison( value ) { return value === '' ? 'EMPTY' : 'EQUAL_CASE_SENSITIVE'; } } ); LW.Utilities.Assign( 'DateFilterHandler', class DateFilterHandler extends LW.Utilities.BaseFilterHandler { /** * Appends inputs specific to filter type. */ appendInputs() { let that = this, context = that.context, firstInput = document.createElement( 'lw-date-time-picker' ), secondInput = document.createElement( 'lw-date-time-picker' ); if ( !LW.DateTimePicker ) { firstInput = document.createElement( 'input' ); secondInput = document.createElement( 'input' ); firstInput.placeholder = context.localize( 'placeholderDate' ); firstInput.setAttribute( 'aria-label', firstInput.placeholder ); firstInput.classList.add( 'lw-input' ); secondInput.placeholder = context.localize( 'placeholderDate' ); secondInput.setAttribute( 'aria-label', secondInput.placeholder ); secondInput.classList.add( 'lw-input' ); that.firstInput = firstInput; that.secondInput = secondInput; return; } firstInput.calendarButton = true; firstInput.editMode = 'partial'; firstInput.formatString = context.formatString; firstInput.dropDownDisplayMode = 'auto'; firstInput.locale = context.locale; if ( !firstInput.messages[ context.locale ] ) { firstInput.messages[ context.locale ] = {}; } firstInput.messages[ context.locale ].dateTabLabel = context.localize( 'dateTabLabel' ); firstInput.messages[ context.locale ].timeTabLabel = context.localize( 'timeTabLabel' ); firstInput.nullable = true; firstInput.value = null; secondInput.calendarButton = true; secondInput.editMode = 'partial'; secondInput.formatString = context.formatString; secondInput.dropDownDisplayMode = 'auto'; secondInput.locale = context.locale; if ( !secondInput.messages[ context.locale ] ) { secondInput.messages[ context.locale ] = {}; } secondInput.messages[ context.locale ].dateTabLabel = context.localize( 'dateTabLabel' ); secondInput.messages[ context.locale ].timeTabLabel = context.localize( 'timeTabLabel' ); secondInput.nullable = true; secondInput.value = null; secondInput._onCompleted = function () { if ( secondInput._dropDownDisplayMode === 'timePicker' ) { firstInput.placeholder = context.localize( 'placeholderTime' ); secondInput.placeholder = context.localize( 'placeholderTime' ); } else { firstInput.placeholder = context.localize( 'placeholderDate' ); secondInput.placeholder = context.localize( 'placeholderDate' ); } }; that.firstInput = firstInput; that.secondInput = secondInput; } /** * Parses filter input value. */ getFilterInputValue( input ) { if ( input.value === null ) { return ''; } if ( !LW.DateTimePicker ) { return new Date( input.value ); } const result = input.value.toDate(); if ( this.displayMode === 'calendar' ) { result.setHours( 0, 0, 0 ); } return result; } /** * Clears filter. */ defaultClear() { const that = this; that.firstList.selectedIndexes = [ that.defaultListSelection ]; that.firstInput.value = null; that.logicalOperatorList.selectedIndexes = [ 0 ]; that.secondList.selectedIndexes = [ that.defaultListSelection ]; that.secondInput.value = null; that.filterObject.clear(); that.cacheFilter( that.defaultListSelection, 0, that.defaultListSelection ); } /** * Gets hierarchical data source ('excel' mode). */ getHierarchicalDataSource( displayMode ) { const that = this, dataSource = that.dataSource, mapping = {}, treeSource = []; let blanks; if ( displayMode === 'timePicker' ) { return; } if ( dataSource[ dataSource.length - 1 ].value === '' ) { blanks = dataSource[ dataSource.length - 1 ]; dataSource.pop(); } dataSource.forEach( function ( item ) { const date = item.value, year = date.getFullYear(), month = new Intl.DateTimeFormat( that.context.locale, { month: 'long' } ).format( date ), day = date.getDate(); if ( !mapping[ year ] ) { mapping[ year ] = {}; } if ( !mapping[ year ][ month ] ) { mapping[ year ][ month ] = {}; } if ( !mapping[ year ][ month ][ day ] ) { if ( displayMode === 'calendar' ) { mapping[ year ][ month ][ day ] = date; return; } else { mapping[ year ][ month ][ day ] = {}; } } if ( displayMode === 'calendar' ) { return; } const hours = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds(); if ( !mapping[ year ][ month ][ day ][ hours ] ) { mapping[ year ][ month ][ day ][ hours ] = {}; } if ( !mapping[ year ][ month ][ day ][ hours ][ minutes ] ) { mapping[ year ][ month ][ day ][ hours ][ minutes ] = {}; } if ( !mapping[ year ][ month ][ day ][ hours ][ minutes ][ seconds ] ) { mapping[ year ][ month ][ day ][ hours ][ minutes ][ seconds ] = date; } } ); for ( let year in mapping ) { const yearLevelItem = { label: year, items: [], customAttribute: 'default-item' }; treeSource.push( yearLevelItem ); for ( let month in mapping[ year ] ) { const monthLevelItem = { label: month, items: [], customAttribute: 'default-item' }; yearLevelItem.items.push( monthLevelItem ); for ( let day in mapping[ year ][ month ] ) { const dayLeveItem = { label: day, customAttribute: 'default-item' }; monthLevelItem.items.push( dayLeveItem ); if ( displayMode === 'calendar' ) { dayLeveItem.value = mapping[ year ][ month ][ day ]; continue; } dayLeveItem.items = []; for ( let hours in mapping[ year ][ month ][ day ] ) { const hoursLevelItem = { label: '0'.repeat( 2 - hours.length ) + hours, items: [], customAttribute: 'default-item' }; dayLeveItem.items.push( hoursLevelItem ); for ( let minutes in mapping[ year ][ month ][ day ][ hours ] ) { const minutesLevelItem = { label: ':' + '0'.repeat( 2 - minutes.length ) + minutes, items: [], customAttribute: 'default-item' }; hoursLevelItem.items.push( minutesLevelItem ); for ( let seconds in mapping[ year ][ month ][ day ][ hours ][ minutes ] ) { const secondsLevelItem = { label: ':' + '0'.repeat( 2 - seconds.length ) + seconds, value: mapping[ year ][ month ][ day ][ hours ][ minutes ][ seconds ], customAttribute: 'default-item' }; minutesLevelItem.items.push( secondsLevelItem ); } } } } } } if ( blanks ) { treeSource.push( blanks ); } that.dataSource = treeSource; } } ); LW.Utilities.Assign( 'BooleanFilterHandler', class BooleanFilterHandler extends LW.Utilities.BaseFilterHandler { /** * Caches filter. */ cacheFilter( firstFilterComparison, operator, secondFilterComparison ) { const that = this; that.cachedFilter = { firstFilterComparison: firstFilterComparison, firstFilterValue: that.firstInput.selectedIndexes.slice( 0 ), logicalOperator: operator, secondFilterComparison: secondFilterComparison, secondFilterValue: that.secondInput.selectedIndexes.slice( 0 ) }; } /** * Sets default source and selection. */ setDefaults() { const that = this, context = that.context; that.defaultListSource = [ { value: 'EQUAL', label: context.localize( 'equal' ) }, { value: 'NOT_EQUAL', label: context.localize( 'notEqual' ) }, { value: 'NULL', label: context.localize( 'null' ) }, { value: 'NOT_NULL', label: context.localize( 'notNull' ) } ]; that.filterBuilderOperations = [ '=', '<>', 'NULL', 'NOT_NULL' ]; that.defaultListSelection = 0; } /** * Appends inputs specific to filter type. */ appendInputs() { const that = this, firstInput = document.createElement( 'lw-drop-down-list' ), secondInput = document.createElement( 'lw-drop-down-list' ); firstInput.dataSource = [ { value: true, label: 'true' }, { value: false, label: 'false' } ]; firstInput.placeholder = that.context.localize( 'placeholderBoolean' ); firstInput.selectedIndexes = []; firstInput.selectionMode = 'zeroOrOne'; secondInput.dataSource = [ { value: true, label: 'true' }, { value: false, label: 'false' } ]; secondInput.placeholder = that.context.localize( 'placeholderBoolean' ); secondInput.selectedIndexes = []; secondInput.selectionMode = 'zeroOrOne'; that.firstInput = firstInput; that.secondInput = secondInput; } /** * Parses filter input value. */ getFilterInputValue( input ) { if ( input.selectedValues.length === 0 ) { return ''; } return input.selectedValues[ 0 ] === 'true'; } /** * Clears filter. */ defaultClear() { const that = this; that.firstList.selectedIndexes = [ that.defaultListSelection ]; that.firstInput.selectedIndexes = []; that.logicalOperatorList.selectedIndexes = [ 0 ]; that.secondList.selectedIndexes = [ that.defaultListSelection ]; that.secondInput.selectedIndexes = []; that.filterObject.clear(); that.cacheFilter( that.defaultListSelection, 0, that.defaultListSelection ); } /** * Cancels current filter application. */ defaultCancel() { const that = this; that.firstList.selectedIndexes = [ that.cachedFilter.firstFilterComparison ]; that.firstInput.selectedIndexes = that.cachedFilter.firstFilterValue; that.logicalOperatorList.selectedIndexes = [ that.cachedFilter.logicalOperator ]; that.secondList.selectedIndexes = [ that.cachedFilter.secondFilterComparison ]; that.secondInput.selectedIndexes = that.cachedFilter.secondFilterValue; } } ); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * List Item custom element. */ LW('lw-list-item', class Item extends LW.ContentElement { // Item's properties. static get properties() { return { 'alternationIndex': { value: -1, type: 'int' }, 'color': { value: '', type: 'string' }, 'displayMode': { allowedValues: ['plain', 'checkBox', 'radioButton'], value: 'plain', type: 'string' }, 'grouped': { value: false, type: 'boolean' }, 'selected': { value: false, type: 'boolean' }, 'value': { value: '', type: 'string' }, 'label': { value: '', type: 'string' }, 'details': { value: '', type: 'string' }, 'group': { value: '', type: 'string' }, 'hidden': { value: false, type: 'boolean' }, 'readonly': { value: false, type: 'boolean' } }; } get hasStyleObserver() { return false; } get enableShadowDOM() { return false; } get _focused() { const that = this; if (that.__focused === undefined) { that.__focused = false; } return that.__focused; } set _focused(value) { const that = this; that.__focused = value; if (value) { that.setAttribute('focus', ''); if (that.ownerListBox && that.ownerListBox.ownerElement && LW.ComboBox && that.ownerListBox.ownerElement instanceof LW.ComboBox) { that.ownerListBox.ownerElement.$.input.setAttribute('aria-activedescendant', that.id); } } else { that.removeAttribute('focus'); } } /** * lw-list-item's template. */ template() { return `<div id="container"> <span id='itemInput' class='lw-input lw-hidden'></span> <span class="lw-overlay" id="overlay"></span> <div id="itemContainer" class="lw-content lw-list-item-container"><span class="lw-content-label" inner-h-t-m-l=\'[[innerHTML]]\' role="presentation"><content></content></span><span inner-h-t-m-l=\'[[details]]\' id="details" class="lw-content-details"></span></div> </div>`; } appendChild(node) { const that = this; if (!that.isCompleted || node.classList.contains('lw-ripple')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.itemContainer.innerHTML = ''; if (node instanceof HTMLElement) { that.$.itemContainer.appendChild(node); } } insertBefore(newNode, referenceNode) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } referenceNode.parentNode.insertBefore(newNode, referenceNode); } removeChild(node) { const that = this; if (!that.isCompleted || node.classList.contains('lw-ripple')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (node instanceof HTMLElement) { that.$.itemContainer.removeChild(node); } } attached() { const that = this; super.attached(); that.ownerListBox = that.getListBox(); } /** * lw-list-item's event listeners. **/ static get listeners() { return { 'mouseenter': '_itemOnMouseEnter', 'mouseleave': '_itemOnMouseLeave' }; } /** * Called when the element is ready. Used for one-time configuration of the Item. */ ready() { super.ready(); const that = this; that.setAttribute('role', 'option'); if (that.label !== '') { that.innerHTML = that.label; } else if (that.innerHTML !== '') { that.label = that.innerHTML; } that._setDisplayMode(that.displayMode); that._setItemColor(); that.$.container.noRipple = true; } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); if (propertyName === 'hidden') { if (!newValue) { that.$.removeClass('lw-hidden'); } else { that.$.addClass('lw-hidden'); } } else if (propertyName === 'color') { that._setItemColor(); } else if (propertyName === 'displayMode') { that._setDisplayMode(newValue); } else if (propertyName === 'label' || propertyName === 'value') { const context = that.context; that.context = document; if (propertyName === 'label') { that.innerHTML = newValue; } const listBox = that.getListBox(); listBox._applyTemplate(that); listBox.onItemUpdated(that); that.context = context; } else if (propertyName === 'details') { const context = that.context; that.context = document; that.$.details.innerHTML = newValue; const listBox = that.getListBox(); listBox.onItemUpdated(that); that.context = context; } else if (propertyName === 'innerHTML') { const listBox = that.getListBox(); listBox.onItemUpdated(that); } else if (propertyName === 'selected') { if (newValue) { that.setAttribute('aria-selected', true); } else { const listBox = that.getListBox(); if (that.readonly || that.disabled || !listBox || ['oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'checkBox'].indexOf(listBox.selectionMode) === -1) { that.removeAttribute('aria-selected'); } else { that.setAttribute('aria-selected', false); } } } } getListBox() { const that = this; let parent = that.parentNode; while (parent instanceof LW.ListBox === false && parent !== null) { parent = parent.parentNode; } if (!parent && LW.EnableShadowDOM) { return that.getRootNode().host; } return parent; } /** * Item onMouseEnter event handler. */ _itemOnMouseEnter() { const that = this; if (that.disabled || !that.ownerListBox) { return; } if (LW.ListBox.DragDrop.Dragging && that.ownerListBox.allowDrop) { LW.ListBox.DragDrop.DropDetails = { item: that, position: 'bottom' }; } if (that.ownerListBox.$.verticalScrollBar.thumbCapture || that.ownerListBox.$.horizontalScrollBar.thumbCapture) { return; } that.setAttribute('hover', ''); } /** * Item onMouseMove event handler. */ _itemOnMouseMove(event) { const that = this; if (!that.ownerListBox) { return; } if (LW.ListBox.DragDrop.Dragging && that.ownerListBox.allowDrop && !LW.Utilities.Core.isMobile) { const itemsWithFeedback = [].slice.call(that.ownerListBox.getElementsByClassName('lw-list-item-bottom-line-feedback')); for (let i = 0; i < itemsWithFeedback.length; i++) { itemsWithFeedback[i].$.removeClass('lw-list-item-line-feedback'); itemsWithFeedback[i].$.removeClass('lw-list-item-bottom-line-feedback'); } LW.ListBox.DragDrop.DropDetails = { item: that, position: 'top' }; if (!that.ownerListBox._areCSSVarsSupported) { if (that.ownerListBox._indexOf(that) === that.ownerListBox._items.length - 1 || that.parentNode.lastElementChild === that) { const rect = that.getBoundingClientRect(); if (event.pageY - window.pageYOffset > rect.top + (rect.height / 2) - 1) { LW.ListBox.DragDrop.DropDetails = { item: that, position: 'bottom' }; } } return; } that.$.removeClass('lw-list-item-line-feedback'); that.$.removeClass('lw-list-item-bottom-line-feedback'); if (that.ownerListBox.sorted && that.ownerListBox.autoSort) { return; } const visibleItems = that.ownerListBox._items.filter(item => !item.hidden); if (visibleItems.indexOf(that) === visibleItems.length - 1 || that.parentNode.lastElementChild === that) { const rect = that.getBoundingClientRect(); if (event.pageY - window.pageYOffset > rect.top + (rect.height / 2) - 1) { that.$.addClass('lw-list-item-bottom-line-feedback'); LW.ListBox.DragDrop.DropDetails = { item: that, position: 'bottom' }; } else if (!arguments[1]) { that.$.addClass('lw-list-item-line-feedback'); } } else if (!arguments[1]) { that.$.addClass('lw-list-item-line-feedback'); } } } /** * Item onMouseLeave event handler. */ _itemOnMouseLeave() { const that = this; if (!that.ownerListBox) { return; } if (LW.ListBox.DragDrop.Dragging) { that.$.removeClass('lw-list-item-line-feedback'); that.$.removeClass('lw-list-item-bottom-line-feedback'); } that.removeAttribute('hover'); } _setDisplayMode(value) { const that = this; const listBox = that.getListBox(); if (listBox) { const displayMode = listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton' ? listBox.selectionMode : 'plain'; that.displayMode = value = displayMode; } if (value === 'plain') { that.$itemInput.addClass('lw-hidden'); return; } that.$itemInput.removeClass('lw-hidden'); } /** * Set's the color property */ _setItemColor() { const that = this, label = that.querySelector('.lw-content-label'), color = /(^#[0-9A-F]{3}$)|(^#[0-9A-F]{6}$)|(^#[0-9A-F]{8}$)/i.test(that.color) ? that.color : ''; //HEX check label.style.backgroundColor = color; label.style.color = that._getContrastColor(color); } /** * Returns a contrasting color of the target color * @param {any} color - HEX */ _getContrastColor(color) { if (!color) { return ''; } function hexToRgb(h, e, x) { return [parseInt(h, 16), parseInt(e, 16), parseInt(x, 16)]; } let rgb = hexToRgb(color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)), luminance = (0.299 * rgb[0] + 0.61 * rgb[1] + 0.114 * rgb[2]) / 255; if (parseFloat(luminance.toFixed(2)) > 0.65) { return '#000000'; } else { return '#FFFFFF'; } } }); /** * List Items Group custom element. */ LW('lw-list-items-group', class ListItemsGroup extends LW.ContentElement { // Item's properties. static get properties() { return { 'label': { value: '', type: 'string' } }; } get enableShadowDOM() { return false; } /** * lw-list-items-group's template. */ template() { return `<div id="container" role="presentation"> <span id="itemsLabel" class="lw-list-items-group-label">[[label]]</span> <div id="listItemsGroupContainer" inner-h-t-m-l=\'[[innerHTML]]\' class="lw-list-items-group-container" role="presentation"> <content></content> </div> </div>`; } appendChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (node instanceof HTMLElement) { that.$.listItemsGroupContainer.appendChild(node); } } removeChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (node instanceof HTMLElement) { that.$.listItemsGroupContainer.removeChild(node); } } getListBox() { const that = this; let parent = that.parentNode; while (parent instanceof LW.ListBox === false && parent !== null) { parent = parent.parentNode; } return parent; } attached() { const that = this; super.attached(); if (!that.ownerListBox) { that.ownerListBox = that.getListBox(); } that.setAttribute('role', 'group'); if (!that.$.itemsLabel.id) { that.$.itemsLabel.id = that.id + 'Label'; } that.setAttribute('aria-labelledby', that.$.itemsLabel.id); } }); /** * List box custom element. */ LW('lw-list-box', class ListBox extends LW.ScrollViewer { /** * ListBox's properties */ static get properties() { return { 'allowDrag': { value: false, type: 'boolean' }, 'allowDrop': { value: false, type: 'boolean' }, 'alternationStart': { value: 0, type: 'int' }, 'alternationEnd': { value: 0, type: 'int' }, 'alternationCount': { value: 0, type: 'int' }, 'autoSort': { value: true, type: 'boolean' }, 'dataSource': { value: null, type: 'any?', reflectToAttribute: false }, 'dragFeedbackFormatFunction': { value: null, type: 'function?' }, 'dragOffset': { value: [10, 10], type: 'array' }, 'displayLoadingIndicator': { value: false, type: 'boolean' }, 'displayMember': { value: '', type: 'string' }, 'shadowDomMode': { allowedValues: ['light', 'shadow'], value: 'shadow', type: 'string' }, 'dropAction': { value: 'move', type: 'string', allowedValues: ['copy', 'move', 'none'] }, 'editable': { value: false, type: 'boolean' }, 'filterable': { value: false, type: 'boolean' }, 'filterCallback': { value: null, type: 'function?' }, 'filterMode': { value: 'containsIgnoreCase', allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase', 'custom'], type: 'string' }, 'filterInputPlaceholder': { value: '', type: 'string' }, 'grouped': { value: false, type: 'boolean' }, 'groupMember': { value: '', type: 'string' }, 'itemTemplate': { value: null, type: 'any' }, 'itemHeight': { value: null, type: 'number?' }, 'incrementalSearchDelay': { value: 700, type: 'number?' }, 'incrementalSearchMode': { value: 'startsWithIgnoreCase', allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'], type: 'string' }, 'itemMeasureMode': { value: 'auto', allowedValues: ['auto', 'precise'], type: 'string' }, 'loadingIndicatorPlaceholder': { value: 'Loading...', type: 'string' }, 'loadingIndicatorPosition': { value: 'center', allowedValues: ['bottom', 'center', 'top'], type: 'string' }, 'messages': { extend: true, value: { 'en': { 'overridingProperties': '{{elementType}}: Overriding properties {{property1}} and {{property2}} applied. The "{{property1}}" property is used by default.', 'invalidIndex': '{{elementType}}: "{{method}}" method accepts an index of type number or an Array of numbers.', 'indexOutOfBound': '{{elementType}}: Out of bound index/indexes in "{{method}}" method.', 'invalidItem': '{{elementType}}: "{{method}}" method accepts an object or an array of objects as it\'s second parameter.', 'invalidSettings': '{{elementType}}: "{{method}}" method accepts a string or an object as it\'s second parameter.' } }, type: 'object' }, 'name': { value: '', type: 'string' }, 'placeholder': { value: 'No Items', type: 'string' }, 'selectedIndexes': { value: [], type: 'array' }, 'selectedValues': { value: [], type: 'array' }, 'selectionMode': { value: 'oneOrManyExtended', allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'], type: 'string' }, 'selectionChangeAction': { value: 'release', allowedValues: ['press', 'release'], type: 'string' }, 'sorted': { value: false, type: 'boolean' }, 'sortDirection': { value: 'asc', type: 'string' }, 'topVisibleIndex': { value: -1, type: 'int' }, 'type': { value: 'list', type: 'string', defaultReflectToAttribute: true, readonly: true }, 'valueMember': { value: '', type: 'string' }, 'virtualized': { value: false, type: 'boolean' } } } /** * ListBox's requires */ static get requires() { return { 'LW.ScrollBar': 'lw.scrollbar.js' } } static get styleUrls() { return [ 'lw.listbox.css', 'lw.dropdown.css', 'lw.scrollbar.css' ] } /** * ListBox's event listeners. */ static get listeners() { return { 'focus': '_focusHandler', 'blur': '_blurHandler', 'container.wheel': '_mouseWheelHandler', 'editInput.change': '_editInputEventHandler', 'editInput.blur': '_editInputEventHandler', 'editInput.keydown': '_editInputEventHandler', 'horizontalScrollBar.change': '_horizontalScrollbarHandler', 'itemsInnerContainer.down': '_downHandler', 'itemsInnerContainer.dblclick': '_dblclickEventHandler', 'itemsInnerContainer.move': '_itemsContainerMoveHandler', 'itemsContainer.mouseleave': '_mouseLeaveHandler', 'itemsInnerContainer.touchmove': '_touchmoveHandler', 'itemsInnerContainer.touchstart': '_touchstartHandler', 'document.move': '_moveHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler', 'resize': '_resizeHandler', 'selectstart': '_selectStartHandler', 'styleChanged': '_styleChangedHandler', 'swipeleft': '_swipeLeftHandler', 'swiperight': '_swipeRightHandler', 'touchmove': '_overriddenHandler', 'touchstart': '_overriddenHandler', 'verticalScrollBar.change': '_verticalScrollbarHandler' }; } /* * ListBox's HTML template. */ template() { return `<div id="container" class="lw-container" role="presentation"> <div class="lw-list-box-filter-input-container lw-hidden" id="filterInputContainer" role="presentation"><input id="filterInput" disabled="[[disabled]]" placeholder='[[filterInputPlaceholder]]' role="searchbox" aria-label="[[filterInputPlaceholder]]"></div> <div id="itemsContainer" class="lw-list-items-container" role="presentation"> <div id="placeholder" class="lw-placeholder" role="presentation" aria-hidden="true">[[placeholder]]</div> <div id="itemsInnerContainer" inner-h-t-m-l=\'[[innerHTML]]\' class="lw-list-items-inner-container" role="presentation"> <content></content> </div> <input type="text" id="editInput" class= "lw-hidden"/> </div> <lw-scroll-bar wait right-to-left="[[rightToLeft]]" id="verticalScrollBar" disabled="[[disabled]]" orientation="vertical"></lw-scroll-bar> <lw-scroll-bar wait right-to-left="[[rightToLeft]]" id="horizontalScrollBar" disabled="[[disabled]]"></lw-scroll-bar> <div id="loadingIndicatorContainer" class="lw-loader-container" role="presentation"> <span id="loadingIndicator" class="lw-loader" role="img" aria-label="[[loadingIndicatorPlaceholder]]"></span> <span id="loadingIndicatorPlaceHolder" class="lw-loader-label lw-hidden">[[loadingIndicatorPlaceholder]]</span> </div> <input id="hiddenInput" type="hidden" name="[[name]]"> </div>`; } get value() { const that = this; if (that.isRendered && that._selectedItems.length > 0) { return that._selectedItems.map(item => { return { label: item.label, value: item.value }; }) } return null; } set value(newValue) { const that = this; if (Array.isArray(newValue)) { const context = that.context; that.context = that; that._isUpdating++; that.selectedValues = []; that.clearSelection(); for (let i = 0; i < newValue.length; i++) { const selectedValue = newValue[i]; const item = that.getItem(selectedValue); if (item) { if (that.selectionMode === 'oneOrManyExtended') { that._select(item); } else { that.select(item); } } } that.context = context; that._isUpdating--; return; } const item = that.getItem(newValue); if (item) { that.select(item); } } get _selectedItems() { const that = this; const items = []; if (that.isRendered) { for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; if (item.selected) { items.push(item); } } } return items; } _mouseLeaveHandler() { const that = this, itemsWithFeedback = [].slice.call(that.getElementsByClassName('lw-list-item-bottom-line-feedback')); //Remove Bottom Line feedbacks for (let i = 0; i < itemsWithFeedback.length; i++) { itemsWithFeedback[i].$.removeClass('lw-list-item-line-feedback'); itemsWithFeedback[i].$.removeClass('lw-list-item-bottom-line-feedback'); } } _downHandler(event) { const that = this; if (that.disabled || that.displayLoadingIndicator || that.readonly) { return; } let target = event.originalEvent.target; let item = null; if ((target instanceof LW.ListItem) && !target.disabled && !target.hidden && !(target instanceof LW.ListItemsGroup)) { item = target.dataItem; } else { while (target.parentElement) { if ((target instanceof LW.ListItem) && !target.disabled && !target.hidden && !(target instanceof LW.ListItemsGroup)) { item = target.dataItem; break; } target = target.parentElement; } } LW.ListBox.DragDrop.StartTime = new Date(); LW.ListBox.DragDrop.StartPosition = { left: event.pageX, top: event.pageY }; if (!item) { return; } event.stopPropagation(); if (that.hasRippleAnimation) { if (!item.readonly && !item.disabled) { LW.Utilities.Animation.Ripple.animate(target.$.overlay, event.pageX, event.pageY); } } if (!LW.Utilities.Core.isMobile && that.selectionChangeAction === 'press') { that._focus(item); that.select(item); } if (!LW.ListBox.DragDrop.Feedback && that.allowDrag) { LW.ListBox.DragDrop.DraggedFrom = that; LW.ListBox.DragDrop.Feedback = document.createElement('span'); if (that.rightToLeft) { LW.ListBox.DragDrop.Feedback.setAttribute('right-to-left', true); } else { LW.ListBox.DragDrop.Feedback.removeAttribute('right-to-left'); } if (that.dragFeedbackFormatFunction) { LW.ListBox.DragDrop.Feedback.innerHTML = that.dragFeedbackFormatFunction(item); } else { LW.ListBox.DragDrop.Feedback.appendChild(item.offsetHeight ? item.cloneNode(true) : that._createItem(item)); } LW.ListBox.DragDrop.Item = item; LW.Utilities.Extend(LW.ListBox.DragDrop.Feedback).addClass('lw-popup lw-list-item lw-list-item-feedback'); } } /** * Double click on itemsContainer event handler * @param {any} event */ _dblclickEventHandler(event) { const that = this; if (!that.editable) { return; } const target = event.target.closest('lw-list-item'); if (!(target instanceof LW.ListItem) || target.disabled || target.readonly) { that.$editInput.addClass('lw-hidden'); return; } that.$.editInput.dir = that.rightToLeft ? 'rtl' : 'ltr'; that.$.editInput.style.width = that.$.itemsInnerContainer.offsetWidth + 'px'; that.$.editInput.owner = target; that.$.editInput.value = target.label; that.$.editInput.style.height = target.offsetHeight + 'px'; that.$.editInput.style.top = (target.offsetTop + that.$.itemsInnerContainer.offsetTop) + 'px'; that.$.editInput.setAttribute('aria-label', 'Edit item ' + target.label); if (that.$editInput.hasClass('lw-hidden')) { that.$editInput.removeClass('lw-hidden'); } that.$.editInput.focus({ preventScroll: true }); } /** * List Item edit input change and blur event handler * @param {any} event */ _editInputEventHandler(event) { const that = this; if (event.type === 'blur' || (event.type === 'keydown' && event.key === 'Escape')) { !that.$editInput.hasClass('lw-hidden') ? that.$editInput.addClass('lw-hidden') : undefined; that.focus(); return; } if (event.type === 'keydown' || that.$editInput.hasClass('lw-hidden')) { return; } const target = event.target; event.stopPropagation(); //stop input's original change event if (target.owner.label !== target.value) { target.owner.label = target.value; if (that.itemTemplate) { that._applyTemplate(target.owner) } if (that.dataSource) { const index = target.owner.dataIndex; const dataItem = that.dataSource[index]; if (dataItem) { if (that.displayMember) { dataItem[that.displayMember] = target.value; } else { dataItem.label = target.value; } } } } that.$editInput.addClass('lw-hidden'); that.$.fireEvent('itemLabelChange', { 'selected': target.owner.selected, 'disabled': target.owner.disabled, 'index': that._indexOf(target.owner), 'label': target.owner.label, 'value': target.owner.value }); } _pointerUpHandler(customEvent) { const that = this; let event = customEvent.originalEvent; let target = event.target; if (that.shadowRoot || that.isInShadowDOM) { target = event.originalEvent ? event.originalEvent.composedPath()[0] : event.composedPath()[0]; } const select = (item) => { const listBox = item.ownerListBox; if (listBox.disabled || listBox !== that || listBox.displayLoadingIndicator || listBox.selectionMode === 'none' || item.grouped || item.readonly) { return; } listBox._focus(item); listBox.select(item); LW.ListBox.DragDrop.StartPosition = null; that.$.fireEvent('itemClick', { 'selected': target.selected, 'disabled': target.disabled, 'index': that._indexOf(target), 'label': target.label, 'value': target.value }); } if ((event.target instanceof LW.ListItem) && !event.target.disabled && !(event.target instanceof LW.ListItemsGroup)) { select(target.dataItem); return; } while (target.parentElement) { if ((target instanceof LW.ListItem) && !target.disabled && !(target instanceof LW.ListItemsGroup)) { select(target.dataItem); return; } target = target.parentElement; } if (this.shadowRoot && this.shadowDomMode === 'shadow') { const composedPath = event.composedPath(); for (let i = 0; i < composedPath.length; i++) { const htmlElement = composedPath[i]; if (htmlElement instanceof LW.ListItem && !htmlElement.disabled) { select(htmlElement.dataItem); } } } } _upHandler(event) { const that = this; super._upHandler(); if (that.disabled || that.readonly || !LW.ListBox.DragDrop.StartPosition) { return; } if (LW.Utilities.Core.isMobile && !LW.ListBox.DragDrop.Dragging) { const left = Math.abs(event.pageX - LW.ListBox.DragDrop.StartPosition.left); const top = Math.abs(event.pageY - LW.ListBox.DragDrop.StartPosition.top); let canSelect = (left >= 0 && left <= 3) && (top >= 0 && top <= 3); if (LW.Utilities.Core.isMobile) { if (new Date() - LW.ListBox.DragDrop.StartTime >= 300) { canSelect = false; LW.ListBox.DragDrop.StartTime = null; } } if (canSelect) { const closestListBox = event.originalEvent.target.closest('lw-list-box'); closestListBox ? closestListBox._pointerUpHandler(event) : that._pointerUpHandler(event); LW.ListBox.DragDrop.StartPosition = null; } else { let target = event.originalEvent.target; if ((event.target instanceof LW.ListItem) && !target.readonly && !event.target.disabled && !(event.target instanceof LW.ListItemsGroup)) { event.stopPropagation(); } else { while (target.parentElement) { if ((target instanceof LW.ListItem) && !target.readonly && !target.disabled && !(target instanceof LW.ListItemsGroup)) { event.stopPropagation(); break; } target = target.parentElement; } } } } else if (!LW.Utilities.Core.isMobile && !LW.ListBox.DragDrop.Dragging && that.selectionChangeAction === 'release') { const closestListBox = (that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target).closest('lw-list-box'); closestListBox ? closestListBox._pointerUpHandler(event) : that._pointerUpHandler(event); } if (LW.ListBox.DragDrop.Feedback) { if (LW.ListBox.DragDrop.Feedback.parentNode) { LW.ListBox.DragDrop.Feedback.parentNode.removeChild(LW.ListBox.DragDrop.Feedback); } LW.ListBox.DragDrop.Feedback = null; let dropTarget; if (LW.Utilities.Core.isMobile && LW.ListBox.DragDrop.Dragging) { for (let j = 0; j < LW.ListBox.DragDrop.ListBoxes.length; j++) { const listBox = LW.ListBox.DragDrop.ListBoxes[j]; const rect = listBox.getBoundingClientRect(); if (!listBox.allowDrop || listBox.closest('.lw-visibility-hidden')) { continue; } if (rect.left <= event.clientX && event.clientX <= rect.left + rect.width && rect.top <= event.clientY && event.clientY <= rect.top + rect.height) { dropTarget = listBox; const visibleItems = listBox._items.filter(item => !item.hidden); for (let i = 0; i < visibleItems.length; i++) { const item = visibleItems[i]; const itemRect = item.getBoundingClientRect(); if (visibleItems.indexOf(item) === visibleItems.length - 1 || item.parentNode.lastElementChild === item) { if (event.clientY >= rect.top + item.offsetTop - listBox.scrollTop + (itemRect.height / 2) && event.clientY <= rect.top - listBox.scrollTop + item.offsetTop + itemRect.height) { LW.ListBox.DragDrop.DropDetails = { item: item, position: 'bottom' }; break; } } if (event.clientY >= rect.top + item.offsetTop - listBox.scrollTop && event.clientY <= rect.top + item.offsetTop + itemRect.height - listBox.scrollTop) { LW.ListBox.DragDrop.DropDetails = { item: item, position: 'top' }; break; } } } } } if (LW.ListBox.DragDrop.Dragging) { if (LW.ListBox.DragDrop.DropDetails) { let dropItem = LW.ListBox.DragDrop.DropDetails.item, dragItem = LW.ListBox.DragDrop.Item; const dragItemListBox = dragItem.ownerListBox; let target = event.originalEvent.target; if (that.isInShadowDOM) { target = event.originalEvent ? event.originalEvent.composedPath()[0] : event.composedPath()[0]; } dropTarget = !dropTarget && target.closest ? target.closest('lw-list-box') : dropTarget; document.body.classList.remove('lw-dragging'); dropItem.$.removeClass('lw-list-item-line-feedback'); dropItem.$.removeClass('lw-list-item-bottom-line-feedback'); if (dropTarget && dropItem.ownerListBox !== dropTarget && dropTarget.items.length > 0) { dropItem = dropTarget.items[dropTarget.items.length - 1]; } if (LW.ListBox.DragDrop.Item !== dropItem && (dropTarget === dropItem.ownerListBox || LW.Utilities.Core.isMobile)) { if (dragItem.ownerListBox.dropAction !== 'none') { if (dropItem.ownerListBox !== dragItem.ownerListBox && dragItem.ownerListBox.dropAction === 'move') { LW.ListBox.DragDrop.Item.ownerListBox.removeChild(LW.ListBox.DragDrop.Item); } if (dragItem.ownerListBox.dropAction === 'copy') { dragItem = dragItem.cloneNode(true); } LW.ListBox.DragDrop.Item.group = dropItem.group; const listBox = dropItem.ownerListBox; if (listBox.selectionMode !== 'checkBox' && listBox.selectionMode !== 'radioButton') { listBox.clearSelection(); } if (LW.ListBox.DragDrop.DropDetails.position === 'top') { listBox.insertBefore(dragItem, dropItem); } else { if (dropItem.parentNode.lastElementChild === dropItem) { listBox.appendChild(dragItem); } else { listBox.appendChild(dragItem, dropItem); } } listBox.ensureVisible(dragItem); if (listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton') { listBox._focus(dragItem); listBox._refreshSelection(); } else { listBox.clearSelection(); listBox.select(dragItem); } } } else if (dropTarget && dropTarget._items.length === 0 && dropTarget.dropAction !== 'none') { if (dropTarget.dropAction === 'move') { LW.ListBox.DragDrop.Item.ownerListBox.removeChild(LW.ListBox.DragDrop.Item); } else if (dropTarget.dropAction === 'copy') { dragItem = dragItem.cloneNode(true); } dropTarget.appendChild(dragItem); } if (dragItem.selected && dropTarget !== dragItemListBox) { dragItemListBox._refreshSelection(); } const item = LW.ListBox.DragDrop.Item; const listBox = item.ownerListBox; item.displayMode = listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton' ? listBox.selectionMode : 'plain'; listBox.$.fireEvent('dragEnd', { 'item': item, 'target': dropItem, 'data': LW.ListBox.DragDrop, 'previousContainer': dragItemListBox, 'container': dropTarget, 'originalEvent': event }); listBox._focus(item); } else { const item = LW.ListBox.DragDrop.Item; const listBox = item.ownerListBox; item.displayMode = listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton' ? listBox.selectionMode : 'plain'; document.body.classList.remove('lw-dragging'); listBox.$.fireEvent('dragEnd', { 'item': item, 'target': null, 'data': LW.ListBox.DragDrop, 'previousContainer': listBox, 'container': listBox, 'originalEvent': event }); listBox._focus(item); } event.preventDefault(); } delete LW.ListBox.DragDrop.DraggedFrom; LW.ListBox.DragDrop.Dragging = false; LW.ListBox.DragDrop.Item = null; LW.ListBox.DragDrop.DropDetails = null; } for (let i = 0; i < LW.ListBox.DragDrop.ListBoxes.length; i++) { const listBox = LW.ListBox.DragDrop.ListBoxes[i]; if (listBox._dragInterval) { clearInterval(listBox._dragInterval); } } } _itemsContainerMoveHandler(event) { const that = this; if (LW.ListBox.DragDrop.Dragging) { that._applyItemFeedback(event); that._moveHandler(event); event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); return false; } } /** * touchmove handler. */ _touchmoveHandler(event) { if (LW.ListBox.DragDrop.Dragging && event.cancelable) { event.preventDefault(); event.stopPropagation(); return; } super._touchmoveHandler(event); } _applyItemFeedback(event) { const that = this, target = event.originalEvent.target, targetItem = target.closest ? target.closest('lw-list-item') : target; //Event.target doesn't work on Mobile. This is used just to the Drop logic inside upHandler if (LW.Utilities.Core.isMobile) { LW.ListBox.DragDrop.DropDetails = { item: LW.ListBox.DragDrop.Item, position: 'bottom' }; return; } if (that.items.length === 0) { return; } if (!targetItem) { that.items[that.items.length - 1]._itemOnMouseMove(event, true); return; } targetItem._itemOnMouseMove(event); } _moveHandler(event) { const that = this; if (!LW.ListBox.DragDrop.Feedback || LW.ListBox.DragDrop.DraggedFrom !== that) { return; } const dragOffset = that.dragOffset; if (!LW.ListBox.DragDrop.Dragging) { const left = Math.abs(event.pageX - LW.ListBox.DragDrop.StartPosition.left); const top = Math.abs(event.pageY - LW.ListBox.DragDrop.StartPosition.top); const timeOut = new Date() - LW.ListBox.DragDrop.StartTime; let canStartDrag = (left >= 5 && left <= 15) || (top >= 5 && top <= 15); if (LW.Utilities.Core.isMobile) { if (timeOut < 300 || timeOut > 1000) { canStartDrag = false; } } if (canStartDrag) { LW.ListBox.DragDrop.Dragging = true; LW.ListBox.DragDrop.Feedback.style.left = dragOffset[0] + event.pageX + 'px'; LW.ListBox.DragDrop.Feedback.style.top = dragOffset[1] + event.pageY + 'px'; that.getShadowRootOrBody().appendChild(LW.ListBox.DragDrop.Feedback); event.preventDefault(); event.stopPropagation(); event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); const item = LW.ListBox.DragDrop.Item; const listBox = item.ownerListBox; listBox.$.fireEvent('dragStart', { 'item': item, 'data': LW.ListBox.DragDrop, 'container': listBox, 'previousContainer': listBox, 'originalEvent': event.originalEvent }); document.body.classList.add('lw-dragging'); } } else { LW.ListBox.DragDrop.Feedback.style.left = dragOffset[0] + event.pageX + 'px'; LW.ListBox.DragDrop.Feedback.style.top = dragOffset[1] + event.pageY + 'px'; that.$.fireEvent('dragging', { 'item': LW.ListBox.DragDrop.Item, 'data': LW.ListBox.DragDrop, 'originalEvent': event.originalEvent }); for (let i = 0; i < LW.ListBox.DragDrop.ListBoxes.length; i++) { const listBox = LW.ListBox.DragDrop.ListBoxes[i]; if (listBox._dragInterval) { clearInterval(listBox._dragInterval); } listBox._dragInterval = setInterval(function () { const rect = listBox.getBoundingClientRect(); if (rect.left <= event.clientX && rect.left + rect.width >= event.clientX) { if (event.clientY >= rect.top && event.clientY <= rect.top + 20) { listBox.scrollTop -= 2; } else if (event.clientY >= rect.top + rect.height - 20 && event.clientY <= rect.top + rect.height) { listBox.scrollTop += 2; } } }, 1); } event.preventDefault(); event.stopPropagation(); event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); return false; } } _focusHandler() { const that = this; that._focused = true; that.setAttribute('focus', ''); } _blurHandler() { const that = this; that._focused = false; that.removeAttribute('focus'); } appendChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (that.isVirtualized) { if (that._items.indexOf(node) > -1) { that._items.splice(that._items.indexOf(node), 1); } that._items.push(node); } else { node.dataItem = node; if (that.shadowRoot && that.shadowDomMode === 'light') { that.appendChild(node); } else { that.$.itemsInnerContainer.appendChild(node); } if (that._items.indexOf(node) > -1) { that._items.splice(that._items.indexOf(node), 1); } that._items.push(node); } that._refreshItems(); that._refreshSelection(); } insertBefore(newNode, referenceNode) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (that.isVirtualized) { if (that._items.indexOf(newNode) > -1) { that._items.splice(that._items.indexOf(newNode), 1); } that._items.splice(that._indexOf(referenceNode), 0, newNode); } else { newNode.dataItem = newNode; referenceNode.parentNode.insertBefore(newNode, referenceNode); if (that._items.indexOf(newNode) > -1) { that._items.splice(that._items.indexOf(newNode), 1); } that._items.splice(that._indexOf(referenceNode), 0, newNode); } that._refreshItems(); that._refreshSelection(); } removeChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (that.isVirtualized) { that._items.splice(that._indexOf(node), 1); } else { if (node.parentNode) { const selectedIndexes = that.selectedIndexes.slice(0), selectedValues = that.selectedValues.slice(0), selectedItemIndex = selectedIndexes.indexOf(node.dataIndex); node.parentNode.removeChild(node); if (selectedItemIndex > -1) { selectedIndexes.splice(selectedItemIndex, 1); selectedValues.splice(selectedItemIndex, 1); that.selectedIndexes = selectedIndexes; that.selectedValues = selectedValues; } } } that._refreshItems(); } /** * Updates the listbox when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'innerHTML': that.clearSelection(); that._dataBind(); that.innerHTML = that.content = LW.Utilities.Core.html(that.$.content); break; case 'dataSource': case 'valueMember': case 'groupMember': case 'displayMember': { that.clearSelection(); that._dataBind(); break; } case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'displayLoadingIndicator': { that._setLoadingIndicatorVisibility(); break; } case 'filterable': { that._refreshFilter(); that._refreshLayout(); break; } case 'grouped': { if (newValue) { that._group(); } else { that._ungroup(); } if (that.selectionMode === 'radioButton') { if (that.selectedValues.length > 0) { const selectedValues = that.selectedValues; that.clearSelection(); that.select(selectedValues[0]); } } else { that._refreshSelection(); } that._refreshLayout(); break; } case 'itemTemplate': { if (newValue === null || newValue === '') { that._items.map((item) => item.innerHTML = item.label); delete that._bindingDetails; that._refreshLayout(); return; } const items = that.querySelectorAll('lw-list-item'); const itemsReady = function () { if (that._handleItemTemplate(newValue)) { that._items.map((item) => that._applyTemplate(item)); that._refreshLayout(); } if (that.ownerElement && that.ownerElement._setDropDownSize) { that.ownerElement._setDropDownSize(); } that.$.fireEvent('bindingComplete'); } if (items.length === 0) { itemsReady(); } else { that._ensureItemsReady(items, itemsReady); } break; } case 'selectedIndexes': case 'selectedValues': { let _selectedIndexes = that.selectedIndexes.slice(0); let _selectedValues = that.selectedValues.slice(0); if (!that._items || that._items.length === 0) { that.selectedIndexes = []; that.selectedValues = []; //Update the hidden form input that.$.hiddenInput.value = that.selectedValues.toString(); return; } that._propertyChanging = true; if (propertyName === 'selectedIndexes') { _selectedIndexes = oldValue.slice(0); that.clearSelection(); for (let i = 0; i < newValue.length; i++) { const index = newValue[i]; const item = that._items[index]; if (item) { if (that.selectionMode === 'oneOrManyExtended' || that.selectionMode === 'oneOrMany') { if (that.selectedIndexes.length > 0 && i === 0) { that.clearSelection(); } that._select(item); } else { that.select(item); } } } } else { _selectedValues = oldValue.slice(0); that.selectedValues = []; that.clearSelection(); for (let i = 0; i < newValue.length; i++) { const selectedValue = newValue[i]; const item = that.getItem(selectedValue); if (item) { if (that.selectionMode === 'oneOrManyExtended') { that._select(item); } else { that.select(item); } } } } if (that.selectedIndexes.length > 0) { that._focus(that._items[that.selectedIndexes[0]]); } that._propertyChanging = false; if (JSON.stringify(_selectedValues) !== JSON.stringify(that.selectedValues.slice(0))) { let selectedItems = [], unselectedItems = []; // get all newly unselected items for (let i = 0; i < _selectedIndexes.length; i++) { if (that.selectedIndexes.indexOf(_selectedIndexes[i]) < 0) { unselectedItems.push(that._items[_selectedIndexes[i]]); } } // get all newly selected items for (let i = 0; i < that.selectedIndexes.length; i++) { if (_selectedIndexes.indexOf(that.selectedIndexes[i]) < 0) { selectedItems.push(that._items[that.selectedIndexes[i]]); } } let eventDetails = { 'addedItems': selectedItems, 'removedItems': unselectedItems }; if (that.selectedIndexes.length > 0) { const lastSelectedItem = that._items[that.selectedIndexes[that.selectedIndexes.length - 1]]; if (lastSelectedItem !== undefined) { eventDetails.selected = lastSelectedItem.selected; eventDetails.disabled = lastSelectedItem.disabled; eventDetails.index = that._indexOf(lastSelectedItem); eventDetails.label = lastSelectedItem.label; eventDetails.value = lastSelectedItem.value; } } else { eventDetails.selected = false; eventDetails.disabled = false; eventDetails.index = -1; eventDetails.label = ''; eventDetails.value = ''; } that.$.fireEvent('change', eventDetails); } break; } case 'selectionMode': { const displayMode = that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' ? that.selectionMode : 'plain'; const _selectedIndexes = that.selectedIndexes.slice(0); const _selectedValues = that.selectedValues.slice(0); that._propertyChanging = true; const selectedValues = that.selectedValues; that.setAttribute('aria-multiselectable', ['oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'checkBox', 'radioButton'].indexOf(newValue) !== -1); that.selectedValues = []; that.clearSelection(); for (let i = 0; i < selectedValues.length; i++) { const selectedValue = selectedValues[i]; const item = that.getItem(selectedValue); if (item) { if (that.selectionMode === 'oneOrManyExtended') { that._select(item); } else { that.select(item); } } } that._items.forEach(item => item.displayMode = displayMode); that._recycle(); that._propertyChanging = false; if (JSON.stringify(_selectedValues) !== JSON.stringify(that.selectedValues.slice(0))) { let selectedItems = [], unselectedItems = []; // get all newly unselected items for (let i = 0; i < _selectedIndexes.length; i++) { if (that.selectedIndexes.indexOf(_selectedIndexes[i]) < 0) { unselectedItems.push(that._items[_selectedIndexes[i]]); } } // get all newly selected items for (let i = 0; i < that.selectedIndexes.length; i++) { if (_selectedIndexes.indexOf(that.selectedIndexes[i]) < 0) { selectedItems.push(that._items[that.selectedIndexes[i]]); } } let eventDetails = { 'addedItems': selectedItems, 'removedItems': unselectedItems }; if (_selectedIndexes.length > 0) { const lastSelectedIndex = that._items[_selectedIndexes[_selectedIndexes.length - 1]]; if (lastSelectedIndex) { eventDetails.selected = lastSelectedIndex.selected; eventDetails.disabled = lastSelectedIndex.disabled; eventDetails.index = that._indexOf(lastSelectedIndex); eventDetails.label = lastSelectedIndex.label; eventDetails.value = lastSelectedIndex.value; } } that.$.fireEvent('change', eventDetails); } that._applyAriaSelected(); if (newValue === 'checkBox' || newValue === 'radioButton' || oldValue === 'checkBox' || oldValue === 'radioButton') { that._refreshLayout(); } break; } case 'topVisibleIndex': that._setTopVisibleIndex(newValue); break; case 'autoSort': that._canSort = newValue; break; case 'sortDirection': case 'sorted': { that._canSort = true; if (newValue) { that._sort(); } else { that._unsort(); } const selectedValues = that.selectedValues; that.selectedValues = []; that._refreshSelection(); for (let i = 0; i < selectedValues.length; i++) { const selectedValue = selectedValues[i]; const item = that.getItem(selectedValue); if (item) { if (that.selectionMode === 'oneOrManyExtended') { that._select(item); } else { that.select(item); } } } that._refreshLayout(); that._canSort = that.autoSort; break; } } } /** * refreshes selection items. */ _refreshSelection() { const that = this; if (!that._items || that._items.length === 0) { return; } const selectedValues = that.selectedValues; that.selectedIndexes = []; that.selectedValues = []; for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; item.selected = false; if (selectedValues.indexOf(item.value) > -1) { that.select(item); } } that._recycle(); } /** * Unselects all items. */ clearSelection() { const that = this; if (!that._items || that._items.length === 0) { return; } let removedItems = []; for (let i = 0; i < that._items.length; i++) { if (that._items[i].selected) { removedItems.push(that._items[i]); } } that._items.map(item => item.selected = false); const _selectedValues = that.selectedValues.slice(0); const _selectedIndexes = that.selectedIndexes.slice(0); that.selectedIndexes = []; that.selectedValues = []; //Update the hidden form input that.$.hiddenInput.value = that.selectedValues.toString(); that._recycle(); if (that.context !== that) { let eventDetails = { 'addedItems': [], 'removedItems': removedItems }; if (_selectedIndexes.length > 0) { const lastSelectedIndex = that._items[_selectedIndexes[_selectedIndexes.length - 1]]; if (lastSelectedIndex) { eventDetails.selected = lastSelectedIndex.selected; eventDetails.disabled = lastSelectedIndex.disabled; eventDetails.index = that._indexOf(lastSelectedIndex); eventDetails.label = lastSelectedIndex.label; eventDetails.value = lastSelectedIndex.value; } } that.$.fireEvent('change', eventDetails); } } ensureVisible(item) { const that = this; if (!item) { return; } if (typeof item === 'string') { item = that.getItem(item); if (!item) { return false; } } if (!that.isVirtualized && that.$.itemsContainer.scrollTop !== that.scrollTop) { that.scrollTop = that.$.itemsContainer.scrollTop; } if (item.top + item.height >= that.scrollTop + that.offsetHeight) { that.scrollTop = that.scrollTop + item.height; if (!that.isVirtualized) { that.$.itemsContainer.scrollTop = that.scrollTop; } } if (item.top <= that.scrollTop || item.top >= that.scrollTop + that.$.itemsContainer.offsetHeight) { that.scrollTop = item.top; if (!that.isVirtualized) { that.$.itemsContainer.scrollTop = that.scrollTop; } } if (that._indexOf(item) === 0 || (that._indexOf(item) === 1 && that._items.length > 1 && that._items[0].grouped)) { that.scrollTop = 0; if (!that.isVirtualized) { that.$.itemsContainer.scrollTop = that.scrollTop; } } else if (that._indexOf(item) === that._items.length - 1) { that.scrollTop = that.scrollHeight; if (!that.isVirtualized) { that.$.itemsContainer.scrollTop = that.scrollTop; } } return true; } /** * Returns an array with the items from the list. */ get items() { const that = this; if (that._filteredItems) { return that._filteredItems; } return that._items; } /** * ListBox ready method. */ ready() { super.ready(); const that = this; //LightDom test if (that.shadowRoot && that.shadowDomMode === 'light') { const fragment = document.createDocumentFragment(); [].slice.call(that.$.itemsInnerContainer.children).map(item => fragment.appendChild(item)); that.appendChild(fragment); that.$.itemsInnerContainer.appendChild(document.createElement('slot')); } that._areCSSVarsSupported = LW.Utilities.Core.CSSVariablesSupport(); that.isUpdating = 0; if (that._scrollView) { that._scrollView = new LW.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar); that._scrollView.hScrollBar.$.addClass('lw-hidden'); that._scrollView.vScrollBar.$.addClass('lw-hidden'); } const vScrollBar = that._scrollView.vScrollBar; const hScrollBar = that._scrollView.hScrollBar; vScrollBar.hasStyleObserver = false; hScrollBar.hasStyleObserver = false; vScrollBar.hasResizeObserver = false; hScrollBar.hasResizeObserver = false; vScrollBar.wait = false; hScrollBar.wait = false; that._setFocusable(); } render() { const that = this; that.setAttribute('role', 'listbox'); that.setAttribute('aria-orientation', 'vertical'); that.$.verticalScrollBar.setAttribute('aria-controls', that.id); that.$.horizontalScrollBar.setAttribute('aria-controls', that.id); that._keysPressed = {}; that._incrementalSearchQuery = ''; that._incrementalSearchItems = []; that._canSort = true; that._previousEntry = ''; that._setLoadingIndicatorVisibility(); that._refreshFilter(); that._initializeInnerHTML(); that._dataBind(); if (that.enableShadowDOM) { HTMLElement.prototype.appendChild.apply(that, [that.$.hiddenInput]); } that.setAttribute('aria-multiselectable', ['oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'checkBox', 'radioButton'].indexOf(that.selectionMode) !== -1); super.render(); } attached() { const that = this; super.attached(); if (!LW.ListBox.DragDrop) { LW.ListBox.DragDrop = { ListBoxes: [] }; } LW.ListBox.DragDrop.ListBoxes.push(that); if (!that._scrollView) { that._scrollView = new LW.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar); } if (that.selectedIndexes.length > 0 && that._items) { that.ensureVisible(that._items[that.selectedIndexes[0]]); } } detached() { const that = this; super.detached(); if (that._scrollView) { that._scrollView.unlisten(); delete that._scrollView; } if (LW.ListBox.DragDrop && LW.ListBox.DragDrop.ListBoxes) { const index = LW.ListBox.DragDrop.ListBoxes.indexOf(that); LW.ListBox.DragDrop.ListBoxes.splice(index, 1); } } _createItem(item, index, recycling) { const that = this; const displayMode = that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' ? that.selectionMode : 'plain'; const htmlItem = recycling ? {} : document.createElement('lw-list-item'); htmlItem.ownerListBox = that; if (typeof item === 'number') { item = '' + item; } const getMemberValue = function (memberName, defaultMemberName) { if (item[memberName] !== undefined) { return '' + item[memberName]; } return item[defaultMemberName]; } let label = typeof item === 'string' ? item : getMemberValue(that.displayMember, 'label'), value = typeof item === 'string' ? item : getMemberValue(that.valueMember, 'value'), group = getMemberValue(that.groupMember, 'group') if (undefined === label) { if (index !== undefined) { label = '' + index; } else { label = ''; } } htmlItem.label = htmlItem.innerHTML = '' + label; if (undefined === value) { if (index !== undefined) { value = '' + index; } else { value = label; } } if (item.color) { htmlItem.color = item.color; } htmlItem.value = '' + value; htmlItem.displayMode = displayMode; htmlItem.selected = item.selected ? item.selected : false; htmlItem.disabled = item.disabled ? item.disabled : false; htmlItem.dataItem = htmlItem; if (index !== undefined) { htmlItem.dataIndex = index; } that._alternateItem(htmlItem); if (item.title) { htmlItem.title = item.title; } if (group) { htmlItem.group = '' + group; } return htmlItem; } _alternateItem(item) { const that = this; const start = that.alternationStart; const end = that.alternationEnd > 0 ? that.alternationEnd : Infinity; if (that.alternationCount <= 0) { return; } if (that._alternationIndexCounter === undefined) { that._alternationIndexCounter = 0; } if (item.dataIndex >= start && item.dataIndex <= end) { item.alternationIndex = that._alternationIndexCounter++; if (that._alternationIndexCounter === that.alternationCount) { that._alternationIndexCounter = 0; } } } _beginUpdate() { const that = this; that.isUpdating++; } _isUpdating() { const that = this; return that.isUpdating > 0; } _endUpdate() { const that = this; that.isUpdating--; } get _scrollHeight() { const that = this; if (that._items.length === 0 || that._items.filter(i => !i.hidden).length < 2) { return 0; } let scrollHeight = 0; if (that.isVirtualized) { if (that.__scrollHeight) { return that.__scrollHeight; } if (that._items.length === 0) { return 0; } that.isUpdating++; const measureItem = that._createItem(that.dataSource[0]); that.$.itemsInnerContainer.appendChild(measureItem); for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; if (item.hidden) { item.height = 0; item.top = scrollHeight; continue; } if (!that.itemHeight) { measureItem.label = item.label; item.height = measureItem.offsetHeight; } else { if (that.itemHeight < 32) { that.itemHeight = 32; } item.height = that.itemHeight; } item.top = scrollHeight; scrollHeight += item.height; } that.$.itemsInnerContainer.removeChild(measureItem) that.__scrollHeight = scrollHeight - that.$.itemsInnerContainer.offsetHeight; if (that.filterable) { that.__scrollHeight += that.$.filterInput.offsetHeight; } scrollHeight = that.__scrollHeight; that.isUpdating--; } else { for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; if (item.hidden) { item.height = 0; item.top = scrollHeight; continue; } if (!that.itemHeight) { item.height = item.offsetHeight; } else if (that.itemHeight !== 'auto') { item.height = that.itemHeight; item.style.height = item.height + 'px'; } item.top = item.offsetTop; scrollHeight += item.height; } scrollHeight = that.$.itemsInnerContainer.scrollHeight - that.$.itemsInnerContainer.offsetHeight; if (that.filterable && scrollHeight > 0) { scrollHeight += that.$.filterInput.offsetHeight; } that.__scrollHeight = scrollHeight; } return scrollHeight; //Note: Incorrectly decreases the scrollHeight //let bottomOffset = 0; //if (scrollHeight) { // bottomOffset = 2 * (parseInt(getComputedStyle(that.$.itemsInnerContainer).getPropertyValue('--lw-list-item-vertical-offset')) || 0); //} //return scrollHeight - bottomOffset; } _initializeRecyclingItems() { const that = this; if ((!that.dataSource || (that.dataSource && that.dataSource.length === 0)) || !that.isVirtualized) { return; } let itemsHeight = 0; let listBoxHeight = that.offsetHeight; that.$.itemsInnerContainer.innerHTML = ''; that._recyclingItems = []; const createRecyclingItems = function () { for (let i = 0; i < that.dataSource.length; i++) { const item = that.dataSource[i]; const htmlItem = that._createItem(item); if (that.itemHeight && that.itemHeight !== 'auto') { htmlItem.style.height = that.itemHeight + 'px'; } that.$.itemsInnerContainer.appendChild(htmlItem); itemsHeight += htmlItem.offsetHeight; htmlItem.dataItem = that._items[i]; that._recyclingItems.push(htmlItem); if (itemsHeight > 1.5 * listBoxHeight) { break; } } } createRecyclingItems(); let maxIterations = 0; while (itemsHeight < 1.5 * listBoxHeight && ++maxIterations < 5) { createRecyclingItems(); } } _dataBind() { const that = this; if (!that._scrollView) { that._scrollView = new LW.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar); } if (typeof that.dataSource === 'function') { that._items = []; } if (typeof that.dataSource === 'string') { that.dataSource = JSON.parse(that.dataSource); } if (that.dataSource !== null && Array.isArray(that.dataSource)) { that.isUpdating++; const initializeDataBoundItems = (fragment) => { that._items = []; that._groups = []; const dataSource = that.dataSource; for (let i = 0; i < dataSource.length; i++) { const item = dataSource[i], htmlItem = that._createItem(item, i, !fragment); that._items[i] = htmlItem; if (fragment) { fragment.appendChild(htmlItem); } } } if (that.isVirtualized) { initializeDataBoundItems(); that._initializeRecyclingItems(); } else { const fragment = document.createDocumentFragment(); that.$.itemsInnerContainer.innerHTML = ''; initializeDataBoundItems(fragment); that.$.itemsInnerContainer.appendChild(fragment); } that.isUpdating--; } const items = that.shadowRoot ? that.shadowRoot.querySelectorAll('lw-list-item') : that.querySelectorAll('lw-list-item'); const itemsReady = function () { that.isUpdating++; if (!that.dataSource) { that._initializeHtmlListItems(); that._initializeHtmlListGroups(); } if (that.grouped) { that._group(); } if (that.sorted) { that._sort(); } that._refreshLayout(); that._initializeSelection(); that.isInitialized = true; that._canSort = that.autoSort; that.isUpdating--; if (that.itemTemplate) { if (that._handleItemTemplate(that.itemTemplate)) { that._items.map((item) => that._applyTemplate(item)); that._refreshLayout(); } } if (that.__onCompleted) { that._onCompleted = that.__onCompleted; that.__onCompleted = null; that._onCompleted(); } if (that.topVisibleIndex > -1) { that._setTopVisibleIndex(that.topVisibleIndex); } that.$.fireEvent('bindingComplete'); that._updateTopVisibleIndex(); if (that._items.length === 0) { that.clearItems(); } that._applyAriaSelected(); } if (items.length === 0) { itemsReady(); } else { if (that._onCompleted) { that.__onCompleted = that._onCompleted; that._onCompleted = null; } that._ensureItemsReady(items, itemsReady); } } _ensureItemsReady(nodes, callback) { const that = this; const contextCallback = function () { const setContext = function (context) { for (let i = 0; i < nodes.length; i++) { nodes[i].context = context === 'node' ? nodes[i] : document; } } setContext('node'); callback(); setContext(); } if (nodes.length === 0) { contextCallback(); } else { that._nodesReadyListeners = 0; for (let i = 0; i < nodes.length; i++) { const node = nodes[i]; const readyEventHandler = function () { that._nodesReadyListeners--; if (that._nodesReadyListeners === 0) { contextCallback(); delete that._nodesReadyListeners; } }.bind(that); if (!node.isCompleted) { that._nodesReadyListeners++; node._onCompleted = readyEventHandler; } } if (that._nodesReadyListeners === 0) { contextCallback(); } } } _initializeInnerHTML() { const that = this; if (that.$.itemsInnerContainer.innerHTML.indexOf('<option') >= 0) { that.$.itemsInnerContainer.innerHTML = that.$.itemsInnerContainer.innerHTML.replace(/<optgroup/ig, '<lw-list-items-group').replace(/<\/optgroup/ig, '<\/lw-list-items-group').replace(/<option/ig, '<lw-list-item').replace(/<\/option/ig, '<\/lw-list-item'); } else if (that.$.itemsInnerContainer.innerHTML.indexOf('<ul') >= 0) { that.$.itemsInnerContainer.innerHTML = that.$.itemsInnerContainer.innerHTML.replace(/<ul/ig, '<lw-list-items-group').replace(/<\/ul/ig, '<\/lw-list-items-group').replace(/<li/ig, '<lw-list-item').replace(/<\/li/ig, '<\/lw-list-item'); } } _initializeHtmlListItems() { const that = this; const htmlItems = that.shadowRoot && that.shadowDomMode === 'shadow' ? that.shadowRoot.querySelectorAll('lw-list-item') : that.querySelectorAll('lw-list-item'); const displayMode = that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' ? that.selectionMode : 'plain'; const getMemberValue = function (item, memberName, defaultMemberName) { if (item[memberName] !== undefined) { return '' + item[memberName]; } return item[defaultMemberName]; } that._items = []; let top = 0; for (let i = 0; i < htmlItems.length; i++) { const item = htmlItems[i]; item.dataIndex = i; item.label = item.innerHTML; item.dataItem = item; if (!item.top) { item.top = top; } if (!item.height) { item.height = item.offsetHeight; } top += item.height; if (!item.value) { item.value = '' + i; } const label = getMemberValue(item, that.displayMember, 'label'); const value = getMemberValue(item, that.valueMember, 'value') const group = getMemberValue(item, that.groupMember, 'group') if (item.label !== label) { item.label = label; } if (item.value !== value) { item.value = value; } if (item.group !== group) { item.group = group; } //NOTE: the context must be set to document in order for item._setDisplayMode() to get called const originalContext = item.context; item.context = document; item.displayMode = displayMode; item.context = originalContext; that._alternateItem(item); if (item.selected) { that.selectedIndexes.push(i); that.selectedValues.push(item.value); } that._items.push(item); } if (that.itemTemplate && that._handleItemTemplate(that.itemTemplate)) { that._items.map((item) => that._applyTemplate(item)); } } _group() { const that = this; that.isUpdating++; let groups = []; let items = []; if (that._canSort) { that._unsort(); } for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; let label = item.group ? item.group.trim() : item.innerHTML.charAt(0) || item.label.charAt(0); label += ' '; if (!groups[label]) { groups[groups.length++] = groups[label] = { items: [item], label: label }; } else { groups[label].items.push(item); } } if (!that.isVirtualized) { while (that.$.itemsInnerContainer.firstChild) { that.$.itemsInnerContainer.removeChild(that.$.itemsInnerContainer.firstChild); } const fragment = document.createDocumentFragment(); that._groups = []; for (let i = 0; i < groups.length; i++) { const group = groups[i]; const groupElement = document.createElement('lw-list-items-group'); groupElement.label = group.label; groupElement.dataIndex = i; for (let j = 0; j < groups[i].items.length; j++) { const item = group.items[j]; items.push(item); item.group = group.label; groupElement.appendChild(item); } that._groups.push(groupElement); fragment.appendChild(groupElement); } that._items = items; const isIE = /Trident|Edge/.test(navigator.userAgent); if (isIE) { setTimeout(function () { that.$.itemsInnerContainer.appendChild(fragment); }, 50); } else { that.$.itemsInnerContainer.appendChild(fragment); } } else { that._groups = []; for (let i = 0; i < groups.length; i++) { const group = groups[i]; group.dataIndex = i; group.grouped = true; group.hidden = false; group.displayMode = 'plain'; items.push(group); for (let j = 0; j < groups[i].items.length; j++) { const item = group.items[j]; item.group = group; items.push(item); } } that._groups = groups; that._items = items; } if (that.sorted) { that._sort(); } that.isUpdating--; } _ungroup() { const that = this; that.isUpdating++; that._groups = []; if (that._canSort) { that._unsort(); } let items = []; if (!that.isVirtualized) { const fragment = document.createDocumentFragment(); for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; fragment.appendChild(item); items.push(item); } if (items.length > 0) { that.$.itemsInnerContainer.innerHTML = ''; that.$.itemsInnerContainer.appendChild(fragment); } } else { for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; if (item.grouped) { continue; } items.push(item); } } that._items = items; if (that.sorted) { that._sort(); } that.isUpdating--; } _initializeHtmlListGroups() { const that = this; const htmlListItemsGroups = that.$.itemsInnerContainer.querySelectorAll('lw-list-items-group'); that._groups = []; for (let i = 0; i < htmlListItemsGroups.length; i++) { const group = htmlListItemsGroups[i]; group.dataIndex = i; that._groups.push(group); } } _initializeSelection() { const that = this; /* if (that.selectionMode === 'one' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'oneOrManyExtended') { if (that.selectedIndexes.length === 0 && that.selectedValues.length === 0 && that._items.length > 0 && firstSelectableItem) { } } */ const selectedIndexes = that.selectedIndexes.slice(0); const selectedValues = that.selectedValues.slice(0); that.clearSelection(); if (that.selectionMode === 'oneOrManyExtended') { that._keysPressed['Control'] = true; } for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; if (selectedIndexes.indexOf(i) >= 0 || selectedValues.indexOf(item.value || item.label) >= 0) { if (that._focusedItem) { that._focusedItem._focused = false; } that._focusedItem = null; that.select(item); } } if (that.selectionMode === 'oneOrManyExtended') { that._keysPressed['Control'] = false; } } onItemUpdated() { const that = this; if (!that.isInitialized || that._isUpdating()) { return; } that.isUpdating++; that._refreshLayout(); that.isUpdating--; } _refreshItems() { const that = this; if (!that.isInitialized || that._isUpdating()) { return; } that.isUpdating++; if (that.grouped) { that._ungroup(); } else if (that.sorted && that._canSort) { that._unsort(); } if (!that.isVirtualized) { that._items = []; const items = that.shadowRoot ? that.shadowRoot.querySelectorAll('lw-list-item') : that.querySelectorAll('lw-list-item'); for (let i = 0; i < items.length; i++) { items[i].dataIndex = i; that._alternateItem(items[i]); that._items.push(items[i]); } } if (that.grouped) { that._group(); } else if (that.sorted) { that._sort(); } that._refreshLayout(); that.isUpdating--; } /** * Incremental Search logic. */ _applyIncrementalSearch(key) { const that = this; if (that.incrementalSearchDelay === null || isNaN(that.incrementalSearchDelay)) { return; } if (['Shift', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Control', 'Home', 'End', 'PageUp', 'PageDown'].indexOf(key) > -1) { return; } if (that._incrementalSearchQuery.indexOf(key) !== 0) { that._incrementalSearchQuery += key; } if (that._incrementalSearchTimer) { clearTimeout(that._incrementalSearchTimer); } that._incrementalSearch(); that._incrementalSearchTimer = setTimeout(function () { that._incrementalSearchQuery = ''; }, that.incrementalSearchDelay); return; } /** * Selects an item by its HTML Element or Value. */ select(item) { const that = this; if (typeof item === 'string') { item = that.getItem(item); if (!item) { return; } } if (typeof item === 'number') { item = that.getItem(item); if (!item) { return; } } if (item.grouped || item.readonly || !that._items.length || (item instanceof HTMLElement && !that.contains(item))) { return; } if (that.selectionMode === 'none') { that.selectedIndexes = []; that.selectedValues = []; return; } if (!that._focusedItem !== item && that.selectionMode !== 'none') { if (that._focusedItem) { that._focusedItem._focused = false; } that._focusedItem = item; item._focused = true; } switch (that.selectionMode) { case 'one': if (that.selectedIndexes.length === 1 && that.selectedIndexes[0] === that._indexOf(item)) { return false; } that._previouslySelectedIndexes = that.selectedIndexes; if (that.selectedIndexes.length >= 1) { that.clearSelection(); } that._select(item); delete that._previouslySelectedIndexes; return true; case 'zeroOrOne': if (that.selectedIndexes.length === 1 && that.selectedIndexes[0] === that._indexOf(item)) { that.unselect(item); return true; } that._previouslySelectedIndexes = that.selectedIndexes; if (that.selectedIndexes.length >= 1) { that.clearSelection(); } that._select(item); delete that._previouslySelectedIndexes; return true; case 'radioButton': that._previouslySelectedIndexes = that.selectedIndexes; if (that.$.itemsInnerContainer.querySelectorAll('lw-list-items-group').length > 0) { const group = item.parentNode; if (!item.selected) { for (let index in group.children) { const item = group.children[index]; if (item.selected) { that.unselect(item); } } that._select(item); } delete that._previouslySelectedIndexes; return true; } else if (that.isVirtualized && that._groups.length > 0) { const group = item.group; if (!item.selected) { for (let index in group.items) { const item = group.items[index]; if (item.selected) { that.unselect(item); } } that._select(item); } delete that._previouslySelectedIndexes; return true; } if (!item.selected) { if (that.selectedIndexes.length >= 1) { that.clearSelection(); } that._select(item); } delete that._previouslySelectedIndexes; return true; case 'oneOrMany': if (!item.selected) { that._select(item); } else if (that.selectedIndexes.length > 1) { that.unselect(item); } return true; case 'zeroOrMany': case 'checkBox': if (!item.selected) { that._select(item); } else { that.unselect(item); } return true; case 'oneOrManyExtended': { const selectedValues = that.selectedValues; if (that._keysPressed['Control']) { if (that.selectedIndexes.length > 1) { if (item.selected) { that.unselect(item); that._focus(that._items[that.selectedIndexes[0]]); } else { that._select(item); } } else { that._select(item); } return true; } if (that._keysPressed['Shift']) { const selectedItem = that._items[that.selectedIndexes[0]]; let index; that.clearSelection(); const preventEvent = selectedValues.indexOf(selectedItem.value) >= 0 || selectedItem.selected; that._select(selectedItem, preventEvent); if (that._indexOf(selectedItem) > that._indexOf(item)) { index = that._indexOf(selectedItem) - 1; while (index >= that._indexOf(item)) { const item = that._items[index]; const preventEvent = selectedValues.indexOf(item.value) >= 0 || item.selected; that._select(item, preventEvent); index--; } } else { index = that._indexOf(selectedItem) + 1; while (index <= that._indexOf(item)) { const item = that._items[index]; const preventEvent = selectedValues.indexOf(item.value) >= 0 || item.selected; that._select(item, preventEvent); index++; } } const unselectedItems = []; for (let i = 0; i < selectedValues.length; i++) { unselectedItems.push(that.getItem(selectedValues[i])); } if (unselectedItems.length > 0 && !that._propertyChanging) { let selectedItems = []; for (let i = 0; i < that.selectedValues.length; i++) { const previousSelectedValue = that.selectedValues[i]; if (selectedValues.indexOf(previousSelectedValue) < 0) { selectedItems.push(that.getItem(previousSelectedValue)); } } that.$.fireEvent('change', { 'addedItems': selectedItems, 'removedItems': unselectedItems, 'selected': item.selected, 'disabled': item.disabled, 'index': that._indexOf(item), 'label': item.label, 'value': item.value }); } return true; } for (let i = 0; i < selectedValues.length; i++) { const value = selectedValues[i]; const selectedItem = that.getItem(value) if (item !== selectedItem) { that.unselect(selectedItem); } } that.clearSelection(); that._select(item, selectedValues.indexOf(item.value) >= 0); return true; } } return false; } /** * Returns the contents of the template with the new content applied. */ _applyTemplate(item, refreshLayout) { const that = this; if (that.itemTemplate === null) { return; } if (typeof that.itemTemplate === 'function') { that.itemTemplate(item, { label: item.label, value: item.value, index: that._items.indexOf(item) }); return; } if (!that._bindingDetails || that._bindingDetails.length === 0) { return; } const bindingsCount = that._bindingDetails.length; let clone = document.importNode(that._template.content, true), bindingHolderElement, bindingStringsCount; for (let b = 0; b < bindingsCount; b++) { bindingHolderElement = clone.childNodes[that._bindingDetails[b].childNodeIndex]; bindingStringsCount = that._bindingDetails[b].bindingString.length; for (let i = 0; i < bindingStringsCount; i++) { const propertyName = that._bindingDetails[b].bindingString[i]; const propertyValue = propertyName.indexOf('label') >= 0 ? item.label : item.value; bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(propertyName, propertyValue); } } item.innerHTML = ''; for (let i = 0; i < clone.childNodes.length; i++) { if (clone.childNodes[i].outerHTML) { item.innerHTML += clone.childNodes[i].outerHTML; } } if (refreshLayout === false) { return; } if (that._scrollHeightTimer) { clearInterval(that._scrollHeightTimer); that._scrollHeightCounter = 0; } that._scrollHeightTimer = setInterval(function () { if (that._lastScrollHeight !== that.$.itemsInnerContainer.scrollHeight || that._scrollHeightCounter === 10) { that._refreshLayout(); clearInterval(that._scrollHeightTimer); } that._lastScrollHeight = that.$.itemsInnerContainer.scrollHeight; that._scrollHeightCounter++; }, 50); } /** * Filter items. */ _filterItems(noSelectionRefresh, callback, ignoreFilterQueryLength) { const that = this; const filterQuery = that.$.filterInput.value; let filteredItems, items; const updateListBox = function () { if (items.length === 0) { that._filteredItems = []; if (callback) { callback(); } return; } filteredItems = that._queryItems(filterQuery, that.filterMode); for (let i = 0; i < items.length; i++) { items[i].hidden = true; items[i].$.addClass('lw-hidden'); } for (let i = 0; i < filteredItems.length; i++) { const item = filteredItems[i]; item.hidden = false; item.$.removeClass('lw-hidden'); } if (that.grouped && that.isVirtualized) { for (let i = 0; i < that._groups.length; i++) { const group = that._groups[i]; const items = group.items; let canHide = true; for (let j = 0; j < items.length; j++) { if (!items[j].hidden) { canHide = false; } } if (canHide) { group.hidden = true; } } } if (that.grouped && !that.isVirtualized) { for (let i = 0; i < that._groups.length; i++) { const group = that._groups[i]; const items = [].concat(...group.querySelectorAll('lw-list-item')); let canHide = true; for (let j = 0; j < items.length; j++) { if (!items[j].$.hasClass('lw-hidden')) { canHide = false; } } if (canHide) { group.$.addClass('lw-hidden'); } else { group.$.removeClass('lw-hidden'); } } } that._filteredItems = filteredItems; that._refreshLayout(); if (callback) { callback(); } if (noSelectionRefresh) { return; } that._refreshSelection(); } if (typeof (that.dataSource) === 'function') { if (filterQuery || ignoreFilterQueryLength) { const queryCallback = function (response) { if ((!filterQuery && !ignoreFilterQueryLength) || !that.isAttached) { return; } that._updateListBoxAfterQuery = function () { filteredItems = items = that._items; updateListBox(); }; that.clearItems(); that.insert(0, response); } const response = that.dataSource(filterQuery, queryCallback); if (response) { if (!filterQuery && !ignoreFilterQueryLength) { return; } that._updateListBoxAfterQuery = function () { filteredItems = items = that._items; updateListBox(); }; that.clearItems(); that.insert(0, response); } } else { that.clearItems(); filteredItems = items = that._items; updateListBox(); //Notify that the DataSource has changed that.$.fireEvent('bindingComplete'); } } else { items = that._items; if (items.length === 0) { return; } updateListBox(); } } /** * Returns the next item in the list. */ _getNextItem(activeItemIndex) { const that = this, items = that._items, itemsCount = that._items.length; let index = Math.max(activeItemIndex + 1, 0); while (index < itemsCount) { const item = items[index]; if (!item.disabled && !item.hidden && !item.grouped && !item.readonly) { return item; } index++; } return items[activeItemIndex]; } /** * Returns the previous item in the list. */ _getPreviousItem(activeItemIndex) { const that = this, items = that._items; let index = Math.max(activeItemIndex - 1, 0); while (index > -1) { const item = items[index]; if (!item.disabled && !item.hidden && !item.grouped && !item.readonly) { return item; } index--; } return items[activeItemIndex]; } /** * Calculates the width/height of the items. */ get _scrollWidth() { const that = this, items = that._items; if (that.__scrollWidth) { return that.__scrollWidth; } that.__scrollWidth = (() => { const that = this, virtualized = that.virtualized, itemMeasureMode = that.itemMeasureMode; let longestItemWidth = 0; let longestLabel = ''; function measure(labelToMeasure) { const measureItem = that._createItem({ label: labelToMeasure }); //NOTE: Avoids resize event being thrown as a result of element height/width change measureItem.style.position = 'absolute'; that.$.itemsContainer.appendChild(measureItem); measureItem.label = labelToMeasure; //This setting is enough to make the item width to 'auto' and measure it's size measureItem.style.width = 'auto'; //if not checked, fails in Karma because element is not Completed if (measureItem.isCompleted) { measureItem.$.itemContainer.style.width = 'auto'; } const measureItemStyle = getComputedStyle(measureItem); const padding = parseInt(measureItemStyle.paddingLeft) + parseInt(measureItemStyle.paddingRight), measureItemContent = measureItem.$.itemContainer || measureItem, result = measureItemContent.offsetWidth + measureItemContent.offsetLeft + padding; measureItem.parentNode.removeChild(measureItem); return result; } for (let i = 0; i < items.length; i++) { const currentItem = items[i]; if (currentItem.hidden) { continue; } if (itemMeasureMode === 'auto') { const label = virtualized ? currentItem.label : currentItem.textContent.trim(); if (label.length > longestLabel.length) { longestLabel = label; } } else { longestItemWidth = Math.max(longestItemWidth, measure(currentItem.label)); } } if (itemMeasureMode === 'auto') { return measure(longestLabel); } return longestItemWidth; })(); return that.__scrollWidth; } update(index, details) { const that = this; const htmlItem = that._items[index]; if (htmlItem) { if (typeof details === 'string') { htmlItem.label = details; if (undefined === htmlItem.value) { htmlItem.value = details; } } else { for (let detail in details) { if (detail === 'selected' && htmlItem[detail] !== details[detail]) { that.select(htmlItem); } else { htmlItem[detail] = details[detail]; } if (detail === 'group') { that._refreshItems(); } } } if (that.sorted || that.grouped || that.isVirtualized) { that._refreshItems(); that._refreshSelection(); } } else { that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'update' })); } } insert(index, items) { const that = this; let htmlItems = []; function itemsReady() { that._refreshItems(); if (that._items.length === 0) { return; } if (that._updateListBoxAfterQuery) { that._updateListBoxAfterQuery(); delete that._updateListBoxAfterQuery; } that._refreshSelection(); that.$.fireEvent('bindingComplete'); } if (!index) { index = 0; } if (Array.isArray(items)) { that.isUpdating++; for (let i = 0; i < items.length; i++) { const item = items[i]; const htmlItem = that._createItem(item); htmlItems.push(htmlItem); if (index >= that._items.length || that._items.length === 0) { that.appendChild(htmlItem); } else { that.insertBefore(htmlItem, that._items[index]); } } that.isUpdating--; } else { const htmlItem = that._createItem(items); htmlItems.push(htmlItem); if (index >= that._items.length || that._items.length === 0) { that.appendChild(htmlItem); } else { that.insertBefore(htmlItem, that._items[index]); } } if (htmlItems.length > 0) { htmlItems.map(item => that._applyTemplate(item)); that._ensureItemsReady(htmlItems, itemsReady); } else if (that._updateListBoxAfterQuery) { that._updateListBoxAfterQuery(); delete that._updateListBoxAfterQuery; } } removeAt(index) { const that = this; const htmlItem = that._items[index]; if (htmlItem) { if (htmlItem.selected) { that.unselect(htmlItem); } if (that.isVirtualized) { that._items.splice(index, 1); } else { htmlItem.parentNode.removeChild(htmlItem); } that._refreshItems(); that._refreshSelection(); if (that.selectedIndexes.length === 0 && that._items.length > 0) { if (that.selectionMode === 'oneOrMany' || that.selectionMode === 'one' || that.selectionMode === 'oneOrManyExtended') { that.select(that._items[0]); } } } else { that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'remove' })); } } /** * Update all matched cases from the filter input. */ _queryItems(searchQuery, searchMode) { const that = this; const result = []; const findItem = function (item, filterQuery) { if (item.grouped) { return item; } switch (searchMode) { case 'startsWith': if (item.label.indexOf(filterQuery) === 0) { return item; } break; case 'startsWithIgnoreCase': if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) === 0) { return item; } break; case 'doesNotContain': if (item.label.indexOf(filterQuery) < 0) { return item; } break; case 'doesNotContainIgnoreCase': if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) < 0) { return item; } break; case 'contains': if (item.label.indexOf(filterQuery) > -1) { return item; } break; case 'containsIgnoreCase': if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) > -1) { return item; } break; case 'equals': if (item.label.localeCompare(filterQuery) === 0) { return item; } break; case 'equalsIgnoreCase': if (item.label.toLowerCase().localeCompare(filterQuery.toLowerCase()) === 0) { return item; } break; case 'endsWith': if (item.label.endsWith(filterQuery)) { return item; } break; case 'endsWithIgnoreCase': if (item.label.toLowerCase().endsWith(filterQuery.toLowerCase())) { return item; } break; case 'custom': if (that.filterCallback(item, searchQuery)) { return item; } break; } return null; } if (searchQuery.length === 0) { return that._items; } for (let i = 0; i < that._items.length; i++) { const item = findItem(that._items[i], searchQuery); if (item) { result.push(item); } } return result; } _select(item, preventEvent) { const that = this; const selectedIndex = that.selectedIndexes.indexOf(that._indexOf(item)); const indexes = that.selectedIndexes.slice(0), values = that.selectedValues.slice(0); item.selected = true; if (selectedIndex === -1) { indexes.push(that._indexOf(item)); values.push(item.value || item.label); } else { that._recycle(); return false; } that.selectedIndexes = indexes; that.selectedValues = values; that._recycle(); //Update the hidden form input that.$.hiddenInput.value = values.toString(); if (!that.isCompleted || preventEvent || !that.isInitialized || that._propertyChanging) { return; } let previouslySelectedItems = []; if (that._previouslySelectedIndexes) { for (let i = 0; i < that._previouslySelectedIndexes.length; i++) { if (that.selectedIndexes.indexOf(that._previouslySelectedIndexes[i]) < 0) { previouslySelectedItems.push(that._items[that._previouslySelectedIndexes[i]]); } } delete that._previouslySelectedIndexes; } that.$.fireEvent('change', { 'addedItems': [item], 'removedItems': previouslySelectedItems, 'selected': item.selected, 'disabled': item.disabled, 'index': that._indexOf(item), 'label': item.label, 'value': item.value }); return true; } /** * Handles the topVisibleIndex property. Sets an item always as first in the listBox view area * @param {any} item */ _setTopVisibleIndex(item) { const that = this; if (typeof item === 'number') { that.topVisibleIndex = Math.max(0, item); item = that._items[that.topVisibleIndex]; } if (!item) { return false; } if (item.top !== that.scrollTop) { that.scrollTop = item.top; if (!that.isVirtualized) { that.$.itemsContainer.scrollTop = that.scrollTop; } //Update topVisibleIndex to the first visible item if (that.scrollHeight === that.scrollTop) { that._updateTopVisibleIndex(); } } } /** * Updates the topVisibleIndex */ _updateTopVisibleIndex() { const that = this, minScrollTop = that.scrollTop + that._scrollView.verticalScrollBar.offsetHeight - that.offsetHeight; let lastVisibleItem; if (that.scrollTop < that.scrollHeight / 2) { for (let i = 0; i < that._items.length; i++) { if (that._items[i].top >= minScrollTop) { lastVisibleItem = that._items[i]; break; } } } else { for (let i = that._items.length - 1; i >= 0; i--) { if (that._items[i].top < minScrollTop) { break; } lastVisibleItem = that._items[i]; } } if (lastVisibleItem) { that.topVisibleIndex = lastVisibleItem.dataIndex; } } unselect(item) { const that = this; if (!item) { return; } if (typeof item === 'string') { item = that.getItem(item); if (!item) { return; } } if (that.selectionMode === 'none') { that.clearSelection(); return; } const selectedIndex = that.selectedIndexes.indexOf(that._indexOf(item)); const indexes = that.selectedIndexes.slice(0), values = that.selectedValues.slice(0); item.selected = false; if (selectedIndex >= 0) { indexes.splice(selectedIndex, 1); values.splice(selectedIndex, 1); } else { return false; } that.selectedIndexes = indexes; that.selectedValues = values; //Update the hidden form input that.$.hiddenInput.value = values.toString(); if (!that.isCompleted || that._propertyChanging) { return; } that.$.fireEvent('change', { 'addedItems': [], 'removedItems': [item], 'selected': item.selected, 'disabled': item.disabled, 'index': that._indexOf(item), 'label': item.label, 'value': item.value }); that._recycle(); return true; } /** * Validates the template and if valid, returns an object with binding details. */ _handleItemTemplate(template) { if (template === null || !template) { return; } if (typeof template === 'function') { return template; } const that = this; if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); that.itemTemplate = null; return; } template = document.getElementById(template); if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'itemTemplate' })); that.itemTemplate = null; return; } const templateContent = template.content, childrenCount = templateContent.childNodes.length, regex = /{{\w+}}/g; let bindingString, bindingsFound; that._bindingDetails = []; that._template = template; for (let i = 0; i < childrenCount; i++) { bindingsFound = []; while ((bindingString = regex.exec(templateContent.childNodes[i].innerHTML))) { bindingsFound.push(bindingString[0]); } if (bindingsFound.length > 0) { that._bindingDetails.push({ childNodeIndex: i, bindingString: bindingsFound }); } } return true; } /** * Handles pressed keys. */ _handleKeyStrokes(key) { const that = this; const toFocus = that.selectionMode === 'radioButton' || that.selectionMode === 'checkBox' || that.selectionMode === 'zeroOrMany' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne'; let items = that._items; if (that.filterable && that.$.filterInput.value.length > 0) { items = that._filteredItems; } if (that.disabled || that.readonly || !items.length) { return; } switch (key) { case 'ArrowLeft': case 'ArrowUp': that._handleArrowKeys(true); break; case 'ArrowRight': case 'ArrowDown': that._handleArrowKeys(false); break; case ' ': { if (that.selectedIndexes.length < 1 && !that._focusedItem) { return; } const focusedItem = that._focusedItem ? that._focusedItem : that._items[that.selectedIndexes[that.selectedIndexes.length - 1]]; const makeSelection = (item) => { if (item.selected && that.selectionMode !== 'radioButton') { that.unselect(item); } else { that.select(item); } } if (that.selectionMode === 'oneOrMany') { if (focusedItem.selected && that.selectedIndexes.length > 1) { makeSelection(focusedItem); } else if (!focusedItem.selected) { makeSelection(focusedItem); } return; } makeSelection(focusedItem); break; } case 'Home': { if (items.length === 0) { return; } if (toFocus) { that._focus(items[0]); } else { if (!that._keysPressed['Shift']) { that.clearSelection(); } that.select(items[0]); that._focus(items[0]); } that.scrollTop = 0; break; } case 'End': { if (items.length === 0) { return; } if (toFocus) { that._focus(items[items.length - 1]); } else { if (!that._keysPressed['Shift']) { that.clearSelection(); } that.select(items[items.length - 1]); that._focus(items[items.length - 1]); } that.scrollTop = that.scrollHeight; break; } case 'PageUp': { that._pageUpKeyHandler(items); break; } case 'PageDown': { that._pageDownKeyHandler(items); break; } } that._recycle(); } /** * Horizontal Scroll Bar handler */ _horizontalScrollbarHandler(event) { const that = this; event.stopPropagation(); if (that.isVirtualized) { that._recycle(); } else { that.$.itemsContainer.scrollLeft = that._getScrollLeft(event.detail.value); } } /** * Returns the scrollLeft of the itemsContainer */ _getScrollLeft(scrollLeft, scrollWidth) { const that = this; if (!that.rightToLeft) { return scrollLeft; } //Note: Chrome has a bug with direction: rtl. Doesn't inverse the scrollLeft //see: https://bugs.chromium.org/p/chromium/issues/detail?id=721759 if (LW.Utilities.Core.Browser.Chrome) { if (!scrollWidth) { const horizontalOffset = 2 * (parseInt(getComputedStyle(that.$.itemsInnerContainer).getPropertyValue('--lw-list-item-horizontal-offset')) || 0); scrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - horizontalOffset; } scrollLeft = scrollWidth - scrollLeft; } else { scrollLeft *= -1; } return scrollLeft; } _unsort() { const that = this; that.isUpdating++; const sortByIndex = function (a, b) { let indexA = a.dataIndex; let indexB = b.dataIndex; if (indexA < indexB) { return -1; } if (indexA > indexB) { return 1; } return 0; }; if (!that.isVirtualized) { if (that._groups.length > 0) { that._groups.sort(sortByIndex); let sortedItems = []; for (let i = 0; i < that._groups.length; i++) { const group = that._groups[i]; const items = [].concat(...group.querySelectorAll('lw-list-item')); items.sort(sortByIndex); sortedItems = sortedItems.concat(items); } that._items = sortedItems; } else { that._items.sort(sortByIndex); } that._applySortOrder(); } else { if (that._groups.length > 0) { that._groups.sort(sortByIndex); let sortedItems = []; for (let i = 0; i < that._groups.length; i++) { const group = that._groups[i]; const items = [].concat(...group.items); items.sort(sortByIndex); sortedItems.push(group); sortedItems = sortedItems.concat(items); } that._items = sortedItems; } else { that._items.sort(sortByIndex); } } that.isUpdating--; } _applySortOrder() { const that = this; const reorder = function (items) { for (let i = 0; i < items.length; i++) { const item = items[i]; const parentNode = item.parentNode; if (!parentNode) { continue; } parentNode.appendChild(item); } } reorder(that._items); reorder(that._groups); } _sort() { const that = this; if (!that._canSort) { return; } that.isUpdating++; const sortByLabel = function (a, b) { let labelA = a.label; let labelB = b.label; if (that.sortDirection === 'asc') { if (labelA < labelB) { return -1; } if (labelA > labelB) { return 1; } } else { if (labelA < labelB) { return 1; } if (labelA > labelB) { return -1; } } return 0; }; that._groups.sort(sortByLabel); if (!that.isVirtualized) { if (that._groups.length > 0) { let sortedItems = []; for (let i = 0; i < that._groups.length; i++) { const group = that._groups[i]; const items = [].concat(...group.querySelectorAll('lw-list-item')); items.sort(sortByLabel); sortedItems = sortedItems.concat(items); } that._items = sortedItems; } else { that._items.sort(sortByLabel); } that._applySortOrder(); } else { if (that._groups.length > 0) { let sortedItems = []; for (let i = 0; i < that._groups.length; i++) { const group = that._groups[i]; const items = [].concat(...group.items); sortedItems.push(group); items.sort(sortByLabel); sortedItems = sortedItems.concat(items); } that._items = sortedItems; } else { that._items.sort(sortByLabel); } } that.isUpdating--; } getItem(value) { const that = this; for (let i = 0; i < that._items.length; i++) { if (that._items[i].value === value) { return that._items[i]; } } return null; } _focus(item) { const that = this; if (!item || that.selectionMode === 'none' || that.disabled || that.readonly) { return; } if (that._focusedItem) { that._focusedItem._focused = false; } that._focusedItem = item; that._focusedItem._focused = true; } /** * KeyDown handler. */ _keyDownHandler(event) { const that = this, activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement; let key = event.key; if (that.disabled || that.readonly) { return; } if (that.filterable && that.$.filterInput === activeElement) { return; } if (!that._focused) { return; } if (that._items.length === 0 || that.disabled || that.displayLoadingIndicator) { return; } if (that.editable) { if (key === 'F2') { that._dblclickEventHandler({ target: that._focusedItem }); return; } else { if (that.$.editInput === activeElement) { return; } } } if (that.selectionMode === 'none') { return; } event.stopPropagation(); // Fix for not standartized event.key in Edge. switch (key) { case 'Down': case 'Right': case 'Left': case 'Up': key = 'Arrow' + key; break; } if (that.filterable) { switch (key) { case 'ArrowLeft': case 'ArrowRight': return; case 'ArrowUp': case 'ArrowDown': event.preventDefault(); } } that._applyIncrementalSearch(key); if (['Shift', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Control', ' ', 'Home', 'End', 'PageUp', 'PageDown'].indexOf(key) < 0) { return; } event.preventDefault(); //prevent window scrolling if (!that._focusedItem && that._items.length > 0) { if (that.selectionMode === 'one' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'oneOrManyExtended') { that.select(that._items[0]); } else { that._focus(that._items[0]); } return; } switch (that.selectionMode) { case 'one': if (key === 'Shift' || key === 'Control' || key === ' ') { return; } that._handleKeyStrokes(key); break; case 'oneOrMany': case 'zeroOrOne': case 'zeroOrMany': case 'radioButton': case 'checkBox': if (key === 'Shift' || key === 'Control') { return; } that._handleKeyStrokes(key); break; case 'oneOrManyExtended': if (key === ' ') { return; } that._keysPressed[key] = event.type === 'keydown'; that._handleKeyStrokes(key); break; } } /** * KeyUp handler. */ _keyUpHandler(event) { const that = this, activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement; if (that.editable && that.$.editInput === activeElement) { return; } if (that.filterable && that.$.filterInput === activeElement) { if (that._filterTimer) { clearTimeout(that._filterTimer); } that._filterTimer = setTimeout(function () { const context = that.context; that.context = that; that._filterItems(); that.scrollTop = that.$.itemsContainer.scrollTop = 0; that.scrollLeft = that.$.itemsContainer.scrollLeft = that._getScrollLeft(0); that.context = context; }, 300); return; } if (!that._focused) { return; } if (that._focusedItem && that._focusedItem.hidden) { if (that._filteredItems.length > 0) { let itemToFocus = that._filteredItems[0]; if (itemToFocus.grouped && that._filteredItems.length > 1) { itemToFocus = that._filteredItems[1]; } that._focus(itemToFocus); that._recycle(); } } event.stopPropagation(); event.preventDefault(); if (that.disabled) { return; } if (['Shift', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Control', ' ', 'PageUp', 'PageDown'].indexOf(event.key) < 0) { return; } that._keysPressed[event.key] = false; } /** * Container mousewheel event handler. */ _mouseWheelHandler(event) { const that = this; if (!that.computedHorizontalScrollBarVisibility && !that.computedVerticalScrollBarVisibility) { return; } if (!that.disabled && that.computedVerticalScrollBarVisibility) { const scrollTop = that.scrollTop; if (scrollTop === 0 && event.deltaY < 0 || scrollTop === that.scrollHeight && event.deltaY > 0) { return; } event.stopPropagation(); event.preventDefault(); that.scrollTo(scrollTop + that._getScrollCoefficient(event, that.offsetHeight)); } } /** * Page Down key handler. */ _pageDownKeyHandler(items) { const that = this; if (items.length === 0) { return; } let selectedItem = that._items[that.selectedIndexes[that.selectedIndexes.length - 1]]; if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') { if (that._focusedItem) { selectedItem = that._focusedItem; } } if (!selectedItem) { return; } let item; const selectedItemIndex = that._indexOf(selectedItem); let viewTop = selectedItem.top + that.$.itemsContainer.offsetHeight - selectedItem.height; for (let i = selectedItemIndex; i < items.length; i++) { if (items[i].top >= viewTop) { item = items[i]; break; } } if (!item) { item = items[items.length - 1]; } if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') { that._focus(item); } else { if (!item.selected) { if (!that._keysPressed['Shift']) { that.clearSelection(); } that.select(item); that._focus(item); } } if (item.height + item.top > that.$.itemsContainer.scrollTop + that.$.itemsContainer.offsetHeight || item.top < that.$.itemsContainer.scrollTop) { that.scrollTop = item.top - that.$.itemsContainer.offsetHeight + item.height; } } /** * Page Up key handler. */ _pageUpKeyHandler(items) { const that = this; if (items.length === 0) { return; } let selectedItem = that._items[that.selectedIndexes[that.selectedIndexes.length - 1]]; if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') { if (that._focusedItem) { selectedItem = that._focusedItem; } } if (!selectedItem) { return; } const viewTop = selectedItem.top - that.$.itemsContainer.offsetHeight; const selectedItemIndex = that._indexOf(selectedItem); let item; for (let i = selectedItemIndex; i > 0; i--) { if (items[i].top <= viewTop) { item = items[i]; break; } } if (!item) { item = items[0]; } if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') { that._focus(item); } else { if (!item.selected) { if (!that._keysPressed['Shift']) { that.clearSelection(); } that.select(item); that._focus(item); } } that.scrollTop = item.top; const itemIndex = that._indexOf(item); if (itemIndex === 0) { that.scrollTop = 0; } } /** * Removes all items from DOM. */ clearItems() { const that = this; that.clearSelection(); that.$.itemsInnerContainer.innerHTML = ''; that._items = []; delete that._focusedItem; that.$placeholder.removeClass('lw-hidden'); } /** * List Box resize handler. */ _resizeHandler(event) { const that = this; if (event.target === that && !that._isUpdatingScrollBars) { that._isUpdatingScrollBars = true; that._initializeRecyclingItems(); that._refreshLayout(); that._isUpdatingScrollBars = false; } } _indexOf(item) { const that = this; if (!item) { return -1; } let index = that._items.indexOf(item); if (index === -1) { index = that._items.indexOf(that.getItem(item.value)); } return index; } /** * Search items. */ _incrementalSearch() { const that = this; const canSelect = that.selectionMode !== 'radioButton' && that.selectionMode !== 'checkBox' && that.selectionMode !== 'zeroOrMany' && that.selectionMode !== 'oneOrMany' && that.selectionMode !== 'zeroOrOne'; let searchQuery; let i = 0; switch (that.incrementalSearchMode) { case 'containsIgnoreCase': case 'equalsIgnoreCase': case 'startsWithIgnoreCase': case 'endsWithIgnoreCase': searchQuery = that._incrementalSearchQuery.toLowerCase(); break; default: searchQuery = that._incrementalSearchQuery; break; } const select = function (item) { if (item.grouped || item.readonly) { return; } if (canSelect) { if (that.selectedIndexes.length > 0) { that.clearSelection(); } that._focus(item); that.select(item); } else { that._focus(item); } //Move the scrollBar when item is out of view if (item.height + item.top > that.$.itemsContainer.scrollTop + that.$.itemsContainer.offsetHeight || item.top < that.scrollTop) { that.scrollTop = item.top; } if (that._indexOf(item) === 0) { that.scrollTop = 0; } if (that._indexOf(item) === that._items.length - 1) { that.scrollTop = that.scrollHeight; } } if (that._previousEntry.localeCompare(searchQuery) !== 0) { that._incrementalSearchItems = that._queryItems(that._incrementalSearchQuery, that.incrementalSearchMode); delete that._itemPosition; } //Previously entered string. that._previousEntry = searchQuery; const foundItemsCount = that._incrementalSearchItems.length; if (foundItemsCount === 0) { return; } if (foundItemsCount === 1) { select(that._incrementalSearchItems[0]); return; } if (that._itemPosition !== undefined) { if (that._itemPosition < foundItemsCount - 1) { i = that._itemPosition; } else { i = 0; if (canSelect) { that._incrementalSearchItems[that._itemPosition].selected = false; that.selectedIndexes = []; that.selectedValues = []; } else { that._incrementalSearchItems[that._itemPosition]._focused = false; } } } else if (canSelect) { that.clearSelection(); } for (i; i < foundItemsCount; i++) { if (that._incrementalSearchItems[i].selected && canSelect) { that._incrementalSearchItems[i].selected = false; that.selectedIndexes = []; that.selectedValues = []; continue; } if (!canSelect && that._incrementalSearchItems[i]._focused) { that._incrementalSearchItems[i]._focused = false; continue; } select(that._incrementalSearchItems[i]); that._itemPosition = i; return; } } /** * Document select start handler. */ _selectStartHandler(event) { const that = this, activeElement = (that.shadowRoot || that.getRootNode()).activeElement; if (that.$.filterInput === activeElement) { return; } if (that.$.editInput === activeElement) { return; } event.preventDefault(); } /** * Sets an item active via Keyboard. */ _handleArrowKeys(isArrowUp) { const that = this; const canSelect = that.selectionMode !== 'radioButton' && that.selectionMode !== 'checkBox' && that.selectionMode !== 'zeroOrMany' && that.selectionMode !== 'oneOrMany' && that.selectionMode !== 'zeroOrOne'; if (that.disabled || that.readonly) { return; } let focusedItemIndex; if (that._focusedItem && !that._keysPressed['Shift']) { focusedItemIndex = that._indexOf(that._focusedItem); that._focusedItem._focused = false; } else if (that.selectedIndexes.length !== 0) { focusedItemIndex = that.selectedIndexes[that.selectedIndexes.length - 1] } else { return; } const focusedItem = isArrowUp ? that._getPreviousItem(focusedItemIndex) : that._getNextItem(focusedItemIndex); that._focus(focusedItem); if (canSelect) { if (that._keysPressed['Shift']) { that.select(focusedItem); } else if (that._items[focusedItemIndex] !== focusedItem) { that.clearSelection(); that.select(focusedItem); } } that.ensureVisible(focusedItem); } /** * Enable/Disable the filter input component. */ _refreshFilter() { const that = this; if (that.filterable) { that.$.filterInput.disabled = that.disabled || that.displayLoadingIndicator ? true : false; that.$filterInputContainer.removeClass('lw-hidden'); that.$itemsContainer.addClass('filter'); return; } that.$.filterInput.disabled = true; that.$filterInputContainer.addClass('lw-hidden'); that.$itemsContainer.removeClass('filter'); } /** * Set tabIndex. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); return; } that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0; } /** * Set Loading Indicator Visibility */ _setLoadingIndicatorVisibility() { const that = this; if (that.displayLoadingIndicator) { that.$loadingIndicatorContainer.hasClass('lw-visibility-hidden') ? that.$loadingIndicatorContainer.removeClass('lw-visibility-hidden') : that.$loadingIndicatorContainer.removeClass('lw-hidden'); return; } //Check for old browsers. that._areCSSVarsSupported ? that.$loadingIndicatorContainer.addClass('lw-hidden') : that.$loadingIndicatorContainer.addClass('lw-visibility-hidden'); } /** * Sets the initial scroll bar sizes. */ _refreshLayout() { const that = this; const source = that._filteredItems || that._items; that.__scrollHeight = null; that.__scrollWidth = null; that._height = null; if (!that._scrollView) { that._scrollView = new LW.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar); } that.$itemsContainer.removeClass('hscroll'); that.$itemsContainer.removeClass('vscroll'); if (!source || source === null || source.length === 0) { that.scrollWidth = 0; that.scrollHeight = 0; that.$filterInputContainer.removeClass('vscroll'); that.$placeholder.removeClass('lw-hidden'); if (that.isVirtualized) { that._recycle(); } //Reset that.$.itemsInnerContainer.style.width = ''; return; } that.$placeholder.addClass('lw-hidden'); const horizontalOffset = 2 * (parseInt(getComputedStyle(that.$.itemsContainer).getPropertyValue('--lw-list-item-horizontal-offset')) || 0); let hScrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - horizontalOffset; let vScrollHeight = that._scrollHeight; that._refreshHorizontalScrollBarVisibility(hScrollWidth); that._refreshVerticalScrollBarVisibility(vScrollHeight); //Reset the width before measure that.$.itemsInnerContainer.style.width = ''; if (that.horizontalScrollBarVisibility === 'hidden') { that.$.itemsInnerContainer.style.width = that.$.itemsContainer.offsetWidth - horizontalOffset; } else { that.$.itemsInnerContainer.style.width = Math.max(that.$.itemsContainer.offsetWidth - horizontalOffset, -horizontalOffset + that.__scrollWidth) + 'px'; } if (that.computedVerticalScrollBarVisibility) { hScrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - horizontalOffset; that._refreshHorizontalScrollBarVisibility(hScrollWidth); if (that.horizontalScrollBarVisibility !== 'hidden') { //Reset the width before measure that.$.itemsInnerContainer.style.width = ''; that.$.itemsInnerContainer.style.width = Math.max(that.$.itemsContainer.offsetWidth - horizontalOffset, -horizontalOffset + that.__scrollWidth) + 'px'; } if (that.computedHorizontalScrollBarVisibility) { if (!(that.horizontalScrollBarVisibility === 'visible' && that.scrollWidth === 0)) { that.__scrollHeight += that._scrollView.hScrollBar.offsetHeight; } else if (that.horizontalScrollBarVisibility === 'visible') { that.__scrollHeight += that._scrollView.hScrollBar.offsetHeight; } that.scrollHeight = that.__scrollHeight; } if (that.isVirtualized) { that._recycle(); } return; } hScrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - horizontalOffset; that._refreshHorizontalScrollBarVisibility(hScrollWidth); if (that.computedHorizontalScrollBarVisibility) { that.scrollHeight = that._scrollHeight; that._refreshVerticalScrollBarVisibility(that.scrollHeight); if (that.computedVerticalScrollBarVisibility) { hScrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - that._scrollView.vScrollBar.offsetWidth; that._refreshHorizontalScrollBarVisibility(hScrollWidth); } //Resize event not thrown after 'bottom-corner' is applied if (that._scrollView.vScrollBar.$.hasClass('bottom-corner')) { that._scrollView.vScrollBar.refresh(); } } if (that.isVirtualized) { that._recycle(); } const isIE = /Trident|Edge/.test(navigator.userAgent); if (!that.isRefreshing && isIE) { setTimeout(function () { that.isRefreshing = true; that._refreshLayout(); that.isRefreshing = false; }, 50); } } /** * Style change event. */ _styleChangedHandler() { const that = this; that._refreshLayout(); } /** * SwipeLeft event handler. **/ _swipeLeftHandler() { } /** * SwipeRight event handler. */ _swipeRightHandler() { } /** * Enable/Disable Horizontal Scroll bar. */ _refreshHorizontalScrollBarVisibility(scrollWidth) { const that = this; that.scrollWidth = scrollWidth; if (that.computedHorizontalScrollBarVisibility) { that.scrollLeft = that._getScrollLeft(that.$.itemsContainer.scrollLeft, scrollWidth); that.$itemsContainer.addClass('hscroll'); } else { that.$itemsContainer.removeClass('hscroll'); } } /** * Enable/Disable Vertical Scroll bar. */ _refreshVerticalScrollBarVisibility(scrollHeight) { const that = this; that.scrollHeight = scrollHeight; if (that.computedVerticalScrollBarVisibility) { that.$itemsContainer.addClass('vscroll'); that.$filterInputContainer.addClass('vscroll'); } else { that.$itemsContainer.removeClass('vscroll'); that.$filterInputContainer.removeClass('vscroll'); } } /** * Validates Template properties. */ _validateTemplate(property, template) { if (template === null || !template) { return; } const that = this; if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); that[property] = null; return; } template = document.getElementById(template); if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: property })); that[property] = null; return; } return template; } _getItemIndexByPosition(position) { const that = this; const getItemIndex = (items) => { let bottomPointer = 0; let topPointer = items.length - 1; if (position <= 0) { return 0; } const lastNode = items[items.length - 1]; if (lastNode.top <= position) { return items.length - 1; } const condition = true; while (condition) { const midPointer = Math.floor((bottomPointer + topPointer) / 2); const currentitem = items[midPointer]; if (that._isItemInPosition(currentitem, position)) { return midPointer; } else if (currentitem.top < position) { bottomPointer = midPointer + 1; } else if (currentitem.top > position) { topPointer = midPointer - 1; } } }; const items = that.filterable && that.$.filterInput.value.length > 0 ? that._filteredItems : that._items; const index = getItemIndex(items); return index; } _isItemInPosition(item, position) { const topPixel = item.top; const bottomPixel = item.top + item.height; const pixelInRow = topPixel <= position && bottomPixel > position; return pixelInRow; } get isVirtualized() { const that = this; return that.virtualized && that.dataSource && that.dataSource.length > 0 } _recycle() { const that = this; if (!that._recyclingItems) { return; } let height = that._height; if (!that._height) { height = that._height = that.$.itemsContainer.offsetHeight; } let j = 0; const value = that.scrollTop; const itemIndex = that._getItemIndexByPosition(value); const items = that.filterable && that.$.filterInput.value.length > 0 ? that._filteredItems : that._items; const item = items[itemIndex]; let itemTop = item ? item.top : 0; that.$.itemsInnerContainer.style.left = -that.scrollLeft + 'px'; that.$.itemsInnerContainer.style.top = -value + itemTop + 'px'; that.isUpdating++; if (itemIndex >= 0) { const totalItems = items.length; for (let i = itemIndex; i < totalItems; i++) { const item = items[i]; if (item.height === 0) { continue; } if (itemTop + item.height >= value && itemTop <= value + height) { const listItem = that._recyclingItems[j++]; if (!listItem) { break; } listItem.setAttribute('aria-setsize', totalItems); listItem.setAttribute('aria-posinset', i); listItem.context = document; listItem.dataItem = item; listItem.label = item.label; listItem.value = item.value; listItem.selected = item.selected; listItem._focused = item._focused; listItem.hidden = item.hidden; listItem.grouped = item.grouped; listItem.readonly = item.readonly; listItem.style.height = item.height + 'px'; that._alternateItem(listItem); if (item.title) { listItem.title = item.title; } else { listItem.title = ''; } if (!item.grouped) { listItem.displayMode = item.displayMode; } else { listItem.displayMode = 'plain'; } if (that.scrollWidth > 0) { listItem.style.width = that.$.itemsInnerContainer.offsetWidth + that.scrollWidth + 'px'; } if (that.itemTemplate && that._handleItemTemplate(that.itemTemplate)) { that._applyTemplate(listItem, false); } } else { break; } itemTop += item.height; } } if (j < that._recyclingItems.length) { for (let i = j; i < that._recyclingItems.length; i++) { const listItem = that._recyclingItems[j++]; const context = listItem.context; listItem.context = document; listItem.hidden = true; listItem.context = context; } } that.isUpdating--; } /** * Vertical Scroll Bar handler */ _verticalScrollbarHandler(event) { const that = this; const value = event.detail.value; event.stopPropagation(); if (that.isVirtualized) { that._recycle(); } else { that.$.itemsContainer.scrollTop = value; } that._updateTopVisibleIndex(); if (event.context.max === event.context.value) { that.$.fireEvent('scrollBottomReached'); return; } if (event.context.min === event.context.value) { that.$.fireEvent('scrollTopReached'); } } /** * Applies "aria-selected" attribute to items (related to WAI-ARIA support). */ _applyAriaSelected() { const that = this, items = that.isVirtualized ? that._recyclingItems : that._items, selectionMode = that.selectionMode; for (let i = 0; i < items.length; i++) { const item = items[i]; if (item.selected) { item.setAttribute('aria-selected', true); } else if (item.readonly || item.disabled || ['oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'checkBox'].indexOf(selectionMode) === -1) { item.removeAttribute('aria-selected'); } else { item.setAttribute('aria-selected', false); } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Numeric text box custom element. */ LW('lw-numeric-text-box', class NumericTextBox extends LW.BaseElement { /** * Numeric text box's properties. */ static get properties() { return { 'decimalSeparator': { value: '.', type: 'string' }, 'dropDownAppendTo': { value: null, type: 'any' }, 'enableMouseWheelAction': { value: false, type: 'boolean' }, 'inputFormat': { value: 'integer', allowedValues: ['integer', 'floatingPoint', 'complex'], type: 'string' }, 'hint': { value: '', type: 'string' }, 'label': { value: '', type: 'string' }, 'leadingZeros': { value: false, type: 'boolean' }, 'max': { value: null, type: 'any' }, 'messages': { value: { 'en': { 'binary': 'BIN', 'octal': 'OCT', 'decimal': 'DEC', 'hexadecimal': 'HEX', 'integerOnly': 'lwNumericTextBox: The property {{property}} can only be set when inputFormat is integer.', 'noInteger': 'lwNumericTextBox: the property {{property}} cannot be set when inputFormat is integer.', 'significantPrecisionDigits': 'lwNumericTextBox: the properties significantDigits and precisionDigits cannot be set at the same time.' } }, type: 'object', extend: true }, 'min': { value: null, type: 'any' }, 'name': { value: '', type: 'string' }, 'nullable': { value: false, type: 'boolean' }, 'opened': { value: false, type: 'boolean' }, 'outputFormatString': { value: null, type: 'string?' }, 'placeholder': { value: '', type: 'string' }, 'dropDownEnabled': { value: false, type: 'boolean' }, 'precisionDigits': { value: null, type: 'number?' }, 'radix': { value: 10, allowedValues: ['2', '8', '10', '16', 2, 8, 10, 16, 'binary', 'octal', 'decimal', 'hexadecimal'], type: 'any' }, 'radixDisplay': { value: false, type: 'boolean' }, 'radixDisplayPosition': { value: 'left', allowedValues: ['left', 'right'], type: 'string' }, 'scientificNotation': { value: false, type: 'boolean' }, 'showDropDownValues': { value: false, type: 'boolean' }, 'showUnit': { value: false, type: 'boolean' }, 'significantDigits': { value: null, type: 'number?' }, 'spinButtons': { value: false, type: 'boolean' }, 'spinButtonsDelay': { value: 75, type: 'number' }, 'spinButtonsInitialDelay': { value: 0, type: 'number' }, 'spinButtonsPosition': { value: 'right', allowedValues: ['left', 'right'], type: 'string' }, 'spinButtonsStep': { value: '1', type: 'any' }, 'type': { value: 'numeric', type: 'string', defaultReflectToAttribute: true, readonly: true }, 'unit': { value: 'kg', type: 'string' }, 'validation': { value: 'strict', allowedValues: ['strict', 'interaction'], type: 'string' }, 'value': { value: '0', type: 'any?' }, 'wordLength': { value: 'int32', allowedValues: ['int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'], type: 'string' } }; } /** * Numeric text box's event listeners. */ static get listeners() { return { 'mouseenter': '_mouseenterMouseleaveHandler', 'mouseleave': '_mouseenterMouseleaveHandler', 'resize': '_resizeHandler', 'downButton.click': '_downButtonClickHandler', 'downButton.mouseenter': '_mouseenterMouseleaveHandler', 'downButton.mouseleave': '_mouseenterMouseleaveHandler', 'dropDown.click': '_dropDownItemClickHandler', 'dropDown.mouseout': '_mouseenterMouseleaveHandler', 'dropDown.mouseover': '_mouseenterMouseleaveHandler', 'input.blur': '_inputBlurHandler', 'input.change': '_inputChangeHandler', 'input.focus': '_inputFocusHandler', 'input.keydown': '_inputKeydownHandler', 'input.keyup': '_inputKeyupHandler', 'input.paste': '_inputPasteHandler', 'input.wheel': '_inputWheelHandler', 'radixDisplayButton.click': '_radixDisplayButtonClickHandler', 'radixDisplayButton.mouseenter': '_mouseenterMouseleaveHandler', 'radixDisplayButton.mouseleave': '_mouseenterMouseleaveHandler', 'upButton.click': '_upButtonClickHandler', 'upButton.mouseenter': '_mouseenterMouseleaveHandler', 'upButton.mouseleave': '_mouseenterMouseleaveHandler', 'document.down': '_documentMousedownHandler', 'document.up': '_documentMouseupHandler' }; } /** * Numeric text box's required files. */ static get requires() { if (window.NIComplex) { return { 'LW.Button': 'lw.button.js', 'LW.Utilities.BigNumber': 'lw.math.js', 'LW.Utilities.NumericProcessor': 'lw.numeric.js' }; } return { 'LW.Button': 'lw.button.js', 'LW.Utilities.Complex': 'lw.complex.js', 'LW.Utilities.BigNumber': 'lw.math.js', 'LW.Utilities.NumericProcessor': 'lw.numeric.js' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.button.css', 'lw.numerictextbox.css' ] } /** * Numeric text box's HTML template. */ template() { const template = `<div id="container" class="lw-container" role="presentation"> <span id="label" inner-h-t-m-l="[[label]]" class="lw-label"></span> <div id="radixDisplayButton" class="lw-unselectable lw-input-addon lw-drop-down-button lw-numeric-text-box-component lw-numeric-text-box-radix-display" role="button" aria-haspopup="listbox"></div> <input id="input" type="text" spellcheck="false" class="lw-input lw-numeric-text-box-component" placeholder="[[placeholder]]" readonly="[[readonly]]" disabled="[[disabled]]" name="[[name]]" aria-label="[[placeholder]]" /> <div id="unitDisplay" class="lw-unselectable lw-input-addon lw-drop-down-button lw-numeric-text-box-component lw-numeric-text-box-unit-display" role="presentation"></div> <div id="spinButtonsContainer" class="lw-input-addon lw-numeric-text-box-component lw-spin-buttons-container" role="presentation"> <lw-repeat-button initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" animation="[[animation]]" unfocusable id="upButton" class="lw-spin-button" aria-label="Increment" right-to-left="[[rightToLeft]]"> <div class="lw-arrow lw-arrow-up" role="presentation" aria-hidden="true"></div> </lw-repeat-button> <lw-repeat-button initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" animation="[[animation]]" unfocusable id="downButton" class="lw-spin-button" aria-label="Decrement" right-to-left="[[rightToLeft]]"> <div class="lw-arrow lw-arrow-down" role="presentation" aria-hidden="true"></div> </lw-repeat-button> </div> <ul id="dropDown" class="lw-visibility-hidden lw-drop-down lw-numeric-text-box-drop-down" role="listbox"> <li id="dropDownItem2" class="lw-list-item" data-value="2" role="option"></li> <li id="dropDownItem8" class="lw-list-item" data-value="8" role="option"></li> <li id="dropDownItem10" class="lw-list-item" data-value="10" role="option"></li> <li id="dropDownItem16" class="lw-list-item" data-value="16" role="option"></li> </ul> <span id="hint" class="lw-hint lw-hidden" inner-h-t-m-l="[[hint]]"></span> </div>`; return template; } /** * Called when the element is attached from the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted) { return; } that._positionDetection.dropDownAttached(); that._positionDetection.checkBrowserBounds(); } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); if (that.opened) { that._closeRadix(true); } if (that._positionDetection) { that._positionDetection.dropDownDetached(); } } /** * Invoked when an instance of custom element is attached to the DOM for the first time. */ ready() { super.ready(); } render() { const that = this; that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'inputFormat'); that._numberRenderer = new LW.Utilities.NumberRenderer(); that._numberRenderer.localizationObject.decimalseparator = that.decimalSeparator; that._positionDetection = new LW.Utilities.PositionDetection(that, that.$.dropDown, that.$.container, '_closeRadix'); that._positionDetection.getDropDownParent(true); that._dropDownListPosition = 'bottom'; if (that.rightToLeft) { that.spinButtonsPosition = that.spinButtonsPosition === 'right' ? 'left' : 'right'; } that._setIds(); that.setAttribute('aria-describedby', that.$.unitDisplay.id + ' ' + that.$.hint.id); if (!that.getAttribute('aria-labelledby')) { that.setAttribute('aria-labelledby', that.$.label.id); } that.$.radixDisplayButton.setAttribute('aria-owns', that.$.dropDown.id); if (that.rightToLeft && that.dropDownAppendTo !== null) { that.$.dropDown.setAttribute('right-to-left', ''); } that._radixPrefixes = { 10: 'd', 2: 'b', 8: 'o', 16: 'x' }; // regular expressions for binary, octal, decimal and hexadecimal numbers that._regex = { 2: new RegExp(/^[0-1]+$/), 8: new RegExp(/^[0-7]+$/), 10: new RegExp(/^[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?$/), 16: new RegExp(/^[0-9a-f]+$/i) }; // regular expressions for special values that._regexSpecial = { nan: new RegExp(/^(nan)$/i), inf: new RegExp(/^((-?inf(inity)?)|([+\-]?))$/i), nonNumericValue: new RegExp(/^$|(^((nan)|((-?inf(inity)?)|([+\-]?))|(null))$)/i), exaValue: new RegExp(/^[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[E][+\-]\d*)?i$/) } that._initialDropDownOptionsSet = false; if (that.spinButtonsPosition === 'left') { that.$.container.insertBefore(that.$.spinButtonsContainer, that.$.label.nextElementSibling); } if (that.radixDisplayPosition === 'right') { that.$.container.insertBefore(that.$.radixDisplayButton, that.$.unitDisplay.nextElementSibling); } that._setInitialComponentDisplay(); that._initialAdjustments(); that._refreshShape(); that._initialized = true; if(!that.hint) { that.hint = that.placeholder; } super.render(); } /** * Sets ids to elements from the template (whenever necessary). */ _setIds() { const that = this; if (!that.$.label.id) { that.$.label.id = that.id + 'Label'; } if (!that.$.radixDisplayButton.id) { that.$.radixDisplayButton.id = that.id + 'RadixDisplayButton'; } if (!that.$.unitDisplay.id) { that.$.unitDisplay.id = that.id + 'UnitDisplay'; } if (!that.$.dropDown.id) { that.$.dropDown.id = that.id + 'DropDown'; } if (!that.$.hint.id) { that.$.hint.id = that.id + 'Hint'; } } _refreshShape() { const that = this, addons = that.$.container.querySelectorAll('.lw-numeric-text-box-component:not(.lw-hidden)'); Array.from(that.$.container.getElementsByClassName('lw-numeric-text-box-component')).forEach(addon => addon.classList.remove('lw-numeric-text-box-component-border-left', 'lw-numeric-text-box-component-border-right')); if (addons.length > 0) { addons[0].classList.add('lw-numeric-text-box-component-border-left'); addons[addons.length - 1].classList.add('lw-numeric-text-box-component-border-right'); } } /* * Public methods */ /** * Sets or gets the value of the numeric text box. * * @param {Number/String} value Optional value to be set to the numeric text box. If this parameter is not set, the method gets the value. * @param {Boolean} suppressValidation Optional If true is passed, the value is not validated. */ val(value, suppressValidation) { const that = this, isEmptyObject = value !== null && typeof value === 'object' && Object.keys(value).length === 0; if (value !== undefined && isEmptyObject === false) { // use as value setter const oldValue = that.value; if ((value === '' || value === null) && oldValue === null) { return null; } if (value === null) { that._triggerChangeEvent = that.validation === 'strict'; that._validate(false, null); that._triggerChangeEvent = false; that._programmaticValueIsSet = true; return; } value = value.toString(); if (value.toUpperCase() !== oldValue.toString().toUpperCase()) { if (suppressValidation === undefined) { // sets the value after validation that._triggerChangeEvent = that.validation === 'strict'; that._validate(false, value); that._triggerChangeEvent = false; } else { // sets the value without validation that._setValue(value); } that._programmaticValueIsSet = true; } else { return value; } } else { // use as value getter return that.value; } } /** * Focuses the input of the numeric text box. */ focus() { this.$.input.focus(); } /* * Private methods */ /** * Updates the internal spin buttons step object ("_spinButtonsStepObject"). */ _updateSpinButtonsStepObject() { const that = this; that._spinButtonsStepObject = that._numericProcessor.createDescriptor(that.spinButtonsStep, true); } /** * Sets the initial display of the various numeric text box components. */ _setInitialComponentDisplay() { const that = this; if (that.spinButtons === false) { that.$spinButtonsContainer.addClass('lw-hidden'); } if (that.radixDisplay === false) { that.$radixDisplayButton.addClass('lw-hidden'); } if (that.showUnit === false) { that.$unitDisplay.addClass('lw-hidden'); } } /** * Makes initial validations and adjustments to the numeric text box. */ _initialAdjustments() { const that = this; that._radixNumber = that._getRadix(that.radix); that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength); that._validatePropertyCompatibility(); that._numericProcessor.validateMinMax(true, true); that._updateSpinButtonsStepObject(); that._validate(true); that._programmaticValueIsSet = true; that._cachedInputValue = that.$.input.value; if (that._editableValue === undefined) { that._editableValue = that._cachedInputValue; } that.$.radixDisplayButton.innerHTML = that._radixPrefixes[that._radixNumber]; that.$.unitDisplay.innerHTML = that.unit; if (that.disabled) { that.$.upButton.disabled = true; that.$.downButton.disabled = true; } if (that.opened) { if (that.dropDownEnabled && !that.disabled && that.value !== null) { that._openRadix(); } else { that.opened = false; } } that.$.radixDisplayButton.setAttribute('aria-expanded', that.opened); that._setFocusable(); } /** * Validates some initial non-numeric property values. */ _validatePropertyCompatibility() { const that = this; if (that.inputFormat !== 'integer') { if (that._radixNumber !== 10) { that.error(that.localize('integerOnly', { property: 'radix' })); } if (that.radixDisplay) { that.error(that.localize('integerOnly', { property: 'radixDisplay' })); } if (that.dropDownEnabled) { that.error(that.localize('integerOnly', { property: 'dropDownEnabled' })); } if (that.wordLength !== 'int32') { that.error(that.localize('integerOnly', { property: 'wordLength' })); } } else if (that.precisionDigits !== null) { that.error(that.localize('noInteger', { property: 'precisionDigits' })); } if (that.significantDigits === null && that.precisionDigits === null) { that.significantDigits = 8; } else if (that.significantDigits !== null && that.precisionDigits !== null) { that.error(that.localize('significantPrecisionDigits')); } } /** * Validates the value of the numeric text box. */ _validate(initialValidation, programmaticValue) { const that = this; let value; if (initialValidation) { value = that.value; if (value === undefined) { if (that.nullable) { value = null; } else { value = '0'; } } } else { if (programmaticValue === undefined || (programmaticValue === null && !that.nullable)) { value = that.$.input.value; if (value === that.value && that._programmaticValueIsSet !== true) { that.$.input.value = that._cachedInputValue; return; } } else { value = programmaticValue; } } if (that.nullable && (value === null || value === '')) { that.value = null; that._number = null; that.$.input.value = ''; that._cachedInputValue = ''; that._editableValue = ''; that._disableComponents(); return; } const validationOptions = that._numericProcessor.prepareForValidation(initialValidation, programmaticValue, value); if (validationOptions === undefined) { that._disableComponents(); return; } const validNumber = that._numericProcessor.createDescriptor( validationOptions.value, true, true, (!initialValidation && programmaticValue === undefined) || that.validation === 'strict', initialValidation || programmaticValue !== undefined, validationOptions.enteredComplexNumber ); if (initialValidation) { that._number = validNumber; let renderedValue = that._renderValue(validNumber); that.value = validNumber.toString(); that.$.input.value = renderedValue; } else { that._updateValue(validNumber); } that._programmaticValueIsSet = false; that._disableComponents(); } /** * Validates the value of the numeric text box when it is not a number. */ _handleNonNumericValue(initialValidation, programmaticValue, value) { const that = this; if (that.inputFormat !== 'integer') { if (that._regexSpecial.nan.test(value)) { // 'NaN' (or a derivative) has been entered that._handleNaN(initialValidation); return; } if (that._regexSpecial.inf.test(value)) { // '(-)Inf' (or a derivative) has been entered that._handleInfinity(initialValidation, programmaticValue, value); return; } } // invalid input if (initialValidation) { let defaultValue = that._numericProcessor.createDescriptor(0); that._number = that._validateRange(defaultValue); const defaultValidValue = that._renderValue(that._number); that.value = that._number.toString(); that.$.input.value = defaultValidValue; } else { // the old value is reverted if (programmaticValue === undefined) { that.$.input.value = that._cachedInputValue; } else { const correctValue = that._number.toString(); if (that.value !== correctValue) { that.value = correctValue; } } } } /** * Handles NaN (or derivative) entered value. */ _handleNaN(initialValidation) { const that = this; that.$.input.value = 'NaN'; if (initialValidation) { that.value = NaN; that._number = NaN; } else { const oldValue = that.value; if (oldValue === null || oldValue.toString() !== 'NaN') { that.value = NaN; that._number = NaN; that._cachedInputValue = 'NaN'; that._editableValue = 'NaN'; if (that._triggerChangeEvent) { that.$.fireEvent('change', { 'value': NaN, 'oldValue': oldValue, 'radix': that._radixNumber }); } } } } /** * Handles (-)Infinity (or derivative) entered value. */ _handleInfinity(initialValidation, programmaticValue, value) { const that = this; let newInputValue, newValue; if (value.charAt(0) === '-') { if (value.charAt(1) === '') { newInputValue = '-'; } else { newInputValue = '-Inf'; } newValue = -Infinity; } else { if (value.indexOf('') !== -1) { newInputValue = ''; } else { newInputValue = 'Inf'; } newValue = Infinity; } if (newValue === -Infinity && that.min === -Infinity || newValue === Infinity && that.max === Infinity || programmaticValue !== undefined) { if (initialValidation) { that.value = newValue; that._number = newValue; that.$.input.value = newInputValue; } else { const oldValue = that.value; if (value !== newInputValue) { that.$.input.value = newInputValue; } if (oldValue !== newValue) { that.value = newValue; that._number = newValue; that._cachedInputValue = newInputValue; that._editableValue = newInputValue; if (that._triggerChangeEvent) { that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, 'radix': that._radixNumber }); } } } } else { // if -Infinity/Infinity is out of the "min"-"max" range, the value is set to "min"/"max" instead if (newValue === -Infinity) { that._validate(false, that.min); } else { that._validate(false, that.max); } } } /** * Checks if the value is within the range from min to max. */ _validateRange(numberToValidate) { const that = this; numberToValidate = that._numericProcessor.validate(numberToValidate, that._minObject, that._maxObject); return numberToValidate; } /** * Invoked when the value of a public property has been changed by the user. */ propertyChangedHandler(key, oldValue, value) { super.propertyChangedHandler(key, oldValue, value); const that = this, input = that.$.input; function handleLeadingZeros() { if (that._initialDropDownOptionsSet === true) { that._setDropDownOptions(true); } if (that._radixNumber === 2 || that._radixNumber === 16) { that._cachedInputValue = that._number.toString(that._radixNumber, that._wordLengthNumber, that.leadingZeros); that._editableValue = that._cachedInputValue; that.$.input.value = that._cachedInputValue; } } // eslint-disable-next-line if (value != oldValue) { switch (key) { case 'disabled': that._setFocusable(); if (value === true) { that.$.upButton.disabled = true; that.$.downButton.disabled = true; } else { that._disableComponents(); } break; case 'dropDownAppendTo': that._positionDetection.dropDownAppendToChangedHandler(); that.$.dropDown.removeAttribute('right-to-left'); if (that.rightToLeft && value !== null) { that.$.dropDown.setAttribute('right-to-left', ''); } break; case 'unfocusable': that._setFocusable(); break; case 'enableMouseWheelAction': case 'placeholder': case 'readonly': case 'spinButtonsDelay': case 'spinButtonsInitialDelay': break; case 'value': { if (value === '' && oldValue === null) { return; } if (value === null || value === '' || oldValue === null) { that.value = oldValue; that._triggerChangeEvent = that.validation === 'strict'; that._validate(false, value); that._triggerChangeEvent = false; that._programmaticValueIsSet = true; return; } const stringValue = value.toString(), stringOldValue = oldValue.toString(); if (stringOldValue !== stringValue) { if (stringOldValue.toUpperCase() === stringValue.toUpperCase()) { that.value = oldValue; } that.value = oldValue; that._triggerChangeEvent = that.validation === 'strict'; that._validate(false, stringValue); that._triggerChangeEvent = false; that._programmaticValueIsSet = true; } break; } case 'radix': if (that.inputFormat === 'integer') { that._changeRadix(value); } else { that.error(that.localize('integerOnly', { property: 'radix' })); } break; case 'rightToLeft': if (that.dropDownAppendTo !== null) { value ? that.$.dropDown.setAttribute('right-to-left', '') : that.$.dropDown.removeAttribute('right-to-left'); } break; case 'leadingZeros': if (that.inputFormat === 'integer' && that._number !== null) { handleLeadingZeros(); } break; case 'min': case 'max': { if (value !== null) { that[`_${key}IsNull`] = false; } that._numericProcessor.validateMinMax(key === 'min', key === 'max'); if (that.validation === 'strict') { that._triggerChangeEvent = true; that._validate(false, that.value); that._triggerChangeEvent = false; } else if (that._regexSpecial.nonNumericValue.test(that.value) === false) { const numberToValidate = that._numericProcessor.createDescriptor(that._number), validValue = that._validateRange(numberToValidate); if (that._numericProcessor.compare(that.value, validValue) === true) { that._programmaticValueIsSet = true; } } break; } case 'opened': if (value) { if (that.dropDownEnabled && !that.disabled && that.value !== null) { that._openRadix(); } else { that.opened = false; that.$.radixDisplayButton.setAttribute('aria-expanded', false); } } else { that._closeRadix(false, true); } break; case 'outputFormatString': if (value) { that._cachedInputValue = that._numberRenderer.formatNumber(that._number, value); that.$.input.value = that._cachedInputValue; } else { that._cachedInputValue = that._editableValue; that.$.input.value = that._editableValue; } break; case 'dropDownEnabled': if (value) { if (that.inputFormat !== 'integer') { that.error(that.localize('integerOnly', { property: 'dropDownEnabled' })); } if (that._initialDropDownOptionsSet === true) { that._setDropDownOptions(true); } } else if (that.opened) { that._closeRadix(true); } break; case 'spinButtons': if (value) { that.$spinButtonsContainer.removeClass('lw-hidden'); } else { that.$spinButtonsContainer.addClass('lw-hidden'); } that._refreshShape(); break; case 'spinButtonsStep': that._updateSpinButtonsStepObject(); break; case 'significantDigits': case 'precisionDigits': { if (key === 'precisionDigits' && that.inputFormat === 'integer') { that.error(that.localize('noInteger', { property: key })); } if (key === 'significantDigits' && that.precisionDigits !== null) { that.precisionDigits = null; } else if (key === 'precisionDigits' && that.significantDigits !== null) { that.significantDigits = null; } if (that._regexSpecial.nonNumericValue.test(that.value) === false) { const renderedValue = that._renderValue(that._number); input.value = renderedValue; } break; } case 'decimalSeparator': { that._numberRenderer.localizationObject.decimalseparator = that.decimalSeparator; const numericValue = that._discardDecimalSeparator(input.value, oldValue), valueWithNewSeparator = that._applyDecimalSeparator(numericValue), editableValueWithNewSeparator = that._applyDecimalSeparator(that._discardDecimalSeparator(that._editableValue, oldValue)); input.value = valueWithNewSeparator; that._editableValue = editableValueWithNewSeparator; break; } case 'spinButtonsPosition': if (value === 'left') { that.$.container.insertBefore(that.$.spinButtonsContainer, that.$.label.nextElementSibling); } else { that.$.container.insertBefore(that.$.spinButtonsContainer, that.$.dropDown); } that._refreshShape(); break; case 'wordLength': that._wordLengthNumber = that._numericProcessor.getWordLength(value); if (that.inputFormat === 'integer') { that._numericProcessor.validateMinMax(true, true); if (that._number !== null) { let validValue = that._validateRange(new LW.Utilities.BigNumber(that._number)); that._updateValue(validValue); if (that.leadingZeros) { handleLeadingZeros(); } } } break; case 'radixDisplay': if (value) { if (that.inputFormat !== 'integer') { that.error(that.localize('integerOnly', { property: 'radixDisplay' })); } that.$radixDisplayButton.removeClass('lw-hidden'); } else { that.$radixDisplayButton.addClass('lw-hidden'); } that._refreshShape(); break; case 'radixDisplayPosition': if (value === 'left') { that.$.container.insertBefore(that.$.radixDisplayButton, that.$.input); } else { that.$.container.insertBefore(that.$.radixDisplayButton, that.$.unitDisplay.nextElementSibling); } that._refreshShape(); break; case 'inputFormat': that._changeInputFormat(oldValue, value); break; case 'showUnit': if (value) { that.$unitDisplay.removeClass('lw-hidden'); } else { that.$unitDisplay.addClass('lw-hidden'); } that._refreshShape(); break; case 'unit': that.$.unitDisplay.innerHTML = value; break; case 'scientificNotation': { if (that._regexSpecial.nonNumericValue.test(that.value) === false) { const renderedValue = that._renderValue(that._number); input.value = renderedValue; } break; } case 'locale': case 'messages': case 'showDropDownValues': if (that.opened) { that._setDropDownOptions(); } else { that._initialDropDownOptionsSet = false; } break; case 'nullable': if (oldValue === true && that.value === null) { that._validate(false, '0'); } break; case 'validation': if (value === 'strict') { that._triggerChangeEvent = true; that._validate(false, that.value); that._triggerChangeEvent = false; } break; } } else if (typeof value !== 'string' && typeof oldValue === 'string') { that[key] = oldValue; } that._cachedInputValue = input.value; } /** * Changes the input format. */ _changeInputFormat(oldFormat, newFormat) { const that = this; that._numericProcessor = new LW.Utilities.NumericProcessor(that, 'inputFormat'); if (oldFormat === 'complex') { // 'complex' -> 'integer'/'floatingPoint' that._changeFromComplexInputFormat(newFormat); return; } if (newFormat === 'integer' && oldFormat === 'floatingPoint') { // 'floatingPoint' -> 'integer' that._changeFromFloatingPointToIntegerInputFormat(); } if (newFormat === 'floatingPoint' && oldFormat === 'integer') { // 'integer' -> 'floatingPoint' that._changeFromIntegerToFloatingPointInputFormat(); } if (newFormat === 'complex') { // 'integer'/'floatingPoint' -> 'complex' that._changeToComplexInputFormat(oldFormat); } that._updateSpinButtonsStepObject(); if (that.value !== null) { that._inputFormatChangedFlag = true; that._validate(undefined, that._number.toString()); that._inputFormatChangedFlag = false; } } /** * Changes the input format from 'complex' to 'integer' or 'floatingPoint'. */ _changeFromComplexInputFormat(newFormat) { const that = this; that.spinButtonsStep = that._spinButtonsStepObject.realPart; that._updateSpinButtonsStepObject(); if (newFormat === 'integer') { if (that.min === -Infinity) { that.min = null; } else { that.min = that._minObject.realPart; } if (that.max === Infinity) { that.max = null; } else { that.max = that._maxObject.realPart; } } else { if (that.min !== -Infinity) { that.min = that._minObject.realPart; } if (that.max !== Infinity) { that.max = that._maxObject.realPart; } } that._numericProcessor.validateMinMax(true, true); if (that.value !== null) { that._inputFormatChangedFlag = true; that._validate(undefined, that._number.realPart.toString()); that._inputFormatChangedFlag = false; } } /** * Changes the input format from 'floatingPoint' to 'integer'. */ _changeFromFloatingPointToIntegerInputFormat() { const that = this; if (that.min === -Infinity) { that.min = null; } if (that.max === Infinity) { that.max = null; } that._numericProcessor.validateMinMax(true, true); } /** * Changes the input format from 'integer' to 'floatingPoint'. */ _changeFromIntegerToFloatingPointInputFormat() { const that = this; if (that.radixDisplay) { that.radixDisplay = false; that.$radixDisplayButton.addClass('lw-hidden'); } if (that._radixNumber !== 10) { that.radix = 10; that._radixNumber = 10; } if (that._minIsNull) { that.min = -Infinity; that._minObject = -Infinity; } else { that._minObject = parseFloat(that._minObject.toString()); } if (that._maxIsNull) { that.max = Infinity; that._maxObject = Infinity; } else { that._maxObject = parseFloat(that._maxObject.toString()); } if (that.dropDownEnabled) { that.dropDownEnabled = false; } } /** * Changes the input format from 'integer' to 'floatingPoint'. */ _changeToComplexInputFormat(oldFormat) { const that = this; if (oldFormat === 'integer') { if (that.radixDisplay) { that.radixDisplay = false; that.$radixDisplayButton.addClass('lw-hidden'); } if (that._minIsNull) { that.min = null; } if (that._maxIsNull) { that.max = null; } if (that.dropDownEnabled) { that.dropDownEnabled = false; } } that._numericProcessor.validateMinMax(that.min !== -Infinity, that.max !== Infinity); } /** * Updates the value of the numeric text box input and the "value" property and triggers the respective events. */ _updateValue(value) { const that = this, enteredValue = that.$.input.value, newValue = value.toString(that._radixNumber, that._wordLengthNumber, that.leadingZeros); if (enteredValue !== newValue || enteredValue !== that._cachedInputValue) { const renderedValue = that._renderValue(value), oldValue = that.value, newValueIsNotNumeric = that._regexSpecial.nonNumericValue.test(newValue); that.$.input.value = renderedValue; that._cachedInputValue = renderedValue; if (that._inputFormatChangedFlag || newValueIsNotNumeric && renderedValue !== oldValue || newValueIsNotNumeric === false && that._numericProcessor.compare(value, that._number)) { that._number = that._numericProcessor.createDescriptor(value); const actualNewValue = that._number.toString(); that.value = actualNewValue; that._setDropDownOptions(true); if (that._triggerChangeEvent) { that.$.fireEvent('change', { 'value': actualNewValue, 'oldValue': oldValue, 'radix': that._radixNumber }); } } } else { that.value = that._number.toString(); } } /** * Sets a decimal numeric value to the numeric text box without any validation. */ _setValue(value) { const that = this; that.value = value; that.$.input.value = value; that._number = that._numericProcessor.createDescriptor(value, true); that._setDropDownOptions(true); } /** * Changes the radix (numeral system). */ _changeRadix(radix) { const that = this, newRadix = that._getRadix(radix), oldRadix = that.radix; if (newRadix === that._radixNumber) { return; } that.radix = radix; that._radixNumber = newRadix; const input = that.$.input, oldValue = input.value; let newValue, renderedValue; if (that.value !== null) { newValue = that._number.toString(newRadix, that._wordLengthNumber, that.leadingZeros); renderedValue = that._renderValue(newValue); } else { renderedValue = ''; } input.value = renderedValue; that._cachedInputValue = renderedValue; that.$.radixDisplayButton.innerHTML = that._radixPrefixes[newRadix]; that.$.fireEvent('radixChange', { 'radix': radix, 'oldRadix': oldRadix, 'displayedValue': renderedValue, 'oldDisplayedValue': oldValue }); } /** * Opens the radix selection drop down. */ _openRadix() { const that = this, openingEvent = that.$.fireEvent('opening'); if (openingEvent.defaultPrevented) { that.opened = false; return; } if (that._initialDropDownOptionsSet === false) { that._setDropDownOptions(); that._initialDropDownOptionsSet = true; } if (that._dropDownParent !== null) { that.$.dropDown.style.width = that.offsetWidth + 'px'; } that.$radixDisplayButton.addClass('lw-numeric-text-box-pressed-component'); that.$dropDown.removeClass('lw-visibility-hidden'); that.$.dropDown.style.marginTop = null; that.opened = true; that._positionDetection.positionDropDown(); const windowHeight = window.devicePixelRatio === 1 ? document.documentElement.clientHeight : window.innerHeight, dropDownBoundingRect = that.$.dropDown.getBoundingClientRect(), verticalCorrection = windowHeight - dropDownBoundingRect.top - that.$.dropDown.offsetHeight - parseFloat(getComputedStyle(that.$.dropDown).marginBottom); if (verticalCorrection < 0) { that.$.dropDown.style.marginTop = verticalCorrection + 'px'; } that.$.fireEvent('open', { dropDown: that.$.dropDown }); that.$.radixDisplayButton.setAttribute('aria-expanded', true); } /** * Closes the radix selection drop down. */ _closeRadix(forceClose, closedProgrammatically) { const that = this; if (!that.opened && !closedProgrammatically) { return; } const closingEvent = that.$.fireEvent('closing'); if (closingEvent.defaultPrevented && !forceClose) { that.opened = true; return; } that.$radixDisplayButton.removeClass('lw-numeric-text-box-pressed-component'); that.$dropDown.addClass('lw-visibility-hidden'); that.opened = false; that.$.fireEvent('close', { dropDown: that.$.dropDown }); that.$.radixDisplayButton.setAttribute('aria-expanded', false); } /** * Checks if left button is pressed. */ _isLeftButtonPressed(event) { const buttons = event.buttons === 0 || event.which === 1; return event.detail.buttons === 1 || buttons; } /** * Checks if incrementation and decrementation are allowed */ _isIncrementOrDecrementAllowed() { const that = this; return !that.disabled && !that.readonly && that._regexSpecial.nonNumericValue.test(that.$.input.value) === false; } /** * Up button mousedown event handler. */ _upButtonClickHandler(event) { const that = this, isLeftButton = that._isLeftButtonPressed(event); if (isLeftButton && that._isIncrementOrDecrementAllowed()) { if (!that._up) { that.$upButton.addClass('lw-numeric-text-box-pressed-component'); } that._incrementOrDecrement('add'); } } /** * Down button mousedown event handler. */ _downButtonClickHandler(event) { const that = this, isLeftButton = that._isLeftButtonPressed(event); if (isLeftButton && that._isIncrementOrDecrementAllowed()) { if (!that._up) { that.$downButton.addClass('lw-numeric-text-box-pressed-component'); } that._incrementOrDecrement('subtract'); } } /** * Document mousedown event handler. */ _documentMousedownHandler(event) { const that = this; that._up = false; if (!that.opened) { return; } let target = event.originalEvent.target; if (that.shadowRoot || that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; } if (!(that.shadowRoot || that).contains(target) && !that.$.dropDown.contains(target)) { that._closeRadix(); } } /** * Document mouseup event handler. */ _documentMouseupHandler() { const that = this; that._up = true; that.$upButton.removeClass('lw-numeric-text-box-pressed-component'); that.$downButton.removeClass('lw-numeric-text-box-pressed-component'); } /** * Radix display button click event handler. */ _radixDisplayButtonClickHandler() { const that = this; if (that.dropDownEnabled && !that.disabled && that.value !== null) { if (that.opened) { that._closeRadix(); } else { that._openRadix(); } } } /** * Dropdown item click event handler. */ _dropDownItemClickHandler(event) { if (event.target.$.hasClass('lw-list-item')) { const that = this; let radix = event.target.getAttribute('data-value'); that._changeRadix(parseInt(radix, 10)); that._closeRadix(); } } /** * Spin button, radix display button and dropdown item mouseenter and mouseleave event handler. */ _mouseenterMouseleaveHandler(event) { const that = this; if (event.target === that.$.dropDown || that.disabled || that.readonly) { return; } if (event.type === 'mouseenter') { event.target.setAttribute('hover', ''); } else { event.target.removeAttribute('hover'); } } /** * Input keydown event handler. */ _inputKeydownHandler(event) { const that = this, keyCode = !event.charCode ? event.which : event.charCode; if (keyCode === 40 && that._isIncrementOrDecrementAllowed()) { // decrement when Down Arrow is pressed that._incrementOrDecrement('subtract'); } else if (keyCode === 38 && that._isIncrementOrDecrementAllowed()) { // increment when Up Arrow is pressed that._incrementOrDecrement('add'); } that._keydownInfo = { value: that.$.input.value, specialKey: event.altKey || event.ctrlKey || event.shiftKey }; } /** * Input keyup event handler. */ _inputKeyupHandler(event) { const that = this; if (event.keyCode === 13) { // when Enter is pressed, validation occurs that._suppressBlurEvent = true; if (that.$.input.value !== that._cachedInputValue) { that._triggerChangeEvent = true; that._validate(); that._triggerChangeEvent = false; that.$.input.blur(); } } else if (event.keyCode === 27) { // when Escape is pressed, changes are discarded that.$.input.value = that._editableValue; } else { const inputValue = that.$.input.value; if (inputValue !== '' && that._regex[that._radixNumber].test(inputValue)) { that.$.upButton.disabled = false; that.$.downButton.disabled = false; } else if (inputValue === '') { that.$.upButton.disabled = true; that.$.downButton.disabled = true; } if (that._keydownInfo && that._keydownInfo.value !== inputValue && !that._keydownInfo.specialKey && !event.altKey && !event.ctrlKey && !event.shiftKey && event.key !== 'Control') { that.$.fireEvent('changing', { 'currentValue': inputValue, 'validValue': that.value, 'radix': that._radixNumber }); } } event.preventDefault(); } /** * Input blur event handler. */ _inputBlurHandler() { const that = this; if (that._suppressBlurEvent === true) { // suppresses validation because it was already handled in "_incrementOrDecrement" function that._suppressBlurEvent = false; if (that._formattedValue) { that._cachedInputValue = that._formattedValue; that.$.input.value = that._formattedValue; delete that._formattedValue; } } else if (that.$.input.value !== that._editableValue) { that._triggerChangeEvent = true; that._validate(); that._triggerChangeEvent = false; } else { that.$.input.value = that._cachedInputValue; } if (that.radixDisplay) { that.$.radixDisplayButton.removeAttribute('focus'); } if (that.opened) { that._closeRadix(); } if (that.spinButtons) { that.$.spinButtonsContainer.removeAttribute('focus'); } if (that.showUnit) { that.$.unitDisplay.removeAttribute('focus'); } that.removeAttribute('focus'); that.$.fireEvent('blur'); } /** * Input focus event handler. */ _inputFocusHandler() { const that = this; if (that.spinButtons) { that.$.spinButtonsContainer.setAttribute('focus', ''); } if (that.radixDisplay) { that.$.radixDisplayButton.setAttribute('focus', ''); } if (that.showUnit) { that.$.unitDisplay.setAttribute('focus', ''); } if (that.opened) { that._closeRadix(); } that.setAttribute('focus', ''); if (that.outputFormatString) { that.$.input.value = that._editableValue; } that.$.fireEvent('focus'); } /** * Input change event handler. */ _inputChangeHandler(event) { event.stopPropagation(); event.preventDefault(); } /** * Input paste event handler. */ _inputPasteHandler() { const that = this; requestAnimationFrame(() => that.$.fireEvent('changing', { 'currentValue': that.$.input.value, 'validValue': that.value, 'radix': that._radixNumber })); } /** * Input wheel event handler. */ _inputWheelHandler(event) { const that = this, activeElement = that.shadowRoot ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement; if (that.$.input === activeElement && that.enableMouseWheelAction && that._isIncrementOrDecrementAllowed()) { event.stopPropagation(); event.preventDefault(); if (event.wheelDelta > 0) { that._incrementOrDecrement('add'); } else { that._incrementOrDecrement('subtract'); } } } /** * Gets the internal numeric radix based on the "radix" property. */ _getRadix(radix) { switch (radix.toString()) { case '10': case 'decimal': return 10; case '2': case 'binary': return 2; case '8': case 'octal': return 8; case '16': case 'hexadecimal': return 16; } } /** * Sets the dropdown list radix options. */ _setDropDownOptions(updatedValues) { const that = this; if (that.dropDownEnabled === false || that._number === null) { return; } if (!that.showDropDownValues) { if (updatedValues) { return; } that.$.dropDownItem2.innerHTML = that.localize('binary'); that.$.dropDownItem8.innerHTML = that.localize('octal'); that.$.dropDownItem10.innerHTML = that.localize('decimal'); that.$.dropDownItem16.innerHTML = that.localize('hexadecimal'); return; } const wordLength = that._wordLengthNumber, leadingZeros = that.leadingZeros; that.$.dropDownItem2.innerHTML = `${that._number.toString(2, wordLength, leadingZeros)} (${that.localize('binary')})`; that.$.dropDownItem8.innerHTML = `${that._number.toString(8, wordLength)} (${that.localize('octal')})`; that.$.dropDownItem10.innerHTML = `${that._renderValue(that._number.toString(10, wordLength), true)} (${that.localize('decimal')})`; that.$.dropDownItem16.innerHTML = `${that._number.toString(16, wordLength, leadingZeros)} (${that.localize('hexadecimal')})`; } /** * Increments or decrements the number in the numeric text box input. */ _incrementOrDecrement(func) { const that = this, activeElement = that.shadowRoot ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement; let cachedInputValue = that._cachedInputValue; if (that.$.input === activeElement) { cachedInputValue = that._editableValue; that._suppressBlurEvent = true; } if (that.$.input.value !== cachedInputValue || that._programmaticValueIsSet && that.validation === 'interaction') { // validates the value before incrementing or decrementing that._triggerChangeEvent = true; that._validate(); that._triggerChangeEvent = false; if (that._isIncrementOrDecrementAllowed() === false) { return; } } const currentNumber = that._numericProcessor.incrementDecrement(that._number, func, that._spinButtonsStepObject), validNumber = that._validateRange(currentNumber); that._triggerChangeEvent = true; that._updateValue(validNumber); that._triggerChangeEvent = false; } /** * Returns a BigNumber object from a binary, octal, decimal or hexadecimal value. */ _toBigNumberDecimal(number, radix) { const that = this; let result; if (radix === 10) { result = new LW.Utilities.BigNumber(number); } else { if (that._unsigned || that._isNegative(number, radix) === false) { if (that._wordLengthNumber < 64) { result = parseInt(number, radix); result = new LW.Utilities.BigNumber(result); } else { result = that._getBigNumberFrom64BitBinOctHex(number, radix); } } else { result = that._getNegativeDecimal(number, radix); result = new LW.Utilities.BigNumber(result); } } return result; } /** * Checks if the passed binary, octal or hexadecimal value is negative based on the word length. */ _isNegative(value, radix) { const that = this, valueLength = value.length, firstCharacter = value.charAt(0).toLowerCase(); if (radix === 2) { return valueLength === that._wordLengthNumber && firstCharacter === '1'; } else if (radix === 8) { switch (that._wordLengthNumber) { case 8: return valueLength === 3 && (firstCharacter === '2' || firstCharacter === '3'); case 16: return valueLength === 5 && firstCharacter === '1'; case 32: return valueLength === 11 && (firstCharacter === '2' || firstCharacter === '3'); case 64: return valueLength === 22 && firstCharacter === '1'; } } else { return valueLength === that._wordLengthNumber / 4 && ['8', '9', 'a', 'b', 'c', 'd', 'e', 'f'].indexOf(firstCharacter) !== -1; } } /** * Returns a BigNumber object from a positive binary, octal or hexadecimal value. */ _getBigNumberFrom64BitBinOctHex(number, radix) { let result = new LW.Utilities.BigNumber(0); for (let i = number.length - 1; i >= 0; i--) { let current = new LW.Utilities.BigNumber(parseInt(number.charAt(i), radix)); result = result.add((current.multiply(new LW.Utilities.BigNumber(radix).pow(number.length - 1 - i)))); } return result; } /** * Returns a BigNumber object from a negative binary, octal or hexadecimal value. */ _getNegativeDecimal(value, radix) { const that = this; let negativeBinary = value; if (radix === 8) { let threeBits = []; for (let i = 0; i < value.length; i++) { let threeBit = parseInt(value.charAt(i), 8).toString(2); while (threeBit.length !== 3) { threeBit = `0${threeBit}`; } threeBits.push(threeBit); } negativeBinary = threeBits.join(''); while (negativeBinary.charAt(0) === '0') { negativeBinary = negativeBinary.slice(1); } } else if (radix === 16) { let bytes = []; for (let j = 0; j < value.length; j++) { let currentByte = parseInt(value.charAt(j), 16).toString(2); while (currentByte.length !== 4) { currentByte = `0${currentByte}`; } bytes.push(currentByte); } negativeBinary = bytes.join(''); } let negativeDecimal = negativeBinary.replace(/0/g, 'a'); negativeDecimal = negativeDecimal.replace(/1/g, 'b'); negativeDecimal = negativeDecimal.replace(/a/g, '1'); negativeDecimal = negativeDecimal.replace(/b/g, '0'); if (this._wordLengthNumber < 64) { negativeDecimal = (parseInt(negativeDecimal, 2) + 1) * -1; } else { negativeDecimal = that._getBigNumberFrom64BitBinOctHex(negativeDecimal, radix); negativeDecimal = negativeDecimal.add(1).negate(); } return negativeDecimal; } /** * Replaces a custom decimal separator with the default one. */ _discardDecimalSeparator(value, separator) { const that = this; if (separator === undefined) { separator = that.decimalSeparator; } if (separator !== '.' && value !== Infinity && value !== -Infinity) { let decimalSeparatorRegExp = new RegExp(separator, 'g'); return value.replace(decimalSeparatorRegExp, '.'); } else { return value; } } /** * Applies a custom decimal separator. */ _applyDecimalSeparator(value) { const that = this; if (typeof value !== 'string') { value = value.toString(); } if (that.decimalSeparator !== '.') { value = value.replace(/\./g, that.decimalSeparator); } return value; } /** * Applies the scientific notation, significant digits, precision digits and decimal separator settings. */ _renderValue(renderedValue, valueInDropDown) { const that = this, value = renderedValue, ignoreRadixNumber = that._radixNumber === 10 || valueInDropDown === true; renderedValue = that._numericProcessor.render(renderedValue, ignoreRadixNumber); // decimal separator if (that.decimalSeparator !== '.' && ignoreRadixNumber) { renderedValue = that._applyDecimalSeparator(renderedValue); } if (valueInDropDown !== true) { that._editableValue = renderedValue; if (that.outputFormatString && that._radixNumber === 10) { const activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement, formattedValue = that._numberRenderer.formatNumber(value, that.outputFormatString); if (activeElement !== that.$.input) { return formattedValue; } that._formattedValue = formattedValue; } } return renderedValue; } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.$.input.tabIndex = -1; return; } that.$.input.removeAttribute('tabindex'); } /** * Disables or enables components. */ _disableComponents() { const that = this; if (that.disabled) { return; } const value = that.value; if (value === null || value.toString() === 'NaN' || Math.abs(value) === Infinity) { that.$.upButton.disabled = true; that.$.downButton.disabled = true; } else { that.$.upButton.disabled = false; that.$.downButton.disabled = false; } } /** * Resize handler. */ _resizeHandler() { const that = this; if (that.opened) { that._closeRadix(true); } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Pager custom element. */ LW('lw-pager', class Pager extends LW.BaseElement { // Pager's properties. static get properties() { return { 'autoEllipsis': { value: 'none', type: 'string', // After - displays AutoEllipsis only after the Numeric Buttons. // Before - displays AutoEllipsis only before the Numeric Buttons. // Both - displays AutoEllipsis before and after the Numeric Buttons. // None - doesn't display AutoEllipsis. allowedValues: ['none', 'before', 'after', 'both'] }, 'messages': { value: { 'en': { 'firstButton': 'First', 'lastButton': 'Last', 'previousButton': 'Previous', 'nextButton': 'Next', 'navigateToLabel': 'Go to:', 'pageSizeLabel': 'Show:', 'navigateToInputPlaceholder': '', 'ellipsis': '...', 'summaryString': 'of', 'summaryPrefix': 'of', 'summarySuffix': '' } }, type: 'object', extend: true }, 'navigationButtonsPosition': { value: 'both', allowedValues: ['near', 'far', 'both'], type: 'string' }, 'navigationInputPosition': { value: 'far', allowedValues: ['near', 'far'], type: 'string' }, 'pageIndex': { value: 0, type: 'number' }, 'pageIndexSelectors': { value: 0, type: 'any' }, 'pagesCount': { value: 100, type: 'number' }, 'pageSize': { value: 10, type: 'number' }, 'pageSizeSelectorPosition': { value: 'far', allowedValues: ['near', 'far'], type: 'string' }, 'pageSizeSelectorDataSource': { value: [10, 25, 50], type: 'array' }, 'showPrevNextNavigationButtons': { value: false, type: 'boolean' }, 'showFirstLastNavigationButtons': { value: false, type: 'boolean' }, 'showNavigationButtonLabels': { value: false, type: 'boolean' }, 'showNavigationInput': { value: false, type: 'boolean' }, 'showSummary': { value: false, type: 'boolean' }, 'showPageSizeSelector': { value: false, type: 'boolean' }, 'showPageIndexSelectors': { value: false, type: 'boolean' }, 'summaryPosition': { value: 'far', allowedValues: ['near', 'far'], type: 'string' }, 'totalRecords': { value: null, type: 'int?' } }; } /** * Pager's event listeners. */ static get listeners() { return { 'click': '_navigationButtonsClickHandler', 'nextEllipsisButton.click': '_nextEllipsisButtonClickHandler', 'previousEllipsisButton.click': '_previousEllipsisButtonClickHandler', 'down': '_navigationButtonsDownHandler', 'navigateToInput.change': '_navigateToInputChangeHandler', 'nextButton.pointerenter': '_updateInBoundsFlag', 'nextButton.pointerleave': '_updateInBoundsFlag', 'pageIndexSelectorsContainer.click': '_pageIndexSelectorsContainerClickHandler', 'pageSizeSelector.change': '_pageSizeSelectorChangeHandler', 'previousButton.pointerenter': '_updateInBoundsFlag', 'previousButton.pointerleave': '_updateInBoundsFlag', 'keydown': '_keyDownHandler', 'resize': '_resizeHandler', 'document.up': '_stopRepeat' }; } static get requires() { return { 'LW.DropDownList': 'lw.dropdownlist.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.dropdown.css', 'lw.dropdownlist.css', 'lw.pager.css' ] } /** * Pager's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="nearButtonsContainer" class="lw-pager-near-buttons-container" role="presentation"> <div id="firstButton" class="lw-first-button lw-pager-button lw-unselectable" role="button" aria-label="First"></div> <div id="previousButton" class="lw-previous-page-button lw-pager-button lw-unselectable" role="button" aria-label="Previous"></div> </div> <div id="middleButtonsContainer" class="lw-pager-middle-buttons-container" role="presentation"> <span id="previousEllipsisButton" class="lw-previous-ellipsis-button lw-pager-page-index-selector" role="button" aria-label="Previous group of pages"></span> <div id="pageIndexSelectorsContainer" tabindex="0" class="lw-pager-page-index-selectors-container" role="list"></div> <span id="nextEllipsisButton" class="lw-next-ellipsis-button lw-pager-page-index-selector" role="button" aria-label="Next group of pages"</span> </div> <div id="farButtonsContainer" class="lw-pager-far-buttons-container" role="presentation"> <div id="nextButton" class="lw-next-page-button lw-pager-button lw-unselectable" role="button" aria-label="Next"></div> <div id="lastButton" class="lw-last-button lw-pager-button lw-unselectable" role="button" aria-label="Last"></div> </div> <div id="pagerInputAndLabelContainer" class="lw-pager-input-and-label-container" role="presentation"> <span id="navigateToLabel" class="lw-pager-label"></span> <input type="text" id="navigateToInput" class="lw-pager-input lw-input" /> </div> <div id="pagerSizeSelectorAndLabelContainer" class="lw-pager-size-selector-and-label-container"> <span id="pageSizeLabel" class="lw-pager-label"></span> <lw-drop-down-list id="pageSizeSelector" class="lw-page-size-selector" animation="[[animation]]" data-source="[[pageSizeSelectorDataSource]]" right-to-left="[[rightToLeft]]" drop-down-height="auto" selection-mode="one" selected-indexes=[0] disabled="[[disabled]]"> </lw-drop-down-list> </div> <span id="pagerSummaryContainer" class="lw-pager-summary-container lw-pager-label"></span> </div>`; } /** * Called when the element is ready. */ ready() { super.ready(); } render() { const that = this; if (!that.$.navigateToLabel.id) { that.$.navigateToLabel.id = that.id + 'NavigateToLabel'; } if (!that.$.pageSizeLabel.id) { that.$.pageSizeLabel.id = that.id + 'PageSizeLabel'; } if (!that.$.pagerSummaryContainer.id) { that.$.pagerSummaryContainer.id = that.id + 'SummaryContainer'; } that.setAttribute('role', 'navigation'); that.setAttribute('aria-labelledby', that.$.pagerSummaryContainer.id); that.$.navigateToInput.setAttribute('aria-labelledby', that.$.navigateToLabel.id); that.$.pageSizeSelector.setAttribute('aria-labelledby', that.$.pageSizeLabel.id); that._render(); super.render(); } refresh() { const that = this; that._render(); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'navigationButtonsPosition': that._renderButtons(); return; case 'navigationInputPosition': case 'pageSizeSelectorPosition': case 'summaryPosition': case 'totalRecords': that._renderSettings(); return; } that._render(); } /** * Moves to the next page. */ next() { const that = this; that.navigateTo(that.pageIndex + 1); } /** * Moves to the previous page. */ prev() { const that = this; that.navigateTo(that.pageIndex - 1); } beginUpdate() { const that = this; that._updating = true; } endUpdate() { const that = this; that._updating = false; that._render(); } _render() { const that = this; if (that._updating) { return; } that.$.navigateToInput.value = (1 + that.pageIndex).toString(); that._renderButtons(); that._renderPageIndexSelectors(); that._renderSettings(); that._renderVisibility(); that._localize(); if (that.$.pageSizeSelector && that.showPageSizeSelector) { const index = that.pageSizeSelectorDataSource.indexOf(that.pageSize); if (index >= 0) { that.$.pageSizeSelector.selectedIndexes = [index]; } } } _resizeHandler() { const that = this; that._renderVisibility(); } _renderVisibility() { const that = this; const pagerWidth = that.offsetWidth - 20; that._pageIndexSelectorsVisibleCount = that._pageIndexSelectorsCount; if (that.showSummary) { that.$pagerSummaryContainer.removeClass('lw-hidden'); } else { that.$pagerSummaryContainer.addClass('lw-hidden'); } if (that.showPageIndexSelectors) { that.$middleButtonsContainer.removeClass('lw-hidden'); } else { that.$middleButtonsContainer.addClass('lw-hidden'); } if (that.showNavigationInput) { that.$navigateToLabel.removeClass('lw-hidden'); that.$navigateToInput.removeClass('lw-hidden'); } else { that.$navigateToLabel.addClass('lw-hidden'); that.$navigateToInput.addClass('lw-hidden'); } if (that.showPageSizeSelector) { that.$pageSizeLabel.removeClass('lw-hidden'); that.$pageSizeSelector.removeClass('lw-hidden'); } else { that.$pageSizeLabel.addClass('lw-hidden'); that.$pageSizeSelector.addClass('lw-hidden'); } if (that.showFirstLastNavigationButtons) { that.$firstButton.removeClass('lw-hidden'); that.$lastButton.removeClass('lw-hidden'); } else { that.$firstButton.addClass('lw-hidden'); that.$lastButton.addClass('lw-hidden'); } if (that.showPrevNextNavigationButtons) { that.$previousButton.removeClass('lw-hidden'); that.$nextButton.removeClass('lw-hidden'); } else { that.$previousButton.addClass('lw-hidden'); that.$nextButton.addClass('lw-hidden'); } that.$previousEllipsisButton.addClass('lw-hidden'); that.$nextEllipsisButton.addClass('lw-hidden'); if (that.autoEllipsis !== 'after' && that.autoEllipsis !== 'none' && that.pageIndex >= that._pageIndexSelectorsCount) { that.$previousEllipsisButton.removeClass('lw-hidden'); } if (that.autoEllipsis !== 'before' && that.autoEllipsis !== 'none' && that.pageIndex < that.pagesCount - that._pageIndexSelectorsCount) { that.$nextEllipsisButton.removeClass('lw-hidden'); } for (let i = 0; i < that._pageIndexSelectorsCount; i++) { if (!that.$.pageIndexSelectorsContainer.children[i]) { break; } that.$.pageIndexSelectorsContainer.children[i].classList.remove('lw-hidden'); } const pagerSummaryWidth = that.$.pagerSummaryContainer.offsetWidth ? Math.max(100, that.$.pagerSummaryContainer.offsetWidth) : 0; let totalWidth = that.$.nearButtonsContainer.offsetWidth + that.$.middleButtonsContainer.offsetWidth + that.$.farButtonsContainer.offsetWidth + pagerSummaryWidth + that.$.pagerInputAndLabelContainer.offsetWidth + that.$.pagerSizeSelectorAndLabelContainer.offsetWidth; if (totalWidth > 0 && totalWidth > pagerWidth) { totalWidth -= that.$.pagerSummaryContainer.offsetWidth; // hides summary. that.$pagerSummaryContainer.addClass('lw-hidden'); if (totalWidth > pagerWidth) { totalWidth -= that.$.navigateToLabel.offsetWidth; totalWidth -= that.$.navigateToInput.offsetWidth; // hides navigation input and label. that.$navigateToLabel.addClass('lw-hidden'); that.$navigateToInput.addClass('lw-hidden'); if (totalWidth > pagerWidth) { totalWidth -= that.$.pageSizeLabel.offsetWidth; totalWidth -= that.$.pageSizeSelector.offsetWidth; // hides page size selector and label. that.$pageSizeLabel.addClass('lw-hidden'); that.$pageSizeSelector.addClass('lw-hidden'); if (totalWidth > pagerWidth) { that.$previousEllipsisButton.addClass('lw-hidden'); that.$nextEllipsisButton.addClass('lw-hidden'); totalWidth -= that.$.previousEllipsisButton.offsetWidth; totalWidth -= that.$.nextEllipsisButton.offsetWidth; for (let i = that._pageIndexSelectorsCount - 1; i >= 0; i--) { const pageIndexSelector = that.$.pageIndexSelectorsContainer.children[i]; if (totalWidth < pagerWidth || !pageIndexSelector) { break; } that._pageIndexSelectorsVisibleCount--; totalWidth -= pageIndexSelector.offsetWidth; if (pageIndexSelector.hasAttribute('selected')) { continue; } pageIndexSelector.classList.add('lw-hidden'); } } if (totalWidth > pagerWidth && that.showFirstLastNavigationButtons) { that.$firstButton.addClass('lw-hidden'); that.$lastButton.addClass('lw-hidden'); } } } } } _renderSettings() { const that = this, totalRecords = that.totalRecords; let summaryStart = that.pageIndex * that.pageSize; let summaryEnd = (that.pageIndex + 1) * that.pageSize; let totalSummaryEnd = that.pagesCount * that.pageSize; if (totalRecords !== null) { if (summaryEnd === totalSummaryEnd) { summaryEnd = totalRecords; } totalSummaryEnd = totalRecords; if (totalRecords === 0) { summaryStart = -1; } } that.$pagerSummaryContainer.removeClass('near'); that.$pagerSizeSelectorAndLabelContainer.removeClass('near'); that.$pagerInputAndLabelContainer.removeClass('near'); if (that.summaryPosition === 'near') { that.$pagerSummaryContainer.addClass('near'); } if (that.pageSizeSelectorPosition === 'near') { that.$pagerSizeSelectorAndLabelContainer.addClass('near'); } if (that.navigationInputPosition === 'near') { that.$pagerInputAndLabelContainer.addClass('near'); } that.$.pagerSummaryContainer.innerHTML = '<span class="lw-summary-start" role="presentation">' + (1 + summaryStart) + '</span> <span class="lw-summary-hyphen" role="presentation">-</span> <span class="lw-summary-end" role="presentation">' + (summaryEnd) + '</span>' + '<span class="lw-summary-prefix" role="presentation">' + that.localize('summaryPrefix') + '</span> <span class="lw-summary-total-end" role="presentation">' + totalSummaryEnd + '</span> <span class="lw-summary-suffix" role="presentation">' + that.localize('summarySuffix') + '</span>'; } get _pageIndexSelectorsCount() { const that = this; let pageIndexSelectorsCount = parseInt(that.pageIndexSelectors); if (Array.isArray(that.pageIndexSelectors)) { pageIndexSelectorsCount = that.pageIndexSelectors.length; } return pageIndexSelectorsCount; } /** * Creates page with pageIndexSelectors, based on pageIndexSelectors and pageIndexSelectors-per-page properties. */ _renderPageIndexSelectors() { const that = this; if (that.pageIndex < 0 || that.pageIndex >= that.pagesCount) { that.$.pageIndexSelectorsContainer.innerHTML = ''; return; } that.$.pageIndexSelectorsContainer.innerHTML = ''; let isArray = false; if (Array.isArray(that.pageIndexSelectors)) { isArray = true; } let pageIndexSelectorStartIndex = Math.floor(that.pageIndex / that._pageIndexSelectorsCount) * that._pageIndexSelectorsCount; let pageIndexSelectorEndIndex = Math.min(that.pagesCount, pageIndexSelectorStartIndex + that._pageIndexSelectorsCount); let pageIndexSelectorIndex = 0; for (let i = pageIndexSelectorStartIndex; i < pageIndexSelectorEndIndex; i++) { const newPageIndexSelector = document.createElement('span'); let newPageIndexSelectorContent = i + 1; newPageIndexSelector.className = 'lw-pager-page-index-selector'; if (isArray) { const pageIndexSelector = that.pageIndexSelectors[pageIndexSelectorIndex++]; if (pageIndexSelector) { if (pageIndexSelector.label) { newPageIndexSelectorContent = that.pageIndexSelectors[i].label; } else if (typeof pageIndexSelector === 'string') { newPageIndexSelectorContent = pageIndexSelector; } if (pageIndexSelector.value) { newPageIndexSelector.setAttribute('value', that.pageIndexSelectors[i].value); } } } newPageIndexSelector.index = i; newPageIndexSelector.innerHTML = newPageIndexSelectorContent; newPageIndexSelector.setAttribute('role', 'listitem'); that.$.pageIndexSelectorsContainer.appendChild(newPageIndexSelector); if (i === that.pageIndex) { newPageIndexSelector.classList.add('lw-selected'); newPageIndexSelector.setAttribute('selected', ''); newPageIndexSelector.setAttribute('aria-current', 'page'); } } } /** * Last button click handler. */ _lastButtonClickHandler() { const that = this; that.last(); } last() { const that = this; that.navigateTo(that.pagesCount - 1); } /** * First button click handler. */ _firstButtonClickHandler() { const that = this; that.first(); } first() { const that = this; that.navigateTo(0); } _renderButtons() { const that = this; if (that.pageIndex === 0) { that.$.firstButton.setAttribute('disabled', ''); that.$.previousButton.setAttribute('disabled', ''); } else { that.$.firstButton.removeAttribute('disabled'); that.$.previousButton.removeAttribute('disabled'); } if (that.pageIndex === that.pagesCount - 1) { that.$.nextButton.setAttribute('disabled', ''); that.$.lastButton.setAttribute('disabled', ''); } else { that.$.nextButton.removeAttribute('disabled'); that.$.lastButton.removeAttribute('disabled'); } if (that.pagesCount <= 0) { that.$.firstButton.setAttribute('disabled', ''); that.$.previousButton.setAttribute('disabled', ''); that.$.nextButton.setAttribute('disabled', ''); that.$.lastButton.setAttribute('disabled', ''); } that.$nearButtonsContainer.removeClass('far'); that.$farButtonsContainer.removeClass('far'); that.$nearButtonsContainer.removeClass('near'); that.$farButtonsContainer.removeClass('near'); switch (that.navigationButtonsPosition) { case 'near': that.$nearButtonsContainer.addClass('near'); that.$farButtonsContainer.addClass('near'); break; case 'far': that.$nearButtonsContainer.addClass('far'); that.$farButtonsContainer.addClass('far'); break; case 'both': that.$nearButtonsContainer.addClass('near'); that.$farButtonsContainer.addClass('far'); break; } } _navigateToInputChangeHandler() { const that = this; let pageIndex = parseInt(that.$.navigateToInput.value) - 1; if (isNaN(pageIndex)) { that.$.navigateToInput.value = '1'; pageIndex = parseInt(that.$.navigateToInput.value - 1); } that.navigateTo(pageIndex); } _pageIndexSelectorsContainerClickHandler(event) { const that = this, closestPageIndexSelector = that.enableShadowDOM ? event.composedPath()[0].closest('.lw-pager-page-index-selector') : event.target.closest('.lw-pager-page-index-selector'); if (!closestPageIndexSelector || closestPageIndexSelector.classList.contains('lw-selected')) { return; } that.navigateTo(closestPageIndexSelector.index); } _pageSizeSelectorChangeHandler(event) { const that = this; if (!that.showPageSizeSelector || that.disabled || that._updating) { return; } that.pageSize = parseInt(event.detail.value); that.$.fireEvent('pageSizeChanged', { 'value': parseInt(event.detail.value) }); } /** * Pager's keydown event handler. */ _keyDownHandler(event) { const that = this; if (that.disabled) { return; } if ((that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement) === that.$.navigateToInput) { return; } if (that.$.pageSizeSelector.getAttribute('focus') !== null) { return; } switch (event.key) { case 'End': that.last(); event.preventDefault(); break; case 'Home': that.first(); event.preventDefault(); break; case 'PageDown': case 'ArrowDown': case 'ArrowLeft': that.prev(); event.preventDefault(); break; case 'PageUp': case 'ArrowUp': case 'ArrowRight': that.next(); event.preventDefault(); break; } } /** * Next Page button click handler. */ _nextButtonClickHandler() { const that = this; that.next(); } /** * Previous Page button click handler. */ _previousButtonClickHandler() { const that = this; that.prev(); } navigateTo(pageIndex) { const that = this, oldIndex = that.pageIndex; if (that.disabled || that.pageIndex === pageIndex || pageIndex < 0 || pageIndex >= that.pagesCount) { return; } that.pageIndex = pageIndex; that._render(); that.$.fireEvent('change', { 'oldIndex': oldIndex, 'index': pageIndex }); } /** * Updates from-to summary block. */ _localize() { const that = this, buttonsArray = ['firstButton', 'lastButton', 'previousButton', 'nextButton']; for (let i = 0; i < buttonsArray.length; i++) { const button = that.$[buttonsArray[i]]; if (!that.showNavigationButtonLabels && i < 2) { button.innerHTML = ''; if (i === 0) { button.classList.add('lw-arrow-left-first'); } else { button.classList.add('lw-arrow-right-last'); } } else if (!that.showNavigationButtonLabels && i >= 2) { button.innerHTML = ''; if (i === 2) { button.classList.add('lw-arrow-left'); } else { button.classList.add('lw-arrow-right'); } } else { button.classList.remove('lw-arrow-left'); button.classList.remove('lw-arrow-right'); button.classList.remove('lw-arrow-left-first'); button.classList.remove('lw-arrow-right-last'); button.innerHTML = that.localize(buttonsArray[i]); } } that.$.pageSizeLabel.innerHTML = that.localize('pageSizeLabel'); that.$.navigateToLabel.innerHTML = that.localize('navigateToLabel'); that.$.previousEllipsisButton.innerHTML = that.localize('ellipsis'); that.$.nextEllipsisButton.innerHTML = that.localize('ellipsis'); that.$.navigateToInput.placeholder = that.localize('navigateToInputPlaceholder'); } _nextEllipsisButtonClickHandler() { const that = this; that.navigateTo(that._pageIndexSelectorsCount + that.pageIndex); } _previousEllipsisButtonClickHandler() { const that = this; that.navigateTo(-that._pageIndexSelectorsCount + that.pageIndex); } /** * Updates from-to summary block. */ _navigationButtonsClickHandler(event) { const that = this; if (that.disabled) { return; } const targetElement = that.enableShadowDOM ? event.composedPath()[0].closest('.lw-pager-button') : event.target.closest('.lw-pager-button'); switch (targetElement) { case that.$.firstButton: that._firstButtonClickHandler(event); break; case that.$.lastButton: that._lastButtonClickHandler(event); break; case that.$.previousButton: that._previousButtonClickHandler(event); break; case that.$.nextButton: that._nextButtonClickHandler(event); break; } } _navigationButtonsDownHandler(event) { const that = this, targetElement = that.enableShadowDOM ? (event.originalEvent.composedPath()[0].closest('.lw-pager-button') || event.originalEvent.composedPath()[0].closest('.lw-pager-page-index-selector')) : (event.originalEvent.target.closest('.lw-pager-button') || event.originalEvent.target.closest('.lw-pager-page-index-selector')); if (that.disabled || !targetElement) { return; } if (that.hasRippleAnimation) { LW.Utilities.Animation.Ripple.animate(targetElement, event.pageX, event.pageY); } if (targetElement === that.$.previousButton || targetElement === that.$.nextButton) { that._startRepeat(event, targetElement); } } _updateInBoundsFlag(event) { const that = this, button = that.enableShadowDOM ? event.composedPath()[0] : event.target; button._isPointerInBounds = true; if (event.type.indexOf('leave') !== -1) { button._isPointerInBounds = false; } const buttons = ('buttons' in event) ? event.buttons : event.which; if (buttons !== 1) { that._stopRepeat(); } } _startRepeat(event, button) { const that = this; if (!that._initialTimer) { that._initialTimer = setTimeout(function () { that._repeatTimer = setInterval(() => { if (button._isPointerInBounds) { if (button === that.$.previousButton) { that._previousButtonClickHandler(event); } else { that._nextButtonClickHandler(event); } } }, 50); }, 150); } } _stopRepeat() { const that = this; if (that._repeatTimer) { clearInterval(that._repeatTimer); that._repeatTimer = null; } if (that._initialTimer) { clearTimeout(that._initialTimer); that._initialTimer = null; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-base-progress-bar', class BaseProgressBar extends LW.BaseElement { /** Progressbar's properties */ static get properties() { return { 'indeterminate': { value: false, type: 'boolean' }, 'inverted': { value: false, type: 'boolean' }, 'formatFunction': { value: null, type: 'function' }, 'max': { value: 100, type: 'number' }, 'min': { value: 0, type: 'number' }, 'showProgressValue': { value: false, type: 'boolean' }, 'value': { value: 0, type: 'number?' } } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.progressbar.css' ] } render() { const that = this; if (!that.$.label.id) { that.$.label.id = that.id + 'Label'; } that.setAttribute('role', 'progressbar'); that.setAttribute('aria-labelledby', that.$.label.id); that.setAttribute('aria-valuemin', that.min); that.setAttribute('aria-valuemax', that.max); if (that.value !== null && !that.indeterminate) { that.$.value.style.transition = 'none'; } that._updateProgress(); requestAnimationFrame(() => that.$.value.style.transition = ''); super.render(); } /** * Updates the progressbar when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; that._updateProgress(); if (propertyName === 'value') { that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, changeType: 'api' }); } else if (propertyName === 'min' || propertyName === 'max') { that.setAttribute('aria-value' + propertyName, newValue); } } _updateProgress() { const that = this, value = that.value; if (value === null || that.indeterminate) { that.removeAttribute('aria-valuenow'); } else { that.setAttribute('aria-valuenow', value); } } get _percentageValue() { const that = this; const max = Math.max(that.min, that.max); const min = Math.min(that.min, that.max); const validValue = (Math.min(max, Math.max(min, that.value))); const percentageValue = (validValue - min) / (max - min); return percentageValue; } }); LW('lw-circular-progress-bar', class CircularProgressBar extends LW.BaseProgressBar { /** progressbar's HTML template */ template() { return `<div id="container" role="presentation"> <svg width="100%" height="100%" viewPort="0 0 100 100" viewBox="0 0 100 100" role="presentation" aria-hidden="true"> <circle id="value" class="lw-value-path" r="50" cx="50" cy="50" transform="rotate(270 50 50)"></circle> <circle id="value" class="lw-value" r="50" cx="50" cy="50" transform="rotate(270 50 50)"></circle> </svg> <div class="lw-label-container" role="presentation"> <content></content> <span id="label" class="lw-label"></span> </div> </div>`; } /** * Circular Progress bar's event listeners. */ static get listeners() { return { 'resize': '_resizeHandler' }; } render() { const that = this; that.$.container.style.width = that.$.container.style.height = Math.min(that.offsetWidth, that.offsetHeight) + 'px'; if (that.$.hasClass('echo-animation')) { that.value = that.max; that._updateProgress(); } super.render(); } /** * Circular Progress Bar's resize handler. Ensures the Progress Bars always has the same proportions. **/ _resizeHandler() { const that = this; that.$.container.style.width = that.$.container.style.height = Math.min(that.offsetWidth, that.offsetHeight) + 'px'; } /** Updates the progress element. */ _updateProgress() { super._updateProgress(); const that = this, radius = that.indeterminate ? Math.PI * 100 : Math.PI * 100 - that._percentageValue * Math.PI * 100, isIE = /*@cc_on!@*/false || !!document.documentMode, isEdge = !isIE && !!window.StyleMedia; if (that.showProgressValue) { const percentage = parseInt(that._percentageValue * 100); that.$.label.innerHTML = that.formatFunction ? that.formatFunction(percentage) : percentage + '%'; } else { that.$.label.innerHTML = ''; } //Check if the browser is Edge to make the animation if (isIE || isEdge) { if (that.value === null || that.indeterminate) { that.$.value.style.strokeDashoffset = ''; that.$.value.setAttribute('class', 'lw-value lw-value-animation-ms'); return; } else { that.$.value.setAttribute('class', 'lw-value'); that.$.value.style.strokeDashoffset = (that.inverted && !that.rightToLeft) || (!that.inverted && that.rightToLeft) ? -radius : radius; return; } } that.$.value.style.strokeDashoffset = (that.inverted && !that.rightToLeft) || (!that.inverted && that.rightToLeft) ? -radius : radius; if (that.value === null || that.indeterminate) { that.$value.addClass('lw-value-animation'); return; } that.$value.removeClass('lw-value-animation'); } }); LW('lw-progress-bar', class ProgressBar extends LW.BaseProgressBar { /** Progressbar's properties */ static get properties() { return { 'orientation': { value: 'horizontal', allowedValues: ['horizontal', 'vertical'], type: 'string' } }; } /** progressbar's HTML template. */ template() { return `<div role="presentation"> <div id="value" class="lw-value"></div> <div id="label" class="lw-label"></div> </div>`; } /** Updates the progress elements. */ _updateProgress() { super._updateProgress(); const that = this; //Label for Percentages if (that.showProgressValue) { const percentage = parseInt(that._percentageValue * 100); that.$.label.innerHTML = that.formatFunction ? that.formatFunction(percentage) : percentage + '%'; } else { that.$.label.innerHTML = ''; } if (that.value === null || that.indeterminate) { that.$value.addClass('lw-value-animation'); } else { that.$value.removeClass('lw-value-animation'); } that.$.value.style.transform = that.orientation === 'horizontal' ? 'scaleX(' + that._percentageValue + ')' : 'scaleY(' + that._percentageValue + ')'; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * ScrollBar custom element. */ LW('lw-scroll-bar', class ScrollBar extends LW.BaseElement { // ScrollBar's properties. static get properties() { return { 'clickRepeatDelay': { type: 'integer', value: 50 }, 'largeStep': { type: 'integer', value: 100 }, 'min': { type: 'integer', value: 0 }, 'max': { type: 'integer', value: 1000 }, 'mechanicalAction': { value: 'switchWhileDragging', allowedValues: ['switchUntilReleased', 'switchWhenReleased', 'switchWhileDragging'], type: 'string' }, 'orientation': { type: 'string', value: 'horizontal', allowedValues: ['horizontal', 'vertical'] }, 'step': { type: 'integer', value: 10 }, 'showButtons': { type: 'boolean', value: true, defaultReflectToAttribute: true }, 'value': { type: 'integer', value: 0 } }; } static get styleUrls() { return [ 'lw.scrollbar.css' ] } /** ScrollBar's template. */ template() { const template = `<div id="container" class="lw-container" role="presentation"> <div id="nearButton" class="lw-scroll-button lw-arrow-left" role="presentation" aria-hidden="true"></div> <div id="track" class="lw-track" role="presentation"> <div id="thumb" class="lw-thumb" role="presentation"></div> </div> <div id="farButton" class="lw-scroll-button lw-arrow-right" role="presentation" aria-hidden="true"></div> </div>`; return template; } static get listeners() { return { 'nearButton.click': '_nearButtonClickHandler', 'nearButton.down': '_startRepeat', 'nearButton.up': '_stopRepeat', 'nearButton.pointerenter': '_updateInBoundsFlag', 'nearButton.pointerleave': '_updateInBoundsFlag', 'farButton.click': '_farButtonClickHandler', 'farButton.down': '_startRepeat', 'farButton.up': '_stopRepeat', 'farButton.pointerenter': '_updateInBoundsFlag', 'farButton.pointerleave': '_updateInBoundsFlag', 'track.down': '_trackDownHandler', 'track.click': '_trackClickHandler', 'track.move': '_trackMoveHandler', 'thumb.down': '_dragStartHandler', 'document.move': '_dragHandler', 'document.up': '_dragEndHandler', 'up': '_dragEndHandler', 'document.selectstart': '_selectStartHandler', 'resize': '_resizeHandler' }; } _updateInBoundsFlag(event) { const that = this; const button = event.target; button._isPointerInBounds = true; if (event.type.indexOf('leave') !== -1) { button._isPointerInBounds = false; } const buttons = ('buttons' in event) ? event.buttons : event.which; if (buttons !== 1) { that._stopRepeat(event); } } _startRepeat(event) { const that = this; if (that.disabled) { return; } const button = event.target; if (!button._initialTimer) { button._initialTimer = setTimeout(function () { button._repeatTimer = setInterval(() => { if (button._isPointerInBounds) { const buttons = ('buttons' in event) ? event.buttons : event.which; button.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY }); } }, that.clickRepeatDelay); }, 3 * that.clickRepeatDelay); } } _stopRepeat(event) { const that = this; if (that.disabled) { return; } const button = event.target; if (button._repeatTimer) { clearInterval(button._repeatTimer); button._repeatTimer = null; } if (button._initialTimer) { clearTimeout(button._initialTimer); button._initialTimer = null; } } _calculateThumbSize(scrollAreaSize) { const that = this; const positions = that.max - that.min; const enoughSpace = that.orientation === 'horizontal' ? that.$.track.offsetWidth > 10 : that.$.track.offsetHeight > 10; let size = 0; if (positions >= 1 && enoughSpace) { size = (scrollAreaSize / (positions + scrollAreaSize) * scrollAreaSize); if (that.$.thumb.className.indexOf('lw-hidden') >= 0) { that.$thumb.removeClass('lw-hidden'); } } else { that.$thumb.addClass('lw-hidden'); } return Math.max(10, Math.min(size, scrollAreaSize)); } _dragStartHandler(event) { const that = this; if (that.disabled) { return; } that.thumbCapture = true; that.dragStartX = event.clientX; that.dragStartY = event.clientY; that.dragStartValue = that.value; event.stopPropagation(); event.preventDefault(); } _dragHandler(event) { const that = this; if (that.thumbCapture !== true) { return; } that._isThumbDragged = true; const ratio = (that.max - that.min) / (that.scrollBarSize - that.thumbSize); const offsetValue = that.orientation === 'horizontal' ? (event.clientX - that.dragStartX) * ratio : (event.clientY - that.dragStartY) * ratio; let step = offsetValue; if (that.rightToLeft && that.orientation === 'horizontal') { step = -offsetValue; } that._updateValue(that.dragStartValue + step); event.stopPropagation(); event.preventDefault(); if (event.originalEvent) { event.originalEvent.stopPropagation(); event.originalEvent.preventDefault(); } } _dragEndHandler(event) { const that = this; if (that._trackDownTimer) { clearInterval(that._trackDownTimer); that._trackDownTimer = null; } if (!that.thumbCapture) { return; } that.thumbCapture = false; that._isThumbDragged = false; if (that.mechanicalAction === 'switchWhenReleased') { that._updateValue(that.dragStartValue, that.value); } else if (this.mechanicalAction === 'switchUntilReleased') { that._updateValue(that.dragStartValue); } event.preventDefault(); event.stopPropagation(); event.originalEvent.preventDefault(); event.originalEvent.stopPropagation(); } _farButtonClickHandler() { const that = this; if (that.disabled) { return; } const value = that.value; that._updateValue(that.value + (that.orientation === 'horizontal' && that.rightToLeft ? -1 : 1) * that.step); if (that.mechanicalAction === 'switchUntilReleased') { that._updateValue(value); } } _nearButtonClickHandler() { const that = this; if (that.disabled) { return; } const value = that.value; that._updateValue(that.value - (that.orientation === 'horizontal' && that.rightToLeft ? -1 : 1) * that.step); if (that.mechanicalAction === 'switchUntilReleased') { that._updateValue(value); } } propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'min': case 'max': case 'orientation': case 'showButtons': { that._layout(); if (propertyName === 'min') { that.setAttribute('aria-valuemin', newValue); } else if (propertyName === 'max') { that.setAttribute('aria-valuemax', newValue); } else if (propertyName === 'orientation') { that.setAttribute('aria-orientation', newValue); } break; } case 'value': that._updateValue(oldValue, newValue); break; default: { that._layout(); } } } render() { const that = this; that.setAttribute('role', 'scrollbar'); that.setAttribute('aria-orientation', that.orientation); that.setAttribute('aria-valuemin', that.min); that.setAttribute('aria-valuemax', that.max); that.setAttribute('aria-valuenow', that.value); that._layout(); super.render(); } _resizeHandler() { const that = this; that._layout(); } refresh() { const that = this; that._layout(); } _layout() { const that = this; that.scrollBarSize = that.orientation === 'horizontal' ? that.$.track.offsetWidth : that.$.track.offsetHeight; that.thumbSize = that._calculateThumbSize(that.scrollBarSize); if (that.orientation === 'horizontal' && (that.$.thumb.style.width !== that.thumbSize + 'px')) { that.$.thumb.style.width = that.thumbSize + 'px'; } else if (that.orientation === 'vertical' && (that.$.thumb.style.height !== that.thumbSize + 'px')) { that.$.thumb.style.height = that.thumbSize + 'px'; } if (that.orientation === 'horizontal') { if (that.$.nearButton.classList.contains('lw-arrow-up')) { that.$.nearButton.classList.remove('lw-arrow-up'); } if (that.$.farButton.classList.contains('lw-arrow-down')) { that.$.farButton.classList.remove('lw-arrow-down'); } if (!that.$.nearButton.classList.contains('lw-arrow-left')) { that.$.nearButton.classList.add('lw-arrow-left'); } if (!that.$.farButton.classList.contains('lw-arrow-right')) { that.$.farButton.classList.add('lw-arrow-right'); } } else { if (that.$.nearButton.classList.contains('lw-arrow-left')) { that.$.nearButton.classList.remove('lw-arrow-left'); } if (that.$.farButton.classList.contains('lw-arrow-right')) { that.$.farButton.classList.remove('lw-arrow-right'); } if (!that.$.nearButton.classList.contains('lw-arrow-up')) { that.$.nearButton.classList.add('lw-arrow-up'); } if (!that.$.farButton.classList.contains('lw-arrow-down')) { that.$.farButton.classList.add('lw-arrow-down'); } } that._updateThumbPosition(); if (that.value > that.max || that.value < that.min) { that._updateValue(that.value, that.value > that.max ? that.max : that.min); } } _selectStartHandler(event) { const that = this; if (that.thumbCapture) { event.preventDefault(); } } _trackDownHandler(event) { const that = this; if (event.target !== that.$.track) { return; } if (that._trackDownTimer) { clearInterval(that._trackDownTimer); } if (that.thumbCapture) { return; } that._trackDownTimer = setInterval(function () { that._trackClickHandler(event); }, that.clickRepeatDelay); event.stopPropagation(); event.preventDefault(); } _trackClickHandler(event) { const that = this; if (that.disabled) { return; } if (that._isThumbDragged) { clearInterval(that._trackDownTimer); that._trackDownTimer = null; return; } const thumbRect = that.$.thumb.getBoundingClientRect(); const x = event.pageX - window.pageXOffset; const y = event.pageY - window.pageYOffset; const value = (that.rightToLeft ? -1 : 1) * that.value; if (that.orientation === 'horizontal') { if (x > (that._isThumbDragged ? that.dragStartX : thumbRect.right)) { that._updateValue(that.value + (that.rightToLeft ? -1 : 1) * that.largeStep); } else if (x < (that._isThumbDragged ? that.dragStartX : thumbRect.left)) { that._updateValue(that.value - (that.rightToLeft ? -1 : 1) * that.largeStep); } } else { if (y > (that._isThumbDragged ? that.dragStartY : thumbRect.bottom)) { that._updateValue(that.value + that.largeStep); } else if (y < (that._isThumbDragged ? that.dragStartY : thumbRect.top)) { that._updateValue(that.value - that.largeStep); } } if (that.mechanicalAction === 'switchUntilReleased') { that._updateValue(value); } } /** * iOS Fix for the lack of support for 'touch-action: none' */ _trackMoveHandler(event) { if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } _updateValue(oldValue, newValue) { const that = this; if (arguments.length === 1) { newValue = oldValue; oldValue = that.value; } if (newValue === undefined || isNaN(newValue)) { newValue = that.min; } if (newValue > that.max) { newValue = that.max; } if (newValue < that.min) { newValue = that.min; } that.value = newValue; if (oldValue !== newValue) { that.setAttribute('aria-valuenow', newValue); that._updateThumbPosition(); if (that.thumbCapture && that.mechanicalAction === 'switchWhenReleased') { return; } if (that.onChange) { that.onChange({ 'value': that.value, 'oldValue': oldValue, min: that.min, max: that.max }); return; } that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue, min: that.min, max: that.max }); } } _updateThumbPosition() { const that = this; const height = that.$.track.offsetHeight; const width = that.$.track.offsetWidth; const scrollBarSize = (that.orientation === 'horizontal') ? width : height; const thumbSize = that._calculateThumbSize(scrollBarSize); const maxThumbPosition = (that.orientation === 'horizontal') ? width - thumbSize : height - thumbSize; let thumbPosition = (scrollBarSize - thumbSize) / (that.max - that.min) * (that.value - that.min); if (that.rightToLeft && that.orientation === 'horizontal') { thumbPosition = (scrollBarSize - thumbSize) / (that.max - that.min) * (that.max - that.value - that.min); } thumbPosition = Math.min(maxThumbPosition, Math.max(0, thumbPosition)); if (that.orientation === 'vertical' && (that.$.thumb.style.top !== thumbPosition + 'px')) { that.$.thumb.style.top = thumbPosition + 'px'; } else if (that.orientation === 'horizontal' && (that.$.thumb.style.left !== thumbPosition + 'px')) { that.$.thumb.style.left = thumbPosition + 'px'; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-splitter-item', class SplitterItem extends LW.ContentElement { /** * Element's properties */ static get properties() { return { 'collapsed': { value: false, type: 'boolean' }, 'collapsible': { value: false, type: 'boolean' }, 'locked': { value: false, type: 'boolean' }, 'max': { value: '', type: 'any', validator: '_propertyValidator' }, 'min': { value: '', type: 'any', validator: '_propertyValidator' }, 'size': { value: '', type: 'any', validator: '_propertyValidator' } } } /** * Disables ShadowDOM for the splitter items */ get enableShadowDOM() { return false; } /** * Element's template */ template() { return `<div id="container" role="presentation"> <div class="lw-content" id="content" inner-h-t-m-l="[[innerHTML]]" role="presentation"> <content></content> </div> </div>`; } /** * Element's event binding */ static get listeners() { return { 'mouseenter': '_mouseEventsHandler', 'mouseleave': '_mouseEventsHandler', 'styleChanged': '_styleChangedEventHandler' } } /** * Updates the SplitterItem when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'collapsed': that._ignorePropertyValue = true; newValue ? that.collapse() : that.expand(); break; case 'collapsible': that._updateNearSplitterBars(); break; case 'size': case 'min': case 'max': that._setSize(propertyName, newValue); break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Called when the element is attached to the DOM */ attached() { super.attached(); const that = this; if (!that._sizeLimits) { that._sizeLimits = {}; } const computedStyle = getComputedStyle(that); if (!that.min) { that._sizeLimits.minWidth = parseFloat(computedStyle.getPropertyValue('min-width')) || 0; that._sizeLimits.minHeight = parseFloat(computedStyle.getPropertyValue('min-height')) || 0; } if (!that.max) { that._sizeLimits.maxWidth = parseFloat(computedStyle.getPropertyValue('max-width')) || 0; that._sizeLimits.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height')) || 0; } } /** * Called when the element is detached from the DOM */ detached() { super.detached(); const that = this; that.$.removeClass('animate'); } /** * Appends a node to the splitter item. */ appendChild(node) { const that = this; if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' })); return } if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.content.appendChild(node); } /** * Collapses the item */ collapse(far) { const that = this; if (!that.collapsible) { that.collapsed = false; return; } if (that._ignorePropertyValue || !that.collapsed) { const ownerElement = that.closest('lw-splitter') || (that.getRootNode() && that.getRootNode().host ? that.getRootNode().host.closest('lw-splitter') : undefined); if (!ownerElement) { return; } const itemIndex = ownerElement._items.indexOf(that); if (itemIndex === ownerElement._items.length - 1) { far = true; } else if (itemIndex === 0) { far = false; } const direction = far ? -1 : 1; let neighbourItemIndex = itemIndex + direction, neighbourItem = ownerElement._items[neighbourItemIndex]; while (neighbourItem) { if (!neighbourItem.collapsed) { break; } neighbourItemIndex += direction; neighbourItem = ownerElement._items[neighbourItemIndex]; } if (!neighbourItem) { that.collapsed = false; return; } delete that._ignorePropertyValue; //Store the size before collapsing if (!that._sizeBeforeCollapse) { that._sizeBeforeCollapse = that[ownerElement._measurements.size]; } if (!neighbourItem._sizeBeforeCollapse) { neighbourItem._sizeBeforeCollapse = neighbourItem[ownerElement._measurements.size]; } let splitterBar; if (that.previousElementSibling instanceof LW.SplitterBar) { splitterBar = that.previousElementSibling; } else if (that.nextElementSibling instanceof LW.SplitterBar) { splitterBar = that.nextElementSibling; } const totalSpace = neighbourItem[ownerElement._measurements.size] + that[ownerElement._measurements.size], minSize = splitterBar ? splitterBar[ownerElement._measurements.size] : that._sizeLimits[ownerElement._measurements.minDimension], spaceAvailable = totalSpace - minSize; if (totalSpace && spaceAvailable < minSize) { that.collapsed = false; return; } //Add animation class if (ownerElement.hasAnimation && !ownerElement._isInitializing) { if (!that.style[ownerElement._measurements.dimension]) { that.style[ownerElement._measurements.dimension] = that[ownerElement._measurements.size] + 'px'; } that.$.addClass('animate'); neighbourItem.$.addClass('animate'); that.addEventListener('transitionend', that._transitionEndHandler, { once: true }); that.addEventListener('transitioncancel', that._transitionEndHandler, { once: true }); neighbourItem.addEventListener('transitionend', that._transitionEndHandler, { once: true }); neighbourItem.addEventListener('transitioncancel', that._transitionEndHandler, { once: true }); } if (!that._paddings) { const computedStyle = getComputedStyle(that); that._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0); } if (neighbourItem._sizeBeforeCollapse !== undefined) { neighbourItem._sizeBeforeCollapse = neighbourItem._sizeBeforeCollapse + that._sizeBeforeCollapse; } if (neighbourItem._sizeLimits && neighbourItem._sizeLimits[ownerElement._measurements.maxDimension] && totalSpace > neighbourItem._sizeLimits[ownerElement._measurements.maxDimension]) { neighbourItem._sizeLimits.ignoreUpdate = true; if (neighbourItem._sizeBeforeCollapse) { neighbourItem.style[ownerElement._measurements.maxDimension] = neighbourItem._sizeBeforeCollapse + 'px'; } else { neighbourItem.style[ownerElement._measurements.maxDimension] = ''; } } //Reset the size property neighbourItem.set('size', ''); if (neighbourItem._sizeBeforeCollapse) { neighbourItem.style[ownerElement._measurements.dimension] = neighbourItem._sizeBeforeCollapse + 'px'; } that.style[ownerElement._measurements.dimension] = that.style[ownerElement._measurements.minDimension] = '0'; that.style.padding = '0'; //Make sure no paddings interferes with the size of the collapsed item that._neighbourItem = neighbourItem; that.collapsed = true; ownerElement.$.fireEvent('collapse', { itemIndex: ownerElement._items.indexOf(that) }); if (far) { that.previousElementSibling.itemCollapsed = true; that.previousElementSibling.showFarButton = !(that.previousElementSibling.showNearButton = false); } else { that.nextElementSibling.itemCollapsed = true; that.nextElementSibling.showNearButton = !(that.nextElementSibling.showFarButton = false); } } } /** * Expands a splitter item */ expand() { const that = this; if (that._ignorePropertyValue || that.collapsed) { const ownerElement = that.closest('lw-splitter') || (that.getRootNode() && that.getRootNode().host ? that.getRootNode().host.closest('lw-splitter') : undefined); if (!ownerElement) { that.collapsed = true; return; } if (!that._neighbourItem) { that.collapsed = true; return; } delete that._ignorePropertyValue; if (!that._neighbourItem._ignorePropertyValue && that._neighbourItem.collapsed) { let neighbourItemIndex = ownerElement._items.indexOf(that._neighbourItem); const direction = ownerElement._items.indexOf(that) > ownerElement._items.indexOf(that._neighbourItem) ? -1 : 1; that._neighbourItem = ownerElement._items[neighbourItemIndex]; while (that._neighbourItem) { if (!that._neighbourItem.collapsed) { break; } neighbourItemIndex += direction; that._neighbourItem = ownerElement._items[neighbourItemIndex]; } } if (!that._neighbourItem) { that.collapsed = true; return; } if (that.min) { that._setSize('min', that.min, true); } const totalSpace = that._neighbourItem._sizeBeforeCollapse, minSize = that._sizeLimits[ownerElement._measurements.minDimension], neighbourItemMin = that._neighbourItem._sizeLimits[ownerElement._measurements.minDimension], spaceAvailable = totalSpace - minSize; if (totalSpace && spaceAvailable < neighbourItemMin) { that.collapsed = true; return; } if (!that._neighbourItem._paddings) { const computedStyle = getComputedStyle(that._neighbourItem); that._neighbourItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0); } if (!that._paddings) { const computedStyle = getComputedStyle(that); that._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0); } if ((that.size + '').indexOf('%') > -1 && (!that._sizeBeforeCollapse || that._sizeBeforeCollapse === 0) && that._neighbourItem._sizeBeforeCollapse) { let totalItemSize = 0; ownerElement._items.map(item => totalItemSize += !item.collapsed ? (item.style[ownerElement._measurements.dimension] && item.style[ownerElement._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ? item._sizeBeforeCollapse : item.getBoundingClientRect()[ownerElement._measurements.dimension]) : 0); that._sizeBeforeCollapse = totalItemSize * parseFloat(that.size) / 100; } const previousSize = Math.min(Math.max(minSize, that._sizeBeforeCollapse), totalSpace - that._neighbourItem._paddings - that._paddings - neighbourItemMin); if (previousSize < 0) { that.collapsed = true; return; } if (that.min) { that.style[ownerElement._measurements.minDimension] = 0; } //Add animation class if (that.hasAnimation && !ownerElement._isInitializing) { that.$.addClass('animate'); that._neighbourItem.$.addClass('animate'); that.addEventListener('transitionend', that._transitionEndHandler, { once: true }); that.addEventListener('transitioncancel', that._transitionEndHandler, { once: true }); that._neighbourItem.addEventListener('transitionend', that._transitionEndHandler, { once: true }); that._neighbourItem.addEventListener('transitioncancel', that._transitionEndHandler, { once: true }); } //Restore the size before collapsing that.style.padding = ''; if (that.min) { that.style[ownerElement._measurements.minDimension] = that._sizeLimits[ownerElement._measurements.minDimension] + 'px'; } that.style[ownerElement._measurements.dimension] = (that._sizeBeforeCollapse = previousSize) + 'px'; that._neighbourItem.style[ownerElement._measurements.dimension] = (that._neighbourItem._sizeBeforeCollapse = Math.max(that._neighbourItem._sizeLimits[ownerElement._measurements.minDimension], totalSpace - previousSize)) + 'px'; if (that._neighbourItem._sizeLimits[ownerElement._measurements.maxDimension]) { that._neighbourItem.style[ownerElement._measurements.maxDimension] = that._neighbourItem._sizeLimits[ownerElement._measurements.maxDimension] + 'px'; } that.collapsed = false; ownerElement.$.fireEvent('expand', { itemIndex: ownerElement._items.indexOf(that) }); if (ownerElement._items.indexOf(that) > ownerElement._items.indexOf(that._neighbourItem)) { that.previousElementSibling.itemCollapsed = false; that.previousElementSibling.showNearButton = that._neighbourItem.collapsible; } else { that.nextElementSibling.itemCollapsed = false; that.nextElementSibling.showFarButton = that._neighbourItem.collapsible; } const previousElement = ownerElement._items[ownerElement._items.indexOf(that) - 1], nextElement = ownerElement._items[ownerElement._items.indexOf(that) + 1]; if (previousElement) { const previousSplitterBar = previousElement.nextElementSibling; if (previousSplitterBar && previousSplitterBar instanceof LW.SplitterBar) { if (!previousElement.collapsed) { previousSplitterBar.itemCollapsed = false; previousSplitterBar.showNearButton = previousElement.collapsible; previousSplitterBar.showFarButton = that.collapsible; } else { previousSplitterBar.showNearButton = that.collapsible; } } } if (nextElement) { const nextSplitterBar = nextElement.previousElementSibling; if (nextSplitterBar && nextSplitterBar instanceof LW.SplitterBar) { if (!nextElement.collapsed) { nextSplitterBar.itemCollapsed = false; nextSplitterBar.showNearButton = that.collapsible; nextSplitterBar.showFarButton = nextElement.collapsible; } else { nextSplitterBar.showFarButton = nextElement.collapsed; } } } delete that._neighbourItem; } } /** * Inserts a node before another node inside the splitter item. */ insertBefore(node, referenceNode) { const that = this; if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'node' })); return } if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.content.insertBefore(node, referenceNode || null); } /** * Locks a splitter item so it's size can't change. */ lock() { const that = this; that.locked = true; } /** * Unlocks a splitter item */ unlock() { const that = this; that.locked = false; } /** * Invoked when an instance of custom element is attached to the DOM for the first time. */ ready() { super.ready(); } render() { const that = this, ownerElement = that.closest('lw-splitter'), isOwnerReady = ownerElement && ownerElement.isCompleted; that.setAttribute('role', 'region'); that._sizeLimits = {}; let isPercentage = typeof that.min === 'string' && that.min.indexOf('%') > -1; const min = isNaN(parseFloat(that.min)) ? 0 : parseFloat(that.min), max = isNaN(parseFloat(that.max)) ? 0 : parseFloat(that.max); that._sizeLimits.minWidth = that._sizeLimits.minHeight = isPercentage && isOwnerReady ? min * ownerElement[ownerElement._measurements.size] / 100 : min; isPercentage = typeof that.max === 'string' && that.max.indexOf('%') > -1; that._sizeLimits.maxWidth = that._sizeLimits.maxHeight = isPercentage && isOwnerReady ? max * ownerElement[ownerElement._measurements.size] / 100 : max; if (that.size) { isPercentage = typeof that.size === 'string' && that.size.indexOf('%') > -1; const size = that.size === 'auto' ? that.size : isNaN(parseFloat(that.size)) ? 0 : parseFloat(that.size) + (isPercentage ? '%' : 'px'); isOwnerReady ? that.style[ownerElement._measurements.dimension] = size : that.style.width = that.style.height = size; } if (that.min) { that._setSize('min', that.min); } if (that.max) { that._setSize('max', that.max); } that._updateNearSplitterBars(); that.checkLicense(); super.render(); } /** * Removes a child from the Splitter item. */ removeChild(node) { const that = this; if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' })); return } if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.content.removeChild(node); } /** * Expands regardless of the neighbour item. Force expand */ _expand() { const that = this; if (that._neighbourItem && that._neighbourItem.parentElement) { that.expand(); return; } const ownerElement = that.closest('lw-splitter'); if (!ownerElement) { return; } delete that._neighbourItem; that.collapsed = false; ownerElement.$.fireEvent('expand', { itemIndex: ownerElement._items.indexOf(that) }); that.style[ownerElement._measurements.minDimension] = that.min ? that._sizeLimits[ownerElement._measurements.minDimension] + 'px' : ''; that.style[ownerElement._measurements.dimension] = that._sizeBeforeCollapse + 'px'; if (ownerElement._items.length < 2) { return; } if (that.previousElementSibling instanceof LW.SplitterBar) { that.previousElementSibling.itemCollapsed = false; that.previousElementSibling.showNearButton = ownerElement._items[ownerElement._items.indexOf(that) - 1].collapsible; } } /** * Mouse Enter/Leave event handler * @param {any} event */ _mouseEventsHandler(event) { const that = this, ownerElement = that.closest('lw-splitter') || that.getRootNode().host; if (ownerElement && !ownerElement.disabled || LW.Utilities.Core.isMobile) { event.type === 'mouseenter' ? this.setAttribute('hover', '') : this.removeAttribute('hover'); } } /** * Validates the value of the property * @param {any} oldValue - the old value * @param {any} value - the new value */ _propertyValidator(oldValue, newValue) { if (typeof newValue !== 'number' && typeof newValue !== 'string') { return oldValue; } return newValue; } /** * Set the width/height/min/max of the element */ _setSize(propertyName, newValue, noSizeValidation) { const that = this; if (that.isCompleted && that.locked) { return; } const ownerElement = that.closest('lw-splitter'); if (!ownerElement) { return; } if (!ownerElement.isCompleted) { ownerElement.whenReady(() => that._setSize(propertyName, newValue)); return; } const isPercentage = typeof newValue === 'string' && newValue.indexOf('%') > -1, ownerSize = function () { const bars = ownerElement.bars; let splitterBarsSize = 0; for (let b = 0; b < bars.length; b++) { splitterBarsSize += bars[b][ownerElement._measurements.size]; } return ownerElement.$.container[ownerElement._measurements.size] - splitterBarsSize; }(), toPercentages = (val) => val * 100 / ownerSize; newValue = isNaN(parseFloat(newValue)) ? '' : parseFloat(newValue); if (!that._sizeLimits) { that._sizeLimits = {}; } switch (propertyName) { case 'size': { const oldSize = that[ownerElement._measurements.size]; if (arguments[1] === 'auto' || !arguments[1]) { that.style[ownerElement._measurements.dimension] = arguments[1]; that._sizeBeforeCollapse = that[ownerElement._measurements.size]; } else { if (isPercentage) { that.style[ownerElement._measurements.dimension] = newValue + '%'; that._sizeBeforeCollapse = newValue * ownerSize / 100; } else { that.style[ownerElement._measurements.dimension] = (that._sizeBeforeCollapse = newValue || 0) + 'px'; } } that._validateSize(); const sizeDifference = oldSize - that._sizeBeforeCollapse; if (that._originalSize) { that._originalSize = isPercentage ? newValue + '%' : that._sizeBeforeCollapse; } if (ownerElement.hasAttribute('orientation-change')) { break; } const lastSplitterItem = ownerElement._items[ownerElement._items.length - 1]; if (that === lastSplitterItem) { //Get the best fit item let newLastItem = ownerElement._items.find(item => item !== that && !item.collapsed && !item.locked && !item.size) //Get the first possible item if (!newLastItem) { for (let i = Math.max(0, ownerElement._items.length - 2); i >= 0; i--) { if (!ownerElement._items[i].collapsed && !ownerElement._items[i].locked && ownerElement._items[i] !== that) { newLastItem = ownerElement._items[i]; break; } } } if (newLastItem) { newLastItem.style[ownerElement._measurements.dimension] = (newLastItem._sizeBeforeCollapse = Math.max(0, newLastItem[ownerElement._measurements.size] + sizeDifference)) + 'px'; } } break; } case 'min': newValue = isPercentage ? newValue * ownerSize / 100 : newValue; that._sizeLimits['minWidth'] = that._sizeLimits['minHeight'] = newValue; that.style[ownerElement._measurements.minDimension] = that.collapsed || !newValue ? '' : isPercentage ? (toPercentages(newValue) + '%') : (newValue + 'px'); that.style['min' + ownerElement._measurements.restricredDimension] = ''; that._validateSize(); if (!newValue && !ownerElement._noNeighbourValidation) { ownerElement._validateNeighbourSizeLimits(that); } if (that.size) { that._setSize('size', that.size, noSizeValidation); return; } break; case 'max': that._sizeLimits['maxWidth'] = that._sizeLimits['maxHeight'] = isPercentage ? newValue * ownerSize / 100 : newValue; that.style[ownerElement._measurements.maxDimension] = newValue ? (isPercentage ? (toPercentages(newValue) + '%') : (newValue + 'px')) : ''; that.style['max' + ownerElement._measurements.restricredDimension] = ''; that._validateSize(); if (!newValue && !ownerElement._noNeighbourValidation) { ownerElement._validateNeighbourSizeLimits(that); } if (that.size) { that._setSize('size', that.size, noSizeValidation); return; } break; } if (!noSizeValidation && !ownerElement._noItemSizeValidation) { ownerElement._validateItemSize(true); } } /** * Validates the size/min/max of the item agains each other * @param {any} property - the name of the proeprty that is being applied * @param {any} newValue - the new value of the property that is being applied */ _validateSize() { const that = this, ownerElement = that.closest('lw-splitter'); if (that.collapsed && !ownerElement) { return; } const measurements = ownerElement._measurements, isPercentage = (val) => typeof val === 'string' && val.indexOf('%') > -1, sizeInPxls = that._sizeBeforeCollapse ? that._sizeBeforeCollapse : that.getBoundingClientRect()[measurements.dimension]; function validateSize(prop) { const dimension = prop + 'Dimension', limit = that.style[measurements[dimension]], limitInPxls = that._sizeLimits[measurements[dimension]]; if ((prop === 'min' && sizeInPxls < limitInPxls) || (prop === 'max' && sizeInPxls > limitInPxls)) { that.style[measurements.dimension] = isPercentage(limit) ? limit : (limitInPxls + 'px'); that._sizeBeforeCollapse = limitInPxls; } } if (that.min) { validateSize('min'); } if (that.max) { validateSize('max'); } } /** * StyleChanged event handler */ _styleChangedEventHandler(event) { const that = this; if (that.locked) { return; } if (that._sizeLimits.ignoreUpdate) { delete that._sizeLimits.ignoreUpdate; return; } if (that.collapsed) { return; } const ownerElement = that.closest('lw-splitter'); let value; if (event.detail.styleProperties['min-width']) { value = event.detail.styleProperties['min-width'][ownerElement && ownerElement.orientation === 'horizontal' ? 'oldValue' : 'value']; that._sizeLimits['minWidth'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1); } else if (event.detail.styleProperties['max-width']) { value = event.detail.styleProperties['max-width'][ownerElement && ownerElement.orientation === 'horizontal' ? 'oldValue' : 'value']; that._sizeLimits['maxWidth'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1); } else if (event.detail.styleProperties['min-height']) { value = event.detail.styleProperties['min-height'][ownerElement && ownerElement.orientation === 'horizontal' ? 'value' : 'oldValue']; that._sizeLimits['minHeight'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1); } else if (event.detail.styleProperties['max-height']) { value = event.detail.styleProperties['max-height'][ownerElement && ownerElement.orientation === 'horizontal' ? 'value' : 'oldValue']; that._sizeLimits['maxHeight'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1); } } /** * Transitionend Event Handler */ _transitionEndHandler() { const that = this; if (!that.isCompleted && that.$.hasClass('animate')) { return; } that.$.removeClass('animate'); if (that._neighbourItem && that._neighbourItem.$.hasClass('animate')) { that._neighbourItem.$.removeClass('animate'); } if ((that.size + '').indexOf('%') > -1 || (that._neighbourItem && (that._neighbourItem.size + '').indexOf('%') > -1)) { const ownerElement = (that.shadowRoot && that.getRootNode() ? that.getRootNode().host : null) || that.closest('lw-splitter'); ownerElement._validateItemSize(); } } /** * Show/Hide the arrows of the neighbour splitter bars */ _updateNearSplitterBars() { const that = this; if (that.previousElementSibling instanceof LW.SplitterBar) { that.previousElementSibling.showFarButton = that.collapsible; } if (that.nextElementSibling instanceof LW.SplitterBar) { that.nextElementSibling.showNearButton = that.collapsible; } } }); LW('lw-splitter-bar', class SplitterBar extends LW.BaseElement { /** * Element's properties */ static get properties() { return { 'showNearButton': { value: false, type: 'boolean' }, 'showFarButton': { value: false, type: 'boolean' }, 'itemCollapsed': { value: false, type: 'boolean' }, 'locked': { value: false, type: 'boolean' } } } /** * Disables ShadowDOM for the splitter bars */ get enableShadowDOM() { return false; } /** * Element's template */ template() { return `<div id="container" role="presentation"> <div class="lw-splitter-far-collapse-button" id="farCollapseButton" role="button" aria-label="Collapse next"> <span id="arrowNear" class="lw-arrow" aria-hidden="true"></span> </div> <div class="lw-splitter-resize-button" id="resizeButton" aria-hidden="true"> <span></span> </div> <div class="lw-splitter-near-collapse-button" id="nearCollapseButton" role="button" aria-label="Collapse previous"> <span id="arrowFar" class="lw-arrow" aria-hidden="true"></span> </div> </div>`; } /** * Element's event binding */ static get listeners() { return { 'mouseenter': '_mouseEventsHandler', 'mouseleave': '_mouseEventsHandler', 'mouseover': '_mouseEventsHandler', 'mouseout': '_mouseEventsHandler', 'focus': '_focusEventHandler', 'blur': '_focusEventHandler' } } /** * Updates the SplitterBar when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'unfocusable': that._setFocusable(); break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Invoked when an instance of custom element is attached to the DOM for the first time. */ ready() { super.ready(); const that = this; that.setAttribute('role', 'separator'); that.setAttribute('aria-label', 'Resize'); that._setFocusable(); } /** * Hides the Splitter Bar */ hide() { const that = this, ownerElement = that.closest('lw-splitter'); that.$.addClass('lw-hidden'); if (ownerElement) { const ownerItems = ownerElement.items; if (ownerElement.hasAnimation) { let animatedItem; for (let i = 0; i < ownerItems.length; i++) { if (ownerItems[i].$.hasClass('animate')) { animatedItem = true; ownerItems[i].addEventListener('transitionend', function () { that.closest('lw-splitter')._autoFitItems(); }, { once: true }); } } if (animatedItem) { return; } } ownerElement._autoFitItems(); } } /** * Shows the Splitter Bar */ show() { const that = this, ownerElement = that.closest('lw-splitter'); that.$.removeClass('lw-hidden'); if (ownerElement) { const ownerItems = ownerElement.items; if (ownerElement.hasAnimation) { let animatedItem; for (let i = 0; i < ownerItems.length; i++) { if (ownerItems[i].$.hasClass('animate')) { animatedItem = true; ownerItems[i].addEventListener('transitionend', function () { that.closest('lw-splitter')._validateItemSize(); }, { once: true }); } } if (animatedItem) { return; } } ownerElement._validateItemSize(); } } /** * Locks a splitter bar so it can't be dragged */ lock() { const that = this; that.locked = that.unfocusable = true; if (that.showNearButton || that.showFarButton) { return; } that._setFocusable(); } /** * Unlocks a splitter bar */ unlock() { const that = this; that.locked = that.unfocusable = false; that._setFocusable(); } /** * Focus/Blur event handler * @param {any} event */ _focusEventHandler(event) { event.type === 'focus' ? this.setAttribute('focus', '') : this.removeAttribute('focus'); } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); return; } that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0; } /** * MouseEnter and MouseLeave event handler for the hover state of the Splitter Bar */ _handleHoveredState(ownerElement, type) { const that = this; switch (type) { case 'mouseenter': if (!ownerElement._getTargetItem(that, 'previousElementSibling') || !(ownerElement.resizeMode === 'adjacent' ? ownerElement._getTargetItem(that, 'nextElementSibling') : ownerElement._getTargetItem(that, 'previousElementSibling', true))) { return; } that.setAttribute('hover', ''); break; case 'mouseleave': { that.removeAttribute('hover'); break; } } } /** * Mouse Over/Out event handler * @param {any} event */ _mouseEventsHandler(event) { const that = this, ownerElement = that.closest('lw-splitter') || that.getRootNode().host; if (ownerElement && ownerElement.disabled || LW.Utilities.Core.isMobile) { return; } if (event.type === 'mouseenter' || event.type === 'mouseleave') { that._handleHoveredState(ownerElement, event.type); return; } if (event.target.closest('.lw-splitter-far-collapse-button') === that.$.farCollapseButton) { event.type === 'mouseover' ? that.$.farCollapseButton.setAttribute('hover', '') : that.$.farCollapseButton.removeAttribute('hover'); return; } if (event.target.closest('.lw-splitter-near-collapse-button') === that.$.nearCollapseButton) { event.type === 'mouseover' ? that.$.nearCollapseButton.setAttribute('hover', '') : that.$.nearCollapseButton.removeAttribute('hover'); return; } if (event.target.closest('.lw-splitter-resize-button') === that.$.resizeButton) { event.type === 'mouseover' ? that.$.resizeButton.setAttribute('hover', '') : that.$.resizeButton.removeAttribute('hover'); } } }); LW('lw-splitter', class Splitter extends LW.ContentElement { /** * Splitter's properties */ static get properties() { return { 'autoFitMode': { allowedValues: ['end', 'proportional', 'overflow'], value: 'proportional', type: 'string' }, 'dataSource': { value: null, type: 'object?', reflectToAttribute: false }, 'orientation': { allowedValues: ['horizontal', 'vertical'], value: 'vertical', type: 'string' }, 'keepProportionsOnResize': { value: false, type: 'boolean' }, 'resizeMode': { allowedValues: ['none', 'adjacent', 'end', 'proportional'], value: 'adjacent', type: 'string' }, 'resizeStep': { value: 5, type: 'number' }, 'liveResize': { value: false, type: 'boolean' }, 'messages': { extend: true, value: { 'en': { 'invalidIndex': '{{elementType}}: "{{method}}" method accepts an index of type number.', 'indexOutOfBound': '{{elementType}}: Out of bound index/indexes in "{{method}}" method.', 'invalidNode': '{{elementType}}: "{{method}}" method accepts an object or an array of objects as it\'s second parameter.', 'invalidSettings': '{{elementType}}: "{{method}}" method accepts a string or an object as it\'s second parameter.', 'invalidType': '{{elementType}}: "{{propertyName}}" must be of type string or number.' } }, type: 'object' } }; } /** * Splitter's event listeners */ static get listeners() { return { 'focus': '_focusHandler', 'blur': '_focusHandler', 'down': '_downHandler', 'move': '_moveHandler', 'document.dragstart': '_dragStartHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler', 'keydown': '_keyDownHandler', 'resize': '_resizeEventHandler' } } /** * Element ShadowDOM enabler getter */ get enableShadowDOM() { const that = this, enableShadowDOM = LW.EnableShadowDOM; //NOTE: DockingLayout flag for shadowDOM. Splitter insinde DockingLayout do not need to have shadowRoot if (that._isInShadowDOM) { return !that._isInShadowDOM; } if (that.isCompleted) { return that.shadowRoot !== null; } return enableShadowDOM; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.button.css', 'lw.splitter.css' ] } /** * Splitter's HTML template. */ template() { return `<div id="container" role="presentation"> <content></content> </div>`; } /** * Updates the Splitter when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'dataSource': that._createLayout(); break; case 'resizeMode': delete that._dragDetails; break; case 'orientation': { that.bars.forEach(bar => bar.setAttribute('aria-orientation', newValue)); that._setMeasurements(); //Used to avoid the animation if enabled that.setAttribute('orientation-change', ''); for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; if (item.collapsed) { item.style[that._measurements.dimension] = ''; item.style[that._measurements.restricredDimension.toLowerCase()] = '100%'; continue; } if (item.size) { item.style[that._measurements.dimension] = ''; item._setSize('size', item.size, true); } else { item.style[that._measurements.dimension] = item['offset' + that._measurements.restricredDimension] + 'px'; } item.style[that._measurements.restricredDimension.toLowerCase()] = '100%'; item._setSize('min', item.min, true); item._setSize('max', item.max, true); } that._validateItemSize(); //Used to avoid the animation if enabled that.removeAttribute('orientation-change'); break; } case 'unfocusable': that._setFocusable(); break default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Appends a node to the splitter. */ appendChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node || !(node instanceof LW.SplitterItem)) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' })); return } that.insertBefore(node, null); } /** * Called when the element is attached to the DOM */ attached() { super.attached(); const that = this; //Make sure items are calculated properly on attached if (that.isRendered) { that._validateItemSize(); } } /** * Collapses a splitter item * item - Number indicating the index of the item / An isntance of LW.SplitterItem * far - indicates whether the item should collapse to it's far or near side */ collapse(item, far) { const that = this; if (typeof item === 'number') { item = that._items[item]; } if (!item) { return; } const closestSplitter = that.closest('lw-splitter') || (that.getRootNode() && that.getRootNode().host ? that.getRootNode().host.closest('lw-splitter') : undefined); if (item instanceof LW.SplitterItem && closestSplitter === that) { item.collapse(far); return; } if (typeof item !== 'number' || !that._items[item]) { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'collapse' })); return; } item.collapse(far); } /** * Expands a splitter item */ expand(item) { const that = this; if (typeof item === 'number') { item = that._items[item]; } if (!item) { return; } const closestSplitter = that.closest('lw-splitter') || (that.getRootNode() && that.getRootNode().host ? that.getRootNode().host.closest('lw-splitter') : undefined); if (item instanceof LW.SplitterItem && closestSplitter === that) { item.expand(); return; } if (typeof item !== 'number' || !that._items[item]) { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'expand' })); return; } item.expand(); } /** * Hides a splitter bar * index - the valid index of a lwSplitterBar or its instance */ hideBar(item) { const that = this; if (typeof item === 'number') { item = that.bars[item]; } if (!(item instanceof LW.SplitterBar)) { that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'hideBar' })); return; } if (item instanceof LW.SplitterBar && (that.enableShadowDOM ? item.getRootNode().host : item.closest('lw-splitter')) === that) { item.hide(); } } /** * Returns an array of Splitter items that are inside the element */ get items() { const that = this; if (!that.isReady) { return []; } const children = that.$.container.children; let items = []; for (let i = 0; i < children.length; i++) { if (children[i] instanceof LW.SplitterItem || children[i].tagName.toLowerCase() === 'lw-splitter-item') { items.push(children[i]); } } return items; } /** * Insert a new Splitter item at a given position * index - indicates the index at which a new item will be inserted */ insert(index, details) { const that = this; if (typeof details === 'string') { details = { content: details }; } if (!details || typeof details !== 'object') { that.error(that.localize('invalidSettings', { elementType: that.nodeName.toLowerCase(), method: 'insert' })); return; } if (typeof index !== 'number') { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'insert' })); return; } const item = details instanceof LW.SplitterItem ? details : that._createItem(details); if (that.contains(item)) { if (that._items.indexOf(item) === index) { return; } that.removeChild(item); } if (index >= that._items.length || that._items.length === 0) { that.appendChild(item); } else { that.insertBefore(item, that._items[index]); } } /** * Inserts a new node after another node in the splitter. */ insertBefore(node, referenceNode) { const that = this; function validateNodeSize() { const previousItem = function () { let item = node.previousElementSibling; while (item) { if (item instanceof LW.SplitterItem) { return item; } item = item.previousElementSibling; } }(); const lastItem = that._items[0]; if (that.autoFitMode !== 'overflow' && that._items.length === 1) { const isLocked = lastItem.locked; lastItem.locked = false; lastItem._setSize('size', lastItem.size || '', true); lastItem.locked = isLocked; } that._resizeHostItemOnInsert(previousItem, node, splitterBar); if (that._items) { that._items.splice(referenceNode ? that._items.indexOf(referenceNode) : that._items.length, 0, node); } if (previousItem) { if (previousItem.max) { previousItem._setSize('max', previousItem.max, true); } if (previousItem.min) { previousItem._setSize('min', previousItem.min, true); } } that._validateItemSize(); } if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node || !(node instanceof LW.SplitterItem)) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' })); return; } if (referenceNode && !(referenceNode instanceof LW.SplitterItem)) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' })); return; } //Set the restricted to fill the Splitter node.style[that._measurements.restricredDimension.toLowerCase()] = '100%'; if (node.size) { const unit = typeof node.size === 'string' && node.size.indexOf('%') > -1 ? '%' : 'px'; node.style[that._measurements.dimension] = node.size === 'auto' ? node.size : isNaN(parseFloat(node.size)) ? '' : parseFloat(node.size) + unit; if (that.autoFitMode !== 'overflow' && that._items.length === 1) { that._items[0].size = ''; //that._items[0]._setSize('size', that._items[0].size, true); } } else { node.style[that._measurements.dimension] = ''; } if (node._sizeBeforeCollapse) { if (node.size) { const unit = typeof node.size === 'string' && node.size.indexOf('%') > -1 ? '%' : 'px'; node.style[that._measurements.dimension] = (node.size === 'auto' ? node.size : isNaN(parseFloat(node.size)) ? 0 : parseFloat(node.size) + unit); node._sizeBeforeCollapse = node[that._measurements.size]; } else { delete node._sizeBeforeCollapse; } } node.style['max' + that._measurements.restricredDimension] = 'none'; node.style[that._measurements.maxDimension] = node._sizeLimits && node.max ? node._sizeLimits[that._measurements.maxDimension] + 'px' : ''; if (node.collapsed) { node.style.minWidth = node.style.minHeight = ''; node.style[that._measurements.minDimension] = node.style[that._measurements.dimension] = '0'; } else { node.style[that._measurements.minDimension] = node._sizeLimits && node.min ? node._sizeLimits[that._measurements.minDimension] + 'px' : ''; } for (let i = 0; i < that._items.length; i++) { if (!that._items[i]._sizeBeforeCollapse) { that._items[i]._sizeBeforeCollapse = that._items[i][that._measurements.size]; } } that.$.container.insertBefore(node, referenceNode || null); let splitterBar; const currentSplitterBars = that.bars; if (node.previousElementSibling instanceof LW.SplitterItem) { splitterBar = that._createBar(node, node.previousElementSibling); that.$.container.insertBefore(splitterBar, node); } else if (node.nextElementSibling instanceof LW.SplitterItem) { splitterBar = that._createBar(node, node.nextElementSibling); that.$.container.insertBefore(splitterBar, node.nextElementSibling); } if (splitterBar && currentSplitterBars.length > 0) { splitterBar.style[that._measurements.restricredDimension.toLowerCase()] = currentSplitterBars[0].style[that._measurements.restricredDimension.toLowerCase()]; } //MS EDGE specific code. In EDGE browser _validateItemSize() is called before the attached method is called if (!node.isCompleted) { node.__onCompleted = node._onCompleted; node._onCompleted = function () { if (node.__onCompleted) { node.__onCompleted(); delete node.__onCompleted; } validateNodeSize(); } } else { validateNodeSize(); } } /** * Locks a splitter item so it's size can't change. * @param {any} item - the index of a Splitter Item or it's instance */ lockItem(item) { const that = this; if (item instanceof LW.SplitterItem) { item.lock(); return; } if (typeof item !== 'number' || !that._items[item]) { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'lockItem' })); return; } item = that._items[item]; if (item) { item.lock(); } } /** * Locks a splitter bar so it can't be dragged. * @param {any} item - the index of a Splitter Bar or it's instance */ lockBar(item) { const that = this; if (item instanceof LW.SplitterBar) { item.lock(); return; } if (typeof item !== 'number') { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'lockBar' })); return; } item = that.bars[item]; if (item) { item.lock(); } } /** * Set the styleObserver to listen only for resizing */ get hasStyleObserver() { return 'resize'; } /** * Called when the element is ready */ ready() { super.ready(); } render() { const that = this; that.setAttribute('role', 'group'); //a flag used to avoid animations on startup that._isInitializing = true; that._createLayout(); delete that._isInitializing; that._setFocusable(); super.render(); } /** * Refreshes the layout of the element */ refresh() { this._resizeEventHandler(); } /** * Removes a Splitter item at a given position * index - indicates the index at which a new item will be inserted */ removeAt(index) { const that = this; if (index instanceof LW.SplitterItem && index.closest('lw-splitter') === that) { that.removeChild(index); return; } if (typeof index !== 'number') { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'remove' })); return; } if (index > that._items.length || index < 0) { that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'remove' })); return; } that.removeChild(that._items[index]); } /** * Remove all items */ removeAll() { const that = this; that._items = []; that.$.container.innerHTML = ''; } /** * Removes a node from the splitter. */ removeChild(node) { const that = this; function getNewNeighbourItem(deletedItemIndex, item, direction) { let index = deletedItemIndex, newNeighbourItem = that._items[index]; while (newNeighbourItem) { if (!newNeighbourItem.collapsed) { break; } newNeighbourItem = that._items[index += direction] } return newNeighbourItem; } if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node || !(node instanceof LW.SplitterItem)) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' })); return } if (!that._items) { return; } let itemIndex = that._items.indexOf(node); if (node.collapsed) { that.$.container.removeChild(that._items.indexOf(node._neighbourItem) > itemIndex ? node.nextElementSibling : node.previousElementSibling); } else { if (node.previousElementSibling instanceof LW.SplitterBar) { that.$.container.removeChild(node.previousElementSibling); } else if (node.nextElementSibling instanceof LW.SplitterBar) { that.$.container.removeChild(node.nextElementSibling); } } that._items.splice(itemIndex, 1); itemIndex = Math.max(0, itemIndex - 1); let totalItemSize = 0 const uncollapsedItems = that._items.filter(item => !item.collapsed && !item.locked), nodeSize = node._sizeBeforeCollapse || node[that._measurements.size]; uncollapsedItems.map(item => totalItemSize += ((item.style[that._measurements.dimension] ? item._sizeBeforeCollapse : 0) || item[that._measurements.size])); that.$.content.removeChild(node); //If all left items are collapsed, force uncollapsing of the last item if ((that._items.length === 1 && that._items[0].collapsed) || (that._items.length > 0 && that._items.map(item => item.collapsed).indexOf(false) < 0)) { const lastItem = that._items[that._items.length - 1]; let context = lastItem.context; lastItem.context = lastItem; lastItem._expand(); lastItem.context = context; } for (let i = 0; i < that._items.length; i++) { if (that._items[i].collapsed && that._items[i]._neighbourItem === node) { let splitterBar, splitterBarContext; that._items[i]._neighbourItem = getNewNeighbourItem(itemIndex, that._items[i], 1); if (!that._items[i]._neighbourItem) { that._items[i]._neighbourItem = getNewNeighbourItem(itemIndex, that._items[i], -1); splitterBar = that._items[i].previousElementSibling; if (splitterBar) { splitterBarContext = splitterBar.context; splitterBar.context = splitterBar; splitterBar.itemCollapsed = true; splitterBar.showFarButton = !(splitterBar.showNearButton = false); splitterBar.context = splitterBarContext; } } else { splitterBar = that._items[i].nextElementSibling; if (splitterBar) { splitterBarContext = splitterBar.context; splitterBar.context = splitterBar; splitterBar.itemCollapsed = true; splitterBar.showNearButton = !(splitterBar.showFarButton = false); splitterBar.context = splitterBarContext; } } } } if (that.autoFitMode === 'proportional') { let currentItemSize, newSize, itemMinSize; for (let i = 0; i < uncollapsedItems.length; i++) { currentItemSize = uncollapsedItems[i]._sizeBeforeCollapse || uncollapsedItems[i][that._measurements.size]; newSize = currentItemSize + (nodeSize * (currentItemSize / totalItemSize)); //Check for item min size itemMinSize = uncollapsedItems[i]._sizeLimits[that._measurements.minDimension] || 0; uncollapsedItems[i].style[that._measurements.dimension] = (uncollapsedItems[i]._sizeBeforeCollapse = Math.max(0, newSize)) + 'px'; if (itemMinSize > currentItemSize) { uncollapsedItems[i][that._measurements.minDimension] = newSize + 'px'; } } } that._autoFitItems(); } /** * Unhides a Splitter Bar * item - the index of the splitter bar or it's instance */ showBar(item) { const that = this; if (item instanceof LW.SplitterBar) { item.show(); return; } if (typeof item !== 'number') { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'showBar' })); return; } item = that.bars[item]; if (!(item instanceof LW.SplitterBar)) { that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'showBar' })); return; } item.show(); } /** * Returns an array of Splitter items that are inside the element */ get bars() { const that = this; if (!that.isReady) { // return Array.from(that.querySelectorAll('lw-splitter-bar')); return []; } const children = that.$.container.children; let items = []; for (let i = 0; i < children.length; i++) { if (children[i] instanceof LW.SplitterBar || children[i].tagName.toLowerCase() === 'lw-splitter-bar') { items.push(children[i]); } } return items; } /** * Unlocks a previously locked splitter item * @param {any} item - the index of a Splitter Item or it's instance */ unlockItem(item) { const that = this; if (item instanceof LW.SplitterItem) { item.unlock(); return; } if (typeof item !== 'number' || !that._items[item]) { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'unlockItem' })); return; } item = that._items[item]; if (item) { item.unlock(); } } /** * Unlocks a previously locked splitter bar * @param {any} item - the index of a Splitter Bar or it's instance */ unlockBar(item) { const that = this; if (item instanceof LW.SplitterBar) { item.unlock(); return; } if (typeof item !== 'number') { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'unlockBar' })); return; } item = that.bars[item]; if (item) { item.unlock(); } } /** * Updates the Splitter item's properties * @param {any} index - index of the splitter item * @param {any} settings - object of properties and value */ update(item, settings) { const that = this; if (typeof item === 'number') { item = that._items[item]; if (!item) { that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'update' })); return; } } if (!(item instanceof LW.SplitterItem) || !settings || (that.enableShadowDOM ? item.getRootNode().host : that.closest('lw-splitter')) !== that) { return; } for (let key in settings) { if (item[key] !== undefined) { item[key] = settings[key]; } } } /** * Fits the last item according to the free space left in the Splitter. */ _autoFitItems() { const that = this, itemsCount = that._items.length; if (itemsCount === 0 || that.autoFitMode === 'overflow') { return; } let lastItem, lockedItems = [], collapsedItems = [], itemsWithoutSize = []; for (let i = itemsCount - 1; i >= 0; i--) { if (that._items[i].collapsed) { collapsedItems.push(that._items[i]); } else if (that._items[i].locked) { lockedItems.push(that._items[i]); } else if (!lastItem) { lastItem = that._items[i]; } else if (!that._items[i].size) { itemsWithoutSize.push(that._items[i]); } } if (lastItem && lastItem.size && itemsWithoutSize.length > 0) { lastItem = itemsWithoutSize.filter(item => !item.max && !item._sizeLimits[that._measurements.maxDimension])[0] || lastItem; } if (collapsedItems.length === itemsCount) { lastItem = collapsedItems[0]; lastItem.expand(); lastItem.unlock(); } that._autoFitLastItem(lastItem, collapsedItems, lockedItems); } /** * AutoFits the items by shrinking the last item. */ _autoFitLastItem(lastItem, collapsedItems, lockedItems) { const that = this, itemsCount = that._items.length; let lastLockedItem; if (itemsCount === 1 && that._items[0].locked) { lastLockedItem = that._items[0]; lastLockedItem.locked = false; } if (lockedItems.length === itemsCount) { lockedItems[0].unlock(); } if (!lastItem) { lastItem = lockedItems[0]; lastItem.unlock(); } if (that._items.length === 1) { lastItem._setSize('size', '100%', true); delete lastItem._originalSize; } else { let totalItemSize = 0, totalBarsSize = 0; that._items.map(item => totalItemSize += !item.collapsed ? (item.style[that._measurements.dimension] && item.style[that._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ? item._sizeBeforeCollapse : item.getBoundingClientRect()[that._measurements.dimension]) : 0); that.bars.map(bar => totalBarsSize += bar[that._measurements.size]); const currentSplitterSize = totalItemSize + totalBarsSize, containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension]; if (currentSplitterSize !== containerSize) { let lastItemSize; if (lastItem.style[that._measurements.dimension].indexOf('%') < -1) { lastItemSize = lastItem._sizeBeforeCollapse ? lastItem._sizeBeforeCollapse : lastItem.getBoundingClientRect()[that._measurements.dimension]; } else { lastItemSize = lastItem.getBoundingClientRect()[that._measurements.dimension]; } let sizeDifference = Math.abs(containerSize - currentSplitterSize), sign = currentSplitterSize < containerSize ? 1 : -1; const newSize = Math.max(0, (lastItemSize + sign * sizeDifference)); lastItem.style[that._measurements.dimension] = (lastItem._sizeBeforeCollapse = newSize) + 'px'; delete lastItem._originalSize; that._validateItemLimits(lastItem, newSize); } } if (lastLockedItem) { lastLockedItem.locked = true; } } /** * Validates * @param {any} item - the target Splitter item * @param {any} newSize - the new size of the target Splitter item */ _validateItemLimits(item, newSize) { const that = this, containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension]; let isPercentage, expectedSize, sizeLimit; sizeLimit = item._min || item.min; if (sizeLimit) { isPercentage = typeof sizeLimit === 'string' && sizeLimit.indexOf('%') > -1; expectedSize = isPercentage ? parseFloat(sizeLimit) * containerSize / 100 : parseFloat(sizeLimit); if (expectedSize > newSize) { item.style[that._measurements.minDimension] = isPercentage ? (newSize * 100 / containerSize) + '%' : (newSize + 'px'); item._sizeLimits[that._measurements.minDimension] = newSize; item._min = sizeLimit; item.set('min', item.style[that._measurements.minDimension]); } else if (expectedSize < newSize) { item.style[that._measurements.minDimension] = isPercentage ? (expectedSize * 100 / containerSize) + '%' : (expectedSize + 'px'); item._sizeLimits[that._measurements.minDimension] = expectedSize; item.set('min', sizeLimit); delete item._min; } } sizeLimit = item._max || item.max; if (sizeLimit) { isPercentage = typeof sizeLimit === 'string' && sizeLimit.indexOf('%') > -1; expectedSize = isPercentage ? parseFloat(sizeLimit) * containerSize / 100 : parseFloat(sizeLimit); if (expectedSize < newSize) { item.style[that._measurements.maxDimension] = isPercentage ? (newSize * 100 / containerSize) + '%' : (newSize + 'px'); item._sizeLimits[that._measurements.maxDimension] = newSize; item._max = sizeLimit; item.set('max', item.style[that._measurements.maxDimension]); } else if (expectedSize > newSize) { item.style[that._measurements.maxDimension] = isPercentage ? (expectedSize * 100 / containerSize) + '%' : (expectedSize + 'px'); item._sizeLimits[that._measurements.maxDimension] = expectedSize; item.set('max', sizeLimit); delete item._max; } } } /** * AutoFits the items by proportionally reducing the size of all items */ _autoFitItemsProportionally(newItem, splitterBar) { const that = this, uncollapsedItems = that._items.filter(item => !item.collapsed && !item.locked); let newItemSize = newItem[that._measurements.size], totalItemSize = 0; uncollapsedItems.map(item => totalItemSize += item._sizeBeforeCollapse || item[that._measurements.size]); if (splitterBar) { totalItemSize -= splitterBar[that._measurements.size]; } if (newItem.size && !newItem.isCompleted) { newItem._setSize('size', newItemSize); newItemSize = newItem._sizeBeforeCollapse; } newItemSize = Math.min(that.$.container[that._measurements.size] / 2, newItem[that._measurements.size]); if (typeof newItem.size === 'string' && newItem.size.indexOf('%') > -1) { const containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension]; newItem._sizeBeforeCollapse = newItemSize; newItem.style[that._measurements.dimension] = (newItemSize * 100 / containerSize) + '%'; } else { newItem.style[that._measurements.dimension] = (newItem._sizeBeforeCollapse = newItemSize) + 'px'; } let currentItemSize, newSize, itemMinSize; for (let i = 0; i < uncollapsedItems.length; i++) { currentItemSize = uncollapsedItems[i]._sizeBeforeCollapse || uncollapsedItems[i][that._measurements.size]; newSize = (totalItemSize - newItemSize) * (currentItemSize / totalItemSize); //Check for item min size itemMinSize = uncollapsedItems[i]._sizeLimits[that._measurements.minDimension] || 0; uncollapsedItems[i].style[that._measurements.dimension] = (uncollapsedItems[i]._sizeBeforeCollapse = Math.max(itemMinSize, newSize)) + 'px'; delete uncollapsedItems[i]._originalSize; } } /** * Reads the dataSource and populates the Splitter with items. */ _createLayout() { const that = this; that._items = []; if (typeof that.dataSource === 'string') { that.dataSource = JSON.parse(that.dataSource); } if (that.dataSource !== null && Array.isArray(that.dataSource)) { that.$.container.innerHTML = ''; let fragment = document.createDocumentFragment(), item; for (let i = 0; i < that.dataSource.length; i++) { item = that._createItem(that.dataSource[i]); fragment.appendChild(item); } that._handleSplitterBars(fragment); return; } that._handleSplitterBars(that.$.container); } /** * Creates a splitter bar * @param {any} item - the item that precedes a splitter item */ _createBar(item, neighbourItem) { const that = this, splitBar = document.createElement('lw-splitter-bar'); if (item.collapsed) { splitBar.itemCollapsed = true; if (that._items.indexOf(item) === that._items.length - 1) { splitBar.showNearButton = true; } else { splitBar.showFarButton = true; } } else { if (item.collapsible) { splitBar.showNearButton = true; } if (neighbourItem && neighbourItem instanceof LW.SplitterItem && neighbourItem.collapsible) { neighbourItem === item.nextElementSibling ? splitBar.showFarButton = true : splitBar.showNearButton = true; } } splitBar.setAttribute('aria-controls', item.id + (neighbourItem ? ' ' + neighbourItem.id : '')); splitBar.setAttribute('aria-orientation', that.orientation); return splitBar; } /** * Creates a splitter item */ _createItem(data) { const item = document.createElement('lw-splitter-item'); if (data.id) { item.id = data.id; } item.innerHTML = data.content || ''; item.collapsible = data.collapsible || false; item.collapsed = data.collapsed || false; item.locked = data.locked || false; if (data.max) { item.max = data.max; } if (data.min) { item.min = data.min; } if (data.size) { item.size = data.size; } return item; } /** * Finishes the resizing operation */ _completeResizing(canceled) { const that = this; if (that._dragDetails) { if (that._splitBarDummy && that._splitBarDummy.parentElement) { if (!canceled) { that._dragDetails.firstItem.style[that._measurements.dimension] = (that._dragDetails.firstItem._sizeBeforeCollapse = that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings) + 'px'; delete that._dragDetails.firstItem._originalSize; if (that.resizeMode !== 'proportional') { that._dragDetails.secondItem.style[that._measurements.dimension] = (that._dragDetails.secondItem._sizeBeforeCollapse = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that._dragDetails.secondItem._paddings) + 'px'; delete that._dragDetails.secondItem._originalSize; } else { const itemCount = that._dragDetails.itemProportions.length; if (itemCount > 1) { for (let p = 0; p < itemCount; p++) { that._dragDetails.itemProportions[p].item.style[that._measurements.dimension] = (that._dragDetails.itemProportions[p].item._sizeBeforeCollapse = that._dragDetails.itemProportions[p].currentSize + that._dragDetails.itemProportions[p].item._paddings) + 'px'; delete that._dragDetails.itemProportions[p]._originalSize; } } else { that._dragDetails.secondItem[0].style[that._measurements.dimension] = (that._dragDetails.secondItem[0]._sizeBeforeCollapse = Math.floor(that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings)) + 'px'; delete that._dragDetails.secondItem[0]._originalSize; } } } that._validateBarsSize(); that.$.fireEvent('resizeEnd', { firstItem: { index: that._items.indexOf(that._dragDetails.firstItem), oldSize: that._dragDetails.firstItem.originalSize, newSize: that._dragDetails.firstItem[that._measurements.size] }, secondItem: Array.isArray(that._dragDetails.secondItem) ? { index: that._dragDetails.secondItem.map(item => that._items.indexOf(item)), oldSize: that._dragDetails.secondItem.map(item => item.originalSize), newSize: that._dragDetails.secondItem.map(item => item[that._measurements.size]) } : { index: that._items.indexOf(that._dragDetails.secondItem), oldSize: that._dragDetails.secondItem.originalSize, newSize: that._dragDetails.secondItem[that._measurements.size] } }); that._splitBarDummy.classList.remove('limit-reached'); that._splitBarDummy.parentElement.removeChild(that._splitBarDummy); } that.removeAttribute('dragged'); delete that._dragDetails; delete that._keyboardResizing; } } /** * Document DragStart event handler * @param {any} event */ _dragStartHandler(event) { const that = this; if (that._dragDetails) { event.preventDefault(); } } /** * Splitter mouse down event handler */ _downHandler(event) { const that = this; event.stopPropagation(); if (that.disabled) { return; } if (that._keyboardResizing) { that._completeResizing(); return; } const target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; let closestSplitter = target.closest('lw-splitter'); if (!closestSplitter) { closestSplitter = target.getRootNode() && target.getRootNode().host ? target.getRootNode().host.closest('lw-splitter') : undefined; } const closestSplitterBar = target && target.closest ? target.closest('lw-splitter-bar') : null; if (closestSplitterBar && closestSplitter === that) { //Collapse Near item if (target.closest('.lw-splitter-near-collapse-button') === closestSplitterBar.$.nearCollapseButton) { that._collapseButtonPressed = { splitBar: closestSplitterBar, item: closestSplitterBar.previousElementSibling, target: closestSplitterBar.$.nearCollapseButton, farCollapse: false }; return; } //Collapse far item if (target.closest('.lw-splitter-far-collapse-button') === closestSplitterBar.$.farCollapseButton) { that._collapseButtonPressed = { splitBar: closestSplitterBar, item: closestSplitterBar.nextElementSibling, target: closestSplitterBar.$.farCollapseButton, farCollapse: true }; return; } if (!closestSplitterBar.itemCollapsed && !closestSplitterBar.locked && that.resizeMode !== 'none') { that._setDragDetails(closestSplitterBar, event); } } } /** * iOS Safari bug fix. (iOS Safari doesn't support 'touch-action: none') */ _moveHandler() { if (this.hasAttribute('dragged') && LW.Utilities.Core.isMobile) { event.originalEvent.preventDefault(); } } /** * Document move event handler */ _documentMoveHandler(event) { const that = this; if (that._keyboardResizing || that.disabled) { return; } that._resize(event); } /** * Document move event handler */ _documentUpHandler(event) { const that = this; that.removeAttribute('dragging-not-allowed'); that.removeAttribute('show-locked-items'); if (that.disabled) { delete that._dragDetails; delete that._collapseButtonPressed; return; } const target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; that._completeResizing(); if (that._collapseButtonPressed && target.closest('.' + that._collapseButtonPressed.target.classList[0]) === that._collapseButtonPressed.target) { if (that._collapseButtonPressed.item.collapsed) { that.expand(that._collapseButtonPressed.item); } else { that.collapse(that._collapseButtonPressed.item, that._collapseButtonPressed.farCollapse); } delete that._collapseButtonPressed; return; } } /** * Ensures that all items are attached and ready. * @param {any} nodes - nodes that are not ready * @param {any} callback - a function to be called when all items are ready */ _ensureItemsReady(nodes, callback) { const that = this; const contextCallback = function () { const setContext = function (context) { for (let i = 0; i < nodes.length; i++) { nodes[i].context = context === 'node' ? nodes[i] : document; } } setContext('node'); callback(); setContext(); } if (nodes.length === 0) { contextCallback(); } else { that._nodesReadyListeners = 0; for (let i = 0; i < nodes.length; i++) { const node = nodes[i]; const readyEventHandler = function () { that._nodesReadyListeners--; if (that._nodesReadyListeners === 0) { contextCallback(); delete that._nodesReadyListeners; } }.bind(that); if (!node.isCompleted) { that._nodesReadyListeners++; node._onCompleted = readyEventHandler; } } if (that._nodesReadyListeners === 0) { contextCallback(); } } } /** * Element's focus handler */ _focusHandler(event) { const that = this; event.type === 'focus' ? that.setAttribute('focus', '') : that.removeAttribute('focus'); } /** * Used in _setDragDetails() method to get the desired item ( first and second ) * @param {any} sibling - next item * @param {any} reverse - reverse order flag */ _getTargetItem(splitter, sibling, reverse) { const that = this; let previousItem = reverse ? that._items[that._items.length - 1] : splitter[sibling]; while (previousItem) { if (previousItem instanceof LW.SplitterItem && !previousItem.collapsed) { if (!previousItem.locked) { return previousItem; } if (that._dragDetails && !that._dragDetails.firstItem) { that._dragDetails.lockedItemsSize += previousItem[that._measurements.size] + (previousItem.previousElementSibling instanceof LW.SplitterBar ? previousItem.previousElementSibling[that._measurements.size] : 0); } } previousItem = previousItem[sibling]; } } /** * Adds/Removes split bars */ _handleSplitterBars(itemContainer) { const that = this; if (that._items.length < 1) { //IE11 has no support for DocumentFragment.children. Use childNodes instead if no polyfill is provided that._items = itemContainer.parentElement ? that.items : Array.from(itemContainer.children); } if (!that._measurements) { that._setMeasurements(); } if (that._items.length < 2) { const splitBars = that.bars; for (let i = 0; i < splitBars.length; i++) { itemContainer.removeChild(splitBars[i]); } } //Note: attached() is called after render() of the SplitterIte //This flag doesn't allow item size validation that._noItemSizeValidation = true; if (!itemContainer.parentElement && itemContainer !== that.$.container) { that.$.container.appendChild(itemContainer); itemContainer = that.$.container; } that._noItemSizeValidation = false; let item; for (let i = 0; i < that._items.length; i++) { item = that._items[i]; //Remvoes all elements before the first item if (i === 0) { while (itemContainer.firstElementChild && itemContainer.firstElementChild !== item) { itemContainer.removeChild(itemContainer.firstElementChild); } } item.style[that._measurements.restricredDimension.toLowerCase()] = '100%'; item.style['max' + that._measurements.restricredDimension] = 'none'; if (!item.size) { item.style[that._measurements.dimension] = item._sizeBeforeCollapse ? item._sizeBeforeCollapse + 'px' : ''; } const min = item.min, max = item.max; if (typeof min === 'string' && min.indexOf('%') > -1) { item._setSize('min', min); } if (typeof max === 'string' && max.indexOf('%') > -1) { item._setSize('max', max); } item.style[that._measurements.maxDimension] = item.max ? item._sizeLimits[that._measurements.maxDimension] + 'px' : ''; if (item.nextElementSibling) { let nextElementSibling = item.nextElementSibling; //Create a SplitterBar between the two items if (nextElementSibling instanceof LW.SplitterItem || nextElementSibling.tagName.toLowerCase() === 'lw-splitter-item') { item.parentNode.insertBefore(that._createBar(item, item.nextElementSibling), item.nextElementSibling); } else { if (nextElementSibling instanceof LW.SplitterBar || nextElementSibling.tagName.toLowerCase() === 'lw-splitter-bar') { nextElementSibling = nextElementSibling.nextElementSibling; } //Remove any between the items while (nextElementSibling && (!(nextElementSibling instanceof LW.SplitterItem) || (nextElementSibling.tagName.toLowerCase() !== 'lw-splitter-item'))) { nextElementSibling.parentNode.removeChild(nextElementSibling); nextElementSibling = nextElementSibling.nextElementSibling; } } } if (item.collapsed) { const collapsible = item.collapsible; item.style.minWidth = item.style.minHeight = ''; item.style[that._measurements.minDimension] = '0'; item._ignorePropertyValue = true; //Force collapse it item.collapsible = true; item.collapse(); //Return original proeprty value item.collapsible = collapsible; } else { item.style[that._measurements.minDimension] = item._sizeLimits && item.min ? item._sizeLimits[that._measurements.minDimension] + 'px' : ''; } } //Remvoes all unnecessary elements after the last item if (item) { while (itemContainer.lastElementChild !== item) { itemContainer.removeChild(itemContainer.lastElementChild); } } //MS EDGE fix when items are supposed to be ready but they are not yet that._ensureItemsReady(that._items, that._validateItemSize.bind(that)); } /** * Key down event handler * @param {any} event */ _keyDownHandler(event) { const that = this; if (that.disabled) { return; } let splitterBar = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement; if (event.key === 'w' && event.altKey) { //Prevents container scrolling event.preventDefault(); const firstItem = that.enableShadowDOM ? that.shadowRoot.querySelector('lw-splitter-bar') : that.querySelector('lw-splitter-bar'); if (splitterBar !== firstItem) { that._completeResizing(true); } firstItem.focus(); return; } if (!event.ctrlKey && that._splitBarDummy && that._splitBarDummy.parentElement) { splitterBar = that._splitBarDummy; } else if (!(splitterBar instanceof LW.SplitterBar)) { return; } if ((that.enableShadowDOM ? splitterBar.getRootNode().host : splitterBar.closest('lw-splitter')) !== that) { return; } switch (event.key) { case 'ArrowLeft': case 'ArrowRight': case 'ArrowUp': case 'ArrowDown': { if ((event.key === 'ArrowUp' || event.key === 'ArrowDown') && that.orientation === 'vertical') { return; } if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight') && that.orientation === 'horizontal') { return; } //Prevents container scrolling event.preventDefault(); const direction = event.key === 'ArrowLeft' || event.key === 'ArrowUp' ? -1 : 1; if (event.ctrlKey) { //Cancel resizing if it's in motion that._completeResizing(true); let neighbourItem, targetItem; if (direction < 0) { targetItem = splitterBar.previousElementSibling; neighbourItem = splitterBar.nextElementSibling; } else { neighbourItem = splitterBar.previousElementSibling; targetItem = splitterBar.nextElementSibling; } neighbourItem.collapsed ? neighbourItem.expand() : targetItem.collapse(direction > 0); return; } if (splitterBar.locked) { return; } if (that.resizeMode === 'none') { return; } that._keyboardResizing = true; let currentPosition; if (!that._dragDetails) { that._setDragDetails(splitterBar); currentPosition = splitterBar[that._measurements.offset] + direction * that.resizeStep; } else { currentPosition = that._dragDetails.position + direction * that.resizeStep; } //Requires event parameter so we imitate it with an object that._resize({ pageX: currentPosition, pageY: currentPosition }); break; } case 'Enter': that._completeResizing(); break; case 'Escape': case 'Tab': that._completeResizing(true); break; } } /** * Mouse Enter/Leave event handler * @param {any} event */ _mouseEventsHandler(event) { event.type === 'mouseenter' && !LW.Utilities.Core.isMobile ? this.setAttribute('hover', '') : this.removeAttribute('hover'); } /** * Used to recalculate the Proportions during resizing when resizeMode is 'proportional' * @param {any} amount - amount of size that has changed since the start of the operation till now * @param {any} totalItemsCount - total number of all items that are being resized * @param {any} resizableItemsCount - the number of items that can be resized. */ _recalcItemSize(amount, totalItemsCount, resizableItemsCount) { const that = this; let usedSize, minSize; if (!resizableItemsCount) { resizableItemsCount = totalItemsCount; } if (amount > 0) { for (let p = 0; p < totalItemsCount; p++) { minSize = that._dragDetails.itemProportions[p].item._sizeLimits[that._measurements.minDimension]; if (that._dragDetails.itemProportions[p].currentSize > minSize) { if (that._dragDetails.itemProportions[p].currentSize - minSize < amount / resizableItemsCount) { usedSize = that._dragDetails.itemProportions[p].currentSize - minSize; } else { usedSize = amount / resizableItemsCount; } amount -= usedSize; that._dragDetails.itemProportions[p].currentSize = Math.max(minSize, that._dragDetails.itemProportions[p].currentSize - usedSize); delete that._dragDetails.itemProportions[p]._originalSize; } resizableItemsCount = Math.max(1, resizableItemsCount - 1); } } else { const maxSize = (that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize) - (totalItemsCount > 1 ? that._dragDetails.secondItemTotalMinSize - that._dragDetails.itemProportions[0].item._sizeLimits[that._measurements.minDimension] : 0); let itemMaxSize; for (let p = 0; p < totalItemsCount; p++) { if (that._dragDetails.itemProportions[p].item._sizeLimits[that._measurements.maxDimension]) { itemMaxSize = Math.min(that._dragDetails.itemProportions[p].item._sizeLimits[that._measurements.maxDimension], maxSize); } else { itemMaxSize = maxSize; } if (that._dragDetails.itemProportions[p].currentSize < itemMaxSize) { if (that._dragDetails.itemProportions[p].currentSize - amount / resizableItemsCount > itemMaxSize) { usedSize = -1 * (itemMaxSize - that._dragDetails.itemProportions[p].currentSize); } else { usedSize = amount / resizableItemsCount; } amount -= usedSize; that._dragDetails.itemProportions[p].currentSize = Math.min(itemMaxSize, that._dragDetails.itemProportions[p].currentSize - usedSize); delete that._dragDetails.itemProportions[p]._originalSize; } resizableItemsCount = Math.max(1, resizableItemsCount - 1); } } //size less than 0.1 is too small to care. JS can't compute properly with too small values if (Math.abs(amount) > 0.1) { that._recalcItemSize(amount, totalItemsCount, resizableItemsCount); } } /** * Resizes the splitter items */ _resize(event) { const that = this; if (!that._dragDetails) { return; } let distance = event[that._measurements.pagePosition] - that._dragDetails.position, isLimitReached; const direction = Math.sign(distance), firstItemMinSize = that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension], firstItemMaxSize = that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension]; let sizeAvailable, isPossibleToResize; if (!that.hasAttribute('dragged')) { that.$.fireEvent('resizeStart', { firstItem: { index: that._items.indexOf(that._dragDetails.firstItem), size: that._dragDetails.firstItem[that._measurements.size] }, secondItem: Array.isArray(that._dragDetails.secondItem) ? { index: that._dragDetails.secondItem.map(item => that._items.indexOf(item)), size: that._dragDetails.secondItem.map(item => item[that._measurements.size]) } : { index: that._items.indexOf(that._dragDetails.secondItem), size: that._dragDetails.secondItem[that._measurements.size] } }); } that.setAttribute('dragged', ''); if (Math.abs(distance) < that.resizeStep) { return; } let coercedDistance = Math.max(that.resizeStep, Math.floor(Math.abs(distance) / that.resizeStep) * that.resizeStep); const offset = distance - (direction * coercedDistance); switch (that.resizeMode) { case 'adjacent': case 'end': if (direction > 0) { sizeAvailable = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize; isPossibleToResize = () => sizeAvailable - that._dragDetails.secondItemTotalMinSize >= coercedDistance || (firstItemMaxSize && that._dragDetails.firstItem.currentSize + that.resizeStep <= firstItemMaxSize); isLimitReached = () => (firstItemMaxSize && that._dragDetails.firstItem.currentSize === firstItemMaxSize) || sizeAvailable - that.resizeStep <= that._dragDetails.secondItemTotalMinSize; } else { sizeAvailable = that._dragDetails.firstItem.currentSize; isPossibleToResize = () => sizeAvailable - firstItemMinSize >= coercedDistance || (that._dragDetails.secondItemTotalMaxSize && that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that.resizeStep <= that._dragDetails.secondItemTotalMaxSize); isLimitReached = () => (that._dragDetails.secondItemTotalMaxSize && that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize === that._dragDetails.secondItemTotalMaxSize) || sizeAvailable - that.resizeStep <= firstItemMinSize; } distance = 0; while (coercedDistance > 0) { if (isPossibleToResize()) { distance += direction * that.resizeStep; } coercedDistance -= that.resizeStep; } that._resizeItem(event, distance, offset); break; case 'proportional': { const initialRemainingSpace = (that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize); if (direction > 0) { sizeAvailable = Math.abs(initialRemainingSpace - that._dragDetails.secondItemTotalMinSize); isPossibleToResize = () => sizeAvailable >= coercedDistance || (firstItemMaxSize && that._dragDetails.firstItem.currentSize + that.resizeStep <= firstItemMaxSize); isLimitReached = () => (firstItemMaxSize && that._dragDetails.firstItem.currentSize === firstItemMaxSize) || that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize - that.resizeStep < that._dragDetails.secondItemTotalMinSize; } else { sizeAvailable = that._dragDetails.firstItem.currentSize; //TODO: ResizeStep is not taken into account properly isPossibleToResize = () => sizeAvailable - firstItemMinSize >= coercedDistance && (that._dragDetails.secondItemTotalMaxSize ? that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that.resizeStep <= that._dragDetails.secondItemTotalMaxSize : true); isLimitReached = () => (that._dragDetails.secondItemTotalMaxSize && that._dragDetails.splitAreaSize + that.resizeStep - that._dragDetails.firstItem.currentSize >= that._dragDetails.secondItemTotalMaxSize) || that._dragDetails.firstItem.currentSize - that.resizeStep < firstItemMinSize; } let newSize, isResized; while (coercedDistance > 0) { if (isPossibleToResize()) { isResized = true; newSize = Math.min(firstItemMaxSize ? Math.min(firstItemMaxSize, that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize) : that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize, Math.max(firstItemMinSize, that._dragDetails.firstItem.currentSize + direction * that.resizeStep)); that._dragDetails.firstItem.currentSize = that._dragDetails.firstItem._sizeBeforeCollapse = Math.floor(newSize); } coercedDistance -= that.resizeStep; } if (!isResized) { break; } const remaningSpaceAfterResize = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize, itemCount = that._dragDetails.itemProportions.length; //Recalculate the proportions that._recalcItemSize(initialRemainingSpace - remaningSpaceAfterResize, itemCount); if (that.liveResize) { that._dragDetails.firstItem.style[that._measurements.dimension] = (that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings) + 'px'; if (itemCount > 1) { for (let p = 0; p < itemCount; p++) { that._dragDetails.itemProportions[p].item.style[that._measurements.dimension] = that._dragDetails.itemProportions[p].item._sizeBeforeCollapse = (that._dragDetails.itemProportions[p].currentSize + that._dragDetails.itemProportions[p].item._paddings) + 'px'; } } else { that._dragDetails.secondItem[0].style[that._measurements.dimension] = (that._dragDetails.secondItem[0]._sizeBeforeCollapse = Math.floor(remaningSpaceAfterResize + that._dragDetails.itemProportions[0].item._paddings)) + 'px'; } } else { that._splitBarDummy.style[that._measurements.position] = (that._dragDetails.firstItem[that._measurements.offset] + that._dragDetails.firstItem.currentSize + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings) + 'px'; } const edge = that._dragDetails.firstItem.getBoundingClientRect()[that.orientation === 'vertical' ? 'left' : 'top'] + that._dragDetails.splitBarOffset; const maxPosition = firstItemMaxSize && that._dragDetails.splitAreaSize - firstItemMaxSize > that._dragDetails.secondItemTotalMinSize ? firstItemMaxSize : that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize; that._dragDetails.position = Math.max(edge + (that._dragDetails.secondItemTotalMaxSize ? Math.max(that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMaxSize, firstItemMinSize) : firstItemMinSize) + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings, Math.min(edge + maxPosition + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings, event[that._measurements.pagePosition] - offset)); break; } } if (!that.liveResize) { isLimitReached() ? that._splitBarDummy.classList.add('limit-reached') : that._splitBarDummy.classList.remove('limit-reached'); } //Should be called only when Splitter's width is auto that._validateBarsSize(); } /** * Style Changed Event Handler - Refits the items if necessary */ _resizeEventHandler() { const that = this; if (!that._items) { return; } that._resizeEventFired = true; that._validateItemSize(); that._resizeEventFired = false } /** * Resize the host item when inserting a new one inside it * @param {any} hostItem */ _resizeHostItemOnInsert(hostItem, newItem, splitterBar) { const that = this; if (that.autoFitMode === 'proportional') { that._autoFitItemsProportionally(newItem, splitterBar); return; } if (!hostItem || hostItem.locked || that.autoFitMode === 'overflow') { return; } if (newItem.size) { const itemWithoutSize = function () { let item = newItem.previousElementSibling; while (item) { if (item instanceof LW.SplitterItem && !item.size) { return item; } item = item.previousElementSibling; } }(); hostItem = itemWithoutSize || hostItem; } const hostItemNewSize = hostItem[that._measurements.size] - newItem[that._measurements.size] - splitterBar[that._measurements.size], hostItemSize = Math.max(hostItem._sizeLimits[that._measurements.minDimension], hostItemNewSize); hostItem.style[that._measurements.maxDimension] = hostItem.max ? isNaN(parseFloat(hostItem.max)) ? '' : (parseFloat(hostItem.max) + typeof hostItem.max === 'string' && hostItem.max.indexOf('%') > -1 ? '%' : 'px') : ''; //StyleChanged not fired yet const hostItemMax = hostItem.style[that._measurements.maxDimension] ? parseFloat(hostItem.style[that._measurements.maxDimension]) : 0; if (newItem.size) { hostItem.style[that._measurements.dimension] = (hostItem._sizeBeforeCollapse = hostItemMax ? Math.min(hostItemMax, hostItemSize) : hostItemSize) + 'px'; } else { hostItem.style[that._measurements.dimension] = hostItem.size ? (hostItem.size === 'auto' ? hostItem.size : isNaN(parseFloat(hostItem.size)) ? 0 : parseFloat(hostItem.size) + (typeof hostItem.size === 'string' && hostItem.size.indexOf('%') > -1 ? '%' : 'px')) : ''; hostItem._sizeBeforeCollapse = hostItem[that._measurements.size]; } } /** * Resize a single item * @param {any} event * @param {any} distance * @param {any} offset */ _resizeItem(event, distance, offset) { const that = this; //Validate min accoridng to first Item let newSize = Math.max(that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension], Math.min(that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension], that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension] ? Math.min(that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension], that._dragDetails.firstItem.currentSize + distance) : that._dragDetails.firstItem.currentSize + distance)); let minSize = that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension]; if (that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension] && that._dragDetails.splitAreaSize - newSize > that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension]) { minSize = newSize = that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension]; } that._dragDetails.firstItem.currentSize = newSize; if (that.liveResize) { that._dragDetails.firstItem.style[that._measurements.dimension] = (that._dragDetails.firstItem._sizeBeforeCollapse = newSize + that._dragDetails.firstItem._paddings) + 'px'; that._dragDetails.secondItem.style[that._measurements.dimension] = (that._dragDetails.secondItem._sizeBeforeCollapse = that._dragDetails.splitAreaSize - newSize + that._dragDetails.firstItem._paddings) + 'px'; //Reset the original size delete that._dragDetails.firstItem._originalSize; delete that._dragDetails._originalSize; } else { //TODO: Doesn't include collpased items offset that._splitBarDummy.style[that._measurements.position] = (that._dragDetails.firstItem[that._measurements.offset] + newSize + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings) + 'px'; } const edge = that._dragDetails.firstItem.getBoundingClientRect()[that.orientation === 'vertical' ? 'left' : 'top'] + that._dragDetails.splitBarOffset; that._dragDetails.position = Math.max(edge + minSize + that._dragDetails.firstItem._paddings, Math.min(edge + that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension] + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings, event[that._measurements.pagePosition] - offset)); if (that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension]) { that._dragDetails.position = Math.min(edge + that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension], that._dragDetails.position) } } /** * Sets tab index */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); return; } that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0; } /** * Set drag details for a splitter item * @param {any} event */ _setDragDetails(target, event) { const that = this; that._dragDetails = {}; if (!that._measurements) { that._setMeasurements(); } that._dragDetails.scrollAmount = target.parentElement[that._measurements.scroll]; that._dragDetails.lockedItemsSize = 0; that.setAttribute('show-locked-items', ''); if (!(that._dragDetails.firstItem = that._getTargetItem(target, 'previousElementSibling'))) { delete that._dragDetails; that.setAttribute('dragging-not-allowed', ''); return; } that._dragDetails.firstItem.set('size', ''); that._dragDetails.firstItem.currentSize = that._dragDetails.firstItem[that._measurements.size]; that._dragDetails.firstItem.originalSize = that._dragDetails.firstItem.currentSize; let computedStyle = getComputedStyle(that._dragDetails.firstItem); that._dragDetails.firstItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0); //if (that._dragDetails.firstItem.currentSize < that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension]) { // delete that._dragDetails; // return; //} that._dragDetails.firstItem.currentSize -= that._dragDetails.firstItem._paddings; that._dragDetails.splitAreaSize = 0; that._dragDetails.secondItemTotalMaxSize = 0; that._dragDetails.secondItemTotalMinSize = 0; if (that.resizeMode === 'proportional') { if (that._setProportionalDetails()) { return; } } else { if (that._setAdjacentOrEndDetails(target)) { return; } } let splitterBarPagePosition; if (!event || typeof (event) !== 'object') { event = { pageX: target[that._measurements.offset], pageY: target[that._measurements.offset] }; splitterBarPagePosition = target[that._measurements.offset]; } else { splitterBarPagePosition = target.getBoundingClientRect()[that._measurements.position]; } that._dragDetails.position = event[that._measurements.pagePosition]; that._dragDetails.splitBarOffset = that._dragDetails.position - splitterBarPagePosition; if (that.liveResize) { return; } if (!that._splitBarDummy) { that._splitBarDummy = document.createElement('div'); that._splitBarDummy.classList.add('lw-splitter-bar-feedback'); that._splitBarDummy.setAttribute(that.orientation, ''); } that._splitBarDummy.style.width = target.offsetWidth + 'px'; that._splitBarDummy.style.height = target.offsetHeight + 'px'; that._splitBarDummy.style.top = target.offsetTop + 'px'; that._splitBarDummy.style.left = target.offsetLeft + 'px'; that._splitBarDummy.setAttribute(that.orientation, ''); target.parentElement.appendChild(that._splitBarDummy); } /** * Sets the drag details when resizeMode === 'adjacent' or 'end' */ _setAdjacentOrEndDetails(target) { const that = this; if (!(that._dragDetails.secondItem = (that.resizeMode === 'adjacent' ? that._getTargetItem(target, 'nextElementSibling') : that._getTargetItem(target, 'previousElementSibling', true)))) { delete that._dragDetails; that.setAttribute('dragging-not-allowed', ''); return true; } that._dragDetails.secondItem.set('size', ''); that._dragDetails.secondItem.currentSize = that._dragDetails.secondItem[that._measurements.size]; that._dragDetails.secondItem.originalSize = that._dragDetails.secondItem.currentSize; const computedStyle = getComputedStyle(that._dragDetails.secondItem); that._dragDetails.secondItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0); that._dragDetails.secondItem.currentSize -= that._dragDetails.secondItem._paddings; that._dragDetails.splitAreaSize = that._dragDetails.firstItem.currentSize + that._dragDetails.secondItem.currentSize; that._dragDetails.secondItemTotalMaxSize = that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension]; that._dragDetails.secondItemTotalMinSize = that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension]; } /** * Sets the measurement object that will be used during resizing */ _setMeasurements() { const that = this; that._measurements = {}; if (that.orientation === 'horizontal') { that._measurements.dimension = 'height'; that._measurements.minDimension = 'minHeight'; that._measurements.maxDimension = 'maxHeight'; that._measurements.restricredDimension = 'Width'; that._measurements.size = 'offsetHeight'; that._measurements.offset = 'offsetTop'; that._measurements.position = 'top'; that._measurements.position2 = 'bottom'; that._measurements.pagePosition = 'pageY'; that._measurements.scroll = 'scrollTop'; } else { that._measurements.dimension = 'width'; that._measurements.minDimension = 'minWidth'; that._measurements.maxDimension = 'maxWidth'; that._measurements.restricredDimension = 'Height'; that._measurements.size = 'offsetWidth'; that._measurements.offset = 'offsetLeft'; that._measurements.position = 'left'; that._measurements.position2 = 'right'; that._measurements.pagePosition = 'pageX'; that._measurements.scroll = 'scrollLeft'; } that._measurements.overflow = getComputedStyle(that).getPropertyValue('overflow'); } /** * Sets the dragging details when resizeMode = 'proportional' */ _setProportionalDetails() { const that = this; that._dragDetails.secondItem = that._items.slice(that._items.indexOf(that._dragDetails.firstItem) + 1).filter(item => !item.collapsed && !item.locked); if (that._dragDetails.secondItem.length === 0) { delete that._dragDetails; return true; } that._dragDetails.splitAreaSize += that._dragDetails.firstItem.currentSize; that._dragDetails.itemProportions = []; let noMaxLimit; for (let i = 0; i < that._dragDetails.secondItem.length; i++) { that._dragDetails.secondItem[i].set('size', ''); that._dragDetails.secondItem[i].currentSize = that._dragDetails.secondItem[i][that._measurements.size]; that._dragDetails.secondItem[i].originalSize = that._dragDetails.secondItem[i].currentSize const computedStyle = getComputedStyle(that._dragDetails.secondItem[i]); that._dragDetails.secondItem[i]._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0); that._dragDetails.secondItem[i].currentSize -= that._dragDetails.secondItem[i]._paddings; that._dragDetails.splitAreaSize += that._dragDetails.secondItem[i].currentSize; that._dragDetails.itemProportions.push({ item: that._dragDetails.secondItem[i], currentSize: that._dragDetails.secondItem[i].currentSize }); if (!that._dragDetails.secondItem[i]._sizeLimits[that._measurements.maxDimension]) { noMaxLimit = true; } that._dragDetails.secondItemTotalMinSize += that._dragDetails.secondItem[i]._sizeLimits[that._measurements.minDimension]; that._dragDetails.secondItemTotalMaxSize += that._dragDetails.secondItem[i]._sizeLimits[that._measurements.maxDimension]; } if (noMaxLimit) { that._dragDetails.secondItemTotalMaxSize = 0; } } /** * Validates the size of the Splitter Bars inside the Splitter */ _validateBarsSize() { const that = this; //Check if size of the SplitterBar is explicitly set if ((getComputedStyle(that).getPropertyValue('--lw-splitter-bar-fit-size') + '').trim() !== '100%') { that.bars.forEach(bar => bar.style[that._measurements.restricredDimension.toLowerCase()] = null); return; } //NOTE: Checks if the Splitter has height 'auto' if (!that._dragDetails && that.orientation === 'vertical' && that.resizeTrigger) { const splitterSize = that.offsetHeight; that.resizeTrigger.style.display = 'none'; if (that.offsetHeight !== splitterSize) { that.resizeTrigger.style.display = null; return; } that.resizeTrigger.style.display = null; } let biggestItem = that._items[0]; const size = 'offset' + that._measurements.restricredDimension, bars = that.bars; if (bars.length === 0) { return; } for (let i = 0; i < that._items.length; i++) { if (that._items[i][size] > biggestItem[size]) { biggestItem = that._items[i]; } } if (!biggestItem) { return; } if (biggestItem[size] !== bars[0][size]) { bars.map(bar => bar.style[that._measurements.restricredDimension.toLowerCase()] = biggestItem[size] + 'px'); } } /** * Validates the sizes of the Splitter items and resizes them to fit if the overflow is set to 'none' or 'visible' */ _validateItemSize(noStyleChangedIgnoring) { const that = this; if (that.autoFitMode === 'overflow') { return; } const items = that._items, dimension = that._measurements.dimension, containerSize = that.$.container.getBoundingClientRect()[dimension], isPercentage = (sizeProperty) => typeof sizeProperty === 'string' && sizeProperty.indexOf('%') > -1; let totalItemSize = 0; for (let i = 0; i < items.length; i++) { const item = items[i]; //Refresh min/max if in percentages if (item.min && isPercentage(item.min)) { item._sizeLimits[that._measurements.minDimension] = parseFloat(item.min) * containerSize / 100; } if (item.max && isPercentage(item.max)) { item._sizeLimits[that._measurements.maxDimension] = parseFloat(item.max) * containerSize / 100; } if (!item.collapsed) { const sizeApplied = item.style[dimension]; totalItemSize += (sizeApplied && sizeApplied.indexOf('%') < -1 && item._sizeBeforeCollapse ? item._sizeBeforeCollapse : item.getBoundingClientRect()[dimension]) } } if (that.keepProportionsOnResize && that._resizeEventFired) { that._keepItemProportionsOnResize(); } else { //NOTE: Checks if the Splitter has height 'auto' if (that.orientation === 'horizontal' && that.resizeTrigger) { const splitterSize = that.offsetHeight; that.resizeTrigger.style.display = 'none'; if (that.offsetHeight !== splitterSize) { that.resizeTrigger.style.display = null; return; } that.resizeTrigger.style.display = null; } const totalBarsSize = that.bars.reduce((acc, bar) => acc + bar[that._measurements.size], 0); let sizeDifference = totalItemSize + totalBarsSize - containerSize; if (sizeDifference > 0) { that._validateItemsSizeOverflowing(sizeDifference, noStyleChangedIgnoring); } else if (sizeDifference < 0) { that._validateItemsSizeUnderflowing(sizeDifference, noStyleChangedIgnoring); } } that._autoFitItems(); //Should be called only when Splitter's width is 'auto' that._validateBarsSize(); //Keeping the last valid splitter size that._splitterSize = containerSize; //NOTE: Elements in ShadowDOM get initialized in reverse order ( from outher to inner elements). That's why this is necessary. if (that.enableShadowDOM) { const host = that.getRootNode().host; if (host && host.enableShadowDOM && host.isCompleted && host._validateItemSize) { host._validateItemSize(); } } } /** * Validates the min/max properties of the neighbour items * @param {any} item */ _validateNeighbourSizeLimits(item) { const that = this; function checkLimits(neighbourItem) { if (!neighbourItem) { return; } if (neighbourItem.min) { neighbourItem._setSize('min', neighbourItem.min, true); } if (neighbourItem.max) { neighbourItem._setSize('max', neighbourItem.max, true); } } if (!that._items || !that._items.length) { return; } that._noNeighbourValidation = true; const itemIndex = that._items.indexOf(item); //Previous item checkLimits(that._items[itemIndex - 1]); //Next item checkLimits(that._items[itemIndex + 1]); delete that._noNeighbourValidation; } /** * Keeps the same proportion of the items during resizing. Handles the keepProportionsOnResize proeprty */ _keepItemProportionsOnResize() { const that = this; let currentItemsSize = 0, resizableItems = []; for (let i = 0; i < that._items.length; i++) { if (that._items[i].collapsed) { continue; } resizableItems.push(that._items[i]); currentItemsSize += that._items[i]._sizeBeforeCollapse || that._items[i][that._measurements.size]; } if (that._splitterSize) { currentItemsSize = that._splitterSize; } if (that._items.length === 1) { return; } const splitterSizeAfterResize = that.$.container.getBoundingClientRect()[that._measurements.dimension]; for (let i = 0; i < resizableItems.length; i++) { const resizableItem = resizableItems[i], itemSize = resizableItem.style[that._measurements.dimension], itemMin = resizableItem.style[that._measurements.minDimension]; if (itemSize.indexOf('%') > -1 || itemMin.indexOf('%') > -1) { that._validateItemLimits(resizableItem, resizableItem[that._measurements.size] / currentItemsSize * splitterSizeAfterResize); continue; } const currentSize = (resizableItem._sizeBeforeCollapse || resizableItem[that._measurements.size]), newSize = currentSize / currentItemsSize * splitterSizeAfterResize; if (currentSize === newSize) { continue; } resizableItem.style[that._measurements.dimension] = newSize + 'px'; //Splitter has no fixed size if (splitterSizeAfterResize !== that.$.container.getBoundingClientRect()[that._measurements.dimension]) { resizableItem.style[that._measurements.dimension] = currentSize + 'px'; return; } resizableItem.style[that._measurements.dimension] = (resizableItem._sizeBeforeCollapse = newSize) + 'px'; that._validateItemLimits(resizableItem, newSize); } } /** * Validates and recalculates the sizes of the items if they overflow the container */ _validateItemsSizeOverflowing(sizeDifference, noStyleChangedIgnoring) { const that = this, itemsCount = that._items.length; let newSize = 0, initialSize, itemsLocked = [], currentSize, currentlySetSize, lastLockedItem, containerRect = that.$.container.getBoundingClientRect(); for (let i = 0; i < that._items.length; i++) { const item = that._items[i]; //Note: If the size is set in percentages via CSS, it's not possible check if it's really percentages or not //because even getComputedStyle returns the computed size not the original. //The only way to work is by setting the size property to a percentage value ! currentlySetSize = item.style[that._measurements.dimension]; if (!currentlySetSize) { //NOTE: Can't get the original CSS width/height of an item unless it is a CSS variable! //Checks the variable for the width/height of the items for a value currentlySetSize = window.getComputedStyle(that).getPropertyValue('--lw-splitter-item-size') || ''; } currentSize = currentlySetSize.indexOf('%') > -1 ? currentlySetSize : item[that._measurements.size]; if (!currentlySetSize && !item.size && item.size !== 0) { delete item._originalSize; } const isAuto = (currentSize === 'auto' && item.size && isNaN(parseFloat(item.size))) || item.size === 'auto'; item._originalSize = item._originalSize && !isAuto ? item._originalSize : currentSize; itemsLocked.push(item.locked); } if (itemsLocked.indexOf(false) < 0) { lastLockedItem = that._items[that._items.length - 1]; lastLockedItem.locked = false; } //Check how many items should be resized to fit for (let i = itemsCount - 1; i >= 0; i--) { const item = that._items[i]; if (item.collapsed || item.locked || sizeDifference === 0) { continue; } if ((item._originalSize + '').indexOf('%') > -1) { initialSize = item.style[that._measurements.dimension] || item[that._measurements.size]; if (typeof initialSize === 'string' && initialSize.indexOf('%') > -1) { initialSize = parseFloat(initialSize) / 100 * containerRect[that._measurements.dimension]; } item.style[that._measurements.dimension] = item._originalSize; item._sizeBeforeCollapse = containerRect[that._measurements.dimension] * parseFloat(item._originalSize) / 100; sizeDifference -= parseFloat(initialSize) - item._sizeBeforeCollapse; continue; } //Doesn't include the item paddings initialSize = item.getBoundingClientRect()[that._measurements.dimension]; newSize = initialSize - sizeDifference; //May trigger the styleChanged event item.style[that._measurements.dimension] = (item._sizeBeforeCollapse = Math.max(item._sizeLimits ? item._sizeLimits[that._measurements.minDimension] : 0, newSize)) + 'px'; sizeDifference -= initialSize - item._sizeBeforeCollapse; } //Reduce the min-sizes if necessary if (sizeDifference > 0) { for (let i = itemsCount - 1; i >= 0; i--) { const item = that._items[i]; if (item.collapsed || item.locked) { continue; } initialSize = item.getBoundingClientRect()[that._measurements.dimension]; newSize = initialSize - sizeDifference; let itemMin = item._sizeLimits[that._measurements.minDimension] || item.min; if (itemMin) { if ((itemMin + '').indexOf('%') > -1) { itemMin = parseFloat(itemMin) / 100 * item.parentElement[that._measurements.size]; } else { itemMin = parseFloat(itemMin); } if (itemMin > newSize) { //Ignore the StyleChanged event item._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true; item.style[that._measurements.minDimension] = Math.max(0, newSize) + 'px'; } } if (sizeDifference === 0 && item._originalSize && (item._originalSize + '').indexOf('%') > -1) { continue; } item._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true; item.style[that._measurements.dimension] = (item._sizeBeforeCollapse = Math.max(0, newSize)) + 'px'; sizeDifference -= initialSize - item._sizeBeforeCollapse; } } if (lastLockedItem) { lastLockedItem.locked = true; } } /** * Validates the sizes of the items if the're underflowing the container ( should fit ) */ _validateItemsSizeUnderflowing(sizeDifference, noStyleChangedIgnoring) { const that = this, itemsCount = that._items.length; let newSize = 0, initialSize, lastLockedItem; sizeDifference = Math.abs(sizeDifference); if (that._items.length > 0 && that._items.map(item => item.locked).indexOf(false) < 0) { lastLockedItem = that._items[that._items.length - 1]; lastLockedItem.locked = false; } //Increase the min-size of the items if it has been changed for (let i = 0; i < itemsCount; i++) { const item = that._items[i]; if (item.collapsed || item[that._measurements.size] >= (item._sizeLimits ? item._sizeLimits[that._measurements.minDimension] : 0)) { continue; } initialSize = item[that._measurements.size]; newSize = item[that._measurements.size] + sizeDifference; if (item[that._measurements.size] < item._sizeLimits[that._measurements.minDimension]) { //Ignore the StyleChanged event item._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true; item.style[that._measurements.minDimension] = (item._sizeBeforeCollapse = Math.max(0, Math.min(item._sizeLimits[that._measurements.minDimension], newSize))) + 'px'; } sizeDifference -= (item._sizeBeforeCollapse || item[that._measurements.size]) - initialSize; if (sizeDifference <= 0) { break; } } const containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension]; if (sizeDifference > 0) { for (let i = 0; i < itemsCount; i++) { const item = that._items[i]; let usedSize; if (item.collapsed || item.locked || item._originalSize === undefined) { continue; } if ((item._originalSize + '').indexOf('%') > -1) { const sizeInPxls = (parseFloat(item._originalSize) * containerSize) / 100; newSize = Math.min(sizeInPxls, item[that._measurements.size] + sizeDifference); usedSize = newSize - item[that._measurements.size]; if (item[that._measurements.minDimension] < item._sizeLimits[that._measurements.minDimension]) { item.style[that._measurements.minDimension] = Math.min(item._sizeLimits[that._measurements.minDimension], newSize) + 'px'; } item.style[that._measurements.dimension] = sizeInPxls === newSize ? item._originalSize : newSize + 'px'; item._sizeBeforeCollapse = Math.max(0, newSize); sizeDifference -= usedSize; } else if (item[that._measurements.size] >= item._originalSize) { sizeDifference += item[that._measurements.size] - item._originalSize; item.style[that._measurements.dimension] = (item._sizeBeforeCollapse = item._originalSize) + 'px'; } else { newSize = Math.min(item._originalSize, item[that._measurements.size] + sizeDifference); usedSize = newSize - item[that._measurements.size]; if (item[that._measurements.minDimension] < item._sizeLimits[that._measurements.minDimension]) { item.style[that._measurements.minDimension] = Math.min(item._sizeLimits[that._measurements.minDimension], newSize) + 'px'; } item.style[that._measurements.dimension] = (item._sizeBeforeCollapse = Math.max(0, Math.min(newSize, item._originalSize))) + 'px'; sizeDifference -= usedSize; } if (sizeDifference <= 0) { break; } } } if (lastLockedItem) { lastLockedItem.locked = true; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Tab Item custom element. */ LW('lw-tab-item', class TabItem extends LW.ContentElement { // Tab Item's properties. static get properties() { return { 'closeButtonHidden': { value: false, type: 'boolean' }, 'index': { value: null, type: 'number?' }, 'selected': { value: false, type: 'boolean' }, 'label': { value: '', type: 'string' }, 'labelSize': { value: null, type: 'number?' } }; } get enableShadowDOM() { return false; } render() { const that = this; that.setAttribute('role', 'tabpanel'); that.firstElementChild.setAttribute('role', 'presentation'); super.render(); } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted) { return; } that.$.removeClass('right'); that.$.removeClass('left'); that.$.removeClass('top'); that.$.removeClass('bottom'); that.$.removeClass('animate'); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (that._preventPropertyChangedHandler) { delete that._preventPropertyChangedHandler; return; } switch (propertyName) { case 'closeButtonHidden': that.$.fireEvent('closeButtonVisibilityChange', { 'hidden': newValue }); break; case 'index': that.$.fireEvent('indexChange', { 'newIndex': newValue, 'oldIndex': oldValue, 'tabItem': that }); break; case 'label': case 'selected': if (propertyName === 'label') { that.setAttribute('aria-label', newValue); } if (that.tabLabelContainer) { that.tabLabelContainer.setAttribute('aria-' + propertyName, newValue); } break; case 'labelSize': that.$.fireEvent('labelSizeChange', { 'size': newValue }); break; } } /** * Appends a child node directly to the lw-tab-item's container. * * @param {HTMLElement} node The node to append. */ appendChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.firstElementChild.appendChild(node); } /** * Sets the index without "propertyChangedHandler" being called */ _setIndex(index) { const that = this, oldContext = that.context; that.context = that; that.index = index; that.context = oldContext; } }); /** * Tab Items Group custom element. */ LW('lw-tab-items-group', class TabItemsGroup extends LW.ContentElement { // Tab Items Group's properties. static get properties() { return { 'label': { value: '', type: 'string' }, 'labelSize': { value: null, type: 'number?' } }; } get enableShadowDOM() { return false; } /** * Tab Items Group's HTML template. */ template() { return ''; } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (that._preventPropertyChangedHandler) { delete that._preventPropertyChangedHandler; return; } switch (propertyName) { case 'label': break; case 'labelSize': this.$.fireEvent('labelSizeChange', { 'size': newValue }); break; } } }); /** * Tabs custom element. */ LW('lw-tabs', class Tabs extends LW.BaseElement { // Tabs's properties. static get properties() { return { 'addNewTab': { value: false, type: 'boolean' }, 'allowToggle': { value: false, type: 'boolean' }, 'closeButtonMode': { value: 'default', allowedValues: ['default', 'selected'], type: 'string' }, 'closeButtons': { value: false, type: 'boolean' }, 'collapsed': { value: false, type: 'boolean' }, 'collapsible': { value: false, type: 'boolean' }, 'dataSource': { value: null, type: 'array?', reflectToAttribute: false }, 'enableMouseWheelAction': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'ambiguousIndexes': 'lw-tabs: Initially set lw-tab-item indexes are ambiguous and are ignored in favour of the HTML structure.', 'detailsObjectRequired': 'lw-tabs: The method "insert" requires a details Object to be passed as a second argument.', 'invalidIndex': 'lw-tabs: "{{method}}" method accepts an index of type number.', 'referenceNodeNotChild': 'lw-tabs: Passed {{argument}} is not part of this lw-tabs element.', 'tabItemRequired': 'lw-tabs: The method "{{method}}" requires a "lw-tab-item" element to be passed as an argument.' } }, type: 'object', extend: true }, 'name': { value: '', type: 'string' }, 'overflow': { value: 'auto', allowedValues: ['auto', 'hidden', 'scroll'], type: 'string' }, 'reorder': { value: false, type: 'boolean' }, 'resize': { value: false, type: 'boolean' }, 'scrollButtonsPosition': { value: 'both', allowedValues: ['near', 'far', 'both'], type: 'string' }, 'scrollMode': { value: 'paging', allowedValues: ['paging', 'continuous'], type: 'string' }, 'selectedIndex': { value: null, type: 'number?' }, 'selectionMode': { value: 'click', allowedValues: ['click', 'dblclick', 'mouseenter', 'none'], type: 'string' }, 'tabLayout': { value: 'scroll', allowedValues: ['scroll', 'dropDown', 'wrap', 'shrink'], type: 'string', defaultReflectToAttribute: true }, 'tabPosition': { value: 'top', allowedValues: ['top', 'bottom', 'left', 'right', 'hidden'], type: 'string' }, 'tabTextOrientation': { value: 'horizontal', allowedValues: ['horizontal', 'vertical'], type: 'string' } }; } /** * Tabs's event listeners. */ static get listeners() { return { 'closeButtonVisibilityChange': '_closeButtonVisibilityChangeHandler', 'indexChange': '_indexChangeHandler', 'keydown': '_keydownHandler', 'labelSizeChange': '_labelSizeChangeHandler', 'resize': '_applyTabOverflow', 'styleChanged': '_applyTabOverflow', 'container.dblclick': '_containerHandler', 'container.down': '_containerHandler', 'container.mouseout': '_containerHandler', 'container.mouseover': '_containerHandler', 'scrollButtonFar.click': '_scrollButtonClickHandler', 'scrollButtonNear.click': '_scrollButtonClickHandler', 'tabContentSection.transitionend': '_tabContentSectionTransitionendHandler', 'tabsHeaderItems.wheel': '_tabsHeaderItemsWheelHandler', 'tabStrip.mouseleave': '_tabStripMouseleaveHandler', 'tabStrip.move': '_tabStripMoveHandler', 'tabStrip.touchmove': '_tabStripTouchmoveHandler', 'tabStrip.touchstart': '_tabStripTouchstartHandler', 'document.move': '_documentMoveHandler', 'document.selectstart': '_selectStartHandler', 'document.up': '_documentUpHandler' }; } /** * Tabs's required files. */ static get requires() { return { 'LW.RepeatButton': 'lw.button.js' } } static get styleUrls() { return [ 'lw.tabs.css' ] } /** * Tabs's HTML template. */ template() { return `<div id="container"> <div id="tabsHeaderSection" class="lw-header lw-tabs-header-section"> <div id="tabsHeaderItems" class="lw-tabs-header-items"> <lw-repeat-button id="scrollButtonNear" class="lw-tabs-scroll-button lw-nav-button lw-spin-button lw-hidden" animation="[[animation]]" unfocusable> <div id="arrowNear" class="lw-arrow" aria-hidden="true"></div> </lw-repeat-button> <div id="tabStrip" class="lw-tab-strip"></div> <lw-repeat-button id="scrollButtonFar" class="lw-tabs-scroll-button lw-nav-button lw-spin-button lw-hidden" animation="[[animation]]" unfocusable> <div id="arrowFar" class="lw-arrow" aria-hidden="true"></div> </lw-repeat-button> <div id="dropDownButton" class="lw-drop-down-button" role="button" aria-expanded="false" aria-label="Open tab selection popup"> <div id="dropDownButtonArrow" class="lw-drop-down-button-arrow lw-unselectable" aria-hidden="true"></div> </div> <span id="tabSelectionBar" class="lw-tabs-selection-bar" role="presentation"></span> <div id="resizeToken" class="lw-tabs-resize-token lw-hidden" role="presentation"></div> </div> <div id="tabHeaderControls" class="lw-tabs-header-controls"></div> </div> <div id="tabContentSection" class="lw-tabs-content-section"> <content></content> </div> <div id="dropDownButtonDropDown" class="lw-drop-down-button-drop-down lw-hidden"></div> <input id="hiddenInput" type="hidden" name="[[name]]"> </div>`; } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (!that.isCompleted || !that.isRendered) { return; } that._applyTabOverflow(); } /** * Called when the element is ready. Used for one-time configuration of the Tab. */ ready() { super.ready(); const that = this; that._flexWritingModeNoFullSupport = true; // !LW.Utilities.Core.Browser.Chrome; } render() { this._createElement(); super.render(); } /** * Appends a "lw-tab-item" node as the last tab of the Tabs. * * @param {HTMLElement} node The "lw-tab-item" node to append. */ appendChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!(node instanceof LW.TabItem)) { that.error(that.localize('tabItemRequired', { method: 'appendChild' })); } if (!that.isRendered) { that.whenRendered(() => that.insert(that._tabs.length, { node: node })); } else { that.insert(that._tabs.length, { node: node }); } } /** * Collapses the content section. */ collapse() { const that = this; if (!that.collapsible || that.collapsed) { return; } that.collapsed = true; } /** * Makes sure a tab is visible by scrolling to it. * * @param {Number} index The index of the tab to scroll to. */ ensureVisible(index) { const that = this; if (index === null || that.tabLayout === 'wrap' || that.tabLayout === 'shrink' || that.tabPosition === 'hidden') { return; } that._validateIndex(index, 'ensureVisible'); index = Math.max(0, Math.min(index, that._tabs.length - 1)); const group = that._tabs[index].group, tabStrip = that.$.tabStrip, tabStripBoundingRect = tabStrip.getBoundingClientRect(), scrollTarget = group === null ? that._tabLabelContainers[index] : that._groupLabels[that._groups.indexOf(group)], scrollTargetBoundingRect = scrollTarget.getBoundingClientRect(); if (that.tabPosition === 'top' || that.tabPosition === 'bottom') { if (tabStripBoundingRect.left > scrollTargetBoundingRect.left) { tabStrip.scrollLeft += Math.round(scrollTargetBoundingRect.left - tabStripBoundingRect.left); } else { tabStrip.scrollLeft += Math.round(scrollTargetBoundingRect.right - tabStripBoundingRect.right); } } else if ((that.tabPosition === 'left' || that.tabPosition === 'right') && (tabStripBoundingRect.top > scrollTargetBoundingRect.top || tabStripBoundingRect.bottom < scrollTargetBoundingRect.bottom)) { tabStrip.scrollTop += Math.round(scrollTargetBoundingRect.bottom - tabStrip.offsetHeight - tabStripBoundingRect.top); } else { tabStrip.scrollLeft = that._getScrollLeft(0); that.$.tabStrip.scrollTop = 0; } that._updateScrollButtonVisibility(); if (that.resize) { that._getTabCoordinates(); } } /** * Expands the content section. */ expand() { const that = this; if (!that.collapsible || !that.collapsed) { return; } that.collapsed = false; } /** * Returns the offset of the tab item container (lw-tab-item element) from the edge of the Tabs (lw-tabs element) where the tab strip is positioned. * * @param {Number} index The index of the tab item. */ getOffsetFromEdgeOfElement(index) { const that = this; that._validateIndex(index, 'getOffsetFromEdgeOfElement'); index = Math.max(0, Math.min(index, that._tabs.length - 1)); const tabItem = that._tabs[index], position = that.tabPosition; if (position !== 'hidden') { return Math.abs(tabItem.getBoundingClientRect()[position] - that.getBoundingClientRect()[position]); } return tabItem.getBoundingClientRect().top - that.getBoundingClientRect().top; } /** * Inserts a new tab and an associated content section. * * @param {Number} index The index to insert a new tab at. * @param {Object} details An Object with the fields "label", "labelSize", "content" and "group". */ insert(index, details) { const that = this; let group, tab; that._validateIndex(index, 'insert'); if (details === undefined || (details.label === undefined && details.content === undefined && details.node === undefined)) { that.error(that.localize('detailsObjectRequired')); } if (details.node === undefined) { group = details.group; tab = document.createElement('lw-tab-item'); tab.label = details.label !== undefined ? details.label : ''; tab.labelSize = details.labelSize !== undefined ? details.labelSize : null; tab.content = details.content; } else { tab = details.node; if (tab.index !== undefined && tab.index !== null) { const oldContext = tab.context; tab.context = tab; tab.index = null; tab.context = oldContext; } } tab.$.addClass('lw-visibility-hidden'); tab.group = null; const labelContainers = that._addTabLabelContainer(tab), tabLabelContainer = labelContainers.tabLabelContainer, dropDownLabelContainer = labelContainers.dropDownLabelContainer; tabLabelContainer.tab = tab; tab.tabLabelContainer = tabLabelContainer; const tabDetails = { index: index, tab: tab, tabLabelContainer: tabLabelContainer, dropDownLabelContainer: dropDownLabelContainer }; that._setAriaRelations(tab, tabLabelContainer, dropDownLabelContainer); if (that._groups.length === 0 && group === undefined) { that._insertNoGrouping(tabDetails); } else { if (group !== undefined && group !== null) { tabDetails.group = group; const lwTabItemsGroup = that.$.tabContentSection.querySelector('lw-tab-items-group[label="' + group + '"]'); if (lwTabItemsGroup !== null) { // group exists tabDetails.lwTabItemsGroup = lwTabItemsGroup; that._insertIntoExistingGroup(tabDetails); } else { // group does not exist that._insertIntoNewGroup(tabDetails); } } else { that._insertNearAGroup(tabDetails); } } that._getReorderItems(); if (that.selectedIndex === null && !that.allowToggle && that._tabs.length) { that._select(0, true); } if (tab.group !== null && tab.labelSize !== null && that.tabLayout !== 'shrink') { tabLabelContainer.style.removeProperty([that._orientationSettings.dimension]); } that._applyTabOverflow(); } /** * Inserts the specified "lw-tab-item" node before the reference "lw-tab-item" node. * * @param {HTMLElement} newNode The "lw-tab-item" node to insert. * @param {HTMLElement} referenceNode The "lw-tab-item" node before which newNode is inserted. */ insertBefore(newNode, referenceNode) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!(newNode instanceof LW.TabItem) || referenceNode !== undefined && referenceNode !== null && !(referenceNode instanceof LW.TabItem)) { that.error(that.localize('tabItemRequired', { method: 'insertBefore' })); } let reselectIndex; if (that.contains(newNode)) { if (newNode.selected) { reselectIndex = true; } that.removeAt(newNode.index); } if (referenceNode !== undefined && referenceNode !== null) { if (!that.contains(referenceNode)) { that.error(that.localize('referenceNodeNotChild', { argument: 'referenceNode' })); } that.insert(referenceNode.index, { node: newNode }); } else { that.insert(that._tabs.length, { node: newNode }); } if (reselectIndex) { that._select(newNode.index, false); } } /** * Refreshes the Tabs header section. */ refreshTabHeader() { const that = this; if (that.tabLayout === 'scroll') { that._checkOverflowScroll(); } that._positionTabSelectionBar(that._tabLabelContainers ? that._tabLabelContainers[that.selectedIndex] : undefined, true); } /** * Removes a tab and its associated content section. * * @param {Number} index The index of the tab to remove. */ removeAt(index) { const that = this, initialNumberOfTabs = that._tabs.length; if (initialNumberOfTabs === 0) { return; } that._validateIndex(index, 'remove'); index = Math.max(0, Math.min(index, initialNumberOfTabs - 1)); const tab = that._tabs[index], tabLabelContainer = that._tabLabelContainers[index]; //Fixes a iOS issue where removing the labelContainer breaks touchmove event //Used inside DockingLayout to indicate that the lableContainer shouldn't be removed during dragging operation. if (tabLabelContainer._lazyRemove) { tabLabelContainer.classList.add('lw-hidden'); } else { tabLabelContainer.parentElement.removeChild(tabLabelContainer); //Breaks Layout on iOS } tab.parentElement.removeChild(tab); if (tab.group !== null) { const lwTabItemsGroup = that.$.tabContentSection.querySelector('lw-tab-items-group[label="' + tab.group + '"]'); if (lwTabItemsGroup.childElementCount === 0) { const groupIndex = that._groups.indexOf(tab.group); that.$.tabStrip.removeChild(that._groupLabels[groupIndex]); that._groups.splice(groupIndex, 1); that.$.container.removeChild(that._groupLabels[0].dropDown); that._groupLabels.splice(groupIndex, 1); that.$.tabContentSection.removeChild(lwTabItemsGroup); } } if (initialNumberOfTabs > 1) { if (index < that.selectedIndex) { that.selectedIndex--; } else if (index === that.selectedIndex) { if (index === initialNumberOfTabs - 1) { that._select(index - 1, false); } else { that._select(index + 1, false); that.selectedIndex--; } } } else { that.selectedIndex = null; that.$.tabContentSection.innerHTML = ''; } that._tabLabelContainers.splice(index, 1); that.$.dropDownButtonDropDown.removeChild(that.$.dropDownButtonDropDown.children[index]); that._tabs.splice(index, 1); if (that._focusedItem === tab) { that._focusedItem = that._tabs[that._focusedItem.index]; } that._updateTabIndexes(); that._getReorderItems(); that._applyTabOverflow(); that.ensureVisible(that.selectedIndex); that.$.hiddenInput.value = that.selectedIndex; } /** * Removes a child "lw-tab-item" node. * * @param {HTMLElement} node The "lw-tab-item" node to remove. */ removeChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!(node instanceof LW.TabItem)) { that.error(that.localize('tabItemRequired', { method: 'removeChild' })); } if (!that.contains(node)) { that.error(that.localize('referenceNodeNotChild', { argument: 'node' })); } that.removeAt(node.index); } /** * Selects a tab. * * @param {Number} index The index of the tab to select. */ select(index) { const that = this; if (that._tabs.length === 0) { return; } that._validateIndex(index, 'select'); index = Math.max(0, Math.min(index, that._tabs.length - 1)); that.ensureVisible(index); that._select(index, true); } /** * Sets whether the element can be focused. * * @param {Boolean} focusable Whether the element can be focused. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.removeAttribute('tabindex'); return; } if (that.getAttribute('tabindex') === null || that.getAttribute('tabindex') < 0) { that.setAttribute('tabindex', 0); } } /** * Updates a tab and its associated content section. * * @param {Number} index The index of the tab to update. * @param {String} label The new label of the tab. The value can be the id of an HTMLTemplateElement. * @param {String/HTMLElement} content The new content of the tab. */ update(index, label, content) { const that = this; if (that._tabs.length === 0) { return; } that._validateIndex(index, 'update'); index = Math.max(0, Math.min(index, that._tabs.length - 1)); const tab = that._tabs[index]; if (label !== undefined && tab.label !== label) { const labelTextContainer = that._tabLabelContainers[index].firstElementChild.children[0], dropDownLabelContainer = that.$.dropDownButtonDropDown.children[index]; tab.label = label; labelTextContainer.innerHTML = ''; dropDownLabelContainer.innerHTML = ''; that._setLabel(label, labelTextContainer, dropDownLabelContainer); that._applyTabOverflow(); } if (content !== undefined) { tab.content = content; } } /** * Applies initial settings to the Tabs element. */ _createElement() { const that = this; if (!that.$.dropDownButton.id) { that.$.dropDownButton.id = that.id + 'DropDownButton'; } if (!that.$.dropDownButtonDropDown.id) { that.$.dropDownButtonDropDown.id = that.id + 'DropDown'; } that.setAttribute('role', 'tablist'); that.$.dropDownButton.setAttribute('role', 'button'); that.$.dropDownButton.setAttribute('aria-haspopup', true); that.$.dropDownButton.setAttribute('aria-owns', that.$.dropDownButtonDropDown.id); that.$.dropDownButtonDropDown.setAttribute('role', 'menu'); if (that.disabled) { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } if (that.rightToLeft) { that.$.tabsHeaderItems.removeChild(that.$.dropDownButton); if (that.tabPosition === 'top' || that.tabPosition === 'bottom') { that.$.tabsHeaderItems.insertBefore(that.$.dropDownButton, that.$.scrollButtonNear); } else { that.$.tabsHeaderItems.insertBefore(that.$.dropDownButton, that.$.tabSelectionBar); } } that._handlePosition(that.tabPosition); that._handleScrollButtonsPosition(that.scrollButtonsPosition, 'both'); if (that.dataSource !== null) { that._processDataSource(); } that._setFocusable(); if (that.collapsed && !that.collapsible) { that.collapsed = false; } if (that.collapsible) { if (that.allowToggle) { that.allowToggle = false; } } that._processHTML(); if (that.selectedIndex === null) { that.$.tabContentSection.setAttribute('show-placeholder', ''); } setTimeout(() => that.refreshTabHeader(), 300); that.$.hiddenInput.value = that.selectedIndex; if (that.enableShadowDOM) { HTMLElement.prototype.appendChild.apply(that, [that.$.hiddenInput]); } } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'addNewTab': if (newValue) { that._insertAddNewTab(); } else { that.$.tabStrip.removeChild(that._addNewTab); delete that._addNewTab; } that._applyTabOverflow(); break; case 'allowToggle': if (newValue && that.collapsible) { if (that.collapsed) { that._toggleCollapsedState(); } that.collapsible = false; } else if (!newValue && that.selectedIndex === null) { that.ensureVisible(that.selectedIndex = 0); that._select(that.selectedIndex, true, null); } break; case 'closeButtonMode': if (newValue === 'selected') { for (let i = 0; i < that._tabs.length; i++) { that._disableCloseButton(i); } that._enableCloseButton(that.selectedIndex); } else { that._disableCloseButton(that.selectedIndex); const tabLabelContainers = that._tabLabelContainers; for (let i = 0; i < tabLabelContainers.length; i++) { const tabLabelContainer = tabLabelContainers[i]; tabLabelContainer.closeButtonEnabled = that._tabs[i].closeButtonHidden !== true; that._showCloseButton(tabLabelContainer); } } that._applyTabOverflow(); break; case 'closeButtons': { const tabLabelContainers = that._tabLabelContainers, fn = newValue ? that._showCloseButton : that._hideCloseButton; for (let i = 0; i < tabLabelContainers.length; i++) { const tabLabelContainer = tabLabelContainers[i]; fn(tabLabelContainer); } that._applyTabOverflow(); break; } case 'collapsed': if (!that.collapsible && newValue) { that.collapsed = false; return; } break; case 'collapsible': if (!newValue && that.collapsed) { that.collapsed = false; } that.allowToggle = false; if (that.selectedIndex === undefined) { that.select(that._focusedItem.index); } break; case 'dataSource': that.selectedIndex = null; for (let i = 0; i < that._groupLabels.length; i++) { that.$.container.removeChild(that._groupLabels[i].dropDown); } that.$.tabStrip.innerHTML = ''; that._processDataSource(); that._processHTML(); break; case 'disabled': that._setFocusable(); that.$.scrollButtonNear.disabled = newValue; that.$.scrollButtonFar.disabled = newValue; if (!newValue) { that._updateScrollButtonVisibility(); } that._closeDropDownButtonDropDown(); break; case 'messages': case 'scrollMode': case 'selectionMode': case 'readonly': case 'reorder': break; case 'overflow': if (that.tabLayout !== 'scroll') { return; } //that.$.tabStrip.scrollLeft = 0; that.$.tabStrip.scrollLeft = that._getScrollLeft(0); that.$.tabStrip.scrollTop = 0; if (newValue === 'hidden') { that.$tabsHeaderSection.removeClass('scroll-buttons-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); } else { that._checkOverflowScroll(); } that._getTabCoordinates(); break; case 'tabPosition': { that.$.tabSelectionBar.style.transition = 'none'; that._tabPositionChanging = true; that._closeGroupDropDown(); that._handlePosition(newValue, oldValue); if (that.tabLayout !== 'shrink') { that._applyLabelSizes('tabPosition'); } if (that.rightToLeft) { that.$.tabsHeaderItems.removeChild(that.$.dropDownButton); if (that.tabPosition === 'top' || that.tabPosition === 'bottom') { that.$.tabsHeaderItems.insertBefore(that.$.dropDownButton, that.$.scrollButtonNear); } else { that.$.tabsHeaderItems.insertBefore(that.$.dropDownButton, that.$.tabSelectionBar); } } that._applyTabOverflow(); delete that._tabPositionChanging; requestAnimationFrame(function () { that.$.tabSelectionBar.style.transition = null; }); break; } case 'resize': if (newValue) { that._getTabCoordinates(); } break; case 'rightToLeft': that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], true); that.$.tabsHeaderItems.removeChild(that.$.dropDownButton); if (newValue && (that.tabPosition === 'top' || that.tabPosition === 'bottom')) { that.$.tabsHeaderItems.insertBefore(that.$.dropDownButton, that.$.scrollButtonNear); } else { that.$.tabsHeaderItems.insertBefore(that.$.dropDownButton, that.$.tabSelectionBar); } that.ensureVisible(that.selectedIndex); break; case 'scrollButtonsPosition': that._handleScrollButtonsPosition(newValue, oldValue); break; case 'selectedIndex': { if (isNaN(newValue)) { that.selectedIndex = newValue = oldValue; } if ((!that.allowToggle && newValue === null)) { that.selectedIndex = oldValue; return; } let validIndex = newValue; if (newValue !== null) { validIndex = Math.max(0, Math.min(newValue, that._tabs.length - 1)); that.ensureVisible(validIndex); } that._select(validIndex, true, oldValue); break; } case 'tabLayout': if (oldValue === 'scroll') { that.$tabsHeaderSection.removeClass('scroll-buttons-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); } if (newValue === 'shrink') { that._applyLabelSizes('shrink', true); } else if (oldValue === 'shrink') { that._applyLabelSizes('shrink', false); } that._applyTabOverflow(); if (newValue === 'scroll' && that.disabled) { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } that.ensureVisible(that.selectedIndex); break; case 'tabTextOrientation': that._applyTabOverflow(); that.ensureVisible(that.selectedIndex); break; case 'unfocusable': that._setFocusable(); break; } } /** * Adds a tab group container. */ _addGroupContainer(label, labelSize) { const that = this, groupContainer = document.createElement('div'), labelTextWrapper = document.createElement('div'), labelTextContainer = document.createElement('div'), arrow = document.createElement('div'), dropDown = document.createElement('div'); groupContainer.className = 'lw-tab-group-container lw-unselectable'; groupContainer.$ = LW.Utilities.Extend(groupContainer); groupContainer.setAttribute('role', 'group'); groupContainer.setAttribute('aria-expanded', false); groupContainer.setAttribute('aria-haspopup', true); groupContainer.setAttribute('aria-label', label); labelTextWrapper.className = 'lw-tab-label-text-wrapper'; labelTextWrapper.setAttribute('role', 'presentation'); labelTextWrapper.setAttribute('aria-hidden', true); if (labelSize !== null && that.tabLayout !== 'shrink') { groupContainer.style[that._orientationSettings.dimension] = parseInt(labelSize, 10) + 'px'; } // label labelTextContainer.className = 'lw-tab-label-text-container'; labelTextContainer.innerHTML = label; // down arrow arrow.className = 'lw-tab-group-arrow'; // dropdown dropDown.className = 'lw-tab-group-drop-down lw-hidden'; dropDown.$ = LW.Utilities.Extend(dropDown); dropDown.id = that.id + 'GroupDropDown' + label; dropDown.setAttribute('role', 'tablist'); dropDown.setAttribute('aria-orientation', 'vertical'); groupContainer.setAttribute('aria-owns', dropDown.id); labelTextWrapper.appendChild(labelTextContainer); labelTextWrapper.appendChild(arrow); groupContainer.appendChild(labelTextWrapper); that.$.container.appendChild(dropDown); groupContainer.group = label; groupContainer.dropDown = dropDown; dropDown.groupContainer = groupContainer; return { label: groupContainer, dropDown: dropDown }; } /** * Adds group-related elements to the tabstrip. */ _addGroupElements(details) { const that = this, groups = details.groups, groupLabels = details.groupLabels, group = details.group, groupIndex = groups.indexOf(group), tabLabelContainer = details.tabLabelContainer; let groupLabel; if (groupIndex !== -1) { // group exists groupLabel = groupLabels[groupIndex]; groupLabel.dropDown.appendChild(tabLabelContainer); } else { // group does not exist groups.push(group); const groupContainers = that._addGroupContainer(group, details.lwTabItemsGroup.labelSize), groupDropDown = groupContainers.dropDown; groupLabel = groupContainers.label; groupDropDown.appendChild(tabLabelContainer); groupDropDown.groupContainer = groupContainers.label; details.documentFragment.appendChild(groupLabel); groupLabels.push(groupLabel); } if (that.selectedIndex === details.i) { that._selectedGroup = groupLabel; groupLabel.$.addClass('lw-tab-group-selected'); } } /** * "add new" tab event handler. */ _addNewTabHandler(currentElement, eventType, click) { const that = this; if (that._swiping) { return; } if (click) { currentElement.removeAttribute('hover'); that.insert(that._tabs.length, { label: 'New Tab', content: '' }); that._select(that._tabs.length - 1, true); } else if (!that._reordering && !that._swiping) { if (eventType === 'mouseover') { currentElement.setAttribute('hover', ''); } else if (eventType === 'mouseout') { currentElement.removeAttribute('hover'); } } } /** * Adds a tab label container. */ _addTabLabelContainer(tab, addNewTab) { const that = this, tabLabelContainer = document.createElement('div'), labelTextWrapper = document.createElement('div'), labelTextContainer = document.createElement('div'), closeButton = document.createElement('div'); let dropDownLabelContainer; tabLabelContainer.className = 'lw-tab-label-container lw-unselectable'; labelTextWrapper.className = 'lw-tab-label-text-wrapper'; // label labelTextContainer.className = 'lw-tab-label-text-container'; labelTextContainer.setAttribute('role', 'presentation'); // close button closeButton.className = 'lw-tab-close-button'; closeButton.setAttribute('role', 'button'); closeButton.setAttribute('aria-label', 'Close'); if (addNewTab === undefined) { if (that.closeButtons) { if (that.closeButtonMode === 'default' && tab.closeButtonHidden || that.closeButtonMode === 'selected' && !tab.selected) { closeButton.classList.add('lw-hidden'); tabLabelContainer.closeButtonEnabled = false; } else { labelTextContainer.classList.add('lw-close-button-enabled'); tabLabelContainer.closeButtonEnabled = true; } } else { closeButton.classList.add('lw-hidden'); tabLabelContainer.closeButtonEnabled = true; } dropDownLabelContainer = document.createElement('div'); dropDownLabelContainer.className = 'lw-tab-label-container lw-unselectable'; if (tab.group === null && tab.labelSize !== null && that.tabLayout !== 'shrink') { tabLabelContainer.style[that._orientationSettings.dimension] = parseInt(tab.labelSize, 10) + 'px'; } } else { closeButton.classList.add('lw-hidden'); tabLabelContainer.closeButtonEnabled = false; } that._setLabel(tab ? tab.label : '+', labelTextContainer, dropDownLabelContainer); labelTextContainer.$ = LW.Utilities.Extend(labelTextContainer); closeButton.$ = LW.Utilities.Extend(closeButton); labelTextWrapper.appendChild(labelTextContainer); labelTextWrapper.appendChild(closeButton); tabLabelContainer.appendChild(labelTextWrapper); tabLabelContainer.$ = LW.Utilities.Extend(tabLabelContainer); return { tabLabelContainer: tabLabelContainer, dropDownLabelContainer: dropDownLabelContainer }; } /** * Animates selection. */ _animateSelection(tab, oldTab, indexGreaterThanOldIndex) { const that = this; let side1 = 'right', side2 = 'left'; if (that.rightToLeft) { side1 = 'left'; side1 = 'right'; } that._animatedTab = tab; that._animatedOldTab = oldTab; if (!that._animatedTab || !that._animatedOldTab) { return; } if (that.tabPosition === 'left' || that.tabPosition === 'right') { side1 = 'top'; side2 = 'bottom'; } for (let i = 0; i < that._tabs.length; i++) { that._tabs[i].$.removeClass(side1); that._tabs[i].$.removeClass(side2); that._tabs[i].$.removeClass('animate'); } if (tab === oldTab) { tab.$.hasClass('lw-visibility-hidden') ? tab.$.removeClass('lw-visibility-hidden') : tab.$.addClass('lw-visibility-hidden'); that._animatedOldTab.classToRemove = side1; return; } if (indexGreaterThanOldIndex) { tab.$.addClass(side1); tab.$.removeClass('lw-visibility-hidden'); oldTab.$.addClass('animate'); tab.$.addClass('animate'); oldTab.$.addClass(side2); oldTab.$.addClass('lw-visibility-hidden'); tab.$.removeClass(side1); that._animatedOldTab.classToRemove = side2; } else { tab.$.addClass(side2); tab.$.removeClass('lw-visibility-hidden'); oldTab.$.addClass('animate'); tab.$.addClass('animate'); oldTab.$.addClass(side1); oldTab.$.addClass('lw-visibility-hidden'); tab.$.removeClass(side2); that._animatedOldTab.classToRemove = side1; } } /** * Shows or hides the scroll buttons. */ _applyConditionalTabOverflow() { const that = this, verticalPosition = that.tabPosition === 'left' || that.tabPosition === 'right', tabStrip = that.$.tabStrip; if (that.tabLayout === 'scroll') { that._checkOverflowScroll(); return; } if (that._flexWritingModeNoFullSupport && that.tabLayout === 'shrink' && verticalPosition && tabStrip.scrollHeight > tabStrip.offsetHeight) { const tabStripChildren = tabStrip.children, height = 100 / tabStripChildren.length + '%'; tabStrip.$.addClass('shrink-tabs-vertical'); for (let i = 0; i < tabStripChildren.length; i++) { tabStripChildren[i].style.height = height; tabStripChildren[i].firstElementChild.firstElementChild.classList.add('lw-tab-label-text-container-full-height'); } that._inlineStyleTabStripChildren = true; } } /** * Applies label sizes. */ _applyLabelSizes(condition, removeLabelSize) { const that = this, newDimension = that._orientationSettings.dimension, oldDimension = newDimension === 'width' ? 'height' : 'width'; for (let i = 0; i < that._reorderItems.length; i++) { const currentItem = that._reorderItems[i], correspondingCustomElement = that._getCorrespondingCustomElement(currentItem); if (correspondingCustomElement.labelSize !== null) { if (condition === 'tabPosition') { currentItem.style.removeProperty(oldDimension); } if (!removeLabelSize) { currentItem.style[newDimension] = parseInt(correspondingCustomElement.labelSize, 10) + 'px'; } else { currentItem.style.removeProperty(newDimension); } } } } /** * Applies the necessary adjustments in order to achieve the chosen tab overflow. */ _applyTabOverflow() { const that = this; if (!that._tabs) { return; } that._removeInlineStyle(); if (that._tabs.length === 0) { that._toggleNavigationElementsVisibility(); return; } const tabLayout = that.tabLayout, position = that.tabPosition, verticalPosition = position === 'left' || position === 'right', tabStrip = that.$.tabStrip; that._closeDropDownButtonDropDown(); switch (tabLayout) { case 'scroll': case 'dropDown': if (that._flexWritingModeNoFullSupport && that.tabTextOrientation === 'vertical' && verticalPosition) { that._fixTabStripNotChrome(tabStrip); } break; case 'wrap': if (that.tabTextOrientation === 'vertical') { if (that._flexWritingModeNoFullSupport) { // fix for flexbox-related issues in Firefox, Edge, and Safari if (verticalPosition) { that._fixTabStripNotChrome(tabStrip); } else { const tabStripChildren = tabStrip.children; let greatestHeight = tabStripChildren[0].offsetHeight; for (let i = 1; i < tabStripChildren.length; i++) { greatestHeight = Math.max(greatestHeight, tabStripChildren[i].offsetHeight); } for (let i = 1; i < tabStripChildren.length; i++) { tabStripChildren[i].style.height = greatestHeight + 'px'; } that._inlineStyleTabStripChildren = true; } } else if (!verticalPosition) { if (tabStrip.scrollHeight > tabStrip.offsetHeight) { tabStrip.style.height = tabStrip.scrollHeight + 'px'; that._inlineStyleTabStrip = true; } } } else if (verticalPosition && (tabStrip.scrollWidth > tabStrip.offsetWidth)) { tabStrip.style.width = tabStrip.scrollWidth + 'px'; if (position === 'right') { tabStrip.style.flexWrap = 'wrap-reverse'; } that._inlineStyleTabStrip = true; } break; case 'shrink': { if (!verticalPosition) { if (tabStrip.scrollWidth > tabStrip.offsetWidth) { tabStrip.$.addClass('shrink-tabs'); } } else if (that._flexWritingModeNoFullSupport && that.tabTextOrientation === 'vertical') { const tabStripChildren = tabStrip.children, computedStyle = window.getComputedStyle(tabStripChildren[0].firstElementChild), paddings = parseInt(computedStyle.paddingLeft, 10) + parseInt(computedStyle.paddingRight, 10); let maxWidth = 0; for (let i = 0; i < tabStripChildren.length; i++) { maxWidth = Math.max(maxWidth, tabStripChildren[i].firstElementChild.firstElementChild.offsetWidth); } tabStrip.style.width = (paddings + maxWidth) + 'px'; that._inlineStyleTabStrip = true; break; } } } that._applyConditionalTabOverflow(); that._getTabCoordinates(); that._fixTabStripFlex(tabLayout); that._toggleNavigationElementsVisibility(); that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], true); } /** * Checks if items overflow and shows/hides scroll buttons. */ _checkOverflowScroll() { const that = this, tabsHeaderSection = that.$tabsHeaderSection, tabStrip = that.$.tabStrip, overflow = that.overflow; if (overflow === 'hidden') { return; } let overflowing, showNear, showFar; if (!(that.tabPosition === 'left' || that.tabPosition === 'right')) { const scrollLeft = Math.abs(that._getScrollLeft()); overflowing = Math.round(tabStrip.scrollWidth) > Math.round(tabStrip.offsetWidth); if (that.rightToLeft) { showFar = Math.round(scrollLeft) > 0; showNear = Math.round(tabStrip.offsetWidth + scrollLeft) < Math.round(tabStrip.scrollWidth); } else { showNear = Math.round(scrollLeft) > 0; showFar = Math.round(tabStrip.offsetWidth + scrollLeft) < Math.round(tabStrip.scrollWidth); } } else { overflowing = Math.round(tabStrip.scrollHeight) > Math.round(tabStrip.offsetHeight); showNear = Math.round(tabStrip.scrollTop) > 0; showFar = Math.round(tabStrip.offsetHeight + tabStrip.scrollTop) < Math.round(tabStrip.scrollHeight); } if (overflow === 'scroll') { tabsHeaderSection.addClass('scroll-buttons-shown'); that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); } if (overflowing) { if (overflow === 'auto') { if (!tabsHeaderSection.hasClass('scroll-buttons-shown')) { tabsHeaderSection.addClass('scroll-buttons-shown'); } if (showNear) { that.$scrollButtonNear.removeClass('lw-hidden'); } else { that.$scrollButtonNear.addClass('lw-hidden'); } if (showFar) { that.$scrollButtonFar.removeClass('lw-hidden'); } else { that.$scrollButtonFar.addClass('lw-hidden'); } if ((showNear && showFar) === false) { tabsHeaderSection.addClass('one-button-shown'); } else { tabsHeaderSection.removeClass('one-button-shown'); } if (!that.disabled) { that.$.scrollButtonNear.disabled = false; that.$.scrollButtonFar.disabled = false; } } else { tabsHeaderSection.removeClass('one-button-shown'); if (that.disabled) { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } else { that.$.scrollButtonNear.disabled = !showNear; that.$.scrollButtonFar.disabled = !showFar; } } } else if (!overflowing && overflow === 'auto' && tabsHeaderSection.hasClass('scroll-buttons-shown')) { tabsHeaderSection.removeClass('scroll-buttons-shown'); tabsHeaderSection.removeClass('one-button-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); } else if (!overflowing && overflow === 'scroll') { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } } /** * lw-tab-item closeButtonVisibilityChange event handler. */ _closeButtonVisibilityChangeHandler(event) { const that = this, index = (LW.EnableShadowDOM ? event.composedPath()[0] : event.target).index; if (that.closeButtonMode === 'selected') { that._tabLabelContainers[index].closeButtonEnabled = event.detail.hidden; return; } if (event.detail.hidden) { that._disableCloseButton(index); } else { that._enableCloseButton(index); } } /** * Closes the dropdown in mode 'dropDown'. */ _closeDropDownButtonDropDown() { const that = this; if (that._dropDownButtonDropDownOpened) { that.$.dropDownButton.setAttribute('aria-expanded', false); that.$dropDownButtonDropDown.addClass('lw-hidden'); that._dropDownButtonDropDownOpened = false; } } /** * Closes the open group dropdown. */ _closeGroupDropDown() { const that = this; if (!that._openDropDown) { return; } const group = that._openDropDown.groupContainer; if (that._openDropDown.rippleInProgress) { setTimeout(function () { if (that._openDropDown) { group.setAttribute('aria-expanded', false); that._openDropDown.$.addClass('lw-hidden'); delete that._openDropDown.rippleInProgress; that._openDropDown = undefined; } }, 450); } else { group.setAttribute('aria-expanded', false); that._openDropDown.$.addClass('lw-hidden'); that._openDropDown = undefined; } } /** * Container event handler. */ _containerHandler(event) { const that = this, eventType = event.type; if (that.disabled || that.readonly || (that._resizing && eventType !== 'mouseout') || ((eventType === 'down' || eventType === 'up') && event.which !== 1 && !LW.Utilities.Core.isMobile)) { return; } const target = that.shadowRoot || that.isInShadowDOM ? (event.originalEvent || event).composedPath()[0] : (event.originalEvent || event).target; if (that.$.tabContentSection.contains(target)) { return; } if (that.$.dropDownButton.contains(target)) { that._dropDownButtonHandler(target, event); return; } if (that.$.dropDownButtonDropDown.contains(target)) { that._dropDownButtonHandler(target, event, true); return; } that._tabStripHandler(target, event); } /** * Disables the close button of a tab. * * @param {Number} index The index of which tab's close button to hide. */ _disableCloseButton(index) { const that = this, tabLabelContainer = that._tabLabelContainers[index]; tabLabelContainer.closeButtonEnabled = false; if (that.closeButtons) { that._hideCloseButton(tabLabelContainer); } } /** * Document (mouse)move handler. */ _documentMoveHandler(event) { const that = this, orientationSettings = that._orientationSettings; if (that._reordering) { if (!that._reorderStartThrown) { that._fireDragEvent(event, 'dragStart'); that._reorderStartThrown = true; } const mouseCoordinate = event[orientationSettings.coordinate], condition = that.tabLayout !== 'wrap' ? function (currentCoordinateSet) { return mouseCoordinate >= currentCoordinateSet[orientationSettings.from] && mouseCoordinate <= currentCoordinateSet[orientationSettings.to]; } : function (currentCoordinateSet) { return event.pageX >= currentCoordinateSet.fromX && event.pageX <= currentCoordinateSet.toX && event.pageY >= currentCoordinateSet.fromY && event.pageY <= currentCoordinateSet.toY; }; let inTab = false; for (let i = 0; i < that._tabCoordinates.length; i++) { const currentCoordinateSet = that._tabCoordinates[i]; if (condition(currentCoordinateSet)) { inTab = i; break; } } if (that._preventReorder !== true && inTab !== false && inTab !== that._draggedIndex) { that._reorderTabs(that._draggedIndex, inTab); that._closeGroupDropDown(); that._draggedIndex = inTab; that._getReorderItems(); that._getTabCoordinates(); } const draggedIndexCoordinates = that._tabCoordinates[that._draggedIndex]; if (that.tabLayout !== 'wrap' && (mouseCoordinate < draggedIndexCoordinates[orientationSettings.from] || mouseCoordinate > draggedIndexCoordinates[orientationSettings.to]) || that.tabLayout === 'wrap' && (event.originalEvent.target.closest('.lw-tab-label-container') !== null || event.originalEvent.target.closest('.lw-tab-group-container') !== null) && !(event.pageX >= draggedIndexCoordinates.fromX && event.pageX <= draggedIndexCoordinates.toX && event.pageY >= draggedIndexCoordinates.fromY && event.pageY <= draggedIndexCoordinates.toY)) { that._preventReorder = true; } else { that._preventReorder = false; } } else if (that._resizing) { that.$.resizeToken.style[orientationSettings.edge] = event[orientationSettings.coordinate] - that._tabsHeaderSectionCoordinate + 'px'; that.$resizeToken.removeClass('lw-hidden'); } } /** * Document (mouse)up handler. */ _documentUpHandler(event) { const that = this; let target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.$.container.contains(target)) { that._containerHandler(event); } if (that._touchmoveInside) { that._endSwiping(event, Date.now()); } else { delete that._dragStartDetails; delete that._swiping; } delete that._touchCoords; delete that._touchmoveInside; if (that._openDropDown && !that._openDropDown.rippleInProgress && (target === document || target.closest('.lw-tab-group-container') !== that._openDropDown.groupContainer) && event.originalEvent.type !== 'pointercancel') { that._closeGroupDropDown(); } if (!that.$.dropDownButton.contains(target) && event.originalEvent.type !== 'pointercancel') { that._closeDropDownButtonDropDown(); } that._endReordering(event, target); that._resize(event); if (that._tabToResize !== undefined) { that._tabToResize = undefined; } delete that._downTarget; } /** * Dropdown button and dropdown event handler. */ _dropDownButtonHandler(target, event, dropDown) { const that = this, eventType = event.type; if (dropDown) { if (target.classList.contains('lw-tab-label-container')) { switch (eventType) { case 'down': that._downTarget = target; break; case 'mouseout': target.removeAttribute('hover'); break; case 'mouseover': target.setAttribute('hover', ''); break; case 'up': if (target === that._downTarget && event.originalEvent && event.originalEvent.type !== 'pointercancel') { that.select(Array.from(that.$.dropDownButtonDropDown.children).indexOf(target)); that._closeDropDownButtonDropDown(); } break; } } return; } if (eventType === 'down') { that._downTarget = that.$.dropDownButton; } else if (eventType === 'up' && that._downTarget === that.$.dropDownButton) { if (!that._dropDownButtonDropDownOpened) { const tabPosition = that.tabPosition; let left, top; that.$.dropDownButton.setAttribute('aria-expanded', true); switch (tabPosition) { case 'top': left = that.$.dropDownButton.offsetLeft; top = that.$.tabsHeaderSection.offsetTop + that.$.dropDownButton.offsetHeight; break; case 'bottom': left = that.$.dropDownButton.offsetLeft; top = that.$.tabsHeaderSection.offsetTop; break; case 'left': left = that.$.dropDownButton.offsetWidth; top = that.$.dropDownButton.offsetTop; break; case 'right': left = that.$.tabsHeaderSection.offsetLeft; top = that.$.dropDownButton.offsetTop; break; } that.$.dropDownButtonDropDown.style.left = left + 'px'; that.$.dropDownButtonDropDown.style.top = top + 'px'; that.$dropDownButtonDropDown.removeClass('lw-hidden'); that._dropDownButtonDropDownOpened = true; } else { that._closeDropDownButtonDropDown(); } } } /** * Enables the close button of a tab. * * @param {Number} index The index of which tab's close button to show. */ _enableCloseButton(index) { const that = this, tabLabelContainer = that._tabLabelContainers[index]; tabLabelContainer.closeButtonEnabled = true; if (that.closeButtons) { that._showCloseButton(tabLabelContainer); } } /** * Ends reordering operation. */ _endReordering(event, target) { const that = this; if (!that._reordering) { return; } if (that._draggedHoveredTab) { if (!that._draggedHoveredTab.contains(target)) { that._draggedHoveredTab.removeAttribute('hover'); } delete that._draggedHoveredTab; } that._reorderedIndex = undefined; that._reordering = false; that._reorderStartThrown = false; that.removeAttribute('dragged'); if (event) { that._fireDragEvent(event, 'dragEnd'); } } /** * Ends swiping and scrolls kinetically. */ _endSwiping(event, now) { const that = this; if (!that._dragStartDetails) { return; } const orientationSettings = that._orientationSettings, tabStrip = that.$.tabStrip, timeDifference = Math.abs(that._dragStartDetails.startTime - now), speed = 200 / timeDifference, distanceDifference = (that._dragStartDetails[orientationSettings.startCoordinate] - event[orientationSettings.coordinate]) * speed; let remaining = Math.abs(distanceDifference); const scrollable = function () { if (that.rightToLeft && orientationSettings.scrollDirection === 'scrollLeft') { const scrollLeft = Math.abs(that._getScrollLeft()); if (distanceDifference < 0 && scrollLeft === tabStrip[orientationSettings.scrollSize] - tabStrip[orientationSettings.size] || distanceDifference > 0 && scrollLeft === 0) { return false; } } else { if (distanceDifference > 0 && tabStrip[orientationSettings.scrollDirection] === tabStrip[orientationSettings.scrollSize] - tabStrip[orientationSettings.size] || distanceDifference < 0 && tabStrip[orientationSettings.scrollDirection] === 0) { return false; } } return true; } let scrollStep = 0.03 * Math.abs(distanceDifference) * speed; const kineticScrolling = function () { if (scrollStep > 5) { const remainingPart = (remaining - scrollStep) / Math.abs(distanceDifference); if (remainingPart < 0.1) { scrollStep /= 1.25; } else if (remainingPart < 0.15) { scrollStep /= 1.2; } else if (remainingPart < 0.2) { scrollStep /= 1.15; } else if (remainingPart < 0.25) { scrollStep /= 1.1; } else if (remainingPart < 0.3) { scrollStep /= 1.05; } } scrollStep = Math.round(scrollStep); const oldScrollDirection = tabStrip[orientationSettings.scrollDirection]; if (that.rightToLeft && orientationSettings.scrollDirection === 'scrollLeft') { if (LW.Utilities.Core.Browser.Chrome) { if (distanceDifference > 0) { tabStrip[orientationSettings.scrollDirection] = Math.max(oldScrollDirection + scrollStep, 0); } else { tabStrip[orientationSettings.scrollDirection] = Math.min(oldScrollDirection - scrollStep, tabStrip[orientationSettings.scrollSize] - tabStrip[orientationSettings.size]); } } else { if (distanceDifference > 0) { tabStrip[orientationSettings.scrollDirection] = Math.min(oldScrollDirection + scrollStep, tabStrip[orientationSettings.scrollSize] - tabStrip[orientationSettings.size]); } else { tabStrip[orientationSettings.scrollDirection] = Math.min(oldScrollDirection - scrollStep, 0); } } } else { if (distanceDifference > 0) { tabStrip[orientationSettings.scrollDirection] = Math.min(oldScrollDirection + scrollStep, tabStrip[orientationSettings.scrollSize] - tabStrip[orientationSettings.size]); } else { tabStrip[orientationSettings.scrollDirection] = Math.max(oldScrollDirection - scrollStep, 0); } } remaining -= scrollStep; that._updateScrollButtonVisibility(true); const canBeScrolled = scrollable(); if (remaining > 0 && canBeScrolled) { that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling); } else { that._wheelInProgress = false; } }; if (that._scrollingAnimationFrame) { cancelAnimationFrame(that._scrollingAnimationFrame); } if (timeDifference < 500 && scrollable()) { that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling); } else { that._wheelInProgress = false; } delete that._dragStartDetails; if (that._swiping) { delete that._swiping; } } /** * Fires the "dragStart" or "dragEnd" event. */ _fireDragEvent(event, eventToFire) { const that = this, target = that.$.tabStrip.children[that._draggedIndex], tab = target.tab; let selected, index, label; if (tab) { selected = tab.selected; index = tab.index; label = tab.label; } else { label = target.group; } that.$.fireEvent(eventToFire, { 'position': { left: event.pageX, top: event.pageY }, 'target': target, 'selected': selected, 'index': index, 'label': label }); } /** * Fix for the tab strip layout in Firefox, Edge, and Safari when the position and text orientation are vertical. */ _fixTabStripNotChrome(tabStrip) { const that = this; function recalcTabStripWidth() { const tabStripChildren = [].slice.call(tabStrip.children).filter(item => !item._lazyRemove); let rect = tabStripChildren[0].getBoundingClientRect(), leastStartX = rect.left, greatestEndX = leastStartX + tabStripChildren[0].offsetWidth; for (let i = 1; i < tabStripChildren.length; i++) { rect = tabStripChildren[i].getBoundingClientRect(); leastStartX = Math.min(leastStartX, rect.left); greatestEndX = Math.max(greatestEndX, rect.left + tabStripChildren[i].offsetWidth); } tabStrip.style.width = greatestEndX - leastStartX + 'px'; that._inlineStyleTabStrip = true; } if (that._tabs.length === 0) { return; } recalcTabStripWidth(); if (LW.Utilities.Core.Browser.Safari) { setTimeout(function () { tabStrip.parentElement.classList.add('lw-hidden'); setTimeout(function () { tabStrip.parentElement.classList.remove('lw-hidden'); recalcTabStripWidth(); }, 10); }, 10); } //Necessary for cases where the tab is nested for example in a Layout and resize has to be called on the Layout. that.$.fireEvent('tabStripResize'); } /** * Fix for a flexbox-related issue in Chrome. */ _fixTabStripFlex(tabLayout) { const that = this; if (!that._flexWritingModeNoFullSupport && that.tabTextOrientation === 'vertical' && (that.tabPosition === 'left' || that.tabPosition === 'right')) { setTimeout(function () { that.$tabsHeaderSection.addClass('lw-hidden'); setTimeout(function () { that.$tabsHeaderSection.removeClass('lw-hidden'); that._getTabCoordinates(); if (tabLayout === 'scroll') { that._checkOverflowScroll(); } }, 10); }, 10); } } /** * Returns the custom element corresponding to the passed tab strip element. */ _getCorrespondingCustomElement(currentItem) { if (currentItem.$.hasClass('lw-tab-label-container')) { return currentItem.tab; } else { return this.$.tabContentSection.querySelector('lw-tab-items-group[label="' + currentItem.group + '"]'); } } /** * Stores the items that can be reordered in an Array. */ _getReorderItems() { const that = this; let reorderItems; if (that._groups.length === 0) { reorderItems = that._tabLabelContainers; } else { reorderItems = Array.from(that.$.tabStrip.children); if (that.addNewTab) { reorderItems.pop(); } } that._reorderItems = reorderItems; } /** * Stores the coordinates of tab label containers in an Array (for use in reorder and resize functionalities). */ _getTabCoordinates() { const that = this; if ((!that.reorder && !that.resize) || that.tabPosition === 'hidden') { return; } const coordinates = [], windowScrollX = window.scrollX || window.pageXOffset, windowScrollY = window.scrollY || window.pageYOffset; for (let i = 0; i < that._reorderItems.length; i++) { const currentTabLabelContainer = that._reorderItems[i], boundingClientRect = currentTabLabelContainer.getBoundingClientRect(), style = window.getComputedStyle(currentTabLabelContainer), marginLeft = parseFloat(style.marginLeft), marginRight = parseFloat(style.marginRight), marginTop = parseFloat(style.marginTop), marginBottom = parseFloat(style.marginBottom); coordinates.push({ fromX: boundingClientRect.left - marginLeft + windowScrollX, toX: boundingClientRect.right + marginRight + windowScrollX, fromY: boundingClientRect.top - marginTop + windowScrollY, toY: boundingClientRect.bottom + marginBottom + windowScrollY }); } that._tabCoordinates = coordinates; } /** * Stores tabs in an Array. */ _getTabs() { const that = this; let tabs = that.shadowRoot ? that.shadowRoot.querySelectorAll('lw-tab-item') : that.getElementsByTagName('lw-tab-item'); if (that.selectedIndex !== null) { if (tabs.length === 0) { that.selectedIndex = null; } else { that.selectedIndex = Math.max(0, Math.min(that.selectedIndex, tabs.length - 1)); } } that._tabs = Array.from(tabs); that.$.hiddenInput.value = that.selectedIndex; } /** * Group container event handler. */ _groupContainerHandler(currentElement, eventType) { const that = this, dropDown = currentElement.dropDown; if (eventType === 'down') { that._downTarget = currentElement; if (that.reorder && that._reorderItems.length > 1) { that._getTabCoordinates(); that._reordering = true; that.setAttribute('dragged', ''); that._draggedIndex = Array.from(that.$.tabStrip.children).indexOf(currentElement); } return; } if (!that._reordering && !that._swiping) { if (dropDown !== that._openDropDown && eventType === 'mouseover' && !currentElement.classList.contains('lw-tab-group-selected')) { currentElement.setAttribute('hover', ''); } else if (eventType === 'mouseout') { currentElement.removeAttribute('hover'); } } if (eventType !== 'up' || that._downTarget !== currentElement || that._reorderedIndex !== undefined || that._swiping) { return; } if (dropDown === that._openDropDown) { that._closeGroupDropDown(); if (!currentElement.classList.contains('lw-tab-group-selected')) { currentElement.setAttribute('hover', ''); } } else { that._openGroupDropDown(currentElement); } } /** * Handles changes to the "tabPosition" property. */ _handlePosition(newPosition, oldPosition) { const that = this; if ([undefined, 'top', 'left', 'hidden'].indexOf(oldPosition) !== -1 && (newPosition === 'bottom' || newPosition === 'right')) { that.$.container.insertBefore(that.$.tabContentSection, that.$.tabsHeaderSection); } else if ((oldPosition === 'bottom' || oldPosition === 'right') && ['top', 'left', 'hidden'].indexOf(newPosition) !== -1) { that.$.container.insertBefore(that.$.tabsHeaderSection, that.$.tabContentSection); } if (newPosition === 'hidden') { that._orientationSettings = { coordinate: 'pageY', dimension: 'height', edge: 'top', from: 'fromY', size: 'offsetHeight', to: 'toY', scrollDirection: 'scrollTop', scrollSize: 'scrollHeight', startCoordinate: 'startY', wheelOffset: 35 }; that.removeAttribute('horizontal'); that.removeAttribute('vertical'); that.setAttribute('aria-orientation', 'horizontal'); return; } if (newPosition === 'top' || newPosition === 'bottom') { that._orientationSettings = { coordinate: 'pageX', dimension: 'width', edge: 'left', from: 'fromX', size: 'offsetWidth', to: 'toX', scrollDirection: 'scrollLeft', scrollSize: 'scrollWidth', startCoordinate: 'startX', wheelOffset: 70 }; that.removeAttribute('vertical'); that.setAttribute('horizontal', ''); that.$arrowNear.removeClass('lw-arrow-up'); that.$arrowNear.addClass('lw-arrow-left'); that.$arrowFar.removeClass('lw-arrow-down'); that.$arrowFar.addClass('lw-arrow-right'); that.setAttribute('aria-orientation', 'horizontal'); that.$.scrollButtonNear.setAttribute('aria-label', 'Scroll left'); that.$.scrollButtonFar.setAttribute('aria-label', 'Scroll right'); } else { that._orientationSettings = { coordinate: 'pageY', dimension: 'height', edge: 'top', from: 'fromY', size: 'offsetHeight', to: 'toY', scrollDirection: 'scrollTop', scrollSize: 'scrollHeight', startCoordinate: 'startY', wheelOffset: 35 }; that.removeAttribute('horizontal'); that.setAttribute('vertical', ''); that.$arrowNear.removeClass('lw-arrow-left'); that.$arrowNear.addClass('lw-arrow-up'); that.$arrowFar.removeClass('lw-arrow-right'); that.$arrowFar.addClass('lw-arrow-down'); that.setAttribute('aria-orientation', 'vertical'); that.$.scrollButtonNear.setAttribute('aria-label', 'Scroll up'); that.$.scrollButtonFar.setAttribute('aria-label', 'Scroll down'); } } /** * Handles changes to the "scrollButtonsPosition" property. */ _handleScrollButtonsPosition(newScrollButtonsPosition, oldScrollButtonsPosition) { const that = this, tabsHeaderItems = that.$.tabsHeaderItems; if (newScrollButtonsPosition === oldScrollButtonsPosition) { return; } if (newScrollButtonsPosition === 'both') { if (oldScrollButtonsPosition === 'near') { tabsHeaderItems.insertBefore(that.$.scrollButtonFar, that.$.dropDownButton); } else { tabsHeaderItems.insertBefore(that.$.scrollButtonNear, that.$.tabStrip); } } else if (newScrollButtonsPosition === 'near') { if (oldScrollButtonsPosition === 'far') { tabsHeaderItems.insertBefore(that.$.scrollButtonNear, that.$.tabStrip); } tabsHeaderItems.insertBefore(that.$.scrollButtonFar, that.$.tabStrip); } else { if (oldScrollButtonsPosition === 'near') { tabsHeaderItems.insertBefore(that.$.scrollButtonFar, that.$.dropDownButton); } tabsHeaderItems.insertBefore(that.$.scrollButtonNear, that.$.scrollButtonFar); } } /** * Hides the close button of a tab. */ _hideCloseButton(tabLabelContainer) { tabLabelContainer.firstElementChild.children[0].$.removeClass('lw-close-button-enabled'); tabLabelContainer.firstElementChild.children[1].$.addClass('lw-hidden'); } /** * lw-tab-item indexChange event handler. */ _indexChangeHandler(event) { const that = this, oldIndex = event.detail.oldIndex, validNewIndex = Math.max(0, Math.min(event.detail.newIndex, that._tabs.length - 1)); if (oldIndex !== validNewIndex) { if (that._groups.length === 0) { that._reorderTabs(oldIndex, validNewIndex); } else { const tabItem = event.detail.tabItem; tabItem._setIndex(oldIndex); that.removeAt(oldIndex); that.insert(validNewIndex, { node: tabItem }); if (that.selectedIndex === oldIndex) { that._select(validNewIndex, false); } } that._reorderedIndex = undefined; } } /** * Inserts the "add new" tab. */ _insertAddNewTab() { const that = this, tabLabelContainer = that._addTabLabelContainer(undefined, true).tabLabelContainer; tabLabelContainer.$.addClass('lw-add-new-tab'); that.$.tabStrip.appendChild(tabLabelContainer); that._addNewTab = tabLabelContainer; } /** * Inserts a tab into an existing group. */ _insertIntoExistingGroup(details) { const that = this, lwTabItemsGroup = details.lwTabItemsGroup, tab = details.tab, tabLabelContainer = details.tabLabelContainer, group = details.group, groupLabel = that._groupLabels[that._groups.indexOf(group)], groupDropDown = groupLabel.dropDown; let index = details.index; index = Math.max(0, Math.min(index, lwTabItemsGroup.childElementCount)); groupDropDown.insertBefore(tabLabelContainer, groupDropDown.children[index]); const sibling = lwTabItemsGroup.children[index]; let overallIndex; if (sibling) { overallIndex = sibling.index; } else { overallIndex = lwTabItemsGroup.children[index - 1].index + 1; } lwTabItemsGroup.insertBefore(tab, sibling); that._tabLabelContainers.splice(overallIndex, 0, tabLabelContainer); that.$.dropDownButtonDropDown.insertBefore(details.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[overallIndex] || null); that._tabs.splice(overallIndex, 0, tab); index = overallIndex; tab.group = group; that._updateIndexes(index); } /** * Inserts a tab into a new group. */ _insertIntoNewGroup(details) { const that = this, tab = details.tab, tabLabelContainer = details.tabLabelContainer, group = details.group, groupContainers = that._addGroupContainer(group), groupLabel = groupContainers.label, groupDropDown = groupContainers.dropDown; groupDropDown.appendChild(tabLabelContainer); that._groups.push(group); let index = Math.max(0, Math.min(details.index, that.$.tabStrip.childElementCount)), tabStripIndex = index; if (that._addNewTab && tabStripIndex === that.$.tabStrip.childElementCount) { tabStripIndex--; } that.$.tabStrip.insertBefore(groupLabel, that.$.tabStrip.children[tabStripIndex] || null); that._groupLabels.push(groupLabel); const newLWTabItemsGroup = document.createElement('lw-tab-items-group'); newLWTabItemsGroup.appendChild(tab); that.$.tabContentSection.insertBefore(newLWTabItemsGroup, that.$.tabContentSection.children[index]); newLWTabItemsGroup.label = group; const previousSibling = newLWTabItemsGroup.previousElementSibling; let overallIndex = 0; if (previousSibling) { if (previousSibling instanceof LW.TabItem) { overallIndex = previousSibling.index + 1; } else if (previousSibling) { overallIndex = previousSibling.lastElementChild.index + 1; } } that._tabLabelContainers.splice(overallIndex, 0, tabLabelContainer); that.$.dropDownButtonDropDown.insertBefore(details.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[overallIndex] || null); that._tabs.splice(overallIndex, 0, tab); index = overallIndex; tab.group = group; that._updateIndexes(index); } /** * Inserts a stand-alone tab when there are groups. */ _insertNearAGroup(details) { const that = this, tab = details.tab, tabLabelContainer = details.tabLabelContainer; let index = details.index; index = Math.max(0, Math.min(index, that._tabs.length)); const previous = that._tabs[index - 1], next = that._tabs[index], groupOfNext = next ? next.group : undefined; if (previous && previous.group !== null && next && groupOfNext !== null) { // insert into group next.tabLabelContainer.parentElement.insertBefore(tabLabelContainer, next.tabLabelContainer); next.parentElement.insertBefore(tab, next); tab.group = groupOfNext; } else { if (next) { if (groupOfNext !== null) { that.$.tabStrip.insertBefore(tabLabelContainer, that._groupLabels[that._groups.indexOf(groupOfNext)]); that.$.tabContentSection.insertBefore(tab, that.$.tabContentSection.querySelector('lw-tab-items-group[label="' + groupOfNext + '"]')); } else { that.$.tabStrip.insertBefore(tabLabelContainer, next.tabLabelContainer); that.$.tabContentSection.insertBefore(tab, next); } } else { that.$.tabStrip.insertBefore(tabLabelContainer, that._addNewTab || null); that.$.tabContentSection.appendChild(tab); } } that._tabLabelContainers.splice(index, 0, tabLabelContainer); that.$.dropDownButtonDropDown.insertBefore(details.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[index] || null); that._tabs.splice(index, 0, tab); that._updateIndexes(index); } /** * Inserts a tab when there are no groups. */ _insertNoGrouping(tabDetails) { const that = this, index = Math.max(0, Math.min(tabDetails.index, that._tabs.length)), tab = tabDetails.tab, tabLabelContainer = tabDetails.tabLabelContainer; that.$.tabStrip.insertBefore(tabLabelContainer, that._tabLabelContainers[index] || that._addNewTab || null); that.$.tabContentSection.insertBefore(tab, that._tabs[index] || null); that._tabLabelContainers.splice(index, 0, tabLabelContainer); that.$.dropDownButtonDropDown.insertBefore(tabDetails.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[index] || null); that._tabs.splice(index, 0, tab); that._updateIndexes(index); } /** * keydown event handler. */ _keydownHandler(event) { const that = this, key = event.key, activeElement = that.isInShadowDOM ? that.getRootNode().activeElement : document.activeElement; if (activeElement !== that || ['ArrowLeft', 'ArrowDown', 'ArrowRight', 'ArrowUp', 'End', 'Home', 'Enter', ' ', 'Escape'].indexOf(key) === -1 || that.disabled || that.readonly || that.selectionMode === 'none' || (!that.allowToggle && that.selectedIndex === null) || that._reordering || that._swiping) { return; } event.preventDefault(); const lastTabIndex = that._tabs.length - 1; let indexToSelect, noSelect, keyPrevious, keyNext, step = 0; if (that.rightToLeft) { keyPrevious = 'ArrowRight'; keyNext = 'ArrowLeft'; } else { keyPrevious = 'ArrowLeft'; keyNext = 'ArrowRight'; } switch (key) { case keyPrevious: case 'ArrowUp': if (that.collapsible && event.ctrlKey) { if (key === keyPrevious) { if (that.tabPosition === 'right') { that.expand(); } else if (that.tabPosition === 'left') { that.collapse(); } } else if (key === 'ArrowUp') { if (that.tabPosition === 'bottom') { that.expand(); } else if (that.tabPosition === 'top') { that.collapse(); } } return; } step = -1; // selects previous tab if (that.selectedIndex === 0) { noSelect = true; break; } indexToSelect = that.selectedIndex + step; break; case keyNext: case 'ArrowDown': if (that.collapsible && event.ctrlKey) { if (key === keyNext) { if (that.tabPosition === 'right') { that.collapse(); } else if (that.tabPosition === 'left') { that.expand(); } } else if (key === 'ArrowDown') { if (that.tabPosition === 'bottom') { that.collapse(); } else if (that.tabPosition === 'top') { that.expand(); } } return; } step = 1; // selects next tab if (that.selectedIndex === lastTabIndex) { noSelect = true; break; } indexToSelect = that.selectedIndex + step; break; case 'End': if (that.selectedIndex === lastTabIndex) { noSelect = true; break; } indexToSelect = lastTabIndex; break; case 'Home': if (that.selectedIndex === 0) { noSelect = true; break; } indexToSelect = 0; break; case 'Enter': case ' ': if (!that.allowToggle) { return; } if (that._focusedItem) { that.select(that._focusedItem.index); const closestGroupContainer = that._focusedItem.tabLabelContainer.closest('.lw-tab-group-drop-down'); if (closestGroupContainer) { that._openGroupDropDown(closestGroupContainer.groupContainer); } } return; case 'Escape': if (that._openDropDown) { that._closeGroupDropDown(); } return; } if (that.allowToggle && that._tabs.length > 0) { if (that._focusedItem) { that._focusedItem.tabLabelContainer.removeAttribute('focus'); } else { that._focusedItem = that._focusedItem || that._tabs[that.selectedIndex] || that._tabs[0]; } that._focusedItem = that._tabs[Math.min(Math.max(0, that._focusedItem.index + step), lastTabIndex)]; that._focusedItem.tabLabelContainer.setAttribute('focus', ''); that.ensureVisible(that._focusedItem.index); const closestGroupContainer = that._focusedItem.tabLabelContainer.closest('.lw-tab-group-drop-down'); if (closestGroupContainer && closestGroupContainer.groupContainer) { if (that._openDropDown && that._openDropDown !== closestGroupContainer.dropDown) { that._closeGroupDropDown(); } that._openGroupDropDown(closestGroupContainer.groupContainer); } else if (that._openDropDown) { that._closeGroupDropDown(); } return; } if (!noSelect) { that.select(indexToSelect); } } /** * Tab label container/label text container event handler. */ _labelContainerHandler(currentElement, event, eventType) { const that = this, click = eventType === 'up' && that._downTarget === currentElement; if (eventType === 'down') { that._downTarget = currentElement; if (that.selectionMode === 'click' && currentElement !== that._addNewTab) { if (LW.Utilities.Core.isMobile && currentElement.tab.group === null) { const scrollDirection = that.$.tabStrip[that._orientationSettings.scrollDirection]; setTimeout(function () { if (scrollDirection === that.$.tabStrip[that._orientationSettings.scrollDirection]) { const rippleInProgress = that._ripple(event, currentElement); if (rippleInProgress && that._openDropDown && that._openDropDown.contains(currentElement)) { that._openDropDown.rippleInProgress = true; } } }, 100); } else { const rippleInProgress = that._ripple(event, currentElement); if (rippleInProgress && that._openDropDown && that._openDropDown.contains(currentElement)) { that._openDropDown.rippleInProgress = true; } } } } if (currentElement === that._addNewTab) { that._addNewTabHandler(currentElement, eventType, click); return; } const index = currentElement.tab.index, currentElementStatic = !(that._reordering && that._reorderedIndex !== undefined); if (click && index === that.selectedIndex) { that._closeGroupDropDown(); if (currentElementStatic && currentElement.tab.group === null) { that._toggleCollapsedState(); } } if (!that._swiping && (currentElementStatic && that.selectionMode === 'click' && click || !that._reordering && (that.selectionMode === eventType || that.selectionMode === 'mouseenter' && eventType === 'mouseover'))) { that._select(index, true); } if (!that._reordering && !that._swiping && (that.selectionMode === 'click' || that.selectionMode === 'dblclick')) { if (eventType === 'mouseover' && !currentElement.hasAttribute('selected')) { currentElement.setAttribute('hover', ''); } else if (eventType === 'mouseout') { currentElement.removeAttribute('hover'); } } if (that.reorder && eventType === 'down' && currentElement.tab.group === null && that._reorderItems.length > 1) { that._getTabCoordinates(); that._reordering = true; that.setAttribute('dragged', ''); if (currentElement.hasAttribute('hover')) { that._draggedHoveredTab = currentElement; } if (that._groups.length === 0) { that._draggedIndex = currentElement.tab.index; } else { that._draggedIndex = Array.from(that.$.tabStrip.children).indexOf(currentElement); } } } /** * lw-tab-item labelSizeChange event handler. */ _labelSizeChangeHandler(event) { const that = this, newSize = event.detail.size; let correspondingLabelContainer; if (that.tabLayout === 'shrink') { return; } if (event.target instanceof LW.TabItem) { correspondingLabelContainer = event.target.tabLabelContainer; } else { correspondingLabelContainer = that._groupLabels[that._groups.indexOf(event.target.label)]; } if (newSize !== null) { correspondingLabelContainer.style[that._orientationSettings.dimension] = parseInt(newSize, 10) + 'px'; } else { correspondingLabelContainer.style.removeProperty(that._orientationSettings.dimension); } that._applyTabOverflow(); } /** * Opens the open group dropdown. */ _openGroupDropDown(currentElement) { const that = this; if (!currentElement) { return; } if (that._openDropDown) { that._openDropDown.$.addClass('lw-hidden'); } currentElement.dropDown.$.removeClass('lw-hidden'); that._positionGroupDropDown(currentElement); that._openDropDown = currentElement.dropDown; currentElement.removeAttribute('hover'); currentElement.setAttribute('aria-expanded', true); } /** * Orders tabs initially. */ _orderTabs() { const that = this, groups = that.getElementsByTagName('lw-tab-items-group'), indexes = [], list = []; let unset = true, ambiguous = false; if (groups.length === 0) { for (let i = 0; i < that._tabs.length; i++) { const tab = that._tabs[i], index = tab.index; if (unset && index !== null) { unset = false; } if (indexes.indexOf(index || 0) !== -1) { ambiguous = true; if (index !== null) { break; } } indexes.push(index || 0); list.push({ tab: tab, index: index }); } } if (!ambiguous) { const sortedIndexes = indexes.slice(0).sort(function (a, b) { return a - b; }); if (JSON.stringify(indexes) === JSON.stringify(sortedIndexes)) { unset = true; } } if (!unset && !ambiguous) { list.sort(function (a, b) { return a.index - b.index; }); for (let i = 0; i < list.length; i++) { const tab = list[i].tab; tab._setIndex(i); that.$.tabContentSection.removeChild(tab); } for (let i = 0; i < list.length; i++) { const tab = list[i].tab; that.$.tabContentSection.appendChild(tab); that._tabs[i] = tab; } } else { if (!unset) { that.warn(that.localize('ambiguousIndexes')); } for (let i = 0; i < that._tabs.length; i++) { that._tabs[i]._setIndex(i); } } } /** * Populates the tab strip. */ _populateTabStrip() { const that = this, documentFragment = document.createDocumentFragment(), tabLabelContainers = [], groups = [], groupLabels = []; let selectedTabLabelContainer = null; for (let i = 0; i < that._tabs.length; i++) { const tab = that._tabs[i], tabParentElement = tab.parentElement, group = tabParentElement instanceof LW.TabItemsGroup ? tabParentElement.label : null; tab.group = group; const labelContainers = that._addTabLabelContainer(tab), tabLabelContainer = labelContainers.tabLabelContainer, dropDownLabelContainer = labelContainers.dropDownLabelContainer; if (that.selectedIndex === i) { tabLabelContainer.$.addClass('lw-tab-selected'); tabLabelContainer.setAttribute('selected', ''); selectedTabLabelContainer = tabLabelContainer; } tab.tabLabelContainer = tabLabelContainer; tabLabelContainer.tab = tab; tabLabelContainers.push(tabLabelContainer); that._setAriaRelations(tab, tabLabelContainer, dropDownLabelContainer); if (group === null) { documentFragment.appendChild(tabLabelContainer); } else { that._addGroupElements({ documentFragment: documentFragment, groups: groups, groupLabels: groupLabels, i: i, group: group, tabLabelContainer: tabLabelContainer, lwTabItemsGroup: tabParentElement }); } that.$.dropDownButtonDropDown.appendChild(dropDownLabelContainer); } that.$.tabStrip.appendChild(documentFragment); that._tabLabelContainers = tabLabelContainers; that._groups = groups; that._groupLabels = groupLabels; that._positionTabSelectionBar(selectedTabLabelContainer, true); } /** * Sets WAI-ARIA relations between tab and tabpanel elements. */ _setAriaRelations(tab, tabLabelContainer, dropDownLabelContainer) { const that = this, tabsId = that.id; if (!tab.id) { tab.id = tabsId + 'TabItem' + tab.index; } if (!tabLabelContainer.id) { tabLabelContainer.id = tabsId + 'TabLabelContainer' + tab.index; } tabLabelContainer.setAttribute('role', 'tab'); tabLabelContainer.setAttribute('aria-controls', tab.id); tabLabelContainer.setAttribute('aria-label', tab.label); tabLabelContainer.setAttribute('aria-selected', tab.selected); tab.setAttribute('aria-label', tab.label); dropDownLabelContainer.setAttribute('role', 'menuitem'); dropDownLabelContainer.setAttribute('aria-controls', tab.id); } _positionTabSelectionBar(selectedTabLabelContainer, noAnimation) { const that = this; if (!selectedTabLabelContainer) { return; } const tabPosition = that.tabPosition; let left, top, width, height; if (noAnimation) { that.$.tabSelectionBar.style.transition = 'none'; } if (selectedTabLabelContainer.tab.group) { selectedTabLabelContainer = that._groupLabels[that._groups.indexOf(selectedTabLabelContainer.tab.group)]; } if (tabPosition === 'top' || tabPosition === 'bottom') { if (that.tabLayout === 'wrap') { top = selectedTabLabelContainer.offsetTop; if (tabPosition === 'top') { top += selectedTabLabelContainer.offsetHeight - that.$.tabSelectionBar.offsetHeight; } top += 'px'; } else { top = null; } height = null; if (that.rightToLeft && that.tabTextOrientation === 'horizontal') { if (LW.Utilities.Core.Browser.Chrome) { const tabStrip = that.$.tabStrip; left = -(tabStrip.scrollLeft - (tabStrip.scrollWidth - tabStrip.offsetWidth)) + selectedTabLabelContainer.offsetLeft + 'px'; } else { left = -that.$.tabStrip.scrollLeft + (selectedTabLabelContainer.offsetLeft) + 'px'; } } else { left = -that.$.tabStrip.scrollLeft + (selectedTabLabelContainer.offsetLeft) + 'px'; } width = selectedTabLabelContainer.offsetWidth + 'px'; } else if (tabPosition === 'left' || tabPosition === 'right') { if (that.tabLayout === 'wrap') { left = selectedTabLabelContainer.offsetLeft; if (tabPosition === 'left') { left += selectedTabLabelContainer.offsetWidth - that.$.tabSelectionBar.offsetWidth; } left += 'px'; } else { left = null; } width = null; top = -that.$.tabStrip.scrollTop + selectedTabLabelContainer.offsetTop + 'px'; height = selectedTabLabelContainer.offsetHeight + 'px'; } function updateStyle() { that.$.tabSelectionBar.style.top = top; that.$.tabSelectionBar.style.height = height; that.$.tabSelectionBar.style.left = left; that.$.tabSelectionBar.style.width = width; } if (LW.Utilities.Core.isMobile && that.hasAnimation && !noAnimation) { requestAnimationFrame(function () { requestAnimationFrame(updateStyle); }); } else { updateStyle(); } if (noAnimation && !that._tabPositionChanging) { requestAnimationFrame(() => that.$.tabSelectionBar.style.transition = null); } } /** * Positions a group dropdown. */ _positionGroupDropDown(groupLabel) { const that = this, position = that.tabPosition, dropDown = groupLabel.dropDown, headerSectionStyle = window.getComputedStyle(that.$.tabsHeaderSection), headerSectionPaddingLeft = parseFloat(headerSectionStyle[that.rightToLeft ? 'paddingRight' : 'paddingLeft']), headerSectionPaddingTop = parseFloat(headerSectionStyle.paddingTop); if (position === 'top' || position === 'bottom') { const material = false; //that.hasAnimation; if (that.rightToLeft) { dropDown.style.left = groupLabel.offsetLeft - that._getScrollLeft() - headerSectionPaddingLeft - dropDown.offsetWidth + groupLabel.offsetWidth + 'px'; } else { dropDown.style.left = groupLabel.offsetLeft - that.$.tabStrip.scrollLeft + headerSectionPaddingLeft + 'px'; } if (position === 'top') { if (!material) { dropDown.style.top = groupLabel.offsetTop + groupLabel.offsetHeight + headerSectionPaddingTop + 'px'; } } else { let top = groupLabel.getBoundingClientRect().top - that.$.container.getBoundingClientRect().top + headerSectionPaddingTop; if (material) { top += that.$.tabStrip.offsetHeight; } dropDown.style.top = top + 'px'; } } else { dropDown.style.top = groupLabel.offsetTop - that.$.tabStrip.scrollTop + headerSectionPaddingTop + 'px'; if (position === 'left') { dropDown.style.left = groupLabel.offsetLeft + groupLabel.offsetWidth + headerSectionPaddingLeft + 'px'; } else { dropDown.style.left = (groupLabel.getBoundingClientRect().left - that.$.container.getBoundingClientRect().left + headerSectionPaddingLeft) + 'px'; } } } /** * Processes "dataSource" object. */ _processDataSource() { const that = this, dataSource = that.dataSource; function processItem(item, parent) { let element; if (Array.isArray(item.items) && item.items.length > 0) { element = document.createElement('lw-tab-items-group'); for (let i = 0; i < item.items.length; i++) { if (item.items[i].items) { continue; } processItem(item.items[i], element); } } else { element = document.createElement('lw-tab-item'); if (item.closeButtonHidden === true) { element.closeButtonHidden = true; } if (item.content !== undefined) { element.innerHTML = item.content; } if (item.index !== undefined) { element.index = item.index; } if (item.selected === true) { element.selected = item.selected; } } if (item.label !== undefined) { element.label = item.label; } if (item.labelSize !== undefined) { element.labelSize = item.labelSize; } parent.appendChild(element); } that.$.tabContentSection.innerHTML = ''; if (dataSource === null) { return; } for (let i = 0; i < dataSource.length; i++) { const currentItem = dataSource[i]; processItem(currentItem, that.$.tabContentSection); } } /** * Processes HTML structure. */ _processHTML() { const that = this; that._getTabs(); that._orderTabs(); that._validateInitialSelection(); that._populateTabStrip(); if (that.addNewTab) { that._insertAddNewTab(); } that._getReorderItems(); that._applyTabOverflow(); that.ensureVisible(that.selectedIndex); that.$.hiddenInput.value = that.selectedIndex; } /** * Removes set inline style. */ _removeInlineStyle() { const that = this, tabStrip = that.$.tabStrip; if (that._inlineStyleTabStripChildren) { const tabStripChildren = tabStrip.children; for (let i = 0; i < tabStripChildren.length; i++) { tabStripChildren[i].removeAttribute('style'); tabStripChildren[i].firstElementChild.firstElementChild.classList.remove('lw-tab-label-text-container-full-height'); } delete that._inlineStyleTabStripChildren; } if (that._inlineStyleTabStrip) { tabStrip.removeAttribute('style'); delete that._inlineStyleTabStrip; } tabStrip.$.removeClass('shrink-tabs'); tabStrip.$.removeClass('shrink-tabs-vertical'); } /** * Positions a tab before or after another tab. */ _reorderTabs(firstTabIndex, secondTabIndex) { function reorderList(list, x, y) { const temp = list[x]; list.splice(x, 1); list.splice(y, 0, temp); } const that = this, oldScrollValue = that.$.tabStrip[that._orientationSettings.scrollDirection]; if (that._groups.length === 0) { const tabs = that._tabs, tabLabelContainers = that._tabLabelContainers, referenceNodeIndex = firstTabIndex > secondTabIndex ? secondTabIndex : secondTabIndex + 1; if (that.selectedIndex === firstTabIndex) { that.selectedIndex = secondTabIndex; } else if (that.selectedIndex <= secondTabIndex && that.selectedIndex > firstTabIndex) { that.selectedIndex--; } else if (that.selectedIndex >= secondTabIndex && that.selectedIndex < firstTabIndex) { that.selectedIndex++; } let tabStripInsertBefore; if (tabLabelContainers[referenceNodeIndex]) { tabStripInsertBefore = tabLabelContainers[referenceNodeIndex]; } else if (that.addNewTab) { tabStripInsertBefore = that._addNewTab; } else { tabStripInsertBefore = null; } that.$.tabStrip.insertBefore(tabLabelContainers[firstTabIndex], tabStripInsertBefore); that.$.dropDownButtonDropDown.insertBefore(that.$.dropDownButtonDropDown.children[firstTabIndex], that.$.dropDownButtonDropDown.children[referenceNodeIndex] || null); that.$.tabContentSection.insertBefore(tabs[firstTabIndex], tabs[referenceNodeIndex] || null); reorderList(tabs, firstTabIndex, secondTabIndex); reorderList(tabLabelContainers, firstTabIndex, secondTabIndex); that._updateTabIndexes(); } else { that._reorderTabsGrouping(firstTabIndex, secondTabIndex); } that.$.tabStrip[that._orientationSettings.scrollDirection] = oldScrollValue; that.$.fireEvent('reorder', { 'newIndex': secondTabIndex, 'originalIndex': firstTabIndex }); that._reorderedIndex = secondTabIndex; that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], true); that.$.hiddenInput.value = that.selectedIndex; } /** * Positions a tab before or after another tab when there are groups. */ _reorderTabsGrouping(firstTabIndex, secondTabIndex) { const that = this, tabStripChildren = that.$.tabStrip.children, tabContentSectionChildren = that.$.tabContentSection.children, referenceNodeIndex = firstTabIndex > secondTabIndex ? secondTabIndex : secondTabIndex + 1, selectedTab = that._tabs[that.selectedIndex]; that.$.tabStrip.insertBefore(tabStripChildren[firstTabIndex], tabStripChildren[referenceNodeIndex] || null); that.$.tabContentSection.insertBefore(tabContentSectionChildren[firstTabIndex], tabContentSectionChildren[referenceNodeIndex] || null); that._groupLabels = Array.from(that.$.tabStrip.getElementsByClassName('lw-tab-group-container')); that._groups = []; for (let i = 0; i < that._groupLabels.length; i++) { that._groups.push(that._groupLabels[i].group); } that._tabs = Array.from(that.$.tabContentSection.getElementsByTagName('lw-tab-item')); const dropDownContentFragment = document.createDocumentFragment(); let tabLabelContainers = []; for (let i = 0; i < that._tabs.length; i++) { dropDownContentFragment.appendChild(that.$.dropDownButtonDropDown.children[that._tabs[i].index].cloneNode(true)); } that.$.dropDownButtonDropDown.innerHTML = ''; that.$.dropDownButtonDropDown.appendChild(dropDownContentFragment); for (let i = 0; i < that.$.tabStrip.childElementCount; i++) { const currentChild = that.$.tabStrip.children[i]; if (currentChild.$.hasClass('lw-tab-label-container') && currentChild !== that._addNewTab) { tabLabelContainers.push(currentChild); } else if (currentChild.$.hasClass('lw-tab-group-container')) { tabLabelContainers = tabLabelContainers.concat(Array.from(currentChild.dropDown.children)); } } that._tabLabelContainers = tabLabelContainers; that._updateTabIndexes(); if (selectedTab) { that.selectedIndex = selectedTab.index; } } /** * Resizes a tab strip element. */ _resize(event) { const that = this; if (!that._resizing) { return; } const orientationSettings = that._orientationSettings, sizeChange = event[orientationSettings.coordinate] - that._resizeFrom, customElement = that._getCorrespondingCustomElement(that._tabToResize); let oldSize; if (customElement.labelSize === null) { oldSize = that._tabToResize[orientationSettings.size]; } else { oldSize = customElement.labelSize; } const newSize = Math.max(10, oldSize + sizeChange); if (newSize !== oldSize) { customElement._preventPropertyChangedHandler = true; customElement.labelSize = newSize; that._tabToResize.style[orientationSettings.dimension] = parseInt(newSize, 10) + 'px'; } that.$resizeToken.addClass('lw-hidden'); that._applyTabOverflow(); that._resizing = false; that.removeAttribute('resizing'); } /** * Triggers ripple effect. */ _ripple(event, target) { const that = this; if (that.hasRippleAnimation) { const rippleAgent = document.createElement('div'); rippleAgent.className = 'ripple-agent'; target.firstElementChild.appendChild(rippleAgent); setTimeout(function () { target.firstElementChild.removeChild(rippleAgent); }, 1000); LW.Utilities.Animation.Ripple.animate(rippleAgent, event.pageX, event.pageY); return true; } } /** * Scroll button click handler. */ _scrollButtonClickHandler(event) { const that = this, tabStrip = that.$.tabStrip; let modifier = event.target.closest('lw-repeat-button') === that.$.scrollButtonNear ? -1 : 1; if (that.scrollMode === 'paging') { const orientationSettings = that._orientationSettings, swipeInfo = {}; that._dragStartDetails = { startX: 0, startY: 0, pageX: 0, pageY: 0, startTime: Date.now(), target: event.target }; that._wheelInProgress = true; swipeInfo[orientationSettings.coordinate] = -modifier * (tabStrip[orientationSettings.size] / 1.1428571428571428); that._endSwiping(swipeInfo, that._dragStartDetails.startTime + 175); return; } if (that.hasAttribute('horizontal')) { tabStrip.scrollLeft += 10 * modifier; } else { tabStrip.scrollTop += 10 * modifier; } that._updateScrollButtonVisibility(true); } /** * Returns the scrollLeft of the TabStrip */ _getScrollLeft(scrollLeft) { const that = this, tabStrip = that.$.tabStrip; //Note: Chrome has a bug with direction: rtl. Doesn't inverse the scrollLeft //see: https://bugs.chromium.org/p/chromium/issues/detail?id=721759 if (scrollLeft === undefined) { if (that.rightToLeft && LW.Utilities.Core.Browser.Chrome) { return tabStrip.scrollLeft - (tabStrip.scrollWidth - tabStrip.offsetWidth); } else { return tabStrip.scrollLeft; } } if (!that.rightToLeft || (that.tabPosition !== 'top' && that.tabPosition !== 'bottom')) { return scrollLeft; } if (LW.Utilities.Core.Browser.Chrome) { scrollLeft = (tabStrip.scrollWidth - tabStrip.offsetWidth) - scrollLeft; } else { scrollLeft *= -1; } return scrollLeft; } /** * Selects a tab. */ _select(index, fireEvent, oldIndex) { const that = this, hasAnimation = that.hasAnimation; if (oldIndex === undefined) { oldIndex = that.selectedIndex; } if (index === oldIndex && ((!that.allowToggle) || (that.allowToggle && that.selectionMode === 'mouseenter'))) { that.$.hiddenInput.value = that.selectedIndex; return; } const tab = that._tabs[index]; if (that._focusedItem) { that._focusedItem.tabLabelContainer.removeAttribute('focus'); } if (oldIndex !== null) { const oldTab = that._tabs[oldIndex]; if (hasAnimation) { that._animateSelection(tab, oldTab, index > oldIndex); } else { oldTab.$.addClass('lw-visibility-hidden'); } oldTab.selected = false; that._tabLabelContainers[oldIndex].$.removeClass('lw-tab-selected'); that._tabLabelContainers[oldIndex].removeAttribute('selected'); if (that.closeButtons && that.closeButtonMode === 'selected') { that._disableCloseButton(oldIndex); } } if (index !== null) { that._tabLabelContainers[index].removeAttribute('hover'); if (that.closeButtons && that.closeButtonMode === 'selected') { that._enableCloseButton(index); } } if (!that.allowToggle || (index !== null && (arguments[2] !== undefined ? oldIndex : that.selectedIndex) !== index)) { tab.selected = true; that.$.tabContentSection.removeAttribute('show-placeholder'); if (oldIndex === null || !hasAnimation) { tab.$.removeClass('lw-visibility-hidden'); } that.selectedIndex = index; that._focusedItem = that._tabs[index]; that._focusedItem.tabLabelContainer.$.addClass('lw-tab-selected'); that._focusedItem.tabLabelContainer.setAttribute('selected', ''); that._positionTabSelectionBar(that._focusedItem.tabLabelContainer, oldIndex === null); } else { that.selectedIndex = null; that.$.tabContentSection.setAttribute('show-placeholder', ''); if (that.allowToggle) { that._focusedItem = that._tabs[index === null ? oldIndex : index]; if (that._focusedItem) { that._focusedItem.tabLabelContainer.setAttribute('focus', ''); } } } if (fireEvent) { //Upate hidden input that.$.hiddenInput.value = that.selectedIndex; that.$.fireEvent('change', { 'index': that.selectedIndex, 'oldIndex': oldIndex }); } that._closeGroupDropDown(); if (tab && tab.group !== null) { if (that._selectedGroup) { that._selectedGroup.$.removeClass('lw-tab-group-selected'); } if (that.selectedIndex !== null) { that._selectedGroup = that._groupLabels[that._groups.indexOf(tab.group)]; that._selectedGroup.$.addClass('lw-tab-group-selected'); } } else if (that._selectedGroup) { that._selectedGroup.$.removeClass('lw-tab-group-selected'); delete that._selectedGroup; } that.$.hiddenInput.value = that.selectedIndex; } /** * Document select start handler. */ _selectStartHandler(event) { const that = this; if (that._reordering || that._resizing) { event.preventDefault(); } } /** * Sets the label of a tab. */ _setLabel(label, labelTextContainer, dropDownLabelContainer) { const potentialHTMLTemplate = label ? document.getElementById(label) : null; if (potentialHTMLTemplate !== null && potentialHTMLTemplate.tagName.toLowerCase() === 'template') { // label is the id of an HTML template const templateContent = document.importNode(potentialHTMLTemplate.content, true); labelTextContainer.appendChild(templateContent); if (dropDownLabelContainer) { const templateContent = document.importNode(potentialHTMLTemplate.content, true); dropDownLabelContainer.appendChild(templateContent); } } else { // label is string if (label === '') { label = '&nbsp;'; } labelTextContainer.innerHTML = label; if (dropDownLabelContainer) { dropDownLabelContainer.innerHTML = label; } } } /** * Shows the close button of a tab. */ _showCloseButton(tabLabelContainer) { if (tabLabelContainer.closeButtonEnabled) { tabLabelContainer.firstElementChild.children[0].$.addClass('lw-close-button-enabled'); tabLabelContainer.firstElementChild.children[1].$.removeClass('lw-hidden'); } } /** * tabContentSection transitionend handler. */ _tabContentSectionTransitionendHandler(event) { const that = this, target = event.target; if (!(target instanceof LW.TabItem)) { return; } if (target === that._animatedOldTab) { target.$.addClass('lw-hidden'); target.$.removeClass('animate'); target.$.removeClass(that._animatedOldTab.classToRemove); target.$.removeClass('lw-hidden'); delete that._animatedOldTab; } else if (target === that._animatedTab) { target.$.removeClass('animate'); delete that._animatedTab; } target.classList.remove('left'); target.classList.remove('right'); target.classList.remove('top'); target.classList.remove('bottom'); } /** * tabsHeaderItems wheel handler. */ _tabsHeaderItemsWheelHandler(event) { const that = this; if (!that.enableMouseWheelAction || that.disabled) { return; } const tabStrip = that.$.tabStrip, orientationSettings = that._orientationSettings, size = tabStrip[orientationSettings.size], scrollSize = tabStrip[orientationSettings.scrollSize], scrollDirection = tabStrip[orientationSettings.scrollDirection], delta = event.deltaY; if (size === scrollSize || scrollDirection === 0 && delta < 0 || scrollDirection + size === scrollSize && delta > 0) { return; } event.preventDefault(); if (that._wheelInProgress) { return; } that._dragStartDetails = { startX: event.pageX, startY: event.pageY, pageX: event.pageX, pageY: event.pageY, startTime: Date.now(), target: event.target }; that._wheelInProgress = true; const swipeInfo = {}; swipeInfo[orientationSettings.coordinate] = event[orientationSettings.coordinate] + (event.deltaY > 0 ? -1 : 1) * orientationSettings.wheelOffset; that._endSwiping(swipeInfo, that._dragStartDetails.startTime + 100); } /** * Tab strip event handler. */ _tabStripHandler(target, event) { const that = this, eventType = event.type; if (eventType === 'down' && that._tabToResize !== undefined) { that._resizing = true; that._tabsHeaderSectionCoordinate = that.$.tabsHeaderSection.getBoundingClientRect()[that._orientationSettings.edge]; return; } if (eventType === 'down' && LW.Utilities.Core.isMobile) { that._dragStartDetails = { startX: event.pageX, startY: event.pageY, pageX: event.pageX, pageY: event.pageY, startTime: Date.now(), originalTime: Date.now(), target: event.originalEvent.target }; } const scrollButton = target.closest('lw-repeat-button'); if (eventType === 'up' && scrollButton) { that.focus(); if (that.resize) { that._getTabCoordinates(); } return; } if (target.classList.contains('lw-tab-close-button')) { // close button if (eventType === 'up') { if (target === that._downTarget) { const indexToClose = target.parentElement.parentElement.tab.index, closingEvent = that.$.fireEvent('closing', { 'index': indexToClose }); if (!closingEvent.defaultPrevented) { that.removeAt(indexToClose); that.$.fireEvent('close', { 'index': indexToClose }); } return; } } else if (eventType === 'down') { that._downTarget = target; return; } else if (!that._reordering && !that._swiping) { if (eventType === 'mouseover') { target.setAttribute('hover', ''); } else if (eventType === 'mouseout') { target.removeAttribute('hover'); } } } const closestLabelContainer = target.closest('.lw-tab-label-container'); if (closestLabelContainer !== null) { if (event.originalEvent && event.originalEvent.type === 'pointercancel') { if (closestLabelContainer.tab.group) { delete closestLabelContainer.parentElement.rippleInProgress; } } else { that._labelContainerHandler(closestLabelContainer, event, eventType); } return; } const closestGroupContainer = target.closest('.lw-tab-group-container'); if (closestGroupContainer !== null) { that._groupContainerHandler(closestGroupContainer, eventType); } } /** * Tab strip mouseleave handler. */ _tabStripMouseleaveHandler() { const that = this; if (that.resize && !that._resizing && that.hasAttribute('resizing')) { that.removeAttribute('resizing'); } } /** * Tab strip (mouse)move handler. */ _tabStripMoveHandler(event) { const that = this; if (that._dragStartDetails && !that._dragStartDetails.checked) { if (Date.now() - that._dragStartDetails.originalTime < 500) { that._endReordering(undefined, undefined); that._dragStartDetails.checked = true; } else { delete that._dragStartDetails; } } if (that._dragStartDetails && (Math.abs(that._dragStartDetails.pageX - event.pageX) >= 5 || Math.abs(that._dragStartDetails.pageY - event.pageY) >= 5)) { const orientationSettings = that._orientationSettings, difference = that._dragStartDetails[orientationSettings.coordinate] - event[orientationSettings.coordinate], oldScrollDirection = that.$.tabStrip[orientationSettings.scrollDirection]; that.$.tabStrip[orientationSettings.scrollDirection] += difference; if (oldScrollDirection !== that.$.tabStrip[orientationSettings.scrollDirection]) { that._updateScrollButtonVisibility(); } that._dragStartDetails = { startX: that._dragStartDetails.startX, startY: that._dragStartDetails.startY, pageX: event.pageX, pageY: event.pageY, startTime: that._dragStartDetails.startTime, originalTime: that._dragStartDetails.originalTime, target: event.originalEvent.target, checked: that._dragStartDetails.checked }; that._swiping = true; return; } if (!that.resize || that._resizing || that._reordering || that.tabLayout === 'shrink') { return; } const orientationSettings = that._orientationSettings, currentCoordinate = event[orientationSettings.coordinate], tabCoordinates = that._tabCoordinates; let tabToResize; for (let i = 0; i < tabCoordinates.length; i++) { const currentTabCoordinate = tabCoordinates[i][orientationSettings.to]; if (currentCoordinate >= currentTabCoordinate - 4 && currentCoordinate <= currentTabCoordinate + 4) { tabToResize = that._reorderItems[i]; that._resizeFrom = currentCoordinate; break; } } if (tabToResize !== undefined) { that._tabToResize = tabToResize; that.setAttribute('resizing', ''); } else { that._tabToResize = undefined; that.removeAttribute('resizing'); } } /** * tabStrip touchmove handler. */ _tabStripTouchmoveHandler(event) { const that = this; if (that._touchmoveInside && event.cancelable) { event.preventDefault(); event.stopPropagation(); return; } const tabStrip = that.$.tabStrip, orientationSettings = that._orientationSettings, size = tabStrip[orientationSettings.size], scrollSize = tabStrip[orientationSettings.scrollSize], coords = that._touchCoords; if (size === scrollSize || !coords) { return; } const touches = event.touches[0], scrollDirection = tabStrip[orientationSettings.scrollDirection], coord = touches[orientationSettings.coordinate], normalizedCoord = parseFloat(coord.toFixed(5)), previousCoord = coords[orientationSettings.coordinate === 'pageY' ? 1 : 0], normalizedPreviousCoord = parseFloat(previousCoord.toFixed(5)); that._touchCoords = [touches.pageX, touches.pageY]; if (scrollDirection === 0 && normalizedCoord >= normalizedPreviousCoord || // pan up scrollDirection + size === scrollSize && normalizedCoord <= normalizedPreviousCoord) { // pan down return; } if (coord !== previousCoord) { that._touchmoveInside = true; } if (event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * tabStrip touchmove handler. */ _tabStripTouchstartHandler(event) { const touches = event.touches[0]; this._touchCoords = [touches.pageX, touches.pageY]; } /** * Toggles the collapsed state on click. */ _toggleCollapsedState() { const that = this; if (!that.collapsible) { return; } if (!that.collapsed) { that.collapse(); } else { that.expand(); } } /** * Toggles the visibility of navigation elements. */ _toggleNavigationElementsVisibility() { const that = this, numberOfTabs = that._tabs.length; let action; if (numberOfTabs === 0) { action = 'addClass'; } else if (numberOfTabs === 1) { action = 'removeClass'; } else { return; } if (that.tabLayout === 'scroll' && that.overflow === 'scroll') { that.$scrollButtonNear[action]('lw-hidden'); that.$scrollButtonFar[action]('lw-hidden'); } else if (that.tabLayout === 'dropDown') { that.$dropDownButton[action]('lw-hidden'); } } /** * Updates the selected index and the index of each tab. */ _updateIndexes(index) { const that = this; if (that.selectedIndex !== null && index <= that.selectedIndex) { that.selectedIndex++; } that._updateTabIndexes(); } /** * Updates scroll button visibility. */ _updateScrollButtonVisibility(noTabSelectionBarAnimation) { const that = this; if (that.tabLayout !== 'scroll' || that.overflow === 'hidden') { that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], noTabSelectionBarAnimation); return; } const tabsHeaderSection = that.$tabsHeaderSection, tabStrip = that.$.tabStrip, orientationSettings = that._orientationSettings; let showNear = true, showFar = true; if (that.rightToLeft && orientationSettings.scrollDirection === 'scrollLeft') { const scrollLeft = Math.abs(that._getScrollLeft()); if (Math.round(scrollLeft) === 0) { showFar = false; } if (Math.round(tabStrip[orientationSettings.size] + scrollLeft) >= Math.round(tabStrip[orientationSettings.scrollSize]) - 1) { showNear = false; } } else { if (Math.round(tabStrip[orientationSettings.scrollDirection]) === 0) { showNear = false; } if (Math.round(tabStrip[orientationSettings.size] + tabStrip[orientationSettings.scrollDirection]) >= Math.round(tabStrip[orientationSettings.scrollSize]) - 1) { showFar = false; } } if (that.overflow === 'auto') { if (showNear && showFar) { that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); tabsHeaderSection.removeClass('one-button-shown'); if (that._tabLabelContainers[that.selectedIndex]) { that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], noTabSelectionBarAnimation); } return; } if (showNear) { that.$scrollButtonNear.removeClass('lw-hidden'); } else { that.$scrollButtonNear.addClass('lw-hidden'); } if (showFar) { that.$scrollButtonFar.removeClass('lw-hidden'); } else { that.$scrollButtonFar.addClass('lw-hidden'); } tabsHeaderSection.addClass('one-button-shown'); that._getTabCoordinates(); } else if (that.overflow === 'scroll' && !that.disabled) { that.$.scrollButtonNear.disabled = !showNear; that.$.scrollButtonFar.disabled = !showFar; } if (that._tabLabelContainers[that.selectedIndex]) { that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], noTabSelectionBarAnimation); } } /** * Updates the indexes of all tabs. */ _updateTabIndexes() { const that = this; if (that._tabs.length > 0) { for (let i = 0; i < that._tabs.length; i++) { that._tabs[i]._setIndex(i); } } else { that.selectedIndex = null; } that.$.hiddenInput.value = that.selectedIndex; } /** * Validates the index passed to the methods "ensureVisible", "getOffsetFromEdgeOfElement", "insert", "remove", "select" and "update". */ _validateIndex(index, method) { if (isNaN(parseInt(index, 10)) || typeof index === 'object') { const that = this; that.error(that.localize('invalidIndex', { method: method })); } } /** * Validates the initial selection. */ _validateInitialSelection() { const that = this; let selectedIndex = that.selectedIndex; for (let i = 0; i < that._tabs.length; i++) { const currentTab = that._tabs[i]; if (selectedIndex === i) { currentTab.selected = true; currentTab.$.removeClass('lw-visibility-hidden'); } else if (currentTab.selected) { if (selectedIndex === null) { selectedIndex = i; currentTab.$.removeClass('lw-visibility-hidden'); } else { currentTab.selected = false; currentTab.$.addClass('lw-visibility-hidden'); } } else { currentTab.$.addClass('lw-visibility-hidden'); } } if (that._tabs.length > 0 && selectedIndex === null && !that.allowToggle) { selectedIndex = 0; that._tabs[0].selected = true; that._tabs[0].$.removeClass('lw-visibility-hidden'); } that.selectedIndex = selectedIndex; if (that.selectedIndex !== null) { that._focusedItem = that._tabs[that.selectedIndex]; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * TimePicker custom element. */ LW('lw-time-picker', class TimePicker extends LW.BaseElement { /** * TimePicker's properties. */ static get properties() { return { 'autoSwitchToMinutes': { value: false, type: 'boolean' }, 'footer': { value: false, type: 'boolean' }, 'footerTemplate': { value: null, type: 'any?' }, 'format': { value: '12-hour', allowedValues: ['12-hour', '24-hour'], type: 'string' }, 'minuteInterval': { value: 1, type: 'number' }, 'name': { value: '', type: 'string' }, 'selection': { value: 'hour', allowedValues: ['hour', 'minute'], type: 'string' }, 'value': { value: new Date(), type: 'any', reflectToAttribute: false }, 'view': { value: 'portrait', allowedValues: ['landscape', 'portrait'], type: 'string' } }; } /** * TimePicker's event listeners. */ static get listeners() { return { 'keydown': '_keydownHandler', 'resize': '_resizeHandler', 'header.click': '_headerClickHandler', 'picker.down': '_pickerDownHandler', 'picker.move': '_pickerMoveHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler' }; } /** * TimePicker's required files. */ static get requires() { return { 'LW.Utilities.NumericProcessor': 'lw.numeric.js', 'LW.Utilities.BigNumber': 'lw.math.js', 'LW.Utilities.Draw': 'lw.draw.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.timepicker.css' ] } /** * TimePicker's HTML template. */ template() { const template = `<div id="container" role="presentation"> <div id="header" class="lw-header lw-unselectable" role="heading" aria-level="1"> <div id="hourMinuteContainer" class="lw-hour-minute-container"> <div id="hourContainer" class="lw-hour-container" role="button"></div> <div role="presentation">:</div> <div id="minuteContainer" class="lw-minute-container" role="button"></div> </div> <div id="ampmContainer" class="lw-am-pm-container" role="presentation"> <div id="amContainer" class="lw-am-container" role="button">AM</div> <div id="pmContainer" class="lw-pm-container" role="button">PM</div> </div> </div> <div id="main" class="lw-main-container"> <div id="svgContainer" class="lw-svg-container"> <div id="picker" class="lw-svg-picker" role="slider"></div> </div> <div id="footer" class="lw-footer"></div> </div> <input id="hiddenInput" type="hidden" name="[[name]]"> </div>`; return template; } /** * Called when the element is ready. Used for one-time configuration of the TimePicker. */ ready() { super.ready(); } render() { const that = this; that._createElement(); super.render(); } /** * Sets the hours. * * @param {Number} hours The hours to set. */ setHours(hours) { const that = this; if (hours === 24) { hours = 0; } else { hours = Math.max(0, Math.min(hours, 23)); } if (hours < 12) { that._selectAmPm('am'); } else { that._selectAmPm('pm'); } if (that.format === '12-hour') { if (hours === 0) { hours = 12 } else if (hours > 12) { hours -= 12; } } that._updateHours(hours, arguments[1]); if (that.selection === 'hour') { that._inInnerCircle = that.format === '24-hour' && (hours === 0 || hours > 12); that._drawArrow(true, hours, arguments[2]); if (!that.hasAnimation) { that._inInnerCircle = false; } } } /** * Sets the minutes. * * @param {Number} minutes The minutes to set. */ setMinutes(minutes) { const that = this; if (minutes === 60) { minutes = 0; } else { minutes = Math.max(0, Math.min(minutes, 59)); } that._updateMinutes(minutes); if (that.selection === 'minute') { that._drawArrow(true, minutes, arguments[1]); } } /** * Invoked when the value of a public property has been changed by the user. */ propertyChangedHandler(key, oldValue, value) { super.propertyChangedHandler(key, oldValue, value); const that = this; switch (key) { case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'footer': case 'view': that._resizeHandler(); break; case 'footerTemplate': that._validateFooterTemplate(); break; case 'format': { let hours = that.value.getHours(); if (value === '12-hour') { that.$ampmContainer.removeClass('lw-hidden'); if (that.value.getHours() < 12) { that._selectAmPm('am'); } else { that._selectAmPm('pm'); } if (hours === 0) { hours = 12; } else if (hours > 12) { hours -= 12; } } else { that.$ampmContainer.addClass('lw-hidden'); } that.$.hourContainer.innerHTML = hours; if (that.selection === 'hour') { that.$.picker.setAttribute('aria-valuenow', hours); that._draw.clear(); that._renderSVG(); } break; } case 'minuteInterval': { const validValue = Math.max(1, Math.min(value, 60)); if (validValue !== value) { that.minuteInterval = validValue; } if (that.selection === 'minute') { that.interval = validValue; } break; } case 'selection': if (value === 'hour') { that._changeToHourSelection(); } else { that._changeToMinuteSelection(); } break; case 'value': { that._oldValue = oldValue; that._validateValue(); const equalHours = that.value.getHours() === oldValue.getHours(), equalMinutes = that.value.getMinutes() === oldValue.getMinutes(); if (!(equalHours && equalMinutes)) { if (equalMinutes) { that.setHours(that.value.getHours()); } else { if (!equalHours) { that.setHours(that.value.getHours(), true); } that.setMinutes(that.value.getMinutes()); } } delete that._oldValue; break; } } } /** * Applies initial settings to the TimePicker element. */ _applyInitialSettings() { const that = this, value = that.value; let hours, minutes; hours = value.getHours(); minutes = value.getMinutes(); if (that.format === '12-hour') { if (hours < 12) { that._ampm = 'am'; that.$amContainer.addClass('lw-selected'); if (hours === 0) { hours = 12; } } else { that._ampm = 'pm'; that.$pmContainer.addClass('lw-selected'); if (hours > 12) { hours -= 12; } } } else { that.$ampmContainer.addClass('lw-hidden'); } minutes = minutes.toString(); if (minutes.length === 1) { minutes = '0' + minutes; } that.$.hourContainer.innerHTML = hours; that.$.minuteContainer.innerHTML = minutes; if (that.selection === 'hour') { that.$hourContainer.addClass('lw-selected'); that.$.picker.setAttribute('aria-valuenow', hours); } else { that.$minuteContainer.addClass('lw-selected'); that.$.picker.setAttribute('aria-valuenow', minutes); } } /** * Changes the TimePicker selection when the user interacts with it. */ _changeSelection(event, noAnimation) { const that = this, x = event.pageX, y = event.pageY, center = that._getCenterCoordinates(), distanceFromCenter = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2)); that._measurements.center = center; if (event.type === 'down') { if (distanceFromCenter > that._measurements.radius) { event.stopPropagation(); return; } else { that._dragging = true; } } if (that.format === '24-hour' && that.selection === 'hour' && distanceFromCenter < that._measurements.radius - 50) { that._inInnerCircle = true; } else { that._inInnerCircle = false; } const angleRadians = Math.atan2(y - center.y, x - center.x); let angleDeg = -1 * angleRadians * 180 / Math.PI; if (angleDeg < 0) { angleDeg += 360; } that._angle = angleDeg; let newValue = that._numericProcessor.getValueByAngle(that._angle); if (that.selection === 'hour') { if (that.format === '24-hour') { if (that._inInnerCircle) { if (newValue !== 0 && newValue !== 12) { newValue += 12; } else { newValue = 0; } } else if (newValue === 0) { newValue = 12; } } else { if (newValue === 0) { newValue = 12; } } that._updateHours(newValue); } else { if (newValue === 60) { newValue = 0; } that._updateMinutes(newValue); } if (that._oldTimePart === undefined) { return; } cancelAnimationFrame(that._animationFrameId); delete that._animationFrameId; that._drawArrow(true, newValue, noAnimation); } /** * Changes to hour selection. */ _changeToHourSelection() { const that = this, svgCanvas = that._centralCircle.parentElement || that._centralCircle.parentNode; let hours = that.value.getHours(); cancelAnimationFrame(that._animationFrameId); delete that._animationFrameId; that.interval = 1; that.$hourContainer.addClass('lw-selected'); that.$minuteContainer.removeClass('lw-selected'); svgCanvas.removeChild(that._centralCircle); svgCanvas.removeChild(that._arrow); svgCanvas.removeChild(that._head); that._getMeasurements(); that._numericProcessor.getAngleRangeCoefficient(); that._draw.clear(); svgCanvas.appendChild(that._centralCircle); svgCanvas.appendChild(that._arrow); svgCanvas.appendChild(that._head); that._renderHours(); if (that.format === '24-hour' && (hours === 0 || hours > 12)) { that._inInnerCircle = true; } else if (that.format === '12-hour') { hours = hours % 12; if (hours === 0) { hours = 12; } } that._drawArrow(true, undefined, true); that._inInnerCircle = false; that.$.picker.firstElementChild.setAttribute('aria-hidden', true); that.$.picker.setAttribute('aria-valuenow', hours); } /** * Changes to minute selection. */ _changeToMinuteSelection() { const that = this, svgCanvas = that._centralCircle.parentElement || that._centralCircle.parentNode; that._inInnerCircle = false; cancelAnimationFrame(that._animationFrameId); delete that._animationFrameId; that.interval = that.minuteInterval; that.$hourContainer.removeClass('lw-selected'); that.$minuteContainer.addClass('lw-selected'); svgCanvas.removeChild(that._centralCircle); svgCanvas.removeChild(that._arrow); svgCanvas.removeChild(that._head); that._getMeasurements(); that._numericProcessor.getAngleRangeCoefficient(); that._draw.clear(); svgCanvas.appendChild(that._centralCircle); svgCanvas.appendChild(that._arrow); svgCanvas.appendChild(that._head); that._renderMinutes(); that._drawArrow(true, undefined, true); that.$.picker.firstElementChild.setAttribute('aria-hidden', true); that.$.picker.setAttribute('aria-valuenow', that.value.getMinutes()); } /** * Computes arrow body points. */ _computeArrowBodyPoints(radius, angle, width, length) { const that = this, sin = Math.sin(angle), cos = Math.cos(angle), endX1 = radius - width * cos + length * sin, endY1 = radius + width * sin + length * cos, endX2 = radius + width * cos + length * sin, endY2 = radius - width * sin + length * cos, startX1 = radius + width * cos, startY1 = radius - width * sin, startX2 = radius - width * cos, startY2 = radius + width * sin, points = 'M ' + startX1 + ',' + startY1 + ' L ' + startX2 + ',' + startY2 + ' L ' + endX1 + ',' + endY1 + ' ' + endX2 + ',' + endY2; that._headCenter = { x: (endX1 + endX2) / 2, y: (endY1 + endY2) / 2 }; return points; } /** * Applies initial settings to the TimePicker element. */ _createElement() { const that = this; that.setAttribute('role', 'dialog'); that.coerce = true; that.min = 0; that._drawMin = '0'; that.startAngle = -270; that.endAngle = 90; that._angleDifference = that.endAngle - that.startAngle; that.ticksVisibility = 'none'; that._tickIntervalHandler = {}; that._tickIntervalHandler.labelsSize = {}; that._distance = { majorTickDistance: 0, minorTickDistance: 0, labelDistance: 10 }; that._measurements = {}; that._validateInitialPropertyValues(); that._applyInitialSettings(); that._numericProcessor = new LW.Utilities.DecimalNumericProcessor(that); that._draw = new LW.Utilities.Draw(that.$.picker); if (!that._isVisible()) { that._renderingSuspended = true; return; } that._setPickerSize(); that._getMeasurements(); that._numericProcessor.getAngleRangeCoefficient(); that._renderSVG(); that._setFocusable(); that.$.hiddenInput.value = that.value; if (that.enableShadowDOM) { that.appendChild(that.$.hiddenInput); } } /** * Document move handler. */ _documentMoveHandler(event) { const that = this; if (that._dragging) { that._changeSelection(event, true); } } /** * Document up handler. */ _documentUpHandler() { const that = this; function animateToMinutes() { that.$picker.addClass('animate'); setTimeout(function () { that.selection = 'minute'; that._changeToMinuteSelection(); }, 250); setTimeout(function () { that.$picker.removeClass('animate'); }, 550); } function checkRunningAnimation() { if (that._animationFrameId) { requestAnimationFrame(checkRunningAnimation); } else { animateToMinutes(); } } if (that._dragging) { that._inInnerCircle = false; that._dragging = false; if (that.autoSwitchToMinutes && that.selection === 'hour') { if (that.hasAnimation) { checkRunningAnimation(); } else { that.selection = 'minute'; that._changeToMinuteSelection(); } } } else if (that.hasAttribute('focus')) { that.$.fireEvent('blur'); that.removeAttribute('focus'); } } /** * Draws/updates the arrow. */ _drawArrow(update, value, noAnimation) { const that = this, hourSelection = that.selection === 'hour', twelveHourFormat = that.format === '12-hour'; let current = that._oldTimePart; delete that._oldTimePart; if (value === undefined) { if (hourSelection) { value = that.value.getHours(); if (twelveHourFormat && value > 12) { value -= 12; } } else { value = that.value.getMinutes(); } } if (current === undefined || noAnimation || !that.hasAnimation) { that._drawArrowSVG(update, value); return; } if (hourSelection && !twelveHourFormat) { that._animate24HourView(current, value); return; } let step, max; if (hourSelection) { step = 0.2; max = 12; value = value % max; current = current % max; } else { step = 1; max = 60; } let distanceCW = value - current, distanceCCW = current - value; if (distanceCW < 0) { distanceCW += max; } if (distanceCCW < 0) { distanceCCW += max; } if (distanceCCW < distanceCW) { step *= -1; } function animate() { current += step; current = parseFloat((current % max).toFixed(1)); if (current < 0) { current += max; } that._drawArrowSVG(update, current); update = true; if (current !== value % max) { that._animationFrameId = requestAnimationFrame(animate); } else { delete that._animationFrameId; } } animate(); } /** * Animates selection in 24-hour view. */ _animate24HourView(current, value) { const that = this; let step = 0.2; that._inInnerCircle = false; const currentInnerCircle = current === 0 || current > 12, valueInnerCircle = value === 0 || value > 12; if (currentInnerCircle !== valueInnerCircle) { if (currentInnerCircle) { current = Math.abs(current - 12); } else { current = (current + 12) % 24; } that._inInnerCircle = valueInnerCircle; that._drawArrowSVG(true, current); if (current === value) { return; } } else { that._inInnerCircle = valueInnerCircle; } let start = current, end = value; if (that._inInnerCircle) { if (end === 0 && start < 18) { end = 12; } else if (start === 0 && end < 18) { start = 12; } } let distanceCW = end - start, distanceCCW = start - end; if (distanceCW < 0) { distanceCW += 12; } if (distanceCCW < 0) { distanceCCW += 12; } if (distanceCCW < distanceCW) { step *= -1; } function animate(inInnerCircle) { that._inInnerCircle = inInnerCircle; if (inInnerCircle) { current = parseFloat((current + step).toFixed(1)); if (current < 0) { current += 24; } else if (current < 1) { current = current + 12; } if (current === 12 || current === 24) { current = 0; } } else { current += step; if (current !== 12) { current = parseFloat((current % 12).toFixed(1)); } if (current <= 0) { current += 12; } } that._drawArrowSVG(true, current); if (current !== value) { that._animationFrameId = requestAnimationFrame(function () { animate(inInnerCircle); }); } else { delete that._animationFrameId; that._inInnerCircle = false; } } animate(that._inInnerCircle); } /** * Draws/updates the arrow. */ _drawArrowSVG(update, value) { const that = this, measurements = that._measurements, angle = that._numericProcessor.getAngleByValue(value); let arrowBodyPoints; if (!that._inInnerCircle) { arrowBodyPoints = that._computeArrowBodyPoints(measurements.radius, angle, 1, measurements.innerRadius - that._largestLabelSize / 2); } else { arrowBodyPoints = that._computeArrowBodyPoints(measurements.radius, angle, 1, measurements.innerRadius - that._largestLabelSize / 2 - 45); } if (update) { that._arrow.setAttribute('d', arrowBodyPoints); that._head.setAttribute('cx', that._headCenter.x); that._head.setAttribute('cy', that._headCenter.y); that._head.setAttribute('r', that._largestLabelSize); that._headRect = that._head.getBoundingClientRect(); if (value % 1 === 0) { that._highlightLabel(value); } } else { that._arrow = that._draw.path(arrowBodyPoints, { 'class': 'lw-needle' }); that._head = that._draw.circle(that._headCenter.x, that._headCenter.y, that._largestLabelSize, { 'class': 'lw-needle-central-circle' }); that._headRect = that._head.getBoundingClientRect(); } } /** * Draws a label. */ _drawLabel(angle, value, distance) { const that = this, measurements = that._measurements, r = measurements.radius, stylingObj = { 'class': 'lw-label lw-unselectable', 'font-size': measurements.fontSize, 'font-family': measurements.fontFamily, 'font-weight': measurements.fontWeight, 'font-style': measurements.fontStyle }; if (that.selection === 'hour') { if (that._plotInnerCircle) { if (value > 0) { value += 12; } else { value = '00'; } } else { if (value === 0) { value = 12; } } } else { if (value.toString().length === 1) { value = '0' + value; } } const textSize = that._draw.measureText(value, 0, stylingObj), w = r - distance - that._largestLabelSize / 2, x = r + w * Math.sin(angle), y = r + w * Math.cos(angle), label = that._draw.text(value, Math.round(x) - textSize.width / 2, Math.round(y) - textSize.height / 2, textSize.width, textSize.height, 0, stylingObj); label.setAttribute('value', parseFloat(value)); } /** * Gets the center coordinates. */ _getCenterCoordinates() { const that = this, offset = that.$.picker.getBoundingClientRect(), radius = that._measurements.radius, scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft, scrollTop = document.body.scrollTop || document.documentElement.scrollTop; return { x: offset.left + scrollLeft + radius, y: offset.top + scrollTop + radius }; } /** * Measures some elements of the TimePicker and stores the results. */ _getMeasurements() { const that = this, measurements = that._measurements, measureLabel = document.createElement('div'); let minLabel, maxLabel, minLabelWidth, maxLabelWidth, minLabelHeight, maxLabelHeight; measureLabel.className = 'lw-label'; measureLabel.style.position = 'absolute'; measureLabel.style.visibility = 'hidden'; that.$.svgContainer.appendChild(measureLabel); if (that.selection === 'hour') { minLabel = '1'; maxLabel = '23'; that.max = 12; that._drawMax = '12'; that._range = 12; } else { minLabel = '00'; maxLabel = '55'; that.max = 60; that._drawMax = '60'; that._range = 60; } measureLabel.innerHTML = minLabel; minLabelWidth = measureLabel.offsetWidth; minLabelHeight = measureLabel.offsetHeight; measureLabel.innerHTML = maxLabel; maxLabelWidth = measureLabel.offsetWidth; maxLabelHeight = measureLabel.offsetHeight; that._largestLabelSize = Math.max(minLabelWidth, minLabelHeight, maxLabelWidth, maxLabelHeight); that._tickIntervalHandler.labelsSize.minLabelSize = minLabelHeight; that._tickIntervalHandler.labelsSize.maxLabelSize = maxLabelHeight; const measureElementStyle = window.getComputedStyle(measureLabel); measurements.fontSize = measureElementStyle.fontSize; measurements.fontFamily = measureElementStyle.fontFamily; measurements.fontWeight = measureElementStyle.fontWeight; measurements.fontStyle = measureElementStyle.fontStyle; that.$.svgContainer.removeChild(measureLabel); } /** * Header click handler. */ _headerClickHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } switch (event.target) { case that.$.hourContainer: if (that.selection !== 'hour') { that.selection = 'hour'; that._changeToHourSelection(); } break; case that.$.minuteContainer: if (that.selection !== 'minute') { that.selection = 'minute'; that._changeToMinuteSelection(); } break; case that.$.amContainer: if (!that.$amContainer.hasClass('lw-selected')) { that._selectAmPm('am'); const oldValue = new Date(that.value.getTime()); that.value.setHours(that.value.getHours() - 12); // Update the hidden input that.$.hiddenInput.value = that.value; that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue }); } break; case that.$.pmContainer: if (!that.$pmContainer.hasClass('lw-selected')) { that._selectAmPm('pm'); const oldValue = new Date(that.value.getTime()); that.value.setHours(that.value.getHours() + 12); // Update the hidden input that.$.hiddenInput.value = that.value; that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue }); } break; } } /** * Highlights a label. */ _highlightLabel(value) { const that = this; if (that._highlightedLabel) { if (parseFloat(that._highlightedLabel.getAttribute('value')) === value) { return; } that._highlightedLabel.classList.remove('lw-selected'); that._highlightedLabel = undefined; } let roundedValue; if (that.selection === 'hour') { if (value === undefined) { value = that.value.getHours(); } if (that.format === '12-hour') { if (value === 0) { value = 12; } else if (value > 12) { value -= 12; } } roundedValue = value; } else { if (value === undefined) { value = that.value.getMinutes(); } roundedValue = Math.round(value / 5) * 5; if (roundedValue === 60) { roundedValue = 0; } } const labelAtValue = that.$.picker.querySelector('.lw-label[value="' + roundedValue + '"]'); if (labelAtValue && (roundedValue === value || that._overlapsLabel(labelAtValue))) { that._highlightedLabel = labelAtValue; labelAtValue.classList.add('lw-selected'); } } /** * Checks if the element is visible. */ _isVisible() { const that = this; return !!(that.offsetWidth || that.offsetHeight || that.getClientRects().length); } /** * keydown handler. */ _keydownHandler(event) { const that = this; if (that._dragging) { return; } const activeElement = (that.shadowRoot || that.getRootNode()).activeElement, key = event.key; if (that.$.header.contains(activeElement) && (key === 'Enter' || key === ' ')) { event.preventDefault(); that._headerClickHandler({ target: activeElement }); } else if (activeElement === that.$.picker && !event.altKey) { let coefficient; if (key === 'ArrowRight' || key === 'ArrowUp') { coefficient = 1; } else if (key === 'ArrowLeft' || key === 'ArrowDown') { coefficient = -1; } if (coefficient) { event.preventDefault(); if (that.selection === 'hour') { let hours = that.value.getHours(); if (hours === 0 && coefficient === -1) { hours = 23; } else if (hours === 23 && coefficient === 1) { hours = 0; } else { hours += coefficient; } if (that.format === '12-hour') { if (hours >= 12 && that.$amContainer.hasClass('lw-selected')) { hours -= 12; } else if (hours < 12 && that.$pmContainer.hasClass('lw-selected')) { hours += 12; } } that.setHours(hours, undefined, true); } else { let minutes = that.value.getMinutes(); coefficient *= that.minuteInterval; if (minutes + coefficient >= 60) { minutes = 0; } else if (minutes < coefficient * -1) { if (60 % coefficient === 0) { minutes = 60 + coefficient; } else { minutes = 60 - (60 % coefficient); } } else { minutes += coefficient; } that.setMinutes(minutes, true); } } } } /** * Returns if the arrow head overlaps a label. */ _overlapsLabel(label) { const that = this, labelRect = label.getBoundingClientRect(); let headRect = that._headRect; if (headRect.height === 0) { headRect = that._headRect = that._head.getBoundingClientRect(); } return !(labelRect.right - 10 < headRect.left || labelRect.left + 10 > headRect.right || labelRect.bottom - 10 < headRect.top || labelRect.top + 10 > headRect.bottom); } /** * Parses a date string. */ _parseDateString(value, referenceValue) { const indexOfDate = value.indexOf('Date('), indexOfBracket = value.indexOf(')'); let validValue = value; if (indexOfDate !== -1 && indexOfBracket !== -1) { validValue = value.slice(indexOfDate + 5, indexOfBracket); validValue = validValue.replace(/'/g, '').replace(/"/g, '').replace(/^\s+|\s+$|\s+(?=\s)/g, ''); if (validValue.trim() === '') { return new Date(); } if (new RegExp(/(^(\d+)(\s*,\s*\d+)+$)/g).test(validValue)) { validValue = validValue.replace(/\s/g, ''); validValue = validValue.split(','); validValue.map(function (argument, index) { validValue[index] = parseInt(argument); }); validValue.unshift(null); validValue = new (Function.prototype.bind.apply(Date, validValue)); return validValue; } } if (validValue.trim() === '') { return referenceValue; } if (!isNaN(validValue)) { return new Date(parseInt(validValue, 10)); } try { validValue = new Date(validValue); } catch (error) { validValue = referenceValue; } if (isNaN(validValue.getTime())) { return referenceValue; } return validValue; } /** * SVG picker (mouse)down event handler. */ _pickerDownHandler(event) { const that = this; if (that.disabled || that.readonly || !LW.Utilities.Core.isMobile && event.which !== 1) { return; } that._changeSelection(event); that.$.fireEvent('focus'); that.setAttribute('focus', ''); } /** * SVG picker move event handler. */ _pickerMoveHandler(event) { if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * Renders hours view. */ _renderHours() { const that = this; that._highlightedLabel = undefined; that._majorTicksInterval = 1; that._numericProcessor.addGaugeTicksAndLabels(); if (that.format === '24-hour') { that._plotInnerCircle = true; that._distance.labelDistance = 55; that._numericProcessor.addGaugeTicksAndLabels(); that._plotInnerCircle = false; that._distance.labelDistance = 10; that.$.picker.setAttribute('aria-valuemin', 0); that.$.picker.setAttribute('aria-valuemax', 23); } else { that.$.picker.setAttribute('aria-valuemin', 1); that.$.picker.setAttribute('aria-valuemax', 12); } } /** * Renders minutes view. */ _renderMinutes() { const that = this; that._highlightedLabel = undefined; that._majorTicksInterval = 5; that._numericProcessor.addGaugeTicksAndLabels(); that.$.picker.setAttribute('aria-valuemin', 0); that.$.picker.setAttribute('aria-valuemax', 59); } /** * Renders all SVG elements. */ _renderSVG() { const that = this; if (!that._isVisible() || that._renderingSuspended) { that._renderingSuspended = true; return; } that._centralCircle = that._draw.circle(that._measurements.radius, that._measurements.radius, 4, { 'class': 'lw-needle-central-circle' }); if (that.selection === 'hour' && that.format === '24-hour' && (that.value.getHours() === 0 || that.value.getHours() > 12)) { that._inInnerCircle = true; } that._drawArrow(false); that._inInnerCircle = false; if (that.selection === 'hour') { that.interval = 1; that._renderHours(); let hours = that.value.getHours(); if (that.format === '12-hour' && hours > 12) { hours -= 12; } that._highlightLabel(hours); } else { that.interval = that.minuteInterval; that._renderMinutes(); that._highlightLabel(that.value.getMinutes()); } that.$.picker.firstElementChild.setAttribute('aria-hidden', true); } /** * Gauge resize handler. */ _resizeHandler() { const that = this; let shown = false; if (!that.isRendered) { return; } if (!that._isVisible()) { that._renderingSuspended = true; return; } else { that._renderingSuspended = false; shown = true; that._getMeasurements(); that._numericProcessor.getAngleRangeCoefficient(); } that._setPickerSize(); if (that._sizeChanged || shown) { that._draw.clear(); that._renderSVG(); that._sizeChanged = false; } else { that._headRect = that._head.getBoundingClientRect(); that._highlightLabel(); } } /** * Selects the appropriate AM/PM label. */ _selectAmPm(which) { const that = this; if (which === 'am') { that._ampm = 'am'; that.$pmContainer.removeClass('lw-selected'); that.$amContainer.addClass('lw-selected'); } else { that._ampm = 'pm'; that.$amContainer.removeClass('lw-selected'); that.$pmContainer.addClass('lw-selected'); } } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this; if (that.disabled || that.unfocusable) { that.$.hourContainer.removeAttribute('tabindex'); that.$.minuteContainer.removeAttribute('tabindex'); that.$.amContainer.removeAttribute('tabindex'); that.$.pmContainer.removeAttribute('tabindex'); that.$.picker.removeAttribute('tabindex'); return; } const index = that.tabIndex > 0 ? that.tabIndex : 0; that.$.hourContainer.tabIndex = index; that.$.minuteContainer.tabIndex = index; that.$.amContainer.tabIndex = index; that.$.pmContainer.tabIndex = index; that.$.picker.tabIndex = index; } /** * Sets the SVG picker's size. */ _setPickerSize() { const that = this, parentWidth = that.$.svgContainer.offsetWidth, parentHeight = that.$.svgContainer.offsetHeight; let size = Math.min(parentWidth, parentHeight) * 0.9; if (that._pickerSize !== undefined && that._pickerSize !== size) { that._sizeChanged = true; } else { that._sizeChanged = false; } that._pickerSize = size; that._measurements.radius = size / 2; that._measurements.innerRadius = that._measurements.radius - 10; size += 'px'; that.$.picker.style.width = size; that.$.picker.style.height = size; } /** * Updates the hours. */ _updateHours(hours, suppressEvent) { const that = this; let actualHours = hours; if (that.format === '12-hour') { if (that._ampm === 'am') { if (actualHours === 12) { actualHours = 0; } } else if (actualHours < 12) { actualHours += 12; } } else { actualHours = hours; } const oldValue = that._oldValue !== undefined ? that._oldValue : new Date(that.value.getTime()), oldHours = oldValue.getHours(); if (actualHours === oldHours) { delete that._oldTimePart; return; } that._oldTimePart = oldHours; if (that._oldValue === undefined) { that.value.setHours(actualHours); } that.$.hourContainer.innerHTML = hours; if (suppressEvent !== true) { // Update the hidden input that.$.hiddenInput.value = that.value; that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue }); } if (that.selection === 'hour') { that.$.picker.setAttribute('aria-valuenow', hours); } } /** * Updates the minutes. */ _updateMinutes(minutes) { const that = this, oldValue = that._oldValue !== undefined ? that._oldValue : new Date(that.value.getTime()), oldMinutes = oldValue.getMinutes(); if (minutes === oldMinutes) { delete that._oldTimePart; return; } that._oldTimePart = oldMinutes; if (that._oldValue === undefined) { that.value.setMinutes(minutes); } if (that.selection === 'minute') { that.$.picker.setAttribute('aria-valuenow', minutes); } minutes = minutes.toString(); if (minutes.length === 1) { minutes = '0' + minutes; } that.$.minuteContainer.innerHTML = minutes; // Update the hidden input that.$.hiddenInput.value = that.value; that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue }); } /** * Validates the "footerTemplate" property. */ _validateFooterTemplate() { const that = this, footerTemplate = that.footerTemplate; if (footerTemplate === null) { that.$.footer.innerHTML = ''; return; } let potentialHTMLTemplate; if (footerTemplate instanceof HTMLTemplateElement) { potentialHTMLTemplate = footerTemplate; } else if (typeof footerTemplate === 'string') { potentialHTMLTemplate = document.getElementById(footerTemplate); if (!(potentialHTMLTemplate instanceof HTMLTemplateElement)) { potentialHTMLTemplate = undefined; } } if (potentialHTMLTemplate === undefined) { that.footerTemplate = null; that.$.footer.innerHTML = ''; return; } const templateContent = document.importNode(potentialHTMLTemplate.content, true); if (that.enableShadowDOM) { that.$.footer.innerHTML = '<slot></slot>'; that.appendChild(templateContent); return; } that.$.footer.appendChild(templateContent); } /** * Validates initial property values. */ _validateInitialPropertyValues() { const that = this; that._validateFooterTemplate(); that.minuteInterval = Math.max(1, Math.min(that.minuteInterval, 60)); that._validateValue(); } /** * Validates the "value" property. */ _validateValue() { const that = this, value = that.value, referenceValue = that._oldValue !== undefined ? this._oldValue : new Date(); if (value instanceof Date) { return; } else if (typeof value === 'string') { if (/^\d{1,2}:\d{1,2}$/.test(value)) { const timeParts = value.split(':'); that.value = new Date( referenceValue.getFullYear(), referenceValue.getMonth(), referenceValue.getDate(), parseFloat(timeParts[0]), parseFloat(timeParts[1])); return; } that.value = that._parseDateString(value, referenceValue); } else { that.value = referenceValue; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-toast-item', class ToastItem extends LW.ContentElement { /** * Element's properties */ static get properties() { return { 'showCloseButton': { value: false, type: 'boolean' }, 'iconClass': { value: null, type: 'string?' }, 'itemClass': { value: null, type: 'string?' }, 'opened': { value: false, type: 'boolean' } } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.toast.css' ] } /** * Element template */ template() { return `<div id="container" role="presentation"> <div class="lw-toast-item-header"> <span class="lw-toast-item-close-button" role="button" aria-label="Close"></span> </div> <div class="lw-toast-item-container" id="itemContainer"> <span class="lw-toast-item-icon" role="presentation"></span> <span class="lw-toast-item-content" id="itemContent" inner-h-t-m-l="[[innerHTML]]"> <content></content> </span> </div> </div>`; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { switch (propertyName) { default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Renders the element */ render() { const that = this, iconClass = that.iconClass; that.setAttribute('role', 'alert'); if (that.itemClass) { that.className += ' ' + that.itemClass; } that.$.itemContainer.firstElementChild.className += ' ' + (iconClass ? iconClass : 'default'); super.render(); } /** * Appends a node to the item */ appendChild(node) { const that = this; if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' })); return } if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.itemContent.appendChild(node); } /** * Inserts a node before another node inside the item. */ insertBefore(node, referenceNode) { const that = this; if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'node' })); return } if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.itemContent.insertBefore(node, referenceNode || null); } /** * Removes a child from the item. */ removeChild(node) { const that = this; if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' })); return } if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } that.$.itemContent.removeChild(node); } }) /** * lwToast custom element. */ LW('lw-toast', class Toast extends LW.ContentElement { /** * Element's properties */ static get properties() { return { 'appendTo': { value: null, type: 'any' }, 'autoClose': { value: false, type: 'boolean' }, 'autoCloseDelay': { value: 3000, type: 'number' }, 'autoOpen': { value: false, type: 'boolean' }, 'iconClass': { value: null, type: 'string?' }, 'itemClass': { value: null, type: 'string?' }, 'itemTemplate': { value: null, type: 'string?' }, 'modal': { value: false, type: 'boolean' }, 'position': { allowedValues: ['top-left', 'top-right', 'bottom-left', 'bottom-right'], value: 'top-right', type: 'string' }, 'showCloseButton': { value: false, type: 'boolean' }, 'type': { allowedValues: ['info', 'warning', 'success', 'error', 'mail', 'time', null], value: 'info', type: 'string?' }, 'value': { value: '', type: 'any' } } } /** * ShadowDOM enable/disable flag */ get enableShadowDOM() { return false; } /** * Tab Items Group's HTML template. */ template() { return ''; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'value': { const item = that._instances[that._instances.length - 1]; if (item) { if (newValue instanceof HTMLElement) { item.appendChild(newValue); } else { (item.shadowRoot ? item.shadowRoot : item).querySelector('.lw-toast-item-content').innerHTML = newValue; } } break; } case 'appendTo': case 'modal': case 'position': that._handleContainers(); break; case 'rightToLeft': if (that._instances) { that._instances.forEach(item => item[propertyName] = newValue); } break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Called when the element is attached to the DOM. */ attached() { super.attached(); const that = this, containers = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'Custom', 'Modal']; for (let i = 0; i < containers.length; i++) { const itemContainer = that.$['toastContainer' + containers[i]]; if (itemContainer && itemContainer.children.length) { if (containers[i] === 'Custom') { that._appendTo.appendChild(that._container); } else { that.getShadowRootOrBody().appendChild(itemContainer); } } } } /** * Called when the element is detached from the DOM. */ detached() { super.detached(); const that = this, containers = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'Custom', 'Modal']; for (let i = 0; i < containers.length; i++) { const itemContainer = that.$['toastContainer' + containers[i]]; if (itemContainer) { that._removeContainerListeners(itemContainer); itemContainer.parentElement.removeChild(itemContainer); } that.closeAll(); } } /** * Element's ready method. */ ready() { super.ready(); } render() { const that = this; if (that.value && !(that.value instanceof HTMLElement)) { that.innerHTML = that.value; } else { that.value = that.innerHTML; } that._instances = []; if (that.autoOpen) { that.open(); } super.render(); } /** * Closes all opened toast items */ closeAll() { const that = this; for (var i = that._instances.length - 1; i > -1; i--) { that._close(that._instances[i]); } } /** * Closes particular item */ closeItem(instance) { const that = this; if (!instance || that._instances.length === 0) { return; } if (typeof instance === 'string') { instance = document.getElementById(instance); } else if (instance instanceof HTMLElement) { instance = instance.closest('lw-toast-item'); } if (!instance || that._instances.indexOf(instance) === -1) { return; } that._close(instance); } /** * Closes the last opened toast item */ closeLast() { const that = this; if (that._instances.length > 0) { that._close(that._instances[that._instances.length - 1]); } } /** * Opens a new toast item instance */ open() { const that = this; if (that.disabled) { return; } that._handleContainers(); let item = document.createElement('lw-toast-item'); item.iconClass = that.iconClass; item.itemClass = that.itemClass; if (that.value instanceof HTMLElement) { item.appendChild(that.value); } else { item.innerHTML = that._handleItemTemplate() || that.value; } item.rightToLeft = that.rightToLeft; item.theme = that.theme; item.animation = that.animation; item.showCloseButton = that.showCloseButton for (let i = 0; i < that.classList.length; i++) { if (that.classList[i].indexOf('lw-') < 0) { item.classList.add(that.classList[i]); } } that._container.appendChild(item); if (that.type) { const icon = item.querySelector('.lw-toast-item-icon'); item.classList.add(that.type); if (icon) { icon.setAttribute('aria-label', that.type + ' icon'); } } item._parent = that._container; that._instances.push(item); that.$.fireEvent('open', { 'instance': item }); setTimeout(function () { item.opened = true; }, 10); if (that.autoClose) { item._autoCloseTimeout = setTimeout(function () { that._close(item); }, that.autoCloseDelay); } return item; } /** * Container's click handler. Common for all toast containers */ _containerClickHandler(event) { const that = this, target = event.target.shadowRoot ? event.composedPath()[0] : event.target, clickedButton = target.closest('.lw-toast-item-close-button'), clickedItem = (target.getRootNode().host || target).closest('lw-toast-item'); if (clickedButton || clickedItem) { that.$.fireEvent('click', { 'instance': clickedItem, 'target': target }); if (clickedButton) { that._close(clickedItem); } } else if (that.modal) { that.closeAll(); } } /** * Closes (removes) an toast item instance */ _close(instance) { const that = this; if (that._instances.indexOf(instance) > -1) { const closeTransitionDuration = window.getComputedStyle(instance, null).getPropertyValue('transition-duration'), interval = closeTransitionDuration.indexOf('ms') > -1 ? parseInt(closeTransitionDuration) : parseFloat(closeTransitionDuration) * 1000; instance.opened = false; that._instances.splice(that._instances.indexOf(instance), 1); setTimeout(function () { clearTimeout(instance._autoCloseTimeout); that.$.fireEvent('close', { 'instance': instance }); if (instance.parentNode) { instance.parentNode.removeChild(instance); } const parentContainer = instance._parent; if (parentContainer && !parentContainer.children.length && parentContainer.parentElement) { that._removeContainerListeners(parentContainer); parentContainer.parentElement.removeChild(parentContainer); } }, interval); } } /** * Handles the contaner in use, where all new items will be stored */ _handleContainers() { const that = this; let customContainer; if (typeof that.appendTo === 'string') { customContainer = document.getElementById(that.appendTo); } else if (that.appendTo instanceof HTMLElement) { customContainer = that.appendTo; } //Get or create the toast items container that._container = that._getToastContainer(customContainer); if (customContainer) { that._appendTo = customContainer; if (!that._container.parentElement) { //Add events listeners that._addContainerListeners(that._container); that._appendTo.appendChild(that._container); } return; } if (!customContainer && that.$.toastContainerCustom && !that.$.toastContainerCustom.children.length) { that._removeContainerListeners(that.$.toastContainerCustom); if (that.$.toastContainerCustom.parentElement) { that.$.toastContainerCustom.parentElement.removeChild(that.$.toastContainerCustom); } } if (!that._container.parentElement) { //Add events listeners that._addContainerListeners(that._container); that.getShadowRootOrBody().appendChild(that._container); } } /** * Adds event listeners to the toast item container * @param {any} container */ _addContainerListeners(container) { const that = this; if (!container) { return; } const containerId = container.getAttribute('lw-id'), containerEvents = that['$' + containerId]; if (containerEvents) { containerEvents.listen('click', that._containerClickHandler.bind(that)); containerEvents.listen('swipeleft', that._swipeHandler.bind(that)); containerEvents.listen('swiperight', that._swipeHandler.bind(that)); containerEvents.listen('swipetop', that._swipeHandler.bind(that)); containerEvents.listen('swipebottom', that._swipeHandler.bind(that)); } } /** * Removes the event listeners from the toast item container * @param {any} container */ _removeContainerListeners(container) { const that = this; if (!container) { return; } const containerId = container.getAttribute('lw-id'), containerEvents = that['$' + containerId]; if (containerEvents) { containerEvents.unlisten('click'); containerEvents.unlisten('swipeleft'); containerEvents.unlisten('swiperight'); containerEvents.unlisten('swipetop'); containerEvents.unlisten('swipebottom'); } } /** * Returns a toast items container * @param {any} customContainer */ _getToastContainer(customContainer) { const that = this; let type; if (customContainer) { type = 'Custom'; } else if (that.modal) { type = 'Modal'; } else { type = LW.Utilities.Core.toCamelCase(that.position); type = type.charAt(0).toUpperCase() + type.slice(1); } const containerName = 'toastContainer' + type; if (!that.$[containerName]) { //Create it let container = document.createElement('div'); container.setAttribute('lw-id', containerName); container.classList.add('lw-toast-container'); container.classList.add('lw-toast-container-' + LW.Utilities.Core.toDash(type)); that.$['toastContainer' + type] = container; that['$toastContainer' + type] = LW.Utilities.Extend(container); } return that.$[containerName]; } /** * Apply the template to the toast. */ _handleItemTemplate() { const that = this; let template = that.itemTemplate; if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } if (!template) { return that.value; } template = document.getElementById(template); if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' })); return; } const content = template.innerHTML, regex = /{{\w+}}/g; return content.replace(regex, that.value); } /** * SwipeLeft and SwipeRight event handler. **/ _swipeHandler(event) { const that = this, instance = event.originalEvent.target.closest('lw-toast-item'); event.stopPropagation(); if (!instance) { return; } that.$.fireEvent(event.type, { 'instance': instance }); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Tooltip custom element. */ LW('lw-tooltip', class Tooltip extends LW.ContentElement { // Tooltip's properties. static get properties() { return { 'arrow': { value: false, type: 'boolean' }, 'arrowDirection': { allowedValues: ['bottom', 'top', 'left', 'right'], value: 'bottom', type: 'string' }, 'delay': { value: 0, type: 'number' }, 'messages': { extend: true, value: { 'en': { 'invalidSelector': '{{elementType}}: "{{property}}" must be a String, an HTMLElement or null.', 'htmlTemplateNotSuported': '{{elementType}}: Browser doesn\'t support HTMLTemplate elements.', 'invalidTemplate': '{{elementType}}: "{{property}}" property accepts a string that must match the id of an HTMLTemplate element from the DOM.', 'invalidNode': '{{elementType}}: Invalid parameter "{{node}}" when calling {{method}}.' } }, type: 'object' }, 'offset': { value: [], type: 'array' }, 'openMode': { allowedValues: ['click', 'focus', 'hover', 'manual'], value: 'hover', type: 'string' }, 'position': { allowedValues: ['bottom', 'top', 'left', 'right', 'absolute', 'auto'], value: 'top', type: 'string' }, 'selector': { value: null, type: 'any?' }, 'tooltipTemplate': { value: null, type: 'any' }, 'value': { value: '', type: 'string', reflectToAttribute: false }, 'visible': { value: false, type: 'boolean' } }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.tooltip.css' ] } /** * Tooltip's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="content" class="lw-tooltip-content" inner-h-t-m-l="[[innerHTML]]" role="presentation"> <content></content> </div> </div>`; } /** * Updates the Tooltip when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; let eventType; switch (propertyName) { case 'openMode': that.close(); that._handleEventListeners(oldValue); that._handleResize(); break; case 'selector': that._oldOwnerElement = that._ownerElement; that._handleSelector(newValue); that._handleEventListeners(); break; case 'tooltipTemplate': that._handleTemplate(oldValue); break; case 'value': that.tooltipTemplate ? that._handleTemplate() : that.$.content.innerHTML = that.value; break; case 'visible': eventType = newValue ? 'open' : 'close'; that.$.fireEvent(eventType, { 'owner': that._ownerElement }, that.isInShadowDOM ? { composed: true, bubbles: true, cancelable: true } : undefined); break; } that._applyPosition(); } /** * Called when the element is ready */ ready() { const that = this; super.ready(); that.setAttribute('role', 'tooltip'); that._isParentPositionStatic = window.getComputedStyle(that.parentElement || document.querySelector('body')).position === 'static'; that._handleSelector(that.selector); if (that.visible) { that._applyPosition(); } that._handleEventListeners(); that._handleResize(); that.value = that.$.content.innerHTML = that.value ? that.value : that.innerHTML; that._handleTemplate(); } /** * Appends a node to the tooltip. */ appendChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' })); return } that.$.content.appendChild(node); that._applyPosition(); } /** * Closes the tooltip */ close() { const that = this; if (that._isOpening) { clearTimeout(that._isOpening); } if (!that.visible) { return; } that.$.fireEvent('close', { 'owner': that._ownerElement }, that.isInShadowDOM ? { composed: true, bubbles: true, cancelable: true } : undefined); that.visible = false; } /** * Inserts a new node after another node in the tooltip. */ insertBefore(newNode, referenceNode) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!newNode || !referenceNode) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' })); return; } that.$.content.insertBefore(newNode, referenceNode); that._applyPosition(); } /** * Open the tooltip */ open() { const that = this; if (that.disabled || that.readonly || that.visible) { return; } that._isOpening = setTimeout(function () { that._applyPosition(); that.$.fireEvent('open', { 'owner': that._ownerElement }, that.isInShadowDOM ? { composed: true, bubbles: true, cancelable: true } : undefined); //Avoid unnecessaty propertyChangedHandler call const context = that.context; that.context = that; that.visible = true; that.context = context; }, that.delay); } /** * Removes a node from the tooltip. */ removeChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' })); return } that.$.content.removeChild(node); that._applyPosition(); } /** * Toggle the tooltip */ toggle() { const that = this; that.visible ? that.close() : that.open(); } /** * Returns the Array of parents of a target element * @param {any} element */ _getDomElementPosition(element) { let arrayWithParentNodes = [], testedElement = element.parentElement; while (testedElement && testedElement.nodeName !== 'BODY') { arrayWithParentNodes.push(testedElement); if (this.enableShadowDOM && !testedElement.parentElement) { testedElement = testedElement.getRootNode().host; continue; } testedElement = testedElement.parentElement; } return arrayWithParentNodes; } /** * Returns the first non static parent of the tooltip's ownerElement */ _getElementAndOwnerRelation(element) { const tooltipDistanceToBody = this._getDomElementPosition(element || this), tooltipLevelsNumber = tooltipDistanceToBody.length; let itemWithNonStaticPosition = null; for (let i = 0; i < tooltipLevelsNumber; i++) { let style = window.getComputedStyle(tooltipDistanceToBody[i]); if (style.getPropertyValue('position') !== 'static') { itemWithNonStaticPosition = tooltipDistanceToBody[i]; break; } } return itemWithNonStaticPosition; } /** * Selector property handler. */ _applyPosition() { const that = this; if (!that._ownerElement) { return; } if (!that.parentElement) { return; } that._isParentPositionStatic = window.getComputedStyle(that.parentElement).position === 'static'; const ownerRectData = that._ownerElement.getBoundingClientRect(), parentRectData = that.parentElement ? that.parentElement.getBoundingClientRect() : { top: 0, left: 0 }; let topPosition, leftPosition; if (that.parentElement && (that.parentElement.nodeName.toUpperCase() === 'BODY')) { topPosition = ownerRectData.top + window.scrollY; leftPosition = ownerRectData.left + window.scrollX; } else { topPosition = ownerRectData.top - parentRectData.top; leftPosition = ownerRectData.left - parentRectData.left; } const positionObject = { top: ownerRectData.top, left: ownerRectData.left, nonStaticParent: that._getElementAndOwnerRelation() }, position = that.position; let translate; switch (position) { case 'auto': case 'bottom': case 'top': case 'left': case 'right': { const pos = that['_position' + position.charAt(0).toUpperCase() + position.slice(1)](leftPosition, topPosition, positionObject); topPosition = pos.top; leftPosition = pos.left; translate = pos.translate; break; } case 'absolute': that.style.top = that.style.left = ''; topPosition = leftPosition = 0; break; } //Arrow Translation is applied when position='auto' if (translate) { that.$.container.style.setProperty('--lw-tooltip-arrow-translate', translate + 'px'); } else { that.$.container.style.removeProperty('--lw-tooltip-arrow-translate'); } if (topPosition !== undefined && !isNaN(topPosition)) { topPosition += parseInt(that.offset[1]) || 0; that.style.top = topPosition + 'px'; } if (leftPosition !== undefined && !isNaN(leftPosition)) { leftPosition += parseInt(that.offset[0]) || 0; that.style.left = leftPosition + 'px'; } } /** * Handles the auto positioning of the element * @param {any} leftPosition - left position * @param {any} topPosition - right position * @param {any} positionObject - positionObject with details of it's first relative parent */ _positionAuto(leftPosition, topPosition, positionObject) { const that = this; let parentElement = that.parentElement, overflowParent; while (parentElement) { if (getComputedStyle(parentElement).getPropertyValue('overflow') === 'hidden') { overflowParent = parentElement; break; } parentElement = parentElement.parentElement; } if (!overflowParent) { overflowParent = document.body; } const overFlowParentRect = overflowParent.getBoundingClientRect(), arrowWidth = parseFloat(window.getComputedStyle(that).getPropertyValue('--lw-tooltip-arrow-width')) || 0; let possiblePosition = that._positionTop(leftPosition, topPosition, positionObject), nonStaticParent = positionObject.nonStaticParent, minTranslate = that.offsetWidth / 2 - arrowWidth, nonStaticParentTop = 0, nonStaticParentLeft = 0; if (nonStaticParent) { const nonStaticParentRect = nonStaticParent.getBoundingClientRect(); nonStaticParentTop = nonStaticParentRect.top; nonStaticParentLeft = nonStaticParentRect.left; } if (possiblePosition.top + nonStaticParentTop >= overFlowParentRect.top) { topPosition = possiblePosition.top; leftPosition = Math.max(overFlowParentRect.left - nonStaticParentLeft, possiblePosition.left + Math.min(0, overFlowParentRect.right - (possiblePosition.left + nonStaticParentLeft + that.offsetWidth))); return { left: leftPosition, top: topPosition, translate: Math.max(-minTranslate, Math.min(minTranslate, possiblePosition.left - leftPosition)) }; } possiblePosition = that._positionBottom(leftPosition, topPosition, positionObject); if (possiblePosition.top + that.offsetHeight + nonStaticParentTop <= overFlowParentRect.bottom) { topPosition = possiblePosition.top; leftPosition = Math.max(overFlowParentRect.left - nonStaticParentLeft, possiblePosition.left + Math.min(0, overFlowParentRect.right - (possiblePosition.left + nonStaticParentLeft + that.offsetWidth))); return { left: leftPosition, top: topPosition, translate: Math.max(-minTranslate, Math.min(minTranslate, possiblePosition.left - leftPosition)) }; } possiblePosition = that._positionLeft(leftPosition, topPosition, positionObject); topPosition = possiblePosition.top; minTranslate = that.offsetHeight / 2 - arrowWidth; topPosition = Math.max(overFlowParentRect.top - nonStaticParentTop, possiblePosition.top + Math.min(0, overFlowParentRect.bottom - (possiblePosition.top + nonStaticParentTop + that.offsetHeight))); if (possiblePosition.left + nonStaticParentLeft >= overFlowParentRect.left) { leftPosition = possiblePosition.left; } else { possiblePosition = that._positionRight(leftPosition, topPosition, positionObject); leftPosition = possiblePosition.left; } return { left: leftPosition, top: topPosition, translate: Math.max(-minTranslate, Math.min(minTranslate, possiblePosition.top - topPosition)) }; } /** * Returns the offset off all non static parents until the target nonStaticParent * @param {any} nonStaticParent */ _getRelativeParentOffset(nonStaticParent) { const that = this, ownerElement = that._ownerElement; let ownerNonStaticParent = that._getElementAndOwnerRelation(ownerElement); let top = 0, left = 0; if (!nonStaticParent) { return { left: left, top: top } } while (nonStaticParent !== ownerNonStaticParent) { top += ownerNonStaticParent.offsetTop; left += ownerNonStaticParent.offsetLeft; ownerNonStaticParent = that._getElementAndOwnerRelation(ownerNonStaticParent); } return { left: left, top: top } } /** * Position the Tooltip Above the ownerElement * @param {any} leftPosition - left position * @param {any} topPosition - right position * @param {any} positionObject - positionObject with details of it's first relative parent */ _positionTop(leftPosition, topPosition, positionObject) { const that = this, offsetTillNonStaticParent = that._getRelativeParentOffset(positionObject.nonStaticParent); that.set('arrowDirection', 'bottom'); if (positionObject.nonStaticParent === null) { topPosition = (positionObject.top + window.scrollY - that.offsetHeight); leftPosition = (positionObject.left + window.scrollX - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } if (that._isParentPositionStatic) { topPosition = (that._ownerElement.offsetTop - that.offsetHeight); leftPosition = (that._ownerElement.offsetLeft - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2); if (that._ownerElement instanceof SVGElement) { // to be applied in all modes const rect = that._ownerElement.getBoundingClientRect(), rectParent = that._ownerElement.parentNode.getBoundingClientRect(); topPosition = (rect.top - rectParent.top - that.offsetHeight / 2); leftPosition = (rect.left - that.offsetWidth / 2 + rectParent.left / 2); } return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } if (that._ownerElement instanceof SVGElement && that._ownerElement.parentElement) { const rect = that._ownerElement.getBoundingClientRect(), rectParent = that._ownerElement.parentNode.getBoundingClientRect(); topPosition = (rect.top - rectParent.top - that.offsetHeight); leftPosition = (rect.left - rectParent.left - (that.offsetWidth / 2)) + (rect.width / 2); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } topPosition = (topPosition - that.offsetHeight); leftPosition = (leftPosition - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } /** * Position the Tooltip Below the ownerElement * @param {any} leftPosition - left position * @param {any} topPosition - right position * @param {any} positionObject - positionObject with details of it's first relative parent */ _positionBottom(leftPosition, topPosition, positionObject) { const that = this, offsetTillNonStaticParent = that._getRelativeParentOffset(positionObject.nonStaticParent); that.set('arrowDirection', 'top'); if (positionObject.nonStaticParent === null) { topPosition = (positionObject.top + window.scrollY + that._ownerElement.offsetHeight); leftPosition = (positionObject.left + window.scrollX - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } if (that._isParentPositionStatic) { topPosition = (that._ownerElement.offsetTop + that._ownerElement.offsetHeight); leftPosition = (that._ownerElement.offsetLeft - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } topPosition = (topPosition + that._ownerElement.offsetHeight); leftPosition = (leftPosition - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } /** * Position the Tooltip to the Left of the ownerElement * @param {any} leftPosition - left position * @param {any} topPosition - right position * @param {any} positionObject - positionObject with details of it's first relative parent */ _positionLeft(leftPosition, topPosition, positionObject) { const that = this, offsetTillNonStaticParent = that._getRelativeParentOffset(positionObject.nonStaticParent); that.set('arrowDirection', 'right'); if (positionObject.nonStaticParent === null) { topPosition = (positionObject.top + window.scrollY + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2); leftPosition = (positionObject.left + window.scrollX - that.offsetWidth); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } if (that._isParentPositionStatic) { topPosition = (that._ownerElement.offsetTop + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2); leftPosition = (that._ownerElement.offsetLeft - that.offsetWidth); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } topPosition = (topPosition + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2); leftPosition = (leftPosition - that.offsetWidth); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } /** * Position the Tooltip to the Right of the ownerElement * @param {any} leftPosition - left position * @param {any} topPosition - right position * @param {any} positionObject - positionObject with details of it's first relative parent */ _positionRight(leftPosition, topPosition, positionObject) { const that = this, offsetTillNonStaticParent = that._getRelativeParentOffset(positionObject.nonStaticParent); that.set('arrowDirection', 'left'); if (positionObject.nonStaticParent === null) { topPosition = (positionObject.top + window.scrollY + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2); leftPosition = (positionObject.left + window.scrollX + that._ownerElement.offsetWidth); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } if (that._isParentPositionStatic) { topPosition = (that._ownerElement.offsetTop + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2); leftPosition = (that._ownerElement.offsetLeft + that._ownerElement.offsetWidth); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } topPosition = (topPosition + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2); leftPosition = (leftPosition + that._ownerElement.offsetWidth); return { left: leftPosition + offsetTillNonStaticParent.left, top: topPosition + offsetTillNonStaticParent.top }; } /** * Events Handller. * @param {any} event */ _eventsHandler(event) { const that = this; if (that.disabled || that.readonly) { return; } if (event.type === 'click') { that.visible ? this.close() : this.open(); return; } event.type === 'mouseenter' || event.type === 'focus' ? this.open() : this.close(); } /** * Adds event listeners to owner */ _handleEventListeners(oldValue) { const that = this; if (that._oldOwnerElement && that.openMode !== 'manual') { let ariaDescribedby = that._oldOwnerElement.getAttribute('aria-describedby'); if (ariaDescribedby) { if (ariaDescribedby === that.id) { that._oldOwnerElement.removeAttribute('aria-describedby'); } else { ariaDescribedby = ariaDescribedby.replace(' ' + that.id, ''); ariaDescribedby = ariaDescribedby.replace(that.id + ' ', ''); that._oldOwnerElement.setAttribute('aria-describedby', ariaDescribedby); } } that._oldOwnerElement.$.unlisten('mouseenter.tooltip'); that._oldOwnerElement.$.unlisten('mouseleave.tooltip'); that._oldOwnerElement.$.unlisten('focus.tooltip'); that._oldOwnerElement.$.unlisten('blur.tooltip'); that._oldOwnerElement.$.unlisten('click.tooltip'); that._oldOwnerElement = null; } if (!that._ownerElement) { return; } if (oldValue) { //unlisten from previous event. switch (oldValue) { case 'hover': that._ownerElement.$.unlisten('mouseenter.tooltip'); that._ownerElement.$.unlisten('mouseleave.tooltip'); break; case 'focus': that._ownerElement.$.unlisten('focus.tooltip'); that._ownerElement.$.unlisten('blur.tooltip'); break; case 'click': that._ownerElement.$.unlisten('click.tooltip'); break; } } if (that.openMode === 'manual') { return; } if (!(that._ownerElement instanceof LW.BaseElement)) { that._ownerElement.$ = LW.Utilities.Extend(that._ownerElement); } //listen to appropriate event switch (that.openMode) { case 'hover': that._ownerElement.$.listen('mouseenter.tooltip', that._eventsHandler.bind(that)); that._ownerElement.$.listen('mouseleave.tooltip', that._eventsHandler.bind(that)); break; case 'focus': that._ownerElement.$.listen('focus.tooltip', that._eventsHandler.bind(that)); that._ownerElement.$.listen('blur.tooltip', that._eventsHandler.bind(that)); break; case 'click': that._ownerElement.$.listen('click.tooltip', that._eventsHandler.bind(that)); break; default: break; } } /** * Updates the position of the tooltip on window resize. */ _handleResize() { const that = this; function applyPosition() { that._applyPosition(); } if (that.openMode === 'click') { window.addEventListener('resize', applyPosition); } else { window.removeEventListener('resize', applyPosition); } } /** * Selector property handler. */ _handleSelector(newValue) { const that = this; if (typeof newValue === 'string') { that._ownerElement = newValue.length > 0 ? document.getElementById(newValue) : undefined; } else if (newValue instanceof HTMLElement || newValue instanceof SVGElement) { that._ownerElement = newValue; } else if (newValue === null) { that._ownerElement = undefined; return; } else { that.error(that.localize('invalidSelector', { elementType: that.nodeName.toLowerCase(), property: 'selector' })); } const ariaDescribedby = that._ownerElement ? that._ownerElement.getAttribute('aria-describedby') : null; if (!that._ownerElement) { return; } if (!ariaDescribedby) { that._ownerElement.setAttribute('aria-describedby', that.id); } else { that._ownerElement.setAttribute('aria-describedby', ariaDescribedby + ' ' + that.id); } } /** * Apply the template to the tooltip. */ _handleTemplate(oldValue) { const that = this; let template = that.tooltipTemplate; if (oldValue) { that.$.content.innerHTML = that.value ? that.value : ''; } if (template === null || !template) { return; } if (typeof that.tooltipTemplate === 'function') { that.tooltipTemplate(that.$.content, { value: that.value }); return; } if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } template = document.getElementById(template); if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' })); return; } const content = template.content, childrenCount = content.childNodes.length, regex = /{{\w+}}/g; let bindingString, bindingDetails = []; for (let i = 0; i < childrenCount; i++) { bindingString = regex.exec(content.childNodes[i].innerHTML); while (bindingString) { bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] }); bindingString = regex.exec(content.childNodes[i].innerHTML); } } const bindingsCount = bindingDetails.length; let clone = document.importNode(template.content, true), bindingHolderElement, bindingStringsCount; for (let b = 0; b < bindingsCount; b++) { bindingHolderElement = clone.childNodes[bindingDetails[b].childNodeIndex]; bindingStringsCount = bindingDetails.length; for (let i = 0; i < bindingStringsCount; i++) { bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(bindingDetails[b].bindingString, that.value); } } that.$.content.innerHTML = ''; for (let i = 0; i < clone.childNodes.length; i++) { if (clone.childNodes[i].outerHTML) { that.$.content.innerHTML += clone.childNodes[i].outerHTML; } } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * CardView custom element. */ LW('lw-card-view', class CardView extends LW.DataView { // CardView's properties. static get properties() { return { 'cardHeight': { value: null, type: 'number?' }, 'cellOrientation': { value: 'vertical', allowedValues: ['horizontal', 'vertical'], type: 'string' }, 'coverField': { value: null, type: 'string?' }, 'coverMode': { value: 'crop', allowedValues: ['fit', 'crop'], type: 'string' }, 'messages': { value: { 'en': { 'addImage': 'Add', 'coverField': 'Cover field', 'crop': 'Crop', 'customize': 'Customize cards', 'dateTabLabel': 'DATE', 'draggedRecord': 'Record {{id}}', 'fit': 'Fit', 'imageUrl': 'New image URL:', 'incorrectStructure': '"dataSource" must be an instance of LW.DataAdapter or an array of objects with key-value pairs.', 'nextRecord': 'Next record', 'noCoverField': 'No cover field', 'noData': 'No data to display', 'noMatches': 'No matched records', 'now': 'Now', 'previousRecord': 'Previous record', 'removeImage': 'Remove', 'timeTabLabel': 'TIME', 'toggleVisibility': 'Toggle field visibility' } } }, 'onRecordInserted': { value: null, type: 'function?', reflectToAttribute: false }, 'onRecordRemoved': { value: null, type: 'function?', reflectToAttribute: false }, 'scrolling': { value: 'physical', allowedValues: ['physical', 'virtual', 'infinite', 'deferred'], type: 'string' }, 'titleField': { value: null, type: 'string?' } }; } /** * CardView's event listeners. */ static get listeners() { return { 'click': '_clickHandler', 'move': '_moveHandler', 'addNewButton.click': '_addNewButtonClickHandler', 'cardContainer.down': '_cardContainerDownHandler', 'scrollViewer.touchmove': '_scrollViewerTouchmoveHandler' }; } /** * CardView's required files. */ static get requires() { return { 'LW.Button': 'lw.button.js', 'LW.Card': 'lw.card.js', 'LW.Carousel': 'lw.carousel.js', 'LW.CheckBox': 'lw.checkbox.js', 'LW.ColumnPanel': 'lw.gridpanel.js', 'LW.DataAdapter': 'lw.data.js', 'LW.DateTimePicker': 'lw.datetimepicker.js', 'LW.Input': 'lw.input.js', 'LW.NumericTextBox': 'lw.numerictextbox.js', 'LW.ScrollBar': 'lw.scrollbar.js', 'LW.SwitchButton': 'lw.switchbutton.js', 'LW.Window': 'lw.window.js', 'LW.Utilities.DateTime': 'lw.date.js' }; } get hasStyleObserver() { return false; } get editInfo() { return this._editInfo; } /** * ShadowDOM style references */ static get styleUrls() { return [ 'lw.cardview.css' ] } /** * CardView's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="header" class="lw-data-view-header" role="toolbar"> <div id="customizeButton" class="lw-data-view-header-button lw-data-view-customize-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Customize cards"><div role="presentation"></div></div> <div id="filterButton" class="lw-data-view-header-button lw-data-view-filter-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Filter"><div role="presentation"></div></div> <div id="sortButton" class="lw-data-view-header-button lw-data-view-sort-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Sort"><div role="presentation"></div></div> <div id="searchButton" class="lw-data-view-header-button lw-data-view-search-button lw-unselectable" role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Search"></div> <div id="headerDropDown" class="lw-data-view-header-drop-down lw-visibility-hidden" role="dialog"> <div id="customize" class="lw-hidden" role="presentation"></div> <div id="filter" class="lw-hidden" role="presentation"></div> <div id="sort" class="lw-hidden" role="presentation"></div> <div id="search" class="lw-data-view-search-box lw-hidden" role="presentation"> <input type="text" id="searchInput" spellcheck="false" aria-label="Search" /> <div id="searchLabel" class="lw-data-view-search-label lw-unselectable"></div> <div id="searchPrev" class="lw-data-view-search-prev" role="button" aria-label="Previous"></div> <div id="searchNext" class="lw-data-view-search-next" role="button" aria-label="Next"></div> <div id="searchClose" class="lw-data-view-search-close" role="button" aria-label="Close search box"></div> </div> </div> </div> <lw-scroll-viewer id="scrollViewer" animation="[[animation]]" horizontal-scroll-bar-visibility="hidden" right-to-left="[[rightToLeft]]"> <div id="cardContainer" class="lw-card-container" role="list"></div> </lw-scroll-viewer> <div id="loadingIndicatorContainer" class="lw-loader-container lw-hidden" aria-label="Loading"> <span id="loadingIndicator" class="lw-loader" role="presentation"></span> </div> <div id="addNewButton" class="lw-add-new-button" role="button" aria-label="Add new card"></div> </div>`; } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (that.isCompleted && that._editInfo) { that._addWindowHandlers(); document.body.appendChild(that._editInfo.window); } } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); if (!that._editInfo) { return; } const window = that._editInfo.window; window.removeEventListener('open', that._windowEventHandler); window.removeEventListener('closing', that._windowEventHandler); window.removeEventListener('close', that._windowEventHandler); window.removeEventListener('click', that._windowClickHandler); window.removeEventListener('prev', that._prevNextHandler); window.removeEventListener('next', that._prevNextHandler); window.remove(); } /** * Called when the element is ready */ ready() { super.ready(); } render() { const that = this, dataSource = that.dataSource, scrolling = that.scrolling, computedStyle = getComputedStyle(that); if (LW.Utilities.NumberRenderer) { that._numericFormatter = new LW.Utilities.NumberRenderer(); } if (that.shadowRoot) { that.importStyle(LW.Utilities.Core.getScriptLocation() + LW.StyleBaseUrl.replace('/scoped/', '/lw.scrollviewer.css')); that.importStyle(LW.Utilities.Core.getScriptLocation() + LW.StyleBaseUrl.replace('/scoped/', '/lw.carousel.css')); that.importStyle(LW.Utilities.Core.getScriptLocation() + LW.StyleBaseUrl.replace('/scoped/', '/lw.button.css')); that.importStyle(LW.Utilities.Core.getScriptLocation() + LW.StyleBaseUrl.replace('/scoped/', '/lw.sortable.css')); } that._gap = parseFloat(computedStyle.getPropertyValue('--lw-card-view-gap')); that._verticalOffset = parseFloat(computedStyle.getPropertyValue('--lw-card-view-vertical-offset')); that._cards = []; that._collapsed = {}; that._collapsedRows = {}; that._numberOfCollapsedRows = 0; that._cardScrolling = {}; that._cardSelectedCover = {}; that._cardHeight = that.cardHeight; that._autoCardHeight = that._cardHeight === null; that._cachedWidth = that.offsetWidth; that._cachedHeight = that.offsetHeight; that._appliedFiltering = { filters: [], operator: 'and' }; that._appliedSorting = { dataFields: [], dataTypes: [], orderBy: [] }; that._start = { view: 0, data: 0 }; that._autoScrollCoefficient = LW.Utilities.Core.Browser.Firefox ? 8 : LW.Utilities.Core.Browser.Edge ? 16 : 4; that._normalizeDataSource(); that._getVisibleRecords(); that._normalizeColumns(); that._handleHeaderPosition(that.$.scrollViewer); that._localizeHeader(); that._getInnerElementMessages(); if (scrolling === 'deferred') { that.$.scrollViewer.$.verticalScrollBar.mechanicalAction = 'switchWhenReleased'; } else if ((scrolling === 'virtual' || scrolling === 'infinite') && dataSource && dataSource.onVirtualDataSourceRequested === undefined) { that.scrolling = 'physical'; } that._createTemplate(); if (scrolling === 'infinite') { that._requestInitialCards(); } else { that._createCards(); } that.$.scrollViewer._verticalScrollbarHandler = that._onVerticalChange.bind(that); that.$.scrollViewer.hasStyleObserver = false; that.$.scrollViewer.$.verticalScrollBar.hasStyleObserver = false; that.$.scrollViewer.$.horizontalScrollBar.hasStyleObserver = false; super.render(); } /** * Adds a new record. * * @param {Number/String} recordId Optional The id of the record to add. * @param {Object} data Optional The data of the record to add. * @param {String} position Optional The position to add the record to. Possible values: 'first' and 'last'. */ addRecord(recordId, data = {}, position = 'last') { const that = this, dataSource = that.dataSource, scrolling = that.scrolling; function refresh() { if (position !== 'first') { position = 'last'; dataSource.insert(dataSource.length, data); if (dataSource !== that._visibleSource) { that._visibleSource.push(dataSource[dataSource.length - 1]); } } else { dataSource.insert(0, data); if (dataSource !== that._visibleSource) { that._visibleSource.unshift(dataSource[0]); } } that._closeSearchPanel(); that._fullRefresh(); } if (typeof data !== 'object') { return; } if (that.dataSource.dataFields.length === 0) { const newDataSource = [data]; that.dataSource = newDataSource; that.propertyChangedHandler('dataSource', null, newDataSource); return; } const idMember = dataSource.id; if (idMember) { if (recordId !== null && recordId !== undefined && recordId !== '') { data[idMember] = recordId; } else if (data[idMember] === undefined) { if (dataSource[0] && !dataSource[0].$.isEmpty && typeof dataSource[0].$.id === 'number') { data[idMember] = Math.floor(Math.random() * (1000000 - dataSource.length)) + dataSource.length; } else { data[idMember] = Math.random().toString(36).substring(7); } } } if (scrolling === 'physical' || scrolling === 'deferred') { refresh(); return; } // 'virtual'/'infinite' scroll modes function commit(result) { if (result) { refresh(); } } if (that.onRecordInserted) { that.onRecordInserted(idMember ? data[idMember] : recordId, data, position, commit); } } /** * Begins an edit operation. * * @param {Number/String} recordId The id of the record to edit. */ beginEdit(recordId) { const that = this; if (!that.editable || that.disabled) { return; } const record = that._visibleSource.find(record => record.$.id === recordId); if (!record) { return; } const card = that.ensureVisible(recordId); if (that.scrolling !== 'virtual') { that._openEditDialog(card.dataId); } else { that._beginEditOnLoad = recordId; } } /** * Ends the current edit operation and discards changes. */ cancelEdit() { const that = this, editInfo = that._editInfo; if (!editInfo || !editInfo.window.opened) { return; } editInfo.window.close(); } /** * Ends the current edit operation and saves changes. */ endEdit() { const that = this, editInfo = that._editInfo; if (!editInfo || !editInfo.window.opened) { return; } editInfo.ok = true; editInfo.window.close(); } /** * Makes sure a record is visible by scrolling to it. * * @param {Number/String} recordId The id of the record to scroll to. */ ensureVisible(recordId) { const that = this, dataSource = that._visibleSource, record = dataSource.find(record => record.$.id === recordId); if (!record) { return; } const index = dataSource.indexOf(record), cardsPerRow = that._cardsPerRow, fullCardHeight = that._cardHeight + that._gap, verticalScrollBar = that.$.scrollViewer.$.verticalScrollBar, rowOfIndex = Math.floor(index / cardsPerRow), rowStart = Math.max(0, rowOfIndex * cardsPerRow); let scrollValue = 0, cardsWithDataId, cardMatch; if (that._numberOfCollapsedRows > 0) { const numberOfAllRows = Math.floor((dataSource.length - 1) / cardsPerRow) + 1; for (let i = 0; i < numberOfAllRows; i++) { const currentRowIndex = i; if (currentRowIndex === rowOfIndex) { break; } if (that._collapsedRows[currentRowIndex]) { scrollValue += fullCardHeight - that._cardContentHeight; } else { scrollValue += fullCardHeight; } } } else { scrollValue = Math.floor(rowStart / cardsPerRow) * fullCardHeight; } scrollValue = Math.min(scrollValue, verticalScrollBar.max); if (Math.abs(verticalScrollBar.value - scrollValue) < that.$.scrollViewer.$.scrollViewerContainer.offsetHeight / 50) { cardsWithDataId = that._cards.filter(card => card.dataId === index && !card.classList.contains('lw-hidden')); cardMatch = cardsWithDataId[cardsWithDataId.length - 1]; return cardMatch; } verticalScrollBar.value = scrollValue; that._onVerticalChange({ detail: { value: scrollValue } }); cardsWithDataId = that._cards.filter(card => card.dataId === index && !card.classList.contains('lw-hidden')); cardMatch = cardsWithDataId[cardsWithDataId.length - 1]; return cardMatch; } /** * Hides a column. * @param {String} dataField The data field of the column. */ hideColumn(dataField) { this._toggleColumn(dataField, false); } /** * Opens the "Customize cards" header panel (drop down). */ openCustomizePanel() { const that = this, dataSource = that.dataSource; if (!dataSource || dataSource.length === 0 || that.disabled || that.headerPosition === 'none') { return; } const customizePart = that.$.customize, columnPanelDataSource = that.columns.map(col => { const newColumn = Object.assign({}, col); if ([that.coverField, that.titleField].indexOf(newColumn.dataField) !== -1) { newColumn.disableToggle = true; } else { newColumn.disableToggle = false; } return newColumn; }), inputSource = [that.localize('noCoverField')].concat(that.columns.filter(col => col.image)); let switchButton, input, columnPanel; that._closeDialog(); that.$.headerDropDown.classList.add('customize-panel'); that.$.headerDropDown.classList.remove('filter-panel', 'sort-panel', 'search-panel'); customizePart.classList.remove('lw-hidden'); that.$.filter.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); that.$.search.classList.add('lw-hidden'); that._closeSearchPanel(); if (!that._customizePartCreated) { const fragment = document.createDocumentFragment(), container = document.createElement('div'), innerContainer = document.createElement('div'), label = document.createElement('div'); switchButton = document.createElement('lw-switch-button'); input = document.createElement('lw-input'); columnPanel = document.createElement('lw-column-panel'); label.id = that.id + 'CoverFieldLabel'; label.innerHTML = that.localize('coverField'); switchButton.rightToLeft = that.rightToLeft; switchButton.setAttribute('crop', that.localize('crop')); switchButton.setAttribute('fit', that.localize('fit')); switchButton.setAttribute('aria-labelledby', label.id); switchButton.inverted = true; switchButton.animation = that.animation; switchButton.theme = that.theme; input.dataSource = inputSource; input.dropDownButtonPosition = 'right'; input.rightToLeft = that.rightToLeft; input.readonly = true; input.animation = that.animation; input.theme = that.theme; columnPanel.rightToLeft = that.rightToLeft; columnPanel.animation = that.animation; columnPanel.dataSource = columnPanelDataSource; columnPanel.locale = that.locale; columnPanel.messages = that._innerElementMessages.columnPanel; columnPanel.theme = that.theme; innerContainer.appendChild(label); innerContainer.appendChild(switchButton); container.classList.add('lw-card-view-customize-top'); container.appendChild(innerContainer); container.appendChild(input); fragment.appendChild(container); fragment.appendChild(columnPanel); that.$.customize.appendChild(fragment); that._customizePartCreated = true; } else { switchButton = customizePart.getElementsByTagName('lw-switch-button')[0]; switchButton.rightToLeft = that.rightToLeft; input = customizePart.getElementsByTagName('lw-input')[0]; input.dataSource = inputSource; input.rightToLeft = that.rightToLeft; delete input.$.input.dataValue; columnPanel = customizePart.children[1]; columnPanel.set('dataSource', columnPanelDataSource); columnPanel.propertyChangedHandler('dataSource', undefined, columnPanelDataSource); columnPanel.rightToLeft = that.rightToLeft; } switchButton.checked = that.coverMode === 'fit'; input.value = that.coverField ? that.columns.find(col => col.dataField === that.coverField).label : that.localize('noCoverField'); that._changedVisibility = new Map(); that._openHeaderDropDown(that.$.customizeButton); } /** * Opens the "Filter" header panel (drop down). */ openFilterPanel() { const that = this, dataSource = that.dataSource, filterPanelDataSource = this.columns.map(col => { const field = Object.assign({}, col); field.dataType = dataSource.dataFields.find(dataField => dataField.name === field.dataField).dataType; return field; }); super.openFilterPanel(filterPanelDataSource, null); } /** * Opens the "Sort" header panel (drop down). */ openSortPanel() { const that = this, dataSource = that.dataSource, sortPanelDataSource = that.columns.map(col => { const newColumn = Object.assign({}, col), preSortedIndex = that._appliedSorting.dataFields.indexOf(newColumn.dataField); newColumn.dataType = dataSource.dataFields.find(dataField => dataField.name === newColumn.dataField).dataType; newColumn.sortIndex = preSortedIndex; if (preSortedIndex !== -1) { newColumn.sortDirection = that._appliedSorting.orderBy[preSortedIndex]; } return newColumn; }); super.openSortPanel(sortPanelDataSource); } /** * Removes a record. * * @param {Number/String} recordId The id of the record to remove. */ removeRecord(recordId) { const that = this, scrolling = that.scrolling; function refresh() { const dataSource = that.dataSource, record = dataSource.find(record => record.$.id === recordId); if (!record) { return; } const indexInSource = dataSource.indexOf(record), indexInVisibleSource = that._visibleSource.indexOf(record); dataSource.removeAt(indexInSource); if (dataSource !== that._visibleSource) { if (indexInVisibleSource === -1) { return; } that._visibleSource.splice(indexInVisibleSource, 1); } that._closeSearchPanel(); that._fullRefresh(); } if (scrolling === 'physical' || scrolling === 'deferred') { refresh(); return; } // 'virtual'/'infinite' scroll modes function commit(result) { if (result) { refresh(); } } if (that.onRecordRemoved) { that.onRecordRemoved(recordId, commit); } } /** * Shows a column. * * @param {String} dataField The data field of the column. */ showColumn(dataField) { this._toggleColumn(dataField, true); } /** * Updates the CardView when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'allowDrag': case 'coverMode': case 'onRecordInserted': case 'onRecordRemoved': break; case 'addNewButton': if (newValue && that.dataSource.dataFields.length === 0) { that.addNewButton = false; } break; case 'animation': case 'theme': that._cards.forEach(card => { const carousel = card.getElementsByTagName('lw-carousel'); if (carousel) { carousel[propertyName] = newValue; } }); if (that._editInfo) { that._editInfo.window[propertyName] = newValue; for (let dataField in that._editInfo.editors) { that._editInfo.editors[dataField].element[propertyName] = newValue; } } if (that._customizePartCreated) { that.$.customize.firstElementChild.firstElementChild.children[1][propertyName] = newValue; that.$.customize.firstElementChild.children[1][propertyName] = newValue; that.$.customize.children[1][propertyName] = newValue; } if (that._filterPartCreated) { that.$.filter.firstElementChild[propertyName] = newValue; } if (that._sortPartCreated) { that.$.sort.firstElementChild[propertyName] = newValue; } break; case 'disabled': that.closePanel(); if (that._editInfo) { that._editInfo.window.disabled = newValue; } break; case 'cardHeight': that._updateCardHeight(newValue); break; case 'cellOrientation': case 'collapsible': if (!that.dataSource || that.dataSource.length === 0) { return; } that._fullRefresh(); break; case 'columns': that._updateColumns(); break; case 'coverField': case 'titleField': { if (newValue !== null) { const validColumn = that.columns.find(column => column.dataField === newValue); if (!validColumn || propertyName === 'coverField' && !validColumn.image) { that[propertyName] = oldValue; return; } } that._createTemplate(); if (!that.dataSource || that.dataSource.length === 0) { return; } that._fullRefresh(); break; } case 'dataSource': that._close(); that._normalizeDataSource(); that._getVisibleRecords(); that._clearFilterAndSortUI(); that._normalizeColumns(); that._createTemplate(); that._fullRefresh(false); break; case 'editable': if (!newValue) { that._closeDialog(); } break; case 'headerPosition': that._handleHeaderPosition(that.$.scrollViewer); if ((newValue === 'none' || oldValue === 'none') && that.dataSource && that.dataSource.length > 0) { that._partialRefresh(); } break; case 'locale': case 'messages': that.closePanel(); that._localizeHeader(); that._getInnerElementMessages(); if (that._editInfo) { const window = that._editInfo.window; window.$.buttonsContainer.firstElementChild.title = that.localize('previousRecord'); window.$.buttonsContainer.children[1].title = that.localize('nextRecord'); window.$.footer.firstElementChild.innerHTML = that.localize('ok'); window.$.footer.children[1].innerHTML = that.localize('cancel'); Array.from(window.getElementsByClassName('toggle-visibility')).forEach(element => element.title = that.localize('toggleVisibility')); Array.from(window.querySelectorAll('.lw-card-view-editor.image')).forEach(element => { Array.from(element.firstElementChild.children).forEach(thumbnail => thumbnail.title = that.localize('removeImage')); element.children[1].innerHTML = that.localize('imageUrl'); element.children[2].children[1].title = that.localize('addImage'); }); Array.from(window.getElementsByTagName('lw-date-time-picker')).forEach(element => { element.messages = that._innerElementMessages.dateTimePicker; element.locale = that.locale; }); } if (that._customizePartCreated) { const switchButton = that.$.customize.getElementsByTagName('lw-switch-button')[0]; that.$.customize.firstElementChild.firstElementChild.firstElementChild.innerHTML = that.localize('coverField'); that.$.customize.children[1].messages = that._innerElementMessages.columnPanel; that.$.customize.children[1].locale = that.locale; switchButton.setAttribute('crop', that.localize('crop')); switchButton.setAttribute('fit', that.localize('fit')); } if (that._filterPartCreated) { that.$.filter.firstElementChild.messages = that._innerElementMessages.multiColumnFilterPanel; that.$.filter.firstElementChild.locale = that.locale; that.$.filter.firstElementChild.editorPlaceholder = that.localize('filterValuePlaceholder'); } if (that._sortPartCreated) { that.$.sort.firstElementChild.messages = that._innerElementMessages.sortPanel; that.$.sort.firstElementChild.locale = that.locale; } break; case 'rightToLeft': if (that._editInfo && !that._editInfo.updateWindowContent) { that._editInfo.window.rightToLeft = newValue; that.columns.forEach(function (column) { const editorInfo = that._editInfo.editors[column.dataField], element = editorInfo.element; if (editorInfo.type === 'date') { element.calendarButtonPosition = newValue ? 'left' : 'right'; } else if (editorInfo.type === 'number') { if (newValue) { element.spinButtonsPosition = 'left'; element.radixDisplayPosition = 'right'; } else { element.spinButtonsPosition = 'right'; element.radixDisplayPosition = 'left'; } } else if (editorInfo.type === 'string' && element instanceof HTMLTextAreaElement) { that.rightToLeft ? element.setAttribute('right-to-left', '') : element.removeAttribute('right-to-left'); } element.rightToLeft = that.rightToLeft; }); } that.closePanel(); break case 'scrolling': { const virtualModes = ['virtual', 'infinite']; if (virtualModes.indexOf(newValue) !== -1 || virtualModes.indexOf(oldValue) !== -1) { // cannot switch from/to 'virtual' or 'infinite' "scrolling", because "dataSource" has been set up for a particular mode that.scrolling = oldValue; return; } that.$.scrollViewer.$.verticalScrollBar.mechanicalAction = newValue === 'deferred' ? 'switchWhenReleased' : 'switchWhileDragging'; break; } } } /** * Updates the columns property. */ _updateColumns() { const that = this; that._normalizeColumns(); that._createTemplate(); that._fullRefresh(); } /** * "Add new" button (+) click handler. */ _addNewButtonClickHandler() { this._openEditDialog(); } /** * click handler. */ _clickHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; if (that.$.header.contains(target)) { that._headerClickHandler(target, that.$.cardContainer); return; } const card = target.closest('lw-card'); if (!card || target.classList.contains('lw-indicator') || that._dragDetails && that._dragDetails.feedbackShown) { return; } if (that._dragDetails) { delete that._dragDetails; that.$.scrollViewer._scrollView.disableSwipeScroll = false; } if (!target.classList.contains('lw-arrow-up')) { if (that.editable && !that._clickToDrag) { that._openEditDialog(card.dataId); } return; } const dataContainer = card.getElementsByClassName('lw-card-view-content')[0], recordId = that._visibleSource[card.dataId].$.id; dataContainer.removeEventListener('transitionend', that._transitionendHandlerExpand); dataContainer.removeEventListener('transitionend', that._transitionendHandlerCollapse); if (that._collapsed[recordId]) { delete that._collapsed[recordId]; that._getNumberOfCollapsedRows(); if (that.hasAnimation) { that._expandDataContainer(dataContainer); } else { card.classList.remove('collapsed'); target.classList.remove('collapsed'); dataContainer.classList.remove('lw-visibility-hidden'); that._partialRefresh(); } window.getSelection().removeAllRanges(); } else { that._collapsed[recordId] = true; that._getNumberOfCollapsedRows(); card.classList.add('collapsed'); target.classList.add('collapsed'); if (that.hasAnimation) { that._collapseDataContainer(dataContainer); } else { dataContainer.classList.add('lw-visibility-hidden'); that._partialRefresh(); } } } /** * Edit dialog click handler. */ _windowClickHandler(event) { const window = this, that = window.ownerElement, target = event.target.shadowRoot ? event.composedPath()[0] : event.target; if (target.closest('.ok')) { that._editInfo.ok = true; window.close(); } else if (target.closest('.cancel')) { window.close(); } else if (target.closest('.add')) { const container = target.closest('.container'), input = container.firstElementChild; if (input.value.trim() !== '') { const newImage = document.createElement('div'); newImage.className = 'thumbnail'; newImage.style.backgroundImage = `url("${input.value}")`; newImage.title = that.localize('removeImage'); container.parentElement.firstElementChild.appendChild(newImage); input.value = ''; } } else if (target.classList.contains('thumbnail')) { target.parentElement.removeChild(target); } else if (target.classList.contains('toggle-visibility')) { const column = that.columns.find(col => target.parentElement.getAttribute('data-field') === col.dataField); target.classList.toggle('hidden'); that._changedVisibility.set(column, !target.classList.contains('hidden')); } } /** * Expands a card's data container. */ _expandDataContainer(dataContainer) { const that = this, oldHeight = dataContainer.style.height, containerHeight = (that._cardContentHeight - that._verticalOffset) + 'px'; dataContainer.style.height = containerHeight; dataContainer.classList.remove('lw-visibility-hidden'); dataContainer.previousElementSibling.children[1].classList.remove('collapsed'); if (oldHeight === containerHeight || !parseFloat(oldHeight) && !parseFloat(containerHeight)) { that._transitionendHandlerExpand(that, dataContainer); return; } dataContainer.addEventListener('transitionend', that._transitionendHandlerExpand); } /** * Expand animation transitionend handler. */ _transitionendHandlerExpand() { let cardView, container; if (arguments.length === 1) { container = this; cardView = cardView = container.closest('lw-card-view') || (container.getRootNode() && container.getRootNode().host ? container.getRootNode().host.closest('lw-card-view') : undefined); } else { cardView = arguments[0]; container = arguments[1]; } container.removeEventListener('transitionend', cardView._transitionendHandlerExpand); container.style.height = null; container.parentElement.parentElement.parentElement.classList.remove('collapsed'); cardView._partialRefresh(); } /** * Collapses a card's data container. */ _collapseDataContainer(dataContainer) { const that = this, containerHeight = (that._cardContentHeight - that._verticalOffset) + 'px'; dataContainer.style.transition = 'none'; requestAnimationFrame(function () { dataContainer.style.height = containerHeight; dataContainer.style.transition = null; requestAnimationFrame(function () { dataContainer.style.height = '0px'; dataContainer.classList.add('lw-visibility-hidden'); if (containerHeight === '0px') { that._transitionendHandlerCollapse(that, dataContainer); } }); }); dataContainer.addEventListener('transitionend', that._transitionendHandlerCollapse); } /** * Collapse animation transitionend handler. */ _transitionendHandlerCollapse() { let cardView, container; if (arguments.length === 1) { container = this; cardView = container.closest('lw-card-view') || (container.getRootNode() && container.getRootNode().host ? container.getRootNode().host.closest('lw-card-view') : undefined); } else { cardView = arguments[0]; container = arguments[1]; } container.removeEventListener('transitionend', cardView._transitionendHandlerCollapse); container.style.height = null; cardView._partialRefresh(); } /** * Gets the number of collapsed rows. */ _getNumberOfCollapsedRows() { const that = this, dataSource = that._visibleSource, cardsPerRow = that._cardsPerRow, processedRows = [], collapsedRows = {}; let number = 0; for (let recordId in that._collapsed) { const recordIndex = dataSource.findIndex ? dataSource.findIndex(record => record.$.id.toString() === recordId) : dataSource.boundSource.findIndex(record => record.$.id.toString() === recordId), row = Math.floor(recordIndex / cardsPerRow); if (processedRows.indexOf(row) !== -1) { continue; } const firstIndex = Math.max(0, row * cardsPerRow); let rowCollapsed = true; processedRows.push(row); for (let i = 0; i < cardsPerRow; i++) { const currentRecord = dataSource[i + firstIndex]; if (!currentRecord) { break; } if (!that._collapsed[currentRecord.$.id]) { rowCollapsed = false; break; } } if (rowCollapsed) { collapsedRows[row] = true; number++; } } that._collapsedRows = collapsedRows; that._numberOfCollapsedRows = number; } /** * Opens edit dialog. */ _openEditDialog(dataId) { const that = this, dataSource = that._visibleSource, record = dataSource[dataId], openingEvent = that.$.fireEvent('opening', { record: record }); if (openingEvent.defaultPrevented) { return; } that.$.container.setAttribute('modal', ''); that.closePanel(); that._changedVisibility = new Map(); if (that._editInfo && !that._editInfo.updateWindowContent) { that._updateEditedView(dataId, true); return; } const structureFragment = document.createDocumentFragment(), editors = {}; that.columns.forEach(function (column) { const dataField = column.dataField, value = record ? record[dataField] : '', label = document.createElement('div'); let editor; label.className = `lw-card-view-label${column.icon ? ' icon ' + column.icon : ''}`; label.setAttribute('data-field', dataField); label.innerHTML = `${column.label}<span class="toggle-visibility${column.visible === false ? ' hidden' : ''}${ (dataField === that.coverField || dataField === that.titleField) ? ' lw-hidden' : ''}" title="${that.localize('toggleVisibility')}" role="button" aria-label="Toggle field visibility"></span>`; structureFragment.appendChild(label); if (column.image) { editor = document.createElement('div'); editor.className = 'lw-card-view-editor image'; editor.setAttribute('aria-label', column.label); editor.innerHTML = `<div>${that._updateImgThumbNails(value)}</div> <div class="label">${that.localize('imageUrl')}</div> <div class="container" role="presentation"> <lw-input aria-label="New image URL"></lw-input> <lw-button class="add" title="${that.localize('addImage')}" aria-label="Add image">+</lw-button> </div>`; structureFragment.appendChild(editor); editors[dataField] = { element: editor, type: 'image' }; return; } const type = that.dataSource.dataFields.find(dataField => dataField.name === column.dataField).dataType; if (type === 'date') { editor = document.createElement('lw-date-time-picker'); editor.calendarButton = true; editor.calendarButtonPosition = that.rightToLeft ? 'left' : 'right'; editor.dropDownAppendTo = 'body'; editor.dropDownDisplayMode = 'auto'; editor.dropDownPosition = 'bottom'; editor.locale = that.locale; editor.messages = that._innerElementMessages.dateTimePicker; editor.nullable = true; editor.value = value || null; if (column.formatSettings && column.formatSettings.formatString) { editor.formatString = column.formatSettings.formatString; } } else if (type === 'number') { editor = document.createElement('lw-numeric-text-box'); editor.inputFormat = 'floatingPoint'; editor.spinButtons = true; editor.nullable = true; if (that.rightToLeft) { editor.spinButtonsPosition = 'left'; editor.radixDisplayPosition = 'right'; } editor.value = value !== undefined && value !== null ? value : null; if (column.formatSettings && column.formatSettings.formatString) { editor.outputFormatString = column.formatSettings.formatString; } } else if (type === 'boolean') { editor = document.createElement('lw-check-box'); editor.checked = value || false; } else { if (typeof value === 'string' && value.length > 50) { editor = document.createElement('textarea'); if (that.rightToLeft) { editor.setAttribute('right-to-left', ''); } } else { editor = document.createElement('lw-input'); } editor.value = value !== undefined && value !== null ? value.toString() : ''; } editor.className = 'lw-card-view-editor'; editor.setAttribute('aria-label', column.label); editor.animation = that.animation; editor.theme = that.theme; editor.rightToLeft = that.rightToLeft; structureFragment.appendChild(editor); editors[dataField] = { element: editor, type: type }; }); if (that._editInfo && that._editInfo.updateWindowContent) { that._editInfo.window.clear(); that._editInfo.window.appendChild(structureFragment); that._openWindow(); that._editInfo.dataId = dataId; that._editInfo.editors = editors; delete that._editInfo.updateWindowContent; return; } const window = document.createElement('lw-window'), footerTemplate = document.createElement('template'); footerTemplate.innerHTML = `<lw-button class="ok primary">${that.localize('ok')}</lw-button> <lw-button class="cancel">${that.localize('cancel')}</lw-button>`; window.classList.add('lw-card-view-window', 'lw-visibility-hidden'); window.footerTemplate = footerTemplate; window.headerButtons = ['close', 'next', 'prev']; window.label = record ? record[that.titleField] : ''; window.animation = that.animation; window.rightToLeft = that.rightToLeft; window.theme = that.theme; window.ownerElement = that; window.appendChild(structureFragment); document.body.appendChild(window); that._editInfo = { dataId: dataId, editors: editors, window: window }; that._addWindowHandlers(); window.whenRendered(() => { that.setAttribute('aria-owns', window.id); window.$.buttonsContainer.firstElementChild.title = that.localize('previousRecord'); window.$.buttonsContainer.children[1].title = that.localize('nextRecord'); that._openWindow(); }); } /** * Opens the instance of lwWindow. */ _openWindow() { const lwWindow = this._editInfo.window, clientWidth = document.documentElement.clientWidth, clientHeight = document.documentElement.clientHeight, pageXOffset = window.pageXOffset, pageYOffset = window.pageYOffset; lwWindow.style.top = ((clientHeight - lwWindow.offsetHeight) / 2 + pageYOffset) + 'px'; lwWindow.style.left = ((clientWidth - lwWindow.offsetWidth) / 2 + pageXOffset) + 'px'; lwWindow.open(); } /** * Adds window handlers. */ _addWindowHandlers() { const that = this, window = that._editInfo.window; window.addEventListener('open', that._windowEventHandler); window.addEventListener('closing', that._windowEventHandler); window.addEventListener('close', that._windowEventHandler); window.addEventListener('click', that._windowClickHandler); window.addEventListener('prev', that._prevNextHandler); window.addEventListener('next', that._prevNextHandler); } /** * Edit dialog event handler. */ _windowEventHandler(event) { const that = this.ownerElement, type = event.type, oldContext = that.context; if (event.target !== this) { // event is triggered from an editor return; } that.context = that; if (type === 'open') { that.$.fireEvent('open'); } else if (type === 'closing') { const customEvent = that.$.fireEvent('closing'); if (customEvent.defaultPrevented) { event.preventDefault(); } } else if (type === 'close') { that.$.fireEvent('close'); that._windowCloseHandler(event); } that.context = oldContext; } /** * Updates edited view. */ _updateEditedView(dataId, toOpen) { const that = this, record = that._visibleSource[dataId]; if (record && record.$.isEmpty) { return; } that._editInfo.dataId = dataId; that.columns.forEach(function (column) { const dataField = column.dataField, value = record ? record[dataField] : '', editorInfo = that._editInfo.editors[dataField]; if (editorInfo.type === 'image') { editorInfo.element.firstElementChild.innerHTML = that._updateImgThumbNails(value); } else if (editorInfo.type === 'boolean') { editorInfo.element.checked = value || false; } else if (editorInfo.type === 'date') { editorInfo.element.value = value || null; } else if (editorInfo.type === 'number') { editorInfo.element.value = value !== undefined && value !== null ? value : null; } else { if (editorInfo.element instanceof HTMLTextAreaElement) { that.rightToLeft ? editorInfo.element.setAttribute('right-to-left', '') : editorInfo.element.removeAttribute('right-to-left'); } editorInfo.element.value = value !== undefined && value !== null ? value.toString() : ''; } editorInfo.element.rightToLeft = that.rightToLeft; }); that._editInfo.window.label = record ? record[that.titleField] : ''; if (toOpen) { that._openWindow(); } } /** * Updates image thumbnails in editor. */ _updateImgThumbNails(value) { if (value.trim() === '') { return ''; } const urlList = value.split(',').map(url => url.trim()); let htmlResult = ''; urlList.forEach(url => htmlResult += `<div class="thumbnail" style="background-image: url('${url}');" title="${this.localize('removeImage')}" role="img"></div>`); return htmlResult; } /** * move event handler. */ _moveHandler(event) { if (event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * "prev"/"next" button click handler. */ _prevNextHandler(event) { const that = this.ownerElement, oldContext = that.context, dataId = that._editInfo.dataId, nextDataId = event.type === 'prev' ? dataId - 1 : dataId + 1; if (that._visibleSource[nextDataId] && !that._visibleSource[nextDataId].$.isEmpty) { that.context = that; that._saveChanges(); that._updateEditedView(nextDataId); that.context = oldContext; } } /** * Saves changes. */ _saveChanges() { const that = this, dataId = that._editInfo.dataId; let record, card; if (dataId !== undefined) { // saving changes to existing record const cardsWithDataId = that._cards.filter(card => card.dataId === dataId); record = that._visibleSource[dataId]; card = cardsWithDataId[cardsWithDataId.length - 1]; } else { // adding a new record record = {}; } that.columns.forEach(function (column) { const dataField = column.dataField, editorInfo = that._editInfo.editors[dataField], element = editorInfo.element; if (editorInfo.type === 'image') { const newUrls = []; Array.from(editorInfo.element.getElementsByClassName('thumbnail')).forEach(thumbnail => { newUrls.push(thumbnail.style.backgroundImage.replace(/url\(["'](.+)["']\)/g, '$1')); }); record[dataField] = newUrls.join(','); if (card && dataField === that.coverField) { card.firstElementChild.firstElementChild.dataSource = newUrls; return; } } else if (editorInfo.type === 'boolean') { record[dataField] = element.checked; } else if (editorInfo.type === 'date') { record[dataField] = element.value ? element.value.toDate() : null; } else { record[dataField] = element.value; } if (card) { if (dataField === that.titleField) { card.getElementsByClassName('lw-card-view-title')[0].firstElementChild.innerHTML = that._formatValue(record[dataField], record, column); } else if (column.visible) { const field = card.querySelector(`[data-field="${dataField}"] > .lw-card-view-value`); if (field) { field.innerHTML = that._formatValue(record[dataField], record, column); } } } }); if (dataId === undefined) { that.addRecord(null, record); } } /** * Closes header panel (drop down) and edit dialog. */ _close() { const that = this; that.closePanel(); that._closeDialog(); } /** * Closes the edit dialog. */ _closeDialog() { const that = this; if (that._editInfo) { that._editInfo.window.close(); } } /** * resize handler. */ _resizeHandler() { const that = this; if (that._suppressResizeHandler || that.hasAttribute('empty') || that.hasAttribute('no-matches')) { return; } clearTimeout(that._resizeTimeout); that.$.loadingIndicatorContainer.classList.remove('lw-hidden'); that._resizeTimeout = setTimeout(function () { that.$.loadingIndicatorContainer.classList.add('lw-hidden'); if (that._cards.length === that._visibleSource.length) { // no virtual items // horizontal resize if (that.offsetWidth !== that._cachedWidth) { const oldCardsPerRow = that._cardsPerRow; that._getCardsPerRow(); if (oldCardsPerRow !== that._cardsPerRow) { that._getNumberOfCollapsedRows(); } that._cachedWidth = that.offsetWidth; } else { that._cachedHeight = that.offsetHeight; } if (that._cards.length > 0) { if (that._autoCardHeight) { that._updateCardHeight(null); } that.$.scrollViewer.refresh(); } return; } // vertical resize if (that.offsetHeight !== that._cachedHeight) { that._cachedHeight = that.offsetHeight; if (Math.abs(that._refreshedAtDimensions.height - that._cachedHeight) >= 20) { that._dataSourceProcessed = true; that._partialRefresh(); delete that._dataSourceProcessed; } else { that.$.scrollViewer.$.verticalScrollBar.max = Math.max(0, that._scrollHeight - that.$.scrollViewer.$.scrollViewerContainer.offsetHeight - that._numberOfCollapsedRows * that._cardContentHeight); } } // horizontal resize if (that.offsetWidth !== that._cachedWidth) { const oldCardsPerRow = that._cardsPerRow; that._cachedWidth = that.offsetWidth; that._getCardsPerRow(); if (oldCardsPerRow !== that._cardsPerRow) { that._dataSourceProcessed = true; that._partialRefresh(); delete that._dataSourceProcessed; } } }, 75); } /** * Edit window close handler. */ _windowCloseHandler() { const that = this; that.$.container.removeAttribute('modal'); if (that._editInfo.ok) { // OK that._updateColumnsVisibility(function () { that._saveChanges(); }); delete that._editInfo.ok; return; } // Cancel that._changedVisibility.forEach(function (visible, column) { if (column.visible !== visible) { that._editInfo.window.querySelector(`[data-field="${column.dataField}"]`). firstElementChild.classList.toggle('hidden'); } }); } /** * Updates the visibility of columns. */ _updateColumnsVisibility(callback, skipValidation) { const that = this; let updateHeight = false; that._changedVisibility.forEach(function (visible, column) { if (skipValidation !== true && column.visible === visible) { return; } const dataField = column.dataField; column.visible = visible; if (visible) { that._cardContent = that._cardContent.replace(`class="lw-card-view-cell lw-hidden" data-field="${dataField}"`, `class="lw-card-view-cell" data-field="${dataField}"`); if (!callback && that._editInfo) { that._editInfo.window.querySelector(`[data-field="${dataField}"]`).firstElementChild.classList.remove('hidden'); } } else { that._cardContent = that._cardContent.replace(`class="lw-card-view-cell" data-field="${dataField}"`, `class="lw-card-view-cell lw-hidden" data-field="${dataField}"`); if (!callback && that._editInfo) { that._editInfo.window.querySelector(`[data-field="${dataField}"]`).firstElementChild.classList.add('hidden'); } } that._cards.forEach(card => { const cell = card.querySelector(`[data-field="${dataField}"]`); cell.classList.toggle('lw-hidden'); if (visible) { const record = that._visibleSource[card.dataId]; cell.children[1].innerHTML = that._formatValue(record[dataField], record, column); } }); updateHeight = true; }); if (callback) { callback(); } if (that._autoCardHeight && updateHeight) { that._updateCardHeight(null); } } /** * Header panels apply handler. */ _applyHandler(event) { const that = this, target = event.target, detail = event.detail, customize = that.$.customize, columns = that.columns; if (customize.contains(target)) { const switchButton = customize.getElementsByTagName('lw-switch-button')[0], input = customize.getElementsByTagName('lw-input')[0], newCoverMode = switchButton.checked ? 'fit' : 'crop'; let newCoverField = columns.find(col => col.label === input.value) || null, differentCoverField = false; if (newCoverMode !== that.coverMode) { that.coverMode = newCoverMode; } if (newCoverField) { newCoverField = newCoverField.dataField; } if (newCoverField !== that.coverField) { that.coverField = newCoverField; differentCoverField = true; } if (differentCoverField || detail.positionChanged) { if (detail.positionChanged) { that.columns = detail.value; } that._createTemplate(); that._fullRefresh(); if (detail.positionChanged && that._editInfo) { that._editInfo.updateWindowContent = true; } } else { detail.value.forEach(col => { const cardViewColumn = columns.find(column => column.dataField === col.dataField); if (cardViewColumn.visible !== col.visible) { that._changedVisibility.set(cardViewColumn, col.visible); } }); that._updateColumnsVisibility(); } } else if (that.$.filter.contains(target)) { that.addFilter(detail.filters, detail.operator, detail.value); } else if (that.$.sort.contains(target)) { that.addSort(detail.sortByInfo); } that.closePanel(); } /** * Makes a full refresh of the view. */ _fullRefresh(preserveScrolling = true) { const that = this, cardContainer = that.$.cardContainer; let fraction; if (preserveScrolling) { fraction = that._getFractionOfMax(); } that._suppressResizeHandler = true; while (cardContainer.firstChild) { cardContainer.removeChild(cardContainer.firstChild); } that._cards = []; that._createCards(); if (that._visibleSource.length === 0) { that.$.scrollViewer.refresh(); } that._setFractionOfMax(fraction); } /** * Normalizes the representation of the data source. */ _normalizeDataSource() { const that = this; let dataSource = that.dataSource; function getDataFieldsFromColumns() { if (that.columns.length === 0) { that.addNewButton = false; return []; } const dataFields = []; that.columns.forEach(column => { try { dataFields.push({ name: column.dataField || column.label || column, dataType: 'string' }); } catch (error) { return; } }); return dataFields; } if (dataSource instanceof LW.DataAdapter) { if (dataSource.dataFields.length === 0) { dataSource.dataFields = getDataFieldsFromColumns(); } return; } if (!dataSource) { dataSource = []; } else if (!Array.isArray(dataSource)) { if (typeof dataSource === 'object' && Object.keys(dataSource).length > 0) { dataSource = [dataSource]; } else { that.error(that.localize('incorrectStructure')); return; } } let dataFields = []; if (dataSource.length === 0) { dataFields = getDataFieldsFromColumns(); } else { let i = 0, record = dataSource[i], keys = Object.keys(record); while (record && keys.length === 0) { i++; record = dataSource[i]; keys = Object.keys(record); } if (keys.length === 0) { dataFields = getDataFieldsFromColumns(); } else { keys.forEach(key => { const value = record[key]; let type; if (value.constructor === Date) { type = 'date'; } else if (typeof value === 'boolean') { type = 'boolean'; } else if (!isNaN(value) && value !== null && value !== '') { type = 'number'; } else { type = 'string'; } dataFields.push(`${key}: ${type}`); }); } } that.dataSource = new LW.DataAdapter({ dataSource: dataSource, dataFields: dataFields }); } /** * Normalizes the representation of the columns. */ _normalizeColumns() { const that = this, columns = that.columns, dataFields = that.dataSource.dataFields, validColumns = []; if (!Array.isArray(columns) && !(columns instanceof LW.ObservableArray)) { return; } columns.forEach(column => { let columnDataField, formatFunction, formatSettings, icon, image, label, template, visible; if (typeof column === 'object') { columnDataField = column.dataField; formatFunction = column.formatFunction; formatSettings = column.formatSettings; icon = column.icon; image = column.image || false; label = column.label || columnDataField; template = column.template; visible = columnDataField !== that.titleField && columnDataField !== that.coverField ? (column.visible !== undefined ? column.visible : true) : true; } else if (typeof column === 'string') { columnDataField = column; image = false; label = columnDataField; visible = true; } if (dataFields.find(dataField => dataField.name === columnDataField)) { validColumns.push({ dataField: columnDataField, formatFunction: formatFunction, formatSettings: formatSettings, icon: icon, image: image, label: label, template: template, visible: visible }); } }); if (validColumns.length === 0) { dataFields.forEach(dataField => { validColumns.push({ dataField: dataField.name, image: false, label: dataField.name, visible: true }); }); } if (!validColumns.find(col => col.dataField === that.titleField)) { that.titleField = null; } if (!validColumns.find(col => col.dataField === that.coverField && col.image)) { that.coverField = null; } that.columns = new LW.ObservableArray(validColumns); that.columns.canNotify = true; that.columns.notify(function (changeArgs) { if (that.context !== that && changeArgs.newValue !== changeArgs.oldValue) { that._close(); if (changeArgs.action === 'update') { const column = changeArgs.target; switch (changeArgs.propertyName) { case 'dataField': that._updateColumns(); break; case 'formatFunction': case 'formatSettings': case 'template': that._createTemplate(); that._fullRefresh(); break; case 'icon': case 'label': if (column.dataField !== that.coverField && column.dataField !== that.titleField) { that._createTemplate(); that._fullRefresh(); } break; case 'image': if (!changeArgs.newValue && that.coverField === column.dataField) { that.coverField = null; that.propertyChangedHandler('coverField', column.dataField, null); } else { that._createTemplate(); that._fullRefresh(); } break; case 'visible': { const updatedColumnDataField = column.dataField; if (!changeArgs.newValue && (updatedColumnDataField === that.coverField || updatedColumnDataField === that.titleField)) { column.visible = true; return; } that._toggleColumn(updatedColumnDataField, changeArgs.newValue, true); break; } } } else { that._updateColumns(); } if (that._editInfo) { that._editInfo.updateWindowContent = true; } } }); if (that._editInfo) { that._editInfo.updateWindowContent = true; } } /** * Localizes labels in the header. */ _localizeHeader() { const that = this; super._localizeHeader(); that.$.cardContainer.setAttribute('no-data', that.localize('noData')); that.$.cardContainer.setAttribute('no-matches', that.localize('noMatches')); } /** * Opens search panel. */ _openSearchPanel() { const that = this; let source; that.$.headerDropDown.classList.add('search-panel'); that.$.headerDropDown.classList.remove('customize-panel', 'filter-panel', 'sort-panel'); that.$.search.classList.remove('lw-hidden'); that.$.customize.classList.add('lw-hidden'); that.$.filter.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); that._openHeaderDropDown(that.$.searchButton); if (Array.isArray(that._visibleSource)) { source = new LW.DataAdapter({ dataSource: that._visibleSource, dataFields: that.dataSource.dataFields, id: '_id' }); } else { const sortByInfo = that._appliedSorting; let id = that._visibleSource.id; if (id) { source = that._visibleSource; } else { id = 'id'; source = []; for (let i = 0; i < that._visibleSource.length; i++) { const currentRecord = that._visibleSource[i]; source.push(Object.assign({ id: currentRecord.$.id }, currentRecord)); } } source = new LW.DataAdapter({ dataSource: source, dataFields: that.dataSource.dataFields, id: id }); if (sortByInfo.dataFields.length > 0) { source.sortBy(sortByInfo.dataFields, sortByInfo.dataTypes, sortByInfo.orderBy); } } that._searchInfo = { source: source, stringDataFields: that.dataSource.dataFields.filter(dataField => { return dataField.dataType === 'string' && that.columns.find(column => column.dataField === dataField.name && !column.image); }).map(dataField => dataField.name) }; if (that.$.searchInput.value !== '') { that._search(that.$.searchInput.value, false); } } /** * Creates card template. */ _createTemplate() { const that = this, titleField = that.titleField; let content = ''; if (titleField) { content += `<div class="lw-card-view-title" data-field="${titleField}" role="heading" aria-level="1"><div>{{${titleField}}}</div><div class="lw-arrow-up" role="button" aria-label="Toggle card"></div></div>`; } else { content += '<div class="lw-card-view-title empty" role="heading" aria-level="1"><div>&nbsp;</div><div class="lw-arrow-up" role="button" aria-label="Toggle card"></div></div>'; } content += '<div class="lw-card-view-content" role="grid">'; that.columns.forEach(column => { const columnField = column.dataField; if (column.visible !== false) { column.visible = true; } if (columnField === titleField || columnField === that.coverField) { return; } content += `<div class="lw-card-view-cell${column.visible ? '' : ' lw-hidden'}" data-field="${columnField}" role="row"><div class="lw-card-view-label${column.icon ? ' icon ' + column.icon : ''}" role="rowheader">${column.label}</div> <div class="lw-card-view-value" role="gridcell">{{${columnField}}}</div></div>`; }); content += '</div>'; that._cardContent = content; } /** * Requests initial cards when "scrolling" is 'infinite'. */ _requestInitialCards() { const that = this; that.setAttribute('loading', ''); that.$.loadingIndicatorContainer.classList.remove('lw-hidden'); that.dataSource.onVirtualDataSourceRequested(function () { that._createCards(); that.removeAttribute('loading'); that.$.loadingIndicatorContainer.classList.add('lw-hidden'); }, { first: Infinity, last: Infinity, sorting: [], filtering: [], grouping: [], action: '' }); } /** * Creates cards and fills them with data. */ _createCards() { const that = this, dataSource = that._visibleSource; if (!dataSource || dataSource.length === 0) { return; } const scrolling = that.scrolling, virtual = scrolling === 'virtual', viewHeight = that.$.scrollViewer.$.scrollViewerContainer.offsetHeight; let dataSourceLength = dataSource.length, numberOfRealRows = 1, currentRowOffsetTop = 0, maxHeight = 0, cardsPerRow; that._ignoreVerticalChange = true; that.removeAttribute('empty'); if (virtual) { that.setAttribute('loading', ''); } for (let i = 0; i < dataSourceLength; i++) { const card = that._createCard(dataSource[i], i); that._cards.push(card); that.$.cardContainer.appendChild(card); that.$.scrollViewer.refresh(); if (that._autoCardHeight) { maxHeight = Math.max(card.offsetHeight, maxHeight); } if (card.offsetTop > currentRowOffsetTop) { numberOfRealRows++; currentRowOffsetTop = card.offsetTop; if (!cardsPerRow) { that._getCardsPerRow(); cardsPerRow = that._cardsPerRow; } } if (numberOfRealRows >= 3 && that._cards.length % cardsPerRow === 0 && that.$.cardContainer.offsetHeight > viewHeight + 2 * (that.cardHeight || maxHeight) && that._cards.length + 5 < dataSourceLength) { break; } } cardsPerRow = cardsPerRow || that._cards.length; if (scrolling === 'infinite') { while (that._cards.length % cardsPerRow !== 0) { that._createEmptyCard(); } } if (that._autoCardHeight) { that._cardHeight = maxHeight; that._cards.forEach(card => card.style.height = maxHeight + 'px'); } that._cardContentHeight = that._cards[0].getElementsByClassName('lw-card-view-content')[0].offsetHeight + that._verticalOffset; that._cards.forEach(card => that._toggleCard(card, card.firstElementChild.lastElementChild, that._visibleSource[card.dataId].$.id)); const numberOfVirtualRows = Math.ceil(dataSourceLength / cardsPerRow), scrollHeight = (that._cardHeight + that._gap) * numberOfVirtualRows - that._gap; that.$.scrollViewer.$.scrollViewerContentContainer.style.top = 0; that.$.scrollViewer.$.verticalScrollBar.max = Math.max(0, scrollHeight - viewHeight - that._numberOfCollapsedRows * that._cardContentHeight); that._cardsPerRow = cardsPerRow; that._scrollHeight = scrollHeight; that._refreshedAtDimensions = { width: that._cachedWidth, height: that._cachedHeight }; that._getNumberOfCollapsedRows(); delete that._ignoreVerticalChange; delete that._suppressResizeHandler; if (virtual) { that.$.loadingIndicatorContainer.classList.remove('lw-hidden'); that.dataSource.onVirtualDataSourceRequested( that._virtualDataSourceRequestedCallback.bind(that, 0, 0, true), { first: 0, last: that._cards.length, sorting: [], filtering: [], grouping: [], action: '' }); } } /** * "onVirtualDataSourceRequested" callback function. */ _virtualDataSourceRequestedCallback(startOfView, startOfData, initialization) { const that = this; that._ignoreVerticalChange = true; that.$.loadingIndicatorContainer.classList.add('lw-hidden'); that._updateVisibleCards(startOfView, startOfData, initialization); that.removeAttribute('loading'); delete that._ignoreVerticalChange; if (that._beginEditOnLoad) { const cardsWithDataId = that._cards.filter(card => card.dataId === that._beginEditOnLoad), cardMatch = cardsWithDataId[cardsWithDataId.length - 1]; if (cardMatch) { that._openEditDialog(cardMatch.dataId); } delete that._beginEditOnLoad; } } /** * Creates a card. */ _createCard(record = {}, dataId) { const that = this, coverField = that.coverField, visibleSource = that._visibleSource, card = document.createElement('lw-card'), cardDataContainer = document.createElement('div'); requestAnimationFrame(() => card.hasStyleObserver = false); card.setAttribute('aria-setsize', visibleSource.length); card.setAttribute('aria-posinset', dataId + 1); card.dataId = dataId; card.whenRendered(function () { card.setAttribute('role', 'listitem'); card.firstElementChild.onscroll = function () { const id = visibleSource[this.parentElement.dataId].$.id; that._cardScrolling[id] = this.scrollTop; } }); if (!that._autoCardHeight) { card.style.height = that._cardHeight + 'px'; } cardDataContainer.className = 'lw-card-data-container'; cardDataContainer.setAttribute('role', 'presentation'); that._applyTemplate(record, card, cardDataContainer, true); if (coverField) { const carousel = document.createElement('lw-carousel'); let carouselSource = record[coverField]; if (that.shadowRoot) { carousel._isInShadowDOM = true; } carouselSource = typeof carouselSource === 'string' ? carouselSource.split(',').map(url => url.trim()) : []; carousel.dataSource = carouselSource; carousel.hideArrows = true; carousel.unfocusable = true; carousel.animation = that.animation; carousel.theme = that.theme; carousel.rightToLeft = that.rightToLeft; carousel.onIndexChange = function (index) { that._cardSelectedCover[visibleSource[card.dataId].$.id] = index; }; carousel.whenReady(function () { carousel.hasStyleObserver = false; carousel.$.arrowLeft.hasStyleObserver = false; carousel.$.arrowRight.hasStyleObserver = false; }); card.appendChild(carousel); } card.appendChild(cardDataContainer); return card; } /** * Toggles a card. */ _toggleCard(card, dataContainer, recordId) { const that = this; card.setAttribute('updating', ''); if (that._collapsed[recordId]) { card.classList.add('collapsed'); dataContainer.firstElementChild.children[1].classList.add('collapsed'); dataContainer.children[1].classList.add('lw-visibility-hidden'); } else { card.classList.remove('collapsed'); dataContainer.firstElementChild.children[1].classList.remove('collapsed'); dataContainer.children[1].classList.remove('lw-visibility-hidden'); } setTimeout(function () { card.removeAttribute('updating'); }, 100); } /** * Creates an empty card. */ _createEmptyCard(hidden = true) { const that = this, card = that._createCard({}); if (hidden) { card.classList.add('lw-hidden'); } card.style.height = that._cardHeight + 'px'; that._cards.push(card); that.$.cardContainer.appendChild(card); } /** * Applies card template. */ _applyTemplate(record, card, container, create) { const that = this, columns = that.columns, titleField = that.titleField; if (create) { let content = that._cardContent; for (let i = 0; i < columns.length; i++) { const column = columns[i]; if (!column.visible) { continue; } const dataField = column.dataField, regex = new RegExp(`{{${dataField}}}`, 'g'), data = that._formatValue(record[dataField], record, column); content = content.replace(regex, data); } container.innerHTML = content.replace(/{{\w+}}/g, ''); if (titleField) { const titleId = that.id + 'Title' + (record.$ && record.$.id !== undefined ? record.$.id : 'Empty' + Math.floor(Math.random() * 1000)); container.firstElementChild.firstElementChild.id = titleId; card.setAttribute('aria-labelledby', titleId); } return; } for (let i = 0; i < columns.length; i++) { const column = columns[i]; if (!column.visible) { continue; } const dataField = column.dataField, element = container.querySelector(`[data-field="${dataField}"]`); if (element) { const data = that._formatValue(record[dataField], record, column); if (dataField === titleField) { element.firstElementChild.innerHTML = data; } else { element.children[1].innerHTML = data; } } } } /** * Formats a value based on formatFunction, formatString or template. */ _formatValue(value, record, column) { const that = this; if (Object.keys(record).length === 0) { return ''; } const settings = { column: column, record: record, template: column.template, value: value }; if (column.formatFunction) { column.formatFunction(settings); } value = settings.value; if (settings.template) { return that._applyCellTemplate(settings.template, value, record, column); } else if (column.formatSettings) { let result = ''; if (column.formatSettings.prefix) { result += column.formatSettings.prefix; } if (column.formatSettings.formatString && value !== undefined && value !== null) { if (value.constructor === Date) { value = new LW.Utilities.DateTime(value).toString(column.formatSettings.formatString); } else if (value instanceof LW.Utilities.DateTime) { value = value.toString(column.formatSettings.formatString); } else if (!isNaN(value) && that._numericFormatter) { value = that._numericFormatter.formatNumber(value, column.formatSettings.formatString); } } result += value; if (column.formatSettings.sufix) { result += column.formatSettings.sufix; } return result; } return value; } /** * Applies cell template. */ _applyCellTemplate(template, value = '', record, column) { let result = ''; if (typeof template === 'function') { const settings = { column: column, record: record, template: null, value: value }; template(settings); value = settings.value; if (settings.template === null) { return value; } template = settings.template; } if (template.startsWith('#')) { const templateElement = document.querySelector(template); if (templateElement && templateElement instanceof HTMLTemplateElement) { const templateContent = templateElement.content.cloneNode(true), tempElement = document.createElement('div'); tempElement.appendChild(templateContent); value = value.toString(); value = value.replace(/'/ig, '\\\''); value = value.replace(/"/ig, '\\"'); result = tempElement.innerHTML.replace(/{{value}}/ig, value).replace(/{{id}}/ig, record.$.id); if (result.indexOf('{{value=') >= 0) { if (!value) { result = result.replace(/{{value=/ig, ''); result = result.replace(/}}/ig, ''); } else { result = result.substring(0, result.indexOf('{{value=')) + value + result.substring(result.indexOf('}')); result = result.replace(/}/ig, ''); result = result.replace(/{/ig, ''); } } return result; } } result = template.replace(/{{value}}/ig, value).replace(/{{id}}/ig, record.$.id); return result; } /** * Gets the current number of cards per row. */ _getCardsPerRow() { const that = this, cards = that._cards; if (cards.length === 0) { that._cardsPerRow = 0; return; } let previousTop = cards[0].offsetTop, number = 1; for (let i = 1; i < cards.length; i++) { if (cards[i].offsetTop > previousTop) { break; } number++; } that._cardsPerRow = number; } /** * Vertical scrolling handler. */ _onVerticalChange(event) { const that = this; if (that._ignoreVerticalChange) { return; } const dataSource = that._visibleSource, scrolling = that.scrolling, fullCardHeight = that._cardHeight + that._gap, cardsPerRow = that._cardsPerRow; let value = event.detail.value; if (that._cards.length === dataSource.length) { // no virtual items const start = Math.floor(value / fullCardHeight) * cardsPerRow; that._start = { view: start, data: start }; if (that._dataSourceProcessed) { that._refreshCardContent(); } that.$.scrollViewer.$.scrollViewerContentContainer.style.top = -value + 'px'; if (scrolling === 'infinite' && that.$.scrollViewer.$.verticalScrollBar.value === that.$.scrollViewer.$.verticalScrollBar.max) { that._onScrollBottomReached(start, start); } return; } let startOfView, startOfData; clearTimeout(that._scrollingTimeout); if (that._numberOfCollapsedRows > 0) { const numberOfAllRows = Math.floor((dataSource.length - 1) / cardsPerRow) + 1; let height = 0, difference; startOfView = cardsPerRow; for (let i = 0; i < numberOfAllRows; i++) { const currentRowIndex = i, previousHeight = height; if (that._collapsedRows[currentRowIndex]) { height += fullCardHeight - that._cardContentHeight; } else { height += fullCardHeight; } if (startOfData === undefined && value <= height) { startOfData = currentRowIndex * cardsPerRow; difference = value - previousHeight; break; } } value = difference + fullCardHeight; } else { value = value % (2 * fullCardHeight) + fullCardHeight; if (value < fullCardHeight) { value += fullCardHeight; } while (value + that.$.scrollViewer.$.scrollViewerContainer.offsetHeight > that.$.cardContainer.offsetHeight) { value -= fullCardHeight; } startOfView = Math.floor(value / fullCardHeight) * cardsPerRow; startOfData = Math.floor(event.detail.value / fullCardHeight) * cardsPerRow; if (startOfView < 0) { startOfData -= startOfView; startOfView = 0; } } const endOfData = Math.min(startOfData + that._cards.length - startOfView - 1, dataSource.length - 1); if (scrolling === 'virtual' && (dataSource[startOfData].$.isEmpty || dataSource[endOfData].$.isEmpty)) { const size = endOfData - startOfData; let first, last; for (let i = startOfData; i <= endOfData; i++) { if (dataSource[i].$.isEmpty) { first = i; last = first; break; } } while (dataSource[last + 1] && dataSource[last + 1].$.isEmpty && last - first < size) { last++; } that.setAttribute('loading', ''); that.$.loadingIndicatorContainer.classList.remove('lw-hidden'); that.$.scrollViewer.$.scrollViewerContentContainer.style.top = -value + 'px'; that._scrollingTimeout = setTimeout(function () { that.dataSource.onVirtualDataSourceRequested( that._virtualDataSourceRequestedCallback.bind(that, startOfView, startOfData), { first: first, last: last, sorting: [], filtering: [], grouping: [], action: '' }); }, 300); return; } that.$.scrollViewer.$.scrollViewerContentContainer.style.top = -value + 'px'; that._updateVisibleCards(startOfView, startOfData); if (scrolling === 'virtual') { that.removeAttribute('loading'); that.$.loadingIndicatorContainer.classList.add('lw-hidden'); } else if (scrolling === 'infinite' && that.$.scrollViewer.$.verticalScrollBar.value === that.$.scrollViewer.$.verticalScrollBar.max) { that._onScrollBottomReached(startOfView, startOfData); } } /** * Scroll bottom reached handler when "scrolling" is 'infinite'. */ _onScrollBottomReached(startOfView, startOfData) { const that = this; that.$.loadingIndicatorContainer.classList.remove('lw-hidden'); that.dataSource.onVirtualDataSourceRequested(function () { that._updateVisibleCards(startOfView, startOfData); const numberOfVirtualRows = Math.ceil(that._visibleSource.length / that._cardsPerRow), scrollHeight = (that._cardHeight + that._gap) * numberOfVirtualRows - that._gap, viewHeight = that.$.scrollViewer.$.scrollViewerContainer.offsetHeight; that.$.scrollViewer.$.verticalScrollBar.max = Math.max(0, scrollHeight - viewHeight - that._numberOfCollapsedRows * that._cardContentHeight); that._scrollHeight = scrollHeight; that.$.loadingIndicatorContainer.classList.add('lw-hidden'); }, { first: Infinity, last: Infinity, sorting: [], filtering: [], grouping: [], action: '' }); } /** * Updates visible cards. */ _updateVisibleCards(startOfView, startOfData, initialization) { const that = this, startCoefficient = startOfData - startOfView, visibleSourceLength = that._visibleSource.length; for (let i = 0; i < startOfView; i++) { const card = that._cards[i]; card.setAttribute('aria-hidden', true); if (card.classList.contains('collapsed')) { that._toggleCard(card, card.firstElementChild.lastElementChild); } } for (let i = startOfView; i < that._cards.length; i++) { const card = that._cards[i], newDataId = startCoefficient + i; card.removeAttribute('aria-hidden'); if (newDataId < that._visibleSource.length) { card.classList.remove('lw-hidden'); card.setAttribute('aria-setsize', visibleSourceLength); card.setAttribute('aria-posinset', newDataId + 1); if (card.dataId !== newDataId || initialization || that._dataSourceProcessed) { that._updateVirtualCard(card, newDataId); } } else { card.classList.add('lw-hidden'); } } that._start = { view: startOfView, data: startOfData }; } /** * Toggles the visibility of a column. */ _toggleColumn(dataField, visible, skipValidation) { const that = this, dataSource = that._visibleSource; if (!dataField || typeof dataField !== 'string' || dataField === that.coverField || dataField === that.titleField || !dataSource || dataSource.length === 0) { return; } const column = that.columns.find(col => col.dataField === dataField); if (!column) { return; } that._close(); that._changedVisibility = new Map(); that._changedVisibility.set(column, visible); that._updateColumnsVisibility(undefined, skipValidation); } /** * Updates virtual card with new data. */ _updateVirtualCard(card, newDataId) { const that = this, record = that._visibleSource[newDataId], recordId = record.$.id, dataContainer = card.firstElementChild.lastElementChild, coverField = that.coverField; card.dataId = newDataId; that._applyTemplate(record, card, dataContainer); card.firstElementChild.scrollTop = that._cardScrolling[recordId] || 0; if (that._dragDetails) { if (card.dataId === that._dragDetails.index) { card.classList.add('dragged'); } else { card.classList.remove('dragged'); } } if (that._searchInfo) { if (that._searchInfo.foundIdsObject[recordId]) { card.classList.add('lw-data-view-found'); if (that._searchInfo.highlighted === recordId) { card.classList.add('lw-data-view-highlighted'); } else { card.classList.remove('lw-data-view-highlighted'); } } else { card.classList.remove('lw-data-view-found', 'lw-data-view-highlighted'); } } that._toggleCard(card, dataContainer, recordId); if (coverField) { const carousel = card.firstElementChild.firstElementChild; let carouselSource = record[coverField]; carouselSource = typeof carouselSource === 'string' ? carouselSource.split(',').map(url => url.trim()) : []; carousel.set('dataSource', carouselSource); if (carouselSource.length > 0) { const selectedIndex = that._cardSelectedCover[recordId] || 0; carousel._generateIndicators(); carousel._indicators[selectedIndex].classList.add('lw-active'); carousel._generateItems(); carousel._items[selectedIndex].classList.add('lw-active'); carousel._currentIndex = selectedIndex; } } } /** * Updates virtual card with new data. */ _updateCardHeight(newHeight) { const that = this, cards = that._cards; if (newHeight === null) { // apply "auto" height let maxHeight = 0, restoreCollapsedState = []; that._autoCardHeight = true; if (that._cards.length === 0) { return; } cards.forEach(card => { card.style.height = null; if (card.classList.contains('collapsed')) { card.setAttribute('updating', ''); card.classList.remove('collapsed'); card.getElementsByClassName('lw-card-view-content')[0].classList.remove('lw-visibility-hidden'); restoreCollapsedState.push(card); } }); cards.forEach(card => maxHeight = Math.max(card.offsetHeight, maxHeight)); cards.forEach(card => card.style.height = maxHeight + 'px'); that._cardContentHeight = that._cards[0].getElementsByClassName('lw-card-view-content')[0].offsetHeight + that._verticalOffset; if (restoreCollapsedState.length > 0) { restoreCollapsedState.forEach(card => { card.classList.add('collapsed'); card.getElementsByClassName('lw-card-view-content')[0].classList.add('lw-visibility-hidden'); }); setTimeout(function () { restoreCollapsedState.forEach(card => card.removeAttribute('updating')); }, 100); } if (that._cardHeight === maxHeight) { return; } that._cardHeight = maxHeight; } else { const firstCard = that._cards[0]; let restoreCollapsedState; that._autoCardHeight = false; if (that._cardHeight === newHeight) { return; } that._cardHeight = newHeight; if (!firstCard) { return; } cards.forEach(card => card.style.height = newHeight + 'px'); if (firstCard.classList.contains('collapsed')) { firstCard.setAttribute('updating', ''); firstCard.classList.remove('collapsed'); firstCard.getElementsByClassName('lw-card-view-content')[0].classList.remove('lw-visibility-hidden'); restoreCollapsedState = true; } that._cardContentHeight = that._cards[0].getElementsByClassName('lw-card-view-content')[0].offsetHeight + that._verticalOffset; if (restoreCollapsedState) { firstCard.classList.add('collapsed'); firstCard.getElementsByClassName('lw-card-view-content')[0].classList.add('lw-visibility-hidden'); setTimeout(function () { firstCard.removeAttribute('updating'); }, 100); } } that._partialRefresh(); } /** * Refreshes the view and adds or removes cards if necessary. */ _partialRefresh() { const that = this; that._refreshedAtDimensions = { width: that._cachedWidth, height: that._cachedHeight }; if (that._cards.length === that._visibleSource.length) { if (that._dataSourceProcessed) { that._refreshCardContent(); } that.$.scrollViewer.refresh(); return; } that._getCardsPerRow(); const viewHeight = that.$.scrollViewer.$.scrollViewerContainer.offsetHeight, fullCardHeight = that._cardHeight + that._gap, numberOfCollapsedCards = Object.keys(that._collapsed).length; let cardsPerRow = that._cardsPerRow; function regulateNumberOfCards() { let targetCardNum = ((viewHeight + 2 * fullCardHeight) / fullCardHeight) * cardsPerRow; targetCardNum = targetCardNum - (targetCardNum % cardsPerRow) + cardsPerRow; while (numberOfCollapsedCards > 0 && targetCardNum * (fullCardHeight - that._cardContentHeight) < viewHeight + 2 * fullCardHeight) { targetCardNum++; } targetCardNum = Math.min(targetCardNum, that._visibleSource.length); while (that._cards.length < targetCardNum) { that._createEmptyCard(false); } while (that._cards.length > targetCardNum) { that._cards[that._cards.length - 1].remove(); that._cards.pop(); } while (that.scrolling === 'infinite' && that._cards.length % cardsPerRow !== 0) { that._createEmptyCard(); } } regulateNumberOfCards(); that._getCardsPerRow(); if (cardsPerRow !== that._cardsPerRow) { cardsPerRow = that._cardsPerRow; regulateNumberOfCards(); } that._getNumberOfCollapsedRows(); const fractionOfMax = that._getFractionOfMax(), numberOfVirtualRows = Math.ceil(that._visibleSource.length / that._cardsPerRow), scrollHeight = fullCardHeight * numberOfVirtualRows - that._gap, newMax = Math.max(0, scrollHeight - viewHeight - that._numberOfCollapsedRows * that._cardContentHeight); that.$.scrollViewer.$.verticalScrollBar.max = newMax; that._scrollHeight = scrollHeight; if (newMax === 0) { that.$.scrollViewer.refresh(); } that._setFractionOfMax(fractionOfMax); } /** * Gets what part of max has been scrolled. */ _getFractionOfMax() { const verticalScrollBar = this.$.scrollViewer.$.verticalScrollBar, max = verticalScrollBar.max; if (max === 0) { return 0; } return verticalScrollBar.value / verticalScrollBar.max; } /** * Scrolls to a fraction of max. */ _setFractionOfMax(fractionOfMax) { const that = this, verticalScrollBar = this.$.scrollViewer.$.verticalScrollBar, newValue = verticalScrollBar.max * fractionOfMax; verticalScrollBar.value = newValue; that._onVerticalChange({ detail: { value: newValue } }); } /** * Refreshes currently visible cards. Should be called when only the values in cards have to be changed. */ _refreshCardContent() { const that = this; that._updateVisibleCards(that._start.view, that._start.data, true); } /** * Gets visible records. */ _getVisibleRecords() { const that = this, dataSource = that.dataSource; if (that._appliedFiltering.filters.length === 0) { that._visibleSource = dataSource; } else { that._visibleSource = []; for (let i = 0; i < dataSource.length; i++) { const record = that.dataSource[i]; if (record.$.filtered !== false) { that._visibleSource.push(record); that._visibleSource[that._visibleSource.length - 1]._id = record.$.id; } } } if (!dataSource || dataSource.length === 0) { that.setAttribute('empty', ''); that.removeAttribute('no-matches'); } else { that.removeAttribute('empty'); if (that._visibleSource.length === 0) { that.setAttribute('no-matches', ''); } else { that.removeAttribute('no-matches'); } } } /** * Searches by a query. */ _search(query, highlight = true) { const that = this; that._searchInfo.query = query; that._cards.forEach(card => card.classList.remove('lw-data-view-found', 'lw-data-view-highlighted')); if (query === '') { that.$.search.classList.remove('matches', 'no-matches'); delete that._searchInfo.foundIdsArray; delete that._searchInfo.foundIdsObject; delete that._searchInfo.highlighted; return; } const source = that._searchInfo.source, filters = [], foundIdsArray = [], foundIdsObject = {}; that._searchInfo.stringDataFields.forEach(dataField => { const filterGroup = new LW.Utilities.FilterGroup(), filterObject = filterGroup.createFilter('string', query, 'CONTAINS'); filterGroup.addFilter('or', filterObject); filters.push([dataField, filterGroup]); }); source._filter(filters, 'or'); for (let i = 0; i < source.length; i++) { const record = source[i]; if (record.$.filtered !== false) { foundIdsArray.push(record.$.id); foundIdsObject[record.$.id] = true; } } let highlighted = foundIdsArray[0]; that._searchInfo.foundIdsArray = foundIdsArray; that._searchInfo.foundIdsObject = foundIdsObject; if (foundIdsArray.length > 0) { if (highlight) { that._searchInfo.highlighted = highlighted; that.ensureVisible(highlighted); } that._cards.forEach(card => { const id = that._visibleSource[card.dataId].$.id; if (foundIdsObject[id]) { if (highlight && highlighted === id) { card.classList.add('lw-data-view-highlighted'); } card.classList.add('lw-data-view-found'); } }); that.$.search.classList.remove('no-matches'); that.$.search.classList.add('matches'); that.$.searchLabel.innerHTML = that.localize('found', { nth: highlight ? 1 : 0, n: foundIdsArray.length }); return; } that.$.search.classList.remove('matches'); that.$.search.classList.add('no-matches'); that.$.searchLabel.innerHTML = that.localize('found', { nth: 0, n: 0 }); } /** * Closes search panel. */ _closeSearchPanel() { const that = this; if (that._searchInfo) { that._cards.forEach(card => card.classList.remove('lw-data-view-found', 'lw-data-view-highlighted')); delete that._searchInfo; } } /** * Card container down handler. */ _cardContainerDownHandler(event) { const that = this; delete that._clickToDrag; if (!that.allowDrag || !that._isMobile && event.button !== 0) { return; } const target = event.originalEvent.target; if (target.closest('.lw-indicator') || target.closest('.lw-arrow-up')) { if (that._isMobile) { that.$.scrollViewer._scrollView.disableSwipeScroll = true; } return; } const card = event.originalEvent.target.closest('lw-card'); if (!card) { return; } that._dragDetails = { card: card, coords: { x: event.pageX, y: event.pageY }, index: card.dataId, originalEvent: event, record: that._visibleSource[card.dataId], startTime: new Date() }; that.$.scrollViewer._scrollView.disableSwipeScroll = true; window.getSelection().removeAllRanges(); } /** * document move handler. */ _documentMoveHandler(event) { const that = this, dragDetails = that._dragDetails; if (!dragDetails) { return; } if (!dragDetails.feedbackShown) { const now = new Date(), timePassed = now.getTime() - dragDetails.startTime.getTime() > 500, moved = Math.abs(dragDetails.coords.x - event.pageX) > 5 || Math.abs(dragDetails.coords.y - event.pageY) > 5; if (moved && (!that._isMobile || that._isMobile && timePassed)) { const startedDragging = that._startDragging(event); if (!startedDragging) { return; } } else { if (that._isMobile && moved && !timePassed) { delete that._dragDetails; that.$.scrollViewer._scrollView.disableSwipeScroll = false; } return; } } const draggedCard = dragDetails.card, record = dragDetails.record, y = event.clientY, x = event.clientX; let target = event.originalEvent.target; that.$.fireEvent('dragging', { card: draggedCard, originalEvent: event, record: record }); dragDetails.feedback.style.left = (event.pageX + 10) + 'px'; dragDetails.feedback.style.top = (event.pageY + 10) + 'px'; if (that._isMobile) { const realTarget = document.elementFromPoint(x, y); if (realTarget) { target = realTarget; } } clearInterval(that._dragInterval); that._dragInterval = setInterval(function () { const rect = that.$.scrollViewer.getBoundingClientRect(); if (that.$.scrollViewer.scrollHeight > 0 && rect.left <= x && rect.left + rect.width >= x) { if (y >= rect.top && y <= rect.top + 36) { that.$.scrollViewer.scrollTop -= that._autoScrollCoefficient; } else if (y >= rect.top + rect.height - 36 && y <= rect.top + rect.height) { that.$.scrollViewer.scrollTop += that._autoScrollCoefficient; } else { clearInterval(that._dragInterval); } } else { clearInterval(that._dragInterval); } }, 2); let closestCard = target.closest('lw-card'), side; if (dragDetails.hoveredCard) { dragDetails.hoveredCard.classList.remove('drop-target', 'left', 'right'); delete dragDetails.hoveredCard; } if (closestCard && closestCard.dataId === dragDetails.index) { return; } if (closestCard) { const rect = closestCard.getBoundingClientRect(), leftDistance = Math.abs(x - rect.left), rightDistance = Math.abs(x - rect.right); side = leftDistance < rightDistance ? 'left' : 'right'; } else if (target === that.$.addNewButton) { return; } else { let closest, closestDistance; that._cards.forEach(card => { const rect = card.getBoundingClientRect(), topDistance = Math.abs(y - rect.top), bottomDisatnce = Math.abs(y - rect.bottom), bestVerticalDistance = Math.min(topDistance, bottomDisatnce), leftDistance = Math.abs(x - rect.left), rightDistance = Math.abs(x - rect.right), bestHorizontalDistance = Math.min(leftDistance, rightDistance), overallDistance = Math.sqrt(Math.pow(bestHorizontalDistance, 2) + Math.pow(bestVerticalDistance, 2)); if (closestDistance === undefined || overallDistance < closestDistance) { closest = card; closestDistance = overallDistance; side = leftDistance < rightDistance ? 'left' : 'right'; } }); closestCard = closest; if (closestCard.dataId === dragDetails.index) { return; } } if (closestCard) { closestCard.classList.add(side, 'drop-target'); dragDetails.hoveredCard = closestCard; dragDetails.side = side; } } /** * Starts dragging operation. */ _startDragging(event) { const that = this, dragDetails = that._dragDetails, draggedCard = dragDetails.card, record = dragDetails.record; const dragStartEvent = that.$.fireEvent('dragStart', { card: draggedCard, originalEvent: event, record: record }); if (dragStartEvent.defaultPrevented) { delete that._dragDetails; that.$.scrollViewer._scrollView.disableSwipeScroll = false; return false; } dragDetails.feedback = that._addDragFeedback(record); dragDetails.feedbackShown = true; that.setAttribute('dragging', ''); draggedCard.classList.add('dragged'); that.closePanel(); that._clickToDrag = true; return true; } /** * Adds drag feedback. */ _addDragFeedback(record) { const that = this, feedback = document.createElement('div'); let innerHTML = ''; feedback.className = 'lw-card-view-drag-feedback'; if (that.theme) { feedback.setAttribute('theme', that.theme); } if (that.coverField) { innerHTML += `<div class="drag-feedback-thumbnail" style="background-image: url('${record[that.coverField].split(',')[0].trim()}');"></div>`; } if (that.titleField) { innerHTML += `<div class="drag-feedback-label">${record[that.titleField]}</div>`; } else if (!that.coverField) { innerHTML += `<div class="drag-feedback-label">${that.localize('draggedRecord', { id: record.$.id })}</div>`; } feedback.innerHTML = innerHTML; if (that.rightToLeft) { feedback.setAttribute('right-to-left', ''); } document.body.appendChild(feedback); return feedback; } /** * document up handler. */ _documentUpHandler(event) { const that = this, dragDetails = that._dragDetails; that.$.scrollViewer._scrollView.disableSwipeScroll = false; if (!dragDetails) { let target = event.originalEvent.target; const header = that.$.header; if (that.shadowRoot && target === that) { target = event.originalEvent.composedPath()[0]; } if (that.headerPosition !== 'none' && !that.$.headerDropDown.classList.contains('lw-visibility-hidden') && !that.$.headerDropDown.classList.contains('search-panel') && (target === header || !header.contains(target))) { const closestInputPopup = target.closest('lw-scroll-viewer'), closestDateTimePickerPopup = target.closest('.lw-drop-down'); if ((!closestInputPopup || !header.contains(closestInputPopup.ownerElement)) && (!closestDateTimePickerPopup || closestDateTimePickerPopup.ownerElement && !header.contains(closestDateTimePickerPopup.ownerElement))) { that.closePanel(); } } return; } const draggedCard = dragDetails.card, draggedRecord = dragDetails.record, hoveredCard = dragDetails.hoveredCard; delete that._dragDetails; if (!that.hasAttribute('dragging')) { return; } const withDraggedClass = that.$.cardContainer.getElementsByClassName('dragged'); Array.from(withDraggedClass).forEach(card => card.classList.remove('dragged')); that.removeAttribute('dragging'); dragDetails.feedback.remove(); clearInterval(that._dragInterval); window.getSelection().removeAllRanges(); if (!hoveredCard) { that.$.fireEvent('dragEnd', { card: draggedCard, originalEvent: event, record: draggedRecord }); return; } const hoveredRecord = that._visibleSource[hoveredCard.dataId], dragEndEvent = that.$.fireEvent('dragEnd', { card: draggedCard, originalEvent: event, record: draggedRecord, targetCard: hoveredCard, targetRecord: hoveredRecord, targetSide: dragDetails.side }); hoveredCard.classList.remove('drop-target', 'left', 'right'); if (dragEndEvent.defaultPrevented) { return; } const dataSource = that.dataSource; let fromIndexInSource, toIndexInSource; for (let i = 0; i < dataSource.length; i++) { const currentRecord = dataSource[i]; if (currentRecord.$.isEmpty) { continue; } if (currentRecord === draggedRecord) { fromIndexInSource = i; } else if (currentRecord === hoveredRecord) { toIndexInSource = i; } if (fromIndexInSource !== undefined && toIndexInSource !== undefined) { break; } } if (!that.rightToLeft && dragDetails.side === 'right' || that.rightToLeft && dragDetails.side === 'left') { toIndexInSource++; } dataSource.move(fromIndexInSource, toIndexInSource); that._getVisibleRecords(); that._dataSourceProcessed = true; that._partialRefresh(); delete that._dataSourceProcessed; } /** * scrollViewer touchmove handler. */ _scrollViewerTouchmoveHandler(event) { if (this._dragDetails && event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * Applies filtering. */ _applyFilter(filters, operator) { const that = this; try { that.dataSource._filter(filters, operator); } catch (error) { return; } that._getVisibleRecords(); that._fullRefresh(); } /** * Applies sorting. */ _applySort() { const that = this, sortByInfo = that._appliedSorting; that.dataSource.sortBy(sortByInfo.dataFields, sortByInfo.dataTypes, sortByInfo.orderBy); that._getVisibleRecords(); that._refreshCardContent(); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Kanban custom element. */ LW('lw-kanban', class Kanban extends LW.DataView { // Kanban's properties. static get properties() { return { 'allowDrag': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'allowDrop': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'autoLoadState': { value: false, type: 'boolean' }, 'autoSaveState': { value: false, type: 'boolean' }, 'currentUser': { value: null, type: 'any' }, 'dragOffset': { value: 'auto', type: 'any' }, 'formatStringDate': { value: 'd', type: 'string' }, 'formatStringTime': { value: 'MMM d, HH:mm', type: 'string' }, 'hierarchy': { value: 'columns', allowedValues: ['columns', 'tabs'], type: 'string' }, 'messages': { value: { 'en': { 'actionsIcon': 'Actions icon', 'addSubtask': 'Add subtask', 'assignedTo': 'Assigned to', 'checklist': 'Checklist', 'color': 'Color', 'commentsIcon': 'Comments icon', 'copy': 'Copy', 'customize': 'Customize tasks', 'dueDate': 'Due date', 'edit': 'Edit', 'editTask': 'Edit task "{{taskId}}"', 'high': 'High', 'low': 'Low', 'newComment': 'New comment', 'newSubtask': 'New subtask', 'normal': 'Normal', 'priority': 'Priority', 'priorityIcon': 'Priority icon', 'progress': 'Progress', 'promptComment': 'Are you sure you want to remove this comment?', 'promptTask': 'Are you sure you want to remove the task "{{taskText}}"?', 'remove': 'Remove', 'removeSubtask': 'Remove subtask', 'send': 'Send', 'startDate': 'Start date', 'status': 'Status', 'swimlane': 'Swimlane', 'tags': 'Tags', 'text': 'Text', 'userId': 'User ID', 'userIcon': 'User icon' } } }, 'selectionMode': { value: 'zeroOrOne', allowedValues: ['zeroOrOne', 'zeroOrManyExtended'], type: 'string' }, 'swimlanes': { value: [], type: 'array', reflectToAttribute: false }, 'swimlanesFrom': { value: 0, type: 'number' }, 'swimlanesTo': { value: null, type: 'number?' }, 'tags': { value: [], type: 'array' }, 'taskActions': { value: false, type: 'boolean' }, 'taskComments': { value: false, type: 'boolean' }, 'taskDue': { value: false, type: 'boolean' }, 'taskPosition': { value: 'all', allowedValues: ['all', 'leaf'], type: 'string' }, 'taskPriority': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'taskProgress': { value: false, type: 'boolean' }, 'taskTags': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'taskUserIcon': { value: true, type: 'boolean', defaultReflectToAttribute: true }, 'textTemplate': { value: null, type: 'any' }, 'userList': { value: false, type: 'boolean' }, 'users': { value: [], type: 'array', reflectToAttribute: false } }; } /** * Kanban's event listeners. */ static get listeners() { return { 'body.focusin': '_bodyFocusinHandler', 'container.click': '_containerClickHandler', 'container.down': '_containerDownHandler', 'container.keydown': '_containerKeydownHandler', 'container.touchmove': '_scrollViewerTouchmoveHandler' }; } /** * Kanban's HTML template. */ template() { const tabindex = this._tabindex; return `<div id="container" role="presentation"> <div id="header" class="lw-data-view-header" role="toolbar"> <div id="customizeButton" class="lw-data-view-header-button lw-data-view-customize-button lw-unselectable"${tabindex} role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Customize tasks"><div role="presentation"></div></div> <div id="filterButton" class="lw-data-view-header-button lw-data-view-filter-button lw-unselectable"${tabindex} role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Filter"><div role="presentation"></div></div> <div id="sortButton" class="lw-data-view-header-button lw-data-view-sort-button lw-unselectable"${tabindex} role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Sort"><div role="presentation"></div></div> <div id="searchButton" class="lw-data-view-header-button lw-data-view-search-button lw-unselectable"${tabindex} role="button" aria-expanded="false" aria-haspopup="dialog" aria-label="Search"></div> <div id="headerDropDown" class="lw-data-view-header-drop-down lw-visibility-hidden" role="dialog"> <div id="customize" class="lw-hidden" role="presentation"></div> <div id="filter" class="lw-hidden" role="presentation"></div> <div id="sort" class="lw-hidden" role="presentation"></div> <div id="search" class="lw-data-view-search-box lw-hidden" role="presentation"> <input type="text" id="searchInput" spellcheck="false" aria-label="Search" /> <div id="searchLabel" class="lw-data-view-search-label lw-unselectable"></div> <div id="searchPrev" class="lw-data-view-search-prev"${tabindex} role="button" aria-label="Previous"></div> <div id="searchNext" class="lw-data-view-search-next"${tabindex} role="button" aria-label="Next"></div> <div id="searchClose" class="lw-data-view-search-close"${tabindex} role="button" aria-label="Close search box"></div> </div> </div> </div> <div id="body" class="lw-kanban-body" role="presentation"></div> </div>`; } render() { const that = this, computedStyle = getComputedStyle(that); Object.defineProperty(that, 'dataSource', { get: function () { if (that.context === that) { return that.properties.dataSource.value; } else { return that._getCurrentDataSource(); } }, set(value) { that.updateProperty(that, that._properties.dataSource, value); } }); that._autoScrollCoefficient = LW.Utilities.Core.Browser.Firefox ? 4 : LW.Utilities.Core.Browser.Edge ? 8 : 2; that._kanbanTaskMinWidth = parseFloat(computedStyle.getPropertyValue('--lw-kanban-task-min-width')); that._dataViewPadding = parseFloat(computedStyle.getPropertyValue('--lw-data-view-padding')); that._allColumns = []; that._customTags = []; that._selectedTasks = []; that._dblclickObject = { numberOfClicks: 0 }; that._appliedFiltering = { filters: [], operator: 'and' }; that._appliedSorting = { dataFields: [], dataTypes: [], orderBy: [] }; that._sortPanelDataSource = [ { label: that.localize('text'), dataField: 'text', dataType: 'string' }, { label: that.localize('userId'), dataField: 'userId', dataType: 'string' }, { label: that.localize('tags'), dataField: 'tags', dataType: 'string' }, { label: that.localize('priority'), dataField: 'priority', dataType: 'string' }, { label: that.localize('progress'), dataField: 'progress', dataType: 'number' }, { label: that.localize('startDate'), dataField: 'startDate', dataType: 'date' }, { label: that.localize('dueDate'), dataField: 'dueDate', dataType: 'date' } ] that._getInnerElementMessages(); that._localizeHeader(); that._handleHeaderPosition(that.$.body); that._validateSwimlanes(); that._renderColumns(); that._handleSwimlanes(); let successfullyLoaded = false; if (that.autoLoadState) { successfullyLoaded = that.loadState(); } if (!successfullyLoaded) { that._processDataSource(); } that._getCurrentUser(); that._setUserList(); that._setActionsList(); that._setCommentsList(); that._autoSaveState(); super.render(); } /** * Called when the element is attached to the DOM. */ attached() { const that = this; super.attached(); if (that.isCompleted && that._dialog) { that._addDialogHandlers(); that.getShadowRootOrBody().appendChild(that._dialog); } } /** * Called when the element is detached from the DOM. */ detached() { const that = this; super.detached(); if (!that._dialog) { return; } const dialog = that._dialog; dialog.removeEventListener('open', that._dialogEventHandler); dialog.removeEventListener('closing', that._dialogEventHandler); dialog.removeEventListener('close', that._dialogEventHandler); dialog.removeEventListener('click', that._dialogClickHandler); dialog.remove(); } /** * Adds a task to a Kanban column. * * @param {Object} data Optional An object containing the new task's data. */ addTask(data = {}) { const that = this, columns = that.columns; if (typeof data !== 'object' || columns.length === 0 || !that._currentUser.allowAdd) { return; } if (data.status === undefined) { data.status = columns[0].dataField; } that._createTask(data, true); that._autoSaveState('dataSource'); } /** * Adds sorting. * * @param {Array/String} dataFields The data field(s) to sort by. * @param {Array/String} orderBy The sort direction(s) to sort the data field(s) by. */ addSort(dataFields, orderBy) { const that = this, dataSource = that.dataSource; let sortByInfo; function validate(dataField, index) { const validDataField = that._sortPanelDataSource.find(field => field.dataField === dataField); if (validDataField) { let columnOrderBy = Array.isArray(orderBy) ? orderBy[index] : typeof orderBy === 'string' ? orderBy : 'ascending'; sortByInfo.dataFields.push(dataField); sortByInfo.dataTypes.push(validDataField.dataType); columnOrderBy = columnOrderBy ? columnOrderBy.indexOf('desc') !== -1 ? 'descending' : 'ascending' : 'ascending'; sortByInfo.orderBy.push(columnOrderBy); } } if (arguments.length === 0 || !dataSource || dataSource.length === 0) { return; } that.closePanel(); if (arguments.length === 1 && typeof dataFields === 'object') { sortByInfo = dataFields; } else { sortByInfo = { dataFields: [], dataTypes: [], orderBy: [] }; if (Array.isArray(dataFields)) { dataFields.forEach(validate); } else if (typeof dataFields === 'string') { validate(dataFields, 0); } else { return; } } super.addSort(sortByInfo); } /** * Begins an edit operation. * * @param {Number|String|HTMLElement} task The task's id or corresponding HTMLElement. */ beginEdit(task) { const that = this; if (!that._currentUser.allowEdit || that.disabled) { return; } task = that._validateTaskArgument(task); if (!task) { return; } that._openDialog(task, 'edit'); } /** * Ends the current edit operation and discards changes. */ cancelEdit() { const dialog = this._dialog; if (dialog && dialog.opened && dialog.classList.contains('edit')) { dialog.close(); } } /** * Collapses a Kanban column. * * @param {String|Number} column The index or dataField of the column to collapse. */ collapse(column) { const that = this; if (!that.collapsible) { return; } column = that._validateColumnArgument(column); if (!column || column.collapsed || !column.collapsible) { return; } const columnElement = that._columnToElement.get(column), siblingColumns = columnElement.siblingColumns; let collapsedSiblings = 0; column.collapsed = true; columnElement.classList.add('collapsed'); siblingColumns.forEach(col => col.collapsed && collapsedSiblings++); if (collapsedSiblings === siblingColumns.length) { const toExpand = siblingColumns.indexOf(column) !== 0 ? 0 : 1, columnToExpand = siblingColumns[toExpand], columnElement = that._columnToElement.get(columnToExpand); columnToExpand.collapsed = false; columnElement.classList.remove('collapsed'); that._updateColumnWidths(siblingColumns, columnElement.parentElement); } else { that._updateColumnWidths(siblingColumns, columnElement.parentElement); } that._allColumns.forEach(col => that._refreshScrollViewer(col)); that._autoSaveState('collapsed'); that._handleSwimlanes(true); } /** * Creates a copy of a task in the same column. * * @param {Number|String|HTMLElement} task The task's id or corresponding HTMLElement. */ copyTask(task) { const that = this; if (!that._currentUser.allowAdd) { return; } task = that._validateTaskArgument(task); if (!task) { return; } const data = Object.assign({}, task.data); data.id = Math.floor(Math.random() * 90000 + 10000); that._createTask(data, true); that._autoSaveState('dataSource'); } /** * Ends the current edit operation and saves changes. */ endEdit() { const dialog = this._dialog; if (dialog && dialog.opened && dialog.classList.contains('edit')) { dialog.ok = true; dialog.close(); } } /** * Makes sure a task is visible by scrolling to it. * * @param {Number|String|HTMLElement} task The task's id or corresponding HTMLElement. */ ensureVisible(task) { const that = this; task = that._validateTaskArgument(task); if (!task || task.filteredOut) { return; } const parentScrollViewer = task.closest('lw-scroll-viewer'); if (parentScrollViewer.scrollHeight === 0) { return task; } const parentScrollViewerScrollTop = parentScrollViewer.scrollTop, taskOffsetTop = task.offsetTop; if (parentScrollViewerScrollTop <= taskOffsetTop && parentScrollViewerScrollTop + parentScrollViewer.offsetHeight >= taskOffsetTop + task.offsetHeight) { return task; } parentScrollViewer.scrollTop = taskOffsetTop; return task; } /** * Expands a Kanban column. * * @param {String|Number} column The index or dataField of the column to expand. */ expand(column) { const that = this; column = that._validateColumnArgument(column); if (!column || !column.collapsed) { return; } const columnElement = that._columnToElement.get(column); column.collapsed = false; columnElement.classList.remove('collapsed'); that._updateColumnWidths(columnElement.siblingColumns, columnElement.parentElement); that._allColumns.forEach(col => that._refreshScrollViewer(col)); that._autoSaveState('collapsed'); that._handleSwimlanes(true); } /** * Expands all Kanban columns. * */ expandAll() { const that = this; that._allColumns.forEach(column => { column.collapsed = false; that._columnToElement.get(column).classList.remove('collapsed'); }); that._allColumns.forEach(column => that._refreshScrollViewer(column)); that._columnContainers.forEach(container => that._updateColumnWidths(container.children, container)); that._autoSaveState('collapsed'); that._handleSwimlanes(true); } /** * Exports the Kanban's data. * * @param {String} dataFormat The file format to export to. * @param {String} fileName Optional The name of the file to export to. * @param {Function} callback Optional A callback function to pass the exported data to (if fileName is not provided). */ exportData(dataFormat, fileName, callback) { const that = this, computedStyle = getComputedStyle(that), borderColor = computedStyle.borderRightColor, swimlanes = that.swimlanes, dataExporter = new LW.Utilities.DataExporter(), dataSource = that._getCurrentDataSource(), dataSourceForExport = [ { id: 'Task ID', text: 'Text', status: 'Status', swimlane: 'Swimlane', asignee: 'Asignee', priority: 'Priority', progress: 'Progress', startDate: 'Start date', dueDate: 'Due date', subTasks: 'Completed sub-tasks', tags: 'Tags' } ], cachedStatuses = {}, cachedSwimlanes = {}, cachedAsignees = {}; dataExporter.style = { border: '1px solid ' + borderColor, borderCollapse: 'collapse', backgroundColor: computedStyle.backgroundColor, color: computedStyle.color, fontFamily: 'Helvetica', header: { border: '1px solid ' + borderColor, fontWeight: 'bold' }, columns: { border: '1px solid ' + borderColor, progress: { format: 'p0' }, startDate: { format: that.formatStringDate }, dueDate: { format: that.formatStringDate } }, rows: {} }; if (swimlanes.length === 0) { delete dataSourceForExport[0].swimlane; } for (let i = 0; i < dataSource.length; i++) { const dataPoint = dataSource[i]; let status = dataPoint.status, swimlane = dataPoint.swimlane, asignee = dataPoint.userId, progress = dataPoint.progress; if (cachedStatuses[status]) { status = cachedStatuses[status]; } else { status = that._allColumns.find(column => column.dataField === status).label; cachedStatuses[dataPoint.status] = status; } if (asignee === null) { asignee = ''; } else if (cachedAsignees[asignee]) { asignee = cachedAsignees[asignee]; } else { asignee = that.users.find(user => user.id === asignee).name; cachedAsignees[dataPoint.userId] = asignee; } if (progress === null) { progress = ''; } else { progress = progress / 100; } const record = { id: dataPoint.id, text: dataPoint.text, status: status, asignee: asignee, priority: dataPoint.priority, progress: progress, startDate: dataPoint.startDate || '', dueDate: dataPoint.dueDate || '', subTasks: that._getCompletedSubTasks(dataPoint.checklist), tags: dataPoint.tags }; if (swimlanes.length) { if (!swimlane) { swimlane = ''; } else if (cachedSwimlanes[swimlane]) { swimlane = cachedSwimlanes[swimlane]; } else { swimlane = swimlanes.find(swmln => swmln.dataField === swimlane).label; cachedSwimlanes[dataPoint.swimlane] = swimlane; } record.swimlane = swimlane; } dataSourceForExport.push(record); if (dataPoint.color) { dataExporter.style.rows[i] = { backgroundColor: dataPoint.color }; } } return dataExporter.exportData(dataSourceForExport, dataFormat, fileName, callback); } /** * Gets the Kanban's state. */ getState() { const that = this, collapsed = {}, state = { collapsed: collapsed, dataSource: that._getCurrentDataSource(), filtering: that._appliedFiltering, selection: { selected: that._selectedTasks.map(task => task.data.id), selectionStart: that._selectionStart ? that._selectionStart.data.id : null }, sorting: that._appliedSorting, tabs: that._selectedTabs, visibility: { taskActions: that.taskActions, taskComments: that.taskComments, taskDue: that.taskDue, taskPriority: that.taskPriority, taskProgress: that.taskProgress, taskTags: that.taskTags, taskUserIcon: that.taskUserIcon } }; let selectionInColumn = null, swimlane = null; if (that._selectionInView) { selectionInColumn = that._selectionInView.closest('.lw-kanban-column').column.dataField; swimlane = that._selectionInView.getAttribute('swimlane'); } state.selection.selectionInColumn = selectionInColumn; state.selection.swimlane = swimlane; that._allColumns.forEach(column => collapsed[column.dataField] = column.collapsed); return state; } /** * Loads the Kanban's state. * * @param {Object} state Optional An object returned by one of the methods getState or saveState. */ loadState(state) { const that = this; if (!state) { state = window.localStorage.getItem('lwKanban' + that.id); if (!state) { return false; } } if (typeof state === 'string') { state = JSON.parse(state, (key, value) => (!value || ['startDate', 'dueDate', 'time'].indexOf(key) === -1) ? value : new Date(value)); } that._selectedTasks = []; delete that._selectionStart; delete that._selectionInView; that.expandAll(); Array.from(that.$.container.querySelectorAll('lw-scroll-viewer.lw-kanban-column-content-tasks')).forEach(scrollViewer => scrollViewer.clearContent()); that._allColumns.forEach(column => { if (state.collapsed[column.dataField]) { that.collapse(column); } }); for (let propertyName in state.visibility) { that[propertyName] = state.visibility[propertyName]; } that.dataSource = state.dataSource; that._processDataSource(); that.addFilter(that._constructFilterGroups(state.filtering), state.filtering.operator); that.addSort(state.sorting); that._autoSaveState(state); state.selection.selected.forEach(id => { const task = that.$.container.querySelector(`.lw-kanban-task[data-id="${id}"]`); if (task) { task.setAttribute('selected', ''); that._selectedTasks.push(task); } }); if (state.selection.selectionStart) { that._selectionStart = that.$.container.querySelector(`.lw-kanban-task[data-id="${state.selection.selectionStart}"]`); } if (state.selection.selectionInColumn) { const columnElement = that._columnToElement.get(that._allColumns.find(column => column.dataField === state.selection.selectionInColumn)); if (state.selection.swimlane) { that._selectionInView = columnElement.querySelector(`lw-scroll-viewer[swimlane=${state.selection.swimlane}]`); } else { that._selectionInView = columnElement.querySelector('lw-scroll-viewer'); } } if (state.tabs) { const tabsHierarchy = that.hierarchy === 'tabs'; that._allColumns.forEach(column => { if (column.selected !== undefined) { const columnElement = that._columnToElement.get(column), selected = state.tabs.indexOf(column.dataField) !== -1; column.selected = selected; if (tabsHierarchy) { columnElement.classList.toggle('lw-hidden', !selected); columnElement.tab.classList.toggle('selected', selected); columnElement.tab.setAttribute('aria-selected', selected); } } }); } return true; } /** * Moves a task to a different column. * * @param {Number|String|HTMLElement} task The task's id or corresponding HTMLElement. * @param {String} newStatus The new status of the task (its new column's dataField). */ moveTask(task, newStatus) { const that = this; if (that.disabled || !newStatus) { return; } task = that._validateTaskArgument(task); if (!task || task.status === newStatus) { return; } const newColumn = that._allColumns.find(col => col.dataField === newStatus); if (!newColumn) { return; } const oldColumnScrollViewer = task.closest('lw-scroll-viewer'), newColumnElement = that._columnToElement.get(newColumn), data = task.data, newColumnScrollViewer = that.getTaskScrollViewer(newColumnElement, data); data.status = newStatus; newColumnScrollViewer.appendChild(task); if (!that._dialog || !that._dialog.ok) { if (that.textTemplate) { that._renderTask(task); } that._autoSaveState('dataSource'); } that._refreshScrollViewer(oldColumnScrollViewer, true); that._refreshScrollViewer(newColumnScrollViewer, true); if (task.hasAttribute('selected')) { task.removeAttribute('selected'); that._selectedTasks = that._selectedTasks.filter(t => t !== task); that._autoSaveState('selection'); } task.removeAttribute('focus'); if ((that.shadowRoot || that.getRootNode()).activeElement === oldColumnScrollViewer) { that._focusTask(that._getFirstItem(oldColumnScrollViewer.$.content)); } } /** * Opens the "Customize tasks" header panel (drop down). */ openCustomizePanel() { const that = this, dataSource = that.dataSource; if (!dataSource || dataSource.length === 0 || that.disabled || that.headerPosition === 'none') { return; } const customizePart = that.$.customize, columnPanelDataSource = [ { label: that.localize('actionsIcon'), dataField: 'taskActions', visible: that.taskActions }, { label: that.localize('commentsIcon'), dataField: 'taskComments', visible: that.taskComments }, { label: that.localize('dueDate'), dataField: 'taskDue', visible: that.taskDue }, { label: that.localize('priorityIcon'), dataField: 'taskPriority', visible: that.taskPriority }, { label: that.localize('progress'), dataField: 'taskProgress', visible: that.taskProgress }, { label: that.localize('tags'), dataField: 'taskTags', visible: that.taskTags }, { label: that.localize('userIcon'), dataField: 'taskUserIcon', visible: that.taskUserIcon } ]; let columnPanel; that._closeDialog(); that.$.headerDropDown.classList.add('customize-panel'); that.$.headerDropDown.classList.remove('filter-panel', 'sort-panel', 'search-panel'); customizePart.classList.remove('lw-hidden'); that.$.filter.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); that.$.search.classList.add('lw-hidden'); that._closeSearchPanel(); if (!that._customizePartCreated) { columnPanel = document.createElement('lw-column-panel'); columnPanel.animation = that.animation; columnPanel.dataSource = columnPanelDataSource; columnPanel.locale = that.locale; columnPanel.messages = that._innerElementMessages.columnPanel; columnPanel.rightToLeft = that.rightToLeft; columnPanel.theme = that.theme; that.$.customize.appendChild(columnPanel); columnPanel.$.sortable.disabled = true; that._customizePartCreated = true; } else { columnPanel = customizePart.firstElementChild; columnPanel.set('dataSource', columnPanelDataSource); columnPanel.propertyChangedHandler('dataSource', undefined, columnPanelDataSource); columnPanel.rightToLeft = that.rightToLeft; } that._openHeaderDropDown(that.$.customizeButton); } /** * Opens the "Filter" header panel (drop down). */ openFilterPanel() { const that = this, filterPanelDataSource = [ { label: that.localize('text'), dataField: 'text', dataType: 'string' }, { label: that.localize('userId'), dataField: 'userId', dataType: 'string' }, { label: that.localize('tags'), dataField: 'tags', dataType: 'string' }, { label: that.localize('priority'), dataField: 'priority', dataType: 'enum', options: [ { label: that.localize('high'), value: 'high' }, { label: that.localize('normal'), value: 'normal' }, { label: that.localize('low'), value: 'low' } ] }, { label: that.localize('progress'), dataField: 'progress', dataType: 'number' }, { label: that.localize('startDate'), dataField: 'startDate', dataType: 'date' }, { label: that.localize('dueDate'), dataField: 'dueDate', dataType: 'date' } ], filterPanelEditorCallback = function (editor, column) { if (column.dataField === 'progress') { editor.min = 0; editor.max = 100; editor.showUnit = true; editor.unit = '%'; } else if (column.dataType === 'date') { editor.formatString = that.formatStringDate; } }; super.openFilterPanel(filterPanelDataSource, filterPanelEditorCallback); } /** * Opens the "Sort" header panel (drop down). */ openSortPanel() { const that = this, sortPanelDataSource = that._sortPanelDataSource.map(field => { const index = that._appliedSorting.dataFields.indexOf(field.dataField); return Object.assign({}, field, { sortIndex: index, sortDirection: index === -1 ? 'ascending' : that._appliedSorting.orderBy[index] }); }); super.openSortPanel(sortPanelDataSource); } /** * Removes a task. * * @param {Number|String|HTMLElement} task The task's id or corresponding HTMLElement. * @param {Boolean} prompt Optional Whether or not to prompt the user before removing the task. */ removeTask(task, prompt) { const that = this; if (!that._currentUser.allowRemove) { return; } task = that._validateTaskArgument(task); if (!task) { return; } if (!prompt) { const scrollViewer = task.closest('lw-scroll-viewer'); task.remove(); that._refreshScrollViewer(scrollViewer, true); that._autoSaveState('dataSource'); } else { that._openDialog(task, 'prompt'); } } /** * Saves the Kanban's state to the browser's localStorage. */ saveState() { const that = this, state = that.getState(); window.localStorage.setItem('lwKanban' + that.id, JSON.stringify(state)); return state; } /** * Updates a task. * * @param {Number|String|HTMLElement} task The task's id or corresponding HTMLElement. * @param {Object} newData The new data to visualize in the task. */ updateTask(task, newData) { const that = this; if (!that._currentUser.allowEdit || !newData) { return; } task = that._validateTaskArgument(task); if (!task) { return; } const oldData = task.data; newData = Object.assign({}, oldData, newData); if (newData.checklist && newData.checklist.length === 0) { newData.checklist = null; } if (JSON.stringify(newData) === JSON.stringify(oldData)) { return; } task.data = newData; if (newData.status !== oldData.status) { that.moveTask(task, newData.status); } if (newData.swimlane !== oldData.swimlane) { const columnElement = task.closest('.lw-kanban-column'); if (that._hasSwimlane(columnElement.index)) { columnElement.querySelector(`lw-scroll-viewer[swimlane=${newData.swimlane}]`).appendChild(task); if (oldData.swimlane) { that._refreshScrollViewer(columnElement.querySelector(`lw-scroll-viewer[swimlane=${oldData.swimlane}]`)); } } else { delete newData.swimlane; } } if (that.textTemplate || newData.text !== oldData.text || newData.tags !== oldData.tags || newData.priority !== oldData.priority) { that._renderTask(task); } else { if (newData.userId !== oldData.userId) { that._updateUserIcon(task); } if (newData.dueDate !== oldData.dueDate) { that._updateTaskDueDate(task); } if (newData.color !== oldData.color) { that._updateTaskColor(task); } if (JSON.stringify(newData.checklist) !== JSON.stringify(oldData.checklist)) { that._updateTaskChecked(task); that._updateTaskProgress(task); } else if (parseFloat(newData.progress) !== parseFloat(oldData.progress)) { that._updateTaskProgress(task); } } that.$.fireEvent('change', { task: task, value: newData, oldValue: oldData }); that._refreshScrollViewer(task.closest('lw-scroll-viewer')); that._autoSaveState('dataSource'); } /** * Updates the Kanban when a property is changed. * @param {String} propertyName The name of the property. * @param {Number|String} oldValue The previously entered value. * @param {Number|stStringring} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this, dialog = that._dialog; function changeUser() { that.cancelEdit(); if (dialog) { dialog.close(); } that._closeList(that._commentsList, '_commentSelectionFor'); that._getCurrentUser(); } super.propertyChangedHandler(propertyName, oldValue, newValue); switch (propertyName) { case 'allowDrag': that._getCurrentUser(); break; case 'animation': case 'theme': { let affectedElements = Array.from(that.$.container.querySelectorAll('lw-column-panel, lw-multi-column-filter-panel, lw-sort-panel')); if (dialog) { affectedElements.push(dialog); if (dialog.editPanelPopulated) { affectedElements = affectedElements.concat(Array.from(dialog.$.container.querySelectorAll('.lw-element.editor'))); } } affectedElements.forEach(element => element[propertyName] = newValue); Array.from(that.$.container.getElementsByClassName('lw-kanban-task')).forEach(task => that._updateTaskColor(task)); break; } case 'autoSaveState': that._autoSaveState(); break; case 'collapsible': if (!newValue) { that.expandAll(); } break; case 'columns': that.dataSource = that._getCurrentDataSource(); that._reset(); if (dialog && dialog.editPanelPopulated) { dialog.editors.status.dataSource = that._allColumns.map(col => ({ label: col.label, value: col.dataField })); } break; case 'currentUser': changeUser(); break; case 'dataSource': if (that.columns.length === 0) { that._renderColumns(); that._handleSwimlanes(); that._processDataSource(); return; } Array.from(that.$.container.querySelectorAll('lw-scroll-viewer.lw-kanban-column-content-tasks')).forEach(scrollViewer => scrollViewer.clearContent()); that._processDataSource(); break; case 'disabled': that.cancelEdit(); that.closePanel(); that._closeList(that._actionsList, '_actionSelectionFor'); that._closeList(that._commentsList, '_commentSelectionFor'); that._closeList(that._userList, '_userSelectionFor'); that._setFocusable(); break; case 'formatStringDate': Array.from(that.$.container.getElementsByClassName('lw-kanban-task')).forEach(task => that._updateTaskDueDate(task)); if (dialog) { dialog.editors.startDate.formatString = newValue; dialog.editors.dueDate.formatString = newValue; } break; case 'formatStringTime': that._closeList(that._commentsList, '_commentSelectionFor'); break; case 'editable': that.cancelEdit(); if (!that._actionsList.classList.contains('edit-comment')) { that._closeList(that._actionsList, '_actionSelectionFor'); } that._getCurrentUser(); break; case 'headerPosition': that._handleHeaderPosition(that.$.body); that._allColumns.forEach(column => that._refreshScrollViewer(column)); break; case 'hierarchy': if (that.swimlanes.length === 0 && that.columns.length !== that._allColumns.length) { that._reset(); } break; case 'locale': case 'messages': that.closePanel(); that._localizeHeader(); that._getInnerElementMessages(); that._closeList(that._actionsList, '_actionSelectionFor'); that._closeList(that._commentsList, '_commentSelectionFor'); that._setActionsList(); that._setCommentsList(); if (dialog) { that.cancelEdit(); dialog.close(); dialog.$.footer.firstElementChild.innerHTML = that.localize('ok'); dialog.$.footer.children[1].innerHTML = that.localize('cancel'); if (dialog.editPanelPopulated) { dialog.editors.priority.dataSource = [{ label: that.localize('low'), value: 'low' }, { label: that.localize('normal'), value: 'normal' }, { label: that.localize('high'), value: 'high' }]; dialog.$.container.querySelector('.new-subtask').placeholder = that.localize('newSubtask'); dialog.$.container.querySelector('lw-button.add').title = that.localize('addSubtask'); Array.from(dialog.$.container.getElementsByClassName('editor-label')).forEach(label => { let purpose = label.id.slice(that.id.length + 5); purpose = purpose.slice(0, 1).toLowerCase() + purpose.slice(1); label.innerHTML = that.localize(purpose); }); } } if (that._customizePartCreated) { that.$.customize.firstElementChild.messages = that._innerElementMessages.columnPanel; that.$.customize.firstElementChild.locale = that.locale; } if (that._filterPartCreated) { that.$.filter.firstElementChild.messages = that._innerElementMessages.multiColumnFilterPanel; that.$.filter.firstElementChild.locale = that.locale; that.$.filter.firstElementChild.editorPlaceholder = that.localize('filterValuePlaceholder'); } if (that._sortPartCreated) { that.$.sort.firstElementChild.messages = that._innerElementMessages.sortPanel; that.$.sort.firstElementChild.locale = that.locale; } break; case 'rightToLeft': that._reset(true); break; case 'selectionMode': if (newValue === 'zeroOrOne' && that._selectedTasks.length > 1) { const selectionStart = that._selectionStart; that._selectedTasks.forEach(selectedTask => selectedTask !== selectionStart && selectedTask.removeAttribute('selected')); that._selectedTasks = [selectionStart]; } break; case 'swimlanes': that._validateSwimlanes(); if (JSON.stringify(that.swimlanes) === JSON.stringify(oldValue)) { return; } that._reset(); if (dialog && dialog.editPanelPopulated) { dialog.editors.swimlane.dataSource = that.swimlanes.map(swimlane => ({ label: swimlane.label, value: swimlane.dataField })); } break; case 'swimlanesFrom': case 'swimlanesTo': { const swimlanesFrom = that.swimlanesFrom, swimlanesTo = that.swimlanesTo; if (swimlanesFrom < 0) { that.swimlanesFrom = 0; } if (swimlanesTo !== null) { if (swimlanesFrom > swimlanesTo) { that.swimlanesFrom = swimlanesTo; } } if (that.swimlanes.length > 0) { that._reset(); } break; } case 'tags': case 'textTemplate': Array.from(that.$.container.getElementsByClassName('lw-kanban-task')).forEach(task => that._renderTask(task)); that._allColumns.forEach(column => that._refreshScrollViewer(column)); break; case 'unfocusable': that._setFocusable(); break; case 'users': that._closeList(that._userList, '_userSelectionFor'); that._setUserList(); Array.from(that.$.container.getElementsByClassName('lw-kanban-task')).forEach(task => that._updateUserIcon(task)); if (dialog && dialog.editPanelPopulated) { dialog.editors.userId.dataSource = that.users.map(user => ({ label: user.name, value: user.id })); } changeUser(); break; } } /** * Resets the Kanban. */ _reset(removeDialog) { const that = this, currentState = that.getState(); that._allColumns = []; that._customTags = []; that._selectedTasks = []; if (that._dialog) { that.cancelEdit(); if (removeDialog) { that._dialog.remove(); delete that._dialog; } } that.closePanel(); that._closeList(that._actionsList, '_actionSelectionFor'); that._closeList(that._commentsList, '_commentSelectionFor'); that._closeList(that._userList, '_userSelectionFor'); that.$.body.innerHTML = ''; Array.from(that.$.container.getElementsByClassName('swimlane')).forEach(swimlane => swimlane.remove()); that._renderColumns(); that._handleSwimlanes(); that.loadState(currentState); } /** * Container click handler. */ _containerClickHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; if (that.$.header.contains(target)) { that._headerClickHandler(target, that.$.body); return; } const columnHeader = target.closest('.lw-kanban-column-header'); if (columnHeader) { const column = columnHeader.parentElement.column; if (target.closest('.lw-kanban-column-header-add')) { that.addTask({ status: column.dataField }); return; } if (that.collapsible && column.collapsible) { that[column.collapsed ? 'expand' : 'collapse'](column); return; } } const tab = target.closest('.lw-kanban-tab'); if (tab) { if (tab.classList.contains('selected')) { return; } const previousSelection = tab.parentElement.querySelector('.selected'); previousSelection.classList.remove('selected'); previousSelection.setAttribute('aria-selected', false); previousSelection.columnElement.classList.add('lw-hidden'); previousSelection.columnElement.column.selected = false; tab.classList.add('selected'); tab.setAttribute('aria-selected', true); tab.columnElement.classList.remove('lw-hidden'); tab.columnElement.column.selected = true; that._selectedTabs = that._allColumns.filter(column => column.selected).map(column => column.dataField); that._autoSaveState('tabs'); that._allColumns.forEach(column => that._refreshScrollViewer(column)); return; } const listItem = target.closest('.lw-kanban-list .item'); if (listItem) { const dataId = parseFloat(listItem.getAttribute('data-id')), userSelectionFor = that._userSelectionFor; if (userSelectionFor) { userSelectionFor.data.userId = dataId; that._updateUserIcon(userSelectionFor); that._closeList(that._userList, '_userSelectionFor'); return; } const actionSelectionFor = that._actionSelectionFor; if (actionSelectionFor) { switch (dataId) { case 0: if (that._actionsList.classList.contains('edit-comment')) { that._commentsList.textarea.value = actionSelectionFor.comment.text; that._commentsList.textarea.focus(); that._commentsList.editing = actionSelectionFor; actionSelectionFor.parentElement.scrollTop = actionSelectionFor.offsetTop; } else { that.beginEdit(actionSelectionFor); } break; case 1: that.copyTask(actionSelectionFor); break; case 2: if (that._actionsList.classList.contains('edit-comment')) { that._openDialog(actionSelectionFor, 'prompt', 'comment'); } else { that.removeTask(actionSelectionFor, true); } break; } that._closeList(that._actionsList, '_actionSelectionFor'); return; } } if (target.closest('.lw-kanban-list.comments')) { const sendButton = target.closest('.send'); if (sendButton) { if (sendButton.disabled) { return; } that._createComment(); that._commentsList.textarea.value = ''; sendButton.disabled = true; } else if (target.classList.contains('remove-button') && target.classList.contains('enabled')) { const comment = target.closest('.comment'); if (!that._actionSelectionFor || that._actionSelectionFor !== comment && !that._actionSelectionFor.classList.contains('lw-kanban-task') && (!that._actionsList.parentElement || that._actionsList.classList.contains('lw-visibility-hidden'))) { that._openActionsList(target, undefined, comment); } } return; } const task = target.closest('.lw-kanban-task'); if (!task) { return; } if (target.classList.contains('lw-kanban-task-user')) { if (that.userList && that._currentUser.allowEdit && (!that._userSelectionFor || that._userSelectionFor !== task && (!that._userList.parentElement || that._userList.classList.contains('lw-visibility-hidden')))) { that._openUserList(target, task); } return; } if (that.taskActions && target.classList.contains('lw-kanban-task-actions')) { if (!that._actionSelectionFor || that._actionSelectionFor !== task && !that._actionSelectionFor.classList.contains('comment') && (!that._actionsList.parentElement || that._actionsList.classList.contains('lw-visibility-hidden'))) { that._openActionsList(target, task); } return; } if (that.taskComments && target.classList.contains('lw-kanban-task-comments')) { if (that.users.length > 0 && (!that._commentSelectionFor || that._commentSelectionFor !== task && (!that._commentsList.parentElement || that._commentsList.classList.contains('lw-visibility-hidden')))) { that._openCommentsList(target, task); } return; } if (!that._preventSelection) { that._selectTask(event, task); } if (!that._currentUser.allowEdit || !event.type) { return; } clearTimeout(that._dblclickObject.timeout); that._dblclickObject.numberOfClicks++; if (that._dblclickObject.numberOfClicks === 2) { that._dblclickObject.numberOfClicks = 0; that.beginEdit(task); } else { that._dblclickObject.timeout = setTimeout(function () { that._dblclickObject.numberOfClicks = 0; }, 300); } } /** * Selects a task on click. */ _selectTask(event, task) { const that = this, selectionMode = that.selectionMode; function selectSingleExtended() { that._selectedTasks.forEach(selectedTask => selectedTask !== task && selectedTask.removeAttribute('selected')); if (!task.hasAttribute('selected')) { task.setAttribute('selected', ''); that._selectedTasks = [task]; } that._selectionStart = task; that._selectionInView = task.closest('lw-scroll-viewer'); that._autoSaveState('selection'); that._focusTask(task); } if (selectionMode === 'zeroOrOne') { that._selectedTasks.forEach(selectedTask => selectedTask !== task && selectedTask.removeAttribute('selected')); if (task.hasAttribute('selected')) { that._focusTask(task); task.removeAttribute('selected'); that._selectedTasks = []; delete that._selectionInView; } else { task.setAttribute('selected', ''); that._selectedTasks = [task]; that._selectionStart = task; that._selectionInView = task.closest('lw-scroll-viewer'); that._focusTask(task); } } else { if (!event.ctrlKey && !event.shiftKey || that._selectedTasks.length === 0 || task.closest('lw-scroll-viewer') !== that._selectionInView) { selectSingleExtended(); return; } if (event.ctrlKey) { if (task.hasAttribute('selected')) { task.removeAttribute('selected'); that._selectedTasks = that._selectedTasks.filter(currentTask => currentTask !== task); } else { task.setAttribute('selected', ''); that._selectedTasks.push(task); that._selectionStart = task; } } else if (event.shiftKey) { if (task === that._selectionStart) { if (that._selectedTasks.length > 1) { selectSingleExtended(); } return; } const tasksInColumn = Array.from(task.parentElement.children); let startIndex = tasksInColumn.indexOf(that._selectionStart), endIndex = tasksInColumn.indexOf(task); const temp = startIndex; startIndex = Math.min(startIndex, endIndex); endIndex = Math.max(temp, endIndex); that._selectedTasks = []; tasksInColumn.forEach((currentTask, index) => { if (index >= startIndex && index <= endIndex && !currentTask.filteredOut) { currentTask.setAttribute('selected', ''); that._selectedTasks.push(currentTask); } else { currentTask.removeAttribute('selected'); } }); } that._focusTask(task); } that._autoSaveState('selection'); } /** * Processes data source. */ _processDataSource() { const that = this, dataSource = that.dataSource; if (that.columns.length === 0 || dataSource === null) { return; } dataSource.forEach(data => { that._createTask(data); }); that.whenRendered(() => that._allColumns.forEach(column => that._refreshScrollViewer(column))); } /** * Creates or updates the user list. */ _setUserList() { const that = this, list = document.createElement('div'); list.id = that.id + 'UserList'; list.className = 'lw-kanban-list users lw-visibility-hidden'; list.setAttribute('role', 'listbox'); if (!that.disabled && !that.unfocusable) { list.tabIndex = 0; } that.users.forEach(user => { const div = document.createElement('div'); div.className = 'item'; div.innerHTML = `<div class="icon" style="background-image: url('${user.image}')"></div><div class="name">${user.name}</div>`; div.setAttribute('data-id', user.id); div.setAttribute('role', 'option'); list.appendChild(div); }); that._userList = list; } /** * Opens an options list. */ _openList(button, list, right) { const that = this, containerRect = that.$.container.getBoundingClientRect(), buttonRect = button.getBoundingClientRect(); let left = buttonRect.left, top = buttonRect.top + button.offsetHeight, windowWidth, windowHeight; function check() { if (list.getBoundingClientRect().height === 0) { requestAnimationFrame(check); } else { list.focus(); } } right = that.rightToLeft ? (right ? false : true) : right; if (window.devicePixelRatio === 1) { windowWidth = document.documentElement.clientWidth; windowHeight = document.documentElement.clientHeight; } else { windowWidth = window.innerWidth; windowHeight = window.innerHeight; } that.$.container.appendChild(list); if (right) { left = buttonRect.right - list.offsetWidth; } if (left + list.offsetWidth > windowWidth) { left = windowWidth - list.offsetWidth; } if (top + list.offsetHeight > windowHeight) { top = windowHeight - list.offsetHeight; } list.style.left = Math.max(0, left) - containerRect.left + 'px'; list.style.top = top - containerRect.top + 'px'; list.classList.remove('lw-visibility-hidden'); button.setAttribute('aria-expanded', true); button.setAttribute('aria-controls', list.id); if (!that.unfocusable) { requestAnimationFrame(check); } list.openedFrom = button; } /** * Opens the user list. */ _openUserList(icon, task) { const that = this; if (that.users.length === 0) { return; } const userId = task.data.userId, userList = that._userList, selectedUser = userList.querySelector('.selected'); if (selectedUser) { selectedUser.classList.remove('selected'); selectedUser.removeAttribute('aria-selected'); } that._openList(icon, userList); if (userId !== null) { const selectedUser = Array.from(userList.children).find(user => user.getAttribute('data-id') === userId.toString()); if (selectedUser) { selectedUser.classList.add('selected'); selectedUser.setAttribute('aria-selected', true); userList.scrollTop = selectedUser.offsetTop; } } that._userSelectionFor = task; } /** * Closes a list. */ _closeList(list, flag) { const that = this; if (!list || !list.parentElement) { return; } const controller = that.$.container.querySelector(`[aria-expanded="true"][aria-controls="${list.id}"]`); function check() { if (!list.classList.contains('lw-visibility-hidden')) { return; } if (list.getBoundingClientRect().height > 0) { requestAnimationFrame(check); } else { list.remove(); delete list.openedFrom; delete that[flag]; } } list.classList.add('lw-visibility-hidden'); requestAnimationFrame(check); if (controller) { controller.removeAttribute('aria-expanded'); controller.removeAttribute('aria-controls'); } } /** * Creates or updates the task actions list. */ _setActionsList() { const that = this, list = document.createElement('div'); list.id = that.id + 'ActionsList'; list.className = 'lw-kanban-list actions lw-visibility-hidden'; list.setAttribute('role', 'menu'); if (!that.disabled && !that.unfocusable) { list.tabIndex = 0; } list.innerHTML = `<div class="item" data-id="0" role="menuitem"><div class="name">${that.localize('edit')}</div></div> <div class="item" data-id="1" role="menuitem"><div class="name">${that.localize('copy')}</div></div> <div class="item" data-id="2" role="menuitem"><div class="name">${that.localize('remove')}</div></div>`; that._actionsList = list; } /** * Opens the task actions list. */ _openActionsList(icon, task, comment) { const that = this, currentUser = that._currentUser, list = that._actionsList; that._openList(icon, list, comment); list.classList.toggle('edit-comment', !!comment); that._actionSelectionFor = task || comment; list.firstElementChild.toggleAttribute('disabled', !!(task && !currentUser.allowEdit)); list.children[1].toggleAttribute('disabled', !!(task && !currentUser.allowAdd)); list.children[2].toggleAttribute('disabled', !!(task && !currentUser.allowRemove)); Array.from(list.children).forEach(item => item.classList.remove('selected')); } /** * Creates or updates the task comments list. */ _setCommentsList() { const that = this, list = document.createElement('div'); list.id = that.id + 'CommentsList'; list.className = 'lw-kanban-list comments lw-visibility-hidden'; list.setAttribute('role', 'dialog'); if (!that.disabled && !that.unfocusable) { list.tabIndex = 0; } list.innerHTML = `<div class="lw-kanban-comments" role="list"></div> <div class="lw-kanban-new-comment" role="presentation"> <textarea placeholder="${that.localize('newComment')}"></textarea> <lw-button class="send primary" disabled${that._rtlAttr}>${that.localize('send')}</lw-button> </div>`; const textarea = list.querySelector('textarea'), button = list.querySelector('lw-button'); button.tabIndex = 0; textarea.onfocus = () => { list.classList.add('expanded'); button.disabled = textarea.value === ''; }; textarea.onblur = (event) => { if (!button.contains(event.relatedTarget)) { list.classList.remove('expanded'); } }; textarea.onkeyup = () => { button.disabled = textarea.value === ''; }; textarea.oncut = () => { button.disabled = textarea.value === ''; }; textarea.onpaste = () => { button.disabled = textarea.value === ''; }; list.textarea = textarea; list.button = button; that._commentsList = list; } /** * Opens the task actions list. */ _openCommentsList(icon, task) { const that = this, list = that._commentsList; list.classList.remove('expanded'); list.firstElementChild.innerHTML = ''; list.textarea.value = ''; list.textarea.disabled = !that._currentUser.allowComment; if (that.unfocusable) { list.textarea.tabIndex = -1; } else { list.textarea.removeAttribute('tabindex'); } delete list.editing; task.data.comments.forEach(comment => that._createComment(comment)); that._openList(icon, list); that._commentSelectionFor = task; } /** * Creates a comment. */ _createComment(comment) { const that = this, commentElement = document.createElement('div'); let newComment, user; if (!comment) { const enteredText = that._commentsList.textarea.value, editedCommentElement = that._commentsList.editing; if (editedCommentElement) { editedCommentElement.querySelector('.comment-body').innerHTML = enteredText; editedCommentElement.comment.text = enteredText; delete that._commentsList.editing; return; } const data = that._commentSelectionFor.data; newComment = true; comment = { text: enteredText, userId: that._currentUser.info.id, time: new Date() }; user = that._currentUser.info; data.comments.push(comment); that._commentSelectionFor.querySelector('.lw-kanban-task-comments').setAttribute('num', data.comments.length || ''); } else { user = that.users.find(user => user.id === comment.userId); } if (!user) { return; } const commentsSection = that._commentsList.firstElementChild; commentElement.classList = 'comment'; commentElement.setAttribute('role', 'listitem'); commentElement.innerHTML = `<div class="comment-indent" role="presentation"> <div class="user-icon" style="background-image: url('${user.image}');" role="img" aria-label="Icon of user ${(user.name || user.id)}"></div> </div> <div class="comment-main" role="presentation"> <div class="comment-header" role="presentation"> <div class="user-name" aria-label="User name">${user.name}</div> <div class="time" aria-label="Comment time">${comment.time ? new LW.Utilities.DateTime(comment.time).toString(that.formatStringTime) : ''}</div> <div class="remove-button${that._currentUser.info && user.id === that._currentUser.info.id && that._currentUser.allowComment ? ' enabled' : ''}"${that._tabindex} role="button" aria-haspopup="menu" aria-label="Comment settings"></div> </div> <div class="comment-body" aria-label="Comment text">${comment.text || ''}</div > </div>`; commentElement.comment = comment; commentsSection.appendChild(commentElement); if (newComment) { commentsSection.scrollTop = commentsSection.scrollHeight - commentsSection.offsetHeight; } } /** * Creates a task. */ _createTask(data, refreshScrollbar) { const that = this, column = that._allColumns.find(column => column.dataField === data.status); if (!column) { return; } const task = document.createElement('div'), columnElement = that._columnToElement.get(column), columnScrollViewer = that.getTaskScrollViewer(columnElement, data); if (data.id === undefined) { data.id = Math.floor(Math.random() * 90000 + 10000); } task.className = 'lw-kanban-task lw-unselectable'; task.setAttribute('role', 'listitem'); task.setAttribute('data-id', data.id); task.data = data; that._renderTask(task); if (data.class && typeof data.class === 'string') { task.classList.add(data.class); } columnScrollViewer.appendChild(task); that._updateTaskColor(task); if (refreshScrollbar) { if (column.collapsed) { columnScrollViewer.toRefresh = true; } else { columnScrollViewer.refresh(); } } } /** * Gets a task's ScrollViewer. */ getTaskScrollViewer(columnElement, data) { const that = this; let scrollViewer; if (that._hasSwimlane(columnElement.index)) { if (data.swimlane !== undefined && that.swimlanes.find(swimlane => swimlane.dataField === data.swimlane)) { scrollViewer = columnElement.querySelector(`lw-scroll-viewer[swimlane="${data.swimlane}"]`); } else { scrollViewer = columnElement.querySelector('lw-scroll-viewer'); data.swimlane = scrollViewer.getAttribute('swimlane'); } } else { scrollViewer = columnElement.querySelector('lw-scroll-viewer'); delete data.swimlane; } return scrollViewer; } /** * Renders task. */ _renderTask(task) { const that = this; that._applyTaskTemplate(task); that._updateUserIcon(task); that._updateTaskChecked(task); that._updateTaskProgress(task); that._updateTaskDueDate(task); if (task.parentElement) { that._updateTaskColor(task); } } /** * Applies task template. */ _applyTaskTemplate(task) { const that = this, tags = that.tags, data = task.data, tabindex = that._tabindex; let text = data.text, taskTags = data.tags, tagsContent = ''; if (text === undefined) { text = ''; data.text = ''; } text = that._applyTextTemplate(text, data, task); if (taskTags && typeof taskTags === 'string') { taskTags = taskTags.replace(/\s+/g, '').split(','); if (tags.length > 0) { taskTags = taskTags.filter(tag => tags.indexOf(tag) !== -1); data.tags = taskTags.join(', '); } else { taskTags.forEach(tag => { if (that._customTags.indexOf(tag) === -1) { that._customTags.push(tag); } }); } tagsContent = taskTags.map(tag => `<span class="lw-kanban-task-tag" role="listitem">${tag}</span>`).join(''); } else { data.tags = ''; } if (typeof data.priority === 'string') { data.priority = data.priority.toLowerCase(); } if (data.priority !== 'high' && data.priority !== 'low') { data.priority = 'normal'; } if (!data.comments || !Array.isArray(data.comments)) { data.comments = []; } task.innerHTML = `<div class="lw-kanban-task-content" role="presentation"> <div class="lw-kanban-task-text ${data.priority}">${text}</div> <div class="lw-kanban-task-user"${tabindex} role="button" aria-haspopup="listbox"></div> </div> <div class="lw-kanban-task-info" role="presentation"> <div class="lw-kanban-task-progress-container"> <div class="lw-kanban-task-progress" role="progressbar" aria-label="Task progress" aria-valuemin="0" aria-valuemax="100"></div> <div class="lw-kanban-task-checked" aria-label="Completed sub-tasks"></div> </div> <div class="lw-kanban-task-due" aria-label="Task due date"></div> </div> <div class="lw-kanban-task-footer" role="toolbar" aria-label="Task footer"> <div class="lw-kanban-task-tags" role="list" aria-label="Tags list">${tagsContent}</div> <div class="lw-kanban-task-actions"${tabindex} role="button" aria-haspopup="menu" aria-label="Open actions list"></div> <div class="lw-kanban-task-comments"${tabindex} num="${data.comments.length || ''}" role="button" aria-haspopup="dialog" aria-label="Open comments list"></div> </div>`; task.setAttribute('aria-label', data.text); } /** * Applies text template. */ _applyTextTemplate(text, data, task) { let template = this.textTemplate; if (!template) { return text; } let result = ''; if (typeof template === 'function') { const settings = { data: data, task: task, text: text, template: null }; template(settings); text = settings.text; if (settings.template === null) { return text; } template = settings.template; } if (template.startsWith('#')) { const templateElement = document.querySelector(template); if (templateElement && templateElement instanceof HTMLTemplateElement) { const templateContent = templateElement.content.cloneNode(true), tempElement = document.createElement('div'); tempElement.appendChild(templateContent); text = text.toString(); text = text.replace(/'/ig, '\\\''); text = text.replace(/"/ig, '\\"'); result = tempElement.innerHTML.replace(/{{text}}/ig, text).replace(/{{id}}/ig, data.id); if (result.indexOf('{{text=') >= 0) { if (!text) { result = result.replace(/{{text=/ig, ''); result = result.replace(/}}/ig, ''); } else { result = result.substring(0, result.indexOf('{{text=')) + text + result.substring(result.indexOf('}')); result = result.replace(/}/ig, ''); result = result.replace(/{/ig, ''); } } return result; } } result = template.replace(/{{text}}/ig, text).replace(/{{id}}/ig, data.id); return result; } /** * Updates a task's user icon. */ _updateUserIcon(task) { const data = task.data, userIcon = task.getElementsByClassName('lw-kanban-task-user')[0]; if (data.userId !== undefined && data.userId !== null) { const user = this.users.find(user => user.id === data.userId); if (user) { userIcon.classList.remove('empty'); userIcon.style.backgroundImage = 'url("' + user.image + '")'; userIcon.setAttribute('aria-label', 'Icon of user ' + (user.name || user.id)); return; } } data.userId = null; userIcon.classList.add('empty'); userIcon.style.backgroundImage = null; userIcon.setAttribute('aria-label', 'Empty user icon'); } /** * Updates a task's progress. */ _updateTaskProgress(task) { const data = task.data, progressBar = task.querySelector('.lw-kanban-task-progress'); let progress = data.progress; if (progress === undefined) { data.progress = null; progressBar.setAttribute('aria-valuenow', 0); return; } progress = parseFloat(progress); if (isNaN(progress)) { data.progress = null; progressBar.setAttribute('aria-valuenow', 0); return; } progress = Math.max(0, Math.min(parseFloat(progress), 100)); data.progress = progress; progressBar.style.width = progress + '%'; progressBar.classList.toggle('bottom', data.checklist !== null); progressBar.setAttribute('aria-valuenow', progress); } /** * Updates checked subtask number. */ _updateTaskChecked(task) { const data = task.data, checklist = data.checklist, checked = task.querySelector('.lw-kanban-task-checked'); if (checklist && Array.isArray(checklist) && checklist.length > 0) { checked.innerHTML = this._getCompletedSubTasks(checklist); } else { data.checklist = null; checked.innerHTML = ''; } } /** * Gets a string representing the number of completed sub-tasks. */ _getCompletedSubTasks(checklist) { if (checklist === null) { return ''; } let completedTasks = 0; checklist.forEach(subTask => subTask.completed && completedTasks++); return completedTasks + '/' + checklist.length; } /** * Updates a task's due date. */ _updateTaskDueDate(task) { const data = task.data, dueDate = data.dueDate, dateContainer = task.querySelector('.lw-kanban-task-due'); if (dueDate) { dateContainer.innerHTML = new LW.Utilities.DateTime(dueDate).toString(this.formatStringDate); dateContainer.classList.toggle('overdue', dueDate.getTime() < new Date().getTime() && data.progress !== 100); } else { data.dueDate = null; dateContainer.innerHTML = ''; dateContainer.classList.remove('overdue'); } if (!data.startDate) { data.startDate = null; } } /** * Updates a task's color. */ _updateTaskColor(task) { const that = this, data = task.data, progressContainer = task.querySelector('.lw-kanban-task-progress-container'), progress = task.querySelector('.lw-kanban-task-progress'), borderColor = that.rightToLeft ? 'borderRightColor' : 'borderLeftColor'; function hex(dec) { let hex = parseFloat(dec).toString(16); hex = '0'.repeat(2 - hex.length) + hex; return hex.toUpperCase(); } function toHex(rgb) { rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/); if (!rgb) { return null; } return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]); } task.style.borderLeftColor = null; task.style.borderRightColor = null; if (data.color) { task.style[borderColor] = data.color; const color = getComputedStyle(task)[borderColor], alpha = that.theme === 'dark' ? 0.4 : 0.1; data.color = toHex(color); progressContainer.style.backgroundColor = `rgba(${color.slice(4, color.length - 1)}, ${alpha})`; progress.style.backgroundColor = color; } else { data.color = null; progressContainer.style.backgroundColor = null; progress.style.backgroundColor = null; } } /** * Validates swimlanes. */ _validateSwimlanes() { const that = this, swimlanesFrom = that.swimlanesFrom, swimlanesTo = that.swimlanesTo, validSwimlanes = []; if (swimlanesFrom < 0) { that.swimlanesFrom = 0; } if (swimlanesTo !== null) { if (swimlanesFrom > swimlanesTo) { that.swimlanesFrom = swimlanesTo; } } that.swimlanes.forEach(swimlane => { if (typeof swimlane === 'string') { swimlane = { dataField: swimlane, label: swimlane }; } if (!swimlane.dataField && !swimlane.label) { return; } if (!swimlane.label) { swimlane.label = swimlane.dataField; } if (!swimlane.dataField) { swimlane.dataField = swimlane.label; } validSwimlanes.push(swimlane); }); that.swimlanes = validSwimlanes; } /** * Handles swimlane creation and positioning. */ _handleSwimlanes(update) { const that = this, swimlanes = that.swimlanes; if (swimlanes.length === 0 || that.columns.length === 0) { return; } const columns = that.columns, headerSize = parseFloat(getComputedStyle(that).getPropertyValue('--lw-kanban-header-size')), container = that.$.container, containerRect = that.$.container.getBoundingClientRect(), columnsWithSwimlanes = that.$.container.querySelectorAll('.lw-kanban-column.has-swimlane'); let firstColumn = columnsWithSwimlanes[0], lastColumn = columnsWithSwimlanes[columnsWithSwimlanes.length - 1]; if (that.rightToLeft) { let temp = firstColumn; firstColumn = lastColumn; lastColumn = temp; } const firstColumnRect = firstColumn.getBoundingClientRect(), lastColumnRect = columnsWithSwimlanes.length > 1 ? lastColumn.getBoundingClientRect() : firstColumnRect, scrollViewers = Array.from(firstColumn.getElementsByTagName('lw-scroll-viewer')); let restoreCollapsed = false, allColumnsCollapsed = true, to = that.swimlanesTo, swimlaneElements, width, left, tops; if (to === null) { to = columns.length - 1; } if (update) { swimlaneElements = container.getElementsByClassName('swimlane'); } if (firstColumn.column.collapsed) { firstColumn.classList.remove('collapsed'); restoreCollapsed = true; } for (let i = that.swimlanesFrom; i <= to; i++) { allColumnsCollapsed = allColumnsCollapsed && columns[i].collapsed; } if (!allColumnsCollapsed) { width = lastColumnRect.right - firstColumnRect.left + 'px'; left = firstColumnRect.left - containerRect.left + 'px'; tops = scrollViewers.map(scrollViewer => scrollViewer.getBoundingClientRect().top - containerRect.top - headerSize - that._dataViewPadding + 'px'); } swimlanes.forEach((swimlane, index) => { let swimlaneElement; if (update) { swimlaneElement = swimlaneElements[index]; } else { swimlaneElement = document.createElement('div'); swimlaneElement.innerHTML = `<div class="swimlane-label">${swimlane.label}</div>`; swimlaneElement.className = 'swimlane'; swimlaneElement.setAttribute('role', 'heading'); swimlaneElement.setAttribute('aria-level', 2); if (swimlane.color) { swimlaneElement.style.backgroundColor = swimlane.color; } } swimlaneElement.classList.toggle('lw-visibility-hidden', allColumnsCollapsed); if (!allColumnsCollapsed) { swimlaneElement.style.width = width; swimlaneElement.style.left = left; swimlaneElement.style.top = tops[index]; } if (!update) { container.appendChild(swimlaneElement); } }); if (restoreCollapsed) { firstColumn.classList.add('collapsed'); } } /** * Renders Kanban columns. */ _renderColumns() { const that = this, collapsibleColumns = that.collapsible, validColumns = [], body = that.$.body, structure = document.createDocumentFragment(); let columns = that.columns; that._columnToElement = new Map(); that._columnContainers = []; if (columns.length === 0) { const dataSource = that.dataSource; if (dataSource && dataSource.length !== 0) { columns = []; dataSource.forEach(data => { const status = data.status; if (status && columns.indexOf(status) === -1) { columns.push(status); } }); } } function validateSiblingColumns(originalArray, validArray, level) { const selectedTabs = []; let collapsedSiblings = 0; originalArray.forEach((column) => { if (typeof column === 'string') { column = { dataField: column, label: column }; } if (!column.dataField && !column.label) { return; } if (!column.label) { column.label = column.dataField; } if (!column.dataField) { column.dataField = column.label; } if (column.orientation !== 'horizontal') { column.orientation = 'vertical'; } if (column.collapsible !== false) { column.collapsible = true; } if (!column.collapsed || !collapsibleColumns || !column.collapsible) { column.collapsed = false; } else { collapsedSiblings++; } if (column.addNewButton !== false) { column.addNewButton = true; } if (level === 0) { delete column.selected; } else if (column.selected === true) { selectedTabs.push(column); } else { column.selected = false; } if (column.columns) { column.validColumns = []; validateSiblingColumns(column.columns, column.validColumns, level + 1); column.columns = column.validColumns; delete column.validColumns; } validArray.push(column); }); if (collapsedSiblings && collapsedSiblings === validArray.length) { validArray[0].collapsed = false; } if (selectedTabs.length > 1) { for (let i = selectedTabs.length - 2; i >= 0; i--) { selectedTabs[i].selected = false; } } else if (level > 0 && selectedTabs.length === 0 && validArray.length > 0) { validArray[0].selected = true; } } validateSiblingColumns(columns, validColumns, 0); that.columns = validColumns; if (that.swimlanes.length === 0) { if (that.hierarchy === 'columns') { that._createColumnElements(validColumns, structure, body, 1); } else { that._createColumnElementsTabs(validColumns, structure, body); } } else { that._createColumnElementsSwimlanes(validColumns, structure, body); } body.appendChild(structure); that._selectedTabs = that._allColumns.filter(column => column.selected).map(column => column.dataField); that._autoSaveState('tabs'); } /** * Creates column elements (no swimlanes). */ _createColumnElements(siblingColumns, parent, container, level) { const that = this, id = that.id, gridTemplateColumns = [], columnFractions = []; let numberOfColumns = 0; siblingColumns.forEach((column, index) => { const columnElement = document.createElement('div'); let innerHTML = `${that._getColumnHeader(column, index < siblingColumns.length - 1, level)} <div class="lw-kanban-column-contentAAA" role="presentation"> <lw-scroll-viewer class="lw-kanban-column-content-tasks"${that._rtlAttr}${that._tabindex} role="list"></lw-scroll-viewer>BBB </div>`, numberOfLeafColumns = 0; if (column.columns) { innerHTML = innerHTML.replace('AAA', ''); innerHTML = innerHTML.replace('BBB', '<div class="lw-kanban-column-content-columns" role="presentation"></div>'); } else { innerHTML = innerHTML.replace('AAA', ' no-sub-columns'); innerHTML = innerHTML.replace('BBB', ''); } columnElement.className = 'lw-kanban-column'; columnElement.setAttribute('role', 'group'); columnElement.setAttribute('aria-labelledby', `${id}ColumnHeaderLabel${column.dataField}`); columnElement.setAttribute('orientation', column.orientation); if (column.collapsible) { columnElement.setAttribute('collapsible', ''); } if (column.addNewButton) { columnElement.setAttribute('add-new-button', ''); } columnElement.innerHTML = innerHTML; columnElement.siblingColumns = siblingColumns; parent.appendChild(columnElement); columnElement.column = column; columnElement.index = index; that._columnToElement.set(column, columnElement); if (column.columns) { const innerColumnContainer = columnElement.querySelector('.lw-kanban-column-content-columns'); numberOfLeafColumns = that._createColumnElements(column.columns, innerColumnContainer, innerColumnContainer, level + 1); numberOfColumns += numberOfLeafColumns; } else { numberOfColumns += 1; } const fraction = (numberOfLeafColumns || 1) + 'fr'; if (column.collapsed) { columnElement.classList.add('collapsed'); gridTemplateColumns.push('auto'); } else { gridTemplateColumns.push(fraction); } columnFractions.push(fraction); that._allColumns.push(column); }); container.style.gridTemplateColumns = gridTemplateColumns.join(' '); container.fractions = columnFractions; that._columnContainers.push(container); return numberOfColumns; } /** * Creates column elements with tabs for sub-columns (no swimlanes). */ _createColumnElementsTabs(siblingColumns, parent, container, tabs) { const that = this, id = that.id, gridTemplateColumns = [], columnFractions = []; siblingColumns.forEach((column, index) => { const columnElement = document.createElement('div'); let innerHTML = `<div class="lw-kanban-column-contentAAA" role="presentation"> <lw-scroll-viewer class="lw-kanban-column-content-tasks"${that._rtlAttr}${that._tabindex} role="list"></lw-scroll-viewer>BBB </div>`; if (column.columns) { innerHTML = innerHTML.replace('AAA', ''); innerHTML = innerHTML.replace('BBB', '<div class="lw-kanban-column-content-columns has-tabs" role="presentation"></div>'); } else { innerHTML = innerHTML.replace('AAA', ' no-sub-columns'); innerHTML = innerHTML.replace('BBB', ''); } columnElement.className = 'lw-kanban-column'; columnElement.setAttribute('orientation', column.orientation); if (column.collapsible) { columnElement.setAttribute('collapsible', ''); } if (column.addNewButton) { columnElement.setAttribute('add-new-button', ''); } if (tabs) { const tab = document.createElement('div'), tabId = `${id}Tab${column.dataField}`, columnElementId = `${id}Column${column.dataField}`; tab.id = tabId; tab.className = 'lw-kanban-tab lw-unselectable'; if (!that.disabled && !that.unfocusable) { tab.tabIndex = 0; } tab.setAttribute('role', 'tab'); tab.setAttribute('aria-controls', columnElementId); tab.innerHTML = `<div class="lw-kanban-tab-label">${column.label}</div>`; tab.columnElement = columnElement; columnElement.id = columnElementId; columnElement.setAttribute('role', 'tabpanel'); columnElement.setAttribute('aria-labelledby', tabId); columnElement.tab = tab; tabs.appendChild(tab); if (column.selected) { tab.classList.add('selected'); } else { columnElement.classList.add('lw-hidden'); } tab.setAttribute('aria-selected', column.selected); } else { innerHTML = that._getColumnHeader(column, index < siblingColumns.length - 1) + innerHTML; columnElement.setAttribute('role', 'group'); columnElement.setAttribute('aria-labelledby', `${id}ColumnHeaderLabel${column.dataField}`); } columnElement.innerHTML = innerHTML; columnElement.siblingColumns = siblingColumns; parent.appendChild(columnElement); columnElement.column = column; columnElement.index = index; that._columnToElement.set(column, columnElement); if (column.columns) { const innerColumnContainer = columnElement.querySelector('.lw-kanban-column-content-columns'), ownTabs = document.createElement('div'); ownTabs.className = 'lw-kanban-tab-strip'; ownTabs.setAttribute('role', 'tablist'); innerColumnContainer.appendChild(ownTabs); that._createColumnElementsTabs(column.columns, innerColumnContainer, innerColumnContainer, ownTabs); } if (!tabs) { if (column.collapsed) { columnElement.classList.add('collapsed'); gridTemplateColumns.push('auto'); } else { gridTemplateColumns.push('1fr'); } columnFractions.push('1fr'); } that._allColumns.push(column); }); if (!tabs) { container.style.gridTemplateColumns = gridTemplateColumns.join(' '); container.fractions = columnFractions; that._columnContainers.push(container); } } /** * Creates column elements (with swimlanes). */ _createColumnElementsSwimlanes(siblingColumns, parent, container) { const that = this, id = that.id, swimlanes = that.swimlanes, gridTemplateColumns = [], columnFractions = []; siblingColumns.forEach((column, index) => { const columnElement = document.createElement('div'); let innerHTML = `${that._getColumnHeader(column, index < siblingColumns.length - 1)} <div class="lw-kanban-column-content no-sub-columns" role="presentation"></div>`; columnElement.className = 'lw-kanban-column'; columnElement.setAttribute('role', 'group'); columnElement.setAttribute('aria-labelledby', `${id}ColumnHeaderLabel${column.dataField}`); columnElement.setAttribute('orientation', column.orientation); if (column.collapsible) { columnElement.setAttribute('collapsible', ''); } if (column.addNewButton) { columnElement.setAttribute('add-new-button', ''); } columnElement.innerHTML = innerHTML; columnElement.siblingColumns = siblingColumns; const columnContent = columnElement.children[1]; let columnContentInnerHTML = ''; if (!that._hasSwimlane(index)) { columnContentInnerHTML = `<lw-scroll-viewer class="lw-kanban-column-content-tasks"${that._rtlAttr}${that._tabindex} role="list"></lw-scroll-viewer>`; } else { let gridTemplateRows = []; for (let i = 0; i < swimlanes.length; i++) { columnContentInnerHTML += `<lw-scroll-viewer class="lw-kanban-column-content-tasks" swimlane="${swimlanes[i].dataField}"${that._rtlAttr}${that._tabindex} role="list"></lw-scroll-viewer>`; gridTemplateRows.push('1fr'); } columnElement.classList.add('has-swimlane'); columnContent.classList.add('has-swimlane'); columnContent.style.gridTemplateRows = gridTemplateRows.join(' '); } columnContent.innerHTML = columnContentInnerHTML; parent.appendChild(columnElement); columnElement.column = column; columnElement.index = index; that._columnToElement.set(column, columnElement); if (column.collapsed) { columnElement.classList.add('collapsed'); gridTemplateColumns.push('auto'); } else { gridTemplateColumns.push('1fr'); } columnFractions.push('1fr'); that._allColumns.push(column); }); container.style.gridTemplateColumns = gridTemplateColumns.join(' '); container.fractions = columnFractions; that._columnContainers.push(container); } /** * Returns the HTML of a column's header. */ _getColumnHeader(column, left, level = 1) { const that = this, tabindex = that._tabindex; return `<div class="lw-kanban-column-header lw-unselectable"${tabindex} role="heading" aria-level=${level}> <div class="lw-kanban-column-header-add"${tabindex} role="button" aria-label="Add new task"></div> <div id="${that.id}ColumnHeaderLabel${column.dataField}" class="lw-kanban-column-header-label">${column.label}</div> <div class="lw-arrow lw-arrow-${left ? 'left' : 'right'}" aria-hidden="true"></div> </div>`; } /** * Determines whether there are swimlanes in a column. */ _hasSwimlane(columnIndex) { const that = this, swimlanes = that.swimlanes; if (swimlanes.length === 0) { return false; } const swimlanesFrom = that.swimlanesFrom; let swimlanesTo = that.swimlanesTo; if (swimlanesTo === null) { swimlanesTo = that.columns.length - 1; } return columnIndex >= swimlanesFrom && columnIndex <= swimlanesTo; } /** * Updates column widths. */ _updateColumnWidths(columns, container) { const fractions = container.fractions, gridTemplateColumns = []; for (let i = 0; i < columns.length; i++) { gridTemplateColumns.push(columns[i].collapsed ? 'auto' : fractions[i]); } container.style.gridTemplateColumns = gridTemplateColumns.join(' '); } /** * Validates the column argument passed to a public method. */ _validateColumnArgument(column) { if (!isNaN(column)) { return this.columns[column]; } const allColumns = this._allColumns; if (typeof column === 'string') { return allColumns.find(col => col.dataField === column); } if (typeof column === 'object') { return allColumns.find(col => col === column); } return null; } /** * resize handler. */ _resizeHandler() { const that = this; clearTimeout(that._resizeTimeout); that._resizeTimeout = setTimeout(function () { that._allColumns.forEach(column => that._refreshScrollViewer(column)); }, 50); that._handleSwimlanes(true); } /** * Refreshes a column's ScrollViewer. */ _refreshScrollViewer(column, force) { const that = this, columnElement = column instanceof HTMLElement ? column : this._columnToElement.get(column); function refresh(scrollViewer, index) { if (!force && scrollViewer.$.scrollViewerContentContainer.innerHTML.trim() === '') { return; } if (column.collapsed) { scrollViewer.toRefresh = true; } else { delete scrollViewer.toRefresh; requestAnimationFrame(() => { scrollViewer.refresh(); if (index === 0 && column.orientation === 'horizontal') { if (scrollViewer.$.content.offsetWidth <= 2 * that._kanbanTaskMinWidth + that._dataViewPadding) { columnElement.setAttribute('orientation', 'vertical'); } else if (columnElement.getAttribute('orientation') === 'vertical') { columnElement.setAttribute('orientation', 'horizontal'); } } }); } } if (column instanceof LW.ScrollViewer) { refresh(column); return; } if (this.swimlanes.length > 0) { Array.from(columnElement.querySelectorAll('lw-scroll-viewer')).forEach((scrollViewer, index) => refresh(scrollViewer, index)); } else { refresh(columnElement.querySelector('lw-scroll-viewer'), 0); } } /** * Container down handler. */ _containerDownHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.originalEvent.composedPath()[0] : event.originalEvent.target, task = target.closest('.lw-kanban-task'); delete that._preventSelection; if (task) { that._focusTask(task); that._startDragging(task, event); } } /** * Container keydown handler */ _containerKeydownHandler(event) { const that = this; if (that._dragDetails) { return; } const key = event.key, target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target, columnElement = target.closest('.lw-kanban-column'); function emulateClick(t = target) { delete that._preventSelection; that._documentUpHandler({ originalEvent: { target: t } }); that._containerClickHandler({ target: t, ctrlKey: event.ctrlKey, shiftKey: event.shiftKey }); event.preventDefault(); } if (columnElement) { if (target.classList.contains('lw-kanban-column-content-tasks')) { that._selectViaKeyboard(target.$.content, event, emulateClick); return; } else if (key === 'Enter' || key === ' ') { emulateClick(); } return; } if (that.$.headerDropDown.contains(target)) { if (key === 'Escape') { that.closePanel(); that.$[/\s?([a-z]+)-panel/g.exec(that.$.headerDropDown.className)[1] + 'Button'].focus(); } return; } if ((target.classList.contains('lw-data-view-header-button') || target.closest('.lw-data-view-search-box') || target.classList.contains('remove-button')) && (key === 'Enter' || key === ' ')) { emulateClick(); } if (target.classList.contains('lw-kanban-list')) { const list = target; switch (key) { case 'ArrowDown': that._selectListItem(that._getNextItem(list)); break; case 'ArrowUp': that._selectListItem(that._getPrevItem(list)); break; case 'Home': that._selectListItem(that._getFirstItem(list)); break; case 'End': that._selectListItem(that._getLastItem(list)); break; case 'Escape': list.openedFrom.focus(); that._closeList(list, list === that._actionsList ? '_actionSelectionFor' : (list === that._commentsList ? '_commentSelectionFor' : '_userSelectionFor')); break; case 'Enter': case ' ': { const selectedItem = that._getSelectedItem(list); if (selectedItem) { emulateClick(selectedItem); } break; } default: return; } event.preventDefault(); return; } } /** * Selects task(s) via keyboard. */ _selectViaKeyboard(container, event, emulateClick) { const that = this; let key = event.key; if (that.rightToLeft) { if (key === 'ArrowRight') { key = 'ArrowLeft'; } else if (key === 'ArrowLeft') { key = 'ArrowRight'; } } switch (key) { case 'ArrowDown': case 'ArrowRight': that._focusTask(that._getNextItem(container, true)); break; case 'ArrowUp': case 'ArrowLeft': that._focusTask(that._getPrevItem(container, true)); break; case 'Home': that._focusTask(that._getFirstItem(container)); break; case 'End': that._focusTask(that._getLastItem(container)); break; case 'Enter': case ' ': case 'F2': case 'Delete': { const focusedItem = that._getSelectedItem(container, true); if (focusedItem) { if (key === 'F2') { that.beginEdit(focusedItem); } else if (key === 'Delete') { that.removeTask(focusedItem, true); } else { emulateClick(focusedItem); } } break; } default: return; } event.preventDefault(); } /** * Gets first enabled item from a list. */ _getFirstItem(list) { const items = list.children; for (let i = 0; i < items.length; i++) { const item = items[i]; if (!item.hasAttribute('disabled') && getComputedStyle(item).display !== 'none') { return item; } } } /** * Gets last enabled item from a list. */ _getLastItem(list) { const items = list.children; for (let i = items.length - 1; i >= 0; i--) { const item = items[i]; if (!item.hasAttribute('disabled') && getComputedStyle(item).display !== 'none') { return item; } } } /** * Gets previous enabled item from a list. */ _getPrevItem(list, task) { const that = this, selectedItem = that._getSelectedItem(list, task); let prev = selectedItem ? selectedItem.previousElementSibling : that._getLastItem(list); while (prev) { if (!prev.hasAttribute('disabled') && getComputedStyle(prev).display !== 'none') { return prev; } prev = prev.previousElementSibling; } } /** * Gets next enabled item from a list. */ _getNextItem(list, task) { const that = this, selectedItem = that._getSelectedItem(list, task); let next = selectedItem ? selectedItem.nextElementSibling : that._getFirstItem(list); while (next) { if (!next.hasAttribute('disabled') && getComputedStyle(next).display !== 'none') { return next; } next = next.nextElementSibling; } } /** * Gets selected item from a list. */ _getSelectedItem(list, task) { if (task) { return list.querySelector('[focus]'); } return list.querySelector('.selected'); } /** * Selects an item from a list. */ _selectListItem(item) { if (!item) { return; } const list = item.parentElement, previouslySelected = list.querySelector('.selected'); if (previouslySelected) { previouslySelected.classList.remove('selected'); previouslySelected.removeAttribute('aria-selected'); } item.classList.add('selected'); item.setAttribute('aria-selected', true); list.scrollTop = item.offsetTop; } /** * Focuses a task. */ _focusTask(task) { if (!task) { return; } const previouslyFocused = Array.from(task.parentElement.querySelectorAll('[focus]')); previouslyFocused.forEach(focusedTask => focusedTask.removeAttribute('focus')); task.setAttribute('focus', ''); this.ensureVisible(task); } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this, container = that.$.container, unfocusable = that.disabled || that.unfocusable; let elements = [ that.$.customizeButton, that.$.filterButton, that.$.sortButton, that.$.searchButton, that.$.searchPrev, that.$.searchNext, that.$.searchClose, that._actionsList, that._userList ]; elements = elements.concat(Array.from( container.querySelectorAll('.lw-kanban-column-header, .lw-kanban-column-header-add, .lw-kanban-tab, .lw-kanban-column-content-tasks, .lw-kanban-task-user, .lw-kanban-task-actions, .lw-kanban-task-comments'))); elements.forEach(element => { if (unfocusable) { element.removeAttribute('tabindex'); } else if (element.getAttribute('tabindex') === null || element.getAttribute('tabindex') < 0) { element.setAttribute('tabindex', 0); } }); if (that._dialog && that._dialog.editPanelPopulated) { const nativeElements = Array.from(that._dialog.$.container.querySelectorAll('.text-editor, .new-subtask')); if (unfocusable) { nativeElements.forEach(element => element.tabIndex = -1); } else { nativeElements.forEach(element => element.removeAttribute('tabindex')); } Array.from(that._dialog.$.container.querySelectorAll('.lw-element.editor, lw-button.add, lw-button.ok, lw-button.cancel')).forEach(element => element.unfocusable = unfocusable); that._dialog.unfocusable = unfocusable; } } /** * Starts dragging operation */ _startDragging(pressedTask, event) { const that = this; if (!that._currentUser.allowDrag) { return; } const scrollViewer = pressedTask.closest('lw-scroll-viewer'), rect = pressedTask.getBoundingClientRect(); let items = pressedTask.hasAttribute('selected') ? Array.from(pressedTask.parentElement.querySelectorAll('[selected]')) : [pressedTask]; that._dragDetails = { StartPosition: { left: event.pageX, top: event.pageY }, Items: items, Item: pressedTask, FeedbackShown: false, OriginalEvent: event, PointerOffset: [rect.x - event.clientX, rect.y - event.clientY], ScrollViewer: scrollViewer, StartTime: new Date(), Dragging: true }; LW.Kanban.kanbanTaskDragged = true; scrollViewer._scrollView.disableSwipeScroll = true; if (that.allowDrop) { LW.Kanban.hoveredKanban = that; LW.Kanban.hoveredItem = pressedTask; } } /** * document move handler. */ _documentMoveHandler(event) { const that = this, dragDetails = that._dragDetails; function clear() { delete that._dragDetails; delete LW.Kanban.kanbanTaskDragged; delete LW.Kanban.hoveredKanban; delete LW.Kanban.hoveredItem; dragDetails.ScrollViewer._scrollView.disableSwipeScroll = false; } if (!dragDetails) { return; } if (!dragDetails.FeedbackShown) { const now = new Date(), timePassed = now.getTime() - dragDetails.StartTime.getTime() > 500, moved = Math.abs(dragDetails.StartPosition.left - event.pageX) > 5 || Math.abs(dragDetails.StartPosition.top - event.pageY) > 5; if (moved && (!that._isMobile || that._isMobile && timePassed)) { const dragStartEvent = that.$.fireEvent('dragStart', { 'item': dragDetails.Item, 'items': dragDetails.Items, 'data': dragDetails, 'container': that, 'previousContainer': that, 'originalEvent': dragDetails.OriginalEvent }); if (dragStartEvent.defaultPrevented) { clear(); return; } that.closePanel(); that._hideBodyOverflow(); dragDetails.Feedback = that._addDragFeedback(); dragDetails.FeedbackShown = true; dragDetails.Items.forEach(item => item.classList.add('dragged')); } else { if (that._isMobile && moved && !timePassed) { clear(); } return; } } let dragOffset = that.dragOffset, realTarget; dragOffset = dragOffset === 'auto' || !Array.isArray(dragOffset) ? dragDetails.PointerOffset : dragOffset; that.$.fireEvent('dragging', { 'item': dragDetails.Item, 'items': dragDetails.Items, 'data': dragDetails, 'originalEvent': event }); dragDetails.Feedback.style.left = (event.pageX + (dragOffset[0] || 0)) + 'px'; dragDetails.Feedback.style.top = (event.pageY + (dragOffset[1] || 0)) + 'px'; if (LW.Kanban.hoveredKanban) { clearInterval(LW.Kanban.hoveredKanban._dragInterval); delete LW.Kanban.hoveredKanban; } if (LW.Kanban.hoveredItem) { LW.Kanban.hoveredItem.classList.remove('drop-target'); LW.Kanban.hoveredItem.classList.remove('before', 'after'); delete LW.Kanban.hoveredItem; } if (that._isMobile) { realTarget = (that.shadowRoot || that.getRootNode()).elementFromPoint(event.clientX, event.clientY); } else { realTarget = that.isInShadowDOM || that.shadowRoot ? event.originalEvent.composedPath()[0] : event.originalEvent.target; } if (!realTarget) { return; } const hoveredKanban = (that.shadowRoot ? realTarget.getRootNode().host : realTarget).closest('lw-kanban'); if (!hoveredKanban || !hoveredKanban.allowDrop) { return; } const hoveredScrollViewer = realTarget.closest('.lw-kanban-column-content-tasks'); LW.Kanban.hoveredKanban = hoveredKanban; if (!hoveredScrollViewer) { return; } const orientation = hoveredScrollViewer.parentElement.parentElement.getAttribute('orientation'), siblingTasks = Array.from(hoveredScrollViewer.$.content.children); let numberOfFiteredOut = 0; siblingTasks.forEach(sibling => sibling.filteredOut && numberOfFiteredOut++); if (siblingTasks.length === 0 || siblingTasks.length === numberOfFiteredOut) { LW.Kanban.hoveredItem = hoveredScrollViewer.$.scrollViewerContainer; LW.Kanban.hoveredItem.classList.add('drop-target'); return; } if (hoveredScrollViewer.scrollHeight > 0) { hoveredKanban._dragInterval = setInterval(function () { const rect = hoveredScrollViewer.getBoundingClientRect(); if (rect.left <= event.clientX && rect.left + rect.width >= event.clientX) { if (event.clientY >= rect.top && event.clientY <= rect.top + 20) { hoveredScrollViewer.scrollTop -= that._autoScrollCoefficient; } else if (event.clientY >= rect.top + rect.height - 20 && event.clientY <= rect.top + rect.height) { hoveredScrollViewer.scrollTop += that._autoScrollCoefficient; } else { clearInterval(hoveredKanban._dragInterval); } } else { clearInterval(hoveredKanban._dragInterval); } }, 2); } let hoveredItem = realTarget.closest('.lw-kanban-task'); if (!hoveredItem || dragDetails.Items.indexOf(hoveredItem) !== -1) { if (hoveredItem && siblingTasks.length === 1) { return; } if (hoveredItem && dragDetails.Items.length === 1) { hoveredItem = that[`_${orientation}ClosestTaskToHover`]( [hoveredItem.previousElementSibling, hoveredItem.nextElementSibling], event, true ); } else { hoveredItem = that[`_${orientation}ClosestTaskToHover`]( siblingTasks, event, hoveredItem || realTarget === hoveredScrollViewer.$.content ); } } else { const hoveredItemRect = hoveredItem.getBoundingClientRect(); if (orientation === 'vertical' && event.clientY - hoveredItemRect.top <= hoveredItemRect.height / 2 || orientation === 'horizontal' && event.clientX - hoveredItemRect.left <= hoveredItemRect.width / 2) { hoveredItem.classList.add('before'); } else { hoveredItem.classList.add('after'); } } if (hoveredItem) { hoveredItem.classList.add('drop-target'); LW.Kanban.hoveredItem = hoveredItem; } } /** * Hides body overflow. */ _hideBodyOverflow() { const that = this, isVerticalScrollable = (document.scrollingElement || document.documentElement).scrollHeight > document.documentElement.clientHeight, isHorizontalScrollable = (document.scrollingElement || document.documentElement).scrollWidth > document.documentElement.clientWidth; const body = that.isInShadowDOM ? that.getRootNode().host : document.body; that._originalBodyOverflow = { overflowX: body.style.overflowX, overflowY: body.style.overflowY, overflow: body.style.overflow }; body.classList.add('lw-dragging'); body.style.overflow = body.style.overflowX = body.style.overflowY = ''; if (isVerticalScrollable && !isHorizontalScrollable) { body.style.overflowX = 'hidden'; } else if (isHorizontalScrollable && !isVerticalScrollable) { body.style.overflowY = 'hidden'; } else if (!isHorizontalScrollable && !isVerticalScrollable) { body.style.overflow = 'hidden'; } } /** * Gets the closest task to hover (vertical orientation). */ _verticalClosestTaskToHover(tasks, event, fromTop) { const draggedTasks = this._dragDetails.Items, clientY = event.clientY; let shortestDistance = Infinity, from = 0, to = tasks.length - 1, increaseBy = 1, nearestTask, className; if (!fromTop) { from = to; to = 0; increaseBy = -1; } while (from !== to + increaseBy) { const currentTask = tasks[from]; from += increaseBy; if (!currentTask || currentTask.filteredOut || draggedTasks.indexOf(currentTask) !== -1) { continue; } if (!fromTop) { nearestTask = currentTask; className = 'after'; break; } const rect = currentTask.getBoundingClientRect(), rectInfo = rect.top + rect.height / 2, currentDistance = Math.abs(clientY - rectInfo); if (currentDistance < shortestDistance) { shortestDistance = currentDistance; nearestTask = currentTask; className = clientY <= rectInfo ? 'before' : 'after'; } else { break; } } if (nearestTask) { nearestTask.classList.add(className); } return nearestTask; } /** * Gets the closest task to hover (horizontal orientation). */ _horizontalClosestTaskToHover(tasks, event) { const draggedTasks = this._dragDetails.Items, y = event.clientY, x = event.clientX; let closest, closestDistance, side; tasks.forEach(currentTask => { if (!currentTask || currentTask.filteredOut || draggedTasks.indexOf(currentTask) !== -1) { return; } const rect = currentTask.getBoundingClientRect(), topDistance = Math.abs(y - rect.top), bottomDisatnce = Math.abs(y - rect.bottom), bestVerticalDistance = Math.min(topDistance, bottomDisatnce), leftDistance = Math.abs(x - rect.left), rightDistance = Math.abs(x - rect.right), bestHorizontalDistance = Math.min(leftDistance, rightDistance), overallDistance = Math.sqrt(Math.pow(bestHorizontalDistance, 2) + Math.pow(bestVerticalDistance, 2)); if (closestDistance === undefined || overallDistance < closestDistance) { closest = currentTask; closestDistance = overallDistance; side = leftDistance < rightDistance ? 'before' : 'after'; } }); if (closest) { closest.classList.add(side); } return closest; } /** * ScrollViewer touchmove handler. */ _scrollViewerTouchmoveHandler(event) { const that = this; if (!that._dragDetails) { return; } const target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; if (target.closest('lw-scroll-viewer') && event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * Document up handler. */ _documentUpHandler(event) { const that = this, dragDetails = that._dragDetails; if (that.$.container.hasAttribute('modal')) { return; } const target = that.isInShadowDOM || that.shadowRoot ? event.originalEvent.composedPath()[0] : event.originalEvent.target, header = that.$.header; if (that._userSelectionFor && !that._userList.contains(target)) { that._closeList(that._userList, '_userSelectionFor'); } if (that._actionSelectionFor && !that._actionsList.contains(target)) { that._closeList(that._actionsList, '_actionSelectionFor'); } if (that._commentSelectionFor) { const commentsList = that._commentsList; if ((that.shadowRoot || that.getRootNode()).activeElement !== commentsList.textarea) { if (!that._actionSelectionFor && !commentsList.contains(target)) { that._closeList(commentsList, '_commentSelectionFor'); } else if (commentsList.classList.contains('expanded') && target !== commentsList.textarea && !commentsList.button.contains(target) && !target.classList.contains('remove-button')) { commentsList.classList.remove('expanded'); } } } if (that.headerPosition !== 'none' && !that.$.headerDropDown.classList.contains('lw-visibility-hidden') && !that.$.headerDropDown.classList.contains('search-panel') && (target === header || !header.contains(target))) { const closestInputPopup = target.closest('lw-scroll-viewer'), closestDateTimePickerPopup = target.closest('.lw-drop-down'); if ((!closestInputPopup || !header.contains(closestInputPopup.ownerElement)) && (!closestDateTimePickerPopup || closestDateTimePickerPopup.ownerElement && !header.contains(closestDateTimePickerPopup.ownerElement))) { that.closePanel(); } } if (!dragDetails) { return; } const targetKanban = LW.Kanban.hoveredKanban, targetItem = LW.Kanban.hoveredItem; delete that._dragDetails; delete LW.Kanban.kanbanTaskDragged; delete LW.Kanban.hoveredKanban; delete LW.Kanban.hoveredItem; dragDetails.ScrollViewer._scrollView.disableSwipeScroll = false; if (!dragDetails.FeedbackShown) { return; } const dropTarget = targetKanban || (that.shadowRoot || that.getRootNode()).elementFromPoint(event.clientX, event.clientY); that._preventSelection = true; const body = that.isInShadowDOM ? that.getRootNode().host : document.body; body.classList.remove('lw-dragging'); body.style.overflow = that._originalBodyOverflow.overflow; body.style.eoverflowX = that._originalBodyOverflow.overflowX; body.style.overflowY = that._originalBodyOverflow.overflowY; delete that._originalBodyOverflow; dragDetails.Feedback.remove(); if (targetKanban) { clearInterval(targetKanban._dragInterval); } const draggedItem = dragDetails.Item, draggedItems = dragDetails.Items; draggedItems.forEach(item => item.classList.remove('dragged')); if (!dropTarget) { return; } if (!targetItem) { // drops item somewhere in the DOM that.$.fireEvent('dragEnd', { 'item': draggedItem, 'items': draggedItems, 'target': dropTarget, 'data': dragDetails, 'previousContainer': that, 'container': dropTarget, 'originalEvent': event }); return; } if (!(targetKanban && targetKanban.allowDrop && !targetKanban.disabled)) { return; } let dropAfter = false; targetItem.classList.remove('drop-target'); if (targetItem.classList.contains('before')) { targetItem.classList.remove('before'); } else if (targetItem.classList.contains('after')) { targetItem.classList.remove('after'); dropAfter = true; } dragDetails.DropDetails = { item: targetItem, after: dropAfter }; const dragEndEvent = that.$.fireEvent('dragEnd', { 'item': draggedItem, 'items': draggedItems, 'target': targetItem, 'data': dragDetails, 'previousContainer': that, 'container': targetKanban, 'originalEvent': event }); if (dragEndEvent.defaultPrevented) { return; } that._moveDraggedItems(dragDetails); } /** * Adds drag feedback. */ _addDragFeedback() { const that = this, draggedItem = that._dragDetails.Item, numberOfDraggedItems = that._dragDetails.Items.length, feedback = document.createElement('div'), clone = draggedItem.cloneNode(true), width = draggedItem.offsetWidth + 'px', height = draggedItem.offsetHeight + 'px'; clone.style.width = width; clone.style.height = height; feedback.className = 'lw-kanban-feedback'; feedback.setAttribute('parent-kanban-id', that.id); if (that.theme) { feedback.setAttribute('theme', that.theme); } ['rightToLeft', 'taskActions', 'taskComments', 'taskDue', 'taskPriority', 'taskProgress', 'taskTags', 'taskUserIcon'].forEach(propertyName => { if (that[propertyName]) { feedback.setAttribute(LW.Utilities.Core.toDash(propertyName), ''); } }); feedback.appendChild(clone); if (numberOfDraggedItems > 1) { const additionalTask = document.createElement('div'); additionalTask.style.width = width; additionalTask.style.height = height; additionalTask.className = 'lw-kanban-feedback-additional'; feedback.insertBefore(additionalTask, clone); clone.setAttribute('num', numberOfDraggedItems); if (numberOfDraggedItems > 2) { additionalTask.classList.add('multiple'); } } that.getShadowRootOrBody().appendChild(feedback); return feedback; } /** * Moves dragged items to new destination. */ _moveDraggedItems(dragDetails) { const that = this; let dropDetails = dragDetails.DropDetails, dropTarget = dropDetails.item, dropColumn = dropTarget.closest('.lw-kanban-column'), originScrollViewer = dragDetails.Item.closest('lw-scroll-viewer'), columnObject = dropColumn.column; let dropParent; if (dropTarget.classList.contains('lw-kanban-task')) { dropParent = dropTarget.parentElement; if (dropDetails.after) { dropTarget = dropTarget.nextElementSibling; } dragDetails.Items.forEach(task => { dropParent.insertBefore(task, dropTarget); task.data.status = columnObject.dataField; }); } else { dropParent = dropTarget.firstElementChild; dragDetails.Items.forEach(task => { dropParent.appendChild(task); task.data.status = columnObject.dataField; }); } dropParent = dropParent.closest('lw-scroll-viewer'); if (that.swimlanes.length > 0) { const dropSwimlane = dropParent.getAttribute('swimlane'); if (dropSwimlane) { dragDetails.Items.forEach(task => task.data.swimlane = dropSwimlane); } else { dragDetails.Items.forEach(task => delete task.data.swimlane); } } that._focusTask(dragDetails.Item); if (originScrollViewer !== dropParent) { dropParent.focus(); if (that.textTemplate) { dragDetails.Items.forEach(task => that._renderTask(task)); } if (dragDetails.Item.hasAttribute('selected')) { dragDetails.Items.forEach(task => task.removeAttribute('selected')); that._selectedTasks = []; that._autoSaveState('selection'); } that._refreshScrollViewer(originScrollViewer, true); that._refreshScrollViewer(dropParent, true); } that._autoSaveState('dataSource'); } /** * Gets the current data source - after user interaction. */ _getCurrentDataSource() { const allTasks = Array.from(this.$.container.getElementsByClassName('lw-kanban-task')), currentDataSource = []; for (let i = 0; i < allTasks.length; i++) { currentDataSource.push(allTasks[i].data); } return currentDataSource; } /** * Validates the "task" argument in public methods. */ _validateTaskArgument(task) { const that = this; if (task instanceof HTMLElement && that.$.container.contains(task) && task.classList.contains('lw-kanban-task')) { return task; } else if (task !== null && (typeof task === 'number' || typeof task === 'string')) { return that.$.container.querySelector(`.lw-kanban-task[data-id="${task}"]`); } } /** * Opens dialog. */ _openDialog(taskOrComment, purpose, type = 'task') { const that = this, openingEventDetail = { purpose: purpose }; openingEventDetail[type] = taskOrComment; const openingEvent = that.$.fireEvent('opening', openingEventDetail); if (openingEvent.defaultPrevented) { return; } if (!that._dialog) { that._createDialog(); } const dialog = that._dialog, isPrompt = purpose === 'prompt'; dialog.openedFrom = (that.shadowRoot || that.getRootNode()).activeElement; dialog.classList.toggle('prompt', isPrompt); dialog.classList.toggle('edit', !isPrompt); dialog.taskOrComment = taskOrComment; if (isPrompt) { const text = type === 'task' ? that.localize('promptTask', { taskText: taskOrComment.data.text }) : that.localize('promptComment'); dialog.setAttribute('aria-label', text); dialog.headerPosition = 'none'; dialog.$.container.querySelector('.prompt').innerHTML = text; } else { dialog.removeAttribute('aria-label'); dialog.headerPosition = 'top'; dialog.label = that.localize('editTask', { taskId: taskOrComment.id }); if (!dialog.editPanelPopulated) { that._populateEditPanel(); } that._beginEdit(taskOrComment); } that.$.container.setAttribute('modal', ''); dialog.open(); } /** * Creates dialog. */ _createDialog() { const that = this, dialog = document.createElement('lw-window'), footerTemplate = document.createElement('template'); footerTemplate.innerHTML = `<lw-button class="ok primary"${that._rtlAttr}>${that.localize('ok')}</lw-button> <lw-button class="cancel"${that._rtlAttr}>${that.localize('cancel')}</lw-button>`; dialog.animation = that.animation; dialog.footerTemplate = footerTemplate; dialog.headerButtons = ['close']; dialog.rightToLeft = that.rightToLeft; dialog.theme = that.theme; dialog.className = 'lw-kanban-window'; dialog.innerHTML = `<div class="prompt"></div> <div class="edit"></div>`; dialog.ownerElement = that; that._dialog = dialog; that._addDialogHandlers(); that.getShadowRootOrBody().appendChild(dialog); } /** * Adds window handlers. */ _addDialogHandlers() { const that = this, dialog = that._dialog; dialog.addEventListener('open', that._dialogEventHandler); dialog.addEventListener('closing', that._dialogEventHandler); dialog.addEventListener('close', that._dialogEventHandler); dialog.addEventListener('click', that._dialogClickHandler); } /** * Dialog event handler. */ _dialogEventHandler(event) { const dialog = this, that = dialog.ownerElement, type = event.type, oldContext = that.context; if ((dialog.isInShadowDOM || dialog.shadowRoot ? event.composedPath()[0] : event.target) !== dialog) { // event is triggered from an editor return; } that.context = that; if (type === 'open') { that.$.fireEvent('open'); } else if (type === 'closing') { const customEvent = that.$.fireEvent('closing'); if (customEvent.defaultPrevented) { event.preventDefault(); delete dialog.ok; } } else if (type === 'close') { that.$.fireEvent('close'); that._dialogCloseHandler(event); } that.context = oldContext; } /** * Dialog click handler. */ _dialogClickHandler(event) { const dialog = this, target = dialog.isInShadowDOM || dialog.shadowRoot ? event.composedPath()[0] : event.target; if (target.closest('.ok')) { dialog.ok = true; dialog.close(); } else if (target.closest('.cancel')) { dialog.close(); } else if (target.closest('.add')) { const newTaskInput = dialog.editors.newSubtask, newTaskLabel = newTaskInput.value; if (newTaskLabel === '') { return; } const listBox = dialog.editors.checklist; listBox.insert(listBox.items.length, { label: newTaskLabel }); newTaskInput.value = ''; dialog.$.content.scrollTop = dialog.$.content.scrollHeight - dialog.$.content.offsetHeight; } else if (target.classList.contains('remove-subtask')) { dialog.editors.checklist.removeChild(target.closest('lw-list-item')); } } /** * Edit window close handler. */ _dialogCloseHandler() { const that = this, dialog = that._dialog; that.$.container.removeAttribute('modal'); if (dialog.ok) { // OK if (dialog.classList.contains('prompt')) { const commentParentTask = that._commentSelectionFor; if (commentParentTask) { const data = commentParentTask.data; data.comments = data.comments.filter(comment => comment !== dialog.taskOrComment.comment); dialog.taskOrComment.remove(); commentParentTask.querySelector('.lw-kanban-task-comments').setAttribute('num', data.comments.length || ''); if (that._commentsList.editing) { that._commentsList.textarea.value = ''; delete that._commentsList.editing; } } else { that.removeTask(dialog.taskOrComment); } } else { that._endEdit(); } delete dialog.ok; } if (dialog.openedFrom) { requestAnimationFrame(() => { if (that.getRootNode().contains(dialog.openedFrom) && dialog.openedFrom.focus) { dialog.openedFrom.focus(); } delete dialog.openedFrom; }); } delete dialog.taskOrComment; } /** * Closes the edit dialog. */ _closeDialog() { const that = this; if (that._dialog) { that._dialog.close(); } } /** * Populates edit panel. */ _populateEditPanel() { const that = this, id = that.id, dialog = that._dialog, editPanel = dialog.$.container.querySelector('.edit'), asigneeSource = that.users.map(user => ({ label: user.name, value: user.id })), statusSource = that._allColumns.map(col => ({ label: col.label, value: col.dataField })), prioritySource = [{ label: that.localize('low'), value: 'low' }, { label: that.localize('normal'), value: 'normal' }, { label: that.localize('high'), value: 'high' }], swimLanesSource = that.swimlanes.map(swimlane => ({ label: swimlane.label, value: swimlane.dataField })), checklistTemplate = document.createElement('template'), sync = ` animation="${that.animation}"${that._rtlAttr} theme="${that.theme}"${that.unfocusable ? ' unfocusable' : ''}`; checklistTemplate.innerHTML = `<div class="lw-kanban-sub-task"><span class="label">{{label}}</span><span class="remove-subtask" aria-label="Remove subtask" title="${that.localize('removeSubtask')}"></span></div>`; checklistTemplate.id = that.id + 'ChecklistTemplate'; dialog.$.container.appendChild(checklistTemplate); editPanel.innerHTML = `<div id="${id}LabelText" class="editor-label">${that.localize('text')}</div> <textarea class="editor text-editor" aria-labelledby="${id}LabelText"></textarea> <div id="${id}LabelTags" class="editor-label">${that.localize('tags')}</div> <lw-combo-box class="editor tags-editor" selection-mode="zeroOrMany" selection-display-mode="tokens"${sync} aria-labelledby="${id}LabelTags"></lw-combo-box> <div class="editor-container"> <div id="${id}LabelStatus" class="editor-label">${that.localize('status')}</div> <div id="${id}LabelSwimlane" class="editor-label">${that.localize('swimlane')}</div> <lw-input class="editor status-editor" data-source='${JSON.stringify(statusSource)}' drop-down-button-position="right" readonly${sync} aria-labelledby="${id}LabelStatus"></lw-input> <lw-input class="editor swimlane-editor" data-source='${JSON.stringify(swimLanesSource)}'${swimLanesSource.length === 0 ? ' disabled' : ''} drop-down-button-position="right" readonly${sync} aria-labelledby="${id}LabelSwimlane"></lw-input> </div> <div class="editor-container"> <div id="${id}LabelAssignedTo" class="editor-label">${that.localize('assignedTo')}</div> <div id="${id}LabelProgress" class="editor-label">${that.localize('progress')}</div> <lw-input class="editor asignee-editor" data-source='${JSON.stringify(asigneeSource)}'${asigneeSource.length === 0 ? ' disabled' : ''} drop-down-button-position="right"${sync} aria-labelledby="${id}LabelAssignedTo"></lw-input> <lw-numeric-text-box class="editor progress-editor" input-format="floatingPoint" min="0" max="100" show-unit unit="%"${sync} aria-labelledby="${id}LabelProgress"></lw-numeric-text-box> </div> <div class="editor-container"> <div id="${id}LabelStartDate" class="editor-label">${that.localize('startDate')}</div> <div id="${id}LabelDueDate" class="editor-label">${that.localize('dueDate')}</div> <lw-date-time-picker class="editor start-date-editor" calendar-button drop-down-append-to="body" drop-down-display-mode="calendar" format-string="${that.formatStringDate}" nullable${sync} aria-labelledby="${id}LabelStartDate"></lw-date-time-picker> <lw-date-time-picker class="editor due-date-editor" calendar-button drop-down-append-to="body" drop-down-display-mode="calendar" format-string="${that.formatStringDate}" nullable${sync} aria-labelledby="${id}LabelDueDate"></lw-date-time-picker> </div> <div class="editor-container"> <div id="${id}LabelPriority" class="editor-label">${that.localize('priority')}</div> <div id="${id}LabelColor" class="editor-label">${that.localize('color')}</div> <lw-input class="editor priority-editor" data-source='${JSON.stringify(prioritySource)}' drop-down-button-position="right" readonly${sync} aria-labelledby="${id}LabelPriority"></lw-input> <lw-color-input class="editor color-editor" drop-down-button-position="right"${sync} aria-labelledby="${id}LabelColor"></lw-color-input> </div> <div id="${id}LabelChecklist" class="editor-label">${that.localize('checklist')}</div> <div class="new-container"> <input type="text" class="new-subtask" placeholder="${that.localize('newSubtask')}" /> <lw-button class="add primary" title="${that.localize('addSubtask')}" aria-label="Add subtask"${sync}>+</lw-button> </div> <lw-list-box class="editor checklist-editor" item-template="${checklistTemplate.id}" selection-mode="checkBox"${sync} aria-labelledby="${id}LabelChecklist"></lw-list-box>`; dialog.editors = { text: editPanel.querySelector('.text-editor'), tags: editPanel.querySelector('.tags-editor'), userId: editPanel.querySelector('.asignee-editor'), status: editPanel.querySelector('.status-editor'), swimlane: editPanel.querySelector('.swimlane-editor'), startDate: editPanel.querySelector('.start-date-editor'), dueDate: editPanel.querySelector('.due-date-editor'), progress: editPanel.querySelector('.progress-editor'), priority: editPanel.querySelector('.priority-editor'), color: editPanel.querySelector('.color-editor'), newSubtask: editPanel.querySelector('.new-subtask'), checklist: editPanel.querySelector('.checklist-editor') } dialog.editPanelPopulated = true; } /** * Begins an edit operation. */ _beginEdit(task) { const that = this, data = task.data, dialog = that._dialog, editors = dialog.editors, tagsDataSource = that.tags.length > 0 ? that.tags : that._customTags, column = that._allColumns.find(col => col.dataField === data.status); dialog.label = that.localize('editTask', { taskId: data.id }); editors.text.value = data.text; editors.tags.dataSource = tagsDataSource; editors.tags.disabled = tagsDataSource.length === 0; if (data.tags) { editors.tags.selectedValues = data.tags.replace(/\s+/g, '').split(','); } else { editors.tags.selectedValues = []; } editors.userId.value = data.userId !== null ? that.users.find(user => user.id === data.userId).name : ''; delete editors.userId.$.input.dataValue; editors.status.value = column.label; delete editors.status.$.input.dataValue; if (that._hasSwimlane(that.columns.indexOf(column))) { editors.swimlane.value = that.swimlanes.find(swimlane => swimlane.dataField === data.swimlane).label; } else { editors.swimlane.value = ''; } delete editors.swimlane.$.input.dataValue; editors.startDate.value = data.startDate || null; editors.dueDate.value = data.dueDate || null; editors.progress.value = parseFloat(data.progress) || 0; editors.priority.value = that.localize(data.priority); delete editors.priority.$.input.dataValue; editors.color.value = data.color || ''; const selectedSubtasks = [], subtaskDataSource = []; (data.checklist || []).forEach((subtask, index) => { if (subtask.completed) { selectedSubtasks.push(index); } subtaskDataSource.push({ label: subtask.text, selected: subtask.completed === true }); }); editors.newSubtask.value = ''; editors.checklist.dataSource = subtaskDataSource; editors.checklist.selectedIndexes = selectedSubtasks; } /** * Ends the current edit operation and saves changes. */ _endEdit() { const that = this, dialog = that._dialog, editors = dialog.editors, task = dialog.taskOrComment, oldData = task.data, newData = Object.assign({}, oldData); let newStartDate = editors.startDate.value, newDueDate = editors.dueDate.value; newData.text = editors.text.value; newData.tags = editors.tags.selectedValues.join(', '); newData.progress = parseFloat(editors.progress.value); newData.color = editors.color.value; if (!newData.color) { delete newData.color; } if (editors.userId.$.input.dataValue !== undefined) { newData.userId = parseFloat(editors.userId.$.input.dataValue); } if (editors.status.$.input.dataValue) { newData.status = editors.status.$.input.dataValue; } if (editors.swimlane.$.input.dataValue) { newData.swimlane = editors.swimlane.$.input.dataValue; } if (newStartDate) { newStartDate = newStartDate.toDate(); } if (newDueDate) { newDueDate = newDueDate.toDate(); } newData.startDate = newStartDate; newData.dueDate = newDueDate; if (editors.priority.$.input.dataValue) { newData.priority = editors.priority.$.input.dataValue; } newData.checklist = editors.checklist.items.map(item => ({ text: item.label, completed: item.selected })); that.updateTask(task, newData); } /** * Gets the current user and their privileges. */ _getCurrentUser() { const that = this, users = that.users; let currentUser = that.currentUser, allowAdd = true, allowComment = false, allowDrag = that.allowDrag, allowEdit = that.editable, allowRemove = true; if (users && currentUser !== null) { currentUser = users.find(user => user.id === currentUser); if (currentUser) { allowAdd = currentUser.allowAdd !== false; allowComment = currentUser.allowComment !== false; allowDrag = allowDrag && currentUser.allowDrag !== false; allowEdit = allowEdit && currentUser.allowEdit !== false; allowRemove = currentUser.allowRemove !== false; } } that._currentUser = { allowAdd: allowAdd, allowComment: allowComment, allowDrag: allowDrag, allowEdit: allowEdit, allowRemove: allowRemove, info: currentUser } } /** * Automatically saves the Kanban's state. */ _autoSaveState(toUpdate) { const that = this; if (!that.autoSaveState) { return; } if (typeof toUpdate === 'object') { that._autoSavedState = toUpdate; return; } if (!toUpdate || !that._autoSavedState) { that._autoSavedState = that.saveState(); return; } switch (toUpdate) { case 'collapsed': { that._allColumns.forEach(column => that._autoSavedState.collapsed[column.dataField] = column.collapsed); break; } case 'dataSource': that._autoSavedState.dataSource = that._getCurrentDataSource() break; case 'filtering': that._autoSavedState.filtering = that._appliedFiltering; break; case 'selection': { let selectionInColumn = null, swimlane = null; if (that._selectionInView) { selectionInColumn = that._selectionInView.closest('.lw-kanban-column').column.dataField; swimlane = that._selectionInView.getAttribute('swimlane'); } that._autoSavedState.selection = { selected: that._selectedTasks.map(task => task.data.id), selectionStart: that._selectionStart ? that._selectionStart.data.id : null, selectionInColumn: selectionInColumn, swimlane: swimlane }; break; } case 'sorting': that._autoSaveState.sorting = that._appliedSorting; break; case 'tabs': that._autoSaveState.tabs = that._selectedTabs; break; case 'visibility': that._autoSavedState.visibility = { taskActions: that.taskActions, taskComments: that.taskComments, taskDue: that.taskDue, taskPriority: that.taskPriority, taskProgress: that.taskProgress, taskTags: that.taskTags, taskUserIcon: that.taskUserIcon }; break; } window.localStorage.setItem('lwKanban' + that.id, JSON.stringify(that._autoSavedState)); } /** * Applies filtering. */ _applyFilter(filters, operator) { const that = this, dataSource = new LW.DataAdapter({ dataSource: that._getCurrentDataSource(), dataFields: [ 'text: string', 'tags: string', 'priority: string', 'progress: number', 'startDate: date', 'dueDate: date', 'userId: string' ], id: 'id' }); try { dataSource._filter(filters, operator); } catch (error) { return; } const allTasks = Array.from(that.$.container.getElementsByClassName('lw-kanban-task')); for (let i = 0; i < dataSource.length; i++) { const task = allTasks[i], filteredOut = !dataSource[i].$.filtered; task.classList.toggle('lw-hidden', filteredOut); task.filteredOut = filteredOut; } that._allColumns.forEach(column => that._refreshScrollViewer(column)); that._autoSaveState('filtering'); } /** * Header panels apply handler. */ _applyHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target, detail = event.detail; if (that.$.customize.contains(target)) { detail.value.forEach(property => that[property.dataField] = property.visible); that._allColumns.forEach(column => that._refreshScrollViewer(column)); that._autoSaveState('visibility'); } else if (that.$.filter.contains(target)) { that.addFilter(detail.filters, detail.operator, detail.value); } else if (that.$.sort.contains(target)) { that.addSort(detail.sortByInfo); } that.closePanel(); } /** * Applies sorting. */ _applySort() { const that = this, sortByInfo = that._appliedSorting; that._autoSaveState('sorting'); if (sortByInfo.dataFields.length === 0) { return; } that._allColumns.forEach(column => { const columnElement = that._columnToElement.get(column), tasksParent = columnElement.querySelector('.lw-scroll-viewer-content-container'), siblingTasks = Array.from(tasksParent.children), data = []; if (siblingTasks.length < 2) { return; } siblingTasks.forEach((task, index) => { const dataPoint = Object.assign({ taskIndex: index }, task.data); if (dataPoint.priority === 'low') { dataPoint.priority = 'z'; } data.push(dataPoint); }); const dataSource = new LW.DataAdapter({ dataSource: data, dataFields: [ 'taskIndex: number', 'text: string', 'tags: string', 'priority: string', 'progress: number', 'startDate: date', 'dueDate: date', 'userId: string' ], id: 'id' }); dataSource.sortBy(sortByInfo.dataFields, sortByInfo.dataTypes, sortByInfo.orderBy); for (let i = 0; i < dataSource.length; i++) { tasksParent.appendChild(siblingTasks[dataSource[i].taskIndex]); } }); } /** * Closes search panel. */ _closeSearchPanel() { const that = this; if (that._searchInfo) { Array.from(that.$.container.querySelectorAll('.lw-kanban-task.lw-data-view-found, .lw-kanban-task.lw-data-view-highlighted')) .forEach(task => task.classList.remove('lw-data-view-found', 'lw-data-view-highlighted')); delete that._searchInfo; } } /** * Constructs FilterGroup object(s) from filtering information. */ _constructFilterGroups(filterInfo) { const dataTypes = { text: 'string', tags: 'string', priority: 'string', progress: 'number', startDate: 'date', dueDate: 'date', }, filterGroups = {}, result = []; filterInfo.filters.forEach(filter => { const dataField = filter[0], dataType = dataTypes[dataField]; let value = filter[2], filterGroup = filterGroups[dataField]; if (filterGroup === undefined) { filterGroup = new LW.Utilities.FilterGroup(); filterGroups[dataField] = filterGroup; } if (dataType === 'date' && typeof value === 'string') { value = new Date(value); } const filterObject = filterGroup.createFilter(dataType, value, filter[1]); filterGroup.addFilter(filterInfo.operator, filterObject); }); for (let dataField in filterGroups) { result.push([dataField, filterGroups[dataField]]); } return result; } /** * Opens search panel. */ _openSearchPanel() { const that = this; that.$.headerDropDown.classList.add('search-panel'); that.$.headerDropDown.classList.remove('customize-panel', 'filter-panel', 'sort-panel'); that.$.search.classList.remove('lw-hidden'); that.$.customize.classList.add('lw-hidden'); that.$.filter.classList.add('lw-hidden'); that.$.sort.classList.add('lw-hidden'); that._openHeaderDropDown(that.$.searchButton); that._searchInfo = { source: that._getCurrentDataSource(), stringDataFields: ['text', 'tags'] } if (that.$.searchInput.value !== '') { that._search(that.$.searchInput.value, false); } } /** * Searches by a query. */ _search(query, highlight = true) { const that = this; that._searchInfo.query = query; Array.from(that.$.container.querySelectorAll('.lw-kanban-task.lw-data-view-found, .lw-kanban-task.lw-data-view-highlighted')) .forEach(task => task.classList.remove('lw-data-view-found', 'lw-data-view-highlighted')); if (query === '') { that.$.search.classList.remove('matches', 'no-matches'); delete that._searchInfo.foundIdsArray; delete that._searchInfo.foundIdsObject; delete that._searchInfo.highlighted; return; } const source = new LW.DataAdapter({ dataSource: that._searchInfo.source, dataFields: [ 'text: string', 'tags: string'], id: 'id' }), filters = [], foundIdsArray = [], foundIdsObject = {}; that._searchInfo.stringDataFields.forEach(dataField => { const filterGroup = new LW.Utilities.FilterGroup(), filterObject = filterGroup.createFilter('string', query, 'CONTAINS'); filterGroup.addFilter('or', filterObject); filters.push([dataField, filterGroup]); }); source._filter(filters, 'or'); for (let i = 0; i < source.length; i++) { const record = source[i]; if (record.$.filtered !== false) { foundIdsArray.push(record.$.id); foundIdsObject[record.$.id] = true; } } that._searchInfo.foundIdsArray = foundIdsArray; that._searchInfo.foundIdsObject = foundIdsObject; Array.from(that.$.container.getElementsByClassName('lw-kanban-task')).forEach(task => { const id = task.data.id; if (foundIdsObject[id]) { if (task.filteredOut) { foundIdsArray.splice(foundIdsArray.indexOf(id), 1); delete foundIdsObject[id]; return; } if (highlight && foundIdsArray[0] === id) { task.classList.add('lw-data-view-highlighted'); } task.classList.add('lw-data-view-found'); } }); if (foundIdsArray.length > 0) { if (highlight) { let highlighted = foundIdsArray[0]; that._searchInfo.highlighted = highlighted; that.ensureVisible(highlighted); } that.$.search.classList.remove('no-matches'); that.$.search.classList.add('matches'); that.$.searchLabel.innerHTML = that.localize('found', { nth: highlight ? 1 : 0, n: foundIdsArray.length }); return; } that.$.search.classList.remove('matches'); that.$.search.classList.add('no-matches'); that.$.searchLabel.innerHTML = that.localize('found', { nth: 0, n: 0 }); } /** * Kanban body focusin handler. */ _bodyFocusinHandler(event) { const that = this; let target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; if (!target.classList.contains('lw-kanban-column-content-tasks')) { return; } target = target.$.content; const focusedTask = that._getSelectedItem(target, true); if (!focusedTask) { that._focusTask(that._getFirstItem(target)); } } /** * Gets "right-to-left" attribute if applicable. */ get _rtlAttr() { return this.rightToLeft ? ' right-to-left' : ''; } /** * Gets "tabindex" attribute if applicable. */ get _tabindex() { const that = this; return that.disabled || that.unfocusable ? '' : ' tabindex="0"'; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Tree Item custom element. */ LW('lw-tree-item', class TreeItem extends LW.MenuItem { // Tree Item's properties. static get properties() { return { 'selected': { value: false, type: 'boolean' } }; } ready() { const that = this; Object.defineProperty(that, 'hasStyleObserver', { get: function () { return false; } }); super.ready(); that.setAttribute('role', 'treeitem'); that.setAttribute('aria-label', that.label); } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this, parentTree = that.menu; super.propertyChangedHandler(propertyName, oldValue, newValue); if (propertyName === 'level') { that.level = oldValue; return; } if (propertyName === 'disabled' || propertyName === 'separator' || !parentTree) { return; } const oldContext = parentTree.context; parentTree.context = parentTree; switch (propertyName) { case 'label': { const restoreSorting = parentTree.sorted && parentTree.autoSort; that.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue; if (restoreSorting) { parentTree._unsortItems(parentTree.$.mainContainer); parentTree._applyGrouping(parentTree.$.mainContainer); } if (parentTree._state.filter) { parentTree._applyFilter(parentTree._state.filter); } that.setAttribute('aria-label', newValue); break; } case 'selected': that.selected = oldValue; if (newValue) { parentTree.select(that); } else { parentTree.unselect(that); } break; case 'shortcut': { let shortcutElement = that.firstElementChild.children[1]; if (!shortcutElement) { shortcutElement = document.createElement('div'); shortcutElement.className = 'lw-tree-item-shortcut'; that.firstElementChild.appendChild(shortcutElement); } shortcutElement.innerHTML = newValue; break; } case 'value': if (parentTree.sort && parentTree.sorted && parentTree.autoSort) { parentTree._refreshSorting(); } break; } parentTree.context = oldContext; } /** * overridden BaseElement method. */ _setId() { } }); /** * Tree Items Group custom element. */ LW('lw-tree-items-group', class TreeItemsGroup extends LW.MenuItemsGroup { // Tree Items Group's properties. static get properties() { return { 'selected': { value: false, type: 'boolean' } }; } ready() { const that = this; Object.defineProperty(that, 'hasStyleObserver', { get: function () { return false; } }); super.ready(); that.setAttribute('role', 'treeitem'); that.removeAttribute('aria-haspopup'); that.setAttribute('aria-label', that.label); } propertyChangedHandler(propertyName, oldValue, newValue) { const that = this, parentTree = that.menu; super.propertyChangedHandler(propertyName, oldValue, newValue); if (propertyName === 'level') { that.level = oldValue; return; } if (propertyName === 'disabled' || propertyName === 'separator' || !parentTree) { return; } const oldContext = parentTree.context; parentTree.context = parentTree; switch (propertyName) { case 'expanded': { that.expanded = oldValue; if (newValue) { parentTree.expandItem(that); } else { parentTree.collapseItem(that); } break; } case 'label': { const restoreSorting = parentTree.sorted && parentTree.autoSort; that.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue; if (restoreSorting) { parentTree._unsortItems(parentTree.$.mainContainer); parentTree._applyGrouping(parentTree.$.mainContainer); } if (parentTree._state.filter) { parentTree._applyFilter(parentTree._state.filter); } that.setAttribute('aria-label', newValue); break; } case 'selected': that.selected = oldValue; if (newValue) { parentTree.select(that); } else { parentTree.unselect(that); } break; case 'value': if (parentTree.sort && parentTree.sorted && parentTree.autoSort) { parentTree._refreshSorting(); } break; } parentTree.context = oldContext; } /** * overridden BaseElement method. */ _setId() { } }); /** * Tree custom element. */ LW('lw-tree', class Tree extends LW.Menu { // Tree's properties. static get properties() { return { 'allowDrag': { value: false, type: 'boolean' }, 'allowDrop': { value: false, type: 'boolean' }, 'autoHideToggleElement': { value: false, type: 'boolean' }, 'autoLoadState': { value: false, type: 'boolean' }, 'autoSaveState': { value: false, type: 'boolean' }, 'autoSort': { value: true, type: 'boolean' }, 'displayLoadingIndicator': { value: false, type: 'boolean' }, 'dragFeedbackFormatFunction': { value: null, type: 'function?' }, 'dragOffset': { value: [10, 10], type: 'array' }, 'editable': { value: false, type: 'boolean' }, 'filterable': { value: false, type: 'boolean' }, 'filterInputPlaceholder': { value: '', type: 'string' }, 'filterMode': { value: 'containsIgnoreCase', allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'], type: 'string' }, 'hasThreeStates': { value: false, type: 'boolean' }, 'loadingIndicatorPlaceholder': { value: 'Loading...', type: 'string' }, 'loadingIndicatorPosition': { value: 'center', allowedValues: ['bottom', 'center', 'top'], type: 'string' }, 'messages': { value: { 'en': { 'noId': 'lw-tree: Saving and loading the element\'s state are not available if the element has no id.' } }, type: 'object', extend: true }, 'scrollMode': { value: 'scrollbar', allowedValues: ['scrollbar', 'scrollButtons'], type: 'string' }, 'selectedIndexes': { value: [], type: 'array' }, 'selectionDisplayMode': { value: 'row', allowedValues: ['row', 'label'], type: 'string' }, 'selectionMode': { value: 'one', allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'], type: 'string' }, 'showLines': { value: false, type: 'boolean' }, 'showRootLines': { value: false, type: 'boolean' }, 'sort': { value: null, type: 'function?' }, 'sortDirection': { value: 'asc', allowedValues: ['asc', 'desc'], type: 'string' }, 'sorted': { value: false, type: 'boolean' }, 'toggleElementPosition': { value: 'near', allowedValues: ['near', 'far'], type: 'string' }, 'toggleMode': { value: 'dblclick', allowedValues: ['click', 'dblclick', 'arrow'], type: 'string' } }; } /** * Tree's event listeners. */ static get listeners() { return { 'blur': '_blurHandler', 'focus': '_focusHandler', 'keydown': '_keydownHandler', 'mouseenter': '_mouseenterHandler', 'mouseleave': '_mouseleaveHandler', 'resize': '_checkOverflow', 'styleChanged': '_styleChangedHandler', 'transitionend': '_overriddenMenuHandler', 'container.click': '_overriddenMenuHandler', 'container.mouseout': '_overriddenMenuHandler', 'container.mouseover': '_overriddenMenuHandler', 'editInput.blur': '_editInputBlurHandler', 'filterInput.keydown': '_filterInputKeydownHandler', 'filterInput.keyup': '_filterInputKeyupHandler', 'mainContainer.click': '_overriddenMenuHandler', 'mainContainer.mouseleave': '_overriddenMenuHandler', 'mainContainer.mouseout': '_overriddenMenuHandler', 'mainContainer.mouseover': '_overriddenMenuHandler', 'mainContainer.swipeleft': '_mainContainerSwipeHandler', 'mainContainer.swiperight': '_mainContainerSwipeHandler', 'scrollButtonFar.click': '_scrollButtonFarClickHandler', 'scrollButtonNear.click': '_scrollButtonNearClickHandler', 'scrollViewer.down': '_scrollViewerDownHandler', 'scrollViewer.kineticScroll': '_scrollViewerWheelHandler', 'scrollViewer.touchmove': '_scrollViewerTouchmoveHandler', 'mainContainer.wheel': '_scrollViewerWheelHandler', 'document.move': '_moveHandler', 'document.selectstart': '_selectstartHandler', 'document.up': '_documentUpHandler' }; } /** * Tree's required files. */ static get requires() { return { 'LW.ScrollBar': 'lw.scrollbar.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.scrollbar.css', 'lw.scrollviewer.css', 'lw.tree.css' ] } /** * Tree's HTML template. */ template() { return `<div id="container" role="presentation"> <div class="lw-tree-filter-input-container" role="presentation"><input id="filterInput" class="lw-filter-input" disabled="[[disabled]]" placeholder="[[filterInputPlaceholder]]" type="text" role="searchbox" aria-label="[[filterInputPlaceholder]]" /></div> <lw-repeat-button id="scrollButtonNear" class="lw-tree-scroll-button lw-spin-button lw-scroll-button-near lw-hidden" animation="[[animation]]" unfocusable aria-label="Scroll up"> <div id="arrowNear" class="lw-arrow lw-arrow-up"></div> </lw-repeat-button> <lw-scroll-viewer id="scrollViewer" animation="[[animation]]" horizontal-scroll-bar-visibility="hidden" right-to-left="[[rightToLeft]]"> <div id="mainContainer" class="lw-tree-main-container" role="presentation"> <content></content> </div> <input type="text" id="editInput" class="lw-tree-edit-input lw-hidden" /> </lw-scroll-viewer> <lw-repeat-button id="scrollButtonFar" class="lw-tree-scroll-button lw-spin-button lw-scroll-button-far lw-hidden" animation="[[animation]]" unfocusable aria-label="Scroll down"> <div id="arrowFar" class="lw-arrow lw-arrow-down"></div> </lw-repeat-button> <div id="loadingIndicatorContainer" class="lw-loader-container lw-hidden" role="presentation"> <span id="loadingIndicator" class="lw-loader" role="img" aria-label="[[loadingIndicatorPlaceholder]]"></span> <span id="loadingIndicatorPlaceHolder" class="lw-loader-label lw-hidden">[[loadingIndicatorPlaceholder]]</span> </div> </div>`; } /** * Called when the element is detached from the DOM. */ detached() { const that = this, dragDetails = that._dragDetails; super.detached(); if (!dragDetails) { return; } const targetTree = LW.Tree.hoveredTree, targetItem = LW.Tree.hoveredItem; delete that._dragDetails; delete LW.Tree.treeItemDragged; delete LW.Tree.hoveredTree; delete LW.Tree.hoveredItem; that.$.scrollViewer._scrollView.disableSwipeScroll = false; if (!dragDetails.FeedbackShown) { return; } targetItem.classList.remove('drop-target', 'top', 'bottom'); document.body.classList.remove('lw-dragging'); dragDetails.Feedback.remove(); if (targetTree) { clearInterval(targetTree._dragInterval); } } /** * Adds an item after another item as a sibling. * * @param {HTMLElement} item A lw-tree-item/lw-tree-items-group to add to the Tree. * @param {HTMLElement/String} sibling The lw-tree-item/lw-tree-items-group (or its id or numeric path) to add the item after. */ addAfter(item, sibling) { const that = this; sibling = that.getItem(sibling); if (sibling === undefined) { return; } that.addTo(item, sibling.parentItem, sibling, true); } /** * Adds an item before another item as a sibling. * * @param {HTMLElement} item A lw-tree-item/lw-tree-items-group to add to the Tree. * @param {HTMLElement/String} sibling The lw-tree-item/lw-tree-items-group (or its id or numeric path) to add the item before. */ addBefore(item, sibling) { const that = this; sibling = that.getItem(sibling); if (sibling === undefined) { return; } that.addTo(item, sibling.parentItem, sibling); } /** * Adds an item as the last child of a parent item. * * @param {HTMLElement} item A lw-tree-item/lw-tree-items-group to add to the Tree. * @param {HTMLElement/String} parent Optional The lw-tree-items-group (or its id or numeric path) to add the item to. */ addTo(item, parent) { const that = this; if (!(item instanceof LW.TreeItem || item instanceof LW.TreeItemsGroup)) { return; } let level, container; if (parent === undefined) { parent = that.$.mainContainer; level = 1; container = parent; } else { parent = that.getItem(parent); if (parent instanceof LW.TreeItemsGroup === false) { return; } level = parent.level + 1; container = parent.itemContainer; } that._createItemHTMLStructure(item, level, parent, container.childElementCount, 0); const restoreSorting = that.sorted && that.autoSort, filterQuery = that._state.filter, oldSelectedIndexes = that.selectedIndexes.slice(0); if (restoreSorting) { that._unsortItems(that.$.mainContainer); } if (item instanceof LW.TreeItemsGroup) { that._processHTML(item, level + 1, false); } let sibling = arguments[2]; if (sibling && arguments[3]) { sibling = sibling.nextElementSibling; } if (sibling) { container.insertBefore(item, sibling); that._menuItems = {}; that._refreshItemPaths(that.$.mainContainer, true, undefined, that.sorted && !that.autoSort); } else { container.appendChild(item); } if (restoreSorting) { that._applyGrouping(that.$.mainContainer); } if (filterQuery) { that._applyFilter(filterQuery); } that._checkOverflow(); that._expandItemsByDefault(); that.selectedIndexes = []; that._applySelection(true, oldSelectedIndexes); } /** * Clears selection. */ clearSelection() { const that = this, oldSelectedIndexes = that.selectedIndexes.slice(0); that.selectedIndexes = []; that._applySelection(false, oldSelectedIndexes); } /** * Collapses all items. * * @param {Boolean} animation Optional If set to false, disables collapse animation even if animation is enabled for the element. */ collapseAll(animation) { const that = this, animationType = that.animation, restoreAnimation = animation === false && that.hasAnimation; if (restoreAnimation) { that.animation = 'none'; } that._collapseAll(true); if (restoreAnimation) { that.animation = animationType; } } /** * Makes sure an item is visible by scrolling to it. * * @param {HTMLElement/String} item lw-tree-item/lw-tree-items-group (or its id or numeric path). */ ensureVisible(item) { const that = this; item = that.getItem(item); if (item === undefined || item.hidden) { return; } let animation = false; if (item.level > 1 && !that._isBranchExpanded(item)) { super.expandItem(item.parentItem, undefined, true); animation = that.hasAnimation; if (animation) { that._ensureVisibleOnTransitionend = item; } } if (!animation) { that._ensureVisible(item); } } /** * Expands all items. * * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element. */ expandAll(animation) { const that = this, animationType = that.animation, restoreAnimation = animation === false && that.hasAnimation; let level = 1, treeItemsGroups = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('lw-tree-items-group[level="1"]'); if (restoreAnimation) { that.animation = 'none'; } while (treeItemsGroups.length > 0) { for (let i = 0; i < treeItemsGroups.length; i++) { const currentTreeItemsGroup = treeItemsGroups[i]; if (currentTreeItemsGroup.expanded) { continue; } that._menuItemsGroupSelectionHandler(currentTreeItemsGroup, { target: currentTreeItemsGroup, type: 'expand' }); } level++; treeItemsGroups = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('lw-tree-items-group[level="' + level + '"]'); } if (restoreAnimation) { that.animation = animationType; } } /** * Expands an item. * * @param {HTMLElement/String} item lw-tree-item/lw-tree-items-group (or its id or numeric path). * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element. */ expandItem(item, animation) { const that = this; item = that.getItem(item); if (item === undefined || item instanceof LW.TreeItemsGroup === false || that._isContainerOpened(item.container.level, item.container)) { return; } const restoreAnimation = animation === false && that.hasAnimation, animationType = that.animation; if (restoreAnimation) { that.animation = 'none'; } that._discardKeyboardHover(); that._menuItemsGroupSelectionHandler(item, { target: item, type: 'expand' }, arguments[2]); if (restoreAnimation) { that.animation = animationType; } } /** * Filters the Tree. * * @param {String} filterQuery Filter query. */ filter(filterQuery) { const that = this; if (that.filterable) { that._applyFilter(filterQuery); that.$.filterInput.value = filterQuery; } } /** * Gets the Tree's state. */ getState() { return JSON.parse(JSON.stringify(this._state)); } /** * Inserts an item at the given position. * * @param {HTMLElement/Object} item A lw-tree-item/lw-tree-items-group (or an Object to create an item from) to add to the Tree. * @param {String} path Optional The path to insert the item at. */ insert(item, path) { const that = this; let element; function createTreeItem(item) { const subItems = item[that.itemsMember], tagName = item.tagName === 'lw-tree-items-group' || Array.isArray(subItems) ? 'lw-tree-items-group' : 'lw-tree-item', element = document.createElement(tagName); if (item.disabled) { element.disabled = true; } if (item[that.displayMember]) { element.label = item[that.displayMember]; } if (item.selected) { element.selected = true; } if (item.separator) { element.separator = true; } if (item[that.valueMember]) { element.value = item[that.valueMember]; } if (tagName === 'lw-tree-items-group') { if (item.expanded) { element.expanded = true; } if (subItems) { for (let i = 0; i < subItems.length; i++) { element.appendChild(createTreeItem(subItems[i])); } } } else if (item.shortcut) { element.shortcut = item.shortcut; } return element; } if (item instanceof LW.TreeItem || item instanceof LW.TreeItemsGroup) { if (that.contains(item)) { return; } element = item; } else if (typeof item === 'object' && item.constructor === Object) { element = createTreeItem(item); } else { return; } if (path === undefined) { that.addTo(element); return; } if (typeof path === 'number') { path = path.toString(); } else if (path instanceof LW.TreeItem || path instanceof LW.TreeItemsGroup) { if (!that.contains(path)) { return; } path = path.path; } else if (typeof path !== 'string') { return; } const pathParts = path.split('.'); let parent, sibling; if (pathParts.length === 1) { sibling = that._menuItems[pathParts[0]]; if (!sibling) { that.addTo(element); } else { that.addBefore(element, sibling); } } else { sibling = that._menuItems[path]; parent = that._menuItems[pathParts.slice(0, pathParts.length - 1).join('.')]; if (sibling) { that.addBefore(element, sibling); } else if (parent && parent instanceof LW.TreeItemsGroup) { that.addTo(element, parent); } } } /** * Loads the Tree's state. * * @param {Object} state Optional An object returned by one of the methods getState or saveState. */ loadState(state) { const that = this, oldSelectedIndexes = that.selectedIndexes.slice(0), selectedIndexes = []; if (!state) { if (!that.id) { that.warn(that.localize('noId')); return; } state = window.localStorage.getItem('lwTree' + that.id); if (!state) { return; } } if (typeof state === 'string') { state = JSON.parse(state); } if (state.filter && !that.filterable) { state.filter = ''; } let filteringChanged = state.filter !== that._state.filter, sortingChanged = state.sorted !== that.sorted; if (sortingChanged) { that.sorted = state.sorted; that._updateState('sorted', that.sorted); if (state.sorted) { that._applyGrouping(that.$.mainContainer); } else { that._unsortItems(that.$.mainContainer); } if (state.filter || filteringChanged) { that._applyFilter(state.filter); that.$.filterInput.value = state.filter; } } else if (filteringChanged) { that._applyFilter(state.filter); that.$.filterInput.value = state.filter; } that._menuItemsGroupsToExpand = []; for (let i = 0; i < state.expanded.length; i++) { const originallyExpandedItem = that.getItem(state.expanded[i]); if (originallyExpandedItem) { that._menuItemsGroupsToExpand.push(originallyExpandedItem); } } that._expandItemsByDefault(true); for (let i = 0; i < state.selected.length; i++) { const originallySelectedItem = that.getItem(state.selected[i]); if (originallySelectedItem) { selectedIndexes.push(originallySelectedItem.path); } } that.selectedIndexes = selectedIndexes; that._applySelection(false, oldSelectedIndexes); } /** * Moves an item down relative to its siblings. * * @param {HTMLElement/String} item The lw-tree-item/lw-tree-items-group (or its id or numeric path) to remove. */ moveDown(item) { const that = this; item = that.getItem(item); const nextSibling = item.nextElementSibling; if (item === undefined || !nextSibling || that.sorted) { return; } that._moveTreeItem(item, nextSibling, 2, [that]); if (that.filterable && that._state.filter) { that._applyFilter(that._state.filter); } } /** * Moves an item up relative to its siblings. * * @param {HTMLElement/String} item The lw-tree-item/lw-tree-items-group (or its id or numeric path) to remove. */ moveUp(item) { const that = this; item = that.getItem(item); const previousSibling = item.previousElementSibling; if (item === undefined || !previousSibling || that.sorted) { return; } that._moveTreeItem(item, previousSibling, 0, [that]); if (that.filterable && that._state.filter) { that._applyFilter(that._state.filter); } } /** * Refreshes the layout of the Tree */ refresh() { this._checkOverflow(); } /** * Removes an item. * * @param {HTMLElement/String} item The lw-tree-item/lw-tree-items-group (or its id or numeric path) to remove. */ removeItem(item) { const that = this; item = that.getItem(item); if (item === undefined) { return; } if (item instanceof LW.TreeItemsGroup) { const container = item.container; if (that._isContainerOpened(container.level, container)) { that._closeSubContainersTreeMode(container.level, container); } } const restoreSorting = that.sorted && that.autoSort; if (restoreSorting) { that._unsortItems(that.$.mainContainer); } item.parentElement.removeChild(item); that._menuItems = {}; that._refreshItemPaths(that.$.mainContainer, true, undefined, that.sorted && !that.autoSort); if (restoreSorting) { that._applyGrouping(that.$.mainContainer); } const filterQuery = that._state.filter, oldSelectedIndexes = that.selectedIndexes.slice(0); if (filterQuery) { that._applyFilter(filterQuery); } that._checkOverflow(); that.selectedIndexes = []; that._applySelection(true, oldSelectedIndexes); delete that._treeAnimationInProgress; } /** * Saves the Tree's state. */ saveState() { const that = this; if (!that.id) { that.warn(that.localize('noId')); } else { window.localStorage.setItem('lwTree' + that.id, JSON.stringify(that._state)); } return JSON.parse(JSON.stringify(that._state)); } /** * Selects an item. * * @param {HTMLElement/String} item lw-tree-item/lw-tree-items-group (or its id or numeric path). */ select(item) { const that = this; item = that.getItem(item); if (item === undefined || item.selected || item.templateApplied) { return; } that._handleSelection(item, { type: 'programmatic' }); } /** * Unselects an item. * * @param {HTMLElement/String} item lw-tree-item/lw-tree-items-group (or its id or numeric path). */ unselect(item) { const that = this; item = that.getItem(item); if (item === undefined || !item.selected || item.templateApplied) { return; } that._handleSelection(item, { type: 'programmatic' }); } /** * Updates an item. * * @param {HTMLElement/String} item lw-tree-item/lw-tree-items-group (or its id or numeric path). * @param {Object} newItem An object with updated properties. */ updateItem(item, newItem) { const that = this; item = that.getItem(item); if (item === undefined || newItem === undefined) { return; } const treeItem = item instanceof LW.TreeItem; for (let prop in newItem) { if (newItem.hasOwnProperty(prop)) { if (treeItem) { if (['disabled', 'label', 'level', 'selected', 'separator', 'shortcut', 'value'].indexOf(prop) === -1) { continue; } } else if (['disabled', 'expanded', 'label', 'level', 'selected', 'separator', 'value'].indexOf(prop) === -1) { continue; } item[prop] = newItem[prop]; } } } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; super.propertyChangedHandler(propertyName, oldValue, newValue); switch (propertyName) { case 'allowDrag': case 'allowDrop': case 'autoLoadState': case 'autoSort': case 'editable': case 'filterInputPlaceholder': case 'loadingIndicatorPlaceholder': case 'selectionDisplayMode': case 'showLines': case 'showRootLines': case 'toggleElementPosition': case 'toggleMode': break; case 'autoHideToggleElement': if (newValue) { that.$mainContainer.addClass('hidden-arrows'); } else { that.$mainContainer.removeClass('hidden-arrows'); } break; case 'autoSaveState': if (!newValue) { return; } if (!that.id) { that.warn(that.localize('noId')); that.autoSaveState = false; return; } window.localStorage.setItem('lwTree' + that.id, JSON.stringify(that._state)); break; case 'dataSource': { const oldSelectedIndexes = that.selectedIndexes.slice(0); that.selectedIndexes = []; that._menuItems = {}; that._processDataSource(); that._checkOverflow(); that._expandItemsByDefault(); that._applySelection(true, oldSelectedIndexes); const filterQuery = that._state.filter; if (filterQuery) { that._applyFilter(filterQuery); } break; } case 'disabled': that._setFocusable(); that.$.scrollButtonNear.disabled = newValue; that.$.scrollButtonFar.disabled = newValue; if (!newValue) { that._updateScrollButtonVisibility(); } break; case 'displayLoadingIndicator': if (newValue) { that._discardKeyboardHover(true); that.$loadingIndicatorContainer.removeClass('lw-hidden'); } else { that.$loadingIndicatorContainer.addClass('lw-hidden'); } break; case 'filterable': if (newValue === false) { that._applyFilter(''); that.$.filterInput.value = ''; } that._checkOverflow(); break; case 'filterMode': if (that.filterable && that._state.filter) { that._applyFilter(that._state.filter); } break; case 'hasThreeStates': if (that.selectionMode !== 'checkBox') { return; } if (newValue) { that._applySelection(false); } else { const indeterminateItems = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[indeterminate]'); for (let i = 0; i < indeterminateItems.length; i++) { indeterminateItems[i].removeAttribute('indeterminate'); } } break; case 'loadingIndicatorPosition': if (newValue === 'center') { that.$loadingIndicatorPlaceHolder.addClass('lw-hidden'); } else { that.$loadingIndicatorPlaceHolder.removeClass('lw-hidden'); } break; case 'overflow': if (that.scrollMode === 'scrollbar') { if (newValue === 'hidden') { that.$.scrollViewer.$.verticalScrollBar.setAttribute('aria-hidden', true); } else { that.$.scrollViewer.$.verticalScrollBar.removeAttribute('aria-hidden'); } if (newValue === 'scroll') { that.$.scrollViewer.verticalScrollBarVisibility = 'visible'; } else { that.$.scrollViewer.verticalScrollBarVisibility = 'auto'; } return; } that.$.scrollViewer.scrollTop = 0; if (newValue === 'hidden') { that.$scrollViewer.removeClass('scroll-buttons-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); } else { that.$.scrollButtonNear.disabled = that.disabled; that.$.scrollButtonFar.disabled = that.disabled; if (newValue === 'auto') { that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); that._checkOverflow(); } else { that.$scrollViewer.addClass('scroll-buttons-shown'); that.$scrollViewer.removeClass('one-button-shown'); that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); that._updateScrollButtonVisibility(); } } that.$.scrollViewer.refresh(); break; case 'rightToLeft': { let oldPadding, newPadding; if (newValue) { oldPadding = 'paddingLeft'; newPadding = 'paddingRight'; } else { oldPadding = 'paddingRight'; newPadding = 'paddingLeft'; } for (let path in that._menuItems) { if (that._menuItems.hasOwnProperty(path)) { const item = that._menuItems[path], labelContainer = item.firstElementChild; labelContainer.style[oldPadding] = ''; that._setIndentation(labelContainer, item.level, newPadding); } } break; } case 'scrollMode': if (that.overflow === 'hidden') { return; } that.$.scrollViewer.scrollTop = 0; if (newValue === 'scrollButtons') { if (that.overflow === 'scroll') { that.$scrollViewer.addClass('scroll-buttons-shown'); that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); } that.$.scrollViewer.$.verticalScrollBar.setAttribute('aria-hidden', true); that.$.scrollViewer.verticalScrollBarVisibility = 'auto'; that._checkOverflow(); return; } that.$.scrollViewer.$.verticalScrollBar.removeAttribute('aria-hidden'); that.$scrollViewer.removeClass('scroll-buttons-shown'); that.$scrollViewer.removeClass('one-button-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); if (that.overflow === 'auto') { that.$.scrollViewer.verticalScrollBarVisibility = 'auto'; } else { that.$.scrollViewer.verticalScrollBarVisibility = 'visible'; } break; case 'selectedIndexes': that._applySelection(false, oldValue); break; case 'selectionMode': that.setAttribute('aria-multiselectable', ['oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'checkBox', 'radioButton'].indexOf(newValue) !== -1); if (that._menuItems['0'] === undefined) { return; } if ((oldValue === 'one' && newValue !== 'none' && newValue !== 'checkBox' && newValue !== 'radioButton') || (oldValue.indexOf('oneOrMany') !== -1 && newValue.indexOf('oneOrMany') !== -1) || (oldValue === 'none' && (newValue.indexOf('zero') !== -1 || newValue === 'checkBox')) || (newValue === 'zeroOrMany' && oldValue !== 'checkBox') || (oldValue === 'radioButton' && newValue.indexOf('Many') !== -1) || (!that.hasThreeStates && (newValue === 'checkBox' || oldValue === 'checkBox' && newValue === 'zeroOrMany'))) { if (newValue === 'one' || newValue === 'oneOrManyExtended') { that._lastSelectedItem = that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]]; } else { that._lastSelectedItem = undefined; } that._applyAriaSelected(); return; } if (that.hasThreeStates && oldValue === 'checkBox') { const indeterminateItems = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[indeterminate]'); for (let i = 0; i < indeterminateItems.length; i++) { indeterminateItems[i].removeAttribute('indeterminate'); } } that._applySelection(false); break; case 'sort': { if (!that.sorted) { return; } that._refreshSorting(); break; } case 'sortDirection': if (that.sorted && !that.sort) { that._unsortItems(that.$.mainContainer); that._applyGrouping(that.$.mainContainer); } break; case 'sorted': { if (!newValue && !that.autoSort) { that._refreshItemPathsAndSelection(); that._updateState('sorted', false); return; } if (newValue) { that._applyGrouping(that.$.mainContainer); } else { that._unsortItems(that.$.mainContainer); } const filterQuery = that._state.filter; if (filterQuery) { that._applyFilter(filterQuery); } that._updateState('sorted', newValue); that._checkOverflow(); break; } case 'unfocusable': that._setFocusable(); break; } } /** * Adds drag feedback. */ _addDragFeedback() { const that = this, feedback = document.createElement('div'); feedback.className = 'lw-tree-item-feedback'; feedback.setAttribute('parent-tree-id', that.id); if (that.theme) { feedback.setAttribute('theme', that.theme); } if (that.dragFeedbackFormatFunction) { feedback.innerHTML = that.dragFeedbackFormatFunction(that._dragDetails.Items); } else if (that._dragDetails.Items.length === 1) { feedback.innerHTML = that._dragDetails.Item.label; } else { feedback.classList.add('multiple'); feedback.innerHTML = '&#xf0c5;'; } document.body.appendChild(feedback); return feedback; } /** * Applies filter. */ _applyFilter(filterQuery) { const that = this; function hide(filteredItem, item) { if (filteredItem) { if (item.hidden) { item.$.removeClass('lw-hidden'); } item.hidden = false; } else { if (!item.hidden) { item.$.addClass('lw-hidden'); } item.hidden = true; } } function filter(item, childItems) { let shownChildren = false, numberOfShownChildren = 0, lastShownChild; childItems = Array.from(childItems); // filter children for (let i = 0; i < childItems.length; i++) { const currentChild = childItems[i]; if (currentChild instanceof LW.TreeItem) { hide(that._findItem(currentChild, filterQuery), currentChild); } else { filter(currentChild, currentChild.itemContainer.children); } if (!currentChild.hidden) { numberOfShownChildren++; lastShownChild = currentChild; } shownChildren = shownChildren || !currentChild.hidden; } // filter the item itself if (item !== that.$.mainContainer) { const filteredItem = that._findItem(item, filterQuery); hide(shownChildren || filteredItem, item); if (shownChildren && filteredItem === null) { item.$.addClass('filtered-child'); } else { item.$.removeClass('filtered-child'); } if (!shownChildren && childItems.length > 0) { item.hiddenChildren = true; item.$.addClass('hidden-children'); that.collapseItem(item, undefined, false); } else { item.hiddenChildren = false; item.$.removeClass('hidden-children'); } } if (filterQuery !== '' && numberOfShownChildren > 0) { lastShownChild.$.addClass('last-filtered-child'); } } if (filterQuery === '' && !that.hasAttribute('filter-applied')) { return; } const lastFilteredChildren = Array.from(that.$.mainContainer.getElementsByClassName('last-filtered-child')); for (let i = 0; i < lastFilteredChildren.length; i++) { lastFilteredChildren[i].$.removeClass('last-filtered-child'); } filter(that.$.mainContainer, that.$.mainContainer.children); if (filterQuery !== '') { that.setAttribute('filter-applied', ''); } else { that.removeAttribute('filter-applied'); } that._updateState('filter', filterQuery); that._checkOverflow(); } /** * Applies hierarchical checkbox selection. */ _applyHierarchicalSelection(item, validatedSelection) { const that = this, branch = item !== that.$.mainContainer, children = branch ? item.itemContainer.children : item.children; let selectedChildren = 0, indeterminateChildren = 0; for (let i = 0; i < children.length; i++) { const currentChild = children[i]; if (item.selected) { currentChild.set('selected', true); } if (currentChild instanceof LW.TreeItemsGroup) { that._applyHierarchicalSelection(currentChild, validatedSelection); } else if (currentChild.selected) { validatedSelection.push(currentChild.path); } if (branch) { if (currentChild.selected) { selectedChildren++; } else if (currentChild.hasAttribute('indeterminate')) { indeterminateChildren++; } } } if (!branch) { return; } that._setThreeStateCheckbox(item, selectedChildren, indeterminateChildren); if (item.selected) { validatedSelection.push(item.path); } } /** * Applies radio button selection. */ _applyRadioButtonSelection(item, initiallySelected, validatedSelection) { const that = this, children = item !== that.$.mainContainer ? item.itemContainer.children : item.children, selectedChildren = []; let selectedSibling; for (let i = 0; i < children.length; i++) { const currentChild = children[i]; if (currentChild instanceof LW.TreeItemsGroup) { that._applyRadioButtonSelection(currentChild, initiallySelected, validatedSelection); } currentChild.set('selected', false); if (initiallySelected.indexOf(currentChild.path) !== -1) { selectedChildren.push(currentChild); } } if (selectedChildren.length === 0) { selectedSibling = children[0]; } else { selectedSibling = selectedChildren[selectedChildren.length - 1]; } selectedSibling.set('selected', true); validatedSelection.push(selectedSibling.path); } /** * Applies selection. */ _applySelection(combine, oldSelectedIndexes) { const that = this; let selected = that.selectedIndexes.slice(0); if (oldSelectedIndexes === undefined) { oldSelectedIndexes = selected.slice(0); } if (that._menuItems['0'] === undefined) { // no items in Tree that.selectedIndexes = []; that._lastSelectedItem = undefined; if (that.isRendered && JSON.stringify(oldSelectedIndexes) !== JSON.stringify([])) { that.$.fireEvent('change', { 'selectedIndexes': that.selectedIndexes, 'oldSelectedIndexes': oldSelectedIndexes }); } return; } const selectionMode = that.selectionMode, itemsWithSelectedAttr = Array.from((that.shadowRoot || that).querySelectorAll('lw-tree-item[selected], lw-tree-items-group[selected]')); for (let i = selected.length - 1; i >= 0; i--) { const currentMatchingItem = that._menuItems[selected[i]]; if (currentMatchingItem === undefined) { selected.splice(i, 1); } } if (combine) { for (let i = 0; i < itemsWithSelectedAttr.length; i++) { if (selected.indexOf(itemsWithSelectedAttr[i].path) === -1) { selected.push(itemsWithSelectedAttr[i].path); } } } else { for (let i = 0; i < itemsWithSelectedAttr.length; i++) { itemsWithSelectedAttr[i].set('selected', false); } itemsWithSelectedAttr.length = 0; } that._sortPathCollection(selected); switch (selectionMode) { case 'none': selected.length = 0; for (let i = 0; i < itemsWithSelectedAttr.length; i++) { itemsWithSelectedAttr[i].set('selected', false); } break; case 'one': case 'zeroOrOne': if (selectionMode !== 'zeroOrOne' && selected.length === 0) { selected.push('0'); } for (let i = 0; i < selected.length; i++) { const currentMatchingItem = that._menuItems[selected[i]]; if (i === selected.length - 1) { currentMatchingItem.set('selected', true); selected = [selected[i]]; break; } if (itemsWithSelectedAttr.indexOf(currentMatchingItem) !== -1) { currentMatchingItem.set('selected', false); } } break; case 'oneOrMany': case 'oneOrManyExtended': if (selected.length === 0) { selected.push('0'); } for (let i = 0; i < selected.length; i++) { that._menuItems[selected[i]].set('selected', true); } break; case 'zeroOrMany': case 'checkBox': for (let i = 0; i < selected.length; i++) { that._menuItems[selected[i]].set('selected', true); } if (selectionMode === 'checkBox' && that.hasThreeStates) { const validatedSelection = []; that._applyHierarchicalSelection(that.$.mainContainer, validatedSelection); that._sortPathCollection(validatedSelection); selected = validatedSelection; } break; case 'radioButton': { const validatedSelection = []; that._applyRadioButtonSelection(that.$.mainContainer, selected, validatedSelection); that._sortPathCollection(validatedSelection); selected = validatedSelection; break; } } that.selectedIndexes = selected; that._updateState('selected'); if (selectionMode === 'one' || selectionMode === 'oneOrManyExtended') { that._lastSelectedItem = that._menuItems[selected[selected.length - 1]]; } else { that._lastSelectedItem = undefined; } if (that.isRendered && arguments[2] !== false && JSON.stringify(oldSelectedIndexes) !== JSON.stringify(selected)) { that.$.fireEvent('change', { 'selectedIndexes': that.selectedIndexes, 'oldSelectedIndexes': oldSelectedIndexes }); } that._applyAriaSelected(); } /** * Applies "aria-selected" attribute to items (related to WAI-ARIA support). */ _applyAriaSelected() { const that = this, selectionMode = that.selectionMode; for (let path in that._menuItems) { const item = that._menuItems[path]; if (item.selected) { item.setAttribute('aria-selected', true); } else if (!that._canItemBeSelected(item) || ['oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'checkBox', 'radioButton'].indexOf(selectionMode) === -1) { item.removeAttribute('aria-selected'); } else { item.setAttribute('aria-selected', false); } } } /** * Automatically loads stored state. */ _autoLoadState(state) { const that = this, selectedIndexes = []; for (let i = 0; i < that._menuItemsGroupsToExpand.length; i++) { that._menuItemsGroupsToExpand[i].set('expanded', false); } that._menuItemsGroupsToExpand = []; for (let i = 0; i < state.expanded.length; i++) { const originallyExpandedItem = that.getItem(state.expanded[i]); if (originallyExpandedItem) { that._menuItemsGroupsToExpand.push(originallyExpandedItem); } } if (that.filterable && state.filter) { that._applyFilter(state.filter); that.$.filterInput.value = state.filter; } for (let i = 0; i < state.selected.length; i++) { const originallySelectedItem = that.getItem(state.selected[i]); if (originallySelectedItem) { selectedIndexes.push(originallySelectedItem.path); } } that.selectedIndexes = selectedIndexes; } /** * blur handler. */ _blurHandler() { this._discardKeyboardHover(true); } /** * Checks if an item can be hovered. */ _canItemBeHovered(item) { const level = item.level; return item.disabled === false && item.templateApplied !== true && item.hidden !== true && (level === 1 || level > 1 && this._isContainerOpened(level, item.parentElement.container) && item.getBoundingClientRect().height > 0); } /** * Checks if an item can be selected. */ _canItemBeSelected(item) { return item.disabled === false && item.templateApplied !== true; } /** * Checks if items overflow and shows/hides scroll buttons. */ _checkOverflow() { const that = this, scrollViewer = that.$.scrollViewer, overflow = that.overflow; if (that.scrollMode === 'scrollbar' || overflow === 'hidden') { scrollViewer.refresh(); return; } const oldScrollTop = scrollViewer.scrollTop; if (overflow === 'auto') { scrollViewer.$.removeClass('scroll-buttons-shown'); scrollViewer.$.removeClass('one-button-shown'); that.$scrollButtonNear.addClass('lw-hidden'); that.$scrollButtonFar.addClass('lw-hidden'); } const overflowing = Math.round(scrollViewer.$.scrollViewerContentContainer.offsetHeight) > Math.round(scrollViewer.$.scrollViewerContainer.offsetHeight), showNear = Math.round(scrollViewer.scrollTop) > 0, showFar = Math.round(scrollViewer.$.scrollViewerContainer.offsetHeight + scrollViewer.scrollTop) < Math.round(scrollViewer.$.scrollViewerContentContainer.offsetHeight); if (overflowing) { if (overflow === 'auto') { scrollViewer.$.addClass('scroll-buttons-shown'); if (showNear) { that.$scrollButtonNear.removeClass('lw-hidden'); } if (showFar) { that.$scrollButtonFar.removeClass('lw-hidden'); } if ((showNear && showFar) === false) { scrollViewer.$.addClass('one-button-shown'); } if (!that.disabled) { that.$.scrollButtonNear.disabled = false; that.$.scrollButtonFar.disabled = false; } scrollViewer.scrollTop = oldScrollTop; } else { that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); if (that.disabled) { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } else { that.$.scrollButtonNear.disabled = !showNear; that.$.scrollButtonFar.disabled = !showFar; } } } else if (overflow === 'scroll') { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } scrollViewer.refresh(); } /** * Applies initial settings to the Tree element. */ _createElement() { const that = this, scrollViewerStyle = window.getComputedStyle(that.$.scrollViewer); that.setAttribute('role', 'tree'); that.setAttribute('aria-multiselectable', ['oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'checkBox', 'radioButton'].indexOf(that.selectionMode) !== -1); that.setAttribute('aria-orientation', 'vertical'); that.$.scrollViewer.onVerticalChange = that._verticalScrollbarHandler; Object.defineProperty(that, 'dataSource', { get: function () { if (that.context === that) { return that.properties.dataSource.value; } else { return that._getDataSource(); } }, set(value) { that.updateProperty(that, that._properties.dataSource, value); } }); if (!that.id && (that.autoLoadState || that.autoSaveState)) { that.warn(that.localize('noId')); that.autoLoadState = false; that.autoSaveState = false; } that.mode = 'tree'; that._element = 'tree'; that._isMobile = LW.Utilities.Core.isMobile; that._edgeMacFF = false; that._autoScrollCoefficient = LW.Utilities.Core.Browser.Firefox ? 4 : LW.Utilities.Core.Browser.Edge ? 8 : 2; that._scrollViewerPadding = (parseFloat(scrollViewerStyle.paddingTop) + parseFloat(scrollViewerStyle.paddingBottom)) || 0; that._state = { expanded: [], filter: '', selected: [] }; that._dblclickObject = { numberOfClicks: 0 }; if (that.autoHideToggleElement) { that.$mainContainer.addClass('hidden-arrows'); } if (that.disabled) { that.$.scrollButtonNear.disabled = true; that.$.scrollButtonFar.disabled = true; } if (that.scrollMode === 'scrollbar' && that.overflow === 'scroll') { that.$.scrollViewer.verticalScrollBarVisibility = 'visible'; } if (that.dataSource === null && that.$.mainContainer.firstElementChild instanceof HTMLUListElement) { that._processUList(); } const items = (that.shadowRoot || that).querySelectorAll('lw-tree-item, lw-tree-items-group'); const itemsReady = function () { let previousState; if (that.autoLoadState) { previousState = window.localStorage.getItem('lwTree' + that.id); if (previousState) { previousState = JSON.parse(previousState); that.sorted = previousState.sorted; } } that._setFocusable(); that._menuItems = {}; if (that.dataSource === null) { that._processHTML(that.$.mainContainer, 1); } else { that._processDataSource(); } if (that.scrollMode === 'scrollButtons' || that.overflow === 'hidden') { that.$.scrollViewer.$.verticalScrollBar.setAttribute('aria-hidden', true); } if (that.scrollMode === 'scrollButtons' && that.overflow === 'scroll') { that.$scrollViewer.addClass('scroll-buttons-shown'); that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); that._updateScrollButtonVisibility(); } that._checkOverflow(); if (previousState) { that._autoLoadState(previousState); } that._expandItemsByDefault(); that._applySelection(true); that._updateState('sorted', that.sorted); if (that.displayLoadingIndicator) { that.$loadingIndicatorContainer.removeClass('lw-hidden'); } if (that.loadingIndicatorPosition !== 'center') { that.$loadingIndicatorPlaceHolder.removeClass('lw-hidden'); } if (that.__onCompleted) { that._onCompleted = that.__onCompleted; that.__onCompleted = null; that._onCompleted(); } } if (items.length === 0 || that.enableShadowDOM || that.isInShadowDOM) { itemsReady(); } else { if (that._onCompleted) { that.__onCompleted = that._onCompleted; that._onCompleted = null; } that._ensureItemsReady(items, itemsReady); } that.checkLicense(); } /** * dblclick handler. */ _dblclickHandler(pressedItem, arrow, event) { const that = this; if (that.toggleMode !== 'dblclick' || pressedItem instanceof LW.TreeItem || arrow) { return; } that._menuItemsGroupSelectionHandler(pressedItem, event); } /** * Removes "focused" class added by keyboard navigation. */ _discardKeyboardHover(overrideCheck, mouseoutMouseover) { const that = this; if (mouseoutMouseover || !that._hoveredViaKeyboard) { return; } if (!overrideCheck && that._hoveredViaKeyboard instanceof LW.MenuItemsGroup && that._isContainerOpened(that._hoveredViaKeyboard.level + 1, that._hoveredViaKeyboard.container)) { return; } that._hoveredViaKeyboard.removeAttribute('focus'); that._hoveredViaKeyboard = undefined; } /** * Document up handler. */ _documentUpHandler(event) { if (event.originalEvent.type === 'pointercancel') { return; } const that = this, downTimeoutInfo = that._downTimeoutInfo, dragDetails = that._dragDetails; if (downTimeoutInfo && (!dragDetails || !dragDetails.FeedbackShown)) { clearTimeout(downTimeoutInfo.timeout); if (that.$.scrollViewer.scrollTop === downTimeoutInfo.scrollTop || that.getBoundingClientRect().top !== downTimeoutInfo.top) { that._continueSelection(downTimeoutInfo.target, downTimeoutInfo.event); } } delete that._downTimeoutInfo; const downItem = that._downItem, upTarget = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; delete that._downItem; if (that._editedItem && !that._editInputDown && (!that._isMobile && upTarget !== that.$.editInput || that._isMobile && (document.elementFromPoint(event.clientX, event.clientY) !== that.$.editInput))) { that._endEditing(); return; } delete that._editInputDown; if (downItem) { const pressedItem = upTarget.closest('lw-tree-item') || upTarget.closest('lw-tree-items-group'); if (pressedItem && pressedItem.selected && pressedItem === downItem && (!that._dragDetails || !that._dragDetails.FeedbackShown) && !(pressedItem instanceof LW.TreeItemsGroup && (upTarget.closest('.lw-tree-items-group-arrow') || upTarget === pressedItem.container || upTarget === pressedItem.container.firstElementChild))) { that._handleSelection(pressedItem, event); } } if (!dragDetails) { return; } const targetTree = LW.Tree.hoveredTree, targetItem = LW.Tree.hoveredItem; delete that._dragDetails; delete LW.Tree.treeItemDragged; delete LW.Tree.hoveredTree; delete LW.Tree.hoveredItem; that.$.scrollViewer._scrollView.disableSwipeScroll = false; if (!dragDetails.FeedbackShown) { return; } const dropTarget = targetTree || document.elementFromPoint(event.clientX, event.clientY); let position; document.body.classList.remove('lw-dragging'); document.body.removeChild(dragDetails.Feedback); if (targetTree) { clearInterval(targetTree._dragInterval); } const draggedItem = dragDetails.Item, draggedItems = dragDetails.Items, validDraggedItems = dragDetails.ValidItems; if (!dropTarget) { return; } if (!targetItem || draggedItem.contains(targetItem)) { // drops item somewhere in the DOM that.$.fireEvent('dragEnd', { 'item': draggedItem, 'items': draggedItems, 'target': dropTarget, 'data': dragDetails, 'previousContainer': that, 'container': targetTree || dropTarget, 'originalEvent': event }); return; } if (!(targetTree && targetTree.allowDrop && !targetTree.disabled)) { return; } const affectedTrees = [targetTree]; let dropDetailsPosition; targetItem.classList.remove('drop-target'); if (targetItem.classList.contains('top')) { targetItem.classList.remove('top'); dropDetailsPosition = 'top'; position = 0; } else if (targetItem.classList.contains('bottom')) { targetItem.classList.remove('bottom'); dropDetailsPosition = 'bottom'; position = 2; } else { dropDetailsPosition = 'inside'; position = 1; } dragDetails.DropDetails = { item: targetItem, position: dropDetailsPosition }; if (targetTree !== that) { affectedTrees.push(that); } else if (dragDetails.ValidateOnDrop) { // drop inside the same tree for (let i = 0; i < validDraggedItems.length; i++) { if (validDraggedItems[i].contains(targetItem)) { return; } } } const dragEndEvent = that.$.fireEvent('dragEnd', { 'item': draggedItem, 'items': draggedItems, 'target': targetItem, 'data': dragDetails, 'previousContainer': that, 'container': targetTree, 'originalEvent': event }); if (dragEndEvent.defaultPrevented) { return; } if (targetTree.sorted && targetTree.autoSort) { targetTree._unsortItems(targetTree.$.mainContainer); } for (let i = 0; i < validDraggedItems.length; i++) { that._moveTreeItem(validDraggedItems[i], targetItem, position, affectedTrees); } if (targetTree.sorted && targetTree.autoSort) { targetTree._applyGrouping(targetTree.$.mainContainer); } if (targetTree !== that && targetTree._state.filter) { targetTree._applyFilter(targetTree._state.filter); } } /** * editInput blur handler. */ _editInputBlurHandler() { this._endEditing(); } /** * Ends editing operation. */ _endEditing(discardChanges) { const that = this, editedItem = that._editedItem; if (!editedItem) { return; } delete that._editedItem; that.$editInput.addClass('lw-hidden'); that.focus(); if (discardChanges) { return; } const newValue = that.$.editInput.value, restoreSorting = that.sorted && that.autoSort, filterQuery = that._state.filter; if (newValue === editedItem.label) { return; } editedItem.set('label', newValue); editedItem.setAttribute('aria-label', newValue); editedItem.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue; if (restoreSorting) { that._unsortItems(that.$.mainContainer); that._applyGrouping(that.$.mainContainer); } if (filterQuery) { that._applyFilter(filterQuery); } } /** * Makes sure an item is visible by scrolling to it. */ _ensureVisible(item) { const that = this; that._ensureVisibleTreeMode(item, item.getBoundingClientRect(), that.$.scrollViewer, that.$.scrollViewer.getBoundingClientRect(), that._scrollViewerPadding); //Used in GanttChart to ensure the TaskBar inside the Timeline is also visible if (that._ensureVisibleCallback) { that._ensureVisibleCallback(item); } } /** * filterInput keydown handler. */ _filterInputKeydownHandler(event) { if (event.key !== 'PageDown') { if (event.key === 'PageUp') { event.preventDefault(); event.stopPropagation(); } return; } const that = this; let itemToHighlight; event.preventDefault(); event.stopPropagation(); if (that.selectedIndexes.length > 0) { const oldSelectedIndexes = that.selectedIndexes.slice(0); itemToHighlight = that._lastSelectedItem || that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]]; if (that.selectionMode !== 'checkBox' && that.selectionMode !== 'radioButton') { that.selectedIndexes = [itemToHighlight.path]; that._applySelection(false, oldSelectedIndexes); } that.focus(); } else { itemToHighlight = that._getFirstEnabledChild(that.$.mainContainer); that.focus(); if (itemToHighlight) { that._hoverViaKeyboard(itemToHighlight); } } that._ensureVisible(itemToHighlight); } /** * focus handler. */ _focusHandler() { const that = this; if (that.selectedIndexes.length > 0 && !that._hoveredViaKeyboard) { if (that._lastSelectedItem) { that._hoverViaKeyboard(that._lastSelectedItem, false, undefined, false); } else { that._hoverViaKeyboard(that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]], false, undefined, false); } } } /** * Gets a JSON representation of the current Tree state. */ _getDataSource() { const that = this, dataSource = []; function recursion(children, itemsArray) { for (let i = 0; i < children.length; i++) { const currentChild = children[i], dataSourceItem = { label: currentChild.label }; if (currentChild.disabled) { dataSourceItem.disabled = true; } if (currentChild.selected) { dataSourceItem.selected = true; } if (currentChild.separator) { dataSourceItem.separator = true; } if (currentChild.value !== null) { dataSourceItem.value = currentChild.value; } if (currentChild instanceof LW.TreeItem) { if (currentChild.shortcut) { dataSourceItem.shortcut = currentChild.shortcut; } } else { if (currentChild.expanded) { dataSourceItem.expanded = true; } dataSourceItem.items = []; recursion(currentChild.itemContainer.children, dataSourceItem.items); } itemsArray.push(dataSourceItem); } } recursion(that.$.mainContainer.children, dataSource); return dataSource; } /** * Handles hierarchical checkbox selection. */ _handleHierarchicalSelection(item, selectedIndexes) { function checkUncheckChildren(item, check) { const children = item.itemContainer.children; for (let i = 0; i < children.length; i++) { const currentChild = children[i]; currentChild.set('selected', check); currentChild.setAttribute('aria-selected', check); currentChild.removeAttribute('indeterminate'); if (currentChild instanceof LW.TreeItemsGroup) { checkUncheckChildren(currentChild, check); } } } const that = this; let currentItem = item; if (item.selected) { item.set('selected', false); item.setAttribute('aria-selected', false); } else { item.set('selected', true); item.setAttribute('aria-selected', true); item.removeAttribute('indeterminate'); } while (currentItem.parentItem) { const parent = currentItem.parentItem, children = parent.itemContainer.children; let selectedChildren = 0, indeterminateChildren = 0; for (let i = 0; i < children.length; i++) { if (children[i].selected) { selectedChildren++; } else if (children[i].hasAttribute('indeterminate')) { indeterminateChildren++; } } that._setThreeStateCheckbox(parent, selectedChildren, indeterminateChildren); currentItem = parent; } if (item instanceof LW.TreeItemsGroup) { checkUncheckChildren(item, item.selected); } selectedIndexes.length = 0; const selectedItems = Array.from((that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[selected]')); for (let i = 0; i < selectedItems.length; i++) { selectedIndexes.push(selectedItems[i].path); } that._sortPathCollection(selectedIndexes); } /** * Handles item selection. */ _handleSelection(item, event) { const that = this, selectionMode = that.selectionMode; if (selectionMode === 'none' || (event.type !== 'programmatic' && !that._canItemBeSelected(item))) { return; } const selected = item.selected; if (selected && event.type === 'down') { return; } const oldSelectedIndexes = that.selectedIndexes.slice(0); let selectedIndexes = oldSelectedIndexes.slice(0); switch (selectionMode) { case 'one': if (selected) { return; } that._menuItems[selectedIndexes[0]].set('selected', false); that._menuItems[selectedIndexes[0]].removeAttribute('aria-selected'); that.selectedIndexes = [item.path]; item.set('selected', true); item.setAttribute('aria-selected', true); that._lastSelectedItem = item; break; case 'zeroOrOne': if (selected) { that.selectedIndexes = []; item.set('selected', false); item.removeAttribute('aria-selected'); } else { if (selectedIndexes[0] !== undefined) { that._menuItems[selectedIndexes[0]].set('selected', false); that._menuItems[selectedIndexes[0]].removeAttribute('aria-selected'); } that.selectedIndexes = [item.path]; item.set('selected', true); item.setAttribute('aria-selected', true); } break; case 'oneOrMany': case 'zeroOrMany': if (selected) { if (selectedIndexes.length === 1 && selectionMode !== 'zeroOrMany') { return; } selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1); item.set('selected', false); item.setAttribute('aria-selected', false); } else { selectedIndexes.push(item.path); that._sortPathCollection(selectedIndexes); item.set('selected', true); item.setAttribute('aria-selected', true); } that.selectedIndexes = selectedIndexes; break; case 'oneOrManyExtended': { const ctrlKey = event.ctrlKey, shiftKey = event.shiftKey; if (!ctrlKey && !shiftKey || shiftKey && item === that._lastSelectedItem) { for (let i = 0; i < selectedIndexes.length; i++) { that._menuItems[selectedIndexes[i]].set('selected', false); that._menuItems[selectedIndexes[i]].setAttribute('aria-selected', false); } selectedIndexes = [item.path]; item.set('selected', true); item.setAttribute('aria-selected', true); that._lastSelectedItem = item; } else if (ctrlKey) { if (item.selected && selectedIndexes.length > 1) { selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1); item.set('selected', false); item.setAttribute('aria-selected', false); } else if (!item.selected) { selectedIndexes.push(item.path); that._sortPathCollection(selectedIndexes); item.set('selected', true); item.setAttribute('aria-selected', true); that._lastSelectedItem = item; } } else if (shiftKey) { for (let i = 0; i < selectedIndexes.length; i++) { that._menuItems[selectedIndexes[i]].set('selected', false); that._menuItems[selectedIndexes[i]].setAttribute('aria-selected', false); } selectedIndexes = that._selectItemRange(that._lastSelectedItem, item); } that.selectedIndexes = selectedIndexes; break; } case 'checkBox': if (that.hasThreeStates) { that._handleHierarchicalSelection(item, selectedIndexes); } else { if (selected) { selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1); item.set('selected', false); item.setAttribute('aria-selected', false); } else { selectedIndexes.push(item.path); that._sortPathCollection(selectedIndexes); item.set('selected', true); item.setAttribute('aria-selected', true); } } that.selectedIndexes = selectedIndexes; break; case 'radioButton': { if (item.selected) { return; } let selectedSibling; for (let i = 0; i < item.parentElement.children.length; i++) { const currentSibling = item.parentElement.children[i]; if (currentSibling.selected) { selectedSibling = currentSibling; break; } } const selectedSiblingIndex = selectedIndexes.indexOf(selectedSibling.path); selectedSibling.set('selected', false); item.setAttribute('aria-selected', false); item.set('selected', true); item.setAttribute('aria-selected', true); selectedIndexes.splice(selectedSiblingIndex, 1); selectedIndexes.push(item.path); that._sortPathCollection(selectedIndexes); that.selectedIndexes = selectedIndexes; break; } } that._discardKeyboardHover(true); that._hoverViaKeyboard(item, false, undefined, !that._treeAnimationInProgress); that._updateState('selected'); if (JSON.stringify(oldSelectedIndexes) !== JSON.stringify(that.selectedIndexes)) { //Will prevent 'change' firing on ready() of the ownerElement if (that.ownerElement && !that.ownerElement.isRendered) { return; } that.$.fireEvent('change', { 'item': item, 'selectedIndexes': that.selectedIndexes, 'oldSelectedIndexes': oldSelectedIndexes }); } } /** * Highlights an item via the keyboard. */ _hoverViaKeyboard(item, selectOnHover, event, ensureVisible) { if (!item) { return; } const that = this; item.setAttribute('focus', ''); that._hoveredViaKeyboard = item; if (ensureVisible !== false) { that._ensureVisible(item); } if (selectOnHover) { that._handleSelection(item, event); } //NOTE: Used in GanttChart in order to handle Task Tree item focus state if (that._hoverViaKeyboardCallback) { that._hoverViaKeyboardCallback(item); } } /** * Keydown event handler. */ _keydownHandler(event) { const that = this, key = event.key; if (that._editedItem) { if (key === 'Enter') { that._endEditing(); } else if (key === 'Escape') { that._endEditing(true); } return; } if (that.getRootNode().activeElement !== that || ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Enter', 'F2', 'Home', 'PageDown', 'PageUp', ' '].indexOf(key) === -1 || that.disabled || that.displayLoadingIndicator) { return; } event.preventDefault(); const treeItems = Array.from(that.$.mainContainer.querySelectorAll('lw-tree-item, lw-tree-items-group')), selectOnHover = that.selectionMode === 'one' || that.selectionMode === 'oneOrManyExtended' && !event.ctrlKey, highlightedItem = that.$.mainContainer.querySelector('[focus]'); function moveDown(startIndex) { for (let i = startIndex; i < treeItems.length; i++) { const currentItem = treeItems[i]; if (that._canItemBeHovered(currentItem)) { if (highlightedItem) { if (highlightedItem === currentItem) { break; } highlightedItem.removeAttribute('focus'); } that._hoverViaKeyboard(currentItem, selectOnHover, event); break; } } } function moveUp(startIndex) { for (let i = startIndex; i >= 0; i--) { const currentItem = treeItems[i]; if (that._canItemBeHovered(currentItem)) { if (highlightedItem) { if (highlightedItem === currentItem) { break; } highlightedItem.removeAttribute('focus'); } that._hoverViaKeyboard(currentItem, selectOnHover, event); break; } } } function navigateToParentItem() { if (highlightedItem.level > 1 && that._canItemBeSelected(highlightedItem.parentItem)) { highlightedItem.removeAttribute('focus'); that._hoverViaKeyboard(highlightedItem.parentItem, selectOnHover, event); } } let startIndex; switch (key) { case 'ArrowDown': if (highlightedItem) { startIndex = treeItems.indexOf(highlightedItem) + 1; } else { startIndex = 0; } moveDown(startIndex); break; case 'ArrowLeft': if (!highlightedItem) { return; } if (highlightedItem instanceof LW.TreeItem) { navigateToParentItem(); } else { if (that._isContainerOpened(highlightedItem.level + 1, highlightedItem.container)) { that._closeSubContainersTreeMode(highlightedItem.level + 1, highlightedItem.container, true, true); return; } navigateToParentItem(); } break; case 'ArrowRight': if (!highlightedItem || highlightedItem instanceof LW.TreeItem) { return; } if (that._isContainerOpened(highlightedItem.level + 1, highlightedItem.container)) { const firstEnabledChild = that._getFirstEnabledChild(highlightedItem.itemContainer); if (firstEnabledChild) { highlightedItem.removeAttribute('focus'); that._hoverViaKeyboard(firstEnabledChild, selectOnHover, event); } } else { that._menuItemsGroupSelectionHandler(highlightedItem, { target: highlightedItem, type: 'keydown' }); } break; case 'ArrowUp': if (highlightedItem) { startIndex = treeItems.indexOf(highlightedItem) - 1; } else { startIndex = treeItems.length - 1; } moveUp(startIndex); break; case 'End': moveUp(treeItems.length - 1); break; case 'Enter': if (highlightedItem && highlightedItem instanceof LW.TreeItemsGroup) { that._menuItemsGroupSelectionHandler(highlightedItem, { target: highlightedItem, type: 'keydown' }); } break; case 'F2': if (that.editable) { that._startEditing(highlightedItem); } break; case 'Home': moveDown(0); break; case 'PageDown': that._pageDownHandler(treeItems, highlightedItem, selectOnHover, event); break; case 'PageUp': that._pageUpHandler(treeItems, highlightedItem, selectOnHover, event); break; case ' ': if (highlightedItem) { that._handleSelection(highlightedItem, event); } break; } } /** * mainContainer swipeleft/swiperight handler. */ _mainContainerSwipeHandler(event) { if (LW.Tree.treeItemDragged) { event.stopPropagation(); } } /** * lw-menu-items-group selection handler. */ _menuItemsGroupSelectionHandler(closestItemsGroup, event, fireEvent) { const that = this, toggleMode = that.toggleMode, arrow = event.originalEvent ? event.originalEvent.target.classList.contains('lw-tree-items-group-arrow') : false, container = closestItemsGroup.container; if (that._waitAnimation && that._treeAnimationInProgress) { return; } if (event.type === 'down' && !arrow && (toggleMode !== 'dblclick' || that._dblclickObject.numberOfClicks === 1)) { that._handleSelection(closestItemsGroup, event); } if (event.type === 'down' && !arrow && (toggleMode === 'dblclick' && that._dblclickObject.numberOfClicks !== 2 || toggleMode === 'click' && that._dblclickObject.numberOfClicks > 1 || toggleMode === 'arrow') || closestItemsGroup.hiddenChildren) { return; } const level = container.level; let animation = that.hasAnimation; if (event.type === 'keydown') { that._discardKeyboardHover(); } if (that._treeAnimationInProgress) { container.removeEventListener('transitionend', that._transitionendHandlerExpand); container.removeEventListener('transitionend', that._transitionendHandlerCollapse); } if (that._isContainerOpened(level, container)) { that._closeSubContainersTreeMode(level, container, true, fireEvent !== false); } else { const expandingEvent = that.$.fireEvent('expanding', { 'item': closestItemsGroup, 'label': closestItemsGroup.label, 'path': closestItemsGroup.path, 'value': closestItemsGroup.value, 'children': closestItemsGroup.itemContainer.children }); if (expandingEvent.defaultPrevented) { return; } if (animation) { if (event.type !== 'expand') { that._ensureVisibleOnTransitionend = closestItemsGroup; } that._expandSection(container); } container.$.removeClass('lw-visibility-hidden'); if (event.type === 'keydown') { closestItemsGroup.setAttribute('focus', ''); that._hoveredViaKeyboard = closestItemsGroup; } closestItemsGroup.$.addClass('lw-tree-items-group-opened'); closestItemsGroup.$.addClass('lw-tree-items-group-expanded'); that._addOpenedContainer(level, container); if (event.type === undefined) { that._hoverViaKeyboard(that._getFirstEnabledChild(closestItemsGroup.itemContainer)); } if (fireEvent !== false) { const eventDetail = { 'item': closestItemsGroup, 'label': closestItemsGroup.label, 'path': closestItemsGroup.path, 'value': closestItemsGroup.value, 'children': closestItemsGroup.itemContainer.children }; if (that.toggleCallback) { eventDetail.type = 'expand'; that.toggleCallback(eventDetail); } else { that.$.fireEvent('expand', eventDetail); } } } if (!animation) { that._checkOverflow(); if (event.type !== 'expand') { that._ensureVisible(closestItemsGroup); } } } /** * mouseenter handler. */ _mouseenterHandler() { const that = this; if (that.autoHideToggleElement) { that.$mainContainer.removeClass('hidden-arrows'); } if (LW.Tree.treeItemDragged && that.allowDrop && !that.disabled) { LW.Tree.hoveredTree = that; } } /** * mouseleave handler. */ _mouseleaveHandler() { const that = this; if (that.autoHideToggleElement) { that.$mainContainer.addClass('hidden-arrows'); } if (LW.Tree.treeItemDragged) { if (LW.Tree.hoveredTree) { clearInterval(LW.Tree.hoveredTree._dragInterval); delete LW.Tree.hoveredTree; } const hoveredItem = LW.Tree.hoveredItem; if (hoveredItem) { hoveredItem.classList.remove('drop-target'); hoveredItem.classList.remove('top'); hoveredItem.classList.remove('bottom'); delete LW.Tree.hoveredItem; } } } /** * Move handler. */ _moveHandler(event) { const that = this, dragDetails = that._dragDetails; if (!dragDetails) { return; } if (!dragDetails.FeedbackShown) { if (Math.abs(dragDetails.StartPosition.left - event.pageX) > 5 || Math.abs(dragDetails.StartPosition.top - event.pageY) > 5) { const dragStartEvent = that.$.fireEvent('dragStart', { 'item': dragDetails.Item, 'items': dragDetails.Items, 'data': dragDetails, 'container': that, 'previousContainer': that, 'originalEvent': dragDetails.OriginalEvent }); if (dragStartEvent.defaultPrevented) { delete that._dragDetails; delete LW.Tree.treeItemDragged; delete LW.Tree.hoveredTree; delete LW.Tree.hoveredItem; that.$.scrollViewer._scrollView.disableSwipeScroll = false; return; } document.body.classList.add('lw-dragging'); dragDetails.Feedback = that._addDragFeedback(); dragDetails.FeedbackShown = true; } else { return; } } const dragOffset = that.dragOffset; let hoveredTree, target, hoveredItem; that.$.fireEvent('dragging', { 'item': dragDetails.Item, 'items': dragDetails.Items, 'data': dragDetails, 'originalEvent': event }); dragDetails.Feedback.style.left = (event.pageX + dragOffset[0]) + 'px'; dragDetails.Feedback.style.top = (event.pageY + dragOffset[1]) + 'px'; if (that._isMobile) { const oldHoveredItem = LW.Tree.hoveredItem; if (oldHoveredItem) { oldHoveredItem.classList.remove('drop-target'); oldHoveredItem.classList.remove('top'); oldHoveredItem.classList.remove('bottom'); delete LW.Tree.hoveredItem; } const realTarget = document.elementFromPoint(event.clientX, event.clientY); if (LW.Tree.hoveredTree) { clearInterval(LW.Tree.hoveredTree._dragInterval); delete LW.Tree.hoveredTree; } if (realTarget) { hoveredTree = realTarget.closest('lw-tree'); if (hoveredTree && hoveredTree.allowDrop) { LW.Tree.hoveredTree = hoveredTree; target = realTarget.closest('lw-tree-item') || realTarget.closest('lw-tree-items-group'); if (target) { hoveredItem = target; } else { target = realTarget; } } } } hoveredTree = LW.Tree.hoveredTree; if (!hoveredTree) { return; } const filterInputHeight = hoveredTree.filterable ? hoveredTree.$.filterInput.offsetHeight + 10 : 0; clearInterval(hoveredTree._dragInterval); hoveredTree._dragInterval = setInterval(function () { const rect = hoveredTree.getBoundingClientRect(); if (hoveredTree.$.scrollViewer.scrollHeight > 0 && rect.left <= event.clientX && rect.left + rect.width >= event.clientX) { if (event.clientY >= rect.top + filterInputHeight && event.clientY <= rect.top + 20 + filterInputHeight) { hoveredTree.$.scrollViewer.scrollTop -= that._autoScrollCoefficient; if (hoveredTree.scrollMode === 'scrollButtons') { hoveredTree._updateScrollButtonVisibility(); } } else if (event.clientY >= rect.top + rect.height - 20 && event.clientY <= rect.top + rect.height) { hoveredTree.$.scrollViewer.scrollTop += that._autoScrollCoefficient; if (hoveredTree.scrollMode === 'scrollButtons') { hoveredTree._updateScrollButtonVisibility(); } } else { clearInterval(hoveredTree._dragInterval); } } else { clearInterval(hoveredTree._dragInterval); } }, 1); if (!that._isMobile) { target = event.originalEvent.target; if (target && target.enableShadowDOM) { target = event.originalEvent.composedPath()[0]; } if (target && target.closest) { hoveredItem = target.closest('lw-tree-item') || target.closest('lw-tree-items-group'); } } if (hoveredItem) { if (LW.Tree.hoveredItem && hoveredItem !== LW.Tree.hoveredItem) { LW.Tree.hoveredItem.classList.remove('drop-target'); LW.Tree.hoveredItem.classList.remove('top'); LW.Tree.hoveredItem.classList.remove('bottom'); } LW.Tree.hoveredItem = hoveredItem; if (dragDetails.Item.contains(hoveredItem)) { return; } const hoveredItemRect = hoveredItem.getBoundingClientRect(); if (hoveredItem instanceof LW.TreeItem) { if (event.clientY - hoveredItemRect.top <= hoveredItemRect.height / 2) { hoveredItem.classList.remove('bottom'); hoveredItem.classList.add('top'); } else { hoveredItem.classList.remove('top'); hoveredItem.classList.add('bottom'); } } else { if (event.clientY - hoveredItemRect.top <= 10) { hoveredItem.classList.remove('bottom'); hoveredItem.classList.add('top'); } else if (!hoveredItem.expanded && hoveredItemRect.bottom - event.clientY <= 10) { hoveredItem.classList.remove('top'); hoveredItem.classList.add('bottom'); } else { hoveredItem.classList.remove('top'); hoveredItem.classList.remove('bottom'); } } hoveredItem.classList.add('drop-target'); } else { if (LW.Tree.hoveredItem) { LW.Tree.hoveredItem.classList.remove('drop-target'); LW.Tree.hoveredItem.classList.remove('top'); LW.Tree.hoveredItem.classList.remove('bottom'); } if (target === hoveredTree.$.scrollViewer.$.scrollViewerContainer) { if (hoveredTree._menuItems['0']) { let lastVisibleItem = hoveredTree.$.mainContainer.lastElementChild, i = hoveredTree.$.mainContainer.childElementCount - 1; while (lastVisibleItem.hidden) { i--; lastVisibleItem = hoveredTree.$.mainContainer.children[i]; if (!lastVisibleItem) { break; } } if (lastVisibleItem) { LW.Tree.hoveredItem = lastVisibleItem; LW.Tree.hoveredItem.classList.add('bottom'); } else { LW.Tree.hoveredItem = hoveredTree.$.container; } LW.Tree.hoveredItem.classList.add('drop-target'); } else { LW.Tree.hoveredItem = hoveredTree.$.container; LW.Tree.hoveredItem.classList.add('drop-target'); } } else { delete LW.Tree.hoveredItem; } } } /** * Moves the sub-items of a lw-tree-items-group. */ _moveSubItems(children, targetTree, padding) { const that = this; for (let i = 0; i < children.length; i++) { const currentChild = children[i]; currentChild.menu = targetTree; currentChild.set('level', currentChild.parentItem.level + 1); currentChild.firstElementChild.style.paddingLeft = ''; currentChild.firstElementChild.style.paddingRight = ''; that._setIndentation(currentChild.firstElementChild, currentChild.level, padding); // restore filtered state currentChild.hidden = false; currentChild.$.removeClass('lw-hidden'); currentChild.$.removeClass('filtered-child'); currentChild.$.removeClass('last-filtered-child'); if (currentChild instanceof LW.TreeItemsGroup) { currentChild.$.removeClass('hidden-children'); currentChild.container.level = currentChild.level + 1; that._moveSubItems(currentChild.itemContainer.children, targetTree, padding); if (targetTree !== that && currentChild.expanded) { targetTree._menuItemsGroupsToExpand.push(currentChild); that._updateState('expanded', currentChild.id, false); } } } } /** * Moves a lw-tree-item. */ _moveTreeItem(draggedItem, targetItem, position, affectedTrees) { const that = this, oldLevel = draggedItem.level; if (position === 0) { if (targetItem.previousElementSibling === draggedItem) { return; } targetItem.parentElement.insertBefore(draggedItem, targetItem); draggedItem.set('level', targetItem.level); } else if (position === 2) { if (targetItem.nextElementSibling === draggedItem) { return; } targetItem.parentElement.insertBefore(draggedItem, targetItem.nextElementSibling || null); draggedItem.set('level', targetItem.level); } else if (targetItem === affectedTrees[0].$.container) { affectedTrees[0].$.mainContainer.appendChild(draggedItem); draggedItem.set('level', 1); } else { if (targetItem.itemContainer.lastElementChild === draggedItem) { return; } targetItem.itemContainer.appendChild(draggedItem); draggedItem.set('level', targetItem.level + 1); } const padding = affectedTrees[0].rightToLeft ? 'paddingRight' : 'paddingLeft'; draggedItem.menu = affectedTrees[0]; draggedItem.parentItem = draggedItem.parentElement.menuItemsGroup; draggedItem.firstElementChild.style.paddingLeft = ''; draggedItem.firstElementChild.style.paddingRight = ''; that._setIndentation(draggedItem.firstElementChild, draggedItem.level, padding); // restore filtered state draggedItem.hidden = false; draggedItem.$.removeClass('lw-hidden'); draggedItem.$.removeClass('filtered-child'); draggedItem.$.removeClass('last-filtered-child'); if (draggedItem instanceof LW.TreeItemsGroup) { draggedItem.$.removeClass('hidden-children'); draggedItem.container.level = draggedItem.level + 1; that._moveSubItems(draggedItem.itemContainer.children, affectedTrees[0], padding); if (draggedItem.expanded) { const index = that._openedContainers[oldLevel + 1].indexOf(draggedItem.container); if (index !== -1) { that._openedContainers[oldLevel + 1].splice(index, 1); } affectedTrees[0]._menuItemsGroupsToExpand.push(draggedItem); if (affectedTrees.length === 2) { that._updateState('expanded', draggedItem.id, false); } } } for (let i = 0; i < affectedTrees.length; i++) { const tree = affectedTrees[i], oldContext = tree.context, oldSelectedIndexes = tree.selectedIndexes.slice(0); tree.context = tree; tree._menuItems = {}; tree._refreshItemPaths(tree.$.mainContainer, true, undefined, tree.sorted && !tree.autoSort); tree.selectedIndexes = []; tree._applySelection(true, oldSelectedIndexes, false); tree._checkOverflow(); tree.context = oldContext; } affectedTrees[0]._expandItemsByDefault(); } /** * An empty handler used to override unnecessarily inherited Menu handlers. */ _overriddenMenuHandler() { } /** * Handles PgDn navigation. */ _pageDownHandler(treeItems, highlightedItem, selectOnHover, event) { const that = this, scrollViewer = that.$.scrollViewer; function getLastItemInView() { for (let i = treeItems.length - 1; i >= 0; i--) { const currentItem = treeItems[i]; if (that._canItemBeHovered(currentItem) && that._getOffsetTop(currentItem) + currentItem.firstElementChild.offsetHeight <= scrollViewer.scrollTop + scrollViewer.$.container.offsetHeight) { return currentItem; } } } if (!highlightedItem) { return; } let lastItemInView = getLastItemInView(); if (!lastItemInView) { return; } if (highlightedItem !== lastItemInView) { highlightedItem.removeAttribute('focus'); that._hoverViaKeyboard(lastItemInView, selectOnHover, event); } else if (scrollViewer.scrollTop + scrollViewer.$.container.offsetHeight !== scrollViewer.$.scrollViewerContentContainer.offsetHeight) { that.$.scrollViewer.scrollTop += scrollViewer.$.container.offsetHeight; if (that.scrollMode === 'scrollButtons') { that._updateScrollButtonVisibility(); } lastItemInView = getLastItemInView(); highlightedItem.removeAttribute('focus'); that._hoverViaKeyboard(lastItemInView, selectOnHover, event); } } /** * Handles PgUp navigation. */ _pageUpHandler(treeItems, highlightedItem, selectOnHover, event) { const that = this, scrollViewer = that.$.scrollViewer; function getFirstItemInView() { for (let i = 0; i < treeItems.length; i++) { const currentItem = treeItems[i]; if (that._canItemBeHovered(currentItem) && that._getOffsetTop(currentItem) >= scrollViewer.scrollTop) { return currentItem; } } } if (!highlightedItem) { return; } let firstItemInView = getFirstItemInView(); if (!firstItemInView) { return; } if (highlightedItem !== firstItemInView) { highlightedItem.removeAttribute('focus'); that._hoverViaKeyboard(firstItemInView, selectOnHover, event); } else if (scrollViewer.scrollTop !== 0) { that.$.scrollViewer.scrollTop -= scrollViewer.$.container.offsetHeight; if (that.scrollMode === 'scrollButtons') { that._updateScrollButtonVisibility(); } firstItemInView = getFirstItemInView(); highlightedItem.removeAttribute('focus'); that._hoverViaKeyboard(firstItemInView, selectOnHover, event); } else if (that.filterable) { that.$.filterInput.focus(); } } /** * Refreshes item paths and selection. */ _refreshItemPathsAndSelection() { const that = this, oldSelectedIndexes = that.selectedIndexes.slice(0); that._menuItems = { }; that._refreshItemPaths(that.$.mainContainer, true); that.selectedIndexes = []; that._applySelection(true, oldSelectedIndexes); } /** * Refreshes sorting. */ _refreshSorting() { const that = this; that._unsortItems(that.$.mainContainer); that._applyGrouping(that.$.mainContainer); const filterQuery = that._state.filter; if (filterQuery) { that._applyFilter(filterQuery); } that._checkOverflow(); } /** * Scrolls using scroll buttons. */ _scroll(scrollCoefficient) { const that = this; that.$.scrollViewer.scrollTop = that.$.scrollViewer.scrollTop + scrollCoefficient * 10; that._updateScrollButtonVisibility(); that.focus(); } /** * Far scroll button click handler. */ _scrollButtonFarClickHandler() { const that = this; if (that.$.scrollButtonFar.disabled) { return; } that._scroll(1); } /** * Near scroll button click handler. */ _scrollButtonNearClickHandler() { const that = this; if (that.$.scrollButtonNear.disabled) { return; } that._scroll(-1); } /** * scrollViewer down handler. */ _scrollViewerDownHandler(event) { const that = this; if (event.target !== that.$.scrollViewer || that.disabled || that.displayLoadingIndicator || (!that._isMobile && event.which !== 1)) { return; } const target = event.originalEvent.target; if (target === that.$.editInput) { that._editInputDown = true; return; } if (that._isMobile) { const currentScroll = that.$.scrollViewer.scrollTop, currentTop = that.getBoundingClientRect().top, timeout = setTimeout(function () { if (that._dragDetails || that.$.scrollViewer.scrollTop !== currentScroll || that.getBoundingClientRect().top !== currentTop) { return; } else { const oldContext = that.context; that.context = that; that._continueSelection(target, event); that.context = oldContext; } }, 250); that._downTimeoutInfo = { target: target, event: event, scrollTop: currentScroll, top: currentTop, timeout: timeout }; } else { that._continueSelection(target, event); } } /** * Continues selection. */ _continueSelection(target, event) { const that = this, pressedItem = target.closest('lw-tree-item') || target.closest('lw-tree-items-group'); if (!(pressedItem && pressedItem.parentElement && that._canItemBeSelected(pressedItem))) { return; } const arrow = target.closest('.lw-tree-items-group-arrow'); let selectionHandler; if (pressedItem instanceof LW.TreeItem) { selectionHandler = '_handleSelection'; } else { if (target === pressedItem.container || target === pressedItem.container.firstElementChild) { return; } selectionHandler = '_menuItemsGroupSelectionHandler'; } clearTimeout(that._dblclickTimeout); if (pressedItem !== that._dblclickObject.target) { that._dblclickObject.numberOfClicks = 0; } that._dblclickObject.target = pressedItem; that._dblclickObject.numberOfClicks++; that._dblclickTimeout = setTimeout(function () { that._dblclickObject.numberOfClicks = 0; }, 300); if (that._dblclickObject.numberOfClicks === 2) { if (!that.editable) { that._dblclickHandler(pressedItem, arrow, event); that._dblclickObject.numberOfClicks = 0; } else { that._startEditing(pressedItem); return; } } if (pressedItem.selected) { that._downItem = pressedItem; } that[selectionHandler](pressedItem, event); that._discardKeyboardHover(true); that._hoverViaKeyboard(pressedItem, false, undefined, false); if (!arrow) { that._startDragging(pressedItem, event); } } /** * scrollViewer touchmove handler. */ _scrollViewerTouchmoveHandler(event) { if (this._dragDetails && event.cancelable) { event.preventDefault(); event.stopPropagation(); } } /** * scrollViewer wheel handler. */ _scrollViewerWheelHandler() { const that = this; if (that.scrollMode === 'scrollButtons' && that.overflow !== 'hidden') { that._updateScrollButtonVisibility(); } } /** * Selects a range of items. */ _selectItemRange(from, to) { const that = this, treeItems = Array.from(that.$.mainContainer.querySelectorAll('lw-tree-item, lw-tree-items-group')), indexOfFrom = treeItems.indexOf(from), indexOfTo = treeItems.indexOf(to), selectedIndexes = []; for (let i = Math.min(indexOfFrom, indexOfTo); i <= Math.max(indexOfFrom, indexOfTo); i++) { const currentItem = treeItems[i]; if (that._canItemBeHovered(currentItem)) { selectedIndexes.push(currentItem.path); currentItem.set('selected', true); } } return selectedIndexes; } /** * selectstart handler. */ _selectstartHandler(event) { if (this._dragDetails) { event.preventDefault(); } } /** * Sets whether the element can be focused. */ _setFocusable() { super._setFocusable(); const that = this; if (that.disabled || that.unfocusable) { that.$.filterInput.tabIndex = -1; return; } that.$.filterInput.removeAttribute('tabindex'); } /** * Sets item indentation. */ _setIndentation(labelContainer, level, padding) { labelContainer.style[padding] = (level * 20 - 10) + 'px'; } /** * Sets checked, unchecked, or indeterminate state to a checkbox. */ _setThreeStateCheckbox(item, selectedChildren, indeterminateChildren) { if (selectedChildren === item.itemContainer.childElementCount) { item.removeAttribute('indeterminate'); item.set('selected', true); item.setAttribute('aria-selected', true); } else if (selectedChildren === 0 && indeterminateChildren === 0) { item.removeAttribute('indeterminate'); item.set('selected', false); item.setAttribute('aria-selected', false); } else { item.setAttribute('indeterminate', ''); item.set('selected', false); item.setAttribute('aria-selected', false); } } /** * Sorts items. */ _sortItems(item) { const that = this; if (!that.sorted) { return; } let parent; if (item instanceof LW.TreeItemsGroup) { parent = item.container.firstElementChild; } else if (item === that.$.mainContainer) { parent = item; } let children = Array.from(parent.children); if (that.sort) { // custom sorting const customSortingResult = that.sort(children, item); if (Array.isArray(customSortingResult)) { children = customSortingResult; } } else if (that.sortDirection === 'asc') { children.sort(function (a, b) { return (a.label).localeCompare(b.label); }); } else { children.sort(function (a, b) { return (b.label).localeCompare(a.label); }); } // sort items in DOM for (let i = children.length - 1; i >= 0; i--) { parent.insertBefore(children[i], parent.firstElementChild); } } /** * Sorts a collection of item paths. */ _sortPathCollection(collection) { collection.sort(function (a, b) { const aSplit = a.split('.'), bSplit = b.split('.'), maxLength = Math.max(aSplit.length, bSplit.length); for (let i = 0; i < maxLength; i++) { const aCurrent = parseFloat(aSplit[i]), bCurrent = parseFloat(bSplit[i]); if (isNaN(aCurrent)) { return -1; } if (isNaN(bCurrent)) { return 1; } if (aCurrent < bCurrent) { return -1; } if (aCurrent > bCurrent) { return 1; } } }); } /** * starts dragging operation */ _startDragging(pressedItem, event) { const that = this, selectionMode = that.selectionMode; if (!that.allowDrag || that._editedItem || selectionMode === 'none') { return; } const items = [], validItems = []; let validateOnDrop; if (['one', 'zeroOrOne', 'checkBox', 'radioButton'].indexOf(selectionMode) !== -1) { validateOnDrop = false; items.push(pressedItem); validItems.push(pressedItem); } else { // selectionModes 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany' validateOnDrop = true; for (let i = 0; i < that.selectedIndexes.length; i++) { items.push(that._menuItems[that.selectedIndexes[i]]); validItems.push(items[i]); } for (let i = 0; i < items.length; i++) { const item = items[i]; if (validItems.indexOf(item) === -1) { continue; } for (let j = validItems.length - 1; j >= 0; j--) { const nextItem = validItems[j]; if (nextItem === item) { break; } if (item.contains(nextItem)) { validItems.splice(j, 1); } } } } that._dragDetails = { StartPosition: { left: event.pageX, top: event.pageY }, Items: items, ValidItems: validItems, Item: pressedItem, FeedbackShown: false, ValidateOnDrop: validateOnDrop, OriginalEvent: event, StartTime: new Date(), Dragging: true }; LW.Tree.treeItemDragged = true; that.$.scrollViewer._scrollView.disableSwipeScroll = true; if (that.allowDrop) { LW.Tree.hoveredTree = that; LW.Tree.hoveredItem = pressedItem; } } /** * Starts editing operation. */ _startEditing(item) { const that = this, editInput = that.$.editInput; let getOffset, padding; if (!that._canItemBeSelected(item)) { return; } const labelContainer = item.firstElementChild, labelElement = labelContainer.firstElementChild; if (!that.rightToLeft) { getOffset = function () { return labelElement.offsetLeft + parseFloat(window.getComputedStyle(labelContainer).borderLeftWidth); }; padding = 'paddingLeft'; } else { getOffset = function () { return labelContainer.offsetWidth - labelElement.offsetLeft - labelElement.offsetWidth; }; padding = 'paddingRight'; } if (item instanceof LW.TreeItemsGroup) { editInput.style[padding] = getOffset() + (that.showLines ? parseFloat(window.getComputedStyle(labelElement.firstElementChild).paddingLeft) : 0) - 1 + 'px'; editInput.style.height = labelContainer.offsetHeight + 'px'; } else { editInput.style[padding] = item.offsetWidth + parseInt(labelContainer.style[padding], 10) - labelContainer.offsetWidth + parseFloat(window.getComputedStyle(labelElement.firstElementChild).paddingLeft) - 2 + 'px'; editInput.style.height = item.offsetHeight + 'px'; } editInput.style.top = that._getOffsetTop(item) + 'px'; that.$editInput.removeClass('lw-hidden'); editInput.value = item.label; that._editedItem = item; editInput.setAttribute('aria-label', 'Edit item ' + item.label); setTimeout(function () { editInput.focus(); }, 0) } /** * styleChanged event handler. */ _styleChangedHandler(event) { if (event.detail.styleProperties && event.detail.styleProperties['font-size']) { this._checkOverflow(); } } /** * Updates scroll button visibility. */ _updateScrollButtonVisibility() { const that = this, overflow = that.overflow; if (that.scrollMode === 'scrollbar' || overflow === 'hidden') { return; } let showNear = true, showFar = true; if (Math.round(that.$.scrollViewer.scrollTop) === 0) { showNear = false; } if (Math.round(that.$.scrollViewer.$.scrollViewerContainer.offsetHeight + that.$.scrollViewer.scrollTop) >= Math.round(that.$.scrollViewer.$.scrollViewerContentContainer.offsetHeight)) { showFar = false; } if (overflow === 'auto') { if (showNear && showFar) { that.$scrollButtonNear.removeClass('lw-hidden'); that.$scrollButtonFar.removeClass('lw-hidden'); that.$scrollViewer.removeClass('one-button-shown'); that.$.scrollViewer.refresh(); return; } if (showNear) { that.$scrollButtonNear.removeClass('lw-hidden'); } else { that.$scrollButtonNear.addClass('lw-hidden'); } if (showFar) { that.$scrollButtonFar.removeClass('lw-hidden'); } else { that.$scrollButtonFar.addClass('lw-hidden'); } that.$scrollViewer.addClass('one-button-shown'); that.$.scrollViewer.refresh(); } else if (overflow === 'scroll' && !that.disabled) { that.$.scrollButtonNear.disabled = !showNear; that.$.scrollButtonFar.disabled = !showFar; } } /** * Updates stored state. */ _updateState(field, value, add) { const that = this; switch (field) { case 'expanded': { const index = that._state.expanded.indexOf(value); if (add && index === -1) { that._state.expanded.push(value); } else if (!add && index !== -1) { that._state.expanded.splice(index, 1); } else { return; } break; } case 'filter': that._state.filter = value !== undefined ? value : that.$.filterInput.value; break; case 'selected': that._state.selected = []; for (let i = 0; i < that.selectedIndexes.length; i++) { const currentSelectedItem = that._menuItems[that.selectedIndexes[i]]; that._state.selected.push(currentSelectedItem.id); } break; case 'sorted': that._state.sorted = value; break; } if (that.autoSaveState) { window.localStorage.setItem('lwTree' + that.id, JSON.stringify(that._state)); } } /** * Vertical Scroll Bar handler */ _verticalScrollbarHandler() { const scrollViewer = this, verticalScrollBar = scrollViewer.$.verticalScrollBar, value = verticalScrollBar.value; if (scrollViewer.disabled) { return; } if (verticalScrollBar.max === value) { if (!scrollViewer._bottomReached) { scrollViewer.$.fireEvent('scrollBottomReached'); delete scrollViewer._topReached; scrollViewer._bottomReached = true; } return; } if (verticalScrollBar.min === value) { if (!scrollViewer._topReached) { scrollViewer.$.fireEvent('scrollTopReached'); delete scrollViewer._bottomReached; scrollViewer._topReached = true; } return; } delete scrollViewer._topReached; delete scrollViewer._bottomReached; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Sortable custom element. */ LW('lw-sortable', class Sortable extends LW.ContentElement { // Sortable's properties. static get properties() { return { 'dragMode': { value: 'item', allowedValues: ['item', 'handle'], type: 'string' }, 'handlePosition': { value: 'right', allowedValues: ['right', 'left', 'top', 'bottom'], type: 'string' }, 'handleVisibility': { value: 'hover', allowedValues: ['hover', 'visible'], type: 'string' }, 'items': { value: null, type: 'string?' }, 'mode': { value: 'vertical', allowedValues: ['horizontal', 'vertical'], type: 'string' } }; } /** * Sortable's event listeners. */ static get listeners() { return { 'contextmenu': '_preventDefault', 'container.down': '_containerDownHandler', 'container.move': '_containerMoveHandler', 'container.transitionend': '_containerTransitionendHandler', 'document.dragstart': '_preventDefault', 'document.move': '_documentMoveHandler', 'document.selectstart': '_preventDefault', 'document.up': '_documentUpHandler' }; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.sortable.css' ] } /** * Sortable's HTML template. */ template() { return '<div id="container" class="lw-sortable-container" role="presentation"><content></content></div>'; } /** * Moves an item from one index to another. * @param {number} fromIndex The original index of the item. * @param {number} toIndex The index to move the item to. */ move(fromIndex, toIndex) { const that = this, items = that._items; if (isNaN(fromIndex) || isNaN(toIndex) || fromIndex === toIndex || fromIndex < 0 || fromIndex >= items.length || toIndex < 0 || toIndex >= items.length) { return; } const itemToMove = items[fromIndex], target = items[toIndex]; if (fromIndex > toIndex) { that._itemsParent.insertBefore(itemToMove, target); } else { that._itemsParent.insertBefore(itemToMove, target.nextElementSibling); } that._getItems(false); } /** * Re-evaluates the items that can be sorted. */ updateItems() { const that = this; that._items.forEach(item => item.classList.remove('lw-sortable-item')); that._getItems(); } /** * Updates the Sortable when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. * @param {number/string} newValue The new entered value. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; switch (propertyName) { case 'disabled': that._originallyDisabled = newValue; if (that._items.length < 2) { that.disabled = true; } break; case 'items': that._itemsParent.classList.remove('lw-sortable-items-parent'); that.updateItems(); break; case 'mode': that._setSettingsObject(); break; } } /** * Called when the element is ready */ ready() { super.ready(); const that = this; that.setAttribute('role', 'group'); that._originallyDisabled = that.disabled; that._getItems(); that._setSettingsObject(); } /** * Gets items collection. */ _getItems(addClass) { const that = this; if (that.items === null) { that._items = Array.from(that.$.container.children); } else { that._items = Array.from((that.shadowRoot || that).querySelectorAll('.lw-sortable-container ' + that.items)); } if (addClass !== false) { that._items.forEach(child => child.classList.add('lw-sortable-item')); if (that._items.length) { that._itemsParent = that._items[0].parentElement; that._itemsParent.classList.add('lw-sortable-items-parent'); if (that._items.length < 2) { that.disabled = true; } else { that.disabled = that._originallyDisabled; } } } } /** * Sets the "_settings" object. */ _setSettingsObject() { const that = this; if (that.mode === 'vertical') { that._settings = { coordinateName: 'y', dimension: 'height', offsetDimension: 'offsetHeight', startOffset: 'top', endOffset: 'bottom' }; } else { that._settings = { coordinateName: 'x', dimension: 'width', offsetDimension: 'offsetWidth', startOffset: 'left', endOffset: 'right' }; } } /** * Prevents event's default functionality. */ _preventDefault(event) { if (this._draggedItem) { event.preventDefault(); } } /** * container down handler. */ _containerDownHandler(event) { const that = this; if (that.disabled || that._draggedItem) { return; } const clickedItem = (that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target).closest('.lw-sortable-item'); if (!clickedItem) { return; } const x = event.pageX - window.scrollX, y = event.pageY - window.scrollY, rect = clickedItem.getBoundingClientRect(), style = getComputedStyle(clickedItem), marginLeft = parseFloat(style.marginLeft), marginTop = parseFloat(style.marginTop); if (that.dragMode === 'handle' && (event.originalEvent.target !== document.elementFromPoint(event.clientX, event.clientY) || x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom)) { // clicked on item itself, not on handle return; } window.getSelection().removeAllRanges(); that._draggedItem = clickedItem; that._positionPlaceholder(); that._getPositionedAncestorCoords(); clickedItem.style.width = clickedItem.offsetWidth + 'px'; clickedItem.style.height = clickedItem.offsetHeight + 'px'; clickedItem.style.left = rect.left - marginLeft + ((- that._positionedAncestorCoords.x) || window.scrollX) + 'px'; clickedItem.style.top = rect.top - marginTop + ((- that._positionedAncestorCoords.y) || window.scrollY) + 'px'; clickedItem.classList.add('dragged'); that._clickOffset = { x: event.pageX - rect.left + marginLeft, y: event.pageY - rect.top + marginTop }; that._prevCoords = { x: x, y: y }; that._getItemCoordinates(); } /** * Adds and positions placeholder item. */ _positionPlaceholder() { const that = this, draggedItem = that._draggedItem, style = getComputedStyle(draggedItem), placeholder = document.createElement('div'); placeholder.className = 'lw-sortable-item placeholder lw-visibility-hidden'; placeholder.style.width = draggedItem.offsetWidth + 'px'; placeholder.style.height = draggedItem.offsetHeight + 'px'; placeholder.style.minHeight = draggedItem.offsetHeight + 'px'; placeholder.style.marginBottom = style.marginBottom; placeholder.style.marginLeft = style.marginLeft; placeholder.style.marginRight = style.marginRight; placeholder.style.marginTop = style.marginTop; that._itemsParent.insertBefore(placeholder, draggedItem.nextElementSibling); that._placeholder = placeholder; } /** * Gets the coordinates of the first non-statically positioned ancestor element. */ _getPositionedAncestorCoords() { const that = this, positionedElement = that.offsetParent; that._positionedAncestorCoords = { x: 0, y: 0 }; if (positionedElement !== document.body) { const positionedElementRect = positionedElement.getBoundingClientRect(); that._positionedAncestorCoords = { x: positionedElementRect.left, y: positionedElementRect.top }; } } /** * Gets item coordinates. */ _getItemCoordinates() { const that = this, coordinates = []; that._items.forEach(function (item) { const rect = item.getBoundingClientRect(); coordinates.push({ left: rect.left, top: rect.top, right: rect.right, bottom: rect.bottom, width: rect.width, height: rect.height }); }); that._coordinates = coordinates; } /** * container move handler. */ _containerMoveHandler(event) { if (this._draggedItem && event.originalEvent.type === 'touchmove') { event.originalEvent.preventDefault(); } } /** * container transitionend handler. */ _containerTransitionendHandler(event) { const that = this; if (that._draggedItem && event.target.classList.contains('lw-sortable-item')) { if (event.target.classList.contains('returning')) { that._resolveDragging(); } else { that._getItemCoordinates(); } } } /** * document move handler. */ _documentMoveHandler(event) { const that = this, draggedItem = that._draggedItem; if (!draggedItem) { return; } const sttngs = that._settings, newCoords = { x: event.pageX - window.scrollX, y: event.pageY - window.scrollY }, coordinate = newCoords[sttngs.coordinateName]; let direction; if (that._prevCoords.x === newCoords.x && that._prevCoords.y === newCoords.y) { return; } if (!that.hasAttribute('dragged')) { that.setAttribute('dragged', ''); } if (that._prevCoords[sttngs.coordinateName] > coordinate) { direction = 'up'; } else { direction = 'down'; } that._prevCoords = newCoords; draggedItem.style.top = event.pageY - that._clickOffset.y + ((- that._positionedAncestorCoords.y) || window.scrollY) + 'px'; draggedItem.style.left = event.pageX - that._clickOffset.x + ((- that._positionedAncestorCoords.x) || window.scrollX) + 'px'; const draggedItemIndex = that._items.indexOf(draggedItem); let overItem; for (let i = 0; i < that._coordinates.length; i++) { const coordinateSet = that._coordinates[i]; if (draggedItemIndex === i) { // ignore moving over dragged item itself continue; } if (direction === 'down' && coordinate >= coordinateSet[sttngs.startOffset] + coordinateSet[sttngs.dimension] / 2 && coordinate <= coordinateSet[sttngs.endOffset]) { overItem = that._items[i]; break; } else if (direction === 'up' && coordinate >= coordinateSet[sttngs.startOffset] && coordinate <= coordinateSet[sttngs.startOffset] + coordinateSet[sttngs.dimension] / 2) { overItem = that._items[i]; break; } } if (!overItem) { delete that._prevOverItem; return; } if (overItem !== that._prevOverItem) { that._prevOverItem = overItem; if (overItem[direction]) { return; } const overItemIndex = that._items.indexOf(overItem); that._overItem = overItem; if (overItem.up || overItem.down) { overItem.style.transform = null; delete overItem.up; delete overItem.down; } else { if (that.mode === 'horizontal' && (direction === 'up' && ((!that.rightToLeft && overItemIndex > draggedItemIndex) || (that.rightToLeft && overItemIndex < draggedItemIndex)) || direction === 'down' && ((!that.rightToLeft && overItemIndex < draggedItemIndex) || (that.rightToLeft && overItemIndex > draggedItemIndex)))) { return; } else if (that.mode === 'vertical' && (direction === 'up' && overItemIndex > draggedItemIndex || direction === 'down' && overItemIndex < draggedItemIndex)) { return; } const overItemStyle = getComputedStyle(overItem); overItem.style.transform = `translate${sttngs.coordinateName.toUpperCase()}(${ (direction === 'up' ? 1 : -1) * (overItem[sttngs.offsetDimension] + parseFloat(overItemStyle['margin-' + sttngs.startOffset]) + parseFloat(overItemStyle['margin-' + sttngs.endOffset])) }px)`; overItem[direction] = true; } } } /** * document up handler. */ _documentUpHandler() { const that = this, draggedItem = that._draggedItem; if (!draggedItem) { return; } let overItem = that._overItem; if (overItem) { const draggedItemIndex = that._items.indexOf(draggedItem), overItemIndex = that._items.indexOf(overItem); if (draggedItemIndex < overItemIndex && overItem[that.rightToLeft && that.mode === 'horizontal' ? 'up' : 'down'] || draggedItemIndex > overItemIndex && !overItem.down && !overItem.up) { that._insertBefore = overItem.nextElementSibling; overItem = that._insertBefore; if (overItem && overItem.nextElementSibling === draggedItem) { overItem = that._placeholder; } } else if (draggedItemIndex > overItemIndex && overItem[that.rightToLeft && that.mode === 'horizontal' ? 'down' : 'up'] || draggedItemIndex < overItemIndex && !overItem.down && !overItem.up) { that._insertBefore = overItem; if (!(draggedItemIndex > overItemIndex && overItem[that.rightToLeft && that.mode === 'horizontal' ? 'down' : 'up'])) { overItem = overItem.previousElementSibling || overItem; } } } else { overItem = that._placeholder; } that._resolveDragging(); } /** * Resolves dragging operation. */ _resolveDragging() { const that = this, draggedItem = that._draggedItem, oldIndex = that._items.indexOf(draggedItem); let fireEvent = false; draggedItem.classList.remove('dragged', 'returning'); that._removeInlineStyle(); if (that._insertBefore !== undefined) { if (that._items.indexOf(that._insertBefore) !== oldIndex && that._insertBefore !== that._placeholder[that.rightToLeft && that.mode === 'horizontal' ? 'previousElementSibling' : 'nextElementSibling']) { that._itemsParent.insertBefore(draggedItem, that._insertBefore); delete that._insertBefore; fireEvent = true; } } that._itemsParent.removeChild(that._placeholder); delete that._clickOffset; delete that._draggedItem; delete that._overItem; delete that._placeholder; delete that._prevCoords; that.removeAttribute('dragged'); if (fireEvent) { that._getItems(false); that.$.fireEvent('dragEnd', { oldIndex: oldIndex, newIndex: that._items.indexOf(draggedItem) }); } } /** * Removes inline styles applied to items. */ _removeInlineStyle() { const that = this; that._items.forEach(function (item) { item.style = null; item.style.transition = 'none'; delete item.up; delete item.down; }); setTimeout(function () { that._items.forEach(item => item.style.transition = null); }, 50); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * Table custom element. */ LW('lw-table', class Table extends LW.ContentElement { /** * Table's properties */ static get properties() { return { 'columns': { value: [], type: 'any?', reflectToAttribute: false }, 'columnReorder': { value: false, type: 'boolean' }, 'dataSource': { value: null, type: 'any?', reflectToAttribute: false }, 'editing': { value: false, type: 'boolean' }, 'editMode': { value: 'cell', allowedValues: ['cell', 'row'], type: 'string' }, 'filtering': { value: false, type: 'boolean' }, 'filterRow': { value: false, type: 'boolean' }, 'filterTemplate': { value: null, type: 'string?' }, 'footerRow': { value: null, type: 'string?' }, 'freezeFooter': { value: false, type: 'boolean' }, 'freezeHeader': { value: false, type: 'boolean' }, 'grouping': { value: false, type: 'boolean' }, 'headerRow': { value: null, type: 'string?' }, 'keyboardNavigation': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'clearFilter': 'Clear filter', 'CONTAINS': 'contains', 'CONTAINS_CASE_SENSITIVE': 'contains (case sensitive)', 'DOES_NOT_CONTAIN': 'does not contain', 'DOES_NOT_CONTAIN_CASE_SENSITIVE': 'does not contain (case sensitive)', 'EMPTY': 'empty', 'ENDS_WITH': 'ends with', 'ENDS_WITH_CASE_SENSITIVE': 'ends with (case sensitive)', 'EQUAL': 'equal', 'EQUAL_CASE_SENSITIVE': 'equal (case sensitive)', 'filterPlaceholder': 'Filter', 'filterCondition': 'Filter condition', 'firstButton': 'First', 'GREATER_THAN': 'greater than', 'GREATER_THAN_OR_EQUAL': 'greater than or equal', 'invalidValue': 'Invalid value', 'itemsPerPage': 'Items per page:', 'lastButton': 'Last', 'LESS_THAN': 'less than', 'LESS_THAN_OR_EQUAL': 'less than or equal', 'nextButton': 'Next', 'NOT_EMPTY': 'not empty', 'NOT_EQUAL': 'not equal', 'NOT_NULL': 'not null', 'NULL': 'null', 'previousButton': 'Previous', 'STARTS_WITH': 'starts with', 'STARTS_WITH_CASE_SENSITIVE': 'starts with (case sensitive)', 'summaryPrefix': 'of' } }, type: 'object', extend: true }, 'onCellRender': { value: null, type: 'function?', reflectToAttribute: false }, 'onColumnRender': { value: null, type: 'function?', reflectToAttribute: false }, 'onInit': { value: null, type: 'function?', reflectToAttribute: false }, 'pageSize': { value: 10, allowedValues: [10, 25, 50], type: 'int' }, 'pageIndex': { value: 0, type: 'int' }, 'paging': { value: false, type: 'boolean' }, 'rowDetailTemplate': { value: null, type: 'string?' }, 'selection': { value: false, type: 'boolean' }, 'sortMode': { value: 'none', type: 'string', allowedValues: ['none', 'one', 'many'] } } } /** * Table's event listeners. */ static get listeners() { return { 'resize': '_resizeHandler', 'filterInput.keyup': '_filterInputKeyupHandler', 'pager.change': '_pagerChangeHandler', 'pager.pageSizeChanged': '_pagerPageSizeChanged', 'tableContainer.change': '_tableContainerChangeHandler', 'tableContainer.click': '_tableContainerClickHandler', 'tableContainer.down': '_tableContainerDownHandler', 'tableContainer.focus': '_tableContainerFocusHandler', 'tableContainer.keydown': '_tableContainerKeydownHandler', 'tableContainer.keyup': '_tableContainerKeyupHandler', 'document.down': '_documentDownHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler' }; } template() { return `<div id="container" class="lw-container" role="presentation"> <div id="header" class="lw-table-header"> <lw-input id="filterInput" class="underlined" animation="[[animation]]" locale="[[locale]]" right-to-left="[[rightToLeft]]"></lw-input> <div id="filterTemplateContainer" class="lw-table-filter-template-container lw-hidden"></div> </div> <table id="tableContainer" inner-h-t-m-l=\'[[innerHTML]]\' class="lw-table-container"> <content></content> </table> <lw-pager id="pager" animation="[[animation]]" locale="[[locale]]" page-index="[[pageIndex]]" page-size="[[pageSize]]" show-first-last-navigation-buttons show-page-size-selector show-prev-next-navigation-buttons show-summary right-to-left="[[rightToLeft]]"></lw-pager> <div id="loadingIndicatorContainer" class="lw-loader-container lw-hidden" aria-label="Loading"> <span id="loadingIndicator" class="lw-loader" role="presentation"></span> </div> </div>`; } render() { const that = this; that.setAttribute('role', 'presentation'); that._isMobile = LW.Utilities.Core.isMobile; that._autoScrollCoefficient = LW.Utilities.Core.Browser.Firefox ? 8 : LW.Utilities.Core.Browser.Edge ? 16 : 4; that._selectedIds = []; that._disabledSelection = []; that._setFocusable(); if (that.selection) { that.$.tableContainer.setAttribute('aria-multiselectable', true); } that._createElement(); super.render(); } /** * Adds a filter to a specific column. * * @param {string} dataField The column's data field. * @param {FilterGroup} filter FilterGroup object. */ addFilter(dataField, filter) { const that = this, column = that._columns.find(column => column.dataField === dataField); if (!column || column.allowFilter === false || filter instanceof LW.Utilities.FilterGroup === false) { return; } if (!that._filterInfo.appliedFilters) { that._filterInfo.appliedFilters = {}; } that._filterInfo.appliedFilters[dataField] = filter; that._refreshFilters(); } /** * Groups by a column. * * @param {string} dataField The column's data field. */ addGroup(dataField) { const that = this; if (!that.grouping) { return; } const column = that._columns.find(col => col.dataField === dataField); if (!column || column.allowGroup === false) { return; } const dataSource = that.dataSource, groupBy = dataSource.groupBy; if (groupBy.indexOf(dataField) !== -1) { return; } groupBy.push(dataField); dataSource.refreshHierarchy(); that._fullRefresh(); that.$.fireEvent('group', { action: 'add', dataField: dataField }); } /** * Begins an edit operation. * * @param {number|string} row The id of the row to edit. * @param {string} dataField Optional The dataField of the cell's column. */ beginEdit(row, dataField) { const that = this; if (!that.editing) { return; } const column = that._columns.find(col => col.dataField === dataField); if (!column) { dataField = undefined; } if (that.editMode === 'cell' && !dataField || column && column.allowEdit === false) { return; } const rowObject = that.rowById[row]; if (!rowObject) { return; } const parsedId = rowObject.data.$.id; if (that._editing) { that.endEdit(); } that._beginEdit({ rowId: parsedId, rowObject: rowObject, dataField: dataField }); } /** * Ends the current edit operation and discards changes. */ cancelEdit() { const that = this, editingInfo = that._editing; if (!editingInfo) { return; } for (let i = 0; i < editingInfo.cells.length; i++) { const cell = editingInfo.cells[i]; if (cell.editor.contains((that.shadowRoot || that.getRootNode()).activeElement)) { that._focusCell(cell.element); } cell.editor.remove(); cell.element.innerHTML = that._formatCellValue(editingInfo.row, that._columns.find(col => col.dataField === cell.dataField), cell.element); cell.element.classList.remove('editing'); } delete that._editing; } /** * Clears applied filters. */ clearFilters() { const that = this; that._clearFilterInput(); that._clearRowFilters(); delete that._filterInfo.appliedFilters; if (!that.dataSource.virtualDataSource) { that.dataSource.clearFilter(); } that._fullRefresh('filter'); that.$.fireEvent('filter', { action: 'remove' }); } /** * Clears grouping. */ clearGrouping() { const that = this, dataSource = that.dataSource, groupBy = dataSource.groupBy; if (groupBy.length === 0) { return; } dataSource.groupBy = []; dataSource.refreshHierarchy(); that._fullRefresh(); that.$.fireEvent('group', { action: 'remove' }); } /** * Clears selection. */ clearSelection() { const that = this; if (that._selectedIds.length === 0) { return; } Array.from(that.$.tableContainer.querySelectorAll('.lw-table-select-row')).forEach(td => { td.parentElement.setAttribute('aria-selected', false); td.classList.remove('selected'); }); that.$.tableContainer.querySelector('.lw-table-select-all').classList.remove('indeterminate', 'selected'); that._selectedIds = []; } /** * Collapses all rows (in tree mode). */ collapseAllRows() { const that = this; if (!that.hasAttribute('hierarchy') || that.grouping) { return; } function collapse(siblings) { for (let i = 0; i < siblings.length; i++) { const sibling = siblings[i]; if (sibling.leaf) { continue; } if (sibling.children) { collapse(sibling.children); } if (sibling.expanded) { that.collapseRow(sibling.$.id); } } } collapse(that.dataSource.boundHierarchy); } /** * Collapses a group. * * @param {string} index The group's hierarchical index. */ collapseGroup(index) { const that = this; if (!that.grouping || that.dataSource.groupBy.length === 0) { return; } const group = that._getGroupByIndex(index); if (!group || !group.expanded) { return; } const groupHeader = that.$.tableContainer.querySelector(`tr[row-id="${group.$.id}"]`); that.$.fireEvent('group', { action: 'collapse', dataField: group.groupDataField, label: group.label }); if (!groupHeader) { // group is not in view group.expanded = false; return; } if (that._isCollapsed(group)) { groupHeader.setAttribute('aria-expanded', false); groupHeader.classList.remove('expanded'); group.expanded = false; return; } that._hierarchyArrowClickHandler(groupHeader); } /** * Collapses a row (in tree mode). * * @param {string | number} rowId The id of the row to collapse. */ collapseRow(rowId) { const that = this; if (!that.hasAttribute('hierarchy') || that.grouping) { return; } const rowObject = that.rowById[rowId], data = rowObject.data; if (!rowObject || data.leaf || !data.expanded) { return; } const rowElement = that.$.tableContainer.querySelector(`tr[row-id="${rowId}"]`); if (!rowElement) { // row is not in view data.expanded = false; return; } if (that._isCollapsed(data)) { rowElement.setAttribute('aria-expanded', false); rowElement.classList.remove('expanded'); data.expanded = false; return; } that._hierarchyArrowClickHandler(rowElement); } /** * Ends the current edit operation and saves changes. */ endEdit() { const that = this, editingInfo = that._editing; if (!editingInfo) { return; } const row = editingInfo.row, data = row.data, editingResults = []; let valid = true; for (let i = 0; i < editingInfo.cells.length; i++) { const cell = editingInfo.cells[i], column = that._columns.find(col => col.dataField === cell.dataField), cellElement = cell.element, editor = cell.editor; let newValue; if (column.editor && column.editor.template) { if (column.editor.getValue) { newValue = column.editor.getValue(editor); } } else { newValue = editor.value; if (editor instanceof HTMLInputElement) { if (editor.type === 'number') { newValue = parseFloat(newValue); } else if (editor.type === 'date') { newValue = new Date(newValue); if (isNaN(newValue.getTime())) { newValue = null; } } } } if (column.validation) { const validationResult = column.validation(newValue), invalid = validationResult !== undefined && validationResult !== true; if (invalid) { let message; if (typeof validationResult === 'object' && validationResult.message) { message = validationResult.message; } else { message = that.localize('invalidValue'); } cellElement.setAttribute('validation-message', message); } else { cellElement.removeAttribute('validation-message'); } cellElement.classList.toggle('invalid', invalid); valid = valid && !invalid; } editingResults.push({ column: column, newValue: newValue }); } if (!valid) { return; } for (let i = 0; i < editingInfo.cells.length; i++) { const cell = editingInfo.cells[i], editingResult = editingResults[i], column = editingResult.column, editor = cell.editor; if (editor.contains((that.shadowRoot || that.getRootNode()).activeElement)) { that._focusCell(cell.element); } editor.remove(); data[cell.dataField] = editingResult.newValue; cell.element.innerHTML = that._formatCellValue(row, column, cell.element); cell.element.classList.remove('editing'); that.$.fireEvent('cellEndEdit', { row: data, dataField: cell.dataField }); } delete that._editing; } /** * Expands all rows (in tree mode). */ expandAllRows() { const that = this; if (!that.hasAttribute('hierarchy') || that.grouping) { return; } function expand(siblings) { for (let i = 0; i < siblings.length; i++) { const sibling = siblings[i]; if (sibling.leaf) { continue; } if (sibling.children) { expand(sibling.children); } if (!sibling.expanded) { that.expandRow(sibling.$.id); } } } expand(that.dataSource.boundHierarchy); } /** * Expands a group. * * @param {string} index The group's hierarchical index. */ expandGroup(index) { const that = this, dataSource = that.dataSource; if (!that.grouping || dataSource.groupBy.length === 0) { return; } const group = that._getGroupByIndex(index); if (!group) { return; } const groupHeader = that.$.tableContainer.querySelector(`tr[row-id="${group.$.id}"]`); if (!group.expanded) { that.$.fireEvent('group', { action: 'expand', dataField: group.groupDataField, label: group.label }); } if (!groupHeader) { // group is not in view group.expanded = true; return; } if (that._isCollapsed(group)) { let parent = group.parent; if (parent && !parent.expanded) { that.expandGroup(group.parent.$.id.replace('Item', '').replace(/_/g, '.')); } } if (!group.expanded) { that._hierarchyArrowClickHandler(groupHeader); } } /** * Expands a row (in tree mode). * * @param {string | number} rowId The id of the row to expand. */ expandRow(rowId) { const that = this; if (!that.hasAttribute('hierarchy') || that.grouping) { return; } const rowObject = that.rowById[rowId], data = rowObject.data; if (!rowObject || data.leaf) { return; } const rowElement = that.$.tableContainer.querySelector(`tr[row-id="${rowId}"]`); if (!rowElement) { // row is not in view data.expanded = true; return; } if (that._isCollapsed(data)) { let parent = data.parent; if (parent && !parent.expanded) { that.expandRow(parent.$.id); } } if (!data.expanded) { that._hierarchyArrowClickHandler(rowElement); } } /** * Exports the Table's data. * * @param {String} dataFormat The file format to export to. * @param {String} fileName Optional The name of the file to export to. * @param {boolean} exportFiltered Optional If set to true, exports only filtered records. * @param {Function} callback Optional A callback function to pass the exported data to (if fileName is not provided). */ exportData(dataFormat, fileName, exportFiltered, callback) { const that = this, dataSource = that.dataSource, computedStyle = getComputedStyle(that), borderColor = computedStyle.borderRightColor, dataExporter = new LW.Utilities.DataExporter(undefined, dataSource.groupBy.toArray()), headerRow = {}, headerCells = that.$.tableContainer.firstElementChild.querySelectorAll('th'); let dataSourceToExport; function processHierarchy(siblings) { const result = []; siblings.forEach(child => { if (exportFiltered && child.$.filtered === false) { return; } result.push(child); if (!child.leaf) { child._expanded = child.expanded; if (child.children) { child.children = processHierarchy(child.children); if (child.children.length === 0) { child._expanded = undefined; child.children = undefined; child.leaf = true; } } } }); return result; } if (dataSource.virtualDataSource) { dataSourceToExport = []; for (let i = 0; i < that.rows.length; i++) { dataSourceToExport.push(that.rows[i].data); } } else if (dataSource.boundHierarchy && !that.grouping) { dataExporter.hierarchical = true; dataSourceToExport = processHierarchy(JSON.parse(JSON.stringify(dataSource.boundHierarchy, (key, value) => { if (key === 'parent') { return undefined; } return value; }))); } else { dataSourceToExport = Array.from(dataSource.toArray()); if (exportFiltered) { dataSourceToExport = dataSourceToExport.filter(record => record.$.filtered !== false); } } dataExporter.style = { border: '1px solid ' + borderColor, borderCollapse: 'collapse', backgroundColor: computedStyle.backgroundColor, color: computedStyle.color, fontFamily: 'Helvetica', header: { border: '1px solid ' + borderColor, fontWeight: 'bold' }, columns: { border: '1px solid ' + borderColor } }; for (let i = 0; i < that._columns.length; i++) { const column = that._columns[i], headerCell = headerCells[i], headerStyle = {}, columnStyle = {}; let columnWidth = headerCell.offsetWidth + 'px'; headerRow[column.dataField] = column.label; if (column.dataType === 'date') { columnStyle.format = 'd'; } headerStyle.width = columnWidth; dataExporter.style.header[column.dataField] = headerStyle; dataExporter.style.columns[column.dataField] = columnStyle; } dataSourceToExport.unshift(headerRow); return dataExporter.exportData(dataSourceToExport, dataFormat, fileName, callback); } /** * Returns an array of selected row ids. */ getSelection() { return this._selectedIds; } /** * Returns the value of a cell. * * @param {number|string} row The id of the cell's row. * @param {string} dataField The dataField of the cell's column. */ getValue(row, dataField) { const that = this, column = that._columns.find(col => col.dataField === dataField); if (!column) { return; } const rowObject = that.rowById[row]; if (!rowObject) { return; } return rowObject.data[dataField]; } /** * Navigates to a page. * * @param {number} pageIndex The zero-based page index to navigate to. */ navigateTo(pageIndex) { const that = this; if (isNaN(pageIndex) || pageIndex === null) { return; } const oldValue = that.pageIndex; that.pageIndex = Math.max(Math.min(Math.round(pageIndex), that.$.pager.pagesCount - 1), 0); if (that.paging && that.pageIndex !== oldValue) { that._fullRefresh('pageIndexChange'); that.$.fireEvent('page', { action: 'pageIndexChange' }); } } /** * Removes filters applied to a specific column. * * @param {string} dataField The column's data field. */ removeFilter(dataField) { const that = this; if (!that._filterInfo.appliedFilters || !that._columns.find(column => column.dataField === dataField)) { return; } delete that._filterInfo.appliedFilters[dataField]; that._refreshFilters(); } /** * Removes grouping by a column. * * @param {string} dataField The column's data field. */ removeGroup(dataField) { const that = this; if (!that.grouping || !that._columns.find(col => col.dataField === dataField)) { return; } const dataSource = that.dataSource, groupBy = dataSource.groupBy, index = groupBy.indexOf(dataField); if (index === -1) { return; } groupBy.splice(index, 1); dataSource.refreshHierarchy(); that._fullRefresh(); that.$.fireEvent('group', { action: 'remove', dataField: dataField }); } /** * Selects a row. * * @param {string | number} rowId The id of the row to select. */ select(rowId) { const that = this; if (!that.selection) { return; } const rowObject = that.rowById ? that.rowById[rowId] : that.rows.find(currentRow => currentRow.$.id === rowId); if (!rowObject) { return; } const parsedId = rowObject.data ? rowObject.data.$.id : rowObject.$.id; if (that._selectedIds.indexOf(parsedId) !== -1 || that._disabledSelection.indexOf(parsedId) !== -1) { return; } const rowElement = that.$.tableContainer.querySelector(`tr[row-id="${parsedId}"`); that._selectedIds.push(parsedId); if (rowElement) { rowElement.firstElementChild.classList.add('selected'); rowElement.setAttribute('aria-selected', true); } that._updateSelectAllState(); } /** * Sets the value of a cell. * * @param {number|string} row The id of the cell's row. * @param {string} dataField The dataField of the cell's column. * @param {any} value The new value of the cell. */ setValue(row, dataField, value) { const that = this, column = that._columns.find(col => col.dataField === dataField); if (!column) { return; } const rowObject = that.rowById[row]; if (!rowObject) { return; } const cell = that.$.tableContainer.querySelector(`tr[row-id="${row}"] td[data-field="${dataField}"]`); that.dataSource._updating = true; rowObject.data[dataField] = value; cell.innerHTML = that._formatCellValue(rowObject, column, cell); delete that.dataSource._updating; } /** * Unselects a row. * * @param {string | number} rowId The id of the row to unselect. */ unselect(rowId) { const that = this; if (!that.selection) { return; } const rowObject = that.rowById ? that.rowById[rowId] : that.rows.find(currentRow => currentRow.$.id === rowId); if (!rowObject) { return; } const parsedId = rowObject.data ? rowObject.data.$.id : rowObject.$.id, selectedIdIndex = that._selectedIds.indexOf(parsedId); if (selectedIdIndex === -1) { return; } const rowElement = that.$.tableContainer.querySelector(`tr[row-id="${parsedId}"`); that._selectedIds.splice(selectedIdIndex, 1); if (rowElement) { rowElement.firstElementChild.classList.remove('selected'); rowElement.setAttribute('aria-selected', false); } that._updateSelectAllState(); } /** * Called when a property is changed. */ propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; function clearFilterSort() { that._clearFilterInput(); that._clearRowFilters(); delete that._filterInfo.appliedFilters; that._sortColumns = []; } switch (propertyName) { case 'animation': if (that.filterRow) { const filterRow = that.$.tableContainer.querySelector('.lw-table-filter-row'), elements = Array.from(filterRow.querySelectorAll('lw-input, lw-button')); elements.forEach(element => element.animation = newValue); } break; case 'columns': clearFilterSort(); that._initColumns(); that.refresh(); break; case 'dataSource': clearFilterSort(); that._dataBind(); break; case 'disabled': case 'unfocusable': case 'keyboardNavigation': that._setFocusable(); break; case 'editing': if (newValue) { that.$.tableContainer.removeAttribute('aria-readonly'); } else { that.$.tableContainer.setAttribute('aria-readonly', true); } break; case 'filtering': if (newValue && that.filterRow) { that._createFilterRow(); } else if (newValue === false) { if (that.filterRow) { that.$.tableContainer.querySelector('.lw-table-filter-row').remove(); } if (that._filterInfo.query || that._filterInfo.rowFilters || that._filterInfo.appliedFilters) { that.clearFilters(); } } break; case 'filterRow': that.$.header.classList.toggle('lw-hidden', newValue && !that.filterTemplate); if (!that.filtering) { return; } if (newValue) { that._createFilterRow(); } else { that.$.tableContainer.querySelector('.lw-table-filter-row').remove(); if (that._filterInfo.rowFilters) { that.clearFilters(); } } break; case 'filterTemplate': that._applyFilterTemplate(); that.$.header.classList.toggle('lw-hidden', that.filterRow && !that.filterTemplate); break; case 'footerRow': { const footer = that.$.tableContainer.querySelector('tfoot'); if (footer) { footer.remove(); } if (newValue) { that._createFooterRow(); } break; } case 'grouping': if (!newValue) { that.clearGrouping(); } break; case 'headerRow': { const headerRows = Array.from(that.$.tableContainer.firstElementChild.children); for (let i = 1; i < headerRows.length; i++) { headerRows[i].remove(); } if (newValue) { that._createCustomHeaderRow(); } break; } case 'locale': case 'messages': that._localize(); if (that.filterRow) { const filterRow = that.$.tableContainer.querySelector('.lw-table-filter-row'), stringConditionsInputs = Array.from(filterRow.querySelectorAll('lw-input.string-filter')), numDateConditionsInputs = Array.from(filterRow.querySelectorAll('lw-input.num-date-filter')), clearFilterButtons = Array.from(filterRow.querySelectorAll('lw-button')); stringConditionsInputs.concat(numDateConditionsInputs).forEach(input => input.title = that.localize('filterCondition')); stringConditionsInputs.forEach(input => { input.dataSource = that._filterInfo.stringConditions; if (input.$.input.dataValue === undefined) { input.value = that.localize('CONTAINS'); } else { input.value = that._filterInfo.stringConditions.find(condition => condition.value === input.$.input.dataValue).label; } }); numDateConditionsInputs.forEach(input => { input.dataSource = that._filterInfo.numberAndDateConditions; if (input.$.input.dataValue === undefined) { input.value = that.localize('EQUAL'); } else { input.value = that._filterInfo.numberAndDateConditions.find(condition => condition.value === input.$.input.dataValue).label; } }); clearFilterButtons.forEach(button => button.title = that.localize('clearFilter')); } break; case 'pageIndex': that.pageIndex = Math.max(Math.min(Math.round(newValue), that.$.pager.pagesCount - 1), 0); if (that.paging && that.pageIndex !== oldValue) { that._fullRefresh('pageIndexChange'); that.$.fireEvent('page', { action: 'pageIndexChange' }); } break; case 'pageSize': if (that.paging) { that._fullRefresh('pageSizeChange'); that.$.fireEvent('page', { action: 'pageSizeChange' }); } break; case 'paging': if (newValue === false) { if (that.dataSource.virtualDataSource) { that.paging = true; return; } if (that.$.pager.pagesCount === 1) { return; } } that._fullRefresh(); break; case 'rightToLeft': Array.from(that.$.tableContainer.querySelectorAll('.freeze-near, .freeze-far')).forEach(td => { td.style.left = null; td.style.right = null; td.style.zIndex = null; }); that._handleFrozenColumnPositions(); break; case 'selection': if (that.filterRow) { const filterRow = that.$.tableContainer.querySelector('.lw-table-filter-row'); if (newValue) { filterRow.insertBefore(document.createElement('td'), filterRow.firstElementChild); } else { filterRow.firstElementChild.remove(); } } that.refresh(); if (newValue) { that.$.tableContainer.setAttribute('aria-multiselectable', true); that._updateSelectAllState(); } else { that.$.tableContainer.removeAttribute('aria-multiselectable'); } break; case 'sortMode': if (newValue === 'none') { that.clearSort(); } break; } } /** * Renders the element. Calls only element-specific functionality. */ _createElement() { const that = this; that._expandedIds = []; that._dblclickObject = { numberOfClicks: 0 }; that._editors = {}; that._setupPagingAndFiltering(); that._localize(); that._dataBind(); if (!that.editing) { that.$.tableContainer.setAttribute('aria-readonly', true); } } _initColumns() { const that = this, columns = that.columns; if (!that.isRendered && that.dataSource.length > 0 && (!columns || Array.isArray(columns) && columns.length === 0)) { that.columns = that.dataSource.dataFields.map(dataField => { return { label: dataField.name, dataField: dataField.name, dataType: dataField.dataType }; }); } that._filterInfo.stringDataFields = []; that._columns = []; that.columnByDataField = {}; for (let i = 0; i < that.columns.length; i++) { let boundColumn = that.columns[i]; if (typeof boundColumn === 'string') { if (that.dataSource.dataFields) { const field = that.dataSource.dataFields.find(field => { if (field.name === boundColumn) { return field; } }); boundColumn = { label: boundColumn, dataField: boundColumn, dataType: field ? field.dataType || 'string' : 'string' }; } } if (boundColumn.label === undefined && boundColumn.dataField === undefined) { continue; } if (boundColumn.label === undefined) { boundColumn.label = boundColumn.dataField; } if (boundColumn.dataField === undefined) { boundColumn.dataField = boundColumn.label; } if (!boundColumn.dataType) { boundColumn.dataType = 'string'; } if ((boundColumn.dataType === 'string' || boundColumn.dataType === 'number') && boundColumn.allowFilter !== false) { that._filterInfo.stringDataFields.push(boundColumn.dataField); } that._columns.push(boundColumn); that.columnByDataField[boundColumn.dataField] = boundColumn; } that.columns = new LW.ObservableArray(that._columns); that.columns.notify(function (changes) { if (!that.columns.canNotify || changes.action === 'length' || changes.action === 'update' && ['allowGroup', 'allowSort', 'sortOrder'].indexOf(changes.propertyName) !== -1) { return; } if (changes.action === 'update') { const dataField = changes.target.dataField; if (changes.propertyName === 'allowEdit') { Array.from(that.$.tableContainer.querySelectorAll(`td[data-field="${dataField}"]`)). forEach(td => { td.classList.toggle('no-edit', changes.newValue === false); if (changes.newValue === false) { td.setAttribute('aria-readonly', true); } else { td.removeAttribute('aria-readonly'); } }); return; } if (changes.propertyName === 'allowFilter') { if (changes.target.dataType === 'string' || changes.target.dataType === 'number') { if (changes.newValue === false) { that._filterInfo.stringDataFields = that._filterInfo.stringDataFields.filter(currentDataField => currentDataField !== dataField); } else if (changes.oldValue === false) { that._filterInfo.stringDataFields.push(dataField); } } if (that.filterRow) { that.$.tableContainer.querySelector(`.lw-table-filter-row td[filter-for="${dataField}"]`).classList.toggle('no-filter', changes.newValue === false); } return; } if (['allowPivot', 'allowRowGroup', 'pivot', 'rowGroup', 'summary'].indexOf(changes.propertyName) !== -1 && that.nodeName.toLowerCase() === 'lw-pivot-table') { that._columnNotify(changes); return; } } that._columns = that.columns._array; that.columnByDataField = []; that._columns.forEach(column => that.columnByDataField[column.dataField] = column); that.refresh(true); }); that.$.tableContainer.setAttribute('aria-colcount', that._columns.length + (+that.selection)); } /** * Initializes rows. */ _initRows() { const that = this, dataSource = that.dataSource, oldContext = that.context; that.context = that; that.rows = []; that.rowById = []; if (dataSource.boundHierarchy) { that.$.tableContainer.setAttribute('role', 'treegrid'); that.setAttribute('hierarchy', ''); that._initHierarchicalRows(); return; } that.$.tableContainer.setAttribute('role', 'grid'); let viewStart = 0, viewEnd = dataSource.length, pagingAndFiltering = false; that.removeAttribute('hierarchy'); if (that.paging) { const pageSize = that.pageSize; if (that._filterInfo.query || that._filterInfo.rowFilters || that._filterInfo.appliedFilters) { let visibleRecords = 0; for (let i = 0; i < viewEnd; i++) { if (dataSource[i].$.filtered !== false) { visibleRecords++; } } viewEnd = visibleRecords; pagingAndFiltering = true; } const pagesCount = Math.max(Math.ceil(viewEnd / pageSize), 1), oldPagesCount = that.$.pager.pagesCount; that.$.pager.pagesCount = pagesCount; that.$.pager.totalRecords = viewEnd; that.pageIndex = Math.max(Math.min(that.pageIndex, pagesCount - 1), 0); if (that.dataSource.virtualDataSource && oldPagesCount !== pagesCount) { that._fullRefresh(); return; } viewStart = that.pageIndex * pageSize; viewEnd = viewStart + pageSize; } if (pagingAndFiltering) { let j = -1; for (let i = 0; i < dataSource.length; i++) { const data = dataSource[i]; if (data && data.$.filtered !== false) { j++; if (j < viewStart) { continue; } if (j >= viewEnd) { break; } that._addNewRow(data, i); } } } else { for (let i = viewStart; i < viewEnd; i++) { const data = dataSource[i]; if (data && data.$.filtered !== false) { that._addNewRow(data, i); } } } that._observeRows(); that.context = oldContext; } /** * Initializes hierarchical rows. */ _initHierarchicalRows() { const that = this, boundHierarchy = that.dataSource.boundHierarchy; let viewStart = 0, viewEnd = boundHierarchy.length, pagingAndFiltering = false; if (that.paging) { const pageSize = that.pageSize; if (that._filterInfo.query || that._filterInfo.rowFilters || that._filterInfo.appliedFilters) { let visibleRecords = 0; for (let i = 0; i < viewEnd; i++) { if (boundHierarchy[i].$.filtered !== false) { visibleRecords++; } } viewEnd = visibleRecords; pagingAndFiltering = true; } const pagesCount = Math.max(Math.ceil(viewEnd / pageSize), 1); that.$.pager.pagesCount = pagesCount; that.$.pager.totalRecords = viewEnd; that.pageIndex = Math.max(Math.min(that.pageIndex, pagesCount - 1), 0); viewStart = that.pageIndex * pageSize; viewEnd = viewStart + pageSize; } function processHierarchy(object, start, end) { for (let i = start; i < end; i++) { const item = object[i]; if (!item) { break; } if (item.leaf) { if (item && item.$.filtered !== false) { that._addNewRow(item, i); } } else { if (item.expanded === undefined) { item.expanded = false; } if (item.children.length && item.$.filtered !== false) { that._addNewRow(item, i); processHierarchy(item.children, 0, item.children.length); } } } } if (pagingAndFiltering) { let j = -1; for (let i = 0; i < boundHierarchy.length; i++) { const data = boundHierarchy[i]; if (data && data.$.filtered !== false) { j++; if (j < viewStart) { continue; } if (j >= viewEnd) { break; } processHierarchy(boundHierarchy, i, i + 1); } } } else { processHierarchy(boundHierarchy, viewStart, viewEnd); } that._observeRows(); } /** * Makes "rows" an observable array. */ _observeRows() { const that = this; that.rows = new LW.ObservableArray(that.rows); that.rows.notify(function (changes) { if (!that.rows.canNotify || changes.path || !that.dataSource) { return; } that.rows.canNotify = false; const changeType = changes.action; that.dataSource.canNotify = false; switch (changeType) { case 'add': that.dataSource.add(that.rows[changes.index]); break; case 'update': that.dataSource.update(changes.index, that.rows[changes.index]); break; case 'remove': that.dataSource.removeAt(changes.index); break; } that.dataSource.canNotify = true; that.rows.canNotify = true; that._fullRefresh(); }); } /** * Adds a new row */ _addNewRow(data, index) { const that = this, id = data.$.id, row = new LW.Observable({ data: data, boundIndex: index }); if (that._disabledSelection.indexOf(id) !== -1) { row.allowSelect = false; } row.canNotify = true; row.notify(function (changes) { if (that._editing) { return; } if (changes.propertyName === 'allowSelect') { const rowElement = that.$.tableContainer.querySelector(`[row-id="${id}"]`), disabledSelectionIndex = that._disabledSelection.indexOf(id); if (!changes.newValue && disabledSelectionIndex === -1) { that.unselect(id); rowElement.removeAttribute('aria-selected'); rowElement.classList.add('disable-select'); that._disabledSelection.push(id); } else if (changes.newValue && disabledSelectionIndex !== -1) { rowElement.setAttribute('aria-selected', false); rowElement.classList.remove('disable-select'); that._disabledSelection.splice(disabledSelectionIndex, 1); } } }); that.rowById[id] = row; that.rows.push(row); } refresh() { const that = this, selection = that.selection, tableContainer = that.$.tableContainer, filterRow = tableContainer.querySelector('.lw-table-filter-row'), footer = tableContainer.querySelector('tfoot'), tbody = document.createElement('tbody'), thead = document.createElement('thead'), tr = document.createElement('tr'), fragment = document.createDocumentFragment(); that.columns.canNotify = false; tableContainer.innerHTML = ''; if (selection) { tr.innerHTML = '<th class="lw-table-select-all freeze-near" scope="col" aria-colindex="1"><div></div></th>'; } for (let i = 0; i < that._columns.length; i++) { const th = document.createElement('th'), column = that._columns[i]; th.setAttribute('aria-colindex', i + 1 + (+selection)); if (column.width && !isNaN(parseFloat(column.width))) { if (typeof column.width === 'number') { column.width += 'px'; } th.style.width = column.width; } if (column.freeze) { th.classList.add('freeze-' + (column.freeze === 'far' ? 'far' : 'near')); } if (column.responsivePriority) { if (typeof column.responsivePriority !== 'number') { column.responsivePriority = 1; } column.responsivePriority = Math.max(Math.min(Math.round(column.responsivePriority), 5), 1); th.classList.add('priority-' + column.responsivePriority); } th.setAttribute('data-field', column.dataField); th.innerHTML = column.label; if (that.onColumnRender) { that.onColumnRender(column.dataField, th); } fragment.appendChild(th); } tr.appendChild(fragment); thead.appendChild(tr); tableContainer.appendChild(thead); if (!that.isRendered && that.onInit) { that.onInit(); } that._createDataRows(tbody); tableContainer.appendChild(tbody); that._createCustomHeaderRow(); that._createFilterRow(filterRow); that._createFooterRow(footer); const headerCellElements = tableContainer.querySelectorAll('th[data-field]'); for (let i = 0; i < that._columns.length; i++) { const column = that._columns[i]; column.headerCellElement = headerCellElements[i]; column.headerCellElement.onclick = function () { const dataField = this.dataField; that.$.fireEvent('columnClick', { dataField: dataField }); if (that.sortMode === 'none' || column.allowSort === false) { return; } that._addSortIconContainer(this); if (this.headerCellElement.sortIconContainerElement.classList.contains('asc')) { that.sortBy(dataField, 'desc'); } else if (this.headerCellElement.sortIconContainerElement.classList.contains('desc')) { that.sortBy(dataField, null); } else { that.sortBy(dataField, 'asc'); } }.bind(column); } if (that._sortColumns && that._sortColumns.length > 0) { for (let i = 0; i < that._sortColumns.length; i++) { const sortColumn = that._sortColumns[i]; const column = that.columnByDataField[sortColumn.dataField]; if (!column.headerCellElement.sortIconContainerElement) { column.headerCellElement.innerHTML += '<span class="sort-by ' + sortColumn.direction + '"></span>'; column.headerCellElement.sortIconContainerElement = column.headerCellElement.lastChild; } } } that._handleFrozenColumnPositions(); that.columns.canNotify = true; } /** * Refreshes data rows only */ _refreshDataRows() { const that = this, tbody = that.$.tableContainer.children[1], dataRows = Array.from(tbody.querySelectorAll('tr:not(.lw-table-filter-row)')); for (let i = 0; i < dataRows.length; i++) { dataRows[i].remove(); } that._createDataRows(tbody); that._handleFrozenColumnPositions(); } /** * Creates Table data rows. */ _createDataRows(tbody) { const that = this, rowDetailTemplate = that.rowDetailTemplate, selection = that.selection, fragment = document.createDocumentFragment(), hierarchical = that.hasAttribute('hierarchy'); for (let i = 0; i < that.rows.length; i++) { const rowObject = that.rows[i], data = rowObject.data; if (data.groupDataField) { that._createGroupHeader(data, selection, fragment); continue; } const id = data.$.id, rowElement = document.createElement('tr'); let colspan = 0; rowElement.setAttribute('aria-rowindex', data.$.index + 1); if (selection) { const selectionTd = document.createElement('td'), selected = that._selectedIds.indexOf(id) !== -1; selectionTd.className = `lw-table-select-row freeze-near${selected ? ' selected' : ''}`; selectionTd.innerHTML = '<div></div>'; selectionTd.setAttribute('aria-colindex', 1); rowElement.appendChild(selectionTd); rowElement.setAttribute('aria-selected', selected); colspan++; } for (let j = 0; j < that._columns.length; j++) { const td = document.createElement('td'), column = that._columns[j]; td.setAttribute('data-field', column.dataField); td.setAttribute('aria-colindex', j + 1 + (+selection)); let value = that._formatCellValue(rowObject, column, td); if (column.freeze) { td.classList.add('freeze-' + (column.freeze === 'far' ? 'far' : 'near')); } if (column.responsivePriority) { td.classList.add('priority-' + column.responsivePriority); } if (column.allowEdit === false) { td.classList.add('no-edit'); td.setAttribute('aria-readonly', true); } if (j === 0 && hierarchical) { const childrenFiltered = that._areChildrenFiltered(data); if (!data.leaf) { td.classList.add('tree-cell'); if (childrenFiltered) { value = `<div> <div class="hierarchy-arrow lw-arrow lw-arrow-down"></div> <div>${value}</div> </div>`; } } if (data.level) { td.classList.add('outline-level-' + Math.min(data.level, 10)); if (data.leaf || !childrenFiltered) { td.classList.add('tree-leaf'); } } } td.innerHTML = value; if (that.onCellRender) { that.onCellRender(data, column.dataField, data[column.dataField], td); } rowElement.appendChild(td); colspan++; } rowElement.data = data; rowElement.setAttribute('row-id', id); if (that._disabledSelection.indexOf(id) !== -1) { rowElement.removeAttribute('aria-selected'); rowElement.classList.add('disable-select'); } if (data.expanded) { rowElement.setAttribute('aria-expanded', true); rowElement.classList.add('expanded'); } if (data.level && that._isCollapsed(data)) { rowElement.setAttribute('aria-hidden', true); rowElement.classList.add('collapsed'); } fragment.appendChild(rowElement); if (rowDetailTemplate) { const detailTr = document.createElement('tr'); detailTr.className = 'lw-table-row-detail'; if (that._expandedIds.indexOf(id) === -1) { detailTr.setAttribute('aria-hidden', true); detailTr.classList.add('collapsed'); } detailTr.innerHTML = `<td colspan="${colspan}"><div class="lw-table-detail-container">${that._applyRowDetailTemplate(rowObject)}</div></td>`; fragment.appendChild(detailTr); } } fragment.appendChild(that._createLastRow()); tbody.appendChild(fragment); } /** * Creates last, invisible, row. */ _createLastRow() { const lastVisibleRow = document.createElement('tr'); lastVisibleRow.setAttribute('aria-hidden', true); lastVisibleRow.classList.add('last-visible'); return lastVisibleRow; } /** * Creates a group header. */ _createGroupHeader(data, selection, container) { const that = this, groupLabel = that._columns.find(col => col.dataField === data.groupDataField).label, groupHeader = document.createElement('tr'), cell = document.createElement('td'), cellInnerContainer = document.createElement('div'), arrow = document.createElement('div'), label = document.createElement('div'); groupHeader.data = data; arrow.classList.add('hierarchy-arrow', 'lw-arrow', 'lw-arrow-down'); label.classList.add('group-label') label.innerHTML = `${groupLabel}: <span class="group-label-value">${data.label}</span>`; cell.colSpan = that._columns.length; cell.classList.add('group-header'); if (data.level) { cell.classList.add('outline-level-' + Math.min(data.level, 10)); if (that._isCollapsed(data)) { groupHeader.setAttribute('aria-hidden', true); groupHeader.classList.add('collapsed'); } } groupHeader.setAttribute('row-id', data.$.id); cellInnerContainer.appendChild(arrow); cellInnerContainer.appendChild(label); cell.appendChild(cellInnerContainer); if (selection) { groupHeader.appendChild(document.createElement('td')); } groupHeader.appendChild(cell); container.appendChild(groupHeader); } /** * Returns whether a data row or group header is collapsed. */ _isCollapsed(data) { let parent = data.parent; while (parent) { if (!parent.expanded) { return true; } parent = parent.parent; } return false; } /** * Returns whether at least one child is not filtered out. */ _areChildrenFiltered(data) { if (data.leaf) { return; } for (let i = 0; i < data.children.length; i++) { if (data.children[i].$.filtered !== false) { return true; } } return false; } /** * Applies row detail template. */ _applyRowDetailTemplate(rowObject) { const that = this, dataFields = that.dataSource.dataFields; let content = that.rowDetailTemplate; for (let i = 0; i < dataFields.length; i++) { const dataField = dataFields[i].name, regex = new RegExp(`{{${dataField}}}`, 'g'); let column = that._columns.find(col => col.dataField === dataField) || { dataField: dataField }; if (regex.test(content)) { const data = that._formatCellValue(rowObject, column, document.createElement('td')); content = content.replace(regex, data); } } return content; } /** * Handles the relative positions of frozen columns. */ _handleFrozenColumnPositions() { const that = this, rightToLeft = that.rightToLeft, columns = that._columns; let frozenNear = [], frozenFar = [], selectionModifier = 0; function applyStyle(property, index, value, i, zIndex) { Array.from(that.$.tableContainer.querySelectorAll(`th:nth-child(${index + 1}), td:nth-child(${index + 1})`)). forEach(td => { td.style[property] = value + 'px'; if (zIndex) { td.style.zIndex = 2 + i; } }); } if (that.selection) { if (!rightToLeft) { frozenNear.push(0); } else { frozenFar.push(0); } selectionModifier = 1; } for (let i = 0 + selectionModifier; i < columns.length + selectionModifier; i++) { const column = columns[i - selectionModifier]; if (!column.freeze) { continue; } if (!rightToLeft && column.freeze === 'far' || rightToLeft && column.freeze !== 'far') { frozenFar.push(i); } else { frozenNear.push(i); } } if (frozenNear.length < 2 && frozenFar.length < 2) { return; } const headerCells = that.$.tableContainer.firstElementChild.querySelectorAll('th'), widths = []; for (let i = 0; i < headerCells.length; i++) { widths.push(headerCells[i].offsetWidth); } if (!rightToLeft) { for (let i = 1; i < frozenNear.length; i++) { const index = frozenNear[i]; let left = 0; for (let j = 0; j < index; j++) { if (frozenNear.indexOf(j) !== -1) { left += widths[j]; } } applyStyle('left', index, left, i, false); } for (let i = 0; i < frozenFar.length - 1; i++) { const index = frozenFar[i]; let right = 0; for (let j = index + 1; j < widths.length; j++) { if (frozenFar.indexOf(j) !== -1) { right += widths[j]; } } applyStyle('right', index, right, i, true); } return; } // right-to-left for (let i = 0; i < frozenNear.length - 1; i++) { const index = frozenNear[i]; let left = 0; for (let j = index + 1; j < widths.length; j++) { if (frozenNear.indexOf(j) !== -1) { left += widths[j]; } } applyStyle('left', index, left, i, true); } for (let i = 1; i < frozenFar.length; i++) { const index = frozenFar[i]; let right = 0; for (let j = 0; j < index; j++) { if (frozenFar.indexOf(j) !== -1) { right += widths[j]; } } applyStyle('right', index, right, i, false); } } /** * Returns formatted cell value. */ _formatCellValue(row, column, cell, value) { if (value === undefined) { value = row.data[column.dataField]; } if (column.formatFunction) { const settings = { value: value, row: row && row.data ? row.data.$.id : row, column: column.dataField, cell: cell, template: null }; column.formatFunction(settings); value = settings.value; if (settings.template === null || typeof settings.template !== 'string') { return value; } const template = settings.template; let result = ''; if (template.startsWith('#')) { const templateElement = document.querySelector(template); if (templateElement && templateElement instanceof HTMLTemplateElement) { const templateContent = templateElement.content.cloneNode(true), tempElement = document.createElement('div'); tempElement.appendChild(templateContent); value = value.toString(); value = value.replace(/'/ig, '\\\''); value = value.replace(/"/ig, '\\"'); result = tempElement.innerHTML.replace(/{{value}}/ig, value); if (result.indexOf('{{value=') >= 0) { if (!value) { result = result.replace(/{{value=/ig, ''); result = result.replace(/}}/ig, ''); } else { result = result.substring(0, result.indexOf('{{value=')) + value + result.substring(result.indexOf('}')); result = result.replace(/}/ig, ''); result = result.replace(/{/ig, ''); } } return result; } } result = template.replace(/{{value}}/ig, value); return result; } else if (column.dataType === 'date' && value instanceof Date) { return value.toLocaleDateString(); } return value; } _dataBind() { const that = this; const removeLastRow = function () { const lastRow = that.rows[that.rows.length - 1]; delete that.rowById[lastRow.uid]; that.rows.pop(); } const removeAt = function (index) { const lastRow = that.rows[that.rows.length - 1]; delete that.rowById[lastRow.uid]; that.rows.splice(index, 1); } if (!that.dataSource) { that.dataFields = []; if (!that.columns || Array.isArray(that.columns) && that.columns.length === 0) { that.columns = []; const th = that.querySelectorAll('th'); for (let i = 0; i < th.length; i++) { const label = th[i].innerHTML.trim(); let boundColumn = { label: label, dataField: label, dataType: 'string' }; that.columns.push(boundColumn); that.dataFields.push(label); } } else { for (let i = 0; i < that.columns.length; i++) { const column = that.columns[i]; if (typeof column === 'string') { that.dataFields.push(column); } else if (typeof column === 'object') { that.dataFields.push(column.dataField + (column.dataType ? ': ' + column.dataType : '')); } } } let rows = []; if (!that.rows) { const tr = that.querySelectorAll('tr'); for (let i = 0; i < tr.length; i++) { const row = tr[i]; const newRow = {}; const td = row.querySelectorAll('td'); if (td.length > 0) { for (let j = 0; j < that.columns.length; j++) { const column = that.columns[j]; newRow[column.dataField] = td[j].innerHTML.trim(); } rows.push(newRow); } } that.dataSource = new LW.DataAdapter( { dataSource: rows, dataFields: that.dataFields }); } const tables = that.$.container.querySelectorAll('table'); if (tables.length > 1) { tables[tables.length - 1].parentNode.removeChild(tables[tables.length - 1]); } } else if (that.dataSource instanceof LW.DataAdapter === false) { if (Array.isArray(that.dataSource)) { that.dataSource = new LW.DataAdapter({ dataSource: that.dataSource }); } else { that.dataSource = new LW.DataAdapter({ dataSource: [] }); } } that._initColumns(); that._initRows(); that.dataSource.notify(function (changes) { if (that.dataSource._updating || that._editing) { return; } const data = changes.data; that.rows.canNotify = false; switch (changes.action) { case 'add': if (data.length) { for (let i = 0; i < data.length; i++) { that._addNewRow(data[i], that.dataSource.length - data.length + i); } } else { that._addNewRow(data, that.dataSource.length - 1); } break; case 'update': if (data.length) { for (let i = 0; i < data.length; i++) { const index = changes.index[i]; that.rows[index].data = data[i]; } } else { /* const index = changes.index; that.rows[index].data = data; */ } break; case 'insert': that._addNewRow(data, changes.index); for (let i = 0; i < that.rows.length; i++) { const row = that.rows[i]; row.dataIndex = i; } break; case 'remove': removeAt(changes.index); break; case 'removeLast': removeLastRow(); break; } that.rows.canNotify = true; that._fullRefresh(); }); that.refresh(); if (that.dataSource.virtualDataSource) { that.paging = true; that._requestVirtualDataSource('dataBind'); } that.$.tableContainer.setAttribute('aria-rowcount', that.dataSource.length); } /** * Request virtual data source (remote data). */ _requestVirtualDataSource(action) { const that = this, pageSize = that.pageSize, viewStart = Math.max(that.pageIndex * pageSize, 0), viewEnd = Math.min(viewStart + pageSize, that.dataSource.length), sorting = [], filtering = []; let filterOperator = null; if (that._sortColumns) { that._sortColumns.forEach((column, index) => sorting[column.dataField] = { sortOrder: column.direction, sortIndex: index }); sorting.length = that._sortColumns.length; } if (that._filterInfo.appliedFilters) { for (let dataField in that._filterInfo.appliedFilters) { filtering[dataField] = that._filterInfo.appliedFilters[dataField]; } filtering.length = Object.keys(that._filterInfo.appliedFilters).length; filterOperator = 'and'; } else { const UIFilters = that._filterInfo.inputFilters || that._filterInfo.rowFilters; if (UIFilters) { UIFilters.forEach(filter => filtering[filter[0]] = filter[1]); filtering.length = UIFilters.length; } filterOperator = that._filterInfo.inputFilters ? 'or' : 'and'; } that.$.loadingIndicatorContainer.classList.remove('lw-hidden'); that.setAttribute('loading', ''); that.dataSource.onVirtualDataSourceRequested( that._virtualDataSourceRequestedCallback.bind(that), { first: viewStart, last: viewEnd, sorting: sorting, filtering: filtering, filterOperator: filterOperator, grouping: [], action: action }); } /** * "onVirtualDataSourceRequested" callback function. */ _virtualDataSourceRequestedCallback() { const that = this; delete that.dataSource._updating; that.$.loadingIndicatorContainer.classList.add('lw-hidden'); that.removeAttribute('loading'); that._initRows(); that._refreshDataRows(); } sortBy(columnDataField, sortOrder) { const that = this, column = that.columnByDataField[columnDataField]; if (column && column.allowSort === false) { return; } that._sortBy({ column: column, columnDataField: columnDataField, sortOrder: sortOrder, dataFields: that.dataSource.dataFields, columnByDataField: 'columnByDataField' }); } /** * General sorting functionality */ _sortBy(settings) { const that = this, column = settings.column, columnDataField = settings.columnDataField, sortOrder = settings.sortOrder, dataFields = settings.dataFields, columnByDataField = settings.columnByDataField, sortDataFields = [], sortOrders = [], sortDataTypes = []; const clearSortColumn = function (column) { that._addSortIconContainer(column); column.headerCellElement.sortIconContainerElement.classList.remove('desc'); column.headerCellElement.sortIconContainerElement.classList.remove('asc'); column.sortOrder = null; } const clearSortColumns = function () { if (that._sortColumns && that._sortColumns.length > 0) { for (let i = 0; i < that._sortColumns.length; i++) { const sortColumn = that._sortColumns[i]; const column = that[columnByDataField][sortColumn.dataField]; clearSortColumn(column); } } that._sortColumns = []; } if (column === null || column === undefined) { if (that._sortColumns && that._sortColumns.length > 0) { clearSortColumns(); that._sortCallback(sortDataFields, sortOrders, sortDataTypes); } return; } if (that.sortMode === 'none' || !that.dataSource) { return; } if (sortOrder && column.sortOrder === sortOrder) { return; } let sortColumnDirection = sortOrder || 'asc'; clearSortColumn(column); if (!that._sortColumns) { that._sortColumns = []; } let dataType = 'string'; for (let i = 0; i < dataFields.length; i++) { const field = dataFields[i]; if (field.name === columnDataField) { dataType = field.dataType; break; } } let addNewSortColumn = true; for (let i = 0; i < that._sortColumns.length; i++) { const sortColumn = that._sortColumns[i]; if (sortColumn.dataField === columnDataField) { addNewSortColumn = false; if (sortColumn.direction === 'asc') { sortColumn.direction = 'desc'; sortColumnDirection = 'desc'; } else if (sortColumn.direction === 'desc') { that._sortColumns.splice(i, 1); clearSortColumn(column); sortColumnDirection = null; break; } } } if (addNewSortColumn) { if (that.sortMode === 'one') { clearSortColumns(); } that._sortColumns.push({ dataField: columnDataField, direction: sortColumnDirection, dataType: dataType }); } that._addSortIconContainer(column); if (sortColumnDirection !== null) { column.headerCellElement.sortIconContainerElement.classList.remove('asc'); column.headerCellElement.sortIconContainerElement.classList.remove('desc'); column.sortOrder = sortColumnDirection; if (sortColumnDirection === 'desc') { column.headerCellElement.sortIconContainerElement.classList.add('desc'); column.headerCellElement.setAttribute('aria-sort', 'descending'); } else { column.headerCellElement.sortIconContainerElement.classList.add('asc'); column.headerCellElement.setAttribute('aria-sort', 'ascending'); } } else { column.headerCellElement.sortIconContainerElement.classList.remove('asc'); column.headerCellElement.sortIconContainerElement.classList.remove('desc'); column.headerCellElement.removeAttribute('aria-sort'); } for (let i = 0; i < that._sortColumns.length; i++) { const sortColumn = that._sortColumns[i]; sortDataFields.push(sortColumn.dataField); sortOrders.push(sortColumn.direction); sortDataTypes.push(sortColumn.dataType); } that._sortCallback(sortDataFields, sortOrders, sortDataTypes); that.$.fireEvent('sort', { columns: that._sortColumns }); } /** * Adds sort icon container to a header cell */ _addSortIconContainer(column) { const headerCellElement = column.headerCellElement; if (!headerCellElement.sortIconContainerElement) { headerCellElement.innerHTML += '<span class="sort-by"></span>'; headerCellElement.sortIconContainerElement = column.headerCellElement.lastChild; } } /** * Applies sorting; refreshes the view */ _sortCallback(sortDataFields, sortOrders, sortDataTypes) { const that = this, dataSource = that.dataSource; if (!dataSource.virtualDataSource) { dataSource._sort(that.dataSource.boundSource, sortDataFields, sortOrders, sortDataTypes); dataSource.refreshHierarchy(); } that._fullRefresh('sort'); } /** * Clears the sorting of all columns */ clearSort() { this.sortBy(null); } /** * Makes a full Table refresh */ _fullRefresh(action) { const that = this; if (that.dataSource.virtualDataSource) { that.dataSource._updating = true; that._requestVirtualDataSource(action); return; } that._initRows(); that._refreshDataRows(); } /** * pager change handler */ _pagerChangeHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; if (target !== that.$.pager) { return; } that.pageIndex = event.detail.index; that._fullRefresh('pageIndexChange'); that.$.fireEvent('page', { action: 'pageIndexChange' }); } /** * pager pageSizeChanged handler */ _pagerPageSizeChanged(event) { const that = this; that.pageSize = event.detail.value; that._fullRefresh('pageSizeChange'); that.$.fireEvent('page', { action: 'pageSizeChange' }); } /** * filterInput keyup handler. */ _filterInputKeyupHandler() { const that = this; clearTimeout(that._filterInputTimeout); that._filterInputTimeout = setTimeout(function () { if (that._filterInfo && that.$.filterInput.value !== that._filterInfo.query) { const oldContext = that.context; that.context = that; that._filterByAll(that.$.filterInput.value); that.context = oldContext; } }, 500); } /** * Filters by all data fields. */ _filterByAll(query) { const that = this; that._filterInfo.query = query; if (query === '') { that.clearFilters(); return; } const filters = []; that._clearRowFilters(); delete that._filterInfo.appliedFilters; that._filterInfo.stringDataFields.forEach(dataField => { const filterGroup = new LW.Utilities.FilterGroup(), filterObject = filterGroup.createFilter('string', query, 'CONTAINS'); filterGroup.addFilter('or', filterObject); filters.push([dataField, filterGroup]); }); if (!that.dataSource.virtualDataSource) { that.dataSource._filter(filters, 'or'); } that._filterInfo.inputFilters = filters; that._fullRefresh('filter'); that.$.fireEvent('filter', { action: 'add', filters: filters }); } /** * Initial paging and filtering setup. */ _setupPagingAndFiltering() { const that = this; that.$.pager.$.pageSizeSelector.classList.add('underlined'); that.$.pager.$.pageSizeSelector.dropDownAppendTo = 'body'; that._filterInfo = { query: '' }; that._applyFilterTemplate(); that.$.header.classList.toggle('lw-hidden', that.filterRow && !that.filterTemplate); } /** * Applies filter template. */ _applyFilterTemplate() { const that = this, filterTemplate = that.filterTemplate; that.$.filterTemplateContainer.innerHTML = ''; if (!filterTemplate) { that.$.filterInput.classList.remove('lw-hidden'); that.$.filterTemplateContainer.classList.add('lw-hidden'); that.filterTemplate = null; return; } const potentialHTMLTemplate = document.getElementById(filterTemplate); if (potentialHTMLTemplate && potentialHTMLTemplate instanceof HTMLTemplateElement) { const templateContent = document.importNode(potentialHTMLTemplate.content, true); that.$.filterInput.classList.add('lw-hidden'); that.$.filterTemplateContainer.classList.remove('lw-hidden'); that.$.filterTemplateContainer.appendChild(templateContent); } else { that.filterTemplate = null; that.$.filterInput.classList.remove('lw-hidden'); that.$.filterTemplateContainer.classList.add('lw-hidden'); } } /** * Refreshes applied filters. */ _refreshFilters() { const that = this, filters = []; for (let columnDataField in that._filterInfo.appliedFilters) { let filterGroup = that._filterInfo.appliedFilters[columnDataField]; filters.push([columnDataField, filterGroup]); } if (filters.length === 0) { that.clearFilters(); return; } that._clearFilterInput(); that._clearRowFilters(); if (!that.dataSource.virtualDataSource) { that.dataSource._filter(filters, 'or'); } that._fullRefresh('filter'); that.$.fireEvent('filter', { action: 'add', filters: filters }); } /** * Localizes labels displayed in the Table. */ _localize() { const that = this, pager = that.$.pager; if (!pager.messages[that.locale]) { pager.messages[that.locale] = {}; } pager.messages[that.locale].pageSizeLabel = that.localize('itemsPerPage'); pager.messages[that.locale].summaryPrefix = that.localize('summaryPrefix'); pager.messages[that.locale].summarySuffix = ''; pager.$.firstButton.setAttribute('tooltip', that.localize('firstButton')); pager.$.previousButton.setAttribute('tooltip', that.localize('previousButton')); pager.$.nextButton.setAttribute('tooltip', that.localize('nextButton')); pager.$.lastButton.setAttribute('tooltip', that.localize('lastButton')); that.$.filterInput.placeholder = that.localize('filterPlaceholder'); that._filterInfo.stringConditions = [ { value: 'EMPTY', label: that.localize('EMPTY') }, { value: 'NOT_EMPTY', label: that.localize('NOT_EMPTY') }, { value: 'CONTAINS', label: that.localize('CONTAINS') }, { value: 'CONTAINS_CASE_SENSITIVE', label: that.localize('CONTAINS_CASE_SENSITIVE') }, { value: 'DOES_NOT_CONTAIN', label: that.localize('DOES_NOT_CONTAIN') }, { value: 'DOES_NOT_CONTAIN_CASE_SENSITIVE', label: that.localize('DOES_NOT_CONTAIN_CASE_SENSITIVE') }, { value: 'STARTS_WITH', label: that.localize('STARTS_WITH') }, { value: 'STARTS_WITH_CASE_SENSITIVE', label: that.localize('STARTS_WITH_CASE_SENSITIVE') }, { value: 'ENDS_WITH', label: that.localize('ENDS_WITH') }, { value: 'ENDS_WITH_CASE_SENSITIVE', label: that.localize('ENDS_WITH_CASE_SENSITIVE') }, { value: 'EQUAL', label: that.localize('EQUAL') }, { value: 'EQUAL_CASE_SENSITIVE', label: that.localize('EQUAL_CASE_SENSITIVE') }, { value: 'NULL', label: that.localize('NULL') }, { value: 'NOT_NULL', label: that.localize('NOT_NULL') } ]; that._filterInfo.numberAndDateConditions = [ { value: 'EQUAL', label: that.localize('EQUAL') }, { value: 'NOT_EQUAL', label: that.localize('NOT_EQUAL') }, { value: 'LESS_THAN', label: that.localize('LESS_THAN') }, { value: 'LESS_THAN_OR_EQUAL', label: that.localize('LESS_THAN_OR_EQUAL') }, { value: 'GREATER_THAN', label: that.localize('GREATER_THAN') }, { value: 'GREATER_THAN_OR_EQUAL', label: that.localize('GREATER_THAN_OR_EQUAL') }, { value: 'NULL', label: that.localize('NULL') }, { value: 'NOT_NULL', label: that.localize('NOT_NULL') } ]; } /** * Creates the Table's filter row. */ _createFilterRow(existingFilterRow) { const that = this; if (!that.filtering || !that.filterRow) { return; } if (existingFilterRow) { that.$.tableContainer.children[1].insertBefore(existingFilterRow, that.$.tableContainer.children[1].firstElementChild); return; } const row = document.createElement('tr'), animation = ` animation="${that.animation}" `, rightToLeft = that.rightToLeft ? ' right-to-left' : ''; let content = ''; row.className = 'lw-table-filter-row'; if (that.selection) { content += '<td></td>'; } for (let i = 0; i < that._columns.length; i++) { const column = that._columns[i], classes = []; let dataSource, inputType, className, value; if (column.dataType === 'string') { dataSource = that._filterInfo.stringConditions; inputType = 'string'; className = 'string-filter'; value = that.localize('CONTAINS'); } else { dataSource = that._filterInfo.numberAndDateConditions; inputType = column.dataType; className = 'num-date-filter'; value = that.localize('EQUAL'); } if (column.freeze) { classes.push('freeze-' + (column.freeze === 'far' ? 'far' : 'near')); } if (column.responsivePriority) { classes.push('priority-' + column.responsivePriority); } if (column.allowFilter === false) { classes.push('no-filter'); } content += `<td${classes.length ? ' class="' + classes.join(' ') + '"' : ''} filter-for="${column.dataField}"> <div> <input type="${inputType}" class="filter-value" aria-label="Filter value" /> <lw-input class="${className}${animation}data-source='${JSON.stringify(dataSource)}' drop-down-button-position="right" drop-down-width="auto" readonly${rightToLeft} value="${value}" title="${that.localize('filterCondition')}" aria-label="Filter condition"></lw-input> <lw-button class="lw-hidden" title="${that.localize('clearFilter')}"${animation}${rightToLeft} aria-label="Clear filter"></lw-button> </div> </td>`; } row.innerHTML = content; that.$.tableContainer.children[1].insertBefore(row, that.$.tableContainer.children[1].firstElementChild); } /** * tableContainer change handler. */ _tableContainerChangeHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; if (target.classList.contains('filter-value') && target.type === 'date' || target instanceof LW.Input && (target.previousElementSibling.value !== '' || ['EMPTY', 'NOT_EMPTY', 'NULL', 'NOT_NULL'].indexOf(event.detail.value) !== -1)) { that._applyRowFilters(); } } /** * tableContainer click handler. */ _tableContainerClickHandler(event) { const that = this; if (that._editing) { return; } const target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target, row = target.closest('tbody tr[row-id]'); if (row) { if (target.classList.contains('hierarchy-arrow')) { that._hierarchyArrowClickHandler(row); return; } const id = row.getAttribute('row-id'), rowData = that.rowById ? that.rowById[id].data : that.rows.find(currentRow => currentRow.$.id === id), parsedId = rowData.$.id, cell = target.closest('td'), dataField = cell ? cell.getAttribute('data-field') : undefined; if (dataField !== undefined) { that.$.fireEvent('cellClick', { row: rowData, dataField: dataField }); } that._toggleSelection(row, parsedId); if (that.editing) { if (!dataField || cell.classList.contains('no-edit')) { return; } clearTimeout(that._dblclickObject.timeout); that._dblclickObject.numberOfClicks++; if (that._dblclickObject.numberOfClicks === 2) { that._dblclickObject.numberOfClicks = 0; that._beginEdit({ rowElement: row, cell: cell, dataField: dataField }); } else { that._dblclickObject.timeout = setTimeout(function () { that._dblclickObject.numberOfClicks = 0; }, 300); } } if (that.rowDetailTemplate) { that._toggleRowDetail(row, parsedId); } return; } if (target.parentElement.classList.contains('lw-table-select-all')) { that._selectAllCheckboxClickHandler(target.parentElement); return; } const clearFilterButton = target.closest('.lw-table-filter-row lw-button'); if (clearFilterButton) { const filterValueInput = clearFilterButton.parentElement.firstElementChild, filterConditionInput = clearFilterButton.parentElement.children[1]; filterValueInput.value = ''; if (['EMPTY', 'NOT_EMPTY', 'NULL', 'NOT_NULL'].indexOf(filterConditionInput.$.input.dataValue) !== -1) { filterConditionInput.value = that.localize(filterValueInput.type === 'text' ? 'CONTAINS' : 'EQUAL'); delete filterConditionInput.$.input.dataValue; } that._applyRowFilters(); return; } } /** * Toggles selection. */ _toggleSelection(row, id) { const that = this; if (!that.selection || row.classList.contains('disable-select')) { return; } if (that._selectedIds.indexOf(id) === -1) { that.select(id); } else { that.unselect(id); } } /** * "Select all" checkbox click handler. */ _selectAllCheckboxClickHandler(checkbox, dataSource) { const that = this; if (dataSource === undefined) { dataSource = that.dataSource; } const dataSourceLength = dataSource.length, on = that._selectedIds.length === dataSourceLength - that._disabledSelection.length; that._selectedIds = []; if (on) { checkbox.classList.remove('indeterminate', 'selected'); Array.from(that.$.tableContainer.querySelectorAll('.lw-table-select-row')).forEach(td => { if (!td.parentElement.classList.contains('disable-select')) { td.parentElement.setAttribute('aria-selected', false); } td.classList.remove('selected'); }); } else { let numberOfSelected = 0; for (let i = 0; i < dataSourceLength; i++) { const id = dataSource[i].$.id; if (that._disabledSelection.indexOf(id) === -1) { that._selectedIds.push(id); numberOfSelected++; } } if (numberOfSelected === dataSourceLength) { checkbox.classList.remove('indeterminate'); checkbox.classList.add('selected'); } else if (numberOfSelected === 0) { checkbox.classList.remove('indeterminate', 'selected'); } else { checkbox.classList.remove('selected'); checkbox.classList.add('indeterminate'); } Array.from(that.$.tableContainer.querySelectorAll('.lw-table-select-row')).forEach(td => { if (!td.parentElement.classList.contains('disable-select')) { td.parentElement.setAttribute('aria-selected', true); td.classList.add('selected'); } }); } } /** * Begins an edit operation. */ _beginEdit(details) { const that = this, dataField = details.dataField; let rowId = details.rowId, rowElement = details.rowElement, rowObject = details.rowObject, cell = details.cell, cells = [], dataFields = []; if (!that.editing) { return; } if (!rowElement) { rowElement = that.$.tableContainer.querySelector(`tr[row-id="${rowId}"]`); } if (!rowObject) { rowId = rowElement.getAttribute('row-id'); rowObject = that.rowById[rowId]; rowId = rowObject.data.$.id; } if (that.editMode === 'row') { cells = rowElement.querySelectorAll('td[data-field]'); dataFields = that._columns.map(col => col.dataField); if (!cell) { cell = dataField ? rowElement.querySelector(`td[data-field="${dataField}"`) : cells[0]; } } else { if (!cell) { cell = rowElement.querySelector(`td[data-field="${dataField}"`); } cells = [cell]; dataFields = [dataField]; } that._editing = { row: rowObject, cells: [] }; for (let i = 0; i < dataFields.length; i++) { const currentCell = cells[i], currentDataField = dataFields[i], column = that._columns.find(column => column.dataField === currentDataField); if (column.allowEdit === false) { continue; } const cellValue = rowObject.data[currentDataField], editor = that._initEditor(column, rowId, currentDataField, cellValue); let standardDateEditor = editor instanceof HTMLInputElement && editor.type === 'date'; if (column.editor && column.editor.template) { if (column.editor.onRender) { column.editor.onRender(rowId, currentDataField, editor, cellValue); } } else if (standardDateEditor) { if (cellValue instanceof Date && !isNaN(cellValue.getTime())) { const month = (cellValue.getMonth() + 1).toString(), date = cellValue.getDate().toString(); editor.value = `${cellValue.getFullYear()}-${'0'.repeat(2 - month.length)}${month}-${'0'.repeat(2 - date.length)}${date}`; } else { editor.value = ''; } } else { editor.value = cellValue; } currentCell.classList.add('editing'); currentCell.innerHTML = ''; currentCell.appendChild(editor); if (currentCell === cell && editor.focus) { editor.focus(); if (!(column.editor && column.editor.template) && !standardDateEditor && editor.select) { editor.select(); } } that._editing.cells.push({ dataField: currentDataField, editor: editor, element: currentCell }); that.$.fireEvent('cellBeginEdit', { row: rowObject.data, dataField: currentDataField }); } } /** * Initializes column editor. */ _initEditor(column, rowId, dataField, value) { const that = this; let editor = that._editors[dataField]; if (editor) { return editor; } if (column.editor && column.editor.template) { const wrapper = document.createElement('div'); wrapper.innerHTML = column.editor.template; editor = wrapper.firstElementChild; editor.className = 'lw-table-editor'; if (column.editor.onInit) { column.editor.onInit(rowId, dataField, editor, value); } return editor; } editor = document.createElement('input'); editor.className = 'lw-table-editor standard'; if (column.dataType === 'number') { editor.type = 'number'; } else if (column.dataType === 'date') { editor.type = 'date'; } else { editor.type = 'text'; } that._editors[dataField] = editor; return editor; } /** * Toggles row detail. */ _toggleRowDetail(row, id) { const that = this, detailRow = row.nextElementSibling; if (that.animation === 'none') { detailRow.classList.toggle('collapsed'); if (!detailRow.classList.contains('collapsed')) { detailRow.removeAttribute('aria-hidden'); that._expandedIds.push(id); } else { detailRow.setAttribute('aria-hidden', true); that._expandedIds = that._expandedIds.filter(currentId => currentId !== id); } return; } const detailContainer = detailRow.firstElementChild.firstElementChild; if (detailRow.classList.contains('collapsed')) { const fullHeight = `calc(${detailRow.firstElementChild.scrollHeight}px + 2 * var(--lw-table-cell-padding))`; detailRow.ontransitionend = function () { detailRow.style.height = null; detailContainer.style.height = null; detailRow.removeAttribute('aria-hidden'); detailRow.classList.remove('collapsed'); detailContainer.style.paddingTop = null; detailContainer.style.paddingBottom = null; detailRow.ontransitionend = null; }; detailRow.style.height = fullHeight; detailContainer.style.height = fullHeight; detailContainer.style.paddingTop = 'var(--lw-table-cell-padding)'; detailContainer.style.paddingBottom = 'var(--lw-table-cell-padding)'; that._expandedIds.push(id); return; } const fullHeight = detailRow.firstElementChild.scrollHeight + 'px'; detailContainer.style.height = fullHeight; detailContainer.style.paddingTop = 'var(--lw-table-cell-padding)'; detailContainer.style.paddingBottom = 'var(--lw-table-cell-padding)'; detailRow.style.height = fullHeight; that._expandedIds = that._expandedIds.filter(currentId => currentId !== id); requestAnimationFrame(() => { detailRow.ontransitionend = function () { detailRow.setAttribute('aria-hidden', true); detailRow.classList.add('collapsed'); detailContainer.style.paddingTop = null; detailContainer.style.paddingBottom = null; detailContainer.style.height = null; detailRow.style.height = null; detailRow.ontransitionend = null; } detailContainer.style.paddingTop = 0; detailContainer.style.paddingBottom = 0; detailContainer.style.height = 0; detailRow.style.height = 0; }); } /** * Sets whether the element can be focused. */ _setFocusable() { const that = this; if (!that.keyboardNavigation || that.disabled || that.unfocusable) { that.$.tableContainer.removeAttribute('tabindex'); return; } const tabindex = that.$.tableContainer.getAttribute('tabindex'); if (tabindex === null || tabindex < 0) { that.$.tableContainer.setAttribute('tabindex', 0); } } /** * tableContainer focus handler. */ _tableContainerFocusHandler() { const that = this; if (!that._focusedCell || !that.$.tableContainer.contains(that._focusedCell)) { that._focusCell(that.$.tableContainer.children[1].querySelector('td[data-field], td.group-header')); } } /** * tableContainer down handler. */ _tableContainerDownHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.originalEvent.composedPath()[0] : event.originalEvent.target; that._focusCell(target.closest('td[data-field], td.group-header')); } /** * Focuses a cell. */ _focusCell(cell, scrollTo) { const that = this; if (!cell || !cell.hasAttribute('data-field') && !cell.classList.contains('group-header')) { return; } if (that._focusedCell) { if (that._focusedCell === cell) { return; } that._focusedCell.removeAttribute('focus'); } that._focusedCell = cell; cell.setAttribute('focus', ''); if (!scrollTo) { return; } const container = that.$.container, frozenHeaderHeight = (that.freezeHeader ? that.$.tableContainer.firstElementChild.offsetHeight : 0), currentScrollTop = container.scrollTop; let targetScrollTop = cell.offsetTop - frozenHeaderHeight; // vertical scroll to if (targetScrollTop < currentScrollTop) { container.scrollTop = targetScrollTop; } else { const filterHeaderHeight = that.$.header.offsetHeight, frozenFooterHeight = that.footerRow && that.freezeFooter ? that.$.tableContainer.lastElementChild.offsetHeight : 0, pagerHeight = that.$.pager.offsetHeight, scrollableHeight = container.clientHeight - (filterHeaderHeight + frozenHeaderHeight + frozenFooterHeight + pagerHeight); targetScrollTop += cell.offsetHeight; if (targetScrollTop > currentScrollTop + scrollableHeight) { that.$.container.scrollTop = targetScrollTop - scrollableHeight; } } if (cell.classList.contains('freeze-near') || cell.classList.contains('freeze-far')) { return; } // horizontal scroll to const currentScrollLeft = container.scrollLeft, firstRow = that.$.tableContainer.querySelector('tr[row-id]'); let targetScrollLeft = cell.offsetLeft, frozenNearWidth = 0; Array.from(firstRow.children).forEach(td => { if (td.classList.contains('freeze-near')) { frozenNearWidth += td.offsetWidth; } }); targetScrollLeft -= frozenNearWidth; if (targetScrollLeft < currentScrollLeft) { container.scrollLeft = targetScrollLeft; } else { const scrollableWidth = container.clientWidth; targetScrollLeft += cell.offsetWidth + frozenNearWidth; if (targetScrollLeft > currentScrollLeft + scrollableWidth) { that.$.container.scrollLeft = targetScrollLeft - scrollableWidth; } } } /** * tableContainer keydown handler. */ _tableContainerKeydownHandler(event) { const that = this, key = event.key, focusedCell = that._focusedCell; if (!focusedCell) { return; } const isGroupHeader = focusedCell.classList.contains('group-header'); if (isGroupHeader && ['ArrowRight', 'ArrowLeft', 'Home', 'End', ' ', 'Escape', 'F2'].indexOf(key) !== -1) { event.preventDefault(); return; } if (that._editing) { switch (key) { case 'Enter': that.endEdit(); break; case 'Escape': that.cancelEdit(); break; default: return; } that.$.tableContainer.focus(); event.preventDefault(); return; } const row = focusedCell.parentElement; let nextArrow = 'ArrowRight', prevArrow = 'ArrowLeft'; if (that.rightToLeft) { nextArrow = 'ArrowLeft'; prevArrow = 'ArrowRight'; } switch (key) { case nextArrow: that._focusCell(focusedCell.nextElementSibling, true); break; case prevArrow: that._focusCell(focusedCell.previousElementSibling, true); break; case 'ArrowUp': { let prevRow = row.previousElementSibling; while (prevRow && (prevRow.classList.contains('lw-table-row-detail') || prevRow.classList.contains('collapsed'))) { prevRow = prevRow.previousElementSibling; } if (prevRow) { if (isGroupHeader) { that._focusCell(prevRow.querySelector('td[data-field], .group-header'), true); } else { that._focusCell(prevRow.querySelector(`td[data-field="${focusedCell.getAttribute('data-field')}"], .group-header`), true); } } break; } case 'ArrowDown': { let nextRow = row.nextElementSibling; while (nextRow && (nextRow.classList.contains('lw-table-row-detail') || nextRow.classList.contains('collapsed'))) { nextRow = nextRow.nextElementSibling; } if (nextRow) { if (isGroupHeader) { that._focusCell(nextRow.querySelector('td[data-field], .group-header'), true); } else { that._focusCell(nextRow.querySelector(`td[data-field="${focusedCell.getAttribute('data-field')}"], .group-header`), true); } } break; } case 'Home': that._focusCell(row.querySelector('td[data-field]'), true); break; case 'End': { const cellsOnRow = row.querySelectorAll('td[data-field]'); that._focusCell(cellsOnRow[cellsOnRow.length - 1], true); break; } case 'PageDown': that._pageDownHandler(focusedCell);// to test with filtering/paging with scrolling break; case 'PageUp': that._pageUpHandler(focusedCell);// to test with filtering/paging with scrolling break; case 'Enter': { const data = row.data; if (that.dataSource.boundHierarchy && that._areChildrenFiltered(data)) { that._hierarchyArrowClickHandler(row); } else if (that.rowDetailTemplate) { that._toggleRowDetail(row, data.$.id); } break; } case ' ': that._toggleSelection(row, row.data.$.id); break; case 'F2': that.beginEdit(row.data.$.id, focusedCell.getAttribute('data-field')); break; default: return; } event.preventDefault(); } /** * Handles PageDown navigation. */ _pageDownHandler(focusedCell) { const that = this, paging = that.paging; if (!paging && focusedCell.parentElement === focusedCell.parentElement.parentElement.lastElementChild) { return; } const container = that.$.container; let dataField = focusedCell.getAttribute('data-field'); dataField = dataField ? `="${dataField}"` : ''; function getLastCellInView() { const rows = that.$.tableContainer.querySelectorAll('tr[row-id]'); let correction = that.$.header.offsetHeight + that.$.pager.offsetHeight; if (that.footerRow && that.freezeFooter) { correction += that.$.tableContainer.lastElementChild.offsetHeight; } for (let i = rows.length - 1; i >= 0; i--) { const currentRow = rows[i]; if (currentRow.classList.contains('collapsed')) { continue; } if (currentRow.offsetTop + currentRow.offsetHeight <= container.scrollTop + container.clientHeight - correction) { return currentRow.querySelector(`td[data-field${dataField}], .group-header`); } } } let lastCellInView = getLastCellInView(); if (!lastCellInView) { return; } if (focusedCell === lastCellInView) { container.scrollTop += container.clientHeight; lastCellInView = getLastCellInView(); if (paging && focusedCell === lastCellInView) { const oldPageIndex = that.pageIndex; that.navigateTo(that.pageIndex + 1); if (that.pageIndex !== oldPageIndex) { that._focusCell(that.$.tableContainer.querySelector(`td[data-field${dataField}], .group-header`), true); } } else { that._focusCell(lastCellInView); } } else { that._focusCell(lastCellInView); } } /** * Handles PageUp navigation. */ _pageUpHandler(focusedCell) { const that = this; const container = that.$.container; let dataField = focusedCell.getAttribute('data-field'); dataField = dataField ? `="${dataField}"` : ''; function getFirstCellInView() { const rows = that.$.tableContainer.querySelectorAll('tr[row-id]'); let correction = 0; if (that.freezeHeader) { correction = that.$.tableContainer.firstElementChild.offsetHeight; } for (let i = 0; i < rows.length; i++) { const currentRow = rows[i]; if (currentRow.classList.contains('collapsed')) { continue; } if (currentRow.offsetTop >= container.scrollTop + correction) { return currentRow.querySelector(`td[data-field${dataField}], .group-header`); } } } let firstCellInView = getFirstCellInView(); if (!firstCellInView) { return; } if (focusedCell === firstCellInView) { container.scrollTop -= container.clientHeight; firstCellInView = getFirstCellInView(); if (that.paging && focusedCell === firstCellInView) { const oldPageIndex = that.pageIndex; that.navigateTo(that.pageIndex - 1); if (that.pageIndex !== oldPageIndex) { const allCellsInColumn = that.$.tableContainer.querySelectorAll(`td[data-field${dataField}], .group-header`); that._focusCell(allCellsInColumn[allCellsInColumn.length - 1], true); } } else { that._focusCell(firstCellInView); } } else { that._focusCell(firstCellInView); } } /** * tableContainer keyup handler. */ _tableContainerKeyupHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.composedPath()[0] : event.target; if (target.classList.contains('filter-value') && target.type !== 'date') { clearTimeout(that._filterRowTimeout); that._filterRowTimeout = setTimeout(function () { const oldContext = that.context; that.context = that; that._applyRowFilters(); that.context = oldContext; }, 500); } } /** * Document down handler. */ _documentDownHandler(event) { const that = this, target = that.isInShadowDOM || that.shadowRoot ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that._editing && !target.closest('.lw-table-editor')) { const dropDown = target.closest('.lw-drop-down') if (!dropDown) { that.endEdit(); return; } const ownerElement = dropDown.ownerElement; if (!ownerElement) { that.endEdit(); return; } if (that.$.container.contains(ownerElement) && ownerElement.classList.contains('lw-table-editor')) { return; } that.endEdit(); return; } if (that.columnReorder) { const th = target.closest('th[data-field]'); if (th && that.$.tableContainer.contains(th)) { that._dragDetails = { FeedbackShown: false, Item: th, StartPosition: { left: event.pageX, top: event.pageY }, StartTime: new Date() }; } } } /** * document move handler. */ _documentMoveHandler(event) { const that = this, dragDetails = that._dragDetails; if (!dragDetails) { return; } if (!dragDetails.FeedbackShown) { const now = new Date(), timePassed = now.getTime() - dragDetails.StartTime.getTime() > 500, moved = Math.abs(dragDetails.StartPosition.left - event.pageX) > 5 || Math.abs(dragDetails.StartPosition.top - event.pageY) > 5; if (moved && (!that._isMobile || that._isMobile && timePassed)) { that._hideBodyOverflow(); dragDetails.Feedback = that._addDragFeedback(); dragDetails.FeedbackShown = true; dragDetails.Item.classList.add('dragged'); that.classList.add('lw-unselectable'); } else { if (that._isMobile && moved && !timePassed) { delete that._dragDetails; } return; } } const container = that.$.container; dragDetails.Feedback.style.left = event.pageX + 10 + 'px'; dragDetails.Feedback.style.top = event.pageY + 10 + 'px'; if (dragDetails.HoveredItem) { dragDetails.HoveredItem.classList.remove('drop-target', 'left', 'right'); delete dragDetails.HoveredItem; } if (container.offsetWidth < container.scrollWidth) { clearInterval(that._dragInterval); that._dragInterval = setInterval(function () { const rect = container.getBoundingClientRect(); if (rect.left <= event.clientX && rect.left + rect.width >= event.clientX) { if (event.clientX >= rect.left && event.clientX <= rect.left + 20) { container.scrollLeft -= that._autoScrollCoefficient; } else if (event.clientX >= rect.left + rect.width - 20 && event.clientX <= rect.left + rect.width) { container.scrollLeft += that._autoScrollCoefficient; } else { clearInterval(that._dragInterval); } } else { clearInterval(that._dragInterval); } }, 10); } const hoveredItem = that._getClosestThToHover(event); if (hoveredItem) { hoveredItem.classList.add('drop-target'); dragDetails.HoveredItem = hoveredItem; } } /** * Hides body overflow. */ _hideBodyOverflow() { const that = this, isVerticalScrollable = (document.scrollingElement || document.documentElement).scrollHeight > document.documentElement.clientHeight, isHorizontalScrollable = (document.scrollingElement || document.documentElement).scrollWidth > document.documentElement.clientWidth; that._originalBodyOverflow = { overflowX: document.body.style.overflowX, overflowY: document.body.style.overflowY, overflow: document.body.style.overflow }; document.body.classList.add('lw-dragging'); document.body.style.overflow = document.body.style.overflowX = document.body.style.overflowY = ''; if (isVerticalScrollable && !isHorizontalScrollable) { document.body.style.overflowX = 'hidden'; } else if (isHorizontalScrollable && !isVerticalScrollable) { document.body.style.overflowY = 'hidden'; } else if (!isHorizontalScrollable && !isVerticalScrollable) { document.body.style.overflow = 'hidden'; } } /** * Adds drag feedback. */ _addDragFeedback() { const that = this, draggedItem = that._dragDetails.Item, feedback = document.createElement('div'); feedback.className = 'lw-table-feedback'; feedback.setAttribute('parent-table-id', that.id); feedback.innerHTML = that._columns.find(col => col.dataField === draggedItem.getAttribute('data-field')).label; if (that.theme) { feedback.setAttribute('theme', that.theme); } document.body.appendChild(feedback); return feedback; } /** * Gets the closest th element to hover. */ _getClosestThToHover(event) { const that = this, x = event.clientX, headerCellElements = Array.from(that.$.tableContainer.querySelectorAll('th[data-field]')); let closest, closestDistance, side; headerCellElements.forEach(currentCell => { if (!currentCell || this._dragDetails.Item === currentCell) { return; } const rect = currentCell.getBoundingClientRect(), leftDistance = Math.abs(x - rect.left), rightDistance = Math.abs(x - rect.right), bestHorizontalDistance = Math.min(leftDistance, rightDistance); if (closestDistance === undefined || bestHorizontalDistance < closestDistance) { closest = currentCell; closestDistance = bestHorizontalDistance; side = leftDistance < rightDistance ? 'left' : 'right'; } }); if (closest) { closest.classList.add(side); } return closest; } /** * Document up handler. */ _documentUpHandler() { const that = this, dragDetails = that._dragDetails; if (!dragDetails) { return; } delete that._dragDetails; if (!dragDetails.FeedbackShown) { return; } const hoveredItem = dragDetails.HoveredItem; document.body.classList.remove('lw-dragging'); document.body.style.overflow = that._originalBodyOverflow.overflow; document.body.style.eoverflowX = that._originalBodyOverflow.overflowX; document.body.style.overflowY = that._originalBodyOverflow.overflowY; delete that._originalBodyOverflow; that.classList.remove('lw-unselectable'); dragDetails.Item.classList.remove('dragged'); document.body.removeChild(dragDetails.Feedback); clearInterval(that._dragInterval); delete that._dragInterval; if (!hoveredItem) { return; } const rightToLeft = that.rightToLeft, originalColumns = that._columns, originDataField = dragDetails.Item.getAttribute('data-field'), originColumn = originalColumns.find(col => col.dataField === originDataField), targetDataField = hoveredItem.getAttribute('data-field'), dropAfter = hoveredItem.classList.contains('right'); let newColumns = that._columns.filter(col => col.dataField !== originDataField); const index = newColumns.findIndex(col => col.dataField === targetDataField); hoveredItem.classList.remove('drop-target', 'left', 'right'); if (index === newColumns.length - 1) { newColumns.push(originColumn); } else if (dropAfter && !rightToLeft || !dropAfter && rightToLeft) { newColumns.splice(index + 1, 0, originColumn); } else { newColumns.splice(index, 0, originColumn); } if (originalColumns.map(col => col.dataField).join(',') === newColumns.map(col => col.dataField).join(',')) { // new column order is the same as old one return; } that.columns = newColumns; that._initColumns(); that.refresh(); } /** * Applies filters from filter row. */ _applyRowFilters() { const that = this; if (!that.filtering || !that.filterRow) { return; } const filterRow = that.$.tableContainer.querySelector('.lw-table-filter-row'), selectionColumnCorrection = that.selection ? 1 : 0, filters = []; for (let i = 0; i < that._columns.length; i++) { const dataField = that._columns[i].dataField, dataType = that._columns[i].dataType, container = filterRow.children[i + selectionColumnCorrection].firstElementChild, button = container.children[2]; let filterValue = container.firstElementChild.value, filterCondition = container.children[1].value; if (dataType === 'string') { filterCondition = that._filterInfo.stringConditions.find(condition => condition.label === filterCondition).value; } else { filterCondition = that._filterInfo.numberAndDateConditions.find(condition => condition.label === filterCondition).value; if (filterValue !== '') { if (dataType === 'number') { filterValue = parseFloat(filterValue); if (isNaN(filterValue)) { container.firstElementChild.value = ''; filterValue = ''; } } else if (dataType === 'date') { filterValue = new Date(filterValue); filterValue.setHours(0, 0, 0); } } } const conditionWithEmptyValue = ['EMPTY', 'NOT_EMPTY', 'NULL', 'NOT_NULL'].indexOf(filterCondition) !== -1; if (filterValue !== '' || conditionWithEmptyValue) { const filterGroup = new LW.Utilities.FilterGroup(), filterObject = filterGroup.createFilter(dataType, filterValue, filterCondition); filterGroup.addFilter('or', filterObject); filters.push([dataField, filterGroup]); button.classList.remove('lw-hidden'); } else { button.classList.add('lw-hidden'); } if (conditionWithEmptyValue) { container.firstElementChild.setAttribute('disabled', true); } else { container.firstElementChild.removeAttribute('disabled'); } } if (filters.length > 0) { if (!that.dataSource.virtualDataSource) { that.dataSource._filter(filters, 'and'); } that._filterInfo.rowFilters = filters; delete that._filterInfo.appliedFilters; that._fullRefresh('filter'); that.$.fireEvent('filter', { action: 'add', filters: filters }); } else if (that._filterInfo.rowFilters) { that.clearFilters(); } } /** * Clears filter input value. */ _clearFilterInput() { const that = this; that._filterInfo.query = ''; delete that._filterInfo.inputFilters; that.$.filterInput.value = ''; } /** * Clears filter row UI. */ _clearRowFilters() { const that = this; if (!that._filterInfo.rowFilters) { return; } const filterRow = that.$.tableContainer.querySelector('.lw-table-filter-row'), selectionColumnCorrection = that.selection ? 1 : 0; for (let i = 0; i < that._columns.length; i++) { const container = filterRow.children[i + selectionColumnCorrection].firstElementChild; container.firstElementChild.value = ''; container.children[2].classList.add('lw-hidden'); } delete that._filterInfo.rowFilters; } /** * Creates the Table's footer row. */ _createFooterRow(existingFooter) { const that = this, footerRow = that.footerRow; if (!footerRow) { return; } if (existingFooter) { that.$.tableContainer.appendChild(existingFooter); return; } const potentialHTMLTemplate = document.getElementById(footerRow); if (potentialHTMLTemplate && potentialHTMLTemplate instanceof HTMLTemplateElement) { const tfoot = document.createElement('tfoot'), templateContent = document.importNode(potentialHTMLTemplate.content, true); tfoot.appendChild(templateContent); that.$.tableContainer.appendChild(tfoot); } else { that.footerRow = null; } } /** * Creates the Table's custom header row. */ _createCustomHeaderRow() { const that = this, headerRow = that.headerRow; if (!headerRow) { return; } const potentialHTMLTemplate = document.getElementById(headerRow); if (potentialHTMLTemplate && potentialHTMLTemplate instanceof HTMLTemplateElement) { const templateContent = document.importNode(potentialHTMLTemplate.content, true); that.$.tableContainer.firstElementChild.appendChild(templateContent); } else { that.headerRow = null; } } /** * Updates the state of the "Select all" checkbox. */ _updateSelectAllState(dataSourceLength) { const that = this, selectedIdsLength = that._selectedIds.length, selectAllCheckboxTd = that.$.tableContainer.querySelector('.lw-table-select-all'); if (dataSourceLength === undefined) { dataSourceLength = that.dataSource.length; } if (selectedIdsLength === 0) { selectAllCheckboxTd.classList.remove('selected', 'indeterminate'); } else if (selectedIdsLength === dataSourceLength) { selectAllCheckboxTd.classList.remove('indeterminate'); selectAllCheckboxTd.classList.add('selected'); } else { selectAllCheckboxTd.classList.remove('selected'); selectAllCheckboxTd.classList.add('indeterminate'); } } /** * resize handler. */ _resizeHandler() { const that = this; that._handleFrozenColumnPositions(); } /** * Expand/collapse arrow click handler. */ _hierarchyArrowClickHandler(groupHeader) { const that = this, animation = that.animation !== 'none', tableContainer = that.$.tableContainer, groupData = groupHeader.data; function expandChildren(siblings) { siblings.forEach(child => { const childRow = tableContainer.querySelector(`tr[row-id="${child.$.id}"]`); if (childRow) { if (animation) { childRow.classList.add('no-height'); childRow.ontransitionend = function () { childRow.classList.remove('no-height'); childRow.ontransitionend = null; } } childRow.removeAttribute('aria-hidden'); childRow.classList.remove('collapsed'); } if (child.children && child.expanded) { expandChildren(child.children); } }); } function collapseChildren(siblings) { siblings.forEach(child => { const childRow = tableContainer.querySelector(`tr[row-id="${child.$.id}"]`); if (childRow) { childRow.setAttribute('aria-hidden', true); childRow.classList.add('collapsed'); } if (child.children) { collapseChildren(child.children); } }); } if (groupData.expanded) { collapseChildren(groupData.children); } else { expandChildren(groupData.children); } groupData.expanded = !groupData.expanded; groupHeader.setAttribute('aria-expanded', groupData.expanded); groupHeader.classList.toggle('expanded', groupData.expanded); } /** * Gets a group by its hierarchical index. */ _getGroupByIndex(index) { const that = this; if (typeof index === 'number') { index = index.toString(); } const boundHierarchy = that.dataSource.boundHierarchy, indexes = index.split('.'); let group = boundHierarchy[indexes[0]]; if (!group) { return; } for (let i = 1; i < indexes.length; i++) { group = group.children[indexes[i]]; if (!group || group.leaf) { return; } } return group; } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * ColorPanel custom element. */ LW('lw-color-panel', class ColorPanel extends LW.BaseElement { // ColorPanel's properties. static get properties() { return { 'applyValueMode': { value: 'instantly', allowedValues: ['instantly', 'useButtons'], type: 'string' }, 'columnCount': { value: 8, type: 'number?' }, 'displayMode': { value: 'default', allowedValues: ['default', 'grid', 'palette', 'radial', 'hexagonal', 'spectrumGrid', 'materialGrid'], type: 'string' }, 'disableUndo': { value: false, type: 'boolean' }, 'editAlphaChannel': { value: false, type: 'boolean' }, 'enableCustomColors': { value: false, type: 'boolean' }, 'gridThemeColors': { value: null, type: 'array?', reflectToAttribute: false }, 'gridShadeColors': { value: null, type: 'array?', reflectToAttribute: false }, 'gridStandardColors': { value: null, type: 'array?', reflectToAttribute: false }, 'hideAlphaEditor': { value: false, type: 'boolean' }, 'hideContentToFit': { value: ['RGB', 'HEX', 'alpha', 'previewContainer'], type: 'array' }, 'hideHEXEditor': { value: false, type: 'boolean' }, 'hidePreviewContainer': { value: false, type: 'boolean' }, 'hideRGBEditor': { value: false, type: 'boolean' }, 'inverted': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'redPrefix': 'R:', 'greenPrefix': 'G:', 'bluePrefix': 'B:', 'hexPrefix': '#:', 'alphaPrefix': 'Alpha:', 'ok': 'OK', 'cancel': 'CANCEL', 'customColor': 'CUSTOM COLOR', 'standardColors': 'Standard colors', 'themeColors': 'Theme colors' } }, type: 'object', extend: true }, 'name': { value: '', type: 'string' }, 'palette': { value: 'default', allowedValues: ['default', 'gray', 'red', 'green', 'blue', 'custom'], type: 'string' }, 'paletteColors': { value: null, type: 'array?', reflectToAttribute: false }, 'paletteCustomColors': { value: null, type: 'array?', reflectToAttribute: false }, 'tooltipDisplayMode': { value: 'hex', allowedValues: ['none', 'rgba', 'rgb', 'hex'], type: 'string' }, 'value': { value: null, type: 'string?' }, 'valueFormat': { value: 'default', allowedValues: ['rgb', 'rgba', 'hex', 'default'], type: 'string' }, 'valueMember': { value: 'value', type: 'string?' } }; } /** * ColorPanel's event listeners. */ static get listeners() { return { 'container.click': '_containerClickHandler', 'container.mouseover': '_handleGridModeCellHover', 'paletteModeContainer.down': '_paletteDownHandler', 'container.change': '_handleInputChange', 'document.move': '_moveThumbHandler', 'document.up': '_releaseThumbUpHandler', 'paletteModeContainer.wheel': '_inputWheelHandler', 'resize': '_hideControlsByPriority', //NOTE: The size of the hexagon is determines by size of a color-sample span element. It's size is set via CSS variable 'hexModeResizeTrigger.resize': '_resizeHoneycombItems', //NOTE: iOS fix. iOS doesn't support CSS prop 'touch-action: none' 'paletteModeContainer.move': '_paletteModeContainerMoveHandler' }; } /** * Checks for missing modules. */ static get requires() { return { 'LW.Utilities.Draw': 'lw.draw.js', 'LW.Button': 'lw.button.js', 'LW.Tooltip': 'lw.tooltip.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.button.css', 'lw.tooltip.css', 'lw.colorpanel.css' ] } /** * DropDownButton's HTML template. */ template() { return `<div id="container" role="presentation"> <div id="gridModeContainer" class="grid-mode-container" role="presentation"></div> <div id="paletteModeContainer" class="palette-mode-container" role="presentation"> <div id="colorPaletteContainer" class="color-palette-container" role="presentation"> <div id="colorPalette" class="color-palette no-touch" aria-label="Color palette"> <div id="colorPaletteThumb" class="color-palette-thumb" role="presentation"></div> </div> <div id="hueScale" class="hue-scale no-touch" aria-label="Hue scale" role="slider" aria-valuemin="0" aria-valuemax="360"> <div id="hueScaleThumb" class="hue-scale-thumb" role="presentation"></div> </div> <div id="colorPaletteRadial" class="color-palette-radial no-touch" aria-label="Radial color palette"> <span class="white-radial-gradient" role="presentation"></span> <div id="colorPaletteRadialThumb" class="color-palette-radial-thumb" role="presentation"></div> </div> <div id="colorPaletteHexagonal" class="color-palette-hexagonal" aria-label="Hexagonal color palette"></div> <div id="brightnessScale" class="brightness-scale no-touch" aria-label="Brightness scale" role="slider" aria-valuemin="0" aria-valuemax="1"> <div id="brightnessScaleThumb" class="brightness-scale-thumb" role="presentation"></div> </div> <span id="hexModeResizeTrigger" class="color-sample hex-mode-resize-trigger"></span> <div id="colorControlsContainer" class="color-controls-container" role="presentation"></div> </div> <div id="alphaChannelContainer" class="alpha-channel-container"></div> </div> <div id="buttonsContainer" class="buttons-container"></div> <input id="hiddenInput" type="hidden" name="[[name]]"> </div>`; } /** * Updates the ColorPanel when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'applyValueMode': if (newValue === 'instantly' && !that.value) { that._HSV = { h: 0, s: 0, v: 1 }; if (that._selectedItem && that._selectedItem.classList.contains('selected')) { that._selectedItem.classList.remove('selected'); that._selectedItem.removeAttribute('aria-current'); that._selectedItem.style.stroke = null; } } if (that.displayMode === 'palette' || that.displayMode === 'radial' || that.displayMode === 'hexagonal') { that._handleCancelButtonClick(); } if (newValue === 'useButtons') { that._createApplyValueButtons(); } break; case 'paletteColors': that._customPalette = that._mapDataSourceToPalette(); updateDisplayMode(that.displayMode); break; case 'inverted': { if (['hexagonal', 'radial', 'spectrumGrid'].indexOf(that.displayMode) === -1) { return; } const previousValue = that.value, hueScaleThumbHeight = that.$.hueScaleThumb.offsetHeight, brightness = that._validateInRange(hueScaleThumbHeight / 2, 0, that.$.hueScale.offsetHeight - hueScaleThumbHeight) / that.$.brightnessScale.offsetHeight; if (isNaN(brightness)) { that._generateGridStructures(); return; } if (newValue) { that._HSV.v = that._HSV.s; that._HSV.s = 1 - brightness; } else { that._HSV.s = that._HSV.v; that._HSV.v = 1 - brightness; } that.value = that._HSVtoRGBA(that._HSV); that.$.colorPaletteRadial.style.setProperty('--lw-color-panel-brightness', (that.$.brightnessScaleThumb.s || 0)); updateDisplayMode(that.displayMode); if (that.value !== previousValue) { that.$.fireEvent('change', { 'oldValue': previousValue, 'value': that.value }); } break; } case 'palette': updateDisplayMode(that.displayMode); that._updatePreviewContainerValues(that.value); break; case 'displayMode': case 'gridThemeColors': case 'gridShadeColors': case 'gridStandardColors': if (propertyName === 'displayMode') { const previousValue = that.value; if (that.$.container.className.indexOf('custom-color-selection') > -1) { //that._handleOkButtonClick(); that._handleCancelButtonClick(); } if (that.value !== null && newValue !== 'palette' && newValue !== 'hexagonal' && newValue !== 'radial') { if (!that.editAlphaChannel && that.$.alphaChannelThumb) { that.$.alphaChannelThumb.style[that.rightToLeft ? 'left' : 'right'] = ''; that.$.alphaChannelThumb.style[that.rightToLeft ? 'right' : 'left'] = 0; that.$.alphaChannelThumb.a = that._RGBA.a = 1; that.$.alphaChannelScale.setAttribute('aria-valuenow', 1); } that.value = that._getValue(that.valueFormat); updateDisplayMode(); that.$.fireEvent('change', { 'oldValue': previousValue, 'value': that.value }); break; } if (that.value === null && (newValue === 'palette' || newValue === 'hexagonal' || newValue === 'radial')) { that._RGBA = { r: 255, g: 255, b: 255, a: 1 }; that._HSV = { h: 0, s: 0, v: 1 } that.value = that._getValue(that.valueFormat); updateDisplayMode(); that.$.fireEvent('change', { 'oldValue': previousValue, 'value': that.value }); break; } that.value = that._getValue(that.valueFormat); if (LW.Utilities.Core.Browser.Firefox && oldValue === 'radial') { const canvas = that.$.colorPaletteRadial.querySelector('canvas'); if (canvas) { canvas.remove(); } } } updateDisplayMode(that.displayMode); break; case 'locale': case 'messages': that._localizeLabels(); break; case 'paletteCustomColors': that._userPalette = newValue || []; if (that.displayMode.toLowerCase().indexOf('grid') > -1 || that.displayMode === 'default') { that._generatePaletteUserColorGrid(true); } break; case 'editAlphaChannel': { !newValue && (that._RGBA.a = 1); if (newValue) { that._createAlphaChannel(); } if (!that.value) { return; } const previousValue = that.value; that.value = that._getValue(that.valueFormat); if (that.value !== previousValue) { that.$.fireEvent('change', { 'oldValue': previousValue, 'value': that.value }); } break; } case 'value': { newValue = typeof newValue === 'string' ? newValue.trim() : newValue; if (!that._isValidColor(newValue)) { that._reset(); return; } that._applyValue(newValue); that.value = that._getValue(that.valueFormat); if (that.displayMode === 'hexagonal') { that._generateHoneycomb(that.columnCount, that.inverted ? { s: that._HSV.s } : { v: that._HSV.v }); } if (oldValue !== that.value) { that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } break; } case 'columnCount': { const style = that.$.container.style; (newValue === null || isNaN(newValue)) ? style.removeProperty('--lw-color-panel-grid-mode-column-count') : style.setProperty('--lw-color-panel-grid-mode-column-count', newValue); that._generatePaletteUserColorGrid(); if (that.displayMode === 'spectrumGrid') { that._generateSpectrumGrid(parseInt(newValue)); } else if (that.displayMode === 'hexagonal') { that._generateHoneycomb(newValue, that._HSV); } } break; case 'valueFormat': { if (!that.value) { return; } const oldValue = that.value; that.value = that._getValue(newValue); that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); break; } case 'tooltipDisplayMode': if (!that.$.tooltip) { return; } if (newValue === 'none') { that.$.tooltip.close(); that.$.tooltip.disabled = true; } else { that.$.tooltip.disabled = false; } break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); if (propertyName === 'disabled') { const inputs = that.getElementsByClassName('color-input'); for (let i = 0; i < inputs.length; i++) { inputs[i][propertyName] === newValue; } } if (propertyName === 'disabled' || propertyName === 'theme' || propertyName === 'animation') { if (that.$.buttonOk) { that.$.buttonOk[propertyName] = newValue; } if (that.$.buttonCancel) { that.$.buttonCancel[propertyName] = newValue; } if (that.$.buttonCustom) { that.$.buttonCustom[propertyName] = newValue; } if (that.$.tooltip) { that.$.tooltip[propertyName] = newValue; } } break; } function updateDisplayMode() { that._generateGridStructures(); that._applyValue(that.value); } } /** * ColorPanel ready method. */ ready() { super.ready(); } render() { const that = this; that.setAttribute('role', 'dialog'); that._initializeBaseVars(); if (that.columnCount === null || isNaN(that.columnCount)) { that.$.container.style.removeProperty('--lw-color-panel-grid-mode-column-count'); } else { that.$.container.style.setProperty('--lw-color-panel-grid-mode-column-count', that.columnCount); } if (that.applyValueMode === 'useButtons') { that._createApplyValueButtons(); } if (that.editAlphaChannel) { that._createAlphaChannel(); } that._generateGridStructures(); that._localizeLabels(); //In displayMode = 'hexagonal' || 'radial' value can't be null if (!that.value && (that.displayMode === 'hexagonal' || that.displayMode === 'radial' || that.displayMode === 'palette')) { that.value = that._getValue(that.valueFormat); } that._applyValue(that.value); that._hideControlsByPriority();// if (that.enableShadowDOM) { that.appendChild(that.$.hiddenInput); } super.render(); } /** * Creates the ApplyValue buttons */ _createApplyValueButtons(createOnDemand) { const that = this; if (!createOnDemand && that.applyValueMode !== 'useButtons') { return } if (that.$.buttonsContainer.innerHTML.trim()) { return; } function createButton(type) { let button = document.createElement('lw-button'); button.classList.add(type); button.classList.add('primary'); button.rightToLeft = that.rightToLeft; button.disabled = that.disabled; button.theme = that.theme; button.animation = that.animation; that.$.buttonsContainer.appendChild(button); return button; } that.$.buttonOk = createButton('button-ok'); that.$.buttonCancel = createButton('button-cancel'); that.$.buttonOk.content = that.localize('ok'); that.$.buttonCancel.content = that.localize('cancel'); } /** * Creates the alpha channel components */ _createAlphaChannel() { const that = this; if (!that.editAlphaChannel || (that.editAlphaChannel && that.$.alphaChannelContainer.innerHTML.trim())) { return; } that.$.alphaChannelContainer.innerHTML = ` <div class="alpha-channel-scale no-touch" aria-label="Alpha channel scale" role="slider"> <div class="alpha-channel-thumb" aria-hidden="true"></div> </div> <label for="${that.id}aChannelInput" class="a-channel"></label> <input type="number" step="0.01" id="${that.id}aChannelInput" class="color-input a-channel" value="1" min="0" max="1">`; that.$.alphaChannelScale = that.$.alphaChannelContainer.querySelector('.alpha-channel-scale'); that.$.alphaChannelThumb = that.$.alphaChannelContainer.querySelector('.alpha-channel-thumb'); that.$.alphaChannelScale.setAttribute('role', 'slider'); that.$.alphaChannelScale.setAttribute('aria-valuemin', 0); that.$.alphaChannelScale.setAttribute('aria-valuemin', 1); const aChannel = that.$.alphaChannelContainer.querySelector('input'); aChannel.disabled = that.disabled; that._localizeLabels(); that._applyAlphaValue(that._RGBA.a, 'alphaScale'); } /** * Creates the components for the Grid modes */ _createGridModeComponents() { const that = this, id = that.id; let nonGridModes = ['radial', 'palette', 'hexagonal']; if (nonGridModes.indexOf(that.displayMode) > -1) { return false; } if (that.$.gridModeContainer.innerHTML.trim()) { return; } const gridModeContainer = that.$.gridModeContainer; gridModeContainer.innerHTML = ` <div id="${id}defaultSamplesContainer" class="default-samples-container"></div> <div id="${id}gridSamplesContainer" class="grid-samples-container"></div> <div id="${id}materialGridSamplesContainer" class="material-grid-samples-container" role="menu"></div> <div id="${id}spectrumGridSamplesContainer" class="spectrum-grid-samples-container"></div> <lw-button id="${id}buttonCustom" class="button-custom-color primary"></lw-button> <div id="${id}userSamplesContainer" class="user-samples-container" aria-label="User colors"></div> <lw-tooltip id="${id}tooltip" arrow position="auto"></lw-tooltip>`; that.$.defaultSamplesContainer = gridModeContainer.querySelector('.default-samples-container'); that.$.gridSamplesContainer = gridModeContainer.querySelector('.grid-samples-container'); that.$.materialGridSamplesContainer = gridModeContainer.querySelector('.material-grid-samples-container'); //Uses addClass/removeClass that.$.materialGridSamplesContainer.$ = LW.Utilities.Extend(that.$.materialGridSamplesContainer); that.$.spectrumGridSamplesContainer = gridModeContainer.querySelector('.spectrum-grid-samples-container'); that.$.userSamplesContainer = gridModeContainer.querySelector('.user-samples-container'); that.$.buttonCustom = gridModeContainer.querySelector('lw-button'); that.$.tooltip = gridModeContainer.querySelector('lw-tooltip'); that.$.buttonCustom.disabled = that.disabled; that.$.buttonCustom.rightToLeft = that.rightToLeft; that.$.buttonCustom.animation = that.animation; that.$.buttonCustom.theme = that.theme; that.$.buttonCustom.content = that.localize('customColor'); that.$.tooltip.disabled = that.disabled || that.tooltipDisplayMode === 'none'; that.$.tooltip.rightToLeft = that.rightToLeft; that.$.tooltip.animation = that.animation; that.$.tooltip.theme = that.theme; } /** * Creates the components for display modes: 'hexahon', 'palette', 'radial' */ _createColorControls(createOnDemand) { const that = this, id = that.id; let nonGridModes = ['radial', 'palette', 'hexagonal']; if (!createOnDemand && nonGridModes.indexOf(that.displayMode) < 0) { return false; } const colorControlsContainer = that.$.colorControlsContainer; if (colorControlsContainer.innerHTML.trim()) { return; } colorControlsContainer.innerHTML = `<div id="${id}previewContainer" class="preview-container gradient-background" aria-label="Preview">` + '<span class="preview-container-top" aria-label="Current color"></span>' + '<span class="preview-container-bottom" aria-label="New color"></span>' + '</div>' + `<label for="${id}rChannelInput" id="${id}rChannelLabel" class="r-channel"></label>` + `<input type="number" min="0" max="255" id="${id}rChannelInput" class="color-input r-channel" value="255">` + `<label for="${id}gChannelInput" id="${id}gChannelLabel" class="g-channel"></label>` + `<input type="number" min="0" max="255" id="${id}gChannelInput" class="color-input g-channel" value="255">` + `<label for="${id}bChannelInput" id="${id}bChannelLabel" class="b-channel"></label>` + `<input type="number" min="0" max="255" id="${id}bChannelInput" class="color-input b-channel" value="255">` + `<label for="${id}hexInput" id="${id}hexLabel" class="hex"></label>` + `<input type="text" id="${id}hexInput" class="color-input hex" value="FFFFFF" maxlength="6">`; const inputs = colorControlsContainer.getElementsByClassName('color-input'); for (let i = 0; i < inputs.length; i++) { inputs[i].disabled = that.disabled; } that._localizeLabels(); } /** * Container Click Handler * @param {any} event */ _containerClickHandler(event) { const that = this; if (that.disabled || that.readonly || !event.target) { return; } if (event.target.classList.contains('color-sample')) { that._handleSampleClick(event); return; } const isButton = event.target.closest('lw-button'); if (isButton === that.$.buttonCancel) { that._handleCancelButtonClick(true); return; } if (isButton === that.$.buttonCustom) { that.$container.addClass('custom-color-selection'); that._createApplyValueButtons(true); that._createColorControls(true); //Prepare the Palette that._applyValueInPaletteMode(); that._customColorSelection = true; if (that._RGBA.a === 1 && that.$.alphaChannelThumb) { that.$.alphaChannelThumb.style[that.rightToLeft ? 'left' : 'right'] = ''; that.$.alphaChannelThumb.style[that.rightToLeft ? 'right' : 'left'] = 0; that.$.alphaChannelThumb.a = that._RGBA.a; that.$.alphaChannelScale.setAttribute('aria-valuenow', that._RGBA.a); } that.$.fireEvent('customColorSelection', { value: true }); return; } if (isButton === that.$.buttonOk) { that._handleOkButtonClick(true); return; } if (event.target === (that.shadowRoot || that).querySelector('.preview-container-top') && that.applyValueMode === 'useButtons' && !that.disableUndo) { that._applyValue(that.value); } } /** * Resets the colorPicker to it's initial value */ _reset(oldValue = this.value) { const that = this; that._RGBA = { r: 255, g: 255, b: 255, a: 1 }; that._HSV = { h: 0, s: 0, v: 1 }; that.$.hueScaleThumb.h = 0; that.$.colorPaletteThumb.s = 0; that.$.colorPaletteThumb.v = 1; that.$.colorPaletteRadialThumb.h = 0; that.$.colorPaletteRadialThumb.s = 0; that.$.brightnessScaleThumb.v = 1; that.$.brightnessScaleThumb.s = 0; if (that.displayMode !== 'hexagonal' && that.displayMode !== 'radial' && that.displayMode !== 'palette') { that.value = null; if (that._selectedItem && that._selectedItem.classList.contains('selected')) { that._selectedItem.classList.remove('selected'); that._selectedItem.removeAttribute('aria-current'); that._selectedItem.style.stroke = null; } } else { that.value = that._getValue(that.valueFormat); } that._applyValue(that.value); that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } /* * Handles down on color palette in 'palette' or 'radial' mode */ _handleColorPaletteDown(event) { const that = this, coord = that._getXYcoordinates(event); if (!coord) { return; } const activeThumb = (that.displayMode === 'palette' || that.displayMode === 'grid') ? that.$.colorPaletteThumb : that.$.colorPaletteRadialThumb; that._activeComponent = coord.container; if (that.displayMode === 'palette' || that.$.container.className.indexOf('custom-color-selection') > -1) { activeThumb.s = that._HSV.s = coord.x / coord.container.offsetWidth; activeThumb.v = that._HSV.v = 1 - coord.y / coord.container.offsetHeight; // When open custom colors in grid mode and click on colorPalette if (that.displayMode === 'grid') { that._moveThumbHandler(event, true); that._applyValueInPaletteMode(event); return; } } else if (that.displayMode === 'radial') { const diameter = that.$.colorPaletteRadial.offsetWidth, dx = coord.x - diameter / 2, dy = coord.y - diameter / 2; activeThumb.h = that._HSV.h = that._calcHueAngle(dx, dy) < 0 ? 360 + that._calcHueAngle(dx, dy) : that._calcHueAngle(dx, dy); const brightnessScaleThumb = that.$.brightnessScaleThumb, brightnessScale = that.$.brightnessScale, value = that._validateInRange(2 * that._calcSatDistance(dx, dy) / diameter, 0, 1), maxScale = brightnessScale.offsetHeight - brightnessScaleThumb.offsetHeight, brightness = that._validateInRange(brightnessScaleThumb.offsetTop, 0, maxScale) / maxScale; if (that.inverted) { activeThumb.v = that._HSV.v = value; activeThumb.s = that._HSV.s = 1 - brightness; } else { activeThumb.s = that._HSV.s = value; activeThumb.v = that._HSV.v = 1 - brightness; } } that._applyValue(that._HSVtoRGBA(that._HSV), event); that._instantUpdate(); } /* * Handles down on HUE/Brightness/Alpha scales */ _handleScalesDown(event) { const that = this, coord = that._getXYcoordinates(event); if (!coord) { return; } that._activeComponent = coord.container; if (coord.container === that.$.hueScale) { that._updateHueScale(coord); } else if (coord.container === that.$.brightnessScale) { that._updateBrightnessScale(coord); if (that.displayMode === 'hexagonal') { that._generateHoneycomb(that.columnCount, that._HSV); } } else if (that.$.alphaChannelScale) { that.$.alphaChannelThumb.a = that._RGBA.a = parseFloat(((coord.container.offsetWidth - coord.x) / coord.container.offsetWidth).toFixed(2)); if (that.rightToLeft) { that.$.alphaChannelThumb.a = that._RGBA.a = (1 - that._RGBA.a).toFixed(2); } that._applyAlphaValue(that._RGBA.a, 'alphaScale'); } that._applyValue(that._HSVtoRGBA(that._HSV), event); that._instantUpdate(); } /** * Updates the Brightness Scale * @param {any} coord - coordinates Object */ _updateBrightnessScale(coord) { const that = this; const thumbCenter = coord.y - that.$.brightnessScaleThumb.offsetHeight / 2, thumbMaxRange = that.$.brightnessScale.offsetHeight - that.$.brightnessScaleThumb.offsetHeight, brightness = Math.min(Math.max(parseFloat(thumbCenter), 0), parseFloat(thumbMaxRange)) / thumbMaxRange; if (that.inverted) { that.$.brightnessScaleThumb.s = that._HSV.s = 1 - brightness; } else { that.$.brightnessScaleThumb.v = that._HSV.v = 1 - brightness; } that.$.brightnessScale.setAttribute('aria-valuenow', that._HSV.v); that.$.brightnessScaleThumb.style.top = (thumbMaxRange * brightness) + 'px'; that.$.colorPaletteRadial.style.setProperty('--lw-color-panel-brightness', brightness); } /** * Update the Hue Scale * @param {any} coord */ _updateHueScale(coord) { const that = this, thumbCenter = coord.y - that.$.hueScaleThumb.offsetHeight / 2, hueHeight = that.$.hueScale.offsetHeight, thumbMaxRange = hueHeight - that.$.hueScaleThumb.offsetHeight; that.$.hueScaleThumb.h = that._HSV.h = 360 * (hueHeight - coord.y) / hueHeight; that.$.hueScale.setAttribute('aria-valuenow', that.$.hueScaleThumb.h); that.$.hueScaleThumb.style.top = (thumbMaxRange * Math.min(Math.max(parseFloat(thumbCenter), 0), parseFloat(thumbMaxRange)) / thumbMaxRange) + 'px'; } /** * paletteModeContainer move event handler. */ _paletteModeContainerMoveHandler(event) { const that = this; if (!LW.Utilities.Core.isMobile) { event.stopPropagation(); } if (event.originalEvent.type === 'touchmove' && that._dragDetails) { event.originalEvent.preventDefault(); } } /* * Calculates value, according to the x,y coordinates of pointer related to palette, HUE scale or alpha channel scale */ _moveThumbHandler(event, customColorSelect) { const that = this, pageX = event.pageX - window.pageXOffset, pageY = event.pageY - window.pageYOffset; if (that.disabled || that.readonly || !that._activeComponent || !that._dragDetails || (that._dragDetails.x === pageX && that._dragDetails.y === pageY && !customColorSelect)) { return; } const coord = that._getXYcoordinates(event); if (!coord) { return; } const containerWidth = that._activeComponent.offsetWidth, containerHeight = that._activeComponent.offsetHeight; switch (that._activeComponent) { case (that.$.colorPalette): { that.$.colorPaletteThumb.style.left = 100 * coord.x / containerWidth + '%'; that.$.colorPaletteThumb.style.top = 100 * coord.y / containerHeight + '%'; that.$.colorPaletteThumb.s = that._HSV.s = coord.x / containerWidth; that.$.colorPaletteThumb.v = that._HSV.v = 1 - coord.y / containerHeight; break; } case (that.$.colorPaletteRadial): { const diameter = containerWidth, dx = coord.x - diameter / 2, dy = coord.y - diameter / 2; that.$.colorPaletteRadialThumb.h = that._HSV.h = that._calcHueAngle(dx, dy) < 0 ? 360 + that._calcHueAngle(dx, dy) : that._calcHueAngle(dx, dy); if (that.inverted) { that.$.colorPaletteRadialThumb.v = that._HSV.v = that._validateInRange(2 * that._calcSatDistance(dx, dy) / diameter, 0, 1); } else { that.$.colorPaletteRadialThumb.s = that._HSV.s = that._validateInRange(2 * that._calcSatDistance(dx, dy) / diameter, 0, 1); } const previewContainerBottom = (that.shadowRoot || that).querySelector('.preview-container-bottom'); if (previewContainerBottom) { previewContainerBottom.style.backgroundColor = that._HSVtoRGBA(); } break; } case (that.$.hueScale): { that._updateHueScale(coord); break; } case (that.$.brightnessScale): { that._updateBrightnessScale(coord); if (that.displayMode === 'hexagonal') { that._generateHoneycomb(that.columnCount, that.inverted ? { s: that._HSV.s } : { v: that._HSV.v }); } break; } case (that.$.alphaChannelScale): { that.$.alphaChannelThumb.a = that._RGBA.a = parseFloat(((containerWidth - coord.x) / containerWidth).toFixed(2)); if (that.rightToLeft) { that.$.alphaChannelThumb.a = that._RGBA.a = (1 - that._RGBA.a).toFixed(2); } break; } } that._applyValue(that._HSVtoRGBA(that._HSV), event); that._instantUpdate(); } /* * Fires change event and updates value */ _releaseThumbUpHandler() { const that = this, hasActiveComponent = !!that._activeComponent; that._activeComponent = null; if (that.disabled || that.readonly || !hasActiveComponent) { return; } if (that._dragDetails && that._dragDetails.isPalettePressed) { return; } that._instantUpdate(); } /* * Handles only cancel button click - called from _handleButtonClick */ _handleCancelButtonClick(fireClickEvent) { const that = this, oldValue = that.value; // Unselect selected color if (that.displayMode !== 'palette' && that.displayMode !== 'radial' && that.displayMode !== 'hexagonal') { that.value = oldValue; that._HSV = that._getValue('hsv', that.value) || { h: 1, s: 0, v: 1 }; that._RGBA = that._getValue('HSVtoRGBAarray', that.value); } else { that._HSV = that._getValue('hsv', that.value) || { h: 1, s: 0, v: 1 }; that._RGBA = that._getValue('HSVtoRGBAarray', that.value); that.value = that._getValue(that.valueFormat); } that._applyValue(that.value); switch (that.displayMode) { case 'radial': that._generateRadialCanvas(); break; case 'hexagonal': that._generateHoneycomb(that.columnCount, that._HSV); break; } if (that.value === null && that._selectedItem && that._selectedItem.classList.contains('selected')) { that._selectedItem.classList.remove('selected'); that._selectedItem.removeAttribute('aria-current'); } if (oldValue !== that.value) { that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } if (that.$.container.className.indexOf('custom-color-selection') > -1) { that._applyValueInPaletteMode(); } if (fireClickEvent) { that.$.fireEvent('cancelButtonClick'); } // Main cancel if (that._customColorSelection === false) { that._updatePreviewContainerValues(that.value); // Unselect selected colors const container = that.displayMode === 'hexagonal' ? that.$.colorPaletteHexagonal : that.$.gridModeContainer; let selectedColor = container.getElementsByClassName('selected'); for (let i = 0; i < selectedColor.length; i++) { if (selectedColor[i] && (!that.value || !that._equalValues(selectedColor[i].colorCode, that.value))) { selectedColor[i].style.stroke = null; selectedColor[i].classList.remove('selected'); selectedColor[i].removeAttribute('aria-current'); } } } else { // Close the palette custom color select that.$container.removeClass('custom-color-selection'); that.$.fireEvent('customColorSelection', { value: false }); } that._customColorSelection = false; that._customTempColor = undefined; if (that.displayMode === 'palette' || that.displayMode === 'radial') { const previewContainerTop = (that.shadowRoot || that).querySelector('.preview-container-top'); if (previewContainerTop) { previewContainerTop.style.backgroundColor = that.value; } } } /* * Handles only ok button click - called from _handleButtonClick */ _handleOkButtonClick(fireClickEvent) { const that = this, oldValue = that.value; // Main ok - visible only in ApplyValueMode: 'useButtons' if ((that._customColorSelection === false) || (typeof that._customColorSelection === 'undefined')) { // Add the selected color if (that._customTempColor) { that._userPalette.unshift(that._customTempColor); that._generatePaletteUserColorGrid(); that._generateNewPalette = false; that._customTempColor = ''; } if (that.displayMode !== 'palette' && that.displayMode !== 'radial' && that.displayMode !== 'hexagonal' && (!that._selectedItem || !that._selectedItem.classList.contains('selected'))) { that.value = null; } else { that.value = that._getValue(that.valueFormat); } // If not selected value, or clicked cancel before if (that.value === null) { if (that.displayMode === 'palette') { //(that._HSVtoRGBA(that._HSV) that._applyValue(that._HSVtoRGBA(that._HSV), event); } else { // Unselect selected colors let selectedColor = that.$.gridModeContainer.getElementsByClassName('selected'); for (let i = 0; i < selectedColor.length; i++) { if (selectedColor[i]) { selectedColor[i].classList.remove('selected'); selectedColor[i].removeAttribute('aria-current'); } } } } if (oldValue !== that.value) { that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } } else { // Palette ok - instantly or use buttons const customColor = that._getValue(that.valueFormat); if (that.applyValueMode !== 'useButtons') { that.value = customColor; } // Close the palette custom color select that._userPalette.unshift(customColor); that._generatePaletteUserColorGrid(); that._customColorSelection = false; if (oldValue !== that.value) { that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } if (fireClickEvent) { that.$.fireEvent('okButtonClick', {}); } that.$container.removeClass('custom-color-selection'); return; } if (fireClickEvent) { that.$.fireEvent('okButtonClick', {}); } that._customColorSelection = false; if (that.applyValueMode !== 'useButtons' || that._equalValues(that.value, that._HSVtoRGBA())) { return; } that._updatePreviewContainerValues(that._getValue('rgba'), true); } /* * Handles changes of RGB, HEX, alpha inputs */ _handleInputChange(event) { const that = this, oldValue = that.value, target = event.target; if (that.disabled || that.readonly) { return; } event.preventDefault(); event.stopPropagation(); const isRGBInput = ['r-channel', 'g-channel', 'b-channel'].find(className => target.className.indexOf(className) > -1), isAlphaChannelInput = target.classList.contains('a-channel'); if (isRGBInput || isAlphaChannelInput) { //Validates the value of the Input target.value = isRGBInput ? Math.min(255, Math.max(0, target.value)) : Math.min(1, Math.max(0, parseFloat(target.value) || 0)); that._RGBA = that._getRGBAFromInputs(); that._HSV = that._getValue('hsv', 'rgba(' + that._RGBA.r + ', ' + that._RGBA.g + ', ' + that._RGBA.b + ', ' + that._RGBA.a + ')'); } else if (target.classList.contains('hex')) { const oldValue = that.value ? that._getValue('hex') : null, testValue = '#' + target.value; if (that._isHEX(testValue)) { that._RGBA.a = 1; that._applyValue(that.editAlphaChannel ? that._toRGBA(testValue) : that._toHEX(testValue)); } else { target.value = oldValue ? oldValue.substring(1) : 'ffffff'; } } that._applyValue(that.editAlphaChannel ? that._getValue('rgba') : that._getValue('hex')); if (that.applyValueMode === 'useButtons' || that.$.container.className.indexOf('custom-color-selection') > -1) { return; } //that.value = that.editAlphaChannel ? that._getValue('rgba') : that._getValue('hex'); that.value = that._getValue(that.valueFormat); that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } /* * Apply the value according to selected grid mode */ _applyValue(value, event) { const that = this; if ((!value) || (value === null) || value === 'rgba(NaN, NaN, NaN, 1)') { that._RGBA = { r: 255, g: 255, b: 255, a: 1 }; that.$.hiddenInput.value = that.value; return; } that._HSVRGBArefresh(value.trim()); if (that.displayMode === 'palette' || that.$.container.className.indexOf('custom-color-selection') > -1) { that._applyValueInPaletteMode(event); } else if (that.displayMode === 'radial') { that._applyValueInRadialMode(event); } else if (that.displayMode === 'hexagonal') { that._applyValueInHexagonalMode(event); } else { that._applyValueInAnyGridMode(value.trim()); } that._applyAlphaValue(that._RGBA.a); that.$.hiddenInput.value = that.value; } /* * Applies allpha value to alpha input, alpha scale, preview box etc. * Vendor can be changed value (default option), alpha scale, alpha input, */ _applyAlphaValue(value, vendor) { const that = this; //value = that._toFixed(value); value = parseFloat(value); if (that.$.alphaChannelScale) { if (vendor !== 'alphaScale') { const thumbWidth = that.$.alphaChannelThumb.offsetWidth, scaleWidth = that.$.alphaChannelScale.offsetWidth, offset = (((1 - value) * scaleWidth) > thumbWidth) ? ((1 - value) * thumbWidth) : 0; that.$.alphaChannelThumb.style[that.rightToLeft ? 'left' : 'right'] = ''; that.$.alphaChannelThumb.style[that.rightToLeft ? 'right' : 'left'] = ((1 - value) * scaleWidth - offset) + 'px'; } if (vendor !== 'alphaInput') { const aInput = that.$.alphaChannelContainer.querySelector('input.a-channel'); aInput.value = value; } that.$.alphaChannelScale.setAttribute('aria-valuenow', value); } that._RGBA.a = value; that._updatePreviewContainerValues(that._getValue('rgba')); } /* * Applies the value 'palette' displayMode */ _applyValueInPaletteMode(event) { const that = this, HEXvalue = that._getValue('hex'), scaleHeight = that.$.hueScale.offsetHeight, thumbHeight = that.$.hueScaleThumb.offsetHeight, hsvYoffsetinPX = that._HSV.h ? (scaleHeight * ((360 - that._HSV.h) / 360)) : 0, hexInput = (that.shadowRoot || that).querySelector('input.hex'); that._setRGBAToInputs(); if (hexInput) { hexInput.value = HEXvalue.substring(1); } that.$.alphaChannelContainer.style.setProperty('--lw-color-panel-alpha-channel-color', that._rgbArrayToHEX([that._RGBA.r, that._RGBA.g, that._RGBA.b, 1])); if (!that._activeComponent) { if (that.$.alphaChannelThumb) { const thumbWidth = that.$.alphaChannelThumb.offsetWidth, scaleWidth = that.$.alphaChannelScale.offsetWidth, offset = (((1 - that._RGBA.a) * scaleWidth) > thumbWidth) ? ((1 - that._RGBA.a) * thumbWidth) : 0; that.$.alphaChannelThumb.style[that.rightToLeft ? 'left' : 'right'] = ''; that.$.alphaChannelThumb.style[that.rightToLeft ? 'right' : 'left'] = ((1 - that._RGBA.a) * scaleWidth - offset) + 'px'; that.$.alphaChannelScale.setAttribute('aria-valuenow', that._RGBA.a); } that.$.hueScaleThumb.style.top = Math.max(0, Math.min(scaleHeight - thumbHeight, hsvYoffsetinPX - thumbHeight / 2)) + 'px'; that._setPalettePointerXYPosition(); } if (that._activeComponent === that.$.hueScale) { that.$.colorPalette.style.backgroundColor = that._rgbaToRGB(that._HSVtoRGBA({ h: that.$.hueScaleThumb.h, s: 1, v: 1 })); } if (!that._activeComponent || that._activeComponent === that.$.colorPalette) { that._setPalettePointerXYPosition(event); } if (that.event) { that._HSV.h = that.$.hueScaleThumb.h; } else { that.$.hueScaleThumb.h = that._HSV.h; that.$.colorPalette.style.backgroundColor = that._rgbaToRGB(that._HSVtoRGBA({ h: that._HSV.h, s: 1, v: 1 })); } that._updatePreviewContainerValues(that._getValue('rgba')); that.$.hueScale.setAttribute('aria-valuenow', that.$.hueScaleThumb.h); } /* * Applies the value 'radial' displayMode */ _applyValueInRadialMode(event) { const that = this, HEXvalue = that._getValue('hex'), hexInput = (that.shadowRoot || that).querySelector('input.hex'); that._setRGBAToInputs(); if (hexInput) { hexInput.value = HEXvalue.substring(1); } that.$.alphaChannelContainer.style.setProperty('--lw-color-panel-alpha-channel-color', that._rgbArrayToHEX([that._RGBA.r, that._RGBA.g, that._RGBA.b, 1])); if (!that._activeComponent) { const thumbMaxRange = that.$.brightnessScale.offsetHeight - that.$.brightnessScaleThumb.offsetHeight; if (that.$.alphaChannelThumb) { const thumbWidth = that.$.alphaChannelThumb.offsetWidth, scaleWidth = that.$.alphaChannelScale.offsetWidth, offset = (((1 - that._RGBA.a) * scaleWidth) > thumbWidth) ? ((1 - that._RGBA.a) * thumbWidth) : 0; that.$.alphaChannelThumb.style[that.rightToLeft ? 'left' : 'right'] = ''; that.$.alphaChannelThumb.style[that.rightToLeft ? 'right' : 'left'] = ((1 - that._RGBA.a) * scaleWidth - offset) + 'px'; that.$.alphaChannelScale.setAttribute('aria-valuenow', that._RGBA.a); } const brightness = (that.inverted ? that._HSV.v : 1 - that._HSV.v); that.$.brightnessScale.setAttribute('aria-valuenow', that._HSV.v); that.$.brightnessScaleThumb.style.top = thumbMaxRange * brightness + 'px'; that.$.colorPaletteRadial.style.setProperty('--lw-color-panel-brightness', brightness); } if (!that._activeComponent || that._activeComponent === that.$.colorPaletteRadial) { that._setPalettePointerXYPosition(event); } that._updatePreviewContainerValues(that._getValue('rgba')); if (that.inverted) { const color1 = that.value === null ? 'black' : that._HSVtoRGBA({ h: that._HSV.h, s: 1, v: that._HSV.v }); that.$.brightnessScale.style.backgroundImage = 'linear-gradient(' + color1 + ', white)'; } else { const color1 = that.value === null ? 'white' : that._HSVtoRGBA({ h: that._HSV.h, s: that._HSV.s, v: 1 }); that.$.brightnessScale.style.backgroundImage = 'linear-gradient(' + color1 + ', black)'; } } /* * Applies the value 'PaletteHexagonal' displayMode. To be renamed as 'hexagonal' mode later, and old hexagonal to be removed */ _applyValueInHexagonalMode() { const that = this, HEXvalue = that._getValue('hex'), hexInput = (that.shadowRoot || that).querySelector('input.hex'); that._setRGBAToInputs(); if (hexInput) { hexInput.value = HEXvalue ? HEXvalue.substring(1) : null; } that.$.alphaChannelContainer.style.setProperty('--lw-color-panel-alpha-channel-color', that._rgbArrayToHEX([that._RGBA.r, that._RGBA.g, that._RGBA.b, 1])); if (!that._activeComponent && !that._targetItem) { const thumbMaxRange = that.$.brightnessScale.offsetHeight - that.$.brightnessScaleThumb.offsetHeight; if (that.$.alphaChannelThumb) { const thumbWidth = that.$.alphaChannelThumb.offsetWidth, scaleWidth = that.$.alphaChannelScale.offsetWidth, offset = (((1 - that._RGBA.a) * scaleWidth) > thumbWidth) ? ((1 - that._RGBA.a) * thumbWidth) : 0; that.$.alphaChannelThumb.style[that.rightToLeft ? 'left' : 'right'] = ''; that.$.alphaChannelThumb.style[that.rightToLeft ? 'right' : 'left'] = ((1 - that._RGBA.a) * scaleWidth - offset) + 'px'; that.$.alphaChannelScale.setAttribute('aria-valuenow', that._RGBA.a); } const brightness = that.inverted ? that._HSV.v : 1 - that._HSV.v; that.$.brightnessScale.setAttribute('aria-valuenow', that._HSV.v); that.$.brightnessScaleThumb.style.top = thumbMaxRange * brightness + 'px'; } const rgbaTempValue = that._getValue('rgba'); that._updatePreviewContainerValues(rgbaTempValue ? rgbaTempValue : that._getValue('hex')); if (that.inverted) { const color1 = that._HSVtoRGBA({ h: that._HSV.h, s: 1, v: that._HSV.v }, 1); that.$.brightnessScale.style.backgroundImage = 'linear-gradient(' + color1 + ', white)'; } else { const color1 = that._HSVtoRGBA({ h: that._HSV.h, s: that._HSV.s, v: 1 }, 1); that.$.brightnessScale.style.backgroundImage = 'linear-gradient(' + color1 + ', black)'; } that._applyValueInAnyGridMode(HEXvalue, that.$.colorPaletteHexagonal);// } /* * Calculates position of the thumb, according to the given center of the circle(x,y) angle and distance from the center */ _radialThumbPoint(x, y, angle, distance) { const point = { x: Math.round(Math.cos(angle * Math.PI / 180) * distance * x + x), y: Math.round(Math.sin(angle * Math.PI / 180) * distance * x + y) }; return point; } /* * Updates preview containers background, according to current color/tempColor */ _updatePreviewContainerValues(newValue, okClick) { const that = this, previewContainer = (that.shadowRoot || that).querySelector('.preview-container'); if (!previewContainer) { return; } //Top preview Container if (that.applyValueMode === 'instantly' || okClick) { previewContainer.firstElementChild.style.backgroundColor = newValue; } //Bottom Preview Container previewContainer.lastElementChild.style.backgroundColor = newValue; } /* * Gets all color containers in current grid mode(grid, hexagonal, default, spectrumGrid); Compares */ _applyValueInAnyGridMode(value, container) { const that = this; if (!value && value !== null) { return; } if (!container) { switch (that.displayMode) { case 'default': container = that.$.defaultSamplesContainer; break; case 'grid': container = that.$.gridSamplesContainer; break; case 'materialGrid': container = that.$.materialGridSamplesContainer; break; case 'spectrumGrid': container = that.$.spectrumGridSamplesContainer; break; default: container = that.$.gridModeContainer; break; } } if (!container) { return; } const samples = Array.from(container.getElementsByClassName('color-sample')); let match = that._targetItem; //Find match by colorCode if (match === undefined || match === null) { for (let i = 0; i < samples.length; i++) { const item = samples[i]; if (that._equalValues(item.colorCode, value)) { match = samples[i]; break; } } } //Bugfix for grid mode when click custom color and slide hue scale if (that.$.container.className.indexOf('custom-color-selection') > -1 && that._HSV.h) { that._applyValueInPaletteMode(); } that._changeSampleSelection(match); } /* * Generates palette grid, according to the chosen palette type */ _generatePaletteGrid() { const that = this; if (!that.$.gridSamplesContainer) { return; } const palette = that['_' + that.palette + 'Palette']; let fragment = document.createDocumentFragment(); for (let i = 0; i < palette.length; i++) { const colorSample = document.createElement('span'), colorCode = palette[i]; colorSample.setAttribute('role', 'menuitem'); colorSample.setAttribute('aria-label', colorCode); colorSample.className = 'color-sample'; colorSample.colorCode = colorCode; colorSample.style.backgroundColor = colorCode; if (that._toRGBA(colorCode) === 'rgba(255, 255, 255, 0)' || that._toHEX(that._toRGBA(colorCode)) === '#FFFFFF00' || colorCode === 'transparent') { colorSample.setAttribute('transparent', ''); } else { colorSample.removeAttribute('transparent'); } fragment.appendChild(colorSample); } that.$.gridSamplesContainer.setAttribute('role', 'menu'); that.$.gridSamplesContainer.innerHTML = ''; that.$.gridSamplesContainer.appendChild(fragment); } /* * Generates palette grid, according to the chosen user colors (to be commbined with _generatePaletteGrid function) */ _generatePaletteUserColorGrid(noSelection) { const that = this; if (!that.$.userSamplesContainer) { return; } if (!that._userPalette || !that._userPalette.length) { that.$.userSamplesContainer.innerHTML = ''; return; } let palette = that._userPalette.filter(v => v !== '').slice(0, that.columnCount || 1), fragment = document.createDocumentFragment(); let newColor; palette = [...new Set(palette)]; for (let i = 0; i < palette.length; i++) { if (palette[i]) { const colorItem = that._createColorSample(palette[i], 'user-color'); fragment.appendChild(colorItem); if (!newColor) { newColor = colorItem; } } } that.$.userSamplesContainer.innerHTML = ''; that.$.userSamplesContainer.appendChild(fragment); that.$.userSamplesContainer.setAttribute('role', 'menu'); if (!noSelection && newColor && newColor.colorCode) { that._changeSampleSelection(newColor); } that.paletteCustomColors = that._userPalette.slice(0); } /* * Generates palette grid, according to the chosen palette type */ _initializeBaseVars() { const that = this; if (that._RGBA !== undefined) { return; } that._RGBA = { r: 255, g: 255, b: 255, a: 1 }; that._HSV = { h: 0, s: 0, v: 1 }; that.$.hueScaleThumb.h = 0; that.$.colorPaletteThumb.s = 0; that.$.colorPaletteThumb.v = 1; that.$.colorPaletteRadialThumb.h = 0; that.$.colorPaletteRadialThumb.s = 0; that._defaultPalette = [ // Palettes names to be updated according to the latest displayMode settings/options/etc. 'rgba(255, 255, 255, 0)', 'rgb(0, 0, 0)', 'rgb(153, 51, 0)', 'rgb(51, 51, 0)', 'rgb(0, 51, 0)', 'rgb(0, 51, 102)', 'rgb(0, 0, 128)', 'rgb(51, 51, 153)', 'rgb(51, 51, 51)', 'rgb(128, 0, 0)', 'rgb(255, 102, 0)', 'rgb(128, 128, 0)', 'rgb(0, 128, 0)', 'rgb(0, 128, 128)', 'rgb(0, 0, 255)', 'rgb(102, 102, 153)', 'rgb(128, 128, 128)', 'rgb(255, 0, 0)', 'rgb(255, 153, 0)', 'rgb(153, 204, 0)', 'rgb(51, 153, 102)', 'rgb(51, 204, 204)', 'rgb(51, 102, 255)', 'rgb(128, 0, 128)', 'rgb(153, 153, 153)', 'rgb(255, 0, 255)', 'rgb(255, 204, 0)', 'rgb(255, 255, 0)', 'rgb(0, 255, 0)', 'rgb(0, 255, 255)', 'rgb(0, 204, 255)', 'rgb(153, 51, 102)', 'rgb(192, 192, 192)', 'rgb(255, 153, 204)', 'rgb(255, 204, 153)', 'rgb(255, 255, 153)', 'rgb(204, 255, 204)', 'rgb(204, 255, 255)', 'rgb(153, 204, 255)', 'rgb(204, 153, 255)', 'rgb(255, 255, 255)' ]; that._grayPalette = that._generateShades(40, 'gray'); that._redPalette = that._generateShades(40, 'red'); that._greenPalette = that._generateShades(40, 'green'); that._bluePalette = that._generateShades(40, 'blue'); that._customPalette = that._mapDataSourceToPalette(); that._userPalette = that.paletteCustomColors || []; that._colorPalette = {}; that._cssColorNamesHEX = { 'aliceblue': '#f0f8ff', 'antiquewhite': '#faebd7', 'aqua': '#00ffff', 'aquamarine': '#7fffd4', 'azure': '#f0ffff', 'beige': '#f5f5dc', 'bisque': '#ffe4c4', 'black': '#000000', 'blanchedalmond': '#ffebcd', 'blue': '#0000ff', 'blueviolet': '#8a2be2', 'brown': '#a52a2a', 'burlywood': '#deb887', 'cadetblue': '#5f9ea0', 'chartreuse': '#7fff00', 'chocolate': '#d2691e', 'coral': '#ff7f50', 'cornflowerblue': '#6495ed', 'cornsilk': '#fff8dc', 'crimson': '#dc143c', 'cyan': '#00ffff', 'darkblue': '#00008b', 'darkcyan': '#008b8b', 'darkgoldenrod': '#b8860b', 'darkgray': '#a9a9a9', 'darkgreen': '#006400', 'darkkhaki': '#bdb76b', 'darkmagenta': '#8b008b', 'darkolivegreen': '#556b2f', 'darkorange': '#ff8c00', 'darkorchid': '#9932cc', 'darkred': '#8b0000', 'darksalmon': '#e9967a', 'darkseagreen': '#8fbc8f', 'darkslateblue': '#483d8b', 'darkslategray': '#2f4f4f', 'darkturquoise': '#00ced1', 'darkviolet': '#9400d3', 'deeppink': '#ff1493', 'deepskyblue': '#00bfff', 'dimgray': '#696969', 'dodgerblue': '#1e90ff', 'firebrick': '#b22222', 'floralwhite': '#fffaf0', 'forestgreen': '#228b22', 'fuchsia': '#ff00ff', 'gainsboro': '#dcdcdc', 'ghostwhite': '#f8f8ff', 'gold': '#ffd700', 'goldenrod': '#daa520', 'gray': '#808080', 'green': '#008000', 'greenyellow': '#adff2f', 'honeydew': '#f0fff0', 'hotpink': '#ff69b4', 'indianred ': '#cd5c5c', 'indigo': '#4b0082', 'ivory': '#fffff0', 'khaki': '#f0e68c', 'lavender': '#e6e6fa', 'lavenderblush': '#fff0f5', 'lawngreen': '#7cfc00', 'lemonchiffon': '#fffacd', 'lightblue': '#add8e6', 'lightcoral': '#f08080', 'lightcyan': '#e0ffff', 'lightgoldenrodyellow': '#fafad2', 'lightgrey': '#d3d3d3', 'lightgreen': '#90ee90', 'lightpink': '#ffb6c1', 'lightsalmon': '#ffa07a', 'lightseagreen': '#20b2aa', 'lightskyblue': '#87cefa', 'lightslategray': '#778899', 'lightsteelblue': '#b0c4de', 'lightyellow': '#ffffe0', 'lime': '#00ff00', 'limegreen': '#32cd32', 'linen': '#faf0e6', 'magenta': '#ff00ff', 'maroon': '#800000', 'mediumaquamarine': '#66cdaa', 'mediumblue': '#0000cd', 'mediumorchid': '#ba55d3', 'mediumpurple': '#9370d8', 'mediumseagreen': '#3cb371', 'mediumslateblue': '#7b68ee', 'mediumspringgreen': '#00fa9a', 'mediumturquoise': '#48d1cc', 'mediumvioletred': '#c71585', 'midnightblue': '#191970', 'mintcream': '#f5fffa', 'mistyrose': '#ffe4e1', 'moccasin': '#ffe4b5', 'navajowhite': '#ffdead', 'navy': '#000080', 'oldlace': '#fdf5e6', 'olive': '#808000', 'olivedrab': '#6b8e23', 'orange': '#ffa500', 'orangered': '#ff4500', 'orchid': '#da70d6', 'palegoldenrod': '#eee8aa', 'palegreen': '#98fb98', 'paleturquoise': '#afeeee', 'palevioletred': '#d87093', 'papayawhip': '#ffefd5', 'peachpuff': '#ffdab9', 'peru': '#cd853f', 'pink': '#ffc0cb', 'plum': '#dda0dd', 'powderblue': '#b0e0e6', 'purple': '#800080', 'rebeccapurple': '#663399', 'red': '#ff0000', 'rosybrown': '#bc8f8f', 'royalblue': '#4169e1', 'saddlebrown': '#8b4513', 'salmon': '#fa8072', 'sandybrown': '#f4a460', 'seagreen': '#2e8b57', 'seashell': '#fff5ee', 'sienna': '#a0522d', 'silver': '#c0c0c0', 'skyblue': '#87ceeb', 'slateblue': '#6a5acd', 'slategray': '#708090', 'snow': '#fffafa', 'springgreen': '#00ff7f', 'steelblue': '#4682b4', 'tan': '#d2b48c', 'teal': '#008080', 'thistle': '#d8bfd8', 'tomato': '#ff6347', 'turquoise': '#40e0d0', 'violet': '#ee82ee', 'wheat': '#f5deb3', 'white': '#ffffff', 'whitesmoke': '#f5f5f5', 'yellow': '#ffff00', 'yellowgreen': '#9acd32' }; that._defaultModeThemeColors = that.gridThemeColors === null ? ['#FFFFFF', '#000000', '#E6E6E6', '#495469', '#5671C2', '#D48439', '#A5A5A5', '#EEC328', '#7399D3', '#85AA4C'] : that.gridThemeColors; that._defaultModeStandardColors = that.gridStandardColors === null ? ['#A52A0D', '#DB3A15', '#EEC328', '#FEFE33', '#A6CD57', '#62AC54', '#65ADEE', '#3F6FBE', '#10205F', '#64379E'] : that.gridStandardColors; that._defaultModeShadesColors = that.gridShadeColors === null ? [ '#F2F2F2', '#808080', '#D0CECE', '#D6DCE4', '#DDEBF7', '#FCE4D6', '#EBEBEB', '#FFF2CC', '#DDE5F7', '#E2EFDA', '#D8D8D8', '#595959', '#AEAAAA', '#ACB9CA', '#BDD7EE', '#F6CAAD', '#DBDBDB', '#FFE699', '#B4C6E7', '#C6E0B4', '#BFBFBF', '#404040', '#757171', '#8497B0', '#9BC2E6', '#F4B084', '#C0C0C0', '#FFD966', '#8EA9DB', '#A9D08E', '#A6A6A6', '#262626', '#312F2F', '#333F4F', '#2F75B5', '#C65911', '#7B7B7B', '#BF8F00', '#305496', '#548235', '#808080', '#0D0D0D', '#161616', '#222B35', '#1F4E78', '#833C0C', '#525252', '#806000', '#203764', '#375623' ] : that.gridShadeColors; that._materialColors = { 'Red': { '50': 'rgb(255, 235, 238)', '100': 'rgb(255, 205, 210)', '200': 'rgb(239, 154, 154)', '300': 'rgb(229, 115, 115)', '400': 'rgb(239, 83, 80)', '500': 'rgb(244, 67, 54)', '600': 'rgb(229, 57, 53)', '700': 'rgb(211, 47, 47)', '800': 'rgb(198, 40, 40)', '900': 'rgb(183, 28, 28)', 'A 100': 'rgb(255, 138, 128)', 'A 200': 'rgb(255, 82, 82)', 'A 400': 'rgb(255, 23, 68)', 'A 700': 'rgb(213, 0, 0)' }, 'Pink': { '50': 'rgb(252, 228, 236)', '100': 'rgb(248, 187, 208)', '200': 'rgb(244, 143, 177)', '300': 'rgb(240, 98, 146)', '400': 'rgb(236, 64, 122)', '500': 'rgb(233, 30, 99)', '600': 'rgb(216, 27, 96)', '700': 'rgb(194, 24, 91)', '800': 'rgb(173, 20, 87)', '900': 'rgb(136, 14, 79)', 'A 100': 'rgb(255, 128, 171)', 'A 200': 'rgb(255, 64, 129)', 'A 400': 'rgb(245, 0, 87)', 'A 700': 'rgb(197, 17, 98)' }, 'Purple': { '50': 'rgb(243, 229, 245)', '100': 'rgb(225, 190, 231)', '200': 'rgb(206, 147, 216)', '300': 'rgb(186, 104, 200)', '400': 'rgb(171, 71, 188)', '500': 'rgb(156, 39, 176)', '600': 'rgb(142, 36, 170)', '700': 'rgb(123, 31, 162)', '800': 'rgb(106, 27, 154)', '900': 'rgb(74, 20, 140)', 'A 100': 'rgb(234, 128, 252)', 'A 200': 'rgb(224, 64, 251)', 'A 400': 'rgb(213, 0, 249)', 'A 700': 'rgb(170, 0, 255)' }, 'Deep Purple': { '50': 'rgb(237, 231, 246)', '100': 'rgb(209, 196, 233)', '200': 'rgb(179, 157, 219)', '300': 'rgb(149, 117, 205)', '400': 'rgb(126, 87, 194)', '500': 'rgb(103, 58, 183)', '600': 'rgb(94, 53, 177)', '700': 'rgb(81, 45, 168)', '800': 'rgb(69, 39, 160)', '900': 'rgb(49, 27, 146)', 'A 100': 'rgb(179, 136, 255)', 'A 200': 'rgb(124, 77, 255)', 'A 400': 'rgb(101, 31, 255)', 'A 700': 'rgb(98, 0, 234)' }, 'Indigo': { '50': 'rgb(232, 234, 246)', '100': 'rgb(197, 202, 233)', '200': 'rgb(159, 168, 218)', '300': 'rgb(121, 134, 203)', '400': 'rgb(92, 107, 192)', '500': 'rgb(63, 81, 181)', '600': 'rgb(57, 73, 171)', '700': 'rgb(48, 63, 159)', '800': 'rgb(40, 53, 147)', '900': 'rgb(26, 35, 126)', 'A 100': 'rgb(140, 158, 255)', 'A 200': 'rgb(83, 109, 254)', 'A 400': 'rgb(61, 90, 254)', 'A 700': 'rgb(48, 79, 254)' }, 'Blue': { '50': 'rgb(227, 242, 253)', '100': 'rgb(187, 222, 251)', '200': 'rgb(144, 202, 249)', '300': 'rgb(100, 181, 246)', '400': 'rgb(66, 165, 245)', '500': 'rgb(33, 150, 243)', '600': 'rgb(30, 136, 229)', '700': 'rgb(25, 118, 210)', '800': 'rgb(21, 101, 192)', '900': 'rgb(13, 71, 161)', 'A 100': 'rgb(130, 177, 255)', 'A 200': 'rgb(68, 138, 255)', 'A 400': 'rgb(41, 121, 255)', 'A 700': 'rgb(41, 98, 255)' }, 'Light Blue': { '50': 'rgb(225, 245, 254)', '100': 'rgb(179, 229, 252)', '200': 'rgb(129, 212, 250)', '300': 'rgb(79, 195, 247)', '400': 'rgb(41, 182, 246)', '500': 'rgb(3, 169, 244)', '600': 'rgb(3, 155, 229)', '700': 'rgb(2, 136, 209)', '800': 'rgb(2, 119, 189)', '900': 'rgb(1, 87, 155)', 'A 100': 'rgb(128, 216, 255)', 'A 200': 'rgb(64, 196, 255)', 'A 400': 'rgb(0, 176, 255)', 'A 700': 'rgb(0, 145, 234)' }, 'Cyan': { '50': 'rgb(224, 247, 250)', '100': 'rgb(178, 235, 242)', '200': 'rgb(128, 222, 234)', '300': 'rgb(77, 208, 225)', '400': 'rgb(38, 198, 218)', '500': 'rgb(0, 188, 212)', '600': 'rgb(0, 172, 193)', '700': 'rgb(0, 151, 167)', '800': 'rgb(0, 131, 143)', '900': 'rgb(0, 96, 100)', 'A 100': 'rgb(132, 255, 255)', 'A 200': 'rgb(24, 255, 255)', 'A 400': 'rgb(0, 229, 255)', 'A 700': 'rgb(0, 184, 212)' }, 'Teal': { '50': 'rgb(224, 242, 241)', '100': 'rgb(178, 223, 219)', '200': 'rgb(128, 203, 196)', '300': 'rgb(77, 182, 172)', '400': 'rgb(38, 166, 154)', '500': 'rgb(0, 150, 136)', '600': 'rgb(0, 137, 123)', '700': 'rgb(0, 121, 107)', '800': 'rgb(0, 105, 92)', '900': 'rgb(0, 77, 64)', 'A 100': 'rgb(167, 255, 235)', 'A 200': 'rgb(100, 255, 218)', 'A 400': 'rgb(29, 233, 182)', 'A 700': 'rgb(0, 191, 165)' }, 'Green': { '50': 'rgb(232, 245, 233)', '100': 'rgb(200, 230, 201)', '200': 'rgb(165, 214, 167)', '300': 'rgb(129, 199, 132)', '400': 'rgb(102, 187, 106)', '500': 'rgb(76, 175, 80)', '600': 'rgb(67, 160, 71)', '700': 'rgb(56, 142, 60)', '800': 'rgb(46, 125, 50)', '900': 'rgb(27, 94, 32)', 'A 100': 'rgb(185, 246, 202)', 'A 200': 'rgb(105, 240, 174)', 'A 400': 'rgb(0, 230, 118)', 'A 700': 'rgb(0, 200, 83)' }, 'Light Green': { '50': 'rgb(241, 248, 233)', '100': 'rgb(220, 237, 200)', '200': 'rgb(197, 225, 165)', '300': 'rgb(174, 213, 129)', '400': 'rgb(156, 204, 101)', '500': 'rgb(139, 195, 74)', '600': 'rgb(124, 179, 66)', '700': 'rgb(104, 159, 56)', '800': 'rgb(85,139,47)', '900': 'rgb(51,105,30)', 'A 100': 'rgb(204,255,144)', 'A 200': 'rgb(178,255,89)', 'A 400': 'rgb(118,255,3)', 'A 700': 'rgb(100, 221, 23)' }, 'Lime': { '50': 'rgb(249, 251, 231)', '100': 'rgb(255, 249, 196)', '200': 'rgb(255, 245, 157)', '300': 'rgb(255, 241, 118)', '400': 'rgb(255, 238, 88)', '500': 'rgb(255, 235, 59)', '600': 'rgb(253, 216, 53)', '700': 'rgb(251, 192, 45)', '800': 'rgb(249, 168, 37)', '900': 'rgb(245, 127, 23)', 'A 100': 'rgb(244, 255, 129)', 'A 200': 'rgb(238, 255, 65)', 'A 400': 'rgb(198, 255, 0)', 'A 700': 'rgb(174, 234, 0)' }, 'Yellow': { '50': 'rgb(255, 253, 231)', '100': 'rgb(255, 249, 196)', '200': 'rgb(255, 245, 157)', '300': 'rgb(255, 241, 118)', '400': 'rgb(255, 238, 88)', '500': 'rgb(255, 235, 59)', '600': 'rgb(253, 216, 53)', '700': 'rgb(251, 192, 45)', '800': 'rgb(249, 168, 37)', '900': 'rgb(245, 127, 23)', 'A 100': 'rgb(255, 255, 141)', 'A 200': 'rgb(255, 255, 0)', 'A 400': 'rgb(255, 234, 0)', 'A 700': 'rgb(255, 214, 0)' }, 'Amber': { '50': 'rgb(255, 248, 225)', '100': 'rgb(255, 236, 179)', '200': 'rgb(255, 224, 130)', '300': 'rgb(255, 213, 79)', '400': 'rgb(255, 202, 40)', '500': 'rgb(255, 193, 7)', '600': 'rgb(255, 179, 0)', '700': 'rgb(255, 160, 0)', '800': 'rgb(255, 143, 0)', '900': 'rgb(255, 111, 0)', 'A 100': 'rgb(255, 229, 127)', 'A 200': 'rgb(255, 215, 64)', 'A 400': 'rgb(255, 196, 0)', 'A 700': 'rgb(255, 171, 0)' }, 'Orange': { '50': 'rgb(255, 243, 224)', '100': 'rgb(255, 224, 178)', '200': 'rgb(255, 204, 128)', '300': 'rgb(255, 183, 77)', '400': 'rgb(255, 167, 38)', '500': 'rgb(255, 152, 0)', '600': 'rgb(251, 140, 0)', '700': 'rgb(245, 124, 0)', '800': 'rgb(239, 108, 0)', '900': 'rgb(230, 81, 0)', 'A 100': 'rgb(255, 209, 128)', 'A 200': 'rgb(255, 171, 64)', 'A 400': 'rgb(255, 145, 0)', 'A 700': 'rgb(255, 109, 0)' }, 'Deep Orange': { '50': 'rgb(251, 233, 231)', '100': 'rgb(255, 204, 188)', '200': 'rgb(255, 171, 145)', '300': 'rgb(255, 138, 101)', '400': 'rgb(255, 112, 67)', '500': 'rgb(255, 87, 34)', '600': 'rgb(244, 81, 30)', '700': 'rgb(230, 74, 25)', '800': 'rgb(216, 67, 21)', '900': 'rgb(191, 54, 12)', 'A 100': 'rgb(255, 158, 128)', 'A 200': 'rgb(255, 110, 64)', 'A 400': 'rgb(255, 61, 0)', 'A 700': 'rgb(221, 44, 0)' }, 'Brown': { '50': 'rgb(239, 235, 233)', '100': 'rgb(215, 204, 200)', '200': 'rgb(188, 170, 164)', '300': 'rgb(161, 136, 127)', '400': 'rgb(141, 110, 99)', '500': 'rgb(121, 85, 72)', '600': 'rgb(109, 76, 65)', '700': 'rgb(93, 64, 55)', '800': 'rgb(78, 52, 46)', '900': 'rgb(62, 39, 35)', 'A 100': '', 'A 200': '', 'A 400': '', 'A 700': '' }, 'Grey': { '50': 'rgb(250, 250, 250)', '100': 'rgb(245, 245, 245)', '200': 'rgb(238, 238, 238)', '300': 'rgb(224, 224, 224)', '400': 'rgb(189, 189, 189)', '500': 'rgb(158, 158, 158)', '600': 'rgb(117, 117, 117)', '700': 'rgb(97, 97, 97)', '800': 'rgb(66, 66, 66)', '900': 'rgb(33, 33, 33)', 'A 100': '', 'A 200': '', 'A 400': '', 'A 700': '' }, 'Blue Grey': { '50': 'rgb(236, 239, 241)', '100': 'rgb(207, 216, 220)', '200': 'rgb(176, 190, 197)', '300': 'rgb(144, 164, 174)', '400': 'rgb(120, 144, 156)', '500': 'rgb(96, 125, 139)', '600': 'rgb(84, 110, 122)', '700': 'rgb(69, 90, 100)', '800': 'rgb(55, 71, 79)', '900': 'rgb(38, 50, 56)', 'A 100': '', 'A 200': '', 'A 400': '', 'A 700': '' } }; } /* * Return color palett regarding to users color settings in dataSource property */ _mapDataSourceToPalette() { const that = this; let customPalette = []; if (!that.paletteColors || !Array.isArray(that.paletteColors) || that.paletteColors.length === 0) { return []; } for (let i = 0; i < that.paletteColors.length; i++) { let item = that.paletteColors[i]; if (typeof item === 'object' && (item[that.valueMember] && typeof item[that.valueMember] === 'string')) { item = item[that.valueMember]; } item += ''; if (that._isValidColor(item)) { customPalette.push(item); } } return customPalette; } /* * Handles click on color sample, regarding to the settings of "applyValueMode" property */ _handleSampleClick(event) { const that = this, item = event.target, oldValue = that.value; let itemColor = item.colorCode; if (that.displayMode === 'hexagonal') { itemColor = that._HSVtoRGBA({ h: item.h, s: item.s, v: item.v }, that._RGBA.a); if (that._hexagonItems.indexOf(item) > -1) { that._HSV.h = item.h; if (that.inverted) { that._HSV.s = item.s; that._HSV.v = item.v; } else { that._HSV.s = item.s that._HSV.v = item.v; } that._targetItem = item; that._applyValue(that._HSVtoRGBA(that._HSV), event); //that._instantUpdate(); delete that._targetItem; } } else { that._changeSampleSelection(item); } that._HSVRGBArefresh(item.classList.contains('selected') ? itemColor : null); if (that.applyValueMode !== 'instantly') { return; } that.$.hiddenInput.value = that.value = that._getValue(that.valueFormat, item.classList.contains('selected') ? itemColor : null); //that._updatePreviewContainerValues(that.value); if (that.value !== oldValue) { that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } } /* * Check if selected color is any of the */ _changeSampleSelection(item) { const that = this; if (that._selectedItem && that.displayMode !== 'radial' && that.displayMode !== 'hexagonal' && (!item || (that._selectedItem === item && item.classList.contains('selected')))) { return; } if (!item) { return; } const strokeColor = that._getContrastColor(that._rgbaToHEX(that._toRGBA(item.colorCode))), svg = item.closest('svg'); Array.from((that.shadowRoot || that).querySelectorAll('.selected')).forEach(item => { item.classList.remove('selected'); item.removeAttribute('aria-current'); item.style.stroke = null; }); item.classList.add('selected'); item.setAttribute('aria-current', true); that._selectedItem = item; if (svg) { item.style.stroke = strokeColor; svg.appendChild(item); } return true; } /** * Returns a contrasting color of the target color * @param {any} color */ _getContrastColor(color) { if (color === undefined) { return undefined; } function hexToRgb(h, e, x) { return [parseInt(h, 16), parseInt(e, 16), parseInt(x, 16)]; } let rgb = hexToRgb(color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)), luminance = (0.299 * rgb[0] + 0.61 * rgb[1] + 0.114 * rgb[2]) / 255; if (luminance > 0.6) { return '#000000'; } else { return '#FFFFFF'; } } /* * Gets x, y cusrsor coordinates, according to active element */ _getXYcoordinates(event) { if (!event) { return; } const that = this, target = that._activeComponent || (event.originalEvent || event).target; if (!target.closest) { return; } const parent = target.closest('.color-palette') || target.closest('.color-palette-radial') || target.closest('.hue-scale') || target.closest('.brightness-scale') || target.closest('.alpha-channel-scale'); if (!parent || that.disabled || that.readonly) { return; } const parentRect = parent.getBoundingClientRect(); let offsetX = event.pageX - window.pageXOffset - parentRect.left, offsetY = event.pageY - window.pageYOffset - parentRect.top; if (offsetX < 0) { offsetX = 0; } else if (offsetX > parent.offsetWidth) { offsetX = parent.offsetWidth; } if (offsetY < 0) { offsetY = 0; } else if (offsetY > parent.offsetHeight) { offsetY = parent.offsetHeight; } return { x: offsetX, y: offsetY, container: parent }; } /* * Updates input's value via mouse wheel */ _inputWheelHandler(event) { const that = this, oldValue = that.value, target = event.target; if (!(event.target instanceof HTMLInputElement) || event.target.classList.contains('hex')) { return; } event.preventDefault(); let value; if (target.classList.contains('a-channel')) { value = parseFloat(target.value) || 0; value = event.deltaY < 0 ? value + 0.01 : value - 0.01; target.value = that._toFixed(that._validateInRange(value, 0, 1)); that._RGBA = that._getRGBAFromInputs(); that._applyAlphaValue(that._RGBA.a, 'alphaInput'); } else { value = parseInt(target.value) || 0; value = event.deltaY < 0 ? value + 1 : value - 1; target.value = that._validateInRange(value, 0, 255); that._RGBA = that._getRGBAFromInputs(); that._HSV = that._getValue('hsv', 'rgba(' + that._RGBA.r + ', ' + that._RGBA.g + ', ' + that._RGBA.b + ', ' + that._RGBA.a + ')'); } that._updatePreviewContainerValues(that._getValue(that.valueFormat)); that._setPalettePointerXYPosition(); if (that.applyValueMode === 'useButtons') { if (that.displayMode === 'palette') { that._applyValueInPaletteMode(); } else if (that.displayMode === 'radial') { that._applyValueInRadialMode(); } else if (that.displayMode === 'hexagonal') { that._generateHoneycomb(that.columnCount, that._HSV); } } if (that.$.container.className.indexOf('custom-color-selection') > -1) { that._applyValue(that._HSVtoRGBA(that._HSV)); return; } if (that.applyValueMode === 'useButtons') { return; } that.value = that._getValue(that.valueFormat); that._applyValue(that.value, event); that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } /** * Palette Mode Container Down Handler * @param {any} event */ _paletteDownHandler(event) { const that = this; if ((!LW.Utilities.Core.isMobile && event.button !== 0) || that.disabled || that.readonly) { return; } that._dragDetails = { x: event.pageX - window.pageXOffset, y: event.pageY - window.pageYOffset }; const target = (event.originalEvent || event).target; if (!target || !target.closest) { return; } that._dragDetails.target = target.closest('.color-palette') || target.closest('.color-palette-radial') if (target.closest('.color-palette') || target.closest('.color-palette-radial')) { that._handleColorPaletteDown(event.originalEvent); that._dragDetails.isPalettePressed = true; return; } if (target.closest('.hue-scale') || target.closest('.alpha-channel-scale') || target.closest('.brightness-scale')) { that._handleScalesDown(event.originalEvent); } } /* * Updates palette pointer position, based on external color settings */ _setPalettePointerXYPosition(event) { const that = this; let coord; if (that.displayMode === 'palette' || that.$.container.className.indexOf('custom-color-selection') > -1) { coord = that._getXYcoordinates(event); that.$.colorPaletteThumb.style.left = (event && coord && coord.x) ? 100 * coord.x / coord.container.offsetWidth + '%' : 100 * that._HSV.s + '%'; that.$.colorPaletteThumb.style.top = (event && coord && coord.y) ? 100 * coord.y / coord.container.offsetHeight + '%' : 100 * (1 - that._HSV.v) + '%'; } else if (that.displayMode === 'radial') { if (event) { coord = that._getXYcoordinates(event); if (!coord) { return; } const offsetW = coord.container.offsetWidth ? coord.container.offsetWidth : that.$.colorPaletteRadial.offsetWidth, offsetH = coord.container.offsetHeight ? coord.container.offsetHeight : that.$.colorPaletteRadial.offsetHeight; const paletteCoordX = Math.round(Math.cos(that._HSV.h * Math.PI / 180) * offsetW / 2 + offsetW / 2), paletteCoordY = Math.round(Math.sin(that._HSV.h * Math.PI / 180) * offsetW / 2 + offsetH / 2); // Bugfix when values are close (in the center of radial mode) if (Math.abs((offsetW / 2) - coord.x) < 5) { that.$.colorPaletteRadialThumb.style.left = 100 * coord.x / that.$.colorPaletteRadial.offsetWidth + '%'; that.$.colorPaletteRadialThumb.style.top = 100 * coord.y / that.$.colorPaletteRadial.offsetHeight + '%'; return; } that.$.colorPaletteRadialThumb.style.left = 100 * (coord.x < offsetW / 2 ? Math.max(paletteCoordX, coord.x) : Math.min(paletteCoordX, coord.x)) / offsetW + '%'; that.$.colorPaletteRadialThumb.style.top = 100 * (coord.y < offsetH / 2 ? Math.max(paletteCoordY, coord.y) : Math.min(paletteCoordY, coord.y)) / offsetH + '%'; return; } else { const thumb = that._radialThumbPoint(that.$.colorPaletteRadial.offsetWidth / 2, that.$.colorPaletteRadial.offsetHeight / 2, that._HSV.h, that._HSV.s); that.$.colorPaletteRadialThumb.style.left = 100 * thumb.x / that.$.colorPaletteRadial.offsetWidth + '%'; that.$.colorPaletteRadialThumb.style.top = 100 * thumb.y / that.$.colorPaletteRadial.offsetHeight + '%'; } } } /* * Handles tooltip appearange, on mouseover color samples */ _handleGridModeCellHover(event) { const that = this, targetCell = event.target.closest('.color-sample'); if (that.disabled || !targetCell || that.tooltipDisplayMode === 'none' || !that.$.tooltip) { return; } that.$.tooltip.arrow = that.displayMode !== 'hexagonal'; if (!that._isValidColor(targetCell.colorCode)) { that.$.tooltip.disabled = true; return; } that.$.tooltip.disabled = false; that.$.tooltip.selector = targetCell; const itemColor = targetCell.h && targetCell.s && targetCell.v ? that._HSVtoRGBA({ h: targetCell.h, s: targetCell.s, v: targetCell.v }, that._RGBA.a) : that._toRGBA(targetCell.colorCode); switch (that.tooltipDisplayMode) { case 'rgba': that.$.tooltip.value = itemColor || ''; break; case 'rgb': that.$.tooltip.value = that._rgbaToRGB(itemColor) || ''; break; case 'hex': that.$.tooltip.value = that._rgbaToHEX(itemColor) || ''; break; } } /* * Handles button's and labels text content */ _localizeLabels() { const that = this, rLabel = (that.shadowRoot || that).querySelector('label.r-channel'), gLabel = (that.shadowRoot || that).querySelector('label.g-channel'), bLabel = (that.shadowRoot || that).querySelector('label.b-channel'), aLabel = (that.shadowRoot || that).querySelector('label.a-channel'), hexLabel = (that.shadowRoot || that).querySelector('label.hex'); if (rLabel) { rLabel.innerHTML = that.localize('redPrefix'); } if (gLabel) { gLabel.innerHTML = that.localize('greenPrefix'); } if (bLabel) { bLabel.innerHTML = that.localize('bluePrefix'); } if (aLabel) { aLabel.innerHTML = that.localize('alphaPrefix'); } if (hexLabel) { hexLabel.innerHTML = that.localize('hexPrefix'); } if (that.$.buttonCustom) { that.$.buttonCustom.content = that.localize('customColor'); } if (that.$.buttonOk) { that.$.buttonOk.content = that.localize('ok'); } if (that.$.buttonCancel) { that.$.buttonCancel.content = that.localize('cancel'); } if (that.$.defaultSamplesContainer) { //Theme colors label const themeColorsLabel = that.$.defaultSamplesContainer.querySelector('.theme-colors-label'), standardColorsLabel = that.$.defaultSamplesContainer.querySelector('.standard-colors-label'); if (themeColorsLabel) { themeColorsLabel.innerHTML = that.localize('themeColors'); } if (standardColorsLabel) { standardColorsLabel.innerHTML = that.localize('standardColors'); } } } /* * Generates honeycomb with particular number of elements(hexagons) */ _generateHoneycomb(cols, customHSV) { const that = this, shortStep = parseInt(getComputedStyle(that).getPropertyValue('--lw-color-panel-grid-mode-item-size')) / 4, hexagonSideSize = Math.sqrt(5 * Math.pow(shortStep, 2)), columns = cols % 2 === 0 ? parseInt(cols) + 1 : parseInt(cols), saturation = (customHSV && customHSV.s !== undefined) ? customHSV.s : 1, brightness = (customHSV && customHSV.v !== undefined) ? customHSV.v : 1, offsets = that._calculateHexagonCoords(columns, hexagonSideSize, 1), centerElement = offsets[Math.floor(offsets.length / 2)], hexagonSize = that._getHoneycomb30degDimmensions(offsets.length, hexagonSideSize, 1); if (!that._draw) { that._draw = new LW.Utilities.Draw(that.$.colorPaletteHexagonal); } that._draw.clear(); that.$.colorPaletteHexagonal.firstElementChild.setAttribute('role', 'presentation'); that.$.colorPaletteHexagonal.firstElementChild.firstElementChild.setAttribute('role', 'menu'); that._hexagonItems = []; // Bugfix when changing mode from materialGrid to hexagonal if (that.$.materialGridSamplesContainer) { that.$.materialGridSamplesContainer.$.addClass('lw-hidden'); } for (let i = 0; i < offsets.length; i++) { const dx = offsets[i].x - centerElement.x, dy = offsets[i].y - centerElement.y, satValCoefficient = that._validateInRange(that._calcSatDistance(dx, dy) / centerElement.x, 0, 1); let hue = that._calcHueAngle(dx, dy) < 0 ? 360 + that._calcHueAngle(dx, dy) : that._calcHueAngle(dx, dy); let s, v; if (that.inverted) { s = saturation; v = satValCoefficient; } else { s = satValCoefficient; v = brightness; } switch (that.palette) { case 'red': hue = 0; break; case 'green': hue = 120; break; case 'blue': hue = 240; break; case 'gray': s = 0; v = that.inverted ? satValCoefficient : 1 - satValCoefficient break; } const settings = { offsetX: offsets[i].x, offsetY: offsets[i].y, style: { 'fill': that._HSVtoRGBA({ h: hue, s: s, v: v }, 1), 'class': 'color-sample' } }; let item = that._hexagon(hexagonSideSize, settings); item.colorCode = that._HSVtoRGBA({ h: hue, s: s, v: v }); item.h = hue; item.s = s; item.v = v; item.setAttribute('role', 'menuitem'); item.setAttribute('aria-label', item.colorCode); that._hexagonItems.push(item); } that._draw.host.style.width = hexagonSize.width + 'px'; that._draw.host.style.height = hexagonSize.height + 'px'; that.$.container.style.setProperty('--lw-color-panel-palette-width', hexagonSize.width + 'px'); that.$.container.style.setProperty('--lw-color-panel-palette-height', hexagonSize.height + 'px'); that._applyValueInHexagonalMode(); that._hideControlsByPriority(); // } /* * Creates hexagonal shape, based on the size of its side and style settings */ _hexagon(side, settings) { // const that = this, shortStep = that._shortStepHexagon(side), longStep = 2 * shortStep, startX1 = longStep + (settings.offsetX || 0), startY1 = settings.offsetY || 0, startX2 = startX1 + longStep, startY2 = startY1 + shortStep, startX3 = startX2, startY3 = startY2 + side, startX4 = startX3 - longStep, startY4 = startY3 + shortStep, startX5 = startX4 - longStep, startY5 = startY4 - shortStep, startX6 = startX5, startY6 = startY5 - side, points = 'M ' + startX1 + ',' + startY1 + ' L ' + startX2 + ',' + startY2 + ' L ' + startX3 + ',' + startY3 + ' L ' + startX4 + ',' + startY4 + ' L ' + startX5 + ',' + startY5 + ' L ' + startX6 + ',' + startY6 + ' Z', hexagon = that._draw.path(points, settings.style || { 'class': 'color-sample' }); return hexagon; } /* * Calculates the shortest path from an edge of hexagon to an edge of the enclosing rectangle */ _shortStepHexagon(sideSize) { return Math.sqrt(Math.pow(sideSize, 2) / 5); } /* * Gets the dimensions of honeycomb, according to the number of total cells */ _getHoneycomb30degDimmensions(cells, itemSideSize, offset) { const that = this, cellsNumberOnSide = 0.5 * (1 + Math.sqrt(1 - 4 * ((1 - cells) / 3))), step = that._shortStepHexagon(itemSideSize), hexagonSquareWidth = step * 4, honeycombWidth = (2 * cellsNumberOnSide - 1) * hexagonSquareWidth + 2 * cellsNumberOnSide * 2 * offset, honeycombHeight = (2 * cellsNumberOnSide - 1) * itemSideSize + 2 * cellsNumberOnSide * step + cellsNumberOnSide * 2 * offset; return { width: honeycombWidth, height: honeycombHeight }; } /* * Calclulates the values of color shades, based on the number of disllayed columns */ _generateShades(items, shadesOf) { const that = this, type = shadesOf || 'gray', base = 255; let color, colors = []; items = Math.max(parseInt(items), 2); const step = 255 / (items - 1); for (let i = 0; i < items; i++) { let shadeValue = Math.max(parseInt(base - i * step), 0); if (that.inverted) { shadeValue = 255 - shadeValue; } switch (type) { case 'red': color = 'rgb(' + shadeValue + ', 0, 0)'; break; case 'green': color = 'rgb(0, ' + shadeValue + ', 0)'; break; case 'blue': color = 'rgb(0, 0, ' + shadeValue + ')'; break; default: color = 'rgb(' + shadeValue + ', ' + shadeValue + ', ' + shadeValue + ')'; } colors.push(color); } return colors; } /* * Generates list of colors, based on HUE, Saturation and Value settings; color generation could be inverted according to "inverted property" */ _generateColorSpectrum(columns) { const that = this; let colors = []; columns = Math.max(parseInt(columns), 2); const hueStep = 360 / (columns - 1), svStep = 2 / columns; let hue = 0, saturation = 1, brightnessValue = 1; for (let i = 0; i < columns; i++) { if (!that.inverted) { if (i === 0) { brightnessValue = 1; } else if (i < columns / 2) { brightnessValue = Math.max((brightnessValue - svStep), (svStep / 2)); } else if (i < (columns - 1)) { saturation = Math.max((saturation - svStep), (svStep / 2)); brightnessValue = Math.min((brightnessValue + svStep), 1); } else { saturation = Math.max((saturation - svStep), (svStep / 2)); brightnessValue = Math.min((brightnessValue + svStep / 4), 1); } } else { if (i === 0) { saturation = 1; } else if (i < columns / 2) { saturation = Math.max((saturation - svStep), (svStep / 2)); } else if (i < (columns - 1)) { brightnessValue = Math.max((brightnessValue - svStep), (svStep / 2)); saturation = Math.min((saturation + svStep), 1); } else { brightnessValue = Math.max((brightnessValue - svStep), (svStep / 2)); saturation = Math.min((saturation + svStep / 4), 1); } } for (let j = 0; j < columns; j++) { hue = parseInt(hueStep * j); hue = hue === 360 ? 360 - hueStep / 2 : hue; colors.push(that._HSVtoRGBA({ h: hue, s: saturation, v: brightnessValue }, 1)); } } return colors; } /* * Generates spectrum grid structure - gray shades row, spectrum scale, user defined colors row */ _generateSpectrumGrid(columns) { const that = this; if (!that.$.spectrumGridSamplesContainer) { return; } const spectrumItems = Math.pow(columns, 2), fragment = document.createDocumentFragment(), containers = {}, containersNames = ['grayShadesBox', 'spectrumBox', 'customColorsBox'], grayRowShades = that._generateShades(columns, 'gray'), customColors = that._customPalette; let spectrumColors; containersNames.forEach(name => { const element = document.createElement('div'); let label = LW.Utilities.Core.toDash(name).split('-').join(' '); containers[name] = element; element.className = LW.Utilities.Core.toDash(name); element.setAttribute('role', 'menu'); element.setAttribute('aria-label', label.slice(0, 1).toUpperCase() + label.slice(1)); fragment.appendChild(element); }); if (that.palette === 'default') { spectrumColors = that._generateColorSpectrum(columns); // to be replaced with the case of custom colors } else if (['gray', 'red', 'green', 'blue'].indexOf(that.palette) > -1) { spectrumColors = that._generateShades(spectrumItems, that.palette); } else { spectrumColors = that._generateColorSpectrum(columns); } for (let i = 0; i < columns; i++) { const colorSample = that._createColorSample(grayRowShades[i], 'gray-shade'); containers.grayShadesBox.appendChild(colorSample); } for (let i = 0; i < spectrumItems; i++) { const colorSample = that._createColorSample(spectrumColors[i], 'spectrum'); containers.spectrumBox.appendChild(colorSample); } for (let i = 0; i < columns; i++) { const colorCode = customColors[i]; if (!colorCode) { break; } const colorSample = that._createColorSample(colorCode, 'custom-color'); containers.customColorsBox.appendChild(colorSample); } that.$.spectrumGridSamplesContainer.innerHTML = ''; that.$.spectrumGridSamplesContainer.appendChild(fragment); } /* * Generates default grid structure - theme colors row, color shades row, standard colors row */ _generateDefaultGrid() { const that = this; if (!that.$.defaultSamplesContainer) { return; } const columns = 10, containers = {}, containersNames = ['themeColorsLabel', 'themeColorsBox', 'themeShadesBox', 'standardColorsLabel', 'standardColorsBox'], themeColors = that.gridThemeColors === null ? that._defaultModeThemeColors : that.gridThemeColors, shadeColors = that.gridShadeColors === null ? that._defaultModeShadesColors : that.gridShadeColors, standardColors = that.gridStandardColors === null ? that._defaultModeStandardColors : that.gridStandardColors, fragment = document.createDocumentFragment(); containersNames.forEach(name => { const element = document.createElement('div'); containers[name] = element; element.className = LW.Utilities.Core.toDash(name); if (name.indexOf('Box') !== -1) { element.setAttribute('role', 'menu'); } else if (name.indexOf('Label') !== -1) { element.id = that.id + name; } fragment.appendChild(element); }); containers.themeColorsLabel.innerHTML = that.localize('themeColors'); 'Theme colors'; containers.standardColorsLabel.innerHTML = that.localize('standardColors'); 'Standard colors'; containers.themeColorsBox.setAttribute('aria-labelledby', that.id + 'themeColorsLabel'); containers.themeShadesBox.setAttribute('aria-labelledby', that.id + 'themeColorsLabel'); containers.standardColorsBox.setAttribute('aria-labelledby', that.id + 'standardColorsLabel'); for (let i = 0; i < that._defaultModeShadesColors.length; i++) { containers.themeShadesBox.appendChild(that._createColorSample(shadeColors[i], 'shades-color')); } for (let i = 0; i < columns; i++) { containers.themeColorsBox.appendChild(that._createColorSample(themeColors[i], 'theme-color')); containers.standardColorsBox.appendChild(that._createColorSample(standardColors[i], 'standard-color')); } that.$.defaultSamplesContainer.innerHTML = ''; that.$.defaultSamplesContainer.appendChild(fragment); } /** * Mixes two colors with a shade * @param {any} colorA - HEX value of colorA * @param {any} colorB - HEX value of colorB * @param {any} shade - from 0 to 1 */ _mixColors(colorA, colorB, shade) { const decToHex = d => d.toString(16), hexToDec = h => parseInt(h, 16); let mixedColorPair, colorBlend = '#'; shade = (typeof (shade) !== 'undefined') ? shade : 0.5; //Remove the # sign colorA = colorA.replace(/#/g, ''); colorB = colorB.replace(/#/g, ''); // Get the R,G,B value pairs for (let i = 0; i <= 5; i += 2) { const colorPair1 = hexToDec(colorA.substr(i, 2)), colorPair2 = hexToDec(colorB.substr(i, 2)); //Mixing the pairs from every color by appling specified shade mixedColorPair = decToHex(Math.round(colorPair2 + (colorPair1 - colorPair2) * (shade))); //Adds a leading zero if value is shorter while (mixedColorPair.length < 2) { mixedColorPair = '0' + mixedColorPair; } colorBlend += mixedColorPair; } //Return the new color as a HEX value by prepending the # sign return colorBlend; } /* * Generates material grid structure - row */ _generateMaterialGrid() { const that = this; if (!that.$.materialGridSamplesContainer) { return; } const fragment = document.createDocumentFragment(); // Bugfix when changing mode from materialGrid to hexagonal that.$.materialGridSamplesContainer.$.removeClass('lw-hidden'); //Create the column labels fragment.appendChild(that._createColorSample('rgb(255, 255, 255, 0)', 'material-color label-column')); Object.entries(that._materialColors['Red']).forEach(color => { const colorSample = that._createColorSample('rgb(255, 255, 255, 0)', 'material-color header'); colorSample.textContent = color[0]; fragment.appendChild(colorSample); }); Object.entries(that._materialColors).forEach(gama => { const colorSample1 = that._createColorSample('rgb(255, 255, 255, 0)', 'material-color label-column'); colorSample1.textContent = gama[0]; fragment.appendChild(colorSample1); Object.entries(gama[1]).forEach(color => { fragment.appendChild(that._createColorSample(color[1], 'material-color')); }); }); that.$.materialGridSamplesContainer.innerHTML = ''; that.$.materialGridSamplesContainer.appendChild(fragment); } /* * Creates span element as color box container */ _createColorSample(color, className) { const colorSample = document.createElement('div'), empty = color ? '' : ' empty'; if (color && className.indexOf('label-column') === -1 && className.indexOf('header') === -1) { colorSample.setAttribute('role', 'menuitem'); colorSample.setAttribute('aria-label', color); } colorSample.className = 'color-sample ' + className + empty; if (className.indexOf('header') > -1 || className.indexOf('label-column') > -1) { return colorSample; } colorSample.colorCode = color; colorSample.style.backgroundColor = color; return colorSample; } /* * Calculates how many hexagon elements can have honeycomb in each bound row, according to the size of the middle row */ _calculateHexagonCoords(columns, elementSideSize, offset) { const that = this, rows = columns, firstRowSize = colsToSide(columns), step = that._shortStepHexagon(elementSideSize), offsetXnextItemInRow = 4 * step + 2 * offset, offsetXnextRow = 2 * step + offset, offsetYnextRow = elementSideSize + step + offset, firstRowX = offsetXnextRow * (rows - 1) / 2; let coordinates = []; for (let i = 0; i < rows; i++) { const rowSize = i < firstRowSize ? firstRowSize + i : columns - 1 - (i - firstRowSize), x0 = i < firstRowSize ? firstRowX - i * offsetXnextRow : firstRowX - (columns - i - 1) * offsetXnextRow, y0 = i * offsetYnextRow; for (let j = 0; j < rowSize; j++) { const x = x0 + j * offsetXnextItemInRow; coordinates.push({ x: x, y: y0 }); } } function colsToSide(columns) { columns = columns % 2 === 0 ? columns + 1 : columns; return (columns + 1) / 2; } return coordinates; } /* * Generates grid structure according to the display mode */ _generateGridStructures() { const that = this, displayMode = that.displayMode; //Used by ColorPicker to lazy initialize the element if (that._initializeOnOpening) { return; } // WAI-ARIA roles function setAriaRoles() { switch (displayMode) { case 'default': case 'grid': that.$.colorPaletteRadial.setAttribute('aria-hidden', true); that.$.brightnessScale.setAttribute('aria-hidden', true); break; case 'hexagonal': that.$.colorPaletteRadial.setAttribute('aria-hidden', true); that.$.brightnessScale.removeAttribute('aria-hidden'); break; case 'materialGrid': that.$.colorPaletteRadial.removeAttribute('aria-hidden'); that.$.brightnessScale.removeAttribute('aria-hidden'); break; case 'palette': that.$.colorPaletteRadial.removeAttribute('aria-hidden'); that.$.brightnessScale.setAttribute('aria-hidden', true); break; case 'radial': case 'spectrumGrid': break; } } if (that._createGridModeComponents() === undefined) { switch (displayMode) { case 'spectrumGrid': that._generateSpectrumGrid(that.columnCount); break; case 'materialGrid': that._generateMaterialGrid(); break; case 'default': that._generateDefaultGrid(); break; case 'grid': that._generatePaletteGrid(); break; } that._generatePaletteUserColorGrid(); setAriaRoles(); return; } that._createColorControls(); switch (displayMode) { case 'radial': that._generateRadialCanvas(); break; case 'hexagonal': that._generateHoneycomb(that.columnCount, that._HSV); break; } setAriaRoles(); } /** * Creates a Canvas that acts as a fallback for the lack of CSS gradient support on iOS devices */ _generateRadialCanvas() { const that = this; if (that.displayMode !== 'radial' || (that.displayMode === 'radial' && !LW.Utilities.Core.Browser.Firefox)) { return; } const diameter = that.$.colorPaletteRadial.offsetWidth, radius = diameter / 2; let canvas = that.$.colorPaletteRadial.querySelector('canvas'); if (!canvas) { canvas = document.createElement('canvas'); canvas.setAttribute('role', 'presentation'); } let ctx = canvas.getContext('2d'), image = ctx.createImageData(diameter, diameter), data = image.data; canvas.width = canvas.height = diameter; for (let x = -radius; x < radius; x++) { for (let y = -radius; y < radius; y++) { let [r, phi] = that._xy2polar(x, y); if (r > radius) { // skip all (x,y) coordinates that are outside of the circle continue; } // Figure out the starting index of this pixel in the image data array. let rowLength = 2 * radius, adjustedX = x + radius, // convert x from [-50, 50] to [0, 100] (the coordinates of the image data array) adjustedY = y + radius, // convert y from [-50, 50] to [0, 100] (the coordinates of the image data array) pixelWidth = 4, // each pixel requires 4 slots in the data array index = (adjustedX + (adjustedY * rowLength)) * pixelWidth; let hue = that._rad2deg(phi), saturation = 1.0, value = 1.0; const [red, green, blue] = that._hsv2rgb(hue, saturation, value); data[index] = red; data[index + 1] = green; data[index + 2] = blue; data[index + 3] = 255; } } ctx.putImageData(image, 0, 0); that.$.colorPaletteRadial.appendChild(canvas); } _xy2polar(x, y) { let r = Math.sqrt(x * x + y * y), phi = Math.atan2(y, x); return [r, phi]; } _rad2deg(rad) { return ((rad + Math.PI) / (2 * Math.PI)) * 360; } _hsv2rgb(hue, saturation, value) { let chroma = value * saturation, hue1 = hue / 60, x = chroma * (1 - Math.abs((hue1 % 2) - 1)), r1, g1, b1; if (hue1 >= 0 && hue1 <= 1) { ([r1, g1, b1] = [chroma, x, 0]); } else if (hue1 >= 1 && hue1 <= 2) { ([r1, g1, b1] = [x, chroma, 0]); } else if (hue1 >= 2 && hue1 <= 3) { ([r1, g1, b1] = [0, chroma, x]); } else if (hue1 >= 3 && hue1 <= 4) { ([r1, g1, b1] = [0, x, chroma]); } else if (hue1 >= 4 && hue1 <= 5) { ([r1, g1, b1] = [x, 0, chroma]); } else if (hue1 >= 5 && hue1 <= 6) { ([r1, g1, b1] = [chroma, 0, x]); } let m = value - chroma, [r, g, b] = [r1 + m, g1 + m, b1 + m]; // Change r,g,b values from [0,1] to [0,255] return [255 * r, 255 * g, 255 * b]; } /* * Hides particular elements on palette resize */ _hideControlsByPriority() { const that = this, colorControlsContainer = (that.shadowRoot || that).querySelector('.color-controls-container'); if (!colorControlsContainer.innerHTML.trim()) { return; } function hideComponent(className) { const components = that.getElementsByClassName(className); for (let i = 0; i < components.length; i++) { components[i].classList.add('lw-hidden'); } } const priority = that.hideContentToFit.slice().reverse(), controlledElements = ['hex', 'r-channel', 'g-channel', 'b-channel', 'a-channel', 'preview-container']; let i = priority.length; controlledElements.forEach(item => { //if (that['$' + item]) { // that['$' + item].removeClass('lw-hidden'); //} const elements = that.getElementsByClassName(item); for (let e = 0; e < elements.length; e++) { elements[e].classList.remove('lw-hidden'); } }); while (colorControlsContainer.scrollHeight > colorControlsContainer.offsetHeight && i > 0) { i--; switch (priority[i]) { case 'HEX': //controlledElements.slice(0, 2).forEach(item => that['$' + item].addClass('lw-hidden')); //controlledElements.slice(0, 2).forEach(item => that['$' + item].addClass('lw-hidden')); hideComponent(controlledElements[0]); break; case 'RGB': //controlledElements.slice(2, 8).forEach(item => that['$' + item].addClass('lw-hidden')); controlledElements.slice(1, 4).forEach(className => hideComponent(className)); break; case 'previewContainer': //that.$previewContainer.addClass('lw-hidden'); hideComponent(controlledElements[5]); break; case 'alpha': //controlledElements.slice(9, 11).forEach(item => that['$' + item].addClass('lw-hidden')); hideComponent(controlledElements[4]); break; } } that._generateRadialCanvas(); } /* * Redraws honeycomb if the variable related to items size is updated */ _resizeHoneycombItems() { const that = this; if (that.displayMode !== 'hexagonal') { return; } that._generateHoneycomb(that.columnCount, that._HSV); } /* * Return value string, regarding to prefered type */ _getValue(type, randomColor) { const that = this, color = that._RGBA; let value = null, rgbaFragments; switch (type) { case 'hex': value = that._rgbArrayToHEX([color.r, color.g, color.b, color.a]); break; case 'rgb': value = 'rgb(' + color.r + ', ' + color.g + ', ' + color.b + ')'; break; case 'rgba': value = (color.r !== null && color.g !== null && color.b !== null) ? 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + color.a + ')' : null; break; case 'HSVtoRGBAarray': { let alpha = that.displayMode === 'hexagonal' || that.displayMode === 'radial' || that.displayMode === 'palette' ? that._RGBA.a : 1; if (randomColor) { if (that._isRGBA(randomColor) && /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.test(randomColor.replace(/\s/g, ''))) { alpha = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(randomColor.replace(/\s/g, ''))[4]; } else if (that._isHEX(randomColor) && /(^#[0-9A-F]{8}$)/gi.test(randomColor.replace(/\s/g, ''))) { alpha = parseInt(/(^#[0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2}$)/gi.exec(randomColor.replace(/\s/g, ''))[4], 16) / 255; } alpha = Math.min(1, Math.max(0, parseFloat(alpha))); if (isNaN(alpha)) { alpha = that._RGBA.a; } } value = that._HSVtoRGBA(that._HSV, alpha); rgbaFragments = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(value.replace(/\s/g, '')); value = { r: parseInt(rgbaFragments[1]), g: parseInt(rgbaFragments[2]), b: parseInt(rgbaFragments[3]), a: parseFloat(rgbaFragments[4]) }; break; } case 'hsv': if (randomColor && that._isValidColor(randomColor)) { value = that._colorToHSV(randomColor); } break; default: if (that.displayMode === 'radial' || that.displayMode === 'hexagonal' || that.displayMode === 'palette') { value = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + color.a + ')'; if (!that.editAlphaChannel) { value = that._rgbaToRGB(value); } } else if (randomColor !== null) { value = that._rgbArrayToHEX([color.r, color.g, color.b, color.a]); } else { value = null; } break; } return value || null; } /* * Updates value and fires event according to applyValueMode */ _instantUpdate() { // rename?remove?update? const that = this, oldValue = that.value; if (that.applyValueMode !== 'instantly' || that.$.container.className.indexOf('custom-color-selection') > -1) { return; } that.value = that._getValue(that.valueFormat); that.$.fireEvent('change', { 'oldValue': oldValue, 'value': that.value }); } /* * Compares if two color values are equal, no matter of their type of representation */ _equalValues(value1, value2) { const that = this; if (value1 === value2) { return true; } else if (!value1 || !value2) { return false; } return that._toRGBA(value1, true) === that._toRGBA(value2, true) } /* * Transform to Hex */ _toHEX(value) { const that = this; if (that._isHEX(value)) { return value; } if (that._isRGB(value)) { value = value.toLowerCase().replace('rgb', 'rgba'); value = that.editAlphaChannel ? value.replace(')', ', ' + (that._RGBA.a || 1) + ')') : value.replace(')', ', 1)'); } if (that._isRGBA(value)) { return that._rgbaToHEX(value); } } /* * Transform RGB/HEX/color to RGBA */ _toRGBA(value, ignoreAlpha) { // check if these transformations are required when there are central _HSV and _RGBA containers const that = this; let val = that.value; if (that._isRGBA(value)) { if (ignoreAlpha) { let rgb = value.match(/(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})/gi); return 'rgba(' + rgb + ', 1)'; } return value; } if (that._isValidColorName(value)) { val = hexToRgba(that._cssColorNamesHEX[value.trim().toLowerCase()]); } else if (that._isHEX(value)) { val = hexToRgba(value); } else if (that._isRGB(value)) { val = value.toLowerCase(); val = val.replace('rgb', 'rgba'); val = that.editAlphaChannel ? val.replace(')', ', ' + (that._RGBA.a || 1) + ')') : val.replace(')', ', 1)'); } else { return false; } return val; function hexToRgba(value) { const shortHexResult = /^#(.)(.)(.)$/gi.exec(value), longHexResult = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(value), r = shortHexResult ? parseInt(shortHexResult[1] + shortHexResult[1], 16) : parseInt(longHexResult[1], 16), g = shortHexResult ? parseInt(shortHexResult[2] + shortHexResult[2], 16) : parseInt(longHexResult[2], 16), b = shortHexResult ? parseInt(shortHexResult[3] + shortHexResult[3], 16) : parseInt(longHexResult[3], 16), a = shortHexResult ? parseInt(shortHexResult[4] + shortHexResult[4], 16) : parseInt(longHexResult[4], 16); if (ignoreAlpha) { return 'rgba(' + r + ', ' + g + ', ' + b + ', 1)'; } return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + (isNaN(a) ? '1' : (a / 255)) + ')'; } } /* * Color transformations */ _rgbaToRGB(value) { const rgba = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(value.replace(/\s/g, '')); return 'rgb(' + rgba[1].trim() + ', ' + rgba[2].trim() + ', ' + rgba[3].trim() + ')'; } _rgbaToHEX(value) { const that = this, rgba = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(value.replace(/\s/g, '')); return that._rgbArrayToHEX([rgba[1], rgba[2], rgba[3], rgba[4]]); } _rgbArrayToHEX(color) { let hex = '#'; if (Array.isArray(color) && color[0] === null) { return null; } for (let i = 0; i < 3; i++) { let hexI = parseInt(color[i]).toString(16).toUpperCase(); hexI = hexI.length === 1 ? 0 + hexI : hexI; hex = hex + hexI; } let alpha = parseFloat(color[3]); if (!isNaN(alpha)) { alpha = parseInt((alpha * 255)).toString(16).toUpperCase(); if (alpha !== 'FF') { hex = hex.slice(0, 7) + (alpha.length === 1 ? 0 + alpha : alpha); } } return hex; } _colorToHSV(value) { const that = this; if (!that._isValidColor(value)) { return; } value = that._toRGBA(value).replace(/\s/g, ''); const rgbaFragments = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(value), r = Math.min(255, Math.max(0, parseFloat(rgbaFragments[1]))) / 255, g = Math.min(255, Math.max(0, parseFloat(rgbaFragments[2]))) / 255, b = Math.min(255, Math.max(0, parseFloat(rgbaFragments[3]))) / 255; let hsv = { h: 0, s: 0, v: 0 }, min = 0, max = 0; if (r >= g && r >= b) { max = r; min = (g > b) ? b : g; } else if (g >= b && g >= r) { max = g; min = (r > b) ? b : r; } else { max = b; min = (g > r) ? r : g; } hsv.v = max; hsv.s = max ? ((max - min) / max) : 0; if (!hsv.s) { hsv.h = that._HSV.h ? that._HSV.h : 0; } else { const delta = max - min; if (r === max) { hsv.h = (g - b) / delta; } else if (g === max) { hsv.h = 2 + (b - r) / delta; } else { hsv.h = 4 + (r - g) / delta; } //hsv.h = Math.round(hsv.h * 60); hsv.h = hsv.h * 60; if (hsv.h < 0) { hsv.h += 360; } } hsv.s = parseFloat(hsv.s); hsv.v = parseFloat(hsv.v); //Invert the saturation and value //if (that.inverted) { // const saturation = hsv.s; // hsv.s = hsv.v; // hsv.v = saturation; //} return hsv; } _HSVtoRGBA(hsv, a) {// to return RGBA array or RGBA object!!! hsv = hsv || { h: 0, s: 0, v: 0 }; const that = this, h = (hsv && hsv.h >= 0) ? hsv.h : that._HSV.h, s = (hsv && hsv.s >= 0) ? hsv.s : that._HSV.s, v = (hsv && hsv.v >= 0) ? hsv.v : that._HSV.v; let chroma = v * s, hue = h / 60, x = chroma * (1 - Math.abs((hue % 2) - 1)), r1, g1, b1; if (hue >= 0 && hue <= 1) { ([r1, g1, b1] = [chroma, x, 0]); } else if (hue >= 1 && hue <= 2) { ([r1, g1, b1] = [x, chroma, 0]); } else if (hue >= 2 && hue <= 3) { ([r1, g1, b1] = [0, chroma, x]); } else if (hue >= 3 && hue <= 4) { ([r1, g1, b1] = [0, x, chroma]); } else if (hue >= 4 && hue <= 5) { ([r1, g1, b1] = [x, 0, chroma]); } else if (hue >= 5 && hue <= 6) { ([r1, g1, b1] = [chroma, 0, x]); } const m = v - chroma, r = Math.round((r1 + m) * 255), g = Math.round((g1 + m) * 255), b = Math.round((b1 + m) * 255); return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + (a !== undefined ? a : (that._RGBA.a || 0)) + ')'; } _HSVRGBArefresh(value) { const that = this; that._HSV = that._getValue('hsv', value) || { h: 1, s: 0, v: 1 }; that._RGBA = that._getValue('HSVtoRGBAarray', value); } /* * Return floating point to precision */ _toFixed(value, symbols) { return parseFloat(parseFloat(value).toFixed(symbols || 2)); } /* * Validates number in range */ _validateInRange(value, min, max) { return Math.min(Math.max(parseFloat(value), parseFloat(min)), parseFloat(max)) } /* * Validation functions about HEX, RGB, RGBA, supported color names */ _isHEX(value) { return /(^#[0-9A-F]{3}$)|(^#[0-9A-F]{6}$)|(^#[0-9A-F]{8}$)/i.test(value); } _isRGB(value) { return /rgb\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\)/i.test(value); } _isRGBA(value) { return /rgba\((\d*.\d+|\d+)\s*,\s*(\d*.\d+|\d+)\s*,\s*(\d*.\d+|\d+)\s*,\s*(\d*.\d+|\d+)\)/i.test(value); } _isValidColorName(value) { return (!value || typeof this._cssColorNamesHEX[value.trim().toLowerCase()] === 'undefined') ? false : true; } _isValidColor(value) { return this._isHEX(value) || this._isRGB(value) || this._isRGBA(value) || this._isValidColorName(value) } /* * Getting/setting inputs, related to Red, Green, Blue, Alpha channels */ _getRGBAFromInputs() { const that = this; let r = (that.shadowRoot || that).querySelector('input.r-channel'), g = (that.shadowRoot || that).querySelector('input.g-channel'), b = (that.shadowRoot || that).querySelector('input.b-channel'), a = (that.shadowRoot || that).querySelector('input.a-channel'); r = r ? r.value : that._RGBA.r; g = g ? g.value : that._RGBA.g; b = b ? b.value : that._RGBA.b; a = a ? a.value : that._RGBA.a; return { r: parseInt(r), g: parseInt(g), b: parseInt(b), a: a }; } _setRGBAToInputs() { const that = this; Object.entries(that._RGBA).forEach(entry => { const input = (that.shadowRoot || that).querySelector('input.' + entry[0] + '-channel'); if (input) { input.value = that._RGBA[entry[0]]; } }); } /* * Circular mode calculations - HUE angle, saturation distance */ _calcHueAngle(dx, dy) { return Math.atan2(dy, dx) * 180 / Math.PI; } _calcSatDistance(dx, dy) { return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * ColorPicker custom element. */ LW('lw-color-picker', class ColorPicker extends LW.DropDownButton { // ColorPicker's properties. static get properties() { return { 'applyValueMode': { value: 'instantly', allowedValues: ['instantly', 'useButtons'], type: 'string' }, 'columnCount': { value: 8, type: 'number' }, 'gridThemeColors': { value: null, type: 'array?', reflectToAttribute: false }, 'gridShadeColors': { value: null, type: 'array?', reflectToAttribute: false }, 'gridStandardColors': { value: null, type: 'array?', reflectToAttribute: false }, 'paletteColors': { value: null, type: 'array?', reflectToAttribute: false }, 'paletteCustomColors': { value: null, type: 'array?', reflectToAttribute: false }, 'disableUndo': { value: false, type: 'boolean' }, 'displayMode': { value: 'default', allowedValues: ['default', 'grid', 'palette', 'radial', 'hexagonal', 'spectrumGrid', 'materialGrid'], type: 'string' }, 'dropDownAppendTo': { value: null, type: 'any' }, 'dropDownHeight': { value: 'auto', type: 'string' }, 'dropDownWidth': { value: 'auto', type: 'string' }, 'editable': { value: false, type: 'boolean' }, 'editAlphaChannel': { value: false, type: 'boolean' }, 'enableCustomColors': { value: false, type: 'boolean' }, 'hidePreviewContainer': { value: false, type: 'boolean' }, 'hideRGBEditor': { value: false, type: 'boolean' }, 'hideHEXEditor': { value: false, type: 'boolean' }, 'hideAlphaEditor': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'redPrefix': 'R:', 'greenPrefix': 'G:', 'bluePrefix': 'B:', 'hexPrefix': '#:', 'alphaPrefix': 'Alpha:', 'ok': 'OK', 'cancel': 'CANCEL', 'customColor': 'CUSTOM COLOR', 'standardColors': 'Standard colors', 'themeColors': 'Theme colors' } }, type: 'object', extend: true }, 'name': { value: '', type: 'string' }, 'palette': { value: 'default', allowedValues: ['default', 'gray', 'red', 'green', 'blue', 'custom'], type: 'string' }, 'placeholder': { value: 'Please Select Color', type: 'string' }, 'tooltipDisplayMode': { value: 'hex', allowedValues: ['none', 'rgba', 'rgb', 'hex'], type: 'string' }, 'value': { value: null, type: 'string?' }, 'valueDisplayMode': { value: 'default', allowedValues: ['default', 'colorBox', 'colorCode', 'none'], // default => (colorBox + text), colorBox(only color box), text(only input), none(only button with placeholder); editable to enable text input in default and text modes, otherwise input to be disabled type: 'string' }, 'valueFormat': { value: 'default', allowedValues: ['default', 'rgb', 'rgba', 'hex'], // in 'default' mode the value is shown in format 'as is' entered by the user type: 'string' }, 'inverted': { value: false, type: 'boolean' }, 'hideContentToFit': { value: ['RGB', 'HEX', 'alpha', 'previewContainer'], // hides palette editors in a sequence if there is not enought space type: 'array' } }; } /** * ColorPicker's event listeners. */ static get listeners() { return { 'input.change': '_inputChangeHandler', 'input.focus': '_focusEventHandler', 'input.blur': '_blurEventHandler', 'colorPanel.cancelButtonClick': '_cancelButtonHandler', 'colorPanel.okButtonClick': '_okButtonHandler', 'colorPanel.customColorSelection': '_customColorSelectionHandler', 'colorPanel.change': '_colorPanelChangeHandler', 'keydown': '_keyDownHandler' }; } /** * Checks for missing modules. */ static get requires() { return { 'LW.ColorPanel': 'lw.colorpanel.js', 'LW.DropDownButton': 'lw.dropdownbutton.js' } } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.colorpanel.css', 'lw.colorpicker.css' ] } /** * ColorPicker's HTML template. */ template() { return `<div id="container" role="presentation"> <span class="lw-label" id="label">[[label]]</span> <div id="content" class="lw-content" role="presentation"> <div id="buttonsContainer" class="lw-buttons-container" role="presentation"> <div id="actionButton" class="lw-action-button"> <div id="colorSampleContainer" class="lw-color-box color-picker-sample-container" role="presentation"> <div id="colorSample" class="color-picker-sample"></div> </div> <input type="text" id="input" class="lw-input lw-color-input color-picker-action-input" placeholder="[[placeholder]]" spellcheck="false" autocomplete="off" aria-label="[[placeholder]]" /> </div> <span id="dropDownButton" class="lw-drop-down-button"> <span class="lw-drop-down-button-icon" id="arrow" aria-hidden="true"></span> </span> </div> <div id="dropDownContainer" class="lw-drop-down lw-drop-down-color-picker lw-drop-down-container lw-visibility-hidden" role="dialog"> <lw-color-panel id="colorPanel" wait animation="[[animation]]" apply-value-mode="[[applyValueMode]]" column-count="[[columnCount]]" disabled="[[disabled]]" display-mode="[[displayMode]]" edit-alpha-channel="[[editAlphaChannel]]" enable-custom-colors="[[enableCustomColors]]" grid-theme-colors="[[gridThemeColors]]" grid-shade-colors="[[gridShadeColors]]" grid-standard-colors="[[gridStandardColors]]" hide-content-to-fit="[[hideContentToFit]]" hide-preview-container="[[hidePreviewContainer]]" hide-r-g-b-editor="[[hideRGBEditor]]" hide-h-e-x-editor="[[hideHEXEditor]]" hide-alpha-editor="[[hideAlphaEditor]]" inverted="[[inverted]]" locale="[[locale]]" messages="[[messages]]" name="[[name]]" palette-colors="[[paletteColors]]" palette-custom-colors="[[paletteCustomColors]]" palette="[[palette]]" right-to-left="[[rightToLeft]]" theme="[[theme]]" tooltip-display-mode="[[tooltipDisplayMode]]" value="{{value}}" value-format="[[valueFormat]]"> </lw-color-panel> <div id="resizeBar" class="lw-drop-down-resize-bar" aria-label="Resize"> <div></div> </div> </div> </div> <span class="lw-hint" id="hint">[[hint]]</span> </div>`; } /** * Updates the DropDownButton when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'editable': case 'disabled': case 'readonly': that.$.input.readOnly = that.disabled || that.readonly || !that.editable; break; case 'value': if (that.$.colorPanel._isValidColor(that.value)) { that._applyValue(that.value); } break; case 'displayMode': that._applyValue(that.value); break; case 'dropDownOpenMode': super.propertyChangedHandler(propertyName, oldValue, newValue); if (newValue === 'dropDownButton') { that.$.actionButton.setAttribute('aria-label', that.value || that.placeholder); } else { that.$.actionButton.removeAttribute('aria-label'); } break; case 'resizeMode': that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode); break; case 'valueDisplayMode': if (newValue === 'none') { that.$.actionButton.setAttribute('role', 'presentation'); } else { that.$.actionButton.removeAttribute('role'); } break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } if (propertyName === 'displayMode') { //Resize event not thrown that.$.colorPanel._hideControlsByPriority(); } } /** * Open method. Opens the popup */ open() { const that = this, dropDownsInDOM = document.querySelectorAll('lw-drop-down-button, lw-color-picker'); //Lazy generate the ColorPanel structure before opening. The first time only if (that.$.colorPanel._initializeOnOpening) { delete that.$.colorPanel._initializeOnOpening; that.$.colorPanel._generateGridStructures(); that.$.colorPanel._applyValue(that.value); that.$.colorPanel._hideControlsByPriority(); } //NOTE: Will not close other DropDown's on page ! For example, DropDownList, DateTimePickers, etc ... //Make sure all dropDownButton popups are closed before openning this one for (let i = 0; i < dropDownsInDOM.length; i++) { if (dropDownsInDOM[i] !== that && dropDownsInDOM[i].opened) { dropDownsInDOM[i].close(); } } //Closes palette for custom color selection if (that.$.colorPanel && that.$.colorPanel.$container.hasClass('custom-color-selection')) { that.$.colorPanel._handleCancelButtonClick(); } that._open(); } /** * Blur method */ blur() { this.$.input.blur(); } /** * Focus method */ focus() { this.$.input.focus(); } /** * ColorPicker ready method */ _createElement() { const that = this; that.$.colorPanel._initializeOnOpening = !that.opened; that.$.colorPanel.wait = false; that.$.colorPanel.setAttribute('role', 'presentation'); that.$.input.readOnly = that.disabled || that.readonly || !that.editable; if (that.editable) { that.dropDownOpenMode = 'dropDownButton'; } that._setAriaRelations(true); if (that.valueDisplayMode === 'none') { that.$.actionButton.setAttribute('role', 'presentation'); } else { that.$.actionButton.removeAttribute('role'); } that._applyValue(that.$.colorPanel.value); that._setFocusable(); } /* * Applies the value */ _colorPanelChangeHandler(event) { const that = this; that._applyValue(event.detail.value); event.stopPropagation(); that.$.fireEvent('change', event.detail); } /** * Handles Cancel Button Click */ _cancelButtonHandler(event) { const that = this; event.stopPropagation(); if (that.$.colorPanel.$.container.className.indexOf('custom-color-selection') > -1) { that.$.fireEvent(event.type, event.detail); return; } that.close(); that.$.fireEvent(event.type, event.detail); } /** * Handles the Custom Color Selection view change * @param {any} event */ _customColorSelectionHandler(event) { const that = this; event.stopPropagation(); //Check the Browser bounds that._positionDetection.checkBrowserBounds('vertically'); that._positionDetection.positionDropDown(); that._positionDetection.checkBrowserBounds('horizontally'); that.$.fireEvent(event.type, event.detail); } /* * Closes the dropdown and applies the value */ _okButtonHandler(event) { const that = this; event.stopPropagation(); if (that.$.colorPanel.$.container.className.indexOf('custom-color-selection') > -1) { that.$.fireEvent(event.type, event.detail); return; } that._applyValue(that.$.colorPanel.value); that.close(); that.$.fireEvent(event.type, event.detail); } /** * Makes the element focusable or not */ _setFocusable() { const that = this; if (!that.disabled && !that.unfocusable) { let index = that.tabIndex > 0 ? that.tabIndex : 0; that.$.input.tabIndex = index; that.dropDownOpenMode === 'dropDownButton' ? that.$.dropDownButton.setAttribute('tabindex', index) : that.$.dropDownButton.removeAttribute('tabindex'); return; } that.$.input.tabIndex = -1; that.$.dropDownButton.removeAttribute('tabindex'); } /* * Applies value */ _inputChangeHandler(event) { const that = this; event.preventDefault(); event.stopPropagation(); that.value = that.$.colorPanel.value = that.$.input.value; } /* * Applies the value to value property, color sample, color panel */ _applyValue(tempValue) { const that = this; that.value = that.$.colorPanel.value = that.$.colorSample.style.backgroundColor = that.$.input.value = tempValue; if (tempValue) { that.$colorSampleContainer.removeClass('no-color'); that.$.colorSample.setAttribute('aria-label', tempValue); } else { that.$colorSampleContainer.addClass('no-color'); that.$.colorSample.setAttribute('aria-label', 'No color'); } if (!that.label) { that._ariaButton.setAttribute('aria-label', tempValue || that.placeholder); } if (that.dropDownOpenMode === 'dropDownButton') { that.$.actionButton.setAttribute('aria-label', tempValue || that.placeholder); } } /** * Key down handler * @param {any} event */ _keyDownHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.composedPath()[0] : event.target, activeElement = (that.shadowRoot || that.getRootNode()).activeElement || document.activeElement; if (that.disabled || that.readonly || (activeElement !== that && activeElement !== that.$.dropDownButton && activeElement !== that.$.input)) { return; } switch (event.key) { case 'Enter': case ' ': if (target !== that.$.input) { if (that.opened && event.key === 'Enter') { event.preventDefault(); that.close(); } else if (!that.opened && !that.readonly && that.dropDownOpenMode !== 'none') { event.preventDefault(); that.open(); } } else if (event.key === 'Enter') { event.preventDefault(); that.$.colorPanel.value = that.$.input.value; } break; case 'ArrowUp': case 'ArrowDown': if (event.altKey) { if (!that.disabled && !that.readonly && that.dropDownOpenMode !== 'none') { event.key === 'ArrowDown' ? that.open() : that.close(); } return; } event.preventDefault(); break; case 'Escape': event.preventDefault(); that.close(); break; } } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // LW('lw-color-input', class ColorInput extends LW.Input { static get properties() { return { 'dataSource': { type: 'any', value: null }, 'displayMode': { value: 'default', allowedValues: ['default', 'grid'], type: 'string' }, 'dropDownHeight': { type: 'any', value: 'auto' }, 'messages': { value: { 'en': { 'standardColors': 'Standard colors', 'themeShadeColors': '', 'themeColors': 'Theme colors' } }, type: 'object', extend: true }, 'placeholder': { value: 'Please Select Color', type: 'string' }, 'valueDisplayMode': { value: 'default', allowedValues: ['default', 'colorBox', 'colorCode'], type: 'string' }, 'valueFormat': { value: 'hex', allowedValues: ['rgb', 'rgba', 'hex'], type: 'string' } } } static get listeners() { return { 'input.focus': '_focusHandler', 'input.blur': '_blurHandler', 'input.keydown': '_keyDownHandler', 'input.keyup': '_keyUpHandler', 'input.keypress': '_keyPressHandler', 'input.select': '_inputSelectHandler', 'dropDownButton.down': '_dropDownButtonDownHandler', 'inputContainer.down': '_downHandler', 'document.up': '_documentUpHandler' }; } /** Button's template. */ template() { return `<div id="inputContainer" role="presentation"> <div class="lw-content"> <div class="lw-buttons-container" role="presentation" id="buttonsContainer"> <div class="lw-action-button" id="actionButton"> <div id="colorSampleContainer" class="lw-color-box color-picker-sample-container" role="presentation"> <div id="colorSample" class="color-picker-sample"></div> </div> <input class="lw-input lw-color-input" id='input' readonly='[[readonly]]' placeholder='[[placeholder]]' type='[[type]]' name='[[name]]' value='{{value::keyup}}' disabled='[[disabled]]' aria-label="[[placeholder]]" spellcheck="false" /> </div> <div id="dropDownButton" tabindex=-1 class="lw-drop-down-button" role="button" aria-label="Toggle popup"> <div id="arrow" class="lw-drop-down-button-icon" aria-hidden="true"></div> </div> </div> <span id="hint" class="lw-hint lw-hidden" inner-h-t-m-l="[[hint]]"></span> </div> </div>`; } open() { const that = this; let items; if (!that.dropDownDataSource) { items = typeof that.dropDownDataSource === 'function' ? that.dropDownDataSource(that.query) : that.dropDownDataSource; } else { that.query = ''; items = typeof that.dataSource === 'function' ? that.dataSource(that.query) : that.dataSource; } that._process(items); const active = that.$.menu.querySelector('.color-sample.selected'); if (active) { const dataValue = that.$.input.dataValue, items = that.$.menu.querySelectorAll('.color-sample'); for (let i = 0; i < items.length; i++) { const item = items[i]; const label = item.getAttribute('data-label'), value = item.getAttribute('value'); if (dataValue !== undefined && value === dataValue || dataValue === undefined && label === that.$.input.value) { active.removeAttribute('aria-current'); active.classList.remove('selected'); item.classList.add('selected'); item.setAttribute('aria-current', true); that._setActiveDescendant(item); that.$.input.dataValue = value; break; } } } that.ensureVisible(); that.$.input.focus(); setTimeout(function () { that.$.input.focus(); }, 25); } _blurHandler() { const that = this; if (!that.opened) { that.removeAttribute('focus'); that.$.actionButton.removeAttribute('focus'); that.$.dropDownButton.removeAttribute('focus'); } delete that._preventLookup; if (!that._isValidColor(that.value)) { that.$.input.value = that.$.input.dataValue = that.value = ''; that.$colorSampleContainer.addClass('no-color'); } } _focusHandler() { const that = this; that.setAttribute('focus', ''); that.$.actionButton.setAttribute('focus', ''); that.$.dropDownButton.setAttribute('focus', ''); if (!that.readonly && that.minLength === 0 && that.$.input.value.length === 0 && !that._preventLookup) { that._lookup(); return; } delete that._preventLookup; } _lookup(event) { const that = this; let items = []; that.query = that.$.input.value; if (that.$.input.readonly) { if (!that._incrementalSearchQuery) { that._incrementalSearchQuery = ''; } that._incrementalSearchQuery += event.key; if (that._incrementalSearchTimer) { clearTimeout(that._incrementalSearchTimer); } that.query = that._incrementalSearchQuery; that._incrementalSearchTimer = setTimeout(function () { that._incrementalSearchQuery = ''; }, 700); } if (that.query.length < that.minLength) { that.close(); return; } items = typeof that.dataSource === 'function' ? that.dataSource(that.query) : that.dataSource; clearTimeout(that._autoCompleteTimeout); that._autoCompleteTimeout = setTimeout(function () { const oldContext = that.context; that.context = that; that._process(items); that.context = oldContext; }, that.autoCompleteDelay); } /** * Returns the defaul colors */ _getDefaultColors() { const that = this; let colors = that._generateColors(); if (that.displayMode === 'grid') { return colors; } let colorList = []; for (let i = 0; i < colors.length; i++) { colorList = colorList.concat(Object.values(colors[i])[0]); } return colorList; } /** * Returns the defaul colors depending on the displayMode */ _generateColors() { const that = this; if (that.displayMode === 'default') { if (that._defaultModeColors) { return that._defaultModeColors; } return that._defaultModeColors = [ { 'themeColors': ['#FFFFFF', '#000000', '#E6E6E6', '#495469', '#5671C2', '#D48439', '#A5A5A5', '#EEC328', '#7399D3', '#85AA4C'] }, { 'themeShadeColors': [ '#F2F2F2', '#808080', '#D0CECE', '#D6DCE4', '#DDEBF7', '#FCE4D6', '#EBEBEB', '#FFF2CC', '#DDE5F7', '#E2EFDA', '#D8D8D8', '#595959', '#AEAAAA', '#ACB9CA', '#BDD7EE', '#F6CAAD', '#DBDBDB', '#FFE699', '#B4C6E7', '#C6E0B4', '#BFBFBF', '#404040', '#757171', '#8497B0', '#9BC2E6', '#F4B084', '#C0C0C0', '#FFD966', '#8EA9DB', '#A9D08E', '#A6A6A6', '#262626', '#312F2F', '#333F4F', '#2F75B5', '#C65911', '#7B7B7B', '#BF8F00', '#305496', '#548235', '#808080', '#0D0D0D', '#161616', '#222B35', '#1F4E78', '#833C0C', '#525252', '#806000', '#203764', '#375623' ] }, { 'standardColors': ['#A52A0D', '#DB3A15', '#EEC328', '#FEFE33', '#A6CD57', '#62AC54', '#65ADEE', '#3F6FBE', '#10205F', '#64379E'] } ] } else { if (that._gridColors) { return that._gridColors; } return that._gridColors = [ 'rgba(255, 255, 255, 0)', 'rgb(0, 0, 0)', 'rgb(153, 51, 0)', 'rgb(51, 51, 0)', 'rgb(0, 51, 0)', 'rgb(0, 51, 102)', 'rgb(0, 0, 128)', 'rgb(51, 51, 153)', 'rgb(51, 51, 51)', 'rgb(128, 0, 0)', 'rgb(255, 102, 0)', 'rgb(128, 128, 0)', 'rgb(0, 128, 0)', 'rgb(0, 128, 128)', 'rgb(0, 0, 255)', 'rgb(102, 102, 153)', 'rgb(128, 128, 128)', 'rgb(255, 0, 0)', 'rgb(255, 153, 0)', 'rgb(153, 204, 0)', 'rgb(51, 153, 102)', 'rgb(51, 204, 204)', 'rgb(51, 102, 255)', 'rgb(128, 0, 128)', 'rgb(153, 153, 153)', 'rgb(255, 0, 255)', 'rgb(255, 204, 0)', 'rgb(255, 255, 0)', 'rgb(0, 255, 0)', 'rgb(0, 255, 255)', 'rgb(0, 204, 255)', 'rgb(153, 51, 102)', 'rgb(192, 192, 192)', 'rgb(255, 153, 204)', 'rgb(255, 204, 153)', 'rgb(255, 255, 153)', 'rgb(204, 255, 204)', 'rgb(204, 255, 255)', 'rgb(153, 204, 255)', 'rgb(204, 153, 255)', 'rgb(255, 255, 255)']; } } _downHandler(event) { const that = this; if (that.readonly || event.originalEvent.target.closest('.lw-color-box')) { that._dropDownButtonDownHandler(event); } } _documentUpHandler(event) { const that = this; const target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (target === that || target.closest && target.closest('.lw-buttons-container') === that.$.buttonsContainer) { return; } if (that.$.scrollView.contains(target.shadowParent || target)) { if (that._isPointerDown) { that._isPointerDown = false; if (that.opened) { that._preventLookup = true; } that.$.input.focus(); } return; } if (that.opened) { that._preventLookup = true; } that._isPointerDown = false; that.close(); } _formatValue(value) { const that = this; if (!that._isValidColor(value)) { return ''; } const color = that._getRGBA(value); switch (that.valueFormat) { case 'hex': value = that._rgbArrayToHEX([color.r, color.g, color.b, color.a]); break; case 'rgb': value = 'rgb(' + color.r + ', ' + color.g + ', ' + color.b + ')'; break; case 'rgba': value = (color.r !== null && color.g !== null && color.b !== null) ? 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + color.a + ')' : null; break; } return value || null; } _getRGBA(value) { const that = this, color = value || that.value; let alpha = 1; if (color) { if (that._isRGBA(color) && /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.test(color.replace(/\s/g, ''))) { alpha = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(color.replace(/\s/g, ''))[4]; } else if (that._isHEX(value) && /(^#[0-9A-F]{8}$)/gi.test(value.replace(/\s/g, ''))) { alpha = parseInt(/(^#[0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2}$)/gi.exec(value.replace(/\s/g, ''))[4], 16) / 255; } alpha = Math.min(1, Math.max(0, parseFloat(alpha))); if (isNaN(alpha)) { alpha = 1; } } value = that._HSVtoRGBA(that._colorToHSV(color), alpha); const rgbaFragments = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(value.replace(/\s/g, '')); return { r: parseInt(rgbaFragments[1]), g: parseInt(rgbaFragments[2]), b: parseInt(rgbaFragments[3]), a: parseFloat(rgbaFragments[4]) }; } _colorToHSV(value) { const that = this; if (!that._isValidColor(value)) { return; } value = that._toRGBA(value).replace(/\s/g, ''); const rgbaFragments = /rgba\((\d*.\d+|\d+),(\d*.\d+|\d+),(\d*.\d+|\d+)\,(\d*.\d+|\d+)\)/gi.exec(value), r = Math.min(255, Math.max(0, parseFloat(rgbaFragments[1]))) / 255, g = Math.min(255, Math.max(0, parseFloat(rgbaFragments[2]))) / 255, b = Math.min(255, Math.max(0, parseFloat(rgbaFragments[3]))) / 255; let hsv = { h: 0, s: 0, v: 0 }, min = 0, max = 0; if (r >= g && r >= b) { max = r; min = (g > b) ? b : g; } else if (g >= b && g >= r) { max = g; min = (r > b) ? b : r; } else { max = b; min = (g > r) ? r : g; } hsv.v = max; hsv.s = max ? ((max - min) / max) : 0; if (!hsv.s) { hsv.h = 0; } else { const delta = max - min; if (r === max) { hsv.h = (g - b) / delta; } else if (g === max) { hsv.h = 2 + (b - r) / delta; } else { hsv.h = 4 + (r - g) / delta; } //hsv.h = Math.round(hsv.h * 60); hsv.h = hsv.h * 60; if (hsv.h < 0) { hsv.h += 360; } } hsv.s = parseFloat(hsv.s); hsv.v = parseFloat(hsv.v); return hsv; } _rgbArrayToHEX(color) { let hex = '#'; if (Array.isArray(color) && color[0] === null) { return null; } for (let i = 0; i < 3; i++) { let hexI = parseInt(color[i]).toString(16).toUpperCase(); hexI = hexI.length === 1 ? 0 + hexI : hexI; hex = hex + hexI; } let alpha = parseFloat(color[3]); if (!isNaN(alpha)) { alpha = parseInt((alpha * 255)).toString(16).toUpperCase(); if (alpha !== 'FF') { hex = hex.slice(0, 7) + (alpha.length === 1 ? 0 + alpha : alpha); } } return hex; } _HSVtoRGBA(hsv, a) {// to return RGBA array or RGBA object!!! hsv = hsv || { h: 0, s: 0, v: 0 }; const that = this, h = hsv.h, s = hsv.s, v = hsv.v; let chroma = v * s, hue = h / 60, x = chroma * (1 - Math.abs((hue % 2) - 1)), r1, g1, b1; if (hue >= 0 && hue <= 1) { ([r1, g1, b1] = [chroma, x, 0]); } else if (hue >= 1 && hue <= 2) { ([r1, g1, b1] = [x, chroma, 0]); } else if (hue >= 2 && hue <= 3) { ([r1, g1, b1] = [0, chroma, x]); } else if (hue >= 3 && hue <= 4) { ([r1, g1, b1] = [0, x, chroma]); } else if (hue >= 4 && hue <= 5) { ([r1, g1, b1] = [x, 0, chroma]); } else if (hue >= 5 && hue <= 6) { ([r1, g1, b1] = [chroma, 0, x]); } const m = v - chroma, r = Math.round((r1 + m) * 255), g = Math.round((g1 + m) * 255), b = Math.round((b1 + m) * 255); return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + (a !== undefined ? a : (that._getRGBA().a || 0)) + ')'; } /* * Transform RGB/HEX/color to RGBA */ _toRGBA(value, ignoreAlpha) { const that = this; let val = that.value; function hexToRgba(value) { const shortHexResult = /^#(.)(.)(.)$/gi.exec(value), longHexResult = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(value), r = shortHexResult ? parseInt(shortHexResult[1] + shortHexResult[1], 16) : parseInt(longHexResult[1], 16), g = shortHexResult ? parseInt(shortHexResult[2] + shortHexResult[2], 16) : parseInt(longHexResult[2], 16), b = shortHexResult ? parseInt(shortHexResult[3] + shortHexResult[3], 16) : parseInt(longHexResult[3], 16), a = shortHexResult ? parseInt(shortHexResult[4] + shortHexResult[4], 16) : parseInt(longHexResult[4], 16); if (ignoreAlpha) { return 'rgba(' + r + ', ' + g + ', ' + b + ', 1)'; } return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + (isNaN(a) ? '1' : (a / 255)) + ')'; } if (that._isRGBA(value)) { if (ignoreAlpha) { let rgb = value.match(/(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})/gi); return 'rgba(' + rgb + ', 1)'; } return value; } if (that._isValidColorName(value)) { val = hexToRgba(that._cssColorNamesHEX[value.trim().toLowerCase()]); } else if (that._isHEX(value)) { val = hexToRgba(value); } else if (that._isRGB(value)) { val = value.toLowerCase(); val = val.replace('rgb', 'rgba'); val = val.replace(')', ', ' + 1 + ')'); } else { return false; } return val; } /** * Checks if the value is HEX * @param {any} value */ _isHEX(value) { return /(^#[0-9A-F]{3}$)|(^#[0-9A-F]{6}$)|(^#[0-9A-F]{8}$)/i.test(value); } /** * Checks if the value is RGB * @param {any} value */ _isRGB(value) { return /rgb\((\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\)/i.test(value); } _isValidColorName(value) { return (!value || typeof this._cssColorNamesHEX[value.trim().toLowerCase()] === 'undefined') ? false : true; } /** * Checks if the value is RGBA * @param {any} value */ _isRGBA(value) { return /rgba\((\d*.\d+|\d+)\s*,\s*(\d*.\d+|\d+)\s*,\s*(\d*.\d+|\d+)\s*,\s*(\d*.\d+|\d+)\)/i.test(value); } /** * Checks if the color is valid * @param {any} value */ _isValidColor(value) { return this._isHEX(value) || this._isRGB(value) || this._isRGBA(value) || this._isValidColorName(value); } _performSelect() { const that = this; const targetItem = that.$.menu.querySelector('.selected') || that.$.menu.querySelector('.color-sample'), label = targetItem.getAttribute('data-label'), value = targetItem.getAttribute('value'), oldLabel = that.value, oldValue = that.$.input.dataValue; that.value = that.$.colorSample.style.backgroundColor = that._formatValue(label); that.$.input.dataValue = value; if (that.value) { that.$colorSampleContainer.removeClass('no-color'); that.$.colorSample.setAttribute('aria-label', that.value); } else { that.$colorSampleContainer.addClass('no-color'); that.$.colorSample.setAttribute('aria-label', 'No color'); } targetItem.classList.add('selected'); targetItem.setAttribute('aria-current', true); if (label !== oldLabel || value !== oldValue) { that.$.fireEvent('change', { value: value, label: label, oldValue: oldValue, oldLabel: oldLabel }); } that.close(); } _process(items) { const that = this; if (!items) { items = []; } items = items.slice(0); if (typeof items === 'string') { items = that.$.deserialize(items, 'array'); } if (that.matcher) { items = items.filter(item => that.matcher(item) > -1); } else if (that.query) { let colorNames = []; for (let prop in that._cssColorNamesHEX) { if (that._matcher(prop, true) > -1) { colorNames.push(that._cssColorNamesHEX[prop]); } } if (colorNames.length) { items = colorNames; } else { if (!items.length && (that.dataSource === null || that.dataSource === undefined)) { let colors = that._generateColors(); if (that.displayMode === 'default') { colors = [].concat.apply([], colors.map(colorGroup => Object.values(colorGroup)[0])); } items = colors.filter(item => that._matcher(item) > -1); } else { items = items.filter(item => that._matcher(item) > -1); } } } items = that._sorter(items); if (!items.length && that.opened) { that.close(); } if (that.query.length > 0 && !items.length || !items.length && that.dataSource !== null && that.dataSource !== undefined) { return; } if (that.query.length > 0) { that._render(items.slice(0, that.items)); } else { that._render(items); } that._open(); that._refreshMenu(); that.ensureVisible(); } _matcher(item, noFormatting) { const that = this; const text = that.query; item = noFormatting ? (item.label || item) : that._formatValue(item.label || item); if (!text) { return -1; } switch (that.queryMode) { case 'startsWith': return item.startsWith(text); case 'startsWithIgnoreCase': return item.toLowerCase().startsWith(text.toLowerCase()); case 'doesNotContain': return item.indexOf(text) < 0; case 'doesNotContainIgnoreCase': return item.toLowerCase().indexOf(text.toLowerCase()) < 0; case 'contains': return item.indexOf(text) > -1; default: case 'containsIgnoreCase': return item.toLowerCase().indexOf(text.toLowerCase()); case 'equals': return item.localeCompare(text) === 0; case 'equalsIgnoreCase': return (item.toLowerCase().localeCompare(text.toLowerCase()) === 0); case 'endsWith': return item.endsWith(text); case 'endsWithIgnoreCase': return item.toLowerCase().endsWith(text.toLowerCase()); } } _render(items) { const that = this; that.$.menu.innerHTML = ''; if (items.length) { that.$.menu.appendChild(that._createColorGroup(that._createColorSamples(items))); } else if ((that.dataSource === null || that.dataSource === undefined) && !that.query.length) { items = that._generateColors(); if (that.displayMode === 'default') { const defaultModeColors = that._generateColors(); for (let i = 0; i < defaultModeColors.length; i++) { const colorGroup = Object.keys(defaultModeColors[i])[0], colors = Object.values(defaultModeColors[i])[0]; const colorGroupLabel = document.createElement('div'); colorGroupLabel.classList.add('standard-colors-label'); colorGroupLabel.innerHTML = that.localize(colorGroup); colorGroupLabel.id = that.id + colorGroup + 'Label'; that.$.menu.appendChild(colorGroupLabel); that.$.menu.appendChild(that._createColorGroup(that._createColorSamples(colors), colorGroup + 'Label')); } } else { that.$.menu.appendChild(that._createColorGroup(that._createColorSamples(items))); } } } _createColorGroup(colorSamples, groupName) { const that = this; const colorGroup = document.createElement('div'); function setActiveState() { const previouslyActive = that.$.menu.getElementsByClassName('selected'); if (previouslyActive[0]) { previouslyActive[0].removeAttribute('aria-current'); previouslyActive[0].classList.remove('selected'); } this.classList.add('selected'); this.setAttribute('aria-current', true); that._setActiveDescendant(this); } colorGroup.classList.add('grid-samples-container'); colorGroup.setAttribute('role', 'menu'); if (groupName) { colorGroup.setAttribute('aria-labelledby', that.id + groupName); } for (let i = 0; i < colorSamples.length; i++) { const colorSample = colorSamples[i]; colorGroup.appendChild(colorSample); colorSample.onmouseenter = setActiveState; colorSample.onclick = setActiveState; colorSample.onmouseleave = function () { this.removeAttribute('aria-current'); this.classList.remove('selected'); that._setActiveDescendant(null); } } return colorGroup; } _createColorSamples(items) { const that = this; let colorSamples = []; for (let i = 0; i < items.length; i++) { const item = items[i]; let label = item, value = item; if (typeof item === 'object') { label = item.label; value = item.value || label; } const colorSample = document.createElement('div'); colorSample.id = that.id + 'Item' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1); colorSample.setAttribute('data-label', label); colorSample.setAttribute('value', value); colorSample.setAttribute('role', 'menuitem'); colorSample.setAttribute('aria-label', label); colorSample.classList.add('color-sample'); colorSample.style.backgroundColor = label; if (label === 'rgba(255, 255, 255, 0)' || label === '#FFFFFF00' || label === 'transparent') { colorSample.setAttribute('transparent', ''); } else { colorSample.removeAttribute('transparent'); } colorSamples.push(colorSample); } if (colorSamples.length > 0 && !that.$.menu.querySelector('.selected')) { colorSamples[0].classList.add('selected'); colorSamples[0].setAttribute('aria-current', true); that._setActiveDescendant(colorSamples[0]); } return colorSamples; } ensureVisible() { const that = this; const item = that.$.menu.querySelector('.color-sample.selected'); if (!item) { return; } } _next() { const that = this; const active = that.$.menu.querySelector('.color-sample.selected'); if (!active) { const first = that.$.menu.querySelector('.color-sample'); first.classList.add('selected'); first.setAttribute('aria-current', true); that._setActiveDescendant(first); return; } active.removeAttribute('aria-current'); active.classList.remove('selected'); let next = active.nextElementSibling; if (!next) { let colorSamplesContainer = active.parentElement.nextElementSibling; while (colorSamplesContainer) { if (colorSamplesContainer.classList.contains('grid-samples-container')) { next = colorSamplesContainer.children[0]; break; } else { colorSamplesContainer = colorSamplesContainer.nextElementSibling; } } if (!next) { next = that.$.menu.querySelector('.color-sample'); } } next.classList.add('selected'); next.setAttribute('aria-current', true); that._setActiveDescendant(next); that.ensureVisible(); } _prev() { const that = this; const active = that.$.menu.querySelector('.color-sample.selected'); if (!active) { const first = that.$.menu.querySelector('.color-sample'); first.classList.add('selected'); first.setAttribute('aria-current', true); that._setActiveDescendant(first); return; } active.removeAttribute('aria-current'); active.classList.remove('selected'); let prev = active.previousElementSibling; if (!prev) { let colorSamplesContainer = active.parentElement.previousElementSibling; while (colorSamplesContainer) { if (colorSamplesContainer.classList.contains('grid-samples-container')) { prev = colorSamplesContainer.children[colorSamplesContainer.children.length - 1]; break; } else { colorSamplesContainer = colorSamplesContainer.previousElementSibling; } } if (!prev) { prev = that.$.menu.querySelector('.grid-samples-container:last-of-type .color-sample:last-of-type'); } } prev.classList.add('selected'); prev.setAttribute('aria-current', true); that._setActiveDescendant(prev); that.ensureVisible(); } _move(event) { const that = this; if (!that.opened) { return; } switch (event.keyCode) { case 9: // tab case 13: // enter case 27: // escape event.preventDefault() break case 37: // left arrow case 38: // up arrow event.preventDefault() that[that.rightToLeft ? '_next' : '_prev'](); break case 39: // right arrow case 40: // down arrow event.preventDefault() that[that.rightToLeft ? '_prev' : '_next'](); break } event.stopPropagation() } _inputSelectHandler() { const that = this; if (that.readonly) { that.$.input.selectionStart = that.$.input.selectionEnd; } } _keyDownHandler(event) { const that = this; that._suppressKeyPressRepeat = ![37, 38, 39, 40, 9, 13, 27, 16, 17, 18].includes(event.keyCode); if (event.shiftKey || event.ctrlKey) { return; } if (event.altKey) { if (event.key === 'ArrowUp') { that.close(); } else if (event.key === 'ArrowDown') { that.open(); } return; } that._move(event); } _keyUpHandler(event) { const that = this; if (event.shiftKey || event.altKey || event.ctrlKey) { return; } switch (event.keyCode) { case 40: // down arrow case 39: // right arrow case 38: // up arrow case 37: // left arrow case 16: // shift case 17: // ctrl case 18: // alt if (event.keyCode === 40 && event.altKey) { that.open(); } if (event.keyCode === 38 && event.altKey) { that.close(); } break; case 9: // tab case 13: // enter if (!that.opened) { if (event.keyCode === 13) { that.open(); } return; } that._performSelect(); event.stopPropagation() event.preventDefault() break case 27: // escape if (!that.opened) { return; } that.close(); event.stopPropagation() event.preventDefault() break default: if (that.readonly) { if (event.keyCode === 32 && !that.opened) { that.open(); } return; } that._lookup(event); if (that.opened && !event.ctrlKey && !event.shiftKey) { event.stopPropagation() event.preventDefault() } that.$.input.dataValue = that.$.input.value; if (!that._isValidColor(that.value)) { that.$colorSampleContainer.addClass('no-color'); that.$.colorSample.setAttribute('aria-label', 'No color'); that.$.colorSample.style.backgroundColor = ''; } } } propertyChangedHandler(propertyName, oldValue, newValue) { super.propertyChangedHandler(propertyName, oldValue, newValue); const that = this; if (propertyName === 'dropDownHeight') { that.$.scrollView.style.setProperty('--lw-input-drop-down-menu-height', that.dropDownHeight + 'px'); } else if (propertyName === 'opened') { that.opened = oldValue; if (newValue) { that.open(); } else { that.close(); } } else if (propertyName === 'placeholder') { if (that.readonly) { const label = that.getAttribute('aria-label'); if (label && label !== oldValue) { return; } if (newValue) { that.setAttribute('aria-label', newValue); } else { that.removeAttribute('aria-label'); } } } else if (propertyName === 'readonly') { that._setAriaRelations(); } else if (propertyName === 'theme') { that.$.scrollView.setAttribute(propertyName, newValue); } else if (propertyName === 'rightToLeft') { newValue ? that.$.scrollView.setAttribute('right-to-left', '') : that.$.scrollView.removeAttribute('right-to-left'); } else if (propertyName === 'valueFormat') { that.value = that._formatValue(that.value); that.$.input.dataValue = that.value; } else if (propertyName === 'displayMode') { that.open(); } else if (propertyName === 'value') { that.set('value', that.$.input.dataValue = that.$.colorSample.style.backgroundColor = that._formatValue(newValue)); if (!that.value) { that.$colorSampleContainer.addClass('no-color'); } } } /** * Called inside the render method of the Base class */ _createElement() { const that = this, menu = document.createElement('div'), scrollView = document.createElement('div'); scrollView.classList.add('lw-color-input-drop-down-menu', 'lw-color-panel'); scrollView.setAttribute('theme', that.theme); that.$.scrollView = scrollView; that.rightToLeft ? that.$.scrollView.setAttribute('right-to-left', '') : that.$.scrollView.removeAttribute('right-to-left'); that.$.menu = menu; that.$.menu.classList.add('default-samples-container', 'grid-mode-container', 'lw-container'); that.$.scrollView.onclick = function (event) { event.stopPropagation() event.preventDefault() that._performSelect(); that.$.input.focus(); } that.classList.add('lw-drop-down-box', 'lw-color-picker'); if (that.value) { that.$colorSampleContainer.removeClass('no-color'); that.$.colorSample.setAttribute('aria-label', that.value); } else { that.$colorSampleContainer.addClass('no-color'); that.$.colorSample.setAttribute('aria-label', 'No color'); } that._cssColorNamesHEX = { 'aliceblue': '#f0f8ff', 'antiquewhite': '#faebd7', 'aqua': '#00ffff', 'aquamarine': '#7fffd4', 'azure': '#f0ffff', 'beige': '#f5f5dc', 'bisque': '#ffe4c4', 'black': '#000000', 'blanchedalmond': '#ffebcd', 'blue': '#0000ff', 'blueviolet': '#8a2be2', 'brown': '#a52a2a', 'burlywood': '#deb887', 'cadetblue': '#5f9ea0', 'chartreuse': '#7fff00', 'chocolate': '#d2691e', 'coral': '#ff7f50', 'cornflowerblue': '#6495ed', 'cornsilk': '#fff8dc', 'crimson': '#dc143c', 'cyan': '#00ffff', 'darkblue': '#00008b', 'darkcyan': '#008b8b', 'darkgoldenrod': '#b8860b', 'darkgray': '#a9a9a9', 'darkgreen': '#006400', 'darkkhaki': '#bdb76b', 'darkmagenta': '#8b008b', 'darkolivegreen': '#556b2f', 'darkorange': '#ff8c00', 'darkorchid': '#9932cc', 'darkred': '#8b0000', 'darksalmon': '#e9967a', 'darkseagreen': '#8fbc8f', 'darkslateblue': '#483d8b', 'darkslategray': '#2f4f4f', 'darkturquoise': '#00ced1', 'darkviolet': '#9400d3', 'deeppink': '#ff1493', 'deepskyblue': '#00bfff', 'dimgray': '#696969', 'dodgerblue': '#1e90ff', 'firebrick': '#b22222', 'floralwhite': '#fffaf0', 'forestgreen': '#228b22', 'fuchsia': '#ff00ff', 'gainsboro': '#dcdcdc', 'ghostwhite': '#f8f8ff', 'gold': '#ffd700', 'goldenrod': '#daa520', 'gray': '#808080', 'green': '#008000', 'greenyellow': '#adff2f', 'honeydew': '#f0fff0', 'hotpink': '#ff69b4', 'indianred ': '#cd5c5c', 'indigo': '#4b0082', 'ivory': '#fffff0', 'khaki': '#f0e68c', 'lavender': '#e6e6fa', 'lavenderblush': '#fff0f5', 'lawngreen': '#7cfc00', 'lemonchiffon': '#fffacd', 'lightblue': '#add8e6', 'lightcoral': '#f08080', 'lightcyan': '#e0ffff', 'lightgoldenrodyellow': '#fafad2', 'lightgrey': '#d3d3d3', 'lightgreen': '#90ee90', 'lightpink': '#ffb6c1', 'lightsalmon': '#ffa07a', 'lightseagreen': '#20b2aa', 'lightskyblue': '#87cefa', 'lightslategray': '#778899', 'lightsteelblue': '#b0c4de', 'lightyellow': '#ffffe0', 'lime': '#00ff00', 'limegreen': '#32cd32', 'linen': '#faf0e6', 'magenta': '#ff00ff', 'maroon': '#800000', 'mediumaquamarine': '#66cdaa', 'mediumblue': '#0000cd', 'mediumorchid': '#ba55d3', 'mediumpurple': '#9370d8', 'mediumseagreen': '#3cb371', 'mediumslateblue': '#7b68ee', 'mediumspringgreen': '#00fa9a', 'mediumturquoise': '#48d1cc', 'mediumvioletred': '#c71585', 'midnightblue': '#191970', 'mintcream': '#f5fffa', 'mistyrose': '#ffe4e1', 'moccasin': '#ffe4b5', 'navajowhite': '#ffdead', 'navy': '#000080', 'oldlace': '#fdf5e6', 'olive': '#808000', 'olivedrab': '#6b8e23', 'orange': '#ffa500', 'orangered': '#ff4500', 'orchid': '#da70d6', 'palegoldenrod': '#eee8aa', 'palegreen': '#98fb98', 'paleturquoise': '#afeeee', 'palevioletred': '#d87093', 'papayawhip': '#ffefd5', 'peachpuff': '#ffdab9', 'peru': '#cd853f', 'pink': '#ffc0cb', 'plum': '#dda0dd', 'powderblue': '#b0e0e6', 'purple': '#800080', 'rebeccapurple': '#663399', 'red': '#ff0000', 'rosybrown': '#bc8f8f', 'royalblue': '#4169e1', 'saddlebrown': '#8b4513', 'salmon': '#fa8072', 'sandybrown': '#f4a460', 'seagreen': '#2e8b57', 'seashell': '#fff5ee', 'sienna': '#a0522d', 'silver': '#c0c0c0', 'skyblue': '#87ceeb', 'slateblue': '#6a5acd', 'slategray': '#708090', 'snow': '#fffafa', 'springgreen': '#00ff7f', 'steelblue': '#4682b4', 'tan': '#d2b48c', 'teal': '#008080', 'thistle': '#d8bfd8', 'tomato': '#ff6347', 'turquoise': '#40e0d0', 'violet': '#ee82ee', 'wheat': '#f5deb3', 'white': '#ffffff', 'whitesmoke': '#f5f5f5', 'yellow': '#ffff00', 'yellowgreen': '#9acd32' }; } /** * Sets WAI-ARIA relations. */ _setAriaRelations() { const that = this, label = that.getAttribute('aria-label'); if (that.readonly) { that.setAttribute('role', 'button'); if (!label && that.placeholder) { that.setAttribute('aria-label', that.placeholder); } that.$.input.setAttribute('aria-hidden', true); that.$.input.removeAttribute('aria-activedescendant'); that.$.input.removeAttribute('aria-controls'); that.$.dropDownButton.setAttribute('aria-hidden', true); } else { that.setAttribute('role', 'combobox'); if (label && label === that.placeholder) { that.removeAttribute('aria-label'); } that.$.input.setAttribute('role', 'searchbox'); that.$.input.removeAttribute('aria-hidden', true); that.$.dropDownButton.removeAttribute('aria-hidden'); } that.setAttribute('aria-expanded', that.opened); that.setAttribute('aria-haspopup', 'listbox'); that.$.scrollView.setAttribute('role', 'listbox'); } }); /* LW UI v7.7.1 (2020-July) Copyright (c) 2011-2020 jQWidgets. License: https://htmlelements.com/license/ */ // /** * lwWindow custom element. */ LW('lw-window', class Window extends LW.ContentElement { /** * Element's properties */ static get properties() { return { 'collapsed': { value: false, type: 'boolean' }, 'closeOnMaskClick': { value: false, type: 'boolean' }, 'disableSnap': { value: false, type: 'boolean' }, 'footerPosition': { value: 'bottom', allowedValues: ['bottom', 'none'], type: 'string' }, 'footerTemplate': { value: null, type: 'any' }, 'headerButtons': { value: ['close', 'maximize', 'minimize'], //Default built-in buttons: ['close', 'collapse', 'pin' 'maximize', 'minimize'] type: 'array' }, 'headerPosition': { value: 'top', allowedValues: ['top', 'bottom', 'left', 'right', 'none'], type: 'string' }, 'headerTemplate': { value: null, type: 'any' }, 'label': { value: '', type: 'string' }, 'liveResize': { value: false, type: 'boolean' }, 'maximized': { value: false, type: 'boolean' }, 'modal': { value: false, type: 'boolean' }, 'minimized': { value: false, type: 'boolean' }, 'opened': { value: false, type: 'boolean' }, 'pinned': { value: false, type: 'boolean' }, 'resizeIndicator': { value: false, type: 'boolean' }, 'resizeMode': { allowedValues: ['none', 'horizontal', 'vertical', 'both', 'top', 'bottom', 'left', 'right'], value: 'none', type: 'string' }, 'windowParent': { value: null, type: 'any' } } } /** * Element's event listeners. */ static get listeners() { return { 'document.dragstart': '_dragStartHandler', 'document.focusin': '_documentFocusInEventHandler', 'document.move': '_documentMoveHandler', 'document.up': '_documentUpHandler', 'document.wheel': '_mouseWheelHandler', 'document.selectstart': '_documentSelectStartHandler', 'down': '_downHandler', 'focus': '_focusHandler', 'blur': '_focusHandler', 'move': '_moveHandler', 'keydown': '_keyDownHandler', 'keyup': '_keyUpHandler' } } /** * Disables the styleObserver */ get hasStyleObserver() { return false; } /** * CSS files needed for the element (ShadowDOM) */ static get styleUrls() { return [ 'lw.button.css', 'lw.window.css' ] } /** * Element's HTML template. */ template() { return `<div role="presentation"> <div class="lw-content-container" id="container"> <div id="headerSection" class="lw-header-section" role="heading" aria-level="1"> <div id="header" class="lw-header" role="presentation">[[label]]</div> <div id="buttonsContainer" class="lw-buttons-container" role="presentation"> <button id="pinButton" class="lw-button lw-element lw-pin-button" aria-label="Pin"></button> <button id="collapseButton" class="lw-button lw-element lw-collapse-button" aria-label="Collapse"></button> <button id="minimizeButton" class="lw-button lw-element lw-minimize-button"aria-label="Minimize"></button> <button id="maximizeButton" class="lw-button lw-element lw-maximize-button" aria-label="Maximize"></button> <button id="closeButton" class="lw-button lw-element lw-close-button" aria-label="Close"></button> </div> </div> <div class="lw-content" inner-h-t-m-l="[[innerHTML]]"><content></content></div> <div id="footer" class="lw-footer"></div> </div> </div>`; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'collapsed': newValue ? that.collapse(true) : that.expand(true); break; case 'disabled': case 'unfocusable': that._setFocusable(); break; case 'headerTemplate': case 'footerTemplate': that._applyLayoutTemplate(that.$[propertyName.split(/[T]/)[0]], newValue); break; case 'headerButtons': that._setHeaderButtons(); break; case 'headerPosition': { const isMinimized = that.minimized; that._preventEventFiring = true; that.restore(); delete that._preventEventFiring; if (isMinimized) { that.minimize(); } break; } case 'label': that.$.header.innerHTML = that.label; break; case 'maximized': newValue ? that.maximize(true) : that.restore(propertyName); break; case 'modal': that._setModal(); that.setAttribute('aria-modal', newValue); break; case 'minimized': newValue ? that.minimize(true) : that.restore(propertyName); break; case 'opened': newValue ? that.open(true) : that.close(true); break; case 'resizeMode': //Reset the resizing indicator that.$.container.classList.remove('lw-window-resizing-bottom-right', 'lw-window-resizing-top-right', 'lw-window-resizing-top-left', 'lw-window-resizing-bottom-left', 'lw-window-resizing-top', 'lw-window-resizing-bottom', 'lw-window-resizing-left', 'lw-window-resizing-right'); break; case 'windowParent': that._setElementParent(newValue); break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Element's ready method. */ ready() { super.ready(); const that = this; that._windowParent = { initialParent: that.parentElement }; } render() { const that = this, animationType = that.animation; if (!that.$.header.id) { that.$.header.id = that.id + 'Header'; } if (!that.$.content.id) { that.$.content.id = that.id + 'Content'; } if (!that.opened) { that.animation = 'none'; } that._windowParent = { initialParent: that.parentElement }; that.$.addClass('lw-window'); that._createElement(); that._setElementParent(that.windowParent); //Remove if added to attached method that._setHeaderButtons(); if (that.headerTemplate) { that._applyLayoutTemplate(that.$.header, that.headerTemplate); } if (that.footerTemplate) { that._applyLayoutTemplate(that.$.footer, that.footerTemplate); } that.opened ? that.open() : that.close(); if (that.maximized) { that.maximize(true); } if (that.minimized) { that.minimize(true); } if (that.collapsed) { that.collapse(true); } that.pinned ? that.pin() : that.unpin(); that._setFocusable(); that.animation = animationType; that.setAttribute('aria-modal', that.modal); that.setAttribute('aria-labelledby', that.$.header.id); super.render(); } /** * Checks for missing modules. */ static get requires() { return { 'LW.Button': 'lw.button.js' } } /** * Sets tab index */ _setFocusable() { const that = this; if (!that.disabled && !that.unfocusable) { let index = that.tabIndex > 0 ? that.tabIndex : 0; that.setAttribute('tabindex', index); } else { that.removeAttribute('tabindex'); } } /** * Appends an HTML element content section of the Window. */ appendChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' })); return } that.$.content.appendChild(node); } /** * Collapses the window */ collapse(propertyChange) { const that = this; if (!propertyChange && that.collapsed) { return; } that.collapsed = true; that.$.fireEvent('collapse'); if (that.headerPosition === 'left' || that.headerPosition === 'right') { that.style.width = ''; } else { that.style.height = ''; } } /** * Closes the window */ close(propertyChange) { const that = this; if (!propertyChange && that.$.hasClass('lw-visibility-hidden')) { return; } if (that.isCompleted) { const isOpeningEventPrevented = that.$.fireEvent('closing').defaultPrevented; if (isOpeningEventPrevented) { return; } that.$.addClass('lw-visibility-hidden'); that.opened = false; if (that.isRendered) { that.$.fireEvent('close'); } } else { that.$.addClass('lw-visibility-hidden'); that.opened = false; } that._setModal(); that.removeAttribute('ontop'); } /** * Element's Attached method */ attached() { super.attached(); const that = this; if (!that.isRendered) { // return; } //MoveHandler not working, if enabled. Reason: Appending twice to the same parent. //that._setElementParent(that.windowParent); if (that._windowParent.parent && that._windowParent.parent !== that.getShadowRootOrBody() && that._windowParent.parent.querySelectorAll('lw-window, lw-dialog-window, lw-progress-window, lw-wait-window, ' + 'lw-alert-window, lw-prompt-window, lw-multiline-prompt-window')) { const windowParentPosition = window.getComputedStyle(that._windowParent.parent).getPropertyValue('position'); if (windowParentPosition === 'static') { that._windowParent.parent.style.position = 'relative'; } } if (that.opened && that._modal) { that.parentElement.insertBefore(that._modal, that); } } /** * Sets the window to the top level so the user can interact with it */ bringToFront() { const that = this; if (!that.parentElement) { return; } const parentWindow = that.parentElement.closest('.lw-window'); if (parentWindow) { parentWindow.bringToFront(); return; } const windows = document.body.getElementsByClassName('lw-window'); let openedWindows = []; for (let w = 0; w < windows.length; w++) { const win = windows[w]; win.removeAttribute('ontop'); if (win.opened) { openedWindows.push(win); } } if (openedWindows.length === 1 && openedWindows[0] === that) { return; } that.setAttribute('ontop', ''); } /** * Clears the content of the Window */ clear() { const that = this; if (!that.isCompleted || that.nodeName !== 'LW-WINDOW') { return; } that.$.content.innerHTML = ''; } /** * Element's Detached method */ detached() { super.detached(); const that = this; if (that._windowParent.parent && !that._windowParent.parent.querySelectorAll('lw-window, lw-dialog-window, lw-progress-window, lw-wait-window, ' + 'lw-alert-window, lw-prompt-window, lw-multiline-prompt-window')) { that._windowParent.parent.style.position = ''; } if (that._modal && that._modal.parentElement) { that._modal.parentElement.removeChild(that._modal); } if (that._resizeDummy && that._resizeDummy.parentElement) { that._handleWindowResizeDummy(); } that._refreshMinimizedWindowsPosition(); } /** * Expands the window */ expand(propertyChange) { const that = this; if (!propertyChange && !that.collapsed) { return; } that.collapsed = false; that.$.fireEvent('expand'); if (that.maximized) { if (that.headerPosition === 'left' || that.headerPosition === 'right') { //In Safari and EDGE there is a bug. If scrollHeight < clientHeight, scrollHeight is not correct that.style.width = (Math.max(that._windowParent.scrollElement.scrollWidth, that._windowParent.element.clientWidth) - that._windowParent.borderWidth) + 'px'; } else { that.style.height = (Math.max(that._windowParent.scrollElement.scrollHeight, that._windowParent.element.clientHeight) - that._windowParent.borderWidth) + 'px'; } } else { if (that.headerPosition === 'left' || that.headerPosition === 'right') { that.style.width = that.className.indexOf('lw-window-snapped-') < 0 && that._dragDetails ? that._dragDetails.width + 'px' : ''; } else { that.style.height = that.className.indexOf('lw-window-snapped-') < 0 && that._dragDetails ? that._dragDetails.height + 'px' : ''; } } } /** * Maximizes the window */ maximize(propertyChange) { const that = this; //Fixes the issue where maximizing a window that overflows the viewport ( scrollbars are rendered ) with animation causes inproper height/width calculation if the scrollbars get hidden function transitionHandler() { if (!that.maximized || !that.hasAnimation) { return; } const scrollHeight = that._windowParent.scrollElement.scrollHeight, clientHeight = that._windowParent.element.clientHeight, totalParentHeight = Math.max(scrollHeight, clientHeight); if (that.headerPosition === 'top' || that.headerPosition === 'bottom') { if (!that.collapsed) { that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%'; } } else { that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%'; } that.removeEventListener('transitionend', transitionHandler); } if (!propertyChange && that.maximized) { return; } if (that.minimized) { that._restoreFromMinimization(propertyChange); } //Save the current size and position before maximizing that._setDragDetails('minimize'); //Remove resizing indicator classes if added if (that.resizeMode !== 'none') { that.$.container.classList.remove('lw-window-resizing-bottom-right', 'lw-window-resizing-top-right', 'lw-window-resizing-top-left', 'lw-window-resizing-bottom-left', 'lw-window-resizing-top', 'lw-window-resizing-bottom', 'lw-window-resizing-left', 'lw-window-resizing-right'); } if (that._snapDummy && that.$.hasClass('lw-window-snapped-' + that._snapDummy._position)) { that.classList.remove('lw-window-snapped-' + that._snapDummy._position); } that.maximized = true; that.$.fireEvent('maximize'); that.style.left = that.style.top = 0; that.style.maxWidth = that.style.maxHeight = 'none'; //NOTE: Resize event must be added in order to always fit the parent. That will hammer the performance. That's why it's not added! //In Safari and EDGE there is a bug. If scrollHeight < clientHeight, scrollHeight is not correct const scrollHeight = that._windowParent.scrollElement.scrollHeight, scrollWidth = that._windowParent.scrollElement.scrollWidth, clientHeight = that._windowParent.element.clientHeight, clientWidth = that._windowParent.element.clientWidth, totalParentHeight = Math.max(scrollHeight, clientHeight), totalParentWidth = Math.max(scrollWidth, clientWidth); if (that.headerPosition === 'top' || that.headerPosition === 'bottom') { that.style.width = scrollWidth > clientWidth ? (totalParentWidth - that._windowParent.borderWidth) + 'px' : '100%'; if (!that.collapsed) { that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%'; } } else { if (!that.collapsed) { that.style.width = scrollWidth > clientWidth ? (totalParentWidth - that._windowParent.borderWidth) + 'px' : '100%'; } that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%'; } if (that.style.height !== '100%') { that.addEventListener('transitionend', transitionHandler); } } /** * Minimizes the window * @param {any} propertyChange */ minimize(propertyChange) { const that = this; if (!propertyChange && that.minimized) { return; } if (that.maximized) { that._preventEventFiring = true; that.restore(); delete that._preventEventFiring; } //Save the size and position of the element before minimizing that._setDragDetails(); that.minimized = true; that.$.fireEvent('minimize'); if (that._snapDummy && that.$.hasClass('lw-window-snapped-' + that._snapDummy._position)) { that.$.removeClass('lw-window-snapped-' + that._snapDummy._position); that.style.right = that.style.top = that.style.left = ''; } const minimizedWindows = that._getAllMinimizedWindows(that._windowParent.element); if (minimizedWindows.length > 0) { const lastWindow = minimizedWindows[minimizedWindows.length - 1]; that.style.left = (lastWindow.offsetLeft + lastWindow.offsetWidth + that._dragDetails.minWidth + 10 > that._windowParent.element.clientWidth ? lastWindow.offsetLeft : lastWindow.offsetLeft + lastWindow.offsetWidth + 5) + 'px'; that.style.top = lastWindow.offsetTop + 'px'; } else { that.style.left = '5px'; //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11! that.style.top = (that._windowParent.element.clientHeight + that._windowParent.scrollElement.scrollTop - that.$.headerSection.offsetHeight - 5) + 'px'; } that.style.width = ''; that.style.height = that.$.headerSection.offsetHeight + 'px'; } /** * Create Element */ _createElement() { this.setAttribute('role', 'dialog'); } /** * Removes an HTML element from the content section. */ removeChild(node) { const that = this; if (!that.isCompleted) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' })); return } that.$.content.removeChild(node); } /** * Unmaximizes the window */ restore(propertyChange) { const that = this; if (propertyChange === 'maximized' || that.maximized) { that.maximized = false; that.style.width = that.style.height = that.style.top = that.style.left = ''; } else if (propertyChange === 'minimized' || that.minimized) { that._restoreFromMinimization(propertyChange); } if (!that._preventEventFiring) { that.$.fireEvent('restore'); } that.style.maxWidth = that.style.maxHeight = ''; if (that._dragDetails) { that.style.left = Math.max(0, Math.min(that._dragDetails.windowX, that._windowParent.element.clientWidth - that._dragDetails.width)) + 'px'; that.style.top = Math.max(0, Math.min(that._dragDetails.windowY, that._windowParent.scrollElement.scrollHeight - that._dragDetails.height)) + 'px'; if (that.collapsed) { if (that.headerPosition === 'top' || that.headerPosition === 'bottom') { that.style.width = that._dragDetails.width + 'px'; } else { that.style.height = that._dragDetails.height + 'px'; } return; } if (that._dragDetails.resized) { that.style.width = that._dragDetails.width + 'px'; that.style.height = that._dragDetails.height + 'px'; } } } /** * Opens the window */ open(propertyChange) { const that = this; if (!propertyChange && !that.$.hasClass('lw-visibility-hidden')) { return; } function focusAfterOpen(event) { if (!that.hasAnimation || event && event.target === that) { that.focus(); that.removeEventListener('transitionend', focusAfterOpen); } } if (that.isCompleted) { const isOpeningEventPrevented = that.$.fireEvent('opening').defaultPrevented; if (isOpeningEventPrevented) { return; } that.$.removeClass('lw-visibility-hidden'); that.opened = true; that.$.fireEvent('open'); } else { that.$.removeClass('lw-visibility-hidden'); that.opened = true; } that.bringToFront(); that._setModal(); that._handleActiveState(); if (!that.hasAnimation) { focusAfterOpen(); } else { that.addEventListener('transitionend', focusAfterOpen); } } /** * Pins the window */ pin() { this.pinned = true; } /** * Unpin the window */ unpin() { this.pinned = false; } /** * Apply the layout template for the header/footer */ _applyLayoutTemplate(selector, template) { const that = this; if (!template) { selector.innerHTML = ''; if (selector === that.$.header && that.label) { selector.innerHTML = that.label; } return; } if (!('content' in document.createElement('template'))) { that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() })); return; } if (!(template instanceof HTMLTemplateElement)) { template = document.getElementById(template); } if (template === null || !('content' in template)) { that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: selector === that.$.footer ? 'footerTemplate' : 'headerTemplate' })); return; } selector.innerHTML = ''; selector.appendChild(document.importNode(template.content, true)); } /** * Cancel the Drag operation * @param {any} event */ _cancelDragging(event) { const that = this; if (that._dragDetails && that._dragDetails.started && that._dragDetails.type === 'drag') { if (!event) { const windowRect = that.getBoundingClientRect(); event = { pageX: windowRect.left, pageY: windowRect.top }; } that.$.fireEvent('dragEnd', { left: event.pageX, top: event.pageY }); that.removeAttribute('dragged'); that._dragDetails.started = false; delete that._mouseManipulation; } } /** * Document focusin event handler. * Called when an element is about to receive focus * @param {any} event */ _documentFocusInEventHandler(event) { const that = this; if (!that._changingFocus) { return; } if (!that.contains(event.target) && !that.contains(event.composedPath()[0])) { that.focus(); } delete that._changingFocus; } /** * Element Down event handler * @param {any} event */ _downHandler(event) { const that = this; let target = LW.Utilities.Core.isMobile ? document.elementFromPoint(event.pageX - window.pageXOffset, event.pageY - window.pageYOffset) : event.originalEvent.target; if (that.shadowRoot || that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; } event.stopPropagation(); //Left mouse click is 1 if (that.disabled || (!LW.Utilities.Core.isMobile && event.which !== 1)) { return; } //AutoHideWindow in a LW.TabsWindow if (that._tabsWindow) { that._tabsWindow._isAutoHideWindowClicked = true; } if (!that.hasAttribute('ontop')) { that.bringToFront(); } if (target.closest && target.closest('.lw-buttons-container') === that.$.buttonsContainer) { that._buttonPressed = target.closest('.lw-button'); if (that._buttonPressed) { return; } } else if (target.getRootNode() && target.getRootNode().host) { that._buttonPressed = target.getRootNode().host; if (that._buttonPressed.closest('.lw-buttons-container') === that.$.buttonsContainer) { return; } } that._isWindowContentClicked = target.closest('.lw-content'); let isInsideLayout = that.closest('lw-docking-layout'); if (that.isInShadowDOM && !isInsideLayout) { let host = that.getRootNode().host; while (host) { isInsideLayout = host.closest('lw-docking-layout'); if (isInsideLayout) { break; } if (!host.getRootNode()) { break; } host = host.getRootNode().host; } } if (that instanceof LW.TabsWindow && isInsideLayout && isInsideLayout.disabled) { return; } that._handleActiveState(); if (that instanceof LW.TabsWindow && isInsideLayout) { if (that.$.hasClass('lw-docking-layout-auto-hide-window')) { //Check if a resize zone is entered on touchstart if (LW.Utilities.Core.isMobile) { that._moveHandler(event); } if (that.resizeMode !== 'none' && that.$.container.className.indexOf('lw-window-resizing') > -1) { that._mouseManipulation = true; that._setDragDetails('resize', event); } } return; } if (target.closest('.lw-header-section') === that.$.headerSection) { if (that._dblClickDetails === undefined) { that._dblClickDetails = { clicks: 0 }; } clearTimeout(that._dblClickDetails.timeOut); that._dblClickDetails.clicks++; that._dblClickDetails.timeOut = setTimeout(function () { if (that._dblClickDetails) { that._dblClickDetails.clicks = 0; } }, 300); if (that._dblClickDetails.clicks === 2) { that._headerDblCickHandler(event); that._dblClickDetails.clicks = 0; return; } } if (that.maximized) { return; } //Check if a resize zone is entered on touchstart if (LW.Utilities.Core.isMobile) { that._moveHandler(event); } if (!that.pinned && !that.minimized && that.$.container.className.indexOf('lw-window-resizing') < 0) { target = target.closest('.lw-header-section'); if (target && target === that.$.headerSection) { that._mouseManipulation = true; that._setDragDetails('drag', event); } } if (that.resizeMode !== 'none' && that.$.container.className.indexOf('lw-window-resizing') > -1) { that._mouseManipulation = true; that._setDragDetails('resize', event); } } /** * Document Move Event Handler * @param {any} event - event details */ _documentMoveHandler(event) { const that = this; if (!that._dragDetails || !that._dragDetails.started || that.minimized || !that._mouseManipulation || (Math.abs(event.pageX - that._dragDetails.x) <= 5 && Math.abs(event.pageY - that._dragDetails.y) <= 5)) { return; } if (!that.hasAttribute('dragged') && !that.hasAttribute('resized')) { that.$.fireEvent(that._dragDetails.type + 'Start', { left: event.pageX, top: event.pageY, width: that.offsetWidth, height: that.offsetHeight }); } event.stopPropagation(); if (that._dragDetails.type === 'drag' && !that.pinned) { that.setAttribute('dragged', ''); if (that._snapDummy && that.$.hasClass('lw-window-snapped-' + that._snapDummy._position)) { that.$.removeClass('lw-window-snapped-' + that._snapDummy._position); that.style.right = that.style.top = that.style.left = ''; if (!that.collapsed) { that.style.height = that._dragDetails.height + 'px'; that.style.width = that._dragDetails.width + 'px'; } } that._drag(event, 'both'); //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11! that._dragDetails.x = Math.max(that._windowParent.offsetLeft + that._dragDetails.offsetX - that._windowParent.scrollElement.scrollLeft, Math.min((that._windowParent.offsetLeft + that._windowParent.element.offsetWidth) - (that._windowParent.element.offsetWidth - that.offsetLeft) + that._dragDetails.offsetX, event.pageX)); that._dragDetails.y = Math.max(that._windowParent.offsetTop + that._dragDetails.offsetY - that._windowParent.scrollElement.scrollTop, Math.min((that._windowParent.offsetTop + that._windowParent.element.offsetHeight) - (that._windowParent.element.offsetHeight - that.offsetTop) + that._dragDetails.offsetY, event.pageY)); //Window snapping logic if (event.pageX >= that._windowParent.offsetLeft + that._windowParent.scrollElement.scrollWidth - 1) { that._handleSnapping('right'); } else if (event.pageY <= that._windowParent.offsetTop) { that._handleSnapping('top'); } else if (event.pageX <= that._windowParent.offsetLeft) { that._handleSnapping('left'); } else { that._handleSnapping(); } } else { that._dragDetails.resized = true; that._resize(that._dragDetails.side, event); //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11! that._dragDetails.x = Math.max(that._windowParent.offsetLeft + that._dragDetails.left, Math.min(that._windowParent.offsetLeft + that._dragDetails.left + (that._dragDetails.side.toLowerCase().indexOf('left') > -1 ? 0 : that._dragDetails.newWidth), event.pageX)); that._dragDetails.y = Math.max(that._windowParent.offsetTop + that._dragDetails.top, Math.min(that._windowParent.offsetTop + that._dragDetails.top + (that._dragDetails.side.toLowerCase().indexOf('top') > -1 ? 0 : that._dragDetails.newHeight), event.pageY)); } } /** * Document Down event handler * @param {any} event - event details */ _documentUpHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if (that.disabled) { that.removeAttribute('active'); delete that._buttonPressed; delete that._isWindowContentClicked; return; } if (that._dragDetails && that._dragDetails.started) { if (that.hasAttribute('resized')) { that.$.fireEvent(that._dragDetails.type + 'End', { left: event.pageX, top: event.pageY, width: that._dragDetails.newWidth, height: that._dragDetails.newHeight }); that.removeAttribute('resized'); that._handleWindowResizeDummy(); that.$.container.classList.remove('lw-window-resizing-bottom-right', 'lw-window-resizing-top-right', 'lw-window-resizing-top-left', 'lw-window-resizing-bottom-left', 'lw-window-resizing-top', 'lw-window-resizing-bottom', 'lw-window-resizing-left', 'lw-window-resizing-right'); } //The only way to stop the transitions when liveResize is false setTimeout(function () { that.$.removeClass('no-transition'); }, 20); if (that.hasAttribute('dragged')) { that.$.fireEvent(that._dragDetails.type + 'End', { left: event.pageX, top: event.pageY }); that.removeAttribute('dragged'); } that._dragDetails.started = false; delete that._mouseManipulation; } if (that._snapDummy && !that._snapDummy.classList.contains('lw-visibility-hidden')) { switch (that._snapDummy._position) { case 'left': case 'top': that.style.left = that.style.top = '0'; that.style.right = 'auto'; break; case 'right': that.style.left = 'auto'; that.style.top = that.style.right = '0'; break; } that.style.width = that._snapDummy._position === 'top' ? '100%' : '50%'; that.style.height = '100%'; that.$.addClass('lw-window-snapped-' + that._snapDummy._position); that._handleSnapping(); } if (that._modal && target === that._modal && !that._isWindowContentClicked) { that.closeOnMaskClick ? that.close() : that.focus(); } if (that._isWindowButton(target)) { that.focus(); } delete that._isWindowContentClicked; delete that._buttonPressed; const activeElement = that.shadowRoot && that._windowParent.element && that._windowParent.element.getRootNode() ? that._windowParent.element.getRootNode().activeElement : document.activeElement; if (!that.hasAttribute('active') || activeElement === that) { return; } if (!target.closest) { return; } let closestWindow = target.closest('.lw-window'); while (closestWindow) { if (closestWindow === that) { break; } closestWindow = closestWindow.parentElement; if (closestWindow) { closestWindow = closestWindow.closest('.lw-window'); } } if (that.opened && closestWindow !== that) { that.removeAttribute('active'); } } /** * Document select start handler. */ _documentSelectStartHandler(event) { const that = this; if (that._dragDetails && that._dragDetails.started) { event.preventDefault(); } } /** * Repositions the window ( Dragging operation ) */ _drag(event, direction) { const that = this; if (!event || that.pinned || that.maximized) { return; } let distanceX, distanceY; if (!that._dragDetails || !that._dragDetails.started) { that._setDragDetails('drag', event); } //Disables animatied movement that.$.addClass('no-transition'); if (typeof (event) === 'object') { distanceX = event.pageX - that._dragDetails.x; distanceY = event.pageY - that._dragDetails.y; } else { distanceX = distanceY = event; } //Safari, EDGE have a different with the height of the viewport depending on the elemnets on the page const totalParentHeight = Math.max(that._windowParent.element.clientHeight, that._windowParent.scrollElement.scrollHeight), totalParentWidth = Math.max(that._windowParent.element.clientWidth, that._windowParent.scrollElement.scrollWidth); switch (direction) { case 'horizontal': that._dragDetails.windowX = Math.max(0, Math.min(that._dragDetails.windowX + distanceX, totalParentWidth - that.offsetWidth)); that.style.left = that._dragDetails.windowX + 'px'; break; case 'vertical': that._dragDetails.windowY = Math.max(0, Math.min(that._dragDetails.windowY + distanceY, totalParentHeight - that.offsetHeight)); that.style.top = that._dragDetails.windowY + 'px'; break; case 'both': that._dragDetails.windowX = Math.max(0, Math.min(that._dragDetails.windowX + distanceX, totalParentWidth - that.offsetWidth)); that._dragDetails.windowY = Math.max(0, Math.min(that._dragDetails.windowY + distanceY, totalParentHeight - that.offsetHeight)); that.style.left = that._dragDetails.windowX + 'px'; that.style.top = that._dragDetails.windowY + 'px'; break; } that._dragDetails.top = that.offsetTop; that._dragDetails.left = that.offsetLeft; } /** * DragStarted Event Handler * @param {any} event */ _dragStartHandler(event) { const that = this; if (that._dragDetails && that._dragDetails.started) { event.preventDefault(); } } /** * Element's focus/blue event handler * @param {any} event */ _focusHandler(event) { const that = this; if (event.type === 'focus') { that.setAttribute('focus', ''); that.bringToFront(); } else if (!that._buttonPressed) { that.removeAttribute('focus'); if (that._dragDetails && that._dragDetails.started) { that._handleWindowResizeDummy(); } } } /** * Retrieves all curently minimized windows in an array. * @param {any} container */ _getAllMinimizedWindows(container) { const that = this; let minimizedWindows = []; if (!container) { container = that._windowParent.element; } const windowElements = container.querySelectorAll('lw-window'); for (let i = 0; i < windowElements.length; i++) { if (windowElements[i] !== that && windowElements[i].hasAttribute('minimized')) { minimizedWindows.push(windowElements[i]); } } minimizedWindows.sort(function (a, b) { let aRect = a.getBoundingClientRect(), bRect = b.getBoundingClientRect(); return aRect.right - bRect.right; }); return minimizedWindows; } /** * Handles the snapping of the window to the viewport. Adds a dummy that will determine the snapping behavior. * @param {any} position */ _handleSnapping(position) { const that = this; function transitionEndHandler() { if (that._snapDummy.classList.contains('lw-visibility-hidden') && that._snapDummy.parentElement) { that._snapDummy.parentElement.removeChild(that._snapDummy); } } if (!position) { if (that._snapDummy && that._snapDummy.parentElement) { that._snapDummy.classList.add('lw-visibility-hidden'); } return; } if (that.disableSnap || that.collapsed) { return; } if (!that._snapDummy) { that._snapDummy = document.createElement('div'); that._snapDummy.addEventListener('transitionend', transitionEndHandler); } that._snapDummy.className = 'lw-window-snap-' + position + '-feedback'; that._snapDummy._position = position; if (!that._snapDummy.parentElement) { that._windowParent.element.appendChild(that._snapDummy); } } /** * Window header double click handler. */ _headerDblCickHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; if ((target !== that.$.headerSection && target !== that.$.header) || (that.$.maximizeButton && that.$.maximizeButton.offsetHeight === 0)) { return; } that.maximized ? that.restore() : that.maximize(); } /** * Element Up event handler * @param {any} event - event details */ _isWindowButton(target) { const that = this; while (target) { let relatedTarget = target.closest && target.closest('.lw-buttons-container'); if (relatedTarget === that.$.buttonsContainer) { break; } target = target.getRootNode().host; } if (!target) { return; } const customButtonRegex = /lw-(\w+[-]*\w*)-button/ig; target = target.closest('.lw-button'); if (!target || target !== that._buttonPressed) { return; } switch (target) { case that.$.closeButton: that.close(); return true; case that.$.collapseButton: that.collapsed ? that.expand() : that.collapse(); return true; case that.$.maximizeButton: that.maximized ? that.restore() : that.maximize(); return true; case that.$.minimizeButton: that.minimized ? that.restore() : that.minimize(); return true; case that.$.pinButton: that.pinned ? that.unpin() : that.pin(); return true; default: //Custom Header Button if (!(customButtonRegex.test(target.className))) { return; } that.$.fireEvent(LW.Utilities.Core.toCamelCase(target.className.match(customButtonRegex).toString().replace('lw-', '').replace('-button', '')), { button: target }); return true; } } /** * Key Down event handler * @param {any} event - event details */ _keyDownHandler(event) { const that = this; delete that._changingFocus; if (that.disabled || ((that.hasAttribute('dragged') || that.hasAttribute('resized')) && that._mouseManipulation)) { return; } event.stopPropagation(); //Distance hardcoded to 10px const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10, activeElement = that.enableShadowDOM && that._windowParent.element.getRootNode() ? that._windowParent.element.getRootNode().activeElement : document.activeElement; switch (event.key) { case 'ArrowUp': case 'ArrowDown': case 'ArrowLeft': case 'ArrowRight': { if (that.minimized || activeElement !== that) { return; } let direction = event.key.indexOf('Right') > -1 || event.key.indexOf('Left') > -1; event.preventDefault(); const isInsideLayout = (that.isInShadowDOM ? that.getRootNode().host : that).closest('lw-docking-layout'); if (!direction && event.altKey && !(that instanceof LW.TabsWindow && isInsideLayout)) { event.key === 'ArrowUp' ? that.maximize() : that.restore(); return; } if (that.maximized) { return; } //that.style.transition = ''; that.$.addClass('no-transition'); if (event.ctrlKey && that.resizeMode !== 'none' && !that.collapsed) { if (['horizontal', 'vertical', 'both'].indexOf(that.resizeMode) === -1) { direction = that.resizeMode; } else { direction = direction ? 'right' : 'bottom'; } if (that.hasAttribute('dragged')) { that._cancelDragging(event); } if (!that.hasAttribute('resized')) { that.$.fireEvent('resizeStart', { 'position': { x: event.pageX, y: event.pageY } }); } that._resize(direction, distance); return; } if (!that.pinned) { if (!that.hasAttribute('dragged')) { that.setAttribute('dragged', ''); that.$.fireEvent('dragStart', { left: event.pageX, top: event.pageY }); } that._drag(distance, direction ? 'horizontal' : 'vertical'); } //that.style.transition = ''; that.$.removeClass('no-transition'); break; } case 'Escape': if (that.headerButtons.indexOf('close') > -1 && activeElement === that) { that.close(); } break; case 'p': if (event.altKey && that.headerButtons.indexOf('pin') > -1) { that.pinned ? that.unpin() : that.pin(); } break; case 'c': if (event.altKey && that.headerButtons.indexOf('collapse') > -1) { that.collapsed ? that.expand() : that.collapse(); } break; case 'm': if (event.altKey && that.headerButtons.indexOf('minimize') > -1) { that.minimized ? that.restore() : that.minimize(); } break; case 'Tab': if (that.opened && that.modal) { that._changingFocus = true; } break; case 'Enter': case ' ': { let target; if (that.shadowRoot || that.isInShadowDOM) { target = event.composedPath()[0]; that._buttonPressed = target.getRootNode().host; } else { target = event.target.closest && event.target.closest('.lw-button'); that._buttonPressed = target; } if (!target) { return; } that._isWindowButton(target); delete that._buttonPressed; break; } } } /** * KeyUp Event Handler */ _keyUpHandler(event) { const that = this; if (!event.key) { return; } if (event.key === 'Control' && that._dragDetails && that.hasAttribute('resized') && !that._mouseManipulation) { if (!that._dragDetails.started) { return; } if (that._dragDetails.type !== 'drag') { that.removeAttribute('resized'); that.$.fireEvent('resizeEnd', { left: event.pageX, top: event.pageY, width: that._dragDetails.newWidth, height: that._dragDetails.newHeight }); that._handleWindowResizeDummy(); } that._dragDetails.started = false; } if (event.key.indexOf('Arrow') > -1 && that.hasAttribute('dragged') && !that._mouseManipulation) { that._cancelDragging(event); } } /** * Document Mouse Wheel event */ _mouseWheelHandler(event) { const that = this; if (that.disabled || !(that._dragDetails && that._dragDetails.started)) { return; } //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11! if (event.deltaY < 0 && that._windowParent.scrollElement.scrollTop + event.deltaY <= 0) { that.style.top = Math.max(0, that._dragDetails.windowY) + 'px'; return; } if (event.deltaY > 0 && (that._dragDetails.windowY + that.offsetHeight + event.deltaY >= that._windowParent.scrollElement.scrollHeight || that._windowParent.scrollElement.scrollTop + that._windowParent.element.clientHeight === that._windowParent.scrollElement.scrollHeight)) { return; } if (that._dragDetails.type === 'drag') { that._dragDetails.windowY += event.deltaY; that.style.top = that._dragDetails.windowY + 'px'; } else { that._dragDetails.height += event.deltaY; that.style.height = that._dragDetails.height + 'px'; } } /** * Element's Mouse Move handler' */ _moveHandler(event) { const that = this; if (that.disabled || that.collapsed || that.maximized || that.minimized) { return; } //iOS Safari fix for dragging (prevents window scrolling) if (LW.Utilities.Core.isMobile && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform) && that.hasAttribute('dragged')) { event.originalEvent.preventDefault(); } if (that._mouseManipulation) { return; } if (that.$.container.className.indexOf('lw-window-resizing') > -1) { that.$.container.classList.remove('lw-window-resizing-bottom-right', 'lw-window-resizing-top-right', 'lw-window-resizing-top-left', 'lw-window-resizing-bottom-left', 'lw-window-resizing-top', 'lw-window-resizing-bottom', 'lw-window-resizing-left', 'lw-window-resizing-right'); } //Set resizing cursor if (that.resizeMode !== 'none') { const windowCoordinates = that.getBoundingClientRect(), isNearTop = event.clientY < windowCoordinates.top + 10 ? true : false, isNearBottom = event.clientY > windowCoordinates.bottom - 10 ? true : false, isNearRight = event.clientX > windowCoordinates.right - 10 ? true : false, isNearLeft = event.clientX < windowCoordinates.left + 10 ? true : false; switch (that.resizeMode) { case 'none': break; case 'both': if (that.resizeIndicator) { if (isNearBottom && isNearRight) { that.$.container.classList.add('lw-window-resizing-bottom-right'); } return; } if (isNearLeft || isNearRight) { if (isNearTop) { that.$.container.classList.add('lw-window-resizing-top-' + (isNearLeft ? 'left' : 'right')); return; } else if (isNearBottom) { that.$.container.classList.add('lw-window-resizing-bottom-' + (isNearLeft ? 'left' : 'right')); return; } that.$.container.classList.add('lw-window-resizing-' + (isNearLeft ? 'left' : 'right')); return; } if (isNearTop || isNearBottom) { if (isNearRight) { that.$.container.classList.add('lw-window-resizing-' + (isNearTop ? 'top-right' : 'bottom-right')); return; } else if (isNearLeft) { that.$.container.classList.add('lw-window-resizing-' + (isNearTop ? 'top-left' : 'bottom-left')); return; } that.$.container.classList.add('lw-window-resizing-' + (isNearTop ? 'top' : 'bottom')); } break; case 'horizontal': if (that.resizeIndicator) { if (isNearBottom && isNearRight) { that.$.container.classList.add('lw-window-resizing-right'); } return; } if (isNearLeft) { that.$.container.classList.add('lw-window-resizing-left'); return; } if (isNearRight) { that.$.container.classList.add('lw-window-resizing-right'); } break; case 'vertical': if (that.resizeIndicator) { if (isNearBottom && isNearRight) { that.$.container.classList.add('lw-window-resizing-bottom'); } return; } if (isNearTop) { that.$.container.classList.add('lw-window-resizing-top'); return; } if (isNearBottom) { that.$.container.classList.add('lw-window-resizing-bottom'); } break; case 'top': if (isNearTop) { if (that.resizeIndicator && !isNearLeft) { return; } that.$.container.classList.add('lw-window-resizing-top'); } break; case 'bottom': if (isNearBottom) { if (that.resizeIndicator && !isNearRight) { return; } that.$.container.classList.add('lw-window-resizing-bottom'); } break; case 'left': if (isNearLeft) { if (that.resizeIndicator && !isNearTop) { return; } that.$.container.classList.add('lw-window-resizing-left'); } break; case 'right': if (isNearRight) { if (that.resizeIndicator && !isNearBottom) { return; } that.$.container.classList.add('lw-window-resizing-right'); } break; } } } /** * Handles the active state of the Window */ _handleActiveState() { const that = this; //Remove the active state of all windows on page const allWindowsOnPage = document.querySelectorAll('.lw-window'); for (let w = 0; w < allWindowsOnPage.length; w++) { if (!allWindowsOnPage[w].contains(that) && !that.contains(allWindowsOnPage[w])) { allWindowsOnPage[w].removeAttribute('active'); allWindowsOnPage[w].removeAttribute('focus'); } } that.setAttribute('active', ''); } /** * Creates a resize dummy that's used during resizing ( if liveResize is off ). */ _handleWindowResizeDummy() { const that = this; if (!that._resizeDummy) { that._resizeDummy = document.createElement('div'); that._resizeDummy.classList.add('lw-window-resize-feedback'); } if (!that.hasAttribute('resized')) { if (that._resizeDummy) { that._resizeDummy.remove(); } if (!that.liveResize && that._dragDetails.type === 'resize' && that._dragDetails.started) { that.style.top = that._dragDetails.top + 'px'; that.style.left = that._dragDetails.left + 'px'; that.style.width = that._dragDetails.newWidth + 'px'; that.style.height = that._dragDetails.newHeight + 'px'; } return; } if (that._resizeDummy.parentElement || that._resizeDummy.getRootNode().host) { return; } that._resizeDummy.style.width = that.offsetWidth + 'px'; that._resizeDummy.style.height = that.offsetHeight + 'px'; that._resizeDummy.style.top = that.offsetTop + 'px'; that._resizeDummy.style.left = that.offsetLeft + 'px'; that._windowParent.element.appendChild(that._resizeDummy); } /** * * @param {any} side - the side from which the dragging occurs * @param {any} event - mouse pointer event */ _resize(side, event) { const that = this; let size; if (!that._dragDetails || (that._dragDetails && that._dragDetails.type === 'drag')) { that._setDragDetails('resize'); } if (!that._dragDetails) { return; } that._dragDetails.started = true; if (!that.hasAttribute('resized')) { that.setAttribute('resized', ''); //Disables animatied movement //that.style.transition = 'none'; if (that.hasAnimation) { that.$.addClass('no-transition'); } } if (!that.liveResize) { that._handleWindowResizeDummy(); } const width = that._snapDummy && that.$.hasClass('lw-window-snapped-' + that._snapDummy._position) ? 'snapWindowWidth' : 'width'; //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11! switch (side) { case 'left': { size = typeof (event) === 'object' ? event.pageX - that._dragDetails.x : event; if (size > 0) { size = Math.min(size, that._dragDetails[width] - that._dragDetails.minWidth); } else { size = Math.min(that._dragDetails.maxWidth ? that._dragDetails.maxWidth - that._dragDetails[width] : that._dragDetails.left, Math.abs(size)) * -1; } that._dragDetails[width] = Math.min(that._dragDetails[width] + that._dragDetails.left - that._windowParent.scrollElement.scrollLeft, that._dragDetails[width] - size); that._dragDetails.windowX = Math.max(that._windowParent.scrollElement.scrollLeft, that._dragDetails.windowX + size); if (typeof (event) !== 'object') { that._dragDetails[width] = Math.max(that._dragDetails[width], that._dragDetails.minWidth); } if (that._dragDetails[width] >= that._dragDetails.minWidth) { that._dragDetails.left = that._dragDetails.windowX; that._dragDetails.newWidth = that._dragDetails[width]; } break; } case 'right': { const borderWidth = that._windowParent.element.clientWidth !== that._windowParent.element.offsetWidth ? that._windowParent.borderWidth : 0, width = that._snapDummy && that.$.hasClass('lw-window-snapped-' + that._snapDummy._position) ? 'snapWindowWidth' : 'width'; size = typeof (event) === 'object' ? event.pageX - that._dragDetails.x : event; if (size > 0 && that._dragDetails.maxWidth) { size = Math.min(that._dragDetails.maxWidth - that._dragDetails[width], size); } that._dragDetails[width] = Math.min(that._windowParent.element.clientWidth + that._windowParent.scrollElement.scrollLeft - that._dragDetails.left - borderWidth, Math.max(0, that._dragDetails[width] + size)); if (typeof (event) !== 'object') { that._dragDetails[width] = Math.max(that._dragDetails[width], that._dragDetails.minWidth); } that._dragDetails.left = that.offsetLeft; that._dragDetails.newWidth = Math.max(that._dragDetails.minWidth, that._dragDetails[width]); break; } case 'top': if (that._snapDummy && that.$.hasClass('lw-window-snapped-' + that._snapDummy._position)) { that._dragDetails.height = that._dragDetails.snapWindowHeight; } size = typeof (event) === 'object' ? event.pageY - that._dragDetails.y : event; if (size > 0) { size = Math.min(size, that._dragDetails.height - that._dragDetails.minHeight); } else { size = Math.min(that._dragDetails.maxHeight ? that._dragDetails.maxHeight - that._dragDetails.height : that._dragDetails.top, Math.abs(size)) * -1; } that._dragDetails.snapWindowHeight = that._dragDetails.height = Math.min(that._dragDetails.height + that._dragDetails.top - that._windowParent.scrollElement.scrollTop, that._dragDetails.height - size); that._dragDetails.windowY = Math.max(that._windowParent.scrollElement.scrollTop, that._dragDetails.windowY + size); if (typeof (event) !== 'object') { that._dragDetails.snapWindowHeight = that._dragDetails.height = Math.max(that._dragDetails.height, that._dragDetails.minHeight); } if (that._dragDetails.height >= that._dragDetails.minHeight) { that._dragDetails.top = that._dragDetails.windowY; that._dragDetails.newHeight = that._dragDetails.height; } that._dragDetails.newWidth = Math.max(that._dragDetails[width], that._dragDetails.newWidth); break; case 'bottom': if (that._snapDummy && that.$.hasClass('lw-window-snapped-' + that._snapDummy._position)) { that._dragDetails.height = that._dragDetails.snapWindowHeight; } size = typeof (event) === 'object' ? event.pageY - that._dragDetails.y : event; if (size > 0 && that._dragDetails.maxHeight) { size = Math.min(that._dragDetails.maxHeight - that._dragDetails.height, size); } that._dragDetails.snapWindowHeight = that._dragDetails.height = Math.min(that._windowParent.element.clientHeight + that._windowParent.scrollElement.scrollTop - that._dragDetails.top - that._windowParent.borderWidth, Math.max(0, that._dragDetails.height + size)); if (typeof (event) !== 'object') { that._dragDetails.snapWindowHeight = that._dragDetails.height = Math.max(that._dragDetails.height, that._dragDetails.minHeight); } that._dragDetails.newHeight = Math.max(that._dragDetails.minHeight, that._dragDetails.height); that._dragDetails.newWidth = Math.max(that._dragDetails[width], that._dragDetails.newWidth); break; case 'bottomLeftCorner': that._resize('bottom', event); that._resize('left', event); break; case 'bottomRightCorner': that._resize('bottom', event); that._resize('right', event); break; case 'topLeftCorner': that._resize('top', event); that._resize('left', event); break; case 'topRightCorner': that._resize('top', event); that._resize('right', event); break; } const resizeTarget = that.liveResize ? that : that._resizeDummy; that._dragDetails.newHeight = Math.max(that._dragDetails.snapWindowHeight, that._dragDetails.newHeight); resizeTarget.style.top = that._dragDetails.top + 'px'; resizeTarget.style.left = that._dragDetails.left + 'px'; resizeTarget.style.width = that._dragDetails.newWidth + 'px'; resizeTarget.style.height = that._dragDetails.newHeight + 'px'; } /** * Restore the window from minimization */ _restoreFromMinimization() { const that = this; that.minimized = false; that.style.width = that.style.height = that.style.top = that.style.left = ''; //Re-arrange the rest of the minimized windows that._refreshMinimizedWindowsPosition(); } /** * Recalculates the position of the minimized windows on the page */ _refreshMinimizedWindowsPosition() { const that = this; const minimizedWindows = that._getAllMinimizedWindows(); if (minimizedWindows.length === 0) { return; } //Some offset from the edge of the window minimizedWindows[0].style.left = '5px'; let lastWindow; //Using style.left instead of offsetLeft to ignore the transiton of the animation if enabled for (let i = 1; i < minimizedWindows.length; i++) { if (parseFloat(minimizedWindows[i - 1].style.left) + minimizedWindows[i - 1].offsetWidth + minimizedWindows[i].offsetWidth + 10 < that._windowParent.element.clientWidth) { minimizedWindows[i].style.left = (parseFloat(minimizedWindows[i - 1].style.left) + minimizedWindows[i - 1].offsetWidth + 5) + 'px'; minimizedWindows[i].style.top = minimizedWindows[i - 1].offsetTop + 'px'; lastWindow = minimizedWindows[i]; } else { minimizedWindows[i].style.left = parseFloat(lastWindow.style.left) + 'px'; minimizedWindows[i].style.top = lastWindow.offsetTop + 'px'; } } } /** * Set the visibility of the Header Buttons */ _setHeaderButtons() { const that = this, buttons = that.headerButtons, currentButtons = that.$.buttonsContainer.children, isAlreadyCreated = function (name) { const button = that.$.buttonsContainer.getElementsByClassName('lw-' + (name + '').split(/(?=[A-Z])/).join('-').toLowerCase() + '-button')[0]; if (button) { button.classList.remove('lw-hidden'); } return button; }; for (let b = 0; b < currentButtons.length; b++) { currentButtons[b].classList.add('lw-hidden'); } //Create a new custom header button if (buttons.length > 0) { for (let i = 0; i < buttons.length; i++) { let button = isAlreadyCreated(buttons[i]); if (!button) { const buttonName = (buttons[i] + '').split(/(?=[A-Z])/); button = document.createElement('button'); button.setAttribute('aria-label', buttonName.map(name => name.slice(0, 1).toUpperCase() + name.slice(1)).join(' ')); button.classList.add('lw-' + buttonName.join('-').toLowerCase() + '-button', 'lw-button', 'lw-element'); } that.$.buttonsContainer.insertBefore(button, that.$.buttonsContainer.firstElementChild); } } } /** * Creates the Drag details for window dragging and resizing * @param {any} type - type of event * @param {any} event - event details (optional) */ _setDragDetails(type, event) { const that = this; if (!that._dragDetails) { that._dragDetails = {}; } if (that._dragDetails.minWidth === undefined || that._dragDetails.minHeight === undefined || that._dragDetails.maxWidth === undefined || that._dragDetails.maxHeight === undefined) { const computedStyle = getComputedStyle(that); that._dragDetails.minWidth = parseFloat(computedStyle.getPropertyValue('min-width')) || 0; that._dragDetails.minHeight = parseFloat(computedStyle.getPropertyValue('min-height')) || 0; that._dragDetails.maxWidth = parseFloat(computedStyle.getPropertyValue('max-width')) || 0; that._dragDetails.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height')) || 0; } that._dragDetails.windowX = that.offsetLeft; that._dragDetails.windowY = that.offsetTop; const elementStyle = that.getBoundingClientRect(); if (!that._snapDummy || !that.$.hasClass('lw-window-snapped-' + that._snapDummy._position)) { // Left/Top of the direct parent of the element. const parentStyle = that.parentElement === document.body ? document.documentElement.getBoundingClientRect() : (that.parentElement ? that.parentElement.getBoundingClientRect() : document.documentElement.getBoundingClientRect()); const scrollX = window.scrollX || window.pageXOffset, scrollY = window.scrollY || window.pageYOffset; that._windowParent.offsetLeft = parentStyle.left + scrollX; that._windowParent.offsetTop = parentStyle.top + scrollY; if (event && typeof event === 'object') { that._dragDetails.offsetX = event.clientX - elementStyle.left; that._dragDetails.offsetY = event.clientY - elementStyle.top; } if (!that.collapsed) { if (that.hasAnimation && type === 'minimize') { that._dragDetails.width = that._dragDetails.width ? that._dragDetails.width : that.offsetWidth; that._dragDetails.height = that._dragDetails.height ? that._dragDetails.height : that.offsetHeight; } else { that._dragDetails.width = that.offsetWidth; that._dragDetails.height = that.offsetHeight; } if (that.style.width || that.style.height) { that._dragDetails.resized = true; } } } else if (that.headerPosition === 'right' && that.collapsed) { that._dragDetails.offsetX = elementStyle.left + that.offsetWidth - event.clientX; } if (type === 'minimize' || !type) { return; } that._dragDetails.type = type; that._dragDetails.started = true; that._dragDetails.snapWindowWidth = that.offsetWidth; that._dragDetails.snapWindowHeight = that.offsetHeight; if (event && typeof (event) === 'object') { that._dragDetails.x = event.pageX; that._dragDetails.y = event.pageY; } else { that._dragDetails.x = that.offsetLeft; that._dragDetails.y = that.offsetTop; } if (type === 'resize') { if (that.resizeMode === 'none') { delete that._dragDetails; return; } that._dragDetails.top = that.offsetTop; that._dragDetails.left = that.offsetLeft; that._dragDetails.newWidth = that._dragDetails.width; that._dragDetails.newHeight = that._dragDetails.height; if (that.$container.hasClass('lw-window-resizing-right')) { that._dragDetails.side = 'right'; } else if (that.$container.hasClass('lw-window-resizing-left')) { that._dragDetails.side = 'left'; } else if (that.$container.hasClass('lw-window-resizing-top')) { that._dragDetails.side = 'top'; } else if (that.$container.hasClass('lw-window-resizing-bottom')) { that._dragDetails.side = 'bottom'; } else if (that.$container.hasClass('lw-window-resizing-top-left')) { that._dragDetails.side = 'topLeftCorner'; } else if (that.$container.hasClass('lw-window-resizing-bottom-left')) { that._dragDetails.side = 'bottomLeftCorner'; } else if (that.$container.hasClass('lw-window-resizing-top-right')) { that._dragDetails.side = 'topRightCorner'; } else if (that.$container.hasClass('lw-window-resizing-bottom-right')) { that._dragDetails.side = 'bottomRightCorner'; } } } /** * Set the window parent. */ _setElementParent(id) { const that = this; that._windowParent.element = undefined; if (that._windowParent.parent && !that._windowParent.parent.querySelectorAll('lw-window, lw-dialog-window, lw-progress-window, lw-wait-window, ' + 'lw-alert-window, lw-prompt-window, lw-multiline-prompt-window')) { that._windowParent.parent.style.position = ''; } if (id instanceof HTMLElement) { that._windowParent.element = id; } else if (typeof (id) === 'string') { that._windowParent.element = id === 'body' ? that.getShadowRootOrBody() : document.getElementById(id); } if (!that._windowParent.element) { if (that._windowParent.initialParent) { that._windowParent.element = that._windowParent.initialParent.parentElement ? that._windowParent.initialParent : that.getShadowRootOrBody(); } else { that._windowParent.element = that.getShadowRootOrBody(); } } if (that.parentElement !== that._windowParent.element) { that._windowParent.element.appendChild(that); } if (that._windowParent.element === that.getShadowRootOrBody()) { that._windowParent.element = document.documentElement; that._windowParent.scrollElement = document.scrollingElement; //Neccessary because EDGE and Safari have a bug that._windowParent.parent = that.getShadowRootOrBody(); that._windowParent.borderWidth = 0; } else { //Used in some rare cases where ShadowDOM is enabled and the parent is a Window that is not completed yet if (that.parentElement instanceof LW.Window && !that.parentElement.isCompleted) { that.parentElement.whenRendered(function () { that.parentElement.appendChild(that); that._setElementParent(that.windowParent) }); return; } //Specific case for lwWindow nesting if (that._windowParent.element instanceof LW.Window) { that._windowParent.element = that._windowParent.element.$.content; } const computedStyle = getComputedStyle(that.parentElement), windowParentPosition = computedStyle.getPropertyValue('position'); that._windowParent.borderWidth = 2 * parseInt(computedStyle.getPropertyValue('border-width') || 0); that._windowParent.parent = that.parentElement; that._windowParent.scrollElement = that._windowParent.element; if (windowParentPosition === 'static') { that.parentElement.style.position = 'relative'; } } that._setModal(); if (that.style.left && that.offsetLeft > that._windowParent.scrollElement.scrollWidth) { that.style.left = that._windowParent.scrollElement.scrollWidth - that.offsetWidth + 'px'; } if (that.style.top && that.offsetTop > that._windowParent.scrollElement.scrollHeight) { that.style.top = that._windowParent.scrollElement.scrollHeight - that.offsetHeight + 'px'; } } /** * Enable/Disable modal mode */ _setModal() { const that = this; delete that._changingFocus; if (!that._windowParent.element) { return; } if (!that.modal) { if (that._modal && that._modal.parentElement) { that._modal.parentElement.removeChild(that._modal); delete that._modal; } return; } if (!that._modal) { that._modal = document.createElement('div'); that._modal.classList.add('lw-modal'); } if (that._windowParent.parent !== document.body) { that._modal.setAttribute('nested-modal', ''); } else { that._modal.removeAttribute('nested-modal'); } that._modal._window = that; if (that.opened && !that._modal.parentElement) { const zIndex = parseInt(getComputedStyle(that).getPropertyValue('z-index')); if (!isNaN(zIndex)) { that._modal.style.zIndex = zIndex - 1; } that.parentElement.insertBefore(that._modal, that); } else if (that._modal.parentElement) { that._modal.parentElement.removeChild(that._modal); } } }); /** * lwDialogWindow */ LW('lw-dialog-window', class DialogWindow extends LW.Window { /** * Element's properties */ static get properties() { return { 'cancelLabel': { value: 'Cancel', type: 'string' }, 'confirmLabel': { value: 'Ok', type: 'string' }, 'disableSnap': { value: true, readOnly: true, type: 'boolean' }, 'headerButtons': { value: ['close'], type: 'array' }, 'modal': { value: true, readOnly: true, type: 'boolean', defaultReflectToAttribute: true } } } /** * Element's event listeners. */ static get listeners() { return { 'footer.click': '_footerClickHandler' } } /** * Element's HTML template. */ template() { return `<div role="presentation"> <div class="lw-content-container" id="container"> <div id="headerSection" class="lw-header-section" role="heading" aria-level="1"> <div id="header" class="lw-header">[[label]]</div> <div id="buttonsContainer" class="lw-buttons-container"> <button id="pinButton" class="lw-pin-button" aria-label="Pin"></button> <button id="collapseButton" class="lw-button lw-element lw-collapse-button" aria-label="Collapse"></button> <button id="minimizeButton" class="lw-button lw-element lw-minimize-button" aria-label="Minimize"></button> <button id="maximizeButton" class="lw-button lw-element lw-maximize-button" aria-label="Maximize"></button> <button id="closeButton" class="lw-button lw-element lw-close-button" aria-label="Close"></button> </div> </div> <div class="lw-content"> <content></content> </div> <div id="footer" class="lw-footer"> <button id="confirmButton" class="lw-button lw-element lw-confirm-button">[[confirmLabel]]</button> <button id="cancelButton" class="lw-button lw-element lw-cancel-button">[[cancelLabel]]</button> </div> </div> </div>`; } /** * Create Element */ _createElement() { const that = this; that.setAttribute('role', 'alertdialog'); that.setAttribute('aria-describedby', that.$.content.id); } /** * Footer Click Event Handler * @param {any} event */ _footerClickHandler(event) { const that = this, target = event.target; if (target.closest('.lw-confirm-button')) { that.$.fireEvent('confirm'); } else if (target.closest('.lw-cancel-button')) { that.$.fireEvent('cancel'); } } /** * Key Down event handler * @param {any} event - event details */ _keyDownHandler(event) { const that = this; delete that._changingFocus; if (that.disabled || ((that.hasAttribute('dragged') || that.hasAttribute('resized')) && that._mouseManipulation)) { return; } event.stopPropagation(); //Distance hardcoded to 10px const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10, activeElement = that.enableShadowDOM && that._windowParent.element.getRootNode() ? that._windowParent.element.getRootNode().activeElement : document.activeElement; switch (event.key) { case 'ArrowUp': case 'ArrowDown': case 'ArrowLeft': case 'ArrowRight': { if (that.minimized || activeElement !== that) { return; } const direction = event.key.indexOf('Right') > -1 || event.key.indexOf('Left') > -1; event.preventDefault(); if (!direction && event.altKey) { event.key === 'ArrowUp' ? that.maximize() : that.restore(); return; } that.$.addClass('no-transition'); if (that.maximized) { return; } if (event.ctrlKey && that.resizeMode !== 'none') { if (that.hasAttribute('dragged')) { that._cancelDragging(event); } if (!that.hasAttribute('resized')) { that.$.fireEvent('resizeStart', { 'position': { x: event.pageX, y: event.pageY } }); } that._resize(direction ? 'right' : 'bottom', distance); return; } if (!that.pinned) { if (!that.hasAttribute('dragged')) { that.setAttribute('dragged', ''); that.$.fireEvent('dragStart', { left: event.pageX, top: event.pageY }); } that._drag(distance, direction ? 'horizontal' : 'vertical'); } //that.style.transition = ''; that.$.removeClass('no-transition'); break; } case 'Escape': if (that.headerButtons.indexOf('close') > -1 && activeElement === that) { that.close(); } break; case 'Tab': if (that.opened && that.modal) { that._changingFocus = true; } break; case 'Enter': case ' ': { let target; if (that.shadowRoot || that.isInShadowDOM) { target = event.composedPath()[0]; that._buttonPressed = target.getRootNode().host; } else { target = event.target.closest && event.target.closest('.lw-button'); that._buttonPressed = target; } if (!target) { return; } that._isWindowButton(target); delete that._buttonPressed; break; } } } }); LW('lw-alert-window', class AlertWindow extends LW.DialogWindow { /** * Element's properties */ static get properties() { return { 'headerButtons': { value: [], type: 'array' } } } /** * Create Element */ _createElement() { const that = this; that.setAttribute('role', 'alertdialog'); that.setAttribute('aria-describedby', that.$.content.id); } }); LW('lw-prompt-window', class PromptWindow extends LW.DialogWindow { /** * Element's properties */ static get properties() { return { 'autoComplete': { allowedValues: ['none', 'manual', 'auto', 'inline'], type: 'string', value: 'manual' }, 'confirmLabel': { value: 'Ok', type: 'string' }, 'cancelLabel': { value: 'Cancel', type: 'string' }, 'disableSnap': { value: true, readOnly: true, type: 'boolean' }, 'displayMode': { value: 'default', allowedValues: ['default', 'escaped'], type: 'string' }, 'headerButtons': { value: ['close'], type: 'array' }, 'form': { value: '', type: 'string' }, 'hint': { value: null, type: 'any?' }, 'maxLength': { value: null, type: 'number?' }, 'minLength': { value: 2, type: 'number' }, 'messages': { extend: true, value: { 'en': { 'missingReference': '{{elementType}}: Missing reference to {{files}}.' } }, type: 'object' }, 'modal': { value: true, readOnly: true, type: 'boolean', defaultReflectToAttribute: true }, 'name': { value: '', type: 'string' }, 'placeholder': { value: '', type: 'string' }, 'promptLabel': { value: '', type: 'string?' }, 'required': { value: false, type: 'boolean' }, 'requiredMessage': { value: '', type: 'string' }, 'selectAllOnFocus': { value: false, type: 'boolean' }, 'value': { value: '', type: 'string' } } } /** * Element's HTML template. */ template() { return `<div role="presentation"> <div class="lw-content-container" id="container"> <div id="headerSection" class="lw-header-section" role="heading" aria-level="1"> <div id="header" class="lw-header">[[label]]</div> <div id="buttonsContainer" class="lw-buttons-container"> <button id="closeButton" class="lw-button lw-element lw-close-button" aria-label="Close"></button> </div> </div> <div class="lw-content"> <content></content> <lw-text-box id="textBox" animation="[[animation]]" auto-complete="[[autoComplete]]" max-length="[[maxLength]]" value="{{value}}" form="[[form]]" label="[[promptLabel]]" hint="[[hint]]" display-mode="[[displayMode]]" max-length="[[maxLength]]" placeholder="[[placeholder]]" required="[[required]]" required-message="[[requiredMessage]]" select-all-on-focus="[[selectAllOnFocus]]" theme="[[theme]]" right-to-left="[[rightToLeft]]"> </lw-text-box> </div> <div id="footer" class="lw-footer"> <button id="confirmButton" class="lw-button lw-element lw-confirm-button flat">[[confirmLabel]]</button> <button id="cancelButton" class="lw-button lw-element lw-cancel-button flat">[[cancelLabel]]</button> </div> </div> </div>`; } /** * Element's event listeners. */ static get listeners() { return { 'footer.click': '_footerClickHandler' } } /** * Checks for missing modules. */ static get requires() { return { 'LW.TextBox': 'lw.textbox.js' } } /** * Footer Click Event Handler * @param {any} event */ _footerClickHandler(event) { const that = this, target = event.target; if (target.closest('.lw-confirm-button')) { that.$.fireEvent('confirm', { value: that.$.textBox.value }); } else if (target.closest('.lw-cancel-button')) { that.$.fireEvent('cancel', { value: that.$.textBox.value }); } } /** * Key Down event handler * @param {any} event - event details */ _keyDownHandler(event) { const that = this; delete that._changingFocus; function endDrag() { if (that._dragDetails) { that._dragDetails.started = false; } that.$.removeClass('no-transition'); } if (that.disabled || (that._dragDetails && that._dragDetails.started)) { return; } event.stopPropagation(); //Distance hardcoded to 10px const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10, activeElement = that.enableShadowDOM && that._windowParent.element.getRootNode() ? that._windowParent.element.getRootNode().activeElement : document.activeElement //that.style.transition = ''; that.$.removeClass('no-transition'); switch (event.key) { case 'ArrowUp': case 'ArrowDown': if (activeElement !== that) { return; } event.preventDefault(); if (event.altKey) { event.key === 'ArrowUp' ? that.maximize() : that.restore(); endDrag(); return; } that.$.addClass('no-transition'); if (event.ctrlKey) { that._resize('bottom', distance); endDrag(); return; } that._drag(distance, 'vertical'); break; case 'ArrowLeft': case 'ArrowRight': if (activeElement !== that) { return; } event.preventDefault(); that.$.addClass('no-transition'); if (event.ctrlKey) { that._resize('right', distance); endDrag(); return; } that._drag(distance, 'horizontal'); that.$.removeClass('no-transition'); break; case 'Escape': if (that.headerButtons.indexOf('close') > -1 && activeElement === that) that.close(); break; case 'Tab': if (that.opened && that.modal) { that._changingFocus = true; } break; case 'Enter': case ' ': { let target; if (that.shadowRoot || that.isInShadowDOM) { target = event.composedPath()[0]; that._buttonPressed = target.getRootNode().host; } else { target = event.target.closest && event.target.closest('.lw-button'); that._buttonPressed = target; } if (!target) { return; } that._isWindowButton(target); delete that._buttonPressed; break; } } endDrag(); } }); LW('lw-multiline-prompt-window', class MultiLinePromptWindow extends LW.PromptWindow { /** * Element's properties */ static get properties() { return { 'autoCapitalize': { value: 'none', allowedValues: ['none', 'words', 'characters'], type: 'string' }, 'autoExpand': { value: false, type: 'boolean' }, 'headerButtons': { value: ['close'], type: 'array' }, 'horizontalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] }, 'modal': { value: true, readOnly: true, type: 'boolean', defaultReflectToAttribute: true }, 'selectionDirection': { value: 'none', allowedValues: ['forward', 'backward', 'none'], type: 'string' }, 'selectionEnd': { value: 0, reflectToAttribute: false, type: 'number' }, 'selectionStart': { value: 0, reflectToAttribute: false, type: 'number' }, 'spellCheck': { value: false, type: 'boolean' }, 'verticalScrollBarVisibility': { type: 'string', value: 'auto', allowedValues: ['auto', 'disabled', 'hidden', 'visible'] }, 'wrap': { value: 'soft', allowedValues: ['hard', 'soft', 'off'], type: 'string' } } } /** * Element's HTML template. */ template() { return `<div role="presentation"> <div class="lw-content-container" id="container"> <div id="headerSection" class="lw-header-section" role="heading" aria-level="1"> <div id="header" class="lw-header">[[label]]</div> <div id="buttonsContainer" class="lw-buttons-container"> <button id="closeButton" class="lw-button lw-element lw-close-button" aria-label="Close"></button> </div> </div> <div class="lw-content"> <content></content> <lw-multiline-text-box id="textBox" animation="[[animation]]" horizontal-scroll-bar-visibility= "[[horizontalScrollBarVisibility]]" vertical-scroll-bar-visibility= "[[verticalScrollBarVisibility]]" auto-capitalize="[[autoCapitalize]]" auto-expand = "[[autoExpand]]" selection-direction= "[[selectionDirection]]" selection-end= "[[selectionEnd]]" selection-start="[[selectionStart]]" spell-check= "[[spellCheck]]" wrap="[[wrap]]" max-length="[[maxLength]]" value="{{value}}" form="[[form]]" label="[[promptLabel]]" hint="[[hint]]" display-mode="[[displayMode]]" max-length="[[maxLength]]" placeholder="[[placeholder]]" required="[[required]]" required-message="[[requiredMessage]]" select-all-on-focus="[[selectAllOnFocus]]" theme="[[theme]]" right-to-left="[[rightToLeft]]"> </lw-multiline-text-box> </div> <div id="footer" class="lw-footer"> <button id="confirmButton" class="lw-button lw-element lw-confirm-button flat">[[confirmLabel]]</button> <button id="cancelButton" class="lw-button lw-element lw-cancel-button flat">[[cancelLabel]]</button> </div> </div> </div>`; } /** * Element's event listeners. */ static get listeners() { return { 'footer.click': '_footerClickHandler' } } /** * Checks for missing modules. */ static get requires() { return { 'LW.MultilineTextBox': 'lw.multilinetextbox.js' } } /** * Footer Click Event Handler * @param {any} event */ _footerClickHandler(event) { const that = this, target = event.target; if (target.closest('.lw-confirm-button')) { that.$.fireEvent('confirm', { value: that.$.textBox.value }); } else if (target.closest('.lw-cancel-button')) { that.$.fireEvent('cancel', { value: that.$.textBox.value }); } } }); LW('lw-progress-window', class ProgressWindow extends LW.Window { /** * Element's properties */ static get properties() { return { 'completeLabel': { value: 'Continue', type: 'string' }, 'disableSnap': { value: true, readOnly: true, type: 'boolean' }, 'headerButtons': { value: ['close'], type: 'array' }, 'indeterminate': { value: false, type: 'boolean' }, 'inverted': { value: false, type: 'boolean' }, 'formatFunction': { value: null, type: 'function' }, 'max': { value: 100, type: 'number' }, 'modal': { value: true, readOnly: true, type: 'boolean', defaultReflectToAttribute: true }, 'min': { value: 0, type: 'number' }, 'showProgressValue': { value: false, type: 'boolean' }, 'value': { value: 0, type: 'number?' } } } /** * Element's HTML template. */ template() { return `<div role="presentation"> <div class="lw-content-container" id="container"> <div id="headerSection" class="lw-header-section" role="heading" aria-level="1"> <div id="header" class="lw-header">[[label]]</div> <div id="buttonsContainer" class="lw-buttons-container"> <button id="closeButton" class="lw-button lw-element lw-close-button" aria-label="Close"></button> </div> </div> <div class="lw-content" inner-h-t-m-l="[[innerHTML]]"> <content></content> </div> <div id="footer" class="lw-footer"> <lw-progress-bar id="progressBar" animation="[[animation]]" min="[[min]]" max="[[max]]" indeterminate="[[inditerminate]]" inverted="[[inverted]]" format-function="[[formatFunction]]" show-progress-value="[[showProgressValue]]" theme="[[theme]]" right-to-left="[[rightToLeft]]" value="{{value}}"> </lw-progress-bar> <button id="completeButton" class="lw-button lw-element lw-complete-button lw-visibility-hidden">[[completeLabel]]</button> </div> </div> </div>`; } /** Checks for missing modules. */ static get requires() { return { 'LW.ProgressBar': 'lw.progressbar.js' } } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; switch (propertyName) { case 'value': that._handleCompletion(); break; default: super.propertyChangedHandler(propertyName, oldValue, newValue); break; } } /** * Create Element method */ _createElement() { const that = this; that.setAttribute('role', 'dialog'); that._handleCompletion(); } /** * Show the complete button when value === max */ _handleCompletion() { const that = this; if (that.$.completeButton) { if (that.value >= that.max) { that.$completeButton.removeClass('lw-visibility-hidden'); that.$progressBar.addClass('lw-visibility-hidden'); } else { that.$completeButton.addClass('lw-visibility-hidden'); that.$progressBar.removeClass('lw-visibility-hidden'); } } } /** * Key Down event handler * @param {any} event - event details */ _keyDownHandler(event) { const that = this; delete that._changingFocus; function endDrag() { if (that._dragDetails) { that._dragDetails.started = false; } that.$.removeClass('no-transition'); } if (that.disabled || (that._dragDetails && that._dragDetails.started)) { return; } event.stopPropagation(); //Distance hardcoded to 10px const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10, activeElement = that.enableShadowDOM && that._windowParent.element.getRootNode() ? that._windowParent.element.getRootNode().activeElement : document.activeElement; //that.style.transition = ''; that.$.removeClass('no-transition'); switch (event.key) { case 'ArrowUp': case 'ArrowDown': if (activeElement !== that) { return; } event.preventDefault(); if (event.altKey) { event.key === 'ArrowUp' ? that.maximize() : that.restore(); endDrag() return; } that.$.addClass('no-transition'); if (event.ctrlKey) { that._resize('bottom', distance); endDrag() return; } that._drag(distance, 'vertical'); that.$.removeClass('no-transition'); break; case 'ArrowLeft': case 'ArrowRight': if (activeElement !== that) { return; } event.preventDefault(); that.$.addClass('no-transition'); if (event.ctrlKey) { that._resize('right', distance); endDrag() return; } that._drag(distance, 'horizontal'); that.$.removeClass('no-transition'); break; case 'Escape': if (that.headerButtons.indexOf('close') > -1 && activeElement === that) { that.close(); } break; case 'Tab': if (that.opened && that.modal) { that._changingFocus = true; } break; case 'Enter': case ' ': { let target; if (that.shadowRoot || that.isInShadowDOM) { target = event.composedPath()[0]; that._buttonPressed = target.getRootNode().host; } else { target = event.target.closest && event.target.closest('.lw-button'); that._buttonPressed = target; } if (!target) { return; } that._isWindowButton(target); delete that._buttonPressed; break; } } endDrag() } }); LW('lw-tabs-window', class TabsWindow extends LW.Window { /** * Element's properties */ static get properties() { return { 'disableSnap': { value: true, readOnly: true, type: 'boolean' }, //Property used by DockingLayouts only 'dropPosition': { //allowedValues: ['all', 'top', 'left', 'right', 'bottom', 'center', 'header', 'none'], value: ['all'], type: 'array' }, 'addNewTab': { value: false, type: 'boolean' }, 'allowToggle': { value: false, type: 'boolean' }, 'autoHide': { value: false, type: 'boolean' }, 'autoHideWindow': { value: null, type: 'any' }, 'dataSource': { value: null, type: 'array?', reflectToAttribute: false }, 'tabCloseButtonMode': { value: 'default', allowedValues: ['default', 'selected'], type: 'string' }, 'tabCloseButtons': { value: false, type: 'boolean' }, 'messages': { value: { 'en': { 'ambiguousIndexes': 'lw-tabs: Initially set lw-tab-item indexes are ambiguous and are ignored in favour of the HTML structure.', 'detailsObjectRequired': 'lw-tabs: The method "insert" requires a details Object to be passed as a second argument.', 'invalidIndex': 'lw-tabs: "{{method}}" method accepts an index of type number.', 'referenceNodeNotChild': 'lw-tabs: Passed {{argument}} is not part of this lw-tabs element.', 'tabItemRequired': 'lw-tabs: The method "{{method}}" requires a "lw-tab-item" element to be passed as an argument.' } }, type: 'object', extend: true }, 'tabOverflow': { value: 'auto', allowedValues: ['auto', 'hidden', 'scroll'], type: 'string' }, 'tabReorder': { value: false, type: 'boolean' }, 'tabResize': { value: false, type: 'boolean' }, 'tabScrollButtonsPosition': { value: 'both', allowedValues: ['near', 'far', 'both'], type: 'string' }, 'selectedIndex': { value: null, type: 'number?' }, 'selectionMode': { value: 'click', allowedValues: ['click', 'dblclick', 'mouseenter', 'none'], type: 'string' }, 'collapsed': { value: false, type: 'boolean' }, 'collapsible': { value: false, type: 'boolean' }, 'locked': { value: false, type: 'boolean' }, 'max': { value: '', type: 'any' }, 'min': { value: '', type: 'any' }, 'size': { value: '', type: 'any' }, 'tabLayout': { value: 'scroll', allowedValues: ['scroll', 'dropdown', 'wrap', 'shrink'], type: 'string', defaultReflectToAttribute: true }, 'tabPosition': { value: 'top', allowedValues: ['top', 'bottom', 'left', 'right', 'hidden'], type: 'string' }, 'tabTextOrientation': { value: 'horizontal', allowedValues: ['horizontal', 'vertical'], type: 'string' }, //Property used by DockingLayouts only 'layout': { value: null, type: 'any' } } } /** * Element's event listeners. */ static get listeners() { return { 'tabsElement.blur': '_tabsFocusHandler', 'tabsElement.change': '_tabsChangeHandler', 'tabsElement.focus': '_tabsFocusHandler', 'autoHideWindow.close': '_autoHideWindowCloseHandler', 'autoHideWindow.open': '_autoHideWindowOpenHandler' } } /** * Element's HTML template. */ template() { return `<div role="presentation"> <div class="lw-content-container" id="container"> <div id="headerSection" class="lw-header-section" role="heading" aria-level="1"> <div id="header" class="lw-header">[[label]]</div> <div id="buttonsContainer" class="lw-buttons-container"> <button id="minimizeButton" class="lw-button lw-element lw-minimize-button" aria-label="Minimize"></button> <button id="maximizeButton" class="lw-button lw-element lw-maximize-button" aria-label="Maximize"></button> <button id="closeButton" class="lw-button lw-element lw-close-button" aria-label="Close"></button> </div> </div> <div id="contentSection" class="lw-content"> <lw-tabs id="tabsElement" animation="[[animation]]" add-new-tab="[[addNewTab]]" allow-toggle="[[allowToggle]]" close-button-mode="[[tabCloseButtonMode]]" close-buttons="[[tabCloseButtons]]" disabled="[[disabled]]" overflow="[[tabOverflow]]" reorder="[[tabReorder]]" resize="[[tabResize]]" scroll-buttons-position="[[tabScrollButtonsPosition]]" selected-index="{{selectedIndex}}" selection-mode="[[selectionMode]]" tab-layout="[[tabLayout]]" tab-position="[[tabPosition]]" tab-text-orientation="[[tabTextOrientation]]" theme="[[theme]]" right-to-left="[[rightToLeft]]"> <content></content> </lw-tabs> </div> <div id="footer" class="lw-footer lw-hidden"></div> </div> </div>`; } /** * Checks for missing modules. */ static get requires() { return { 'LW.Tabs': 'lw.tabs.js' } } /** * Appens a Tab item to the Window * @param {any} node */ appendChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' })); return } if (!(node instanceof LW.TabItem)) { that.error(that.localize('tabItemRequired', { method: 'removeChild' })); } that.$.tabsElement.appendChild(node); } /** * Insert Tab items into the Window * @param {any} index * @param {any} details */ insert(index, details) { this.$.tabsElement.insert(index, details); } /** * Insert a Tab item before another item inside the Window * @param {any} node */ insertBefore(node, referenceNode) { this.$.tabsElement.insertBefore(node, referenceNode); } /** * Removes a Tab item from the Window */ removeAt(index) { this.$.tabsElement.removeAt(index); } /** * Removes a Tab item from the Window * @param {any} node */ removeChild(node) { const that = this; if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('lw-resize-trigger-container')) { const args = Array.prototype.slice.call(arguments, 2); return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments))); } if (!node) { that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' })); return } if (!(node instanceof LW.TabItem)) { that.error(that.localize('tabItemRequired', { method: 'removeChild' })); } if (!(that.shadowRoot || that).contains(node)) { that.error(that.localize('referenceNodeNotChild', { argument: 'node' })); } that.$.tabsElement.removeChild(node); } /** * Refreshes the Header Section of the Tabs element inside the Window */ refreshTabHeader() { const that = this; if (that.$.tabsElement && that.$.tabsElement.isCompleted) { that.$.tabsElement.refreshTabHeader(); } } /** * Refreshes the Tabs element/ Tabs resize/styleChanged handler */ refreshTabs() { const that = this; if (that.$.tabsElement && that.$.tabsElement.isCompleted) { that.$.tabsElement._applyTabOverflow(); } } /** * Selects a Tab item inside the Window * @param {any} index */ select(index) { this.$.tabsElement.select(index); } /** * Update Tab Item element method * @param {any} index * @param {any} label * @param {any} content */ update(index, label, content) { this.$.tabsElement.update(index, label, content); } /** * Returns all tab items */ get items() { const that = this; if (!that.isCompleted || !that.$.tabsElement) { return; } return this.$.tabsElement._tabs; } /** * Returns all tab labels */ get itemLabels() { const that = this; if (!that.$) { return; } return this.$.tabsElement._tabLabelContainers; } /** * Returns a list of all sibling TabsWindow components IF the element is docked inside a DockingLaoyut */ get siblings() { const that = this; let siblings = []; if (!that.isCompleted) { return siblings; } const closestSplitter = that.closest('lw-splitter'); if (!closestSplitter || !closestSplitter.closest('lw-docking-layout')) { return siblings; } const items = closestSplitter._items; if (!items || !items.length) { return siblings; } for (let s = 0; s < items.length; s++) { const item = items[s]; if (item !== that.closest('lw-splitter-item')) { const siblingItem = item.querySelector('lw-tabs-window'); if (siblingItem.closest('lw-splitter') === closestSplitter) { siblings.push(item.querySelector('lw-tabs-window')); } } } return siblings; } /** * Updates the element when a property is changed. * @param {string} propertyName The name of the property. * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String. * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String. */ propertyChangedHandler(propertyName, oldValue, newValue) { const that = this; if (propertyName !== 'collapsed') { super.propertyChangedHandler(propertyName, oldValue, newValue); } switch (propertyName) { case 'theme': if (oldValue !== '') { that.$.closeButton.classList.remove(oldValue); that.$.collapseButton.classList.remove(oldValue); that.$.maximizeButton.classList.remove(oldValue); that.$.pinButton.classList.remove(oldValue); } that._applyTheme(newValue); break; case 'autoHideWindow': that._handleAutoHideWindow(); break; case 'autoHide': if (!newValue) { //Delete the additionaly added cached property if (that.$.tabsElement.selectedIndex !== null) { that.$.tabsElement._tabs[that.$.tabsElement.selectedIndex]._autoHideWindowSize = undefined; } if (that._autoHideWindow) { that._autoHideWindow.close(); } } break; case 'dataSource': that.$.tabsElement.dataSource = newValue; break; case 'layout': that._handleLayoutProperty(); break; case 'collapsible': case 'collapsed': case 'locked': case 'max': case 'min': case 'size': { const parent = (that.isInShadowDOM ? that.getRootNode().host : that); const isInsideLayout = parent.closest('lw-docking-layout'), splitterItemParent = that.closest('lw-splitter-item'); if (!isInsideLayout) { if (propertyName === 'collapsed') { super.propertyChangedHandler(propertyName, oldValue, newValue); } return; } if (splitterItemParent) { splitterItemParent[propertyName] = newValue; } break; } } } /** * Apply theme to internal custom elements */ _applyTheme(theme) { const that = this; if (theme !== '') { const headerButtons = that.$.buttonsContainer.children; for (let i = 0; i < headerButtons.length; i++) { headerButtons[i].classList.add(theme); } } } /** * AutoHideContainer Close event handler */ _autoHideWindowCloseHandler() { const that = this; if (that.allowToggle && that.$.tabsElement.selectedIndex !== null) { that.$.tabsElement.select(that.$.tabsElement.selectedIndex); } if (that._autoHideWindow) { that._moveContent(that._autoHideWindow.items[0], that._autoHideWindow._tab); } } /** * AutoHideContainer Open event handler * @param {any} event */ _autoHideWindowOpenHandler() { const that = this; if (that.$.tabsElement.selectedIndex) { that._handleAutoHide(that.$.tabsElement.selectedIndex); } } /** * Create method called on ready stage **/ _createElement() { const that = this; that.setAttribute('role', 'dialog'); if (that.$.tabsElement.$.tabHeaderControls && !that.$.tabsElement.$.tabHeaderControls.innerHTML) { that.$.tabsElement.$tabHeaderControls.addClass('lw-hidden'); } that.$.tabsElement.dataSource = that.dataSource; that._applyTheme(that.theme); that._handleAutoHideWindow(); if (that.autoHide) { that._handleAutoHide(that.$.tabsElement.selectedIndex); } //Two-way binding possible issue. The Tabs element has selectedIndex but TabsWindow element has null //This leads to setting the attribute 'selectedIndex' of the Tabs element to null even tho //It's actual value is not null if (!that.allowToggle && !that.selectedIndex && that.$.tabsElement.selectedIndex !== null) { that.selectedIndex = that.$.tabsElement.selectedIndex; that.$.tabsElement.setAttribute('selected-index', that.selectedIndex); } that._handleLayoutProperty(); const isInsideLayout = (that.isInShadowDOM ? that.getRootNode().host : that || that).closest('lw-docking-layout'), splitterItemParent = that.closest('lw-splitter-item'); if (isInsideLayout && splitterItemParent) { splitterItemParent.collapsible = that.collapsible; splitterItemParent.collapsed = that.collapsed; splitterItemParent.min = that.min; splitterItemParent.max = that.max; splitterItemParent.size = that.size; splitterItemParent.locked = that.locked; } } attached() { super.attached(); const that = this; that.classList.add('lw-window'); if (that.shadowRoot) { that.$.root.classList.add('lw-window'); } } /** * Hnadle layout property */ _handleLayoutProperty() { const that = this; let ownerLayout = that.closest('lw-docking-layout'); if (!LW.DockingLayout) { return; } if (!that.ownerLayout && that.getRootNode()) { let host = that.getRootNode().host; while (host) { if (!host.closest) { return; } if (host.closest('lw-docking-layout')) { ownerLayout = host.closest('lw-docking-layout'); break; } host = host.getRootNode() ? host.getRootNode().host : undefined; } } if (ownerLayout) { that.layout = ownerLayout; return; } if (that.layout instanceof LW.DockingLayout) { return; } if (typeof that.layout === 'string') { that.layout = document.getElementById(that.layout); } } /** * Window header double click handler. */ _headerDblCickHandler(event) { const that = this, target = that.shadowRoot || that.isInShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target; //NOTE: DoubleCLick + ctrlKey is used in DockingLayout if (event.ctrlKey || (target !== that.$.headerSection && target !== that.$.header) || (that.$.maximizeButton && that.$.maximizeButton.offsetHeight === 0)) { return; } that.maximized ? that.restore() : that.maximize(); } /** * Document Down event handler * @param {any} event - event details */ _documentUpHandler(event) { const that = this; let target = event.originalEvent.target.closest ? event.originalEvent.target.closest('.lw-window') : event.originalEvent.target, isClickInside = target === that || target === that._autoHideWindow || that._isAutoHideWindowClicked, isInsideLayout = that.closest('lw-docking-layout'); if (that.shadowRoot || that.isInShadowDOM) { target = event.originalEvent.composedPath()[0]; isClickInside = target.getRootNode() === that.shadowRoot || target.closest('.lw-window') === that || target.closest('.lw-window') === that._autoHideWindow || that._isAutoHideWindowClicked; } isInsideLayout = ((that.isInShadowDOM ? that.getRootNode().host : that) || that).closest('lw-docking-layout'); if (isInsideLayout && isInsideLayout.disabled) { delete that._isWindowContentClicked; return; } super._documentUpHandler(event); delete that._isAutoHideWindowClicked; if (!that.autoHide || !that._autoHideWindow) { return; } if (!isClickInside || !that._autoHideWindow.opened) { that.selectedIndex = null; if (that._autoHideWindow.parentElement && that._autoHideWindow.parentElement.closest('.lw-window') === that) { that._autoHideWindow.close(); } } } /** * Handles the positioning and content of the auto hide container */ _handleAutoHide(index) { const that = this; if (!that.autoHide || index === null) { return; } if (!that._autoHideWindow) { that._handleAutoHideWindow(true); } if (!that._autoHideWindow) { return; } if (that._autoHideWindow._tabsWindow && that._autoHideWindow._tabsWindow !== that) { that._autoHideWindow._tabsWindow.selectedIndex = null; } const targetTab = that.$.tabsElement._tabs[index]; if (that._autoHideWindow._tab !== targetTab) { that._moveContent(that._autoHideWindow.items[0], that._autoHideWindow._tab); } that._autoHideWindow.label = targetTab.label; that._autoHideWindow.draggable = targetTab.draggable; that._autoHideWindow.floatable = targetTab.floatable; that._autoHideWindow._tab = targetTab; that._moveContent(that._autoHideWindow._tab, that._autoHideWindow.items[0]); that._autoHideWindow.bringToFront(); that._setAutoHideWindowSize(index); that._autoHideWindow.open(); that._autoHideWindow._tabsWindow = that; if (that._autoHideWindow.controlledBy) { that._autoHideWindow.controlledBy.removeAttribute('aria-controls'); } that._autoHideWindow.controlledBy = that.$.tabsElement._tabLabelContainers[index]; that._autoHideWindow.controlledBy.setAttribute('aria-controls', that._autoHideWindow.id); } /** * Sets the cursor on element move event * @param {any} event */ _moveHandler(event) { const that = this, isInsideLayout = that.closest('lw-docking-layout'); if (isInsideLayout) { const layoutItems = isInsideLayout.items; if (layoutItems.indexOf(that) > -1) { return; } } //iOS Safari fix for dragging (prevents window scrolling) if (LW.Utilities.Core.isMobile && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform) && that.layout instanceof LW.DockingLayout && that.layout.hasAttribute('dragged')) { event.originalEvent.preventDefault(); } super._moveHandler(event); } /** * Calculates the width/height/top/left of the autoHideWindow * @param {any} selectedIndex - the selectedIndex of the tabs inside the TabsWindow */ _setAutoHideWindowSize(selectedIndex) { const that = this; if (!that._autoHideWindow) { return; } that._autoHideWindow.$.addClass('no-transition'); that._autoHideWindow.style.maxWidth = that._autoHideWindow.style.maxHeight = ''; const targetTab = that.$.tabsElement._tabs[selectedIndex], autoHideWindowParent = (that._autoHideWindow.isInShadowDOM ? that._autoHideWindow.getRootNode().host : that._autoHideWindow).closest('lw-docking-layout') || that._autoHideWindow.parentElement; let windowParentRect, tabsRect; if (!targetTab) { return; } if (that.tabPosition === 'top' || that.tabPosition === 'bottom') { that._autoHideWindow.resizeMode = that.tabPosition === 'top' ? 'bottom' : 'top'; that._autoHideWindow.style.width = that.$.tabsElement.offsetWidth + 'px'; windowParentRect = autoHideWindowParent.getBoundingClientRect(); tabsRect = that.$.tabsElement.getBoundingClientRect(); let height = targetTab._autoHideWindowSize ? parseFloat(targetTab._autoHideWindowSize) || '' : ''; if (LW.DockingLayout && autoHideWindowParent instanceof LW.DockingLayout) { if (height) { height = Math.min(autoHideWindowParent.$.itemsContainer.offsetHeight, height) + 'px'; } that._autoHideWindow.style.maxHeight = autoHideWindowParent.$.itemsContainer.offsetHeight + 'px'; } that._autoHideWindow.style.height = height; that._autoHideWindow.style.left = (tabsRect.left - windowParentRect.left) + 'px'; if (that._autoHideWindow) { if (that.tabPosition === 'top') { that._autoHideWindow.style.top = (tabsRect.top + -windowParentRect.top + tabsRect.height) + 'px'; } else { that._autoHideWindow.style.top = (tabsRect.top - windowParentRect.top - that._autoHideWindow.offsetHeight) + 'px'; } } } else { that._autoHideWindow.resizeMode = that.tabPosition === 'left' ? 'right' : 'left'; that._autoHideWindow.style.height = that.$.tabsElement.offsetHeight + 'px'; let width = targetTab._autoHideWindowSize ? parseFloat(targetTab._autoHideWindowSize) || '' : ''; if (autoHideWindowParent instanceof LW.DockingLayout) { if (width) { width = Math.min(autoHideWindowParent.$.itemsContainer.offsetWidth, width) + 'px'; } that._autoHideWindow.style.maxWidth = autoHideWindowParent.$.itemsContainer.offsetWidth + 'px'; } that._autoHideWindow.style.width = width; windowParentRect = autoHideWindowParent.getBoundingClientRect(); tabsRect = that.$.tabsElement.getBoundingClientRect(); that._autoHideWindow.style.top = (tabsRect.top - windowParentRect.top) + 'px'; if (that.tabPosition === 'left') { that._autoHideWindow.style.left = (tabsRect.left - windowParentRect.left + that.$.tabsElement.offsetWidth) + 'px'; } else { that._autoHideWindow.style.left = (tabsRect.left - windowParentRect.left - that._autoHideWindow.offsetWidth) + 'px'; } } //Causing the maxWidth/maxHeight to be recalculated if (that._autoHideWindow._dragDetails) { that._autoHideWindow._dragDetails.maxWidth = undefined; } //Make sure the new dimensions are set that._autoHideWindow._setDragDetails('resize'); that._autoHideWindow._dragDetails.started = false; that._autoHideWindow.$.removeClass('no-transition'); } /** * Handles the autoHideWindow instance when 'autoHide' property is enabled */ _handleAutoHideWindow(createWindow) { const that = this; if (that.autoHideWindow) { if (that._autoHideWindow) { that._autoHideWindow.parentElement.removeChild(that._autoHideWindow); } if (typeof (that.autoHideWindow) === 'string') { that._autoHideWindow = document.getElementById(that.autoHideWindow); return; } else if (that.autoHideWindow instanceof LW.Window) { that._autoHideWindow = that.autoHideWindow; return; } } if (!createWindow || that._autoHideWindow || (that.$.contentSection.children.length === 2 && that.$.contentSection.children[1] instanceof LW.Window)) { return; } //Create the autoHideWindow const autoHideWindow = document.createElement('lw-window'); autoHideWindow.$ = LW.Utilities.Extend(autoHideWindow); autoHideWindow.disableSnap = autoHideWindow.pinned = true; autoHideWindow.headerButtons = ['close']; that.$.contentSection.appendChild(autoHideWindow); that._autoHideWindow = autoHideWindow; } /** * Moves the content from one element to another. Used for the autoHideWindow * @param {any} from - Source element * @param {any} to - target element */ _moveContent(from, to) { if (!from || !to) { return; } const contentNodes = [].slice.call(from.$.content.childNodes); for (let i = 0; i < contentNodes.length; i++) { to.appendChild(contentNodes[i]); } } /** * lwtabs element change event handler * @param {any} event */ _tabsChangeHandler(event) { const that = this; if (event.target !== that.$.tabsElement || !that.autoHide) { return; } if (!that._autoHideWindow) { that._handleAutoHideWindow(true); } if (event.detail.oldIndex !== null && that._autoHideWindow.opened) { const previousTabItem = that.$.tabsElement._tabs[event.detail.oldIndex]; previousTabItem._autoHideWindowSize = that._autoHideWindow.style[that.$.tabsElement.tabPosition === 'right' || that.$.tabsElement.tabPosition === 'left' ? 'width' : 'height']; } if (!that.autoHide || event.detail.index === null || event.detail.index === undefined) { that._autoHideWindow.setAttribute('active', ''); that._autoHideWindow.close(); return; } that._handleAutoHide(event.detail.index); } /** * Tabs element focus/blur event handler */ _tabsFocusHandler(event) { const that = this; if (event.type === 'focus') { that.bringToFront(); that.setAttribute('focus', ''); } else { that.removeAttribute('focus'); } } }); LW('lw-wait-window', class WaitWindow extends LW.ProgressWindow { /** * Element's properties */ static get properties() { return { 'headerButtons': { value: [], type: 'array' }, 'disableSnap': { value: true, readOnly: true, type: 'boolean' }, 'modal': { value: true, readOnly: true, type: 'boolean', defaultReflectToAttribute: true }, 'pinned': { value: true, type: 'boolean', readOnly: true } } } /** * Element's HTML template. */ template() { return `<div role="presentation"> <div class="lw-content-container" id="container"> <div id="headerSection" class="lw-header-section" role="heading" aria-level="1"> <div id="header" class="lw-header">[[label]]</div> <div id="buttonsContainer" class="lw-buttons-container"> <button id="closeButton" class="lw-button lw-element lw-close-button" aria-label="Close"></button> </div> </div> <div class="lw-content"> <content></content> <lw-progress-bar id="progressBar" animation="[[animation]]" indeterminate theme="[[theme]]" right-to-left="[[rightToLeft]]"></lw-progress-bar> </div> <div id="footer" class="lw-footer"></div> </div> </div>`; } /** * Key Down event handler * @param {any} event - event details */ _keyDownHandler(event) { const that = this; delete that._changingFocus; function endDrag() { if (that._dragDetails) { that._dragDetails.started = false; } that.$.removeClass('no-transition'); } if (that.disabled || (that._dragDetails && that._dragDetails.started)) { return; } const activeElement = that.shadowRoot || that._windowParent.element.getRootNode() ? that._windowParent.element.getRootNode().activeElement : document.activeElement; event.stopPropagation(); //Distance hardcoded to 10px const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10; //that.style.transition = ''; that.$.removeClass('no-transition'); switch (event.key) { case 'ArrowUp': case 'ArrowDown': if (activeElement !== that) { return; } event.preventDefault(); if (event.altKey) { event.key === 'ArrowUp' ? that.maximize() : that.restore(); endDrag() return; } that.$.addClass('no-transition'); if (event.ctrlKey) { that._resize('bottom', distance); endDrag() return; } that._drag(distance, 'vertical'); break; case 'ArrowLeft': case 'ArrowRight': if (activeElement !== that) { return; } event.preventDefault(); that.$.addClass('no-transition'); if (event.ctrlKey) { that._resize('right', distance); endDrag() return; } that._drag(distance, 'horizontal'); break; case 'Tab': if (that.opened && that.modal) { that._changingFocus = true; } break; case 'Enter': case ' ': { let target; if (that.shadowRoot || that.isInShadowDOM) { target = event.composedPath()[0]; that._buttonPressed = target.getRootNode().host; } else { target = event.target.closest && event.target.closest('.lw-button'); that._buttonPressed = target; } if (!target) { return; } that._isWindowButton(target); delete that._buttonPressed; break; } } endDrag() } });
